<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Clion搭建Gtest单元测试框架</title>
    <url>/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Clion搭建Gtest单元测试框架"><a href="#Clion搭建Gtest单元测试框架" class="headerlink" title="Clion搭建Gtest单元测试框架"></a>Clion搭建Gtest单元测试框架</h1><h2 id="1-下载GTest源码"><a href="#1-下载GTest源码" class="headerlink" title="1 下载GTest源码"></a>1 下载GTest源码</h2><div class="code-wrapper"><pre><code class="hljs shell">git clone https://github.com/google/googletest.git</code></pre></div>

<p>下载下来的google gtest源码目录结构如下，里面包含了很多东西，这里我们只是想利用gtest对自己的代码进行单元测试，因此只需要关注红框所求的文件夹即可，其他的暂时不需要关注</p>
<p><img src="/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/570699-20190715005207916-173277913.png" alt="img"></p>
<h2 id="2-导入-Gtest"><a href="#2-导入-Gtest" class="headerlink" title="2 导入 Gtest"></a>2 导入 Gtest</h2><p>使用CLion新建一下C++项目，把gtest引入到项目中，将上面googletest目录放在external下面了，这个目录随意，看个人喜好了。</p>
<p><img src="/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/image-20210525000900512.png" alt="image-20210525000900512"></p>
<h2 id="3-配置-CMakeList-txt"><a href="#3-配置-CMakeList-txt" class="headerlink" title="3 配置 CMakeList.txt"></a>3 配置 CMakeList.txt</h2><ul>
<li>设置<strong>GOOGLETEST_VERSION</strong>变量，这个变量，其实是在googletest-master目录下的CMakeLists.txt中设置的，在googlegtest目录下的CMakeLists.txt中使用，如果我们不在项目的CMaksLists.txt中设置这个变量，则gtest的编译会失败，这点非常重要。</li>
<li>添加googletest目录到项目中，这个很简单。</li>
<li>添加target link，这个示例中，我新了一个demotest.cpp，里面用来放置单元测试用例相关的代码，将其编译为二进制可执行文件，来对正式项目代码进行测试，因为它依赖于gtest_main，因此这里必须把它们link起来，否则，test_main的编译会失败。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.17</span>)    <span class="hljs-comment"># cmake最低版本号要求</span>
<span class="hljs-keyword">project</span>(TestProject)    <span class="hljs-comment"># 项目名</span>

<span class="hljs-keyword">set</span>(GOOGLETEST_VERSION <span class="hljs-number">1.10</span>.<span class="hljs-number">0</span>)  <span class="hljs-comment"># 设置 Gtest 的版本</span>
<span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)      <span class="hljs-comment"># C++ 版本</span>
<span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;-Wall&quot;</span>)    <span class="hljs-comment">#</span>

<span class="hljs-comment"># 编译google test，会在当前目录生成libtest.a静态库</span>
<span class="hljs-keyword">add_subdirectory</span>(
        external/googletest
)

<span class="hljs-comment"># 添加头文件</span>
<span class="hljs-keyword">include_directories</span>(
        <span class="hljs-keyword">include</span>
        external/googletest/<span class="hljs-keyword">include</span>
)

<span class="hljs-comment">#需要添加googletest运行需要的pthread</span>
<span class="hljs-keyword">set</span>(LIBRARIES
        gtest
        pthread)

<span class="hljs-keyword">set</span>(SOURCE_FLIES tests/demotest.cpp) <span class="hljs-comment"># 其余文件</span>
<span class="hljs-keyword">add_executable</span>(main src/main.cpp)   <span class="hljs-comment"># main 函数</span>
<span class="hljs-keyword">add_executable</span>(TestProject <span class="hljs-variable">$&#123;SOURCE_FLIES&#125;</span> external/googletest)


<span class="hljs-keyword">target_link_libraries</span>(TestProject gtest_main)</code></pre></div>

<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><p>demotest.cpp</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gtest/gtest.h&quot;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::testing;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GTestDemo</span> :</span> <span class="hljs-keyword">public</span> Test &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">GTestDemo</span>() : <span class="hljs-built_in">Test</span>() &#123;

    &#125;

    ~<span class="hljs-built_in">GTestDemo</span>() <span class="hljs-keyword">override</span> = <span class="hljs-keyword">default</span>;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;
        Test::<span class="hljs-built_in">SetUp</span>();
        std::cout &lt;&lt; <span class="hljs-string">&quot;I am setup&quot;</span> &lt;&lt; std::endl;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;
        Test::<span class="hljs-built_in">TearDown</span>();
        std::cout &lt;&lt; <span class="hljs-string">&quot;I am teardown&quot;</span> &lt;&lt; std::endl;
    &#125;
&#125;;

<span class="hljs-built_in">TEST_F</span>(GTestDemo, tc_example_01) &#123;
    std::cout &lt;&lt; <span class="hljs-string">&quot;GTestDemo&quot;</span> &lt;&lt; std::endl;
&#125;</code></pre></div>

<p><img src="/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/image-20210525001538855.png" alt="image-20210525001538855"></p>
]]></content>
      <categories>
        <category>Help</category>
        <category>Win</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言学习笔记</title>
    <url>/2020/04/04/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-语言学习笔记"><a href="#C-语言学习笔记" class="headerlink" title="C 语言学习笔记"></a>C 语言学习笔记</h1><ol>
<li>for 语句比较适合初始化和增加步长都是单条语句并且逻辑相关的情形，因为它将循环控制语句集中放在一起, 且比  while 语句更紧凑。</li>
<li>EOF（end of file）是文件结束指示符。</li>
<li>在该程序段中，for 循环语句的循环体是空的，这是因为所有工作都在测试（条件）部分与增加步长部分完成了。</li>
<li>但 C 语言的语法规则要求 for 循环语句必须有一个循环体，因此用单独的分号代替。单独的分号称为空语句，它正好能满足 for 语句的这一要求。把它单独放在一行是为了更加醒目。</li>
<li>单引号中的字符表示一个整型值，该值等于此字符在机器字符集中对应的数值，我们称之为字符常量。</li>
<li>我们通常把函数定义中圆括号内列表中出现的变量称为形式参数，而把函数调用中与形式参数对应的值称为实际参数。</li>
<li>函数不一定都有返回值。不带表达式的 return 语句将把控制权返回给调用者，但不返回有用的值。这等同于在到达函数的右终结花括号时，函数就“到达了尽头”。主调函数也可以忽 略函数返回的值。    </li>
<li>对数组而言，const 限定符指定数组所有元素的值都不能被修改。</li>
<li>C 语言提供了6 个位操作运算符。这些运算符只能作用于整型操作数，即只能作用于带符号或无符号 char、short、int、long 类型。</li>
<li>栈是一种限定仅在表尾进行插入和删除操作的线性表。</li>
<li><input disabled type="checkbox"> 的优先级高于按位&amp;，&amp;a[0] 等价于 a+0 (其中a是数组名)指的是a[0]的地址，*&amp;a[0] 等价于 a[0] 等价于 *a。</li>
<li>int p 是指 p 是指向 int 类型的指针变量。</li>
<li>数组传递一定是传指针。</li>
<li>continue 语句只用于循环语句，不用于 switch 语句。</li>
<li>作为一种良好的程序设计风格，在 switch 语句最后一个分支（即 default 分支）的后 面也加上一个 break 语句。这样做在逻辑上没有必要，但当我们需要向该 switch 语句后添加其它分支时，这种防范措施会降低犯错误的可能性。</li>
<li>因此，如果两个函数必须共享某些数据，而这两个函数互不调用对方，这种情况下最方便的方式便是把这些共享数据定义为外部变量，而不是作为函数参数传递。</li>
<li>名字的作用域指的是程序中可以使用该名字的部分。对于在函数开头声明的自动变量来说，其作用域是声明该变量名的函数。不同函数中声明的具有相同名字的各个局部变量之间没有任何关系。</li>
<li>函数的参数也是这样的，实际上可以将它看作是局部变量。外部变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束。</li>
<li>在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其它文件可以通过 extern 声明来访问它（定义外部变量的源文件中也可以包含对该外部变量的extern 声明）。</li>
<li>外部变量的定义中必须指定数组的长度，但 extern 声明则不一定要指定数组的长度。 外部变量的初始化只能出现在其定义中。</li>
<li>在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为 0，register 声明只适用于自动变量以及函数的形式参数，而自动变量和寄存器变量的初值则没有定义（即初值为无用的信息）。</li>
<li>对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次。</li>
<li>对于自动变量与寄存器变量来说，初始化表达式可以不是常量表达式，表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用。</li>
<li>int days[ ] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};</li>
<li>C++中，全局阈只能声明、初始化变量； 不能用于赋值、运算、调用函数等！</li>
<li>.如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性地使用关键字 extern。</li>
<li>我们可以得出这样一个结论：对于某些中等规模的程序，最好只用一个头文件存放程序中各部分共享的对象。较大的程序需要使用更多的头文件，我们需要精心地组织它们。</li>
<li>变量的声明（包括初始化）除了可以紧跟在函数开始的花括号之后，还可以紧跟在任何其它标识复合语句开始的左花括号之后。以这 种方式声明的变量可以隐藏程序块外与之同名的变量，它们之间没有任何关系，并在与左花 括号匹配的右花括号出现之前一直存在。</li>
<li>在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为 0，而自动变量和寄存器变量的初值则没有定义（即初值为无用的信息）。</li>
<li>如果文件名用引号引起来，则在源文件所在位置查找该文件；如果在该位置没有找到文件，或者如果文件名是用尖括号&lt;&gt;括起来的，则将根据相应的规则查找该文件，这个规则同具体的实现有关。</li>
<li>宏替换只对记号进行，对括在引号中的字符串不起作用。</li>
<li>在#if 语句中可以使用表达式defined(名字)，该表达式的值遵循下列规则：当名字已经定义时，其值为 1；否则，其值为 0。</li>
<li>指向 void 类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身。</li>
<li>类似于和++这样的一元运算符遵循从右至左的结合顺序。</li>
<li>gets（）是在stdio.h中是输入函数，使用类型：gets（str）。可以从标准输入类中读取一行字符到指定的字符串中，它在遇到EOF和回车换行键才会接受。但是由于功能强大，gets（）和scanf（）混合使用会导致gets（）无法接受字符串，因为scanf回车结束的时，回车键留在了缓冲区，这时gets就无法区分这个空格是否属于gets的输入。gets会接受到这个信号，无法直接接受后续的字符串。</li>
<li>解决办法:(1)：先gets后scanf，不让那gets读取回车；(2)：利用getchar判断，获取\n，后执行gets.</li>
<li>%g用来输出实数，它根据数值的大小，自动选f格式或e格式（选择输出时占宽度较小的一种），且不输出无意义的0。</li>
<li>C 语言保证，0 永远不是有效的数据地址。</li>
<li>指针与整数之间不能相互转换，但 0 是惟一的例外：常量 0 可以赋值给指针，指针也可以和常量 0 进行比较。程序中经常用符号常量 NULL 代替常量 0，这样便于更清晰地说明常量 0 是指针的一个特殊值。符号常量 NULL 定义在标准头文件&lt;stddef.h&gt;中。</li>
<li>任何指针与 0 进行相等或不等的比较运算都有意义。但是，指向不同数组的元素的指针之间的算术或比较运算没有定义。（这里有一个特例：指针的算术运算中可使用数组最 后一个元素的下一个元素的地址。）</li>
<li>字符串常量是一个字符数组。</li>
<li>数组形字符串(例：char a[ ]=”hhhh”) 存放在全局数据区或栈区，可读可写。指针字符串(char  <em>p=”hhh” )存放在常量区，只读不能写。</em></li>
<li>UNIX 系统中的 C 语言程序有一个公共的约定：以负号开头的参数表示一个可选标志或参数。</li>
<li>因为[]与操作数的结合优先级比 * 和 ++ 高，* 和 ++ 优先级一样，但从右至左结合；* 是一个前缀运算符，其优先级低于()。</li>
<li>运算符 . 和 -&gt; 都是从左至右结合的。</li>
<li>在所有运算符中，下面 4 个运算符的优先级最高：结构运算符 “.” 和 “-&gt;” 、用于函数调用的 “()” 以及用于下标的 “[]” ，因此，它们同操作数之间的结合也最紧密。</li>
</ol>
]]></content>
      <categories>
        <category>Technical</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Github 使用的基本操作</title>
    <url>/2020/08/03/Github%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>#Github 使用的基本操作</p>
<h2 id="1-Fork"><a href="#1-Fork" class="headerlink" title="1 Fork"></a>1 Fork</h2><p>现在你要克隆的仓库页面，点击Fork按钮，创建一个自己的仓库</p>
<h2 id="2-克隆"><a href="#2-克隆" class="headerlink" title="2 克隆"></a>2 克隆</h2><p>从远端再把这个仓库克隆到本地</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> git@github.com:用户名/远程仓库名.git</span></code></pre></div>

<h2 id="3-创建一个特性分支"><a href="#3-创建一个特性分支" class="headerlink" title="3 创建一个特性分支"></a>3 创建一个特性分支</h2><p>创建一个特性分支，在这个特性分支中进行开发</p>
<h3 id="3-1-首先确认当前分支"><a href="#3-1-首先确认当前分支" class="headerlink" title="3.1 首先确认当前分支"></a>3.1 首先确认当前分支</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -a</span></code></pre></div>

<h3 id="3-2-创建特性分支"><a href="#3-2-创建特性分支" class="headerlink" title="3.2 创建特性分支"></a>3.2 创建特性分支</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -b 特性分支名称 远程仓库名</span></code></pre></div>

<h3 id="3-3-核查是否创建并切换到特性分支下"><a href="#3-3-核查是否创建并切换到特性分支下" class="headerlink" title="3.3 核查是否创建并切换到特性分支下"></a>3.3 核查是否创建并切换到特性分支下</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -a</span></code></pre></div>

<h2 id="4-进行一定的修改和开发"><a href="#4-进行一定的修改和开发" class="headerlink" title="4 进行一定的修改和开发"></a>4 进行一定的修改和开发</h2><h3 id="5-提交修改"><a href="#5-提交修改" class="headerlink" title="5 提交修改"></a>5 提交修改</h3><h3 id="5-1-先用diff命令查看修改是否已经正确进行"><a href="#5-1-先用diff命令查看修改是否已经正确进行" class="headerlink" title="5.1 先用diff命令查看修改是否已经正确进行"></a>5.1 先用diff命令查看修改是否已经正确进行</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git diff</span></code></pre></div>

<h3 id="5-2-提交到本地仓库"><a href="#5-2-提交到本地仓库" class="headerlink" title="5.2 提交到本地仓库"></a>5.2 提交到本地仓库</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git add 要提交文件名</span></code></pre></div>

<h2 id="6-创建本地特性分支对应远程分支"><a href="#6-创建本地特性分支对应远程分支" class="headerlink" title="6 创建本地特性分支对应远程分支"></a>6 创建本地特性分支对应远程分支</h2><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin 特性分支名称</span>
<span class="hljs-meta">$</span><span class="bash"> git branch -a</span></code></pre></div>

<h2 id="7-确认远程特性分支是否被创建"><a href="#7-确认远程特性分支是否被创建" class="headerlink" title="7 确认远程特性分支是否被创建"></a>7 确认远程特性分支是否被创建</h2><p> 到Github的“用户名/仓库名”页面，确认远程特性分支是否被创建</p>
<h2 id="8-切换至特性分支"><a href="#8-切换至特性分支" class="headerlink" title="8 切换至特性分支"></a>8 切换至特性分支</h2><p>在Github的页面中切换至特性分支，然后点击<strong>Create Pull Request</strong> 按钮,在出现的页面里写好标题和评论。点击<strong>Send pull request</strong>按钮</p>
<h2 id="9-查看Pull-Request-的状态"><a href="#9-查看Pull-Request-的状态" class="headerlink" title="9 查看Pull Request 的状态"></a>9 查看Pull Request 的状态</h2><p>查看Pull Request 的状态，在Conversation标签页里可以看到</p>
]]></content>
      <categories>
        <category>Help</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Java-I/O操作中管道流的使用</title>
    <url>/2020/08/14/Java-IO%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%AE%A1%E9%81%93%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-首先需要导入三个包"><a href="#1-首先需要导入三个包" class="headerlink" title="1-首先需要导入三个包"></a>1-首先需要导入三个包</h2><div class="code-wrapper"><pre><code>import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;</code></pre></div><h2 id="2-我们需要编写两个进行对话的线程类"><a href="#2-我们需要编写两个进行对话的线程类" class="headerlink" title="2- 我们需要编写两个进行对话的线程类"></a>2- 我们需要编写两个进行对话的线程类</h2><h3 id="2-1-发送消息的线程类-Sender"><a href="#2-1-发送消息的线程类-Sender" class="headerlink" title="2.1 - 发送消息的线程类 Sender"></a>2.1 - 发送消息的线程类 Sender</h3><div class="code-wrapper"><pre><code>class Sender extends Thread&#123;
    private PipedOutputStream out = new PipedOutputStream();
    public PipedOutputStream getOutputStream()&#123;return out;&#125;

    @Override
    public void run()&#123;
        String s = new String(&quot;Receiver, 你好!&quot;);
        try &#123;
            out.write(s.getBytes()); // 写入(发送)
            out.close();
        &#125;catch (IOException e)&#123;
            System.out.println(e.getMessage());
        &#125;
    &#125;
&#125;</code></pre></div><h3 id="2-2-接收消息的线程类-Receiver"><a href="#2-2-接收消息的线程类-Receiver" class="headerlink" title="2.2 - 接收消息的线程类 Receiver"></a>2.2 - 接收消息的线程类 Receiver</h3><div class="code-wrapper"><pre><code>class Receiver extends Thread&#123;
    private PipedInputStream in = new PipedInputStream();
    public PipedInputStream getInputStream()&#123;return in;&#125;
    @Override
    public void run()&#123;
        String s = null;
        byte[] buf = new byte[1024];
        try &#123;
            int len = in.read(buf); // 读出信息
            s = new String(buf, 0, len);
            System.out.println(&quot;收到了以下信息: &quot; + s);
            in.close();
        &#125;catch (IOException e)&#123;
            System.out.println(e.getMessage());
        &#125;
    &#125;
&#125;</code></pre></div><p>声明的字节数组大小为1024原因是:类PipedInputStream运用的是一个1024字节固定大小的循环缓冲区。实际上，写入PipedOutputStream的数据保存到对应的PipedInputStream的内部缓冲区。</p>
<h2 id="3-进行管道流测试的主类-管道流的使用"><a href="#3-进行管道流测试的主类-管道流的使用" class="headerlink" title="3 - 进行管道流测试的主类(管道流的使用)"></a>3 - 进行管道流测试的主类(管道流的使用)</h2><div class="code-wrapper"><pre><code>public class PipeStreamDemo &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Sender sender = new Sender();   // 创建线程对象sender
            Receiver receiver = new Receiver(); // 创建线程对象receiver
            PipedOutputStream out = sender.getOutputStream(); // 写入
            PipedInputStream in = receiver.getInputStream(); // 读出
            out.connect(in); // 将输出发送到输入
            sender.start(); // 启动线程
            receiver.start();
        &#125;catch (IOException e)&#123;
            System.out.println(e.getMessage());
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="4-输出示例"><a href="#4-输出示例" class="headerlink" title="4 - 输出示例"></a>4 - 输出示例</h2><div class="code-wrapper"><pre><code>收到了以下信息: Receiver, 你好!</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaAbstractFactory模式</title>
    <url>/2020/09/14/JavaAbstractFactory%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  将关联零件组装成产品</p>
</blockquote>
<h2 id="1-方便统一处理Link和Tray的类"><a href="#1-方便统一处理Link和Tray的类" class="headerlink" title="1 - 方便统一处理Link和Tray的类"></a>1 - 方便统一处理Link和Tray的类</h2><div class="code-wrapper"><pre><code>public abstract class Item &#123;
    protected String caption;

    public Item(String caption)&#123;
        this.caption = caption;
    &#125;

    public abstract String makeHTML();
&#125;</code></pre></div><h2 id="2-抽象零件-表示HTML的链接的类"><a href="#2-抽象零件-表示HTML的链接的类" class="headerlink" title="2 - 抽象零件: 表示HTML的链接的类"></a>2 - 抽象零件: 表示HTML的链接的类</h2><div class="code-wrapper"><pre><code>public abstract class Link extends Item&#123;
    protected String url;

    public Link(String caption, String url) &#123;
        super(caption);
        this.url = url;
    &#125;
&#125;</code></pre></div><h2 id="3-抽象零件-表示含有Link和Tray的类"><a href="#3-抽象零件-表示含有Link和Tray的类" class="headerlink" title="3 - 抽象零件: 表示含有Link和Tray的类"></a>3 - 抽象零件: 表示含有Link和Tray的类</h2><div class="code-wrapper"><pre><code>public abstract class Tray extends Item&#123;

    protected ArrayList tray = new ArrayList();

    public Tray(String caption) &#123;
        super(caption);
    &#125;

    public void add(Item item)&#123;
        tray.add(item);
    &#125;
&#125;</code></pre></div><h2 id="4-抽象零件-表示含有HTML页面的类"><a href="#4-抽象零件-表示含有HTML页面的类" class="headerlink" title="4 - 抽象零件: 表示含有HTML页面的类"></a>4 - 抽象零件: 表示含有HTML页面的类</h2><div class="code-wrapper"><pre><code>public abstract class Page &#123;
    protected String title;
    protected String author;
    protected ArrayList content = new ArrayList();

    public Page(String title, String author)&#123;
        this.title = title;
        this.author = author;
    &#125;

    public void add(Item item)&#123;
        content.add(item);
    &#125;

    public void output()&#123;
        try &#123;
            String filename = title + &quot;.html&quot;;
            Writer writer = new FileWriter(filename);
            writer.write(this.makeHTML());
            writer.close();
            System.out.println(filename + &quot;编写完成&quot;);
        &#125;catch (IOException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;

    public abstract String makeHTML();
&#125;</code></pre></div><h2 id="5-表示抽象工厂的类-制作Link-Tray-Page"><a href="#5-表示抽象工厂的类-制作Link-Tray-Page" class="headerlink" title="5 - 表示抽象工厂的类(制作Link, Tray, Page)"></a>5 - 表示抽象工厂的类(制作Link, Tray, Page)</h2><div class="code-wrapper"><pre><code>public abstract class Factory &#123;
    public static Factory getFactory(String classname)&#123;
        Factory factory = null;
        try &#123;
            factory = (Factory)Class.forName(classname).newInstance();
        &#125;catch (ClassNotFoundException e)&#123;
            e.printStackTrace();
            System.out.println(&quot;没有找到 &quot; + classname + &quot;类&quot;);
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;

        return factory;
    &#125;

    public abstract Link createLink(String caption, String url);
    public abstract Tray createTray(String caption, String url);
    public abstract Page createPage(String title, String auto);
&#125;</code></pre></div><h2 id="6-表示具体工厂的类-制作ListLink-ListTray-ListPage"><a href="#6-表示具体工厂的类-制作ListLink-ListTray-ListPage" class="headerlink" title="6 - 表示具体工厂的类(制作ListLink, ListTray, ListPage)"></a>6 - 表示具体工厂的类(制作ListLink, ListTray, ListPage)</h2><div class="code-wrapper"><pre><code>public class ListFactory extends Factory&#123;
    @Override
    public Link createLink(String caption, String url) &#123;
        return new ListLink(caption, url);
    &#125;

    @Override
    public Tray createTray(String caption) &#123;
        return new ListTray(caption);
    &#125;

    @Override
    public Page createPage(String title, String auto) &#123;
        return new ListPage(title, auto);
    &#125;
&#125;</code></pre></div><h2 id="7-具体零件-表示HTML的链接的类"><a href="#7-具体零件-表示HTML的链接的类" class="headerlink" title="7 - 具体零件: 表示HTML的链接的类"></a>7 - 具体零件: 表示HTML的链接的类</h2><div class="code-wrapper"><pre><code>public class ListLink extends Link&#123;
    public ListLink(String caption, String url) &#123;
        super(caption, url);
    &#125;

    @Override
    public String makeHTML() &#123;
        return &quot;  &lt;li&gt;&lt;a href=\&quot;&quot; + url + &quot;\&quot;&gt;&quot; + caption + &quot;&lt;/a&gt;&lt;/li&gt;\n&quot;;
    &#125;
&#125;</code></pre></div><h2 id="8-具体零件-表示含有Link和Tray的类"><a href="#8-具体零件-表示含有Link和Tray的类" class="headerlink" title="8 - 具体零件: 表示含有Link和Tray的类"></a>8 - 具体零件: 表示含有Link和Tray的类</h2><div class="code-wrapper"><pre><code>public class ListTray extends Tray&#123;
    public ListTray(String caption) &#123;
        super(caption);
    &#125;

    @Override
    public String makeHTML() &#123;
        StringBuilder buffer = new StringBuilder();
        buffer.append(&quot;&lt;li&gt;\n&quot;);
        buffer.append(caption).append(&quot;\n&quot;);
        buffer.append(&quot;&lt;ul&gt;\n&quot;);
        for (Object o : tray) &#123;
            Item item = (Item) o;
            buffer.append(item.makeHTML());
        &#125;

        buffer.append(&quot;&lt;/ul&gt;\n&quot;);
        buffer.append(&quot;&lt;/li&gt;\n&quot;);
        return buffer.toString();
    &#125;
&#125;</code></pre></div><h2 id="9-具体零件-表示HTML页面的类"><a href="#9-具体零件-表示HTML页面的类" class="headerlink" title="9 - 具体零件: 表示HTML页面的类"></a>9 - 具体零件: 表示HTML页面的类</h2><div class="code-wrapper"><pre><code>public class ListPage extends Page&#123;
    public ListPage(String title, String author) &#123;
        super(title, author);
    &#125;

    @Override
    public String makeHTML() &#123;
        StringBuilder buffer = new StringBuilder();
        buffer.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;).append(title).append(&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;);
        buffer.append(&quot;&lt;body&gt;\n&quot;);
        buffer.append(&quot;&lt;h1&gt;&quot;).append(title).append(&quot;&lt;/h1&gt;\n&quot;);
        buffer.append(&quot;&lt;ul&gt;\n&quot;);
        for (Object o : content) &#123;
            Item item = (Item) o;
            buffer.append(item.makeHTML());
        &#125;
        buffer.append(&quot;&lt;/ul&gt;\n&quot;);
        buffer.append(&quot;&lt;hr&gt;&lt;address&gt;&quot;).append(author).append(&quot;&lt;/address&gt;&quot;);
        buffer.append(&quot;&lt;/body&gt;&lt;/html&gt;\n&quot;);
        return buffer.toString();
    &#125;
&#125;</code></pre></div><h2 id="10-测试程序行为的类"><a href="#10-测试程序行为的类" class="headerlink" title="10 - 测试程序行为的类"></a>10 - 测试程序行为的类</h2><p>需要设置参数args[] = listfactory.ListFactory</p>
<div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        if (args.length != 1)&#123;
            System.out.println(&quot;Usage: java Main class.name.of.ConcreteFactory&quot;);
            System.out.println(&quot;Example 1: java Main listFactory.ListFactory&quot;);
            System.out.println(&quot;Example 2: java Main tableFactory.TableFactory&quot;);
            System.exit(0);
        &#125;

        Factory factory = Factory.getFactory(args[0]);

        Link people = factory.createLink(&quot;人民日报&quot;, &quot;http://www.people.com.cn/&quot;);
        Link gmw = factory.createLink(&quot;光明日报&quot;, &quot;http://www.gmw.cn/&quot;);

        Link us_yahoo = factory.createLink(&quot;Yahoo!&quot;, &quot;http://www.yahoo.com/&quot;);
        Link jp_yahoo = factory.createLink(&quot;Yahoo!Japan!&quot;, &quot;http://www.yahoo.co.jp&quot;);
        Link excite = factory.createLink(&quot;Excite&quot;, &quot;http://www.excite.com/&quot;);
        Link google = factory.createLink(&quot;Google&quot;, &quot;http://www.google.com/&quot;);

        Tray trayNews = factory.createTray(&quot;日报&quot;);
        trayNews.add(people);
        trayNews.add(gmw);

        Tray trayYahoo = factory.createTray(&quot;Yahoo!&quot;);
        trayYahoo.add(us_yahoo);
        trayYahoo.add(jp_yahoo);

        Tray traySearch = factory.createTray(&quot;检索引擎&quot;);
        traySearch.add(trayYahoo);
        traySearch.add(excite);
        traySearch.add(google);

        Page page = factory.createPage(&quot;LinkPage&quot;, &quot;杨文轩&quot;);
        page.add(trayNews);
        page.add(traySearch);
        page.output();

    &#125;
&#125;</code></pre></div><h2 id="11-输出示例"><a href="#11-输出示例" class="headerlink" title="11 - 输出示例"></a>11 - 输出示例</h2><div class="code-wrapper"><pre><code>LinkPage.html编写完成

HTML文本效果图</code></pre></div><html><head><title>LinkPage</title></head>
<body>
<h1>LinkPage</h1>
<ul>
<li>
日报
<ul>
<li><a href="http://www.people.com.cn/">人民日报</a></li>
<li><a href="http://www.gmw.cn/">光明日报</a></li>
</ul>
</li>
<li>
检索引擎
<ul>
<li>
Yahoo!
<ul>
<li><a href="http://www.yahoo.com/">Yahoo!</a></li>
<li><a href="http://www.yahoo.co.jp">Yahoo!Japan!</a></li>
</ul>
</li>
<li><a href="http://www.excite.com/">Excite</a></li>
<li><a href="http://www.google.com/">Google</a></li>
</ul>
</li>
</ul>
<hr><address>杨文轩</address></body></html>

<div class="code-wrapper"><pre><code>具体源码
&lt;html&gt;&lt;head&gt;&lt;title&gt;LinkPage&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;LinkPage&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
日报
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.people.com.cn/&quot;&gt;人民日报&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.gmw.cn/&quot;&gt;光明日报&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
检索引擎
&lt;ul&gt;
&lt;li&gt;
Yahoo!
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.yahoo.com/&quot;&gt;Yahoo!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.yahoo.co.jp&quot;&gt;Yahoo!Japan!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.excite.com/&quot;&gt;Excite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.google.com/&quot;&gt;Google&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;&lt;address&gt;杨文轩&lt;/address&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaAbstractFactory模式表格化版本</title>
    <url>/2020/09/17/JavaAbstractFactory%E6%A8%A1%E5%BC%8F%E8%A1%A8%E6%A0%BC%E5%8C%96%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<blockquote>
<p>  将关联零件组装成产品</p>
</blockquote>
<h2 id="1-方便统一处理Link和Tray的类"><a href="#1-方便统一处理Link和Tray的类" class="headerlink" title="1 - 方便统一处理Link和Tray的类"></a>1 - 方便统一处理Link和Tray的类</h2><div class="code-wrapper"><pre><code>public abstract class Item &#123;
    protected String caption;

    public Item(String caption)&#123;
        this.caption = caption;
    &#125;

    public abstract String makeHTML();
&#125;</code></pre></div><h2 id="2-抽象零件-表示HTML的链接的类"><a href="#2-抽象零件-表示HTML的链接的类" class="headerlink" title="2 - 抽象零件: 表示HTML的链接的类"></a>2 - 抽象零件: 表示HTML的链接的类</h2><div class="code-wrapper"><pre><code>public abstract class Link extends Item&#123;
    protected String url;

    public Link(String caption, String url) &#123;
        super(caption);
        this.url = url;
    &#125;
&#125;</code></pre></div><h2 id="3-抽象零件-表示含有Link和Tray的类"><a href="#3-抽象零件-表示含有Link和Tray的类" class="headerlink" title="3 - 抽象零件: 表示含有Link和Tray的类"></a>3 - 抽象零件: 表示含有Link和Tray的类</h2><div class="code-wrapper"><pre><code>public abstract class Tray extends Item&#123;

    protected ArrayList tray = new ArrayList();

    public Tray(String caption) &#123;
        super(caption);
    &#125;

    public void add(Item item)&#123;
        tray.add(item);
    &#125;
&#125;</code></pre></div><h2 id="4-抽象零件-表示含有HTML页面的类"><a href="#4-抽象零件-表示含有HTML页面的类" class="headerlink" title="4 - 抽象零件: 表示含有HTML页面的类"></a>4 - 抽象零件: 表示含有HTML页面的类</h2><div class="code-wrapper"><pre><code>public abstract class Page &#123;
    protected String title;
    protected String author;
    protected ArrayList content = new ArrayList();

    public Page(String title, String author)&#123;
        this.title = title;
        this.author = author;
    &#125;

    public void add(Item item)&#123;
        content.add(item);
    &#125;

    public void output()&#123;
        try &#123;
            String filename = title + &quot;.html&quot;;
            Writer writer = new FileWriter(filename);
            writer.write(this.makeHTML());
            writer.close();
            System.out.println(filename + &quot;编写完成&quot;);
        &#125;catch (IOException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;

    public abstract String makeHTML();
&#125;</code></pre></div><h2 id="5-表示抽象工厂的类-制作Link-Tray-Page"><a href="#5-表示抽象工厂的类-制作Link-Tray-Page" class="headerlink" title="5 - 表示抽象工厂的类(制作Link, Tray, Page)"></a>5 - 表示抽象工厂的类(制作Link, Tray, Page)</h2><div class="code-wrapper"><pre><code>public abstract class Factory &#123;
    public static Factory getFactory(String classname)&#123;
        Factory factory = null;
        try &#123;
            factory = (Factory)Class.forName(classname).newInstance();
        &#125;catch (ClassNotFoundException e)&#123;
            e.printStackTrace();
            System.out.println(&quot;没有找到 &quot; + classname + &quot;类&quot;);
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;

        return factory;
    &#125;

    public abstract Link createLink(String caption, String url);
    public abstract Tray createTray(String caption, String url);
    public abstract Page createPage(String title, String auto);
&#125;</code></pre></div><h2 id="6-具体的工厂-TableFactory-制作TableLink-TableTray-TablePage"><a href="#6-具体的工厂-TableFactory-制作TableLink-TableTray-TablePage" class="headerlink" title="6 - 具体的工厂: TableFactory(制作TableLink, TableTray, TablePage)"></a>6 - 具体的工厂: TableFactory(制作TableLink, TableTray, TablePage)</h2><div class="code-wrapper"><pre><code>public class TableFactory extends Factory &#123;
    @Override
    public Link createLink(String caption, String url) &#123;
        return new TableLink(caption, url);
    &#125;

    @Override
    public Tray createTray(String caption) &#123;
        return new TableTray(caption);
    &#125;

    @Override
    public Page createPage(String title, String auto) &#123;
        return new TablePage(title, auto);
    &#125;
&#125;</code></pre></div><h2 id="7-具体零件-表示HTML的链接的类"><a href="#7-具体零件-表示HTML的链接的类" class="headerlink" title="7 - 具体零件: 表示HTML的链接的类"></a>7 - 具体零件: 表示HTML的链接的类</h2><div class="code-wrapper"><pre><code>public class TableLink extends Link&#123;
    public TableLink(String caption, String url) &#123;
        super(caption, url);
    &#125;

    @Override
    public String makeHTML() &#123;
        return &quot;  &lt;td&gt;&lt;a href=\&quot;&quot; + url + &quot;\&quot;&gt;&quot; + caption + &quot;&lt;/a&gt;&lt;/td&gt;\n&quot;;
    &#125;
&#125;</code></pre></div><h2 id="8-具体零件-表示含有Link和Tray的类"><a href="#8-具体零件-表示含有Link和Tray的类" class="headerlink" title="8 - 具体零件: 表示含有Link和Tray的类"></a>8 - 具体零件: 表示含有Link和Tray的类</h2><div class="code-wrapper"><pre><code>public class TableTray extends Tray &#123;

public TableTray(String caption) &#123;
    super(caption);
&#125;

    @Override
    public String makeHTML() &#123;
        StringBuilder buffer = new StringBuilder();
        buffer.append(&quot;&lt;td&gt;&quot;);
        buffer.append(&quot;&lt;table width=\&quot;100%\&quot; border=\&quot;1\&quot;&gt;&lt;tr&gt;&quot;);
        buffer.append(&quot;&lt;td bgcolor=\&quot;#cccccc\&quot; align=\&quot;center\&quot; colspan=\&quot;&quot;).append(tray.size()).append(&quot;\&quot;&gt;&lt;b&gt;&quot;).append(caption).append(&quot;&lt;/b&gt;&lt;/td&gt;&quot;);
        buffer.append(&quot;&lt;/tr&gt;\n&quot;);
        buffer.append(&quot;&lt;tr&gt;\n&quot;);

        for (Item item : tray) &#123;
            buffer.append(item.makeHTML());
        &#125;

        buffer.append(&quot;&lt;/tr&gt;&lt;/table&gt;&quot;);
        buffer.append(&quot;&lt;/td&gt;\n&quot;);
        return buffer.toString();
    &#125;
&#125;</code></pre></div><h2 id="9-具体零件-表示HTML页面的类"><a href="#9-具体零件-表示HTML页面的类" class="headerlink" title="9 - 具体零件: 表示HTML页面的类"></a>9 - 具体零件: 表示HTML页面的类</h2><div class="code-wrapper"><pre><code>public class TablePage extends Page&#123;

    public TablePage(String title, String author) &#123;
        super(title, author);
    &#125;

    @Override
    public String makeHTML() &#123;
        StringBuilder buffer = new StringBuilder();
        buffer.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;).append(title).append(&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;);
        buffer.append(&quot;&lt;body&gt;\n&quot;);
        buffer.append(&quot;&lt;h1&gt;&quot;).append(title).append(&quot;&lt;/h1&gt;\n&quot;);
        buffer.append(&quot;&lt;table width=\&quot;80%\&quot; border=\&quot;3\&quot;&gt;\n&quot;);
        for (Item item : content) &#123;
            buffer.append(&quot;&lt;tr&gt;&quot;).append(item.makeHTML()).append(&quot;&lt;/tr&gt;&quot;);
        &#125;
        buffer.append(&quot;&lt;/table&gt;\n&quot;);
        buffer.append(&quot;&lt;hr&gt;&lt;address&gt;&quot;).append(author).append(&quot;&lt;/address&gt;&quot;);
        buffer.append(&quot;&lt;/body&gt;&lt;/html&gt;\n&quot;);
        return buffer.toString();
    &#125;
&#125;</code></pre></div><h2 id="10-测试程序行为的类"><a href="#10-测试程序行为的类" class="headerlink" title="10 - 测试程序行为的类"></a>10 - 测试程序行为的类</h2><p>需要设置参数args[] = tablefactory.TableFactory</p>
<div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        if (args.length != 1)&#123;
            System.out.println(&quot;Usage: java Main class.name.of.ConcreteFactory&quot;);
            System.out.println(&quot;Example 1: java Main listFactory.ListFactory&quot;);
            System.out.println(&quot;Example 2: java Main tableFactory.TableFactory&quot;);
            System.exit(0);
        &#125;

        Factory factory = Factory.getFactory(args[0]);

        Link people = factory.createLink(&quot;人民日报&quot;, &quot;http://www.people.com.cn/&quot;);
        Link gmw = factory.createLink(&quot;光明日报&quot;, &quot;http://www.gmw.cn/&quot;);

        Link us_yahoo = factory.createLink(&quot;Yahoo!&quot;, &quot;http://www.yahoo.com/&quot;);
        Link jp_yahoo = factory.createLink(&quot;Yahoo!Japan!&quot;, &quot;http://www.yahoo.co.jp&quot;);
        Link excite = factory.createLink(&quot;Excite&quot;, &quot;http://www.excite.com/&quot;);
        Link google = factory.createLink(&quot;Google&quot;, &quot;http://www.google.com/&quot;);

        Tray trayNews = factory.createTray(&quot;日报&quot;);
        trayNews.add(people);
        trayNews.add(gmw);

        Tray trayYahoo = factory.createTray(&quot;Yahoo!&quot;);
        trayYahoo.add(us_yahoo);
        trayYahoo.add(jp_yahoo);

        Tray traySearch = factory.createTray(&quot;检索引擎&quot;);
        traySearch.add(trayYahoo);
        traySearch.add(excite);
        traySearch.add(google);

        Page page = factory.createPage(&quot;LinkPage&quot;, &quot;杨文轩&quot;);
        page.add(trayNews);
        page.add(traySearch);
        page.output();

    &#125;
&#125;</code></pre></div><h2 id="11-输出示例"><a href="#11-输出示例" class="headerlink" title="11 - 输出示例"></a>11 - 输出示例</h2><div class="code-wrapper"><pre><code>LinkPage.html编写完成

HTML文本效果图</code></pre></div><html><head><title>LinkPage</title></head>
<body>
<h1>LinkPage</h1>
<table width="80%" border="3">
<tr><td><table width="100%" border="1"><tr><td bgcolor="#cccccc" align="center" colspan="2"><b>日报</b></td></tr>
<tr>
  <td><a href="http://www.people.com.cn/">人民日报</a></td>
  <td><a href="http://www.gmw.cn/">光明日报</a></td>
</tr></table></td>
</tr><tr><td><table width="100%" border="1"><tr><td bgcolor="#cccccc" align="center" colspan="3"><b>检索引擎</b></td></tr>
<tr>
<td><table width="100%" border="1"><tr><td bgcolor="#cccccc" align="center" colspan="2"><b>Yahoo!</b></td></tr>
<tr>
  <td><a href="http://www.yahoo.com/">Yahoo!</a></td>
  <td><a href="http://www.yahoo.co.jp">Yahoo!Japan!</a></td>
</tr></table></td>
  <td><a href="http://www.excite.com/">Excite</a></td>
  <td><a href="http://www.google.com/">Google</a></td>
</tr></table></td>
</tr></table>
<hr><address>杨文轩</address></body></html>

<div class="code-wrapper"><pre><code>具体源码
&lt;html&gt;&lt;head&gt;&lt;title&gt;LinkPage&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;LinkPage&lt;/h1&gt;
&lt;table width=&quot;80%&quot; border=&quot;3&quot;&gt;
&lt;tr&gt;&lt;td&gt;&lt;table width=&quot;100%&quot; border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#cccccc&quot; align=&quot;center&quot; colspan=&quot;2&quot;&gt;&lt;b&gt;日报&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.people.com.cn/&quot;&gt;人民日报&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.gmw.cn/&quot;&gt;光明日报&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;table width=&quot;100%&quot; border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#cccccc&quot; align=&quot;center&quot; colspan=&quot;3&quot;&gt;&lt;b&gt;检索引擎&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;table width=&quot;100%&quot; border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#cccccc&quot; align=&quot;center&quot; colspan=&quot;2&quot;&gt;&lt;b&gt;Yahoo!&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.yahoo.com/&quot;&gt;Yahoo!&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.yahoo.co.jp&quot;&gt;Yahoo!Japan!&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.excite.com/&quot;&gt;Excite&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.google.com/&quot;&gt;Google&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;hr&gt;&lt;address&gt;杨文轩&lt;/address&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaBridge模式</title>
    <url>/2020/09/18/JavaBridge%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  类的功能层次结构和实现层次结构的分离</p>
</blockquote>
<h2 id="1-负责”显示”的类"><a href="#1-负责”显示”的类" class="headerlink" title="1 - 负责”显示”的类"></a>1 - 负责”显示”的类</h2><div class="code-wrapper"><pre><code>public class Display &#123;
    private DisplayImpl impl;
    public Display(DisplayImpl impl)&#123;
        this.impl = impl;
    &#125;

    public void open()&#123;
        impl.rawOpen();
    &#125;

    public void print()&#123;
        impl.rawPrint();
    &#125;

    public void close()&#123;
        impl.rawClose();
    &#125;

    public final void display()&#123;
        open();
        print();
        close();
    &#125;
&#125;</code></pre></div><h2 id="2-增加了”只显示规定次数”这一功能的类"><a href="#2-增加了”只显示规定次数”这一功能的类" class="headerlink" title="2 - 增加了”只显示规定次数”这一功能的类"></a>2 - 增加了”只显示规定次数”这一功能的类</h2><div class="code-wrapper"><pre><code>public class CountDisplay extends Display&#123;
    public CountDisplay(DisplayImpl impl) &#123;
        super(impl);
    &#125;

    public void multiDisplay(int times)&#123;
        open();
        for (int i = 0; i &lt; times; i++) &#123;
            print();
        &#125;
        close();
    &#125;
&#125;</code></pre></div><h2 id="3-负责”显示”的类"><a href="#3-负责”显示”的类" class="headerlink" title="3 - 负责”显示”的类"></a>3 - 负责”显示”的类</h2><div class="code-wrapper"><pre><code>public abstract class DisplayImpl &#123;
    public abstract void rawOpen();
    public abstract void rawPrint();
    public abstract void rawClose();
&#125;</code></pre></div><h2 id="4-“用字符串显示”的类"><a href="#4-“用字符串显示”的类" class="headerlink" title="4 -  “用字符串显示”的类"></a>4 -  “用字符串显示”的类</h2><div class="code-wrapper"><pre><code>public class StringDisplayImpl extends DisplayImpl&#123;
    private String string;
    private int width;

    public StringDisplayImpl(String string)&#123;
        this.string = string;
        this.width = string.getBytes().length;
    &#125;
    @Override
    public void rawOpen() &#123;
        printLine();
    &#125;

    @Override
    public void rawPrint() &#123;
        System.out.println(&quot;|&quot; + string + &quot;|&quot;);
    &#125;

    @Override
    public void rawClose() &#123;
        printLine();
    &#125;

    private void printLine()&#123;
        System.out.print(&quot;+&quot;);
        for (int i = 0; i &lt; width; i++) &#123;
            System.out.print(&quot;-&quot;);
        &#125;
        System.out.println(&quot;+&quot;);
    &#125;
&#125;</code></pre></div><h2 id="5-测试程序的类"><a href="#5-测试程序的类" class="headerlink" title="5 - 测试程序的类"></a>5 - 测试程序的类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        Display d1 = new Display(new StringDisplayImpl(&quot;Hello, China.&quot;));
        Display d2 = new CountDisplay(new StringDisplayImpl(&quot;Hello, World.&quot;));
        CountDisplay d3 = new CountDisplay(new StringDisplayImpl(&quot;Hello, Universe.&quot;));

        d1.display();
        d2.display();
        d3.display();
        d3.multiDisplay(3);
    &#125;
&#125;</code></pre></div><h2 id="6-输出示例"><a href="#6-输出示例" class="headerlink" title="6 - 输出示例"></a>6 - 输出示例</h2><div class="code-wrapper"><pre><code>+-------------+
|Hello, China.|
+-------------+
+-------------+
|Hello, World.|
+-------------+
+----------------+
|Hello, Universe.|
+----------------+
+----------------+
|Hello, Universe.|
|Hello, Universe.|
|Hello, Universe.|
+----------------+</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaBuilder模式</title>
    <url>/2020/09/13/JavaBuilder%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  组装复杂的实例</p>
</blockquote>
<h2 id="1-定义了决定文档结构的方法的抽象类"><a href="#1-定义了决定文档结构的方法的抽象类" class="headerlink" title="1 - 定义了决定文档结构的方法的抽象类"></a>1 - 定义了决定文档结构的方法的抽象类</h2><div class="code-wrapper"><pre><code>public abstract class Builder &#123;
    public abstract void makeTitle(String title);
    public abstract void makeString(String str);
    public abstract void makeItems(String[] items);
    public abstract void close();
&#125;</code></pre></div><h2 id="2-编写一个文档的类"><a href="#2-编写一个文档的类" class="headerlink" title="2 - 编写一个文档的类"></a>2 - 编写一个文档的类</h2><div class="code-wrapper"><pre><code>public class Director &#123;
    private Builder builder;

    public Director(Builder builder)&#123;
        this.builder = builder;
    &#125;

    public void construct()&#123;
        builder.makeTitle(&quot;Greeting&quot;);
        builder.makeString(&quot;从早上至下午&quot;);
        builder.makeItems(new String[] &#123;
                &quot;早上好.&quot;,
                &quot;下午好.&quot;
        &#125;);
        builder.makeString(&quot;晚上&quot;);
        builder.makeItems(new String[] &#123;
                &quot;晚上好.&quot;,
                &quot;晚安.&quot;,
                &quot;再见.&quot;
        &#125;);
        builder.close();
    &#125;
&#125;</code></pre></div><h2 id="3-使用纯文本-普通字符串-编写文档的类"><a href="#3-使用纯文本-普通字符串-编写文档的类" class="headerlink" title="3 - 使用纯文本(普通字符串)编写文档的类"></a>3 - 使用纯文本(普通字符串)编写文档的类</h2><div class="code-wrapper"><pre><code>public class TextBuilder extends Builder&#123;
    private StringBuffer buffer = new StringBuffer();

    @Override
    public void makeTitle(String title) &#123;
        buffer.append(&quot;=================================\n&quot;);
        buffer.append(&quot;[&quot;).append(title).append(&quot;]\n&quot;);
        buffer.append(&quot;\n&quot;);
    &#125;

    @Override
    public void makeString(String str) &#123;
        buffer.append(&apos;*&apos;).append(str).append(&quot;\n&quot;);
        buffer.append(&quot;\n&quot;);
    &#125;

    @Override
    public void makeItems(String[] items) &#123;
        for (String item : items) &#123;
            buffer.append(&quot; -&quot;).append(item).append(&quot;\n&quot;);
        &#125;
        buffer.append(&quot;\n&quot;);
    &#125;

    @Override
    public void close() &#123;
        buffer.append(&quot;=================================\n&quot;);
    &#125;

    public String getResult()&#123;
        return buffer.toString();
    &#125;
&#125;</code></pre></div><h2 id="4-使用HTML编写文档的类"><a href="#4-使用HTML编写文档的类" class="headerlink" title="4 - 使用HTML编写文档的类"></a>4 - 使用HTML编写文档的类</h2><div class="code-wrapper"><pre><code>public class HTMLBuilder extends Builder&#123;
    private String filename;
    private PrintWriter writer;

    @Override
    public void makeTitle(String title) &#123;
        filename = title + &quot;.html&quot;;
        try &#123;
            writer = new PrintWriter(new FileWriter(filename));
        &#125;catch (IOException e)&#123;
            e.printStackTrace();
        &#125;
        writer.println(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;);
        writer.println(&quot;&lt;h1&gt;&quot; + title + &quot;&lt;/h1&gt;&quot;);
    &#125;

    @Override
    public void makeString(String str) &#123;
        writer.println(&quot;&lt;p&gt;&quot; + str + &quot;&lt;/p&gt;&quot;);
    &#125;

    @Override
    public void makeItems(String[] items) &#123;
        writer.println(&quot;&lt;ul&gt;&quot;);
        for (String item : items) &#123;
            writer.println(&quot;&lt;li&gt;&quot; + item + &quot;&lt;/li&gt;&quot;);
        &#125;
        writer.println(&quot;&lt;/ul&gt;&quot;);
    &#125;

    @Override
    public void close() &#123;
        writer.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);
        writer.close();
    &#125;

    public String getFilename()&#123;
        return filename;
    &#125;
&#125;</code></pre></div><h2 id="5-测试程序行为的类"><a href="#5-测试程序行为的类" class="headerlink" title="5 - 测试程序行为的类"></a>5 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>// 需要提前设置好args的参数
public class Main5 &#123;
    public static void main(String[] args) &#123;
        if (args.length != 1) &#123;
            usage();
            System.exit(0);
        &#125;

        if (args[0].equals(&quot;plain&quot;))&#123;
            TextBuilder textBuilder = new TextBuilder();
            Director director = new Director(textBuilder);
            director.construct();
            String result = textBuilder.getResult();
            System.out.println(result);
        &#125;else if (args[0].equals(&quot;html&quot;))&#123;
            HTMLBuilder htmlBuilder = new HTMLBuilder();
            Director director = new Director(htmlBuilder);
            director.construct();
            String filename = htmlBuilder.getFilename();
            System.out.println(filename + &quot;文件编写完成&quot;);
        &#125;else &#123;
            usage();
            System.exit(0);
        &#125;
    &#125;

    public static void usage()&#123;
        System.out.println(&quot;Usage: java Main plain      编写纯文本文档&quot;);
        System.out.println(&quot;Usage: java Main html       编写HTML文档&quot;);
    &#125;
&#125;</code></pre></div><h2 id="6-输出示例"><a href="#6-输出示例" class="headerlink" title="6 - 输出示例"></a>6 - 输出示例</h2><h3 id="6-1-Usage-java-Main-plain-编写纯文本文档"><a href="#6-1-Usage-java-Main-plain-编写纯文本文档" class="headerlink" title="6.1 Usage: java Main plain      编写纯文本文档"></a>6.1 Usage: java Main plain      编写纯文本文档</h3><div class="code-wrapper"><pre><code>=================================
    [Greeting]

    *从早上至下午

    -早上好.
    -下午好.

    *晚上

    -晚上好.
    -晚安.
    -再见.

=================================</code></pre></div><h3 id="6-2-Usage-java-Main-html-编写HTML文档"><a href="#6-2-Usage-java-Main-html-编写HTML文档" class="headerlink" title="6.2 Usage: java Main html       编写HTML文档"></a>6.2 Usage: java Main html       编写HTML文档</h3><div class="code-wrapper"><pre><code>Greeting.html文件编写完成

****HTML文本****
 &lt;html&gt;&lt;head&gt;&lt;title&gt;Greeting&lt;/title&gt;&lt;/head&gt;&lt;body&gt;
&lt;h1&gt;Greeting&lt;/h1&gt;
&lt;p&gt;从早上至下午&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;早上好.&lt;/li&gt;
&lt;li&gt;下午好.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;晚上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;晚上好.&lt;/li&gt;
&lt;li&gt;晚安.&lt;/li&gt;
&lt;li&gt;再见.&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;&lt;/html&gt;</code></pre></div><p>在进行一些复杂实例的组装中我们经常用到如下模式</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaChainOfResponsibility模式</title>
    <url>/2020/09/24/JavaChainOfResponsibility%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  推卸责任</p>
</blockquote>
<h2 id="1-表示发生的问题的类-它带有问题编号-number"><a href="#1-表示发生的问题的类-它带有问题编号-number" class="headerlink" title="1 - 表示发生的问题的类.它带有问题编号(number)"></a>1 - 表示发生的问题的类.它带有问题编号(number)</h2><div class="code-wrapper"><pre><code>public class Trouble &#123;
    private int number; // 问题编号

    public Trouble(int number)&#123; // 生成问题
        this.number = number;
    &#125;

    public int getNumber()&#123;
        return number;
    &#125;

    @Override
    public String toString()&#123;
        return &quot;[Trouble &quot; + number + &quot;]&quot;;
    &#125;
&#125;</code></pre></div><h2 id="2-用来解决问题的抽象类"><a href="#2-用来解决问题的抽象类" class="headerlink" title="2 - 用来解决问题的抽象类"></a>2 - 用来解决问题的抽象类</h2><div class="code-wrapper"><pre><code>public abstract class Support &#123;
    private String name;    // 解决问题的实例的名字
    private Support next;   // 要推卸给的对象

    public Support(String name)&#123;
        this.name = name;
    &#125;

    public Support setNext(Support next)&#123;
        this.next = next;
        return next;
    &#125;

    public final void support(Trouble trouble)&#123; // 解决问题的步骤
        if (resolve(trouble))&#123;
            done(trouble);
        &#125;else if(next != null)&#123;
            next.support(trouble);
        &#125;else&#123;
            fail(trouble);
        &#125;
    &#125;

    @Override
    public String toString()&#123;
        return &quot;[&quot; + name + &quot;]&quot;;
    &#125;

    protected abstract boolean resolve(Trouble trouble);

    protected  void done(Trouble trouble)&#123;  // 解决
        System.out.println(trouble + &quot; is resolved by &quot; + this + &quot;.&quot;);
    &#125;

    protected void fail(Trouble trouble)&#123;   // 未解决
        System.out.println(trouble + &quot;cannot be resolved.&quot;);
    &#125;
&#125;</code></pre></div><h2 id="3-用来解决问题的具体类-永远-“-不处理问题-“"><a href="#3-用来解决问题的具体类-永远-“-不处理问题-“" class="headerlink" title="3 - 用来解决问题的具体类(永远 “ 不处理问题 “)"></a>3 - 用来解决问题的具体类(永远 “ 不处理问题 “)</h2><div class="code-wrapper"><pre><code>public class NoSupport extends Support&#123;
    public NoSupport(String name)&#123;
        super(name);
    &#125;

    @Override
    protected boolean resolve(Trouble trouble) &#123;    // 解决问题的方法
        return false;                               // 自己什么也不做
    &#125;
&#125;</code></pre></div><h2 id="4-用来解决问题的具体类-仅解决编号小于指定编号的问题"><a href="#4-用来解决问题的具体类-仅解决编号小于指定编号的问题" class="headerlink" title="4 - 用来解决问题的具体类(仅解决编号小于指定编号的问题)"></a>4 - 用来解决问题的具体类(仅解决编号小于指定编号的问题)</h2><div class="code-wrapper"><pre><code>public class LimitSupport extends Support&#123;
    private int limit;
    public LimitSupport(String name, int limit) &#123;
        super(name);
        this.limit = limit;
    &#125;

    @Override
    protected boolean resolve(Trouble trouble) &#123;
        return trouble.getNumber() &lt; limit;
    &#125;
&#125;</code></pre></div><h2 id="5-用来解决问题的具体类-仅解决奇数编号的问题"><a href="#5-用来解决问题的具体类-仅解决奇数编号的问题" class="headerlink" title="5 - 用来解决问题的具体类(仅解决奇数编号的问题)"></a>5 - 用来解决问题的具体类(仅解决奇数编号的问题)</h2><div class="code-wrapper"><pre><code>public class OddSupport extends Support&#123;
    public OddSupport(String name) &#123;
        super(name);
    &#125;

    @Override
    protected boolean resolve(Trouble trouble) &#123;
        return trouble.getNumber() % 2 == 1;
    &#125;
&#125;</code></pre></div><h2 id="6-用来解决问题的具体类-仅解决指定编号的问题"><a href="#6-用来解决问题的具体类-仅解决指定编号的问题" class="headerlink" title="6 - 用来解决问题的具体类(仅解决指定编号的问题)"></a>6 - 用来解决问题的具体类(仅解决指定编号的问题)</h2><div class="code-wrapper"><pre><code>public class SpecialSupport extends Support&#123;
    private int number;
    public SpecialSupport(String name, int number) &#123;
        super(name);
        this.number = number;
    &#125;

    @Override
    protected boolean resolve(Trouble trouble) &#123;
        return trouble.getNumber() == number;
    &#125;
&#125;</code></pre></div><h2 id="7-制作Support的职责链-制造问题并测试程序行为"><a href="#7-制作Support的职责链-制造问题并测试程序行为" class="headerlink" title="7 - 制作Support的职责链, 制造问题并测试程序行为"></a>7 - 制作Support的职责链, 制造问题并测试程序行为</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        Support alice = new NoSupport(&quot;Alice&quot;);
        Support bob = new LimitSupport(&quot;Bob&quot;, 10);
        Support charlie = new SpecialSupport(&quot;Charlie&quot;, 29);
        Support diana = new LimitSupport(&quot;Diana&quot;, 20);
        Support elmo = new OddSupport(&quot;Elmo&quot;);
        Support fred = new LimitSupport(&quot;Fred&quot;, 30);
        // 形成职责链
        alice.setNext(bob).setNext(charlie).setNext(diana).setNext(elmo).setNext(fred);
        for (int i = 0; i &lt; 50; i++) &#123;
            alice.support(new Trouble(i));
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="8-输出示例"><a href="#8-输出示例" class="headerlink" title="8 - 输出示例"></a>8 - 输出示例</h2><div class="code-wrapper"><pre><code>[Trouble 0] is resolved by [Bob].
[Trouble 1] is resolved by [Bob].
[Trouble 2] is resolved by [Bob].
[Trouble 3] is resolved by [Bob].
[Trouble 4] is resolved by [Bob].
[Trouble 5] is resolved by [Bob].
[Trouble 6] is resolved by [Bob].
[Trouble 7] is resolved by [Bob].
[Trouble 8] is resolved by [Bob].
[Trouble 9] is resolved by [Bob].
[Trouble 10] is resolved by [Diana].
[Trouble 11] is resolved by [Diana].
[Trouble 12] is resolved by [Diana].
[Trouble 13] is resolved by [Diana].
[Trouble 14] is resolved by [Diana].
[Trouble 15] is resolved by [Diana].
[Trouble 16] is resolved by [Diana].
[Trouble 17] is resolved by [Diana].
[Trouble 18] is resolved by [Diana].
[Trouble 19] is resolved by [Diana].
[Trouble 20] is resolved by [Fred].
[Trouble 21] is resolved by [Elmo].
[Trouble 22] is resolved by [Fred].
[Trouble 23] is resolved by [Elmo].
[Trouble 24] is resolved by [Fred].
[Trouble 25] is resolved by [Elmo].
[Trouble 26] is resolved by [Fred].
[Trouble 27] is resolved by [Elmo].
[Trouble 28] is resolved by [Fred].
[Trouble 29] is resolved by [Charlie].
[Trouble 30]cannot be resolved.
[Trouble 31] is resolved by [Elmo].
[Trouble 32]cannot be resolved.
[Trouble 33] is resolved by [Elmo].
[Trouble 34]cannot be resolved.
[Trouble 35] is resolved by [Elmo].
[Trouble 36]cannot be resolved.
[Trouble 37] is resolved by [Elmo].
[Trouble 38]cannot be resolved.
[Trouble 39] is resolved by [Elmo].
[Trouble 40]cannot be resolved.
[Trouble 41] is resolved by [Elmo].
[Trouble 42]cannot be resolved.
[Trouble 43] is resolved by [Elmo].
[Trouble 44]cannot be resolved.
[Trouble 45] is resolved by [Elmo].
[Trouble 46]cannot be resolved.
[Trouble 47] is resolved by [Elmo].
[Trouble 48]cannot be resolved.
[Trouble 49] is resolved by [Elmo].</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaCommand模式</title>
    <url>/2020/10/13/JavaCommand%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  命令也是类</p>
</blockquote>
<h2 id="1-表示”命令”的接口"><a href="#1-表示”命令”的接口" class="headerlink" title="1 - 表示”命令”的接口"></a>1 - 表示”命令”的接口</h2><div class="code-wrapper"><pre><code>public interface Command &#123;
    public abstract void execute();
&#125;</code></pre></div><h2 id="2-表示”由多条命令整合成的命令”的类"><a href="#2-表示”由多条命令整合成的命令”的类" class="headerlink" title="2 - 表示”由多条命令整合成的命令”的类"></a>2 - 表示”由多条命令整合成的命令”的类</h2><div class="code-wrapper"><pre><code>public class MacroCommand implements Command&#123;
    // 命令的集合
    private Stack&lt;Command&gt; commands = new Stack&lt;Command&gt;();

    // 执行
    @Override
    public void execute() &#123;
        for (Object command : commands) &#123;
            ((Command) command).execute();
        &#125;
    &#125;

    // 添加命令
    public void append(Command cmd) &#123;
        if (cmd != this) &#123;
            commands.push(cmd);
        &#125;
    &#125;

    // 删除最后一条命令
    public void undo() &#123;
        if (!commands.empty()) &#123;
            commands.pop();
        &#125;
    &#125;

    // 删除所有命令
    public void clear() &#123;
        commands.clear();
    &#125;
&#125;</code></pre></div><h2 id="3-表示”绘制一个点的命令”的类"><a href="#3-表示”绘制一个点的命令”的类" class="headerlink" title="3 - 表示”绘制一个点的命令”的类"></a>3 - 表示”绘制一个点的命令”的类</h2><div class="code-wrapper"><pre><code>public class DrawCommand implements Command &#123;
    // 绘制对象
    protected Drawable drawable;
    // 绘制位置
    private Point position;

    // 构造函数
    public DrawCommand(Drawable drawable, Point position) &#123;
        this.drawable = drawable;
        this.position = position;
    &#125;

    // 执行
    @Override
    public void execute() &#123;
        drawable.draw(position.x, position.y);
    &#125;

&#125;</code></pre></div><h2 id="4-示”绘制对象”的类"><a href="#4-示”绘制对象”的类" class="headerlink" title="4 - 示”绘制对象”的类"></a>4 - 示”绘制对象”的类</h2><div class="code-wrapper"><pre><code>public interface Drawable &#123;
    public abstract void draw(int x, int y);
&#125;</code></pre></div><h2 id="5-实现”绘制对象”的类"><a href="#5-实现”绘制对象”的类" class="headerlink" title="5 - 实现”绘制对象”的类"></a>5 - 实现”绘制对象”的类</h2><div class="code-wrapper"><pre><code>public class DrawCanvas extends Canvas implements Drawable&#123;
    // 颜色
    private Color color = Color.gray;
    // 命令的历史记录
    private MacroCommand history;

    // 构造函数
    public DrawCanvas(int width, int height, MacroCommand history) &#123;
        setSize(width, height);
        setBackground(Color.white);
        this.history = history;
    &#125;

    // 重新全部绘制
    public void paint(Graphics g) &#123;
        history.execute();
    &#125;

    // 绘制
    @Override
    public void draw(int x, int y) &#123;
        Graphics g = getGraphics();
        g.setColor(color);
        // 要绘制圆点的半径
        int radius = 6;
        g.fillOval(x - radius, y - radius, radius * 2, radius * 2);
    &#125;
&#125;</code></pre></div><h2 id="6-测试程序行为的类"><a href="#6-测试程序行为的类" class="headerlink" title="6 - 测试程序行为的类"></a>6 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>public class Main extends JFrame implements ActionListener, MouseMotionListener, WindowListener&#123;
    // 绘制的历史记录
    private MacroCommand history = new MacroCommand();
    // 绘制区域
    private DrawCanvas canvas = new DrawCanvas(800, 450, history);
    // 删除按钮
    private JButton clearButton = new JButton(&quot;clear&quot;);

    // 构造函数
    public Main(String title) &#123;
        super(title);
        this.addWindowListener(this);
        canvas.addMouseMotionListener(this);
        clearButton.addActionListener(this);

        Box buttonBox = new Box(BoxLayout.X_AXIS);
        buttonBox.add(clearButton);
        Box mainBox = new Box(BoxLayout.Y_AXIS);
        mainBox.add(buttonBox);
        mainBox.add(canvas);
        getContentPane().add(mainBox);

        pack();
        show();
    &#125;

    // ActionListener接口中的方法
    @Override
    public void actionPerformed(ActionEvent e) &#123;
        if (e.getSource() == clearButton) &#123;
            history.clear();
            canvas.repaint();
        &#125;
    &#125;

    // MouseMotionListener接口中的方法
    @Override
    public void mouseDragged(MouseEvent e) &#123;
        Command cmd = new DrawCommand(canvas, e.getPoint());
        history.append(cmd);
        cmd.execute();
    &#125;

    @Override
    public void mouseMoved(MouseEvent mouseEvent) &#123;

    &#125;

    // WindowListener接口中的方法
    @Override
    public void windowOpened(WindowEvent windowEvent) &#123;

    &#125;

    @Override
    public void windowClosing(WindowEvent windowEvent) &#123;
        System.exit(0);
    &#125;

    @Override
    public void windowClosed(WindowEvent windowEvent) &#123;

    &#125;

    @Override
    public void windowIconified(WindowEvent windowEvent) &#123;

    &#125;

    @Override
    public void windowDeiconified(WindowEvent windowEvent) &#123;

    &#125;

    @Override
    public void windowActivated(WindowEvent windowEvent) &#123;

    &#125;

    @Override
    public void windowDeactivated(WindowEvent windowEvent) &#123;

    &#125;

    public static void main(String[] args) &#123;
        new Main(&quot;Command Pattern Sample&quot;);
    &#125;
&#125;</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaComposite模式</title>
    <url>/2020/09/20/JavaComposite%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  容器与内容的一致性</p>
</blockquote>
<h2 id="1-抽象类-用来实现File类和Directory类的一致性"><a href="#1-抽象类-用来实现File类和Directory类的一致性" class="headerlink" title="1- 抽象类, 用来实现File类和Directory类的一致性"></a>1- 抽象类, 用来实现File类和Directory类的一致性</h2><div class="code-wrapper"><pre><code>public abstract class Entry &#123;
    public abstract String getName();   // 获取名字
    public abstract int getSize();      // 获取大小
    public Entry add(Entry entry) throws FileTreateMentException&#123; // 加入条目目录
        throw new FileTreateMentException();
    &#125;

    public void printList()&#123;    // 显示目录条目一览
        printList(&quot;&quot;);
    &#125;

    protected abstract void printList(String prefix);   // 为一览加上前缀
                                                        // 显示条目一览
    @Override                                           // 显示代表类的文字
    public String toString()&#123;
        return getName() + &quot; (&quot; + getSize() + &quot;)&quot;;
    &#125;
&#125;</code></pre></div><h2 id="2-表示文件的类"><a href="#2-表示文件的类" class="headerlink" title="2 - 表示文件的类"></a>2 - 表示文件的类</h2><div class="code-wrapper"><pre><code>public class File extends Entry&#123;
    private String name;
    private int size;

    public File(String name, int size)&#123;
        this.name = name;
        this.size = size;
    &#125;

    @Override
    public String getName() &#123;
        return name;
    &#125;

    @Override
    public int getSize() &#123;
        return size;
    &#125;

    @Override
    protected void printList(String prefix) &#123;
        System.out.println(prefix + &quot;/&quot; + this);
    &#125;
&#125;</code></pre></div><h2 id="3-表示文件夹的类"><a href="#3-表示文件夹的类" class="headerlink" title="3 - 表示文件夹的类"></a>3 - 表示文件夹的类</h2><div class="code-wrapper"><pre><code>public class Directory extends Entry&#123;
    private String name;
    private ArrayList directory = new ArrayList();
    public Directory(String name)&#123;
        this.name = name;
    &#125;

    @Override
    public String getName() &#123;
        return name;
    &#125;

    @Override
    public int getSize() &#123;
        int size = 0;
        Iterator it = directory.iterator();
        while (it.hasNext())&#123;
            Entry entry = (Entry)it.next();
            size += entry.getSize();
        &#125;
        return size;
    &#125;

    public Entry add(Entry entry)&#123;
        directory.add(entry);
        return this;
    &#125;

    @Override
    protected void printList(String prefix) &#123;
        System.out.println(prefix + &quot;/&quot; + this);
        Iterator it = directory.iterator();
        while (it.hasNext())&#123;
            Entry entry = (Entry)it.next();
            entry.printList(prefix + &quot;/&quot; + name);
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="4-表示向文件中增加Entry时发生的异常的类"><a href="#4-表示向文件中增加Entry时发生的异常的类" class="headerlink" title="4 - 表示向文件中增加Entry时发生的异常的类"></a>4 - 表示向文件中增加Entry时发生的异常的类</h2><div class="code-wrapper"><pre><code>public class FileTreateMentException extends RuntimeException&#123;

    public FileTreateMentException()&#123;
    &#125;

    public FileTreateMentException(String msg)&#123;
        super(msg);
    &#125;
&#125;</code></pre></div><h2 id="5-测试程序行为的类"><a href="#5-测试程序行为的类" class="headerlink" title="5 - 测试程序行为的类"></a>5 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        try &#123;
            System.out.println(&quot;Making root entries...&quot;);
            Directory rootDir = new Directory(&quot;root&quot;);
            Directory binDir = new Directory(&quot;bin&quot;);
            Directory tmpDir = new Directory(&quot;tmp&quot;);
            Directory usrDir = new Directory(&quot;usr&quot;);
            rootDir.add(binDir);
            rootDir.add(tmpDir);
            rootDir.add(usrDir);
            binDir.add(new File(&quot;vi&quot;, 10000));
            binDir.add(new File(&quot;latex&quot;, 20000));
            rootDir.printList();

            System.out.println(&quot;&quot;);
            System.out.println(&quot;Making user entries...&quot;);
            Directory yuki = new Directory(&quot;yuki&quot;);
            Directory hanako = new Directory(&quot;hanako&quot;);
            Directory tomura = new Directory(&quot;tomura&quot;);
            usrDir.add(yuki);
            usrDir.add(hanako);
            usrDir.add(tomura);
            yuki.add(new File(&quot;diary.html&quot;, 100));
            yuki.add(new File(&quot;Composite.java&quot;, 200));
            hanako.add(new File(&quot;memo.tex&quot;, 300));
            tomura.add(new File(&quot;game.doc&quot;, 400));
            tomura.add(new File(&quot;junk.mail&quot;, 500));
            rootDir.printList();
        &#125;catch (FileTreateMentException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="6-输出示例"><a href="#6-输出示例" class="headerlink" title="6 - 输出示例"></a>6 - 输出示例</h2><div class="code-wrapper"><pre><code>Making root entries...
/root (30000)
/root/bin (30000)
/root/bin/vi (10000)
/root/bin/latex (20000)
/root/tmp (0)
/root/usr (0)

Making user entries...
/root (31500)
/root/bin (30000)
/root/bin/vi (10000)
/root/bin/latex (20000)
/root/tmp (0)
/root/usr (1500)
/root/usr/yuki (300)
/root/usr/yuki/diary.html (100)
/root/usr/yuki/Composite.java (200)
/root/usr/hanako (300)
/root/usr/hanako/memo.tex (300)
/root/usr/tomura (900)
/root/usr/tomura/game.doc (400)
/root/usr/tomura/junk.mail (500)</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaFlyweight模式</title>
    <url>/2020/10/08/JavaFlyweight%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  共享对象,避免浪费</p>
</blockquote>
<h2 id="1-表示”大型字符”的类"><a href="#1-表示”大型字符”的类" class="headerlink" title="1 - 表示”大型字符”的类"></a>1 - 表示”大型字符”的类</h2><div class="code-wrapper"><pre><code>public class BigChar &#123;
    // 字符名字
    private char charName;
    // 大型字符对应的字符串(由&apos;#&apos;&apos;.&apos;&apos;\n&apos;组成)
    private String fontData;

    private String filePath = &quot;大型字符文件路径&quot;;

    // 构造函数
    public BigChar(char charName) &#123;
        this.charName = charName;

        try &#123;
            BufferedReader reader = new BufferedReader(
                    new FileReader(filePath+ &quot;big&quot; + charName + &quot;.txt&quot;)
            );
            String line;
            StringBuffer buf = new StringBuffer();
            while ((line = reader.readLine()) != null) &#123;
                buf.append(line);
                buf.append(&quot;\n&quot;);
            &#125;
            reader.close();
            this.fontData = buf.toString();
        &#125;catch (IOException e)&#123;
            this.fontData = charName + &quot;?&quot;;
            e.printStackTrace();
        &#125;
    &#125;

    // 显示大型字符
    public void print() &#123;
        System.out.println(fontData);
    &#125;
&#125;</code></pre></div><p>需要提前准备大型字符文件<br>例如字符’1’ ,文件名以”big1.txt”为标准</p>
<div class="code-wrapper"><pre><code>..................
........##........
....######........
........##........
........##........
........##........
........##........
..##############..
..................</code></pre></div><h2 id="2-表示生成和共用BigChar类的实例的类"><a href="#2-表示生成和共用BigChar类的实例的类" class="headerlink" title="2 - 表示生成和共用BigChar类的实例的类"></a>2 - 表示生成和共用BigChar类的实例的类</h2><div class="code-wrapper"><pre><code>public class BigCharFactory &#123;
    // 管理已经生成的BigChar的实例
    private HashMap&lt;String, BigChar&gt; pool = new HashMap&lt;&gt;();

    // Singleton模式
    private static BigCharFactory singleton = new BigCharFactory();

    // 构造函数
    private BigCharFactory() &#123;&#125;

    // 获取唯一实例
    public static BigCharFactory getInstance() &#123;
        return singleton;
    &#125;

    // 生成(共享)BigChar类的实例
    public synchronized BigChar getBigChar(char charName) &#123;
        BigChar bc = pool.get(&quot;&quot; + charName);
        if (bc == null) &#123;
            bc = new BigChar(charName);
            pool.put(&quot;&quot; + charName, bc);
        &#125;
        return bc;
    &#125;
&#125;</code></pre></div><h2 id="3-表示多个BigChar组成的”大型字符串”的类"><a href="#3-表示多个BigChar组成的”大型字符串”的类" class="headerlink" title="3 - 表示多个BigChar组成的”大型字符串”的类"></a>3 - 表示多个BigChar组成的”大型字符串”的类</h2><div class="code-wrapper"><pre><code>public class BigString &#123;
    // &quot;大型字符&quot;的数组
    private BigChar[] bigChars;

    // 构造函数
    public BigString(String string) &#123;
        bigChars = new BigChar[string.length()];
        BigCharFactory factory = BigCharFactory.getInstance();
        for (int i = 0; i &lt; bigChars.length; i++) &#123;
            bigChars[i] = factory.getBigChar(string.charAt(i));
        &#125;
    &#125;

    // 显示
    public void print() &#123;
        for (BigChar bigChar : bigChars) &#123;
            bigChar.print();
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="4-测试程序行为的类"><a href="#4-测试程序行为的类" class="headerlink" title="4 - 测试程序行为的类"></a>4 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        if (args.length == 0) &#123;
            System.out.println(&quot;Usage: java Main digits&quot;);
            System.out.println(&quot;Example: java Main 1212123&quot;);
            System.exit(0);
        &#125;

        BigString bs = new BigString(args[0]);
        bs.print();
    &#125;
&#125;</code></pre></div><p>需要提前设置参数 args[0] = ‘12123’</p>
<h2 id="5-输出示例"><a href="#5-输出示例" class="headerlink" title="5 - 输出示例"></a>5 - 输出示例</h2><div class="code-wrapper"><pre><code>..................
........##........
....######........
........##........
........##........
........##........
........##........
..##############..
..................

...................
....########.......
..##.........###...
............###....
..........###......
........###........
......###..........
....###............
..#############....
...................

..................
........##........
....######........
........##........
........##........
........##........
........##........
..##############..
..................

...................
....########.......
..##.........###...
............###....
..........###......
........###........
......###..........
....###............
..#############....
...................

..................
....#######.......
..##.......##.....
............##....
....#######.......
............##....
..##.......##.....
....######........
..................</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaFacade模式</title>
    <url>/2020/09/25/JavaFacade%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  简单窗口</p>
</blockquote>
<h2 id="1-从邮件地址中获取用户名的类"><a href="#1-从邮件地址中获取用户名的类" class="headerlink" title="1- 从邮件地址中获取用户名的类"></a>1- 从邮件地址中获取用户名的类</h2><div class="code-wrapper"><pre><code>// 需要配置相应的数据库
public class Database &#123;
    private Database() &#123;    // 防止外部new出Database的实例,所以声明为private
    &#125;

    public static Properties getProperties(String dbname)&#123;  // 根据数据库名获取Properties
        String filename = dbname + &quot;.txt&quot;;
        Properties prop = new Properties();
        try &#123;
            prop.load(new FileInputStream(filename));
        &#125;catch (IOException e)&#123;
            System.out.println(&quot;Warning: &quot; + filename + &quot; is not found.&quot;);
        &#125;
        return prop;
    &#125;
&#125;</code></pre></div><h2 id="2-编写HTML文件的类"><a href="#2-编写HTML文件的类" class="headerlink" title="2 - 编写HTML文件的类"></a>2 - 编写HTML文件的类</h2><div class="code-wrapper"><pre><code>public class HtmlWriter &#123;
    private Writer writer;
    public HtmlWriter(Writer writer)&#123;
        this.writer = writer;
    &#125;

    public void title(String title) throws IOException&#123;
        writer.write(&quot;&lt;html&gt;&quot;);
        writer.write(&quot;&lt;head&gt;&quot;);
        writer.write(&quot;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&quot;);
        writer.write(&quot;&lt;/head&gt;&quot;);
        writer.write(&quot;&lt;body&gt;\n&quot;);
        writer.write(&quot;&lt;h1&gt;&quot; + title + &quot;&lt;/h1&gt;&quot;);
    &#125;

    public void paragraph(String msg) throws IOException&#123;
        writer.write(&quot;&lt;p&gt;&quot; + msg + &quot;&lt;/p&gt;\n&quot;);
    &#125;

    public void link(String href, String caption) throws IOException&#123;
        paragraph(&quot;&lt;a href=\&quot;&quot; + href + &quot;\&quot;&gt;&quot; + caption + &quot;&lt;/a&gt;&quot;);
    &#125;

    public void mailto(String mailAddr, String userName) throws IOException&#123;
        link(&quot;mailto: &quot; + mailAddr, userName);
    &#125;

    public void close() throws IOException&#123;
        writer.write(&quot;&lt;/body&gt;&quot;);
        writer.write(&quot;&lt;/html&gt;&quot;);
        writer.close();
    &#125;
&#125;</code></pre></div><h2 id="3-根据邮件地址编写该用户的Web页面"><a href="#3-根据邮件地址编写该用户的Web页面" class="headerlink" title="3 - 根据邮件地址编写该用户的Web页面"></a>3 - 根据邮件地址编写该用户的Web页面</h2><div class="code-wrapper"><pre><code>public class PageMaker &#123;
    private PageMaker() &#123;    // 防止外部new出PageMaker的实例,所以声明为private
    &#125;

    public static void makeWelcomePage(String mailAddr, String filename)&#123;
        try &#123;
            Properties mailProp = Database.getProperties(&quot;mailData&quot;);
            String userName = mailProp.getProperty(mailAddr);
            HtmlWriter writer = new HtmlWriter(new FileWriter(filename));
            writer.title(&quot;Welcome to &quot; + userName + &quot;`s page!&quot;);
            writer.paragraph(userName + &quot;欢迎来到&quot; + userName + &quot;的主页&quot;);
            writer.paragraph(&quot;等着你的邮件哦!&quot;);
            writer.mailto(mailAddr, userName);
            writer.close();
            System.out.println(filename + &quot; is created for &quot; + mailAddr + &quot; (&quot; +
                    userName + &quot;)&quot;);
        &#125;catch (IOException e)&#123;
            e.printStackTrace();
        &#125;

    &#125;
&#125;</code></pre></div><h2 id="4-测试程序行为的类"><a href="#4-测试程序行为的类" class="headerlink" title="4 - 测试程序行为的类"></a>4 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        PageMaker.makeWelcomePage(&quot;hyuki@hyuki.com&quot;, &quot;welcome.html&quot;);
    &#125;
&#125;</code></pre></div><h2 id="5-输出示例"><a href="#5-输出示例" class="headerlink" title="5 - 输出示例"></a>5 - 输出示例</h2><html><head><title>Welcome to Hiroshi Yuki`s page!</title></head><body>
<h1>Welcome to Hiroshi Yuki`s page!</h1><p>null欢迎来到null的主页</p>
<p>等着你的邮件哦!</p>
<p><a href="mailto: hyuki@hyuki.com">Hiroshi Yuki</a></p>
</body></html>

<div class="code-wrapper"><pre><code>// HTML源码
&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to Hiroshi Yuki`s page!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to Hiroshi Yuki`s page!&lt;/h1&gt;
&lt;p&gt;null欢迎来到null的主页&lt;/p&gt;
&lt;p&gt;等着你的邮件哦!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;mailto: hyuki@hyuki.com&quot;&gt;Hiroshi Yuki&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaInterpreter模式</title>
    <url>/2020/10/16/JavaInterpreter%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  语法规则也是类</p>
</blockquote>
<h2 id="1-表示语法树”节点”的类"><a href="#1-表示语法树”节点”的类" class="headerlink" title="1 - 表示语法树”节点”的类"></a>1 - 表示语法树”节点”的类</h2><div class="code-wrapper"><pre><code>public abstract class Node &#123;
    public abstract void parse(Context context) throws ParseException;
&#125;</code></pre></div><h2 id="2-对应program的类"><a href="#2-对应program的类" class="headerlink" title="2 - 对应program的类"></a>2 - 对应program的类</h2><div class="code-wrapper"><pre><code>// &lt;program&gt; ::= program &lt;command list&gt;
public class ProgramNode extends Node&#123;
    private Node commandListNode;

    @Override
    public void parse(Context context) throws ParseException &#123;
        context.skipToken(&quot;program&quot;);
        commandListNode = new CommandListNode();
        commandListNode.parse(context);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;[program &quot; + commandListNode + &quot;]&quot;;
    &#125;
&#125;</code></pre></div><h2 id="3-对应command-List的类"><a href="#3-对应command-List的类" class="headerlink" title="3 - 对应command List的类"></a>3 - 对应command List的类</h2><div class="code-wrapper"><pre><code>// &lt;command list&gt; ::= &lt;command&gt;* end
public class CommandListNode extends Node&#123;
    private ArrayList&lt;Node&gt; list = new ArrayList&lt;&gt;();

    @Override
    public void parse(Context context) throws ParseException &#123;
        while (true) &#123;
            if (context.CurrentToken() == null) &#123;
                throw new ParseException(&quot;Missing &apos;end&apos;&quot;);
            &#125; else if (context.CurrentToken().equals(&quot;end&quot;)) &#123;
                context.skipToken(&quot;end&quot;);
                break;
            &#125; else &#123;
                Node commandNode = new CommandNode();
                commandNode.parse(context);
                list.add(commandNode);
            &#125;
        &#125;
    &#125;

    @Override
    public String toString() &#123;
        return list.toString();
    &#125;
&#125;</code></pre></div><h2 id="4-对应command的类"><a href="#4-对应command的类" class="headerlink" title="4 - 对应command的类"></a>4 - 对应command的类</h2><div class="code-wrapper"><pre><code>// &lt;command&gt; ::= &lt;repeat command&gt; | &lt;primitive command&gt;
public class CommandNode extends Node&#123;
    private Node node;

    @Override
    public void parse(Context context) throws ParseException &#123;
        if (context.CurrentToken().equals(&quot;repeat&quot;))&#123;
            node = new RepeatCommandNode();
            node.parse(context);
        &#125; else &#123;
            node = new PrimitiveCommandNode();
            node.parse(context);
        &#125;
    &#125;

    @Override
    public String toString() &#123;
        return node.toString();
    &#125;
&#125;</code></pre></div><h2 id="5-对应repeat-command的类"><a href="#5-对应repeat-command的类" class="headerlink" title="5 - 对应repeat command的类"></a>5 - 对应repeat command的类</h2><div class="code-wrapper"><pre><code>// &lt;repeat command&gt; ::= repeat &lt;number&gt; &lt;command list&gt;
public class RepeatCommandNode extends Node&#123;
    private int number;
    private Node commandListNode;

    @Override
    public void parse(Context context) throws ParseException &#123;
        context.skipToken(&quot;repeat&quot;);
        number = context.currentNumber();
        context.nextToken();
        commandListNode = new CommandListNode();
        commandListNode.parse(context);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;[repeat &quot; + number + &quot; &quot; + commandListNode + &quot;]&quot;;
    &#125;
&#125;</code></pre></div><h2 id="6-对应primitive-command的类"><a href="#6-对应primitive-command的类" class="headerlink" title="6 - 对应primitive command的类"></a>6 - 对应primitive command的类</h2><div class="code-wrapper"><pre><code>// &lt;primitive command&gt; ::= go | right | left
public class PrimitiveCommandNode extends Node&#123;
    private String name;

    @Override
    public void parse(Context context) throws ParseException &#123;
        name = context.CurrentToken();
        context.skipToken(name);
        if (!name.equals(&quot;go&quot;) &amp;&amp; !name.equals(&quot;right&quot;) &amp;&amp; !name.equals(&quot;left&quot;)) &#123;
            throw new ParseException(name + &quot;is undefined&quot;);
        &#125;
    &#125;

    @Override
    public String toString() &#123;
        return name;
    &#125;
&#125;</code></pre></div><h2 id="7-表示语法解析上下文的类"><a href="#7-表示语法解析上下文的类" class="headerlink" title="7 - 表示语法解析上下文的类"></a>7 - 表示语法解析上下文的类</h2><div class="code-wrapper"><pre><code>public class Context &#123;
    private StringTokenizer tokenizer;
    private String currentToken;

    public Context(String text) &#123;
        tokenizer = new StringTokenizer(text);
        nextToken();
    &#125;

    public void nextToken() &#123;
        if (tokenizer.hasMoreElements()) &#123;
            currentToken = tokenizer.nextToken();
        &#125; else &#123;
            currentToken = null;
        &#125;
    &#125;

    public String CurrentToken() &#123;
        return currentToken;
    &#125;

    public void skipToken(String token) throws ParseException &#123;
        if (!token.equals(currentToken)) &#123;
            throw new ParseException(&quot;Warning: &quot; + token +
                    &quot; is expected, but &quot; + currentToken + &quot; is found.&quot;);
        &#125;
        nextToken();
    &#125;

    public int currentNumber() throws ParseException &#123;
        int number = 0;
        try &#123;
            number = Integer.parseInt(currentToken);
        &#125; catch (NumberFormatException e) &#123;
            throw new ParseException(&quot;Warning: &quot; + e);
        &#125;
        return number;
    &#125;
&#125;</code></pre></div><h2 id="8-表示语法解析中可能会发生的异常的类"><a href="#8-表示语法解析中可能会发生的异常的类" class="headerlink" title="8 -表示语法解析中可能会发生的异常的类"></a>8 -表示语法解析中可能会发生的异常的类</h2><div class="code-wrapper"><pre><code>public class ParseException extends Exception&#123;
    public ParseException(String msg) &#123;
        super(msg);
    &#125;
&#125;</code></pre></div><h2 id="9-测试程序行为的类"><a href="#9-测试程序行为的类" class="headerlink" title="9 - 测试程序行为的类"></a>9 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        String filePath = &quot;Program文件路径&quot;;
        try &#123;
            BufferedReader reader = new BufferedReader(new FileReader(filePath + &quot;Program.txt&quot;));
            String text;
            while ((text = reader.readLine()) != null) &#123;
                System.out.println(&quot;text =\&quot;&quot; + text + &quot;\&quot;&quot;);
                Node node = new ProgramNode();
                node.parse(new Context(text));
                System.out.println(&quot;node = &quot; +node);
            &#125;
            reader.close();
        &#125; catch (IOException | ParseException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="10-输出示例"><a href="#10-输出示例" class="headerlink" title="10 - 输出示例"></a>10 - 输出示例</h2><div class="code-wrapper"><pre><code>text =&quot;program end&quot;
node = [program []]
text =&quot;program go end&quot;
node = [program [go]]
text =&quot;program go right go right go right go right end&quot;
node = [program [go, right, go, right, go, right, go, right]]
text =&quot;program repeat 4 go right end end&quot;
node = [program [[repeat 4 [go, right]]]]
text =&quot;program repeat 4 repeat 3 go right go left end right end end&quot;
node = [program [[repeat 4 [[repeat 3 [go, right, go, left]], right]]]]</code></pre></div><h2 id="11-Program-txt"><a href="#11-Program-txt" class="headerlink" title="11 - Program.txt"></a>11 - Program.txt</h2><div class="code-wrapper"><pre><code>program end
program go end
program go right go right go right go right end
program repeat 4 go right end end
program repeat 4 repeat 3 go right go left end right end end</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaMediator模式</title>
    <url>/2020/09/26/JavaMediator%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  只有一个仲裁者</p>
</blockquote>
<h2 id="1-定义”仲裁者”的接口-API-的接口"><a href="#1-定义”仲裁者”的接口-API-的接口" class="headerlink" title="1 - 定义”仲裁者”的接口(API)的接口"></a>1 - 定义”仲裁者”的接口(API)的接口</h2><div class="code-wrapper"><pre><code>public interface Mediator &#123;
    public abstract void createColleagues();
    public abstract void colleagueChanged();
&#125;</code></pre></div><h2 id="2-定义”组员”的接口-API-的接口"><a href="#2-定义”组员”的接口-API-的接口" class="headerlink" title="2 - 定义”组员”的接口(API)的接口"></a>2 - 定义”组员”的接口(API)的接口</h2><div class="code-wrapper"><pre><code>public interface Colleague &#123;
    public abstract void setMediator(Mediator mediator);
    public abstract void setColleagueEnabled(boolean enabled);
&#125;</code></pre></div><h2 id="3-表示按钮的类-它实现了Colleague接口"><a href="#3-表示按钮的类-它实现了Colleague接口" class="headerlink" title="3 - 表示按钮的类, 它实现了Colleague接口"></a>3 - 表示按钮的类, 它实现了Colleague接口</h2><div class="code-wrapper"><pre><code>public class ColleagueButton extends Button implements Colleague &#123;
    private Mediator mediator;

    public ColleagueButton(String caption) &#123;
        super(caption);
    &#125;

    @Override
    public void setMediator(Mediator mediator) &#123;    // 保存Mediator
        this.mediator = mediator;
    &#125;

    @Override
    public void setColleagueEnabled(boolean enabled) &#123;  // Mediator 下达启用/禁用的指示
        setEnabled(enabled);
    &#125;
&#125;</code></pre></div><h2 id="4-表示文本输入框的类-它实现了Colleague接口"><a href="#4-表示文本输入框的类-它实现了Colleague接口" class="headerlink" title="4 - 表示文本输入框的类, 它实现了Colleague接口"></a>4 - 表示文本输入框的类, 它实现了Colleague接口</h2><div class="code-wrapper"><pre><code>public class ColleagueTextField extends TextField implements TextListener, Colleague &#123;
    private Mediator mediator;

    public ColleagueTextField(String text, int columns)&#123;
        super(text, columns);
    &#125;

    @Override
    public void textValueChanged(TextEvent textEvent) &#123; // 当文字发生改变时通知Mediator
        mediator.colleagueChanged();
    &#125;

    @Override
    public void setMediator(Mediator mediator) &#123;
        this.mediator = mediator;
    &#125;

    @Override
    public void setColleagueEnabled(boolean enabled) &#123;  // Mediator 下达启用/禁用的指示
        setEnabled(enabled);
        setBackground(enabled ? Color.white : Color.lightGray);
    &#125;
&#125;</code></pre></div><h2 id="5-表示勾选框-此处是单按钮-的类-它实现了Colleague接口"><a href="#5-表示勾选框-此处是单按钮-的类-它实现了Colleague接口" class="headerlink" title="5 - 表示勾选框(此处是单按钮)的类, 它实现了Colleague接口"></a>5 - 表示勾选框(此处是单按钮)的类, 它实现了Colleague接口</h2><div class="code-wrapper"><pre><code>public class ColleagueCheckbox extends Checkbox implements ItemListener, Colleague &#123;
    private Mediator mediator;

    public ColleagueCheckbox(String caption, CheckboxGroup group, boolean state) &#123;
        super(caption, group, state);
    &#125;

    @Override
    public void itemStateChanged(ItemEvent itemEvent) &#123; // 当状态发生改变时通知Mediator
        mediator.colleagueChanged();
    &#125;

    @Override
    public void setMediator(Mediator mediator) &#123;
        this.mediator = mediator;
    &#125;

    @Override
    public void setColleagueEnabled(boolean enabled) &#123;  // Mediator 下达启用/禁用的指示
        setEnabled(enabled);
    &#125;
&#125;</code></pre></div><h2 id="6-表示登录对话框的类-它实现了Mediator接口"><a href="#6-表示登录对话框的类-它实现了Mediator接口" class="headerlink" title="6 - 表示登录对话框的类, 它实现了Mediator接口"></a>6 - 表示登录对话框的类, 它实现了Mediator接口</h2><div class="code-wrapper"><pre><code>public class LoginFrame extends Frame implements ActionListener, Mediator &#123;
    private ColleagueCheckbox checkGuest;
    private ColleagueCheckbox checkLogin;
    private ColleagueTextField textUser;
    private ColleagueTextField textPass;
    private ColleagueButton buttonOk;
    private ColleagueButton buttonCancel;

    // 构造函数
    // 生成并配置各个Colleague后,显示对话框
    public  LoginFrame(String title) &#123;
        super(title);
        setBackground(Color.LIGHT_GRAY);
        // 使用布局管理器生成4x2的窗格
        setLayout(new GridLayout(4, 2));
        // 生成各个Colleague
        createColleagues();
        // 配置
        add(checkGuest);
        add(checkLogin);
        add(new Label(&quot;Username:&quot;));
        add(textUser);
        add(new Label(&quot;Password&quot;));
        add(textPass);
        add(buttonOk);
        add(buttonCancel);
        // 设置初始的启用/禁用状态
        colleagueChanged();
        // 显示
        pack();
        show();
    &#125;

    @Override
    public void actionPerformed(ActionEvent actionEvent) &#123;
        System.out.println(actionEvent.toString());
        System.exit(0);
    &#125;

    // 生成各个Colleague
    @Override
    public void createColleagues() &#123;
        // 生成
        CheckboxGroup g = new CheckboxGroup();
        checkGuest = new ColleagueCheckbox(&quot;Guest&quot;, g, true);
        checkLogin = new ColleagueCheckbox(&quot;Login&quot;, g, false);
        textUser = new ColleagueTextField(&quot;&quot;, 10);
        textPass = new ColleagueTextField(&quot;&quot;, 10);
        textPass.setEchoChar(&apos;*&apos;);
        buttonOk = new ColleagueButton(&quot;OK&quot;);
        buttonCancel = new ColleagueButton(&quot;Cancel&quot;);
        // 设置Mediator
        checkGuest.setMediator(this);
        checkLogin.setMediator(this);
        textUser.setMediator(this);
        textPass.setMediator(this);
        buttonOk.setMediator(this);
        buttonCancel.setMediator(this);
        // 设置Listener
        checkGuest.addItemListener(checkGuest);
        checkLogin.addItemListener(checkLogin);
        textUser.addTextListener(textUser);
        textPass.addTextListener(textPass);
        buttonOk.addActionListener(this);
        buttonCancel.addActionListener(this);

    &#125;

    // 接收来自于Colleague的通知然后判断个Colleague的启用/禁用状态
    @Override
    public void colleagueChanged() &#123;
        if(checkGuest.getState()) &#123;
            textUser.setColleagueEnabled(false);
            textPass.setColleagueEnabled(false);
            buttonOk.setColleagueEnabled(true);
        &#125;else &#123;
            textUser.setColleagueEnabled(true);
            underpassChanged();
        &#125;
    &#125;

    // 当textUser或textPass文本输入框中的文字发生变化时
    // 判断Colleague的启用/禁用状态
    public void underpassChanged() &#123;
        if (textUser.getText().length() &gt; 0) &#123;
            textPass.setColleagueEnabled(true);
            if (textPass.getText().length() &gt; 0) &#123;
                buttonOk.setColleagueEnabled(true);
            &#125; else &#123;
                buttonOk.setColleagueEnabled(false);
            &#125;
        &#125; else &#123;
            textPass.setColleagueEnabled(false);
            buttonOk.setColleagueEnabled(false);
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="7-表示测试程序行为的类"><a href="#7-表示测试程序行为的类" class="headerlink" title="7 - 表示测试程序行为的类"></a>7 - 表示测试程序行为的类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        new LoginFrame(&quot;Mediator Sample&quot;);
    &#125;
&#125;</code></pre></div><h2 id="8-输出示例"><a href="#8-输出示例" class="headerlink" title="8 - 输出示例"></a>8 - 输出示例</h2><div class="code-wrapper"><pre><code>// 具体见窗口
java.awt.event.ActionEvent[ACTION_PERFORMED,cmd=OK,
when=1601126737494,modifiers=] on button0</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaMemento模式</title>
    <url>/2020/09/29/JavaMemento%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  保存对象状态</p>
</blockquote>
<h2 id="1-表示Gamer状态的类"><a href="#1-表示Gamer状态的类" class="headerlink" title="1 - 表示Gamer状态的类"></a>1 - 表示Gamer状态的类</h2><div class="code-wrapper"><pre><code>public class Memento &#123;
    int money;  // 所持金钱
    ArrayList fruits;   // 获得的水果

    public int getMoney() &#123; // 获取当前所持有的金钱(narrow interface)
        return money;
    &#125;

    Memento(int money) &#123;    // 构造函数
        this.money = money;
        this.fruits = new ArrayList();
    &#125;

    void addFruits(String fruit) &#123;  // 添加水果
        fruits.add(fruit);
    &#125;

    List getFruits() &#123;  // 获取当前所持有的所有水果(wide interface)
        return (List)fruits.clone();
    &#125;
&#125;</code></pre></div><h2 id="2-表示游戏主人公的类-它会生成Memento的实例"><a href="#2-表示游戏主人公的类-它会生成Memento的实例" class="headerlink" title="2 - 表示游戏主人公的类.它会生成Memento的实例"></a>2 - 表示游戏主人公的类.它会生成Memento的实例</h2><div class="code-wrapper"><pre><code>public class Gamer &#123;
    private int money;  //  所持金钱
    private List fruits = new ArrayList&lt;&gt;();  // 获得的水果
    private Random random = new Random();   // 随机数生成器
    private static String [] fruitsName = &#123; // 表示水果种类的数组
            &quot;苹果&quot;, &quot;葡萄&quot;, &quot;香蕉&quot;, &quot;橘子&quot;,
    &#125;;

    public Gamer(int money) &#123;
        this.money = money;
    &#125;

    public int getMoney() &#123;
        return money;
    &#125;

    public void bet() &#123;         // 投掷骰子进行游戏
        int dice = random.nextInt(6) + 1;   // 骰子结果为1时,增加所持有的金钱.
        if(dice == 1) &#123;
            money += 100;
            System.out.println(&quot;所持金钱增加了.&quot;);
        &#125; else if (dice == 2) &#123; // 骰子结果为2时,所持金钱减半.
            money /= 2;
            System.out.println(&quot;所持金钱减半了.&quot;);
        &#125; else if (dice == 6) &#123; // 骰子结果为6时,获得水果
            String f = getFruit();
            System.out.println(&quot;获得了水果 (&quot; + f + &quot;).&quot;);
            fruits.add(f);
        &#125; else &#123;    // 骰子结果为3,4,5则什么都不会发生
            System.out.println(&quot;什么都没有发生&quot;);
        &#125;
    &#125;

    public Memento createMemento() &#123;    // 拍摄快照
        Memento m = new Memento(money);
        for (Object fruit : fruits) &#123;
            String f = (String) fruit;
            if (f.startsWith(&quot;好吃的&quot;)) &#123;  // 只保存好吃的水果
                m.addFruits((String) f);
            &#125;
        &#125;
        return m;
    &#125;

    public void restoreMemento(Memento memento) &#123;   // 撤销
        this.money = memento.money;
        this.fruits = memento.getFruits();
    &#125;

    @Override
    public String toString() &#123;
        return &quot;[money = &quot; + money + &quot;,fruits = &quot; + fruits + &quot;]&quot;;
    &#125;

    private String getFruit() &#123;
        String prefix = &quot;&quot;;
        if (random.nextBoolean()) &#123;
            prefix = &quot;好吃的&quot;;
        &#125;
        return prefix + fruitsName[random.nextInt(fruitsName.length)];
    &#125;
&#125;</code></pre></div><h2 id="3-进行游戏的类-它会事先保存Memento的实例-之后会根据需要恢复Gamer的状态"><a href="#3-进行游戏的类-它会事先保存Memento的实例-之后会根据需要恢复Gamer的状态" class="headerlink" title="3 - 进行游戏的类.它会事先保存Memento的实例, 之后会根据需要恢复Gamer的状态"></a>3 - 进行游戏的类.它会事先保存Memento的实例, 之后会根据需要恢复Gamer的状态</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        Gamer gamer = new Gamer(100);   // 最初的金钱数为100
        Memento memento = gamer.createMemento();    // 保存最初的状态
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(&quot;===&quot; + i);  // 显示掷骰子的次数
            System.out.println(&quot;当前状态: &quot; + gamer);   // 显示主人公当前的状态

            gamer.bet();    // 进行游戏

            System.out.println(&quot;所持金钱为&quot; + gamer.getMoney() + &quot;元&quot;);
            // 决定如何处理Memento
            if (gamer.getMoney() &gt; memento.getMoney()) &#123;
                System.out.println(&quot;    (所持金钱增加了许多,因此保存游戏当前的状态)&quot;);
                memento = gamer.createMemento();
            &#125; else if (gamer.getMoney() &lt; memento.getMoney() / 2) &#123;
                System.out.println(&quot;   (所持金钱减少了许多,因此将游戏恢复至以前的状态)&quot;);
                gamer.restoreMemento(memento);
            &#125;

            // 等待一段时间
            try &#123;
                Thread.sleep(1000);
            &#125;catch (InterruptedException ignored) &#123;
            &#125;
            System.out.println(&quot;&quot;);
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="4-输出示例"><a href="#4-输出示例" class="headerlink" title="4 - 输出示例"></a>4 - 输出示例</h2><div class="code-wrapper"><pre><code>===0
当前状态: [money = 100,fruits = []]
什么都没有发生
所持金钱为100元

===1
当前状态: [money = 100,fruits = []]
所持金钱减半了.
所持金钱为50元

===2
当前状态: [money = 50,fruits = []]
什么都没有发生
所持金钱为50元

===3
当前状态: [money = 50,fruits = []]
所持金钱增加了.
所持金钱为150元
    (所持金钱增加了许多,因此保存游戏当前的状态)

===4
当前状态: [money = 150,fruits = []]
所持金钱增加了.
所持金钱为250元
    (所持金钱增加了许多,因此保存游戏当前的状态)

===5
当前状态: [money = 250,fruits = []]
什么都没有发生
所持金钱为250元

===6
当前状态: [money = 250,fruits = []]
什么都没有发生
所持金钱为250元

===7
当前状态: [money = 250,fruits = []]
所持金钱减半了.
所持金钱为125元

===8
当前状态: [money = 125,fruits = []]
获得了水果(好吃的苹果).
所持金钱为125元

===9
当前状态: [money = 125,fruits = [好吃的苹果]]
什么都没有发生
所持金钱为125元

===10
当前状态: [money = 125,fruits = [好吃的苹果]]
所持金钱减半了.
所持金钱为62元
(所持金钱减少了许多,因此将游戏恢复至以前的状态)

省略
===49
当前状态: [money = 525,fruits = [好吃的橘子, 橘子]]
什么都没有发生
所持金钱为525元

===50
当前状态: [money = 525,fruits = [好吃的橘子, 橘子]]
所持金钱减半了.
所持金钱为262元
(所持金钱减少了许多,因此将游戏恢复至以前的状态)

===51</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaObserver模式</title>
    <url>/2020/09/28/JavaObserver%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  发送状态变化通知</p>
</blockquote>
<h2 id="1-表示观察者的接口"><a href="#1-表示观察者的接口" class="headerlink" title="1 - 表示观察者的接口"></a>1 - 表示观察者的接口</h2><div class="code-wrapper"><pre><code>public interface Observer &#123;
    public abstract void update(NumberGenerator generator);
&#125;</code></pre></div><h2 id="2-表示生成数值的对象的抽象类"><a href="#2-表示生成数值的对象的抽象类" class="headerlink" title="2 - 表示生成数值的对象的抽象类"></a>2 - 表示生成数值的对象的抽象类</h2><div class="code-wrapper"><pre><code>public abstract class NumberGenerator &#123;
    private ArrayList observers = new ArrayList();  // 保存Observer们

    public void addObserver(Observer observer) &#123;    // 注册Observer
        observers.add(observer);
    &#125;

    public void deleteObserver(Observer observer) &#123;    // 删除Observer
        observers.remove(observer);
    &#125;

    public void notifyObservers() &#123;    // 向Observer发送通知
        for (Object value : observers) &#123;
            Observer o = (Observer) value;
            o.update(this);
        &#125;
    &#125;

    public abstract int getNumber();    // 获取数值
    public abstract void execute();     // 生成数值
&#125;</code></pre></div><h2 id="3-表示生成随机数的类"><a href="#3-表示生成随机数的类" class="headerlink" title="3 - 表示生成随机数的类"></a>3 - 表示生成随机数的类</h2><div class="code-wrapper"><pre><code>public class RandomNumberGenerator extends NumberGenerator&#123;
    private Random random = new Random();   // 随机数生成器
    private int number;     // 当前数值

    @Override
    public int getNumber() &#123;
        return number;
    &#125;

    @Override
    public void execute() &#123;
        for (int i = 0; i &lt; 20; i++) &#123;
            number = random.nextInt(50);
            notifyObservers();
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="4-表示以数字形式显示数值的类"><a href="#4-表示以数字形式显示数值的类" class="headerlink" title="4 - 表示以数字形式显示数值的类"></a>4 - 表示以数字形式显示数值的类</h2><div class="code-wrapper"><pre><code>public class DigitObserver implements Observer&#123;
    @Override
    public void update(NumberGenerator generator) &#123;
        System.out.println(&quot;DigitObserver: &quot; + generator.getNumber());
        try &#123;
            Thread.sleep(100);
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="5-表示以简单的图形显示数值的类"><a href="#5-表示以简单的图形显示数值的类" class="headerlink" title="5 - 表示以简单的图形显示数值的类"></a>5 - 表示以简单的图形显示数值的类</h2><div class="code-wrapper"><pre><code>public class GraphObserver implements Observer&#123;
    @Override
    public void update(NumberGenerator generator) &#123;
        System.out.print(&quot;GraphObserver: &quot;);
        int count = generator.getNumber();
        for (int i = 0; i &lt; count; i++) &#123;
            System.out.print(&apos;*&apos;);
        &#125;
        System.out.println();
        try &#123;
            Thread.sleep(100);
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="6-测试程序行为的类"><a href="#6-测试程序行为的类" class="headerlink" title="6 - 测试程序行为的类"></a>6 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        NumberGenerator generator = new RandomNumberGenerator();
        Observer observer1 = new DigitObserver();
        Observer observer2 = new GraphObserver();
        generator.addObserver(observer1);
        generator.addObserver(observer2);
        generator.execute();
    &#125;
&#125;</code></pre></div><h2 id="7-输出示例"><a href="#7-输出示例" class="headerlink" title="7 - 输出示例"></a>7 - 输出示例</h2><div class="code-wrapper"><pre><code>DigitObserver: 9
GraphObserver: *********
DigitObserver: 16
GraphObserver: ****************
DigitObserver: 40
GraphObserver: ****************************************
DigitObserver: 34
GraphObserver: **********************************
DigitObserver: 18
GraphObserver: ******************
DigitObserver: 6
GraphObserver: ******
DigitObserver: 34
GraphObserver: **********************************
DigitObserver: 31
GraphObserver: *******************************
DigitObserver: 17
GraphObserver: *****************
DigitObserver: 47
GraphObserver: ***********************************************
DigitObserver: 21
GraphObserver: *********************
DigitObserver: 34
GraphObserver: **********************************
DigitObserver: 18
GraphObserver: ******************
DigitObserver: 25
GraphObserver: *************************
DigitObserver: 39
GraphObserver: ***************************************
DigitObserver: 20
GraphObserver: ********************
DigitObserver: 9
GraphObserver: *********
DigitObserver: 4
GraphObserver: ****
DigitObserver: 8
GraphObserver: ********
DigitObserver: 26
GraphObserver: **************************</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaPrototype模式</title>
    <url>/2020/09/12/JavaPrototype%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  通过复制生成实例</p>
</blockquote>
<h2 id="1-声明了抽象方法use和createClone的接口"><a href="#1-声明了抽象方法use和createClone的接口" class="headerlink" title="1 - 声明了抽象方法use和createClone的接口"></a>1 - 声明了抽象方法use和createClone的接口</h2><div class="code-wrapper"><pre><code>public interface Product extends Cloneable&#123;
    public abstract void use(String s);
    public abstract Product createClone();
&#125;</code></pre></div><h2 id="2-调用createClone方法复制实例的类"><a href="#2-调用createClone方法复制实例的类" class="headerlink" title="2 - 调用createClone方法复制实例的类"></a>2 - 调用createClone方法复制实例的类</h2><div class="code-wrapper"><pre><code>import java.util.*;
public class Manager &#123;
    private HashMap&lt;String, Product&gt; showcase = new HashMap&lt;String, Product&gt;();

    public void register(String name, Product proto)&#123;
        showcase.put(name, proto);
    &#125;

    public Product create(String protoname)&#123;
        Product p = showcase.get(protoname);
        return p.createClone();
    &#125;
&#125;</code></pre></div><p>被复制对象的类必须实现java.lang.Clonable接口</p>
<h2 id="3-将字符串放入方框中并使其显示出来的类-实现了use方法和createClone方法"><a href="#3-将字符串放入方框中并使其显示出来的类-实现了use方法和createClone方法" class="headerlink" title="3 - 将字符串放入方框中并使其显示出来的类, 实现了use方法和createClone方法"></a>3 - 将字符串放入方框中并使其显示出来的类, 实现了use方法和createClone方法</h2><div class="code-wrapper"><pre><code>public class MessageBox implements Product &#123;
    private char decochar;
    public MessageBox(char decochar)&#123;
        this.decochar = decochar;
    &#125;

    @Override
    public void use(String s) &#123;
        int length = s.getBytes().length;
        for (int i = 0; i &lt; length + 4; i++) &#123;
            System.out.print(decochar);
        &#125;
        System.out.println(&quot;&quot;);
        System.out.println(decochar + &quot; &quot; + s + &quot; &quot; + decochar);
        for (int i = 0; i &lt; length + 4; i++) &#123;
            System.out.print(decochar);
        &#125;
        System.out.println(&quot;&quot;);
    &#125;

    @Override
    public Product createClone() &#123;
        Product p = null;
        try &#123;
            p = (Product)clone();
        &#125;catch (CloneNotSupportedException e)&#123;
            e.printStackTrace();
        &#125;
        return p;
    &#125;
&#125;</code></pre></div><h2 id="4-给字符串加下划线并使其显示出来的类-实现了use方法和createClone方法"><a href="#4-给字符串加下划线并使其显示出来的类-实现了use方法和createClone方法" class="headerlink" title="4 - 给字符串加下划线并使其显示出来的类,实现了use方法和createClone方法"></a>4 - 给字符串加下划线并使其显示出来的类,实现了use方法和createClone方法</h2><div class="code-wrapper"><pre><code>public class UnderlinePen implements Product &#123;
    private char ulchar;

    public UnderlinePen(char ulchar)&#123;
        this.ulchar = ulchar;
    &#125;

    @Override
    public void use(String s) &#123;
        int length = s.getBytes().length;
        System.out.println(&quot;\&quot;&quot; + s + &quot;\&quot;&quot;);
        System.out.print(&quot; &quot;);
        for (int i = 0; i &lt; length; i++) &#123;
            System.out.print(ulchar);
        &#125;
        System.out.println(&quot;&quot;);
    &#125;

    @Override
    public Product createClone() &#123;
        Product p = null;
        try &#123;
            p = (Product)clone();
        &#125;catch (CloneNotSupportedException e)&#123;
            e.printStackTrace();
        &#125;
        return p;
    &#125;
&#125;</code></pre></div><h2 id="5-测试程序行为的类"><a href="#5-测试程序行为的类" class="headerlink" title="5 - 测试程序行为的类"></a>5 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args)&#123;
        // 准备
        Manager manager = new Manager();
        UnderlinePen upen = new UnderlinePen(&apos;~&apos;);
        MessageBox mbox = new MessageBox(&apos;*&apos;);
        MessageBox sbox = new MessageBox(&apos;/&apos;);
        manager.register(&quot;strong message&quot;, upen);
        manager.register(&quot;warning box&quot;, mbox);
        manager.register(&quot;slash box&quot;, sbox);

        // 生成
        Product p1 = manager.create(&quot;strong message&quot;);
        p1.use(&quot;Hello, world.&quot;);

        Product p2 = manager.create(&quot;warning box&quot;);
        p2.use(&quot;Hello, world.&quot;);

        Product p3 = manager.create(&quot;slash box&quot;);
        p3.use(&quot;Hello, world.&quot;);
    &#125;
&#125;</code></pre></div><h2 id="6-输出示例"><a href="#6-输出示例" class="headerlink" title="6 - 输出示例"></a>6 - 输出示例</h2><div class="code-wrapper"><pre><code>&quot;Hello, world.&quot;
~~~~~~~~~~~~~
*****************
* Hello, world. *
*****************
/////////////////
/ Hello, world. /
/////////////////</code></pre></div><p>在一些情况下,我们很难将种类繁多的对象整合到一个类中或者根据一个类来生成它的的实例,这个时候我们就可以以复制的方式,来根据实例生成新的实例.</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaProxy模式</title>
    <url>/2020/10/11/JavaProxy%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-Printer和PrinterProxy的共同接口"><a href="#1-Printer和PrinterProxy的共同接口" class="headerlink" title="1 - Printer和PrinterProxy的共同接口"></a>1 - Printer和PrinterProxy的共同接口</h2><div class="code-wrapper"><pre><code>public interface Printable &#123;
    public abstract void setPrinterName(String name);
    public abstract String getPrinterName();
    public abstract void print(String string);
&#125;</code></pre></div><h2 id="2-表示带名字的打印机类-本人"><a href="#2-表示带名字的打印机类-本人" class="headerlink" title="2 - 表示带名字的打印机类(本人)"></a>2 - 表示带名字的打印机类(本人)</h2><div class="code-wrapper"><pre><code>public class Printer implements Printable &#123;
    private String name;
    public Printer() &#123;
        heavyJob(&quot;正在生成Printer的实例&quot;);
    &#125;

    public Printer(String name) &#123;
        this.name = name;
        heavyJob(&quot;正在生成Printer的实例(&quot; + name + &quot;)&quot;);
    &#125;

    @Override
    public void setPrinterName(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public String getPrinterName() &#123;
        return name;
    &#125;

    @Override
    public void print(String string) &#123;
        System.out.println(&quot;===&quot; + name + &quot;===&quot;);
        System.out.println(string);
    &#125;

    private void heavyJob(String msg) &#123;
        System.out.print(msg);
        for (int i = 0; i &lt; 5; i++) &#123;
            try &#123;
                Thread.sleep(1000);
            &#125;catch (InterruptedException ignored) &#123;
            &#125;
            System.out.print(&apos;.&apos;);
        &#125;
        System.out.println(&quot;结束!&quot;);
    &#125;
&#125;</code></pre></div><h2 id="3-表示带名字的打印机类-代理人"><a href="#3-表示带名字的打印机类-代理人" class="headerlink" title="3 - 表示带名字的打印机类(代理人)"></a>3 - 表示带名字的打印机类(代理人)</h2><div class="code-wrapper"><pre><code>public class PrinterProxy implements Printable&#123;
    private String name;
    private Printer real;

    public PrinterProxy()&#123;&#125;

    public PrinterProxy(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public synchronized void setPrinterName(String name) &#123;
        if (real != null) &#123;
            real.setPrinterName(name);
        &#125;
        this.name = name;
    &#125;

    @Override
    public String getPrinterName() &#123;
        return name;
    &#125;

    @Override
    public void print(String string) &#123;
        realize();
        real.print(string);
    &#125;

    private synchronized void realize() &#123;
        if (real == null) &#123;
            real = new Printer(name);
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="4-测试程序行为的类"><a href="#4-测试程序行为的类" class="headerlink" title="4 - 测试程序行为的类"></a>4 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        Printable p = new PrinterProxy(&quot;Alice&quot;);
        System.out.println(&quot;现在名字是&quot; + p.getPrinterName() + &quot;.&quot;);
        p.setPrinterName(&quot;Bob&quot;);
        System.out.println(&quot;现在名字是&quot; + p.getPrinterName() + &quot;.&quot;);
        p.print(&quot;Hello, world.&quot;);
    &#125;
&#125;</code></pre></div><h2 id="5-输出示例"><a href="#5-输出示例" class="headerlink" title="5 - 输出示例"></a>5 - 输出示例</h2><div class="code-wrapper"><pre><code>现在名字是Alice.
现在名字是Bob.
正在生成Printer的实例(Bob).....结束!
===Bob===
Hello, world.</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaState模式</title>
    <url>/2020/10/06/JavaState%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  用类表示状态</p>
</blockquote>
<h2 id="1-表示金库状态的接口"><a href="#1-表示金库状态的接口" class="headerlink" title="1 - 表示金库状态的接口"></a>1 - 表示金库状态的接口</h2><div class="code-wrapper"><pre><code>public interface State &#123;
    public abstract void doClock(Context context, int hour);    // 设置时间
    public abstract void doUse(Context context);                // 使用金库
    public abstract void doAlarm(Context context);              // 按下警铃
    public abstract void doPhone(Context context);              // 正常通话
&#125;</code></pre></div><h2 id="2-表示”白天”状态的类-它实现了State接口"><a href="#2-表示”白天”状态的类-它实现了State接口" class="headerlink" title="2 - 表示”白天”状态的类.它实现了State接口"></a>2 - 表示”白天”状态的类.它实现了State接口</h2><div class="code-wrapper"><pre><code>public class DayState implements State&#123;
    private static DayState singleton = new DayState();

    private DayState() &#123;
            // 构造函数是私有的
    &#125;

    public static State getInstance() &#123;
        // 获取唯一实例
        return singleton;
    &#125;

    @Override
    public void doClock(Context context, int hour) &#123;    // 设置时间
        if (hour &lt; 9 || hour &gt;= 17) &#123;
            context.changeState(NightState.getInstance());
        &#125;
    &#125;

    @Override
    public void doUse(Context context) &#123;
        context.recordLog(&quot;使用金库(白天)&quot;);
    &#125;

    @Override
    public void doAlarm(Context context) &#123;
        context.callSecurityCenter(&quot;按下警铃(白天)&quot;);
    &#125;

    @Override
    public void doPhone(Context context) &#123;
        context.callSecurityCenter(&quot;正常通话(白天)&quot;);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;[白天]&quot;;
    &#125;
&#125;</code></pre></div><h2 id="3-表示”晚上”状态的类-它实现了State接口"><a href="#3-表示”晚上”状态的类-它实现了State接口" class="headerlink" title="3 - 表示”晚上”状态的类.它实现了State接口"></a>3 - 表示”晚上”状态的类.它实现了State接口</h2><div class="code-wrapper"><pre><code>public class NightState implements State &#123;
    private static NightState singleton = new NightState();

    private NightState() &#123;
        // 构造函数是私有的
    &#125;

    public static State getInstance() &#123;
        // 获取唯一实例
        return singleton;
    &#125;

    @Override
    public void doClock(Context context, int hour) &#123;
        if (hour &gt;= 9 &amp;&amp; hour &lt; 17) &#123;
            context.changeState(DayState.getInstance());
        &#125;
    &#125;

    @Override
    public void doUse(Context context) &#123;
        context.callSecurityCenter(&quot;紧急:晚上使用金库! &quot;);
    &#125;

    @Override
    public void doAlarm(Context context) &#123;
        context.callSecurityCenter(&quot;按下警铃(晚上)&quot;);
    &#125;

    @Override
    public void doPhone(Context context) &#123;
        context.recordLog(&quot;晚上的通话录音&quot;);
    &#125;

    @Override
    public String toString() &#123;
        return &quot;[晚上]&quot;;
    &#125;
&#125;</code></pre></div><h2 id="4-表示管理金库状态-并与警报中心联系的接口"><a href="#4-表示管理金库状态-并与警报中心联系的接口" class="headerlink" title="4 - 表示管理金库状态, 并与警报中心联系的接口"></a>4 - 表示管理金库状态, 并与警报中心联系的接口</h2><div class="code-wrapper"><pre><code>public interface Context &#123;
    public abstract void setClock(int hour);            // 设置时间
    public abstract void changeState(State state);      // 改变状态
    public abstract void callSecurityCenter(String msg); // 联系警报中心
    public abstract void recordLog(String msg);         // 在警报中心留下记录
&#125;</code></pre></div><h2 id="5-实现了Context接口-在它内部持有按钮和画面显示等UI信息"><a href="#5-实现了Context接口-在它内部持有按钮和画面显示等UI信息" class="headerlink" title="5 - 实现了Context接口.在它内部持有按钮和画面显示等UI信息"></a>5 - 实现了Context接口.在它内部持有按钮和画面显示等UI信息</h2><div class="code-wrapper"><pre><code>public class SafeFrame extends Frame implements ActionListener, Context &#123;
    private TextField textClock = new TextField(60);        // 显示当前时间
    private TextArea textScreen = new TextArea(10, 60); // 显示警报中心的记录
    private Button buttonUse = new Button(&quot;使用金库&quot;);  // 使用金库按钮
    private Button buttonAlarm = new Button(&quot;按下警铃&quot;);  // 按下警铃按钮
    private Button buttonPhone = new Button(&quot;正常通话&quot;);  // 正常通话按钮
    private Button buttonExit = new Button(&quot;结束&quot;);  // 结束按钮

    private State state = DayState.getInstance();   // 当前的状态

    // 构造函数
    public SafeFrame(String title) &#123;
        super(title);
        setBackground(Color.lightGray);
        setLayout(new BorderLayout());
        // 配置textClock
        add(textClock, BorderLayout.NORTH);
        textClock.setEditable(false);
        // 配置textScreen
        add(textScreen, BorderLayout.CENTER);
        textScreen.setEditable(false);
        // 为界面添加按钮
        Panel panel = new Panel();
        panel.add(buttonUse);
        panel.add(buttonAlarm);
        panel.add(buttonPhone);
        panel.add(buttonExit);
        // 配置界面
        add(panel, BorderLayout.SOUTH);
        // 显示
        pack();
        show();
        // 设置监听器
        buttonUse.addActionListener(this);
        buttonAlarm.addActionListener(this);
        buttonPhone.addActionListener(this);
        buttonExit.addActionListener(this);
    &#125;

    // 按钮被按下后该方法会调用
    @Override
    public void actionPerformed(ActionEvent e) &#123;
        System.out.println(e.toString());
        if (e.getSource() == buttonUse) &#123;
            state.doUse(this);
        &#125; else if (e.getSource() == buttonAlarm) &#123;
            state.doAlarm(this);
        &#125; else if (e.getSource() == buttonPhone) &#123;
            state.doPhone(this);
        &#125; else if (e.getSource() == buttonExit) &#123;
            System.exit(0);
        &#125; else &#123;
            System.out.println(&quot;?&quot;);
        &#125;
    &#125;

    // 设置时间
    @Override
    public void setClock(int hour) &#123;
        String clockString = &quot; 现在时间是&quot;;
        if (hour &lt; 10) &#123;
            clockString += &quot;0&quot; + hour + &quot;:00&quot;;
        &#125; else &#123;
            clockString += hour + &quot;:00&quot;;
        &#125;
        System.out.println(clockString);
        textClock.setText(clockString);
        state.doClock(this, hour);
    &#125;

    // 改变状态
    @Override
    public void changeState(State state) &#123;
        System.out.println(&quot;从&quot; + this.state + &quot;状态变为了&quot; + state + &quot;状态.&quot;);
        this.state = state;
    &#125;

    // 联系警报中心
    @Override
    public void callSecurityCenter(String msg) &#123;
        textScreen.append(&quot;call!&quot; + msg + &quot;\n&quot;);
    &#125;

    // 在警报中心留下记录
    @Override
    public void recordLog(String msg) &#123;
        textScreen.append(&quot;record . . . &quot; + msg + &quot;\n&quot;);
    &#125;
&#125;</code></pre></div><h2 id="6-测试程序行为的类"><a href="#6-测试程序行为的类" class="headerlink" title="6 - 测试程序行为的类"></a>6 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        SafeFrame frame = new SafeFrame(&quot;State Sample&quot;);
        while (true) &#123;
            for (int hour = 0; hour &lt; 24; hour++) &#123;
                frame.setClock(hour);
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException ignored)&#123;

                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="7-输出示例"><a href="#7-输出示例" class="headerlink" title="7 - 输出示例"></a>7 - 输出示例</h2><div class="code-wrapper"><pre><code>现在时间是00:00
从[白天]状态变为了[晚上]状态.
现在时间是01:00
现在时间是02:00
现在时间是03:00
java.awt.event.ActionEvent[ACTION_PERFORMED,cmd=正常通话,when=1601985182012,modifiers=] on button0
现在时间是04:00
java.awt.event.ActionEvent[ACTION_PERFORMED,cmd=按下警铃,when=1601985182892,modifiers=] on button1
java.awt.event.ActionEvent[ACTION_PERFORMED,cmd=使用金库,when=1601985183407,modifiers=] on button2
现在时间是05:00
现在时间是06:00</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaStrategy模式</title>
    <url>/2020/09/19/JavaStrategy%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  整体的替换算法</p>
</blockquote>
<h2 id="1-表示猜拳游戏中的的”手势”类"><a href="#1-表示猜拳游戏中的的”手势”类" class="headerlink" title="1 - 表示猜拳游戏中的的”手势”类"></a>1 - 表示猜拳游戏中的的”手势”类</h2><div class="code-wrapper"><pre><code>public class Hand &#123;
    public static final int HANDVALUE_GUU = 0; // 表示石头的值
    public static final int HANDVALUE_CHO = 1; // 表示剪刀的值
    public static final int HANDVALUE_PAA = 2; // 表示布的值

    public static final Hand[] hand = &#123; // 表示猜拳中三种手势的实例
            new Hand(HANDVALUE_GUU),
            new Hand(HANDVALUE_CHO),
            new Hand(HANDVALUE_PAA),
    &#125;;

    private static final String[] name = &#123; // 表示猜拳中手势所对应的字符串
            &quot;石头&quot;, &quot;剪刀&quot;, &quot;布&quot;
    &#125;;

    private int handValue;  // 猜拳中出的手势的值
    private Hand(int handValue)&#123;
        this.handValue = handValue;
    &#125;

    public static Hand getHand(int handValue)&#123; // 根据手势的值获取对应的实例
        return hand[handValue];
    &#125;

    public boolean isStrongerThan(Hand h)&#123; // 如果this战胜了h则返回true
        return fight(h) == 1;
    &#125;

    public boolean isWeakerThan(Hand h)&#123; // 如果this战胜了h则返回false
        return fight(h) == -1;
    &#125;

    private int fight(Hand h)&#123;
        if(this == h)&#123;
            return 0;
        &#125;else if ((this.handValue + 1) % 3 == h.handValue)&#123;
            return 1;
        &#125;else&#123;
            return -1;
        &#125;
    &#125;
    @Override
    public String toString()&#123;
        return name[handValue];
    &#125;
&#125;</code></pre></div><h2 id="2-表示猜拳游戏中策略的类"><a href="#2-表示猜拳游戏中策略的类" class="headerlink" title="2 - 表示猜拳游戏中策略的类"></a>2 - 表示猜拳游戏中策略的类</h2><div class="code-wrapper"><pre><code>public interface Strategy &#123;
    public abstract Hand nextHand();
    public abstract void study(boolean win);
&#125;</code></pre></div><h2 id="3-表示”如果这局猜拳获胜-那么下一局也出一样的手势”这一策略的类"><a href="#3-表示”如果这局猜拳获胜-那么下一局也出一样的手势”这一策略的类" class="headerlink" title="3 - 表示”如果这局猜拳获胜,那么下一局也出一样的手势”这一策略的类"></a>3 - 表示”如果这局猜拳获胜,那么下一局也出一样的手势”这一策略的类</h2><div class="code-wrapper"><pre><code>public class WinningStrategy implements Strategy&#123;
    private Random random;
    private boolean won = false;
    private Hand prevHand;
    public WinningStrategy(int seed)&#123;
        random = new Random(seed);
    &#125;

    @Override
    public Hand nextHand() &#123;
        if (!won) &#123;
            prevHand = Hand.getHand(random.nextInt(3));
        &#125;
        return prevHand;
    &#125;

    @Override
    public void study(boolean win) &#123;
        won = win;
    &#125;
&#125;</code></pre></div><h2 id="4-表示”根据上一局的手势从概率上计算出下一局的手势-从之前的猜拳结果计算下一局出各种拳的概率”这一策略类"><a href="#4-表示”根据上一局的手势从概率上计算出下一局的手势-从之前的猜拳结果计算下一局出各种拳的概率”这一策略类" class="headerlink" title="4 - 表示”根据上一局的手势从概率上计算出下一局的手势,从之前的猜拳结果计算下一局出各种拳的概率”这一策略类"></a>4 - 表示”根据上一局的手势从概率上计算出下一局的手势,从之前的猜拳结果计算下一局出各种拳的概率”这一策略类</h2><div class="code-wrapper"><pre><code>public class ProbStrategy implements Strategy&#123;
    private Random random;
    private int prevHandValue = 0;
    private int currentHandValue = 0;

    private int[][] history = &#123;
            &#123;1, 1, 1&#125;,
            &#123;1, 1, 1&#125;,
            &#123;1, 1, 1&#125;,
    &#125;;

    public ProbStrategy(int seed)&#123;
        random = new Random(seed);
    &#125;

    @Override
    public Hand nextHand() &#123;
        int bet = random.nextInt(getSum(currentHandValue));
        int handValue = 0;
        if (bet &lt; history[currentHandValue][0])&#123;
            handValue = 0;
        &#125;else if (bet &lt; history[currentHandValue][0] + history[currentHandValue][1])&#123;
            handValue = 1;
        &#125;else &#123;
            handValue = 2;
        &#125;

        prevHandValue = currentHandValue;
        currentHandValue = handValue;
        return Hand.getHand(handValue);
    &#125;

    private int getSum(int hv)&#123;
        int sum = 0;
        for (int i = 0; i &lt; 3; i++) &#123;
            sum += history[hv][i];
        &#125;
        return sum;
    &#125;

    @Override
    public void study(boolean win) &#123;
        if (win)&#123;
            history[prevHandValue][currentHandValue]++;
        &#125;else &#123;
            history[prevHandValue][(currentHandValue + 1) % 3]++;
            history[prevHandValue][(currentHandValue + 2) % 3]++;
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="5-表示进行猜拳游戏的选手的类"><a href="#5-表示进行猜拳游戏的选手的类" class="headerlink" title="5 - 表示进行猜拳游戏的选手的类"></a>5 - 表示进行猜拳游戏的选手的类</h2><div class="code-wrapper"><pre><code>public class Player &#123;
    private String name;
    private Strategy strategy;
    private int winCount;
    private int loseCount;
    private int gameCount;

    public Player(String name, Strategy strategy)&#123;
        this.name = name;
        this.strategy = strategy;
    &#125;

    public Hand nextHand()&#123;
        return strategy.nextHand();
    &#125;

    public void win()&#123; // 胜
        strategy.study(true);
        winCount++;
        gameCount++;
    &#125;

    public void lose()&#123; // 输
        strategy.study(false);
        loseCount++;
        gameCount++;
    &#125;

    public void even()&#123; // 平
        gameCount++;
    &#125;

    @Override
    public String toString()&#123;
        return &quot;[&quot; + name + &quot;:&quot; + gameCount + &quot; games, &quot;
                + winCount + &quot; win, &quot; + loseCount + &quot; lose &quot; + &quot;]&quot;;
    &#125;
&#125;</code></pre></div><h2 id="6-测试程序行为的类"><a href="#6-测试程序行为的类" class="headerlink" title="6 - 测试程序行为的类"></a>6 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>// 需要提前设置好args的参数
public class Main &#123;
    public static void main(String[] args) &#123;
        if (args.length != 2)&#123;
            System.out.println(&quot;Usage: java Main randomSeed1 randomSeed2&quot;);
            System.out.println(&quot;Example: java Main 314 15&quot;);
            System.exit(0);
        &#125;

        int seed1 = Integer.parseInt(args[0]);
        int seed2 = Integer.parseInt(args[1]);

        Player player1 = new Player(&quot;Taro&quot;, new WinningStrategy(seed1));
        Player player2 = new Player(&quot;Hana&quot;, new ProbStrategy(seed2));

        for (int i = 0; i &lt; 15; i++) &#123;
            Hand nextHand1 = player1.nextHand();
            Hand nextHand2 = player2.nextHand();
            if (nextHand1.isStrongerThan(nextHand2))&#123;
                System.out.println(&quot;Winner: &quot; + player1);
                player1.win();
                player2.lose();
            &#125;else if (nextHand2.isStrongerThan(nextHand1))&#123;
                System.out.println(&quot;Winner: &quot; + player2);
                player2.win();
                player1.lose();
            &#125;else &#123;
                System.out.println(&quot;Even...&quot;);
                player1.even();
                player2.even();
            &#125;
        &#125;

        System.out.println(&quot;Total result: &quot;);
        System.out.println(player1.toString());
        System.out.println(player2.toString());
    &#125;
&#125;</code></pre></div><h2 id="7-输出示例"><a href="#7-输出示例" class="headerlink" title="7 - 输出示例"></a>7 - 输出示例</h2><div class="code-wrapper"><pre><code>Winner: [Taro:0 games, 0 win, 0 lose ]
Winner: [Taro:1 games, 1 win, 0 lose ]
Even...
Winner: [Hana:3 games, 0 win, 2 lose ]
Winner: [Hana:4 games, 1 win, 2 lose ]
Winner: [Hana:5 games, 2 win, 2 lose ]
Winner: [Hana:6 games, 3 win, 2 lose ]
Winner: [Taro:7 games, 2 win, 4 lose ]
Even...
Winner: [Hana:9 games, 4 win, 3 lose ]
Winner: [Taro:10 games, 3 win, 5 lose ]
Winner: [Taro:11 games, 4 win, 5 lose ]
Winner: [Hana:12 games, 5 win, 5 lose ]
Winner: [Hana:13 games, 6 win, 5 lose ]
Winner: [Taro:14 games, 5 win, 7 lose ]
Total result: 
[Taro:15 games, 6 win, 7 lose ]
[Hana:15 games, 7 win, 6 lose ]</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>JavaVisitor模式</title>
    <url>/2020/09/22/JavaVisitor%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>  访问数据结构并处理数据</p>
</blockquote>
<h2 id="1-表示访问者的抽象类-它访问文件和文件夹"><a href="#1-表示访问者的抽象类-它访问文件和文件夹" class="headerlink" title="1 - 表示访问者的抽象类, 它访问文件和文件夹"></a>1 - 表示访问者的抽象类, 它访问文件和文件夹</h2><div class="code-wrapper"><pre><code>public abstract class Visitor &#123;
    public abstract void visit(File file);
    public abstract void visit(Directory directory);
&#125;</code></pre></div><h2 id="2-表示数据结构的接口-它接受访问者的访问"><a href="#2-表示数据结构的接口-它接受访问者的访问" class="headerlink" title="2 - 表示数据结构的接口, 它接受访问者的访问"></a>2 - 表示数据结构的接口, 它接受访问者的访问</h2><div class="code-wrapper"><pre><code>public interface Element &#123;
    public abstract void accept(Visitor v);
&#125;</code></pre></div><h2 id="3-Visitor类的子类-显示文件和文件夹一览"><a href="#3-Visitor类的子类-显示文件和文件夹一览" class="headerlink" title="3 - Visitor类的子类, 显示文件和文件夹一览"></a>3 - Visitor类的子类, 显示文件和文件夹一览</h2><div class="code-wrapper"><pre><code>public class ListVisitor extends Visitor&#123;
    private String currentDir = &quot;&quot;;

    @Override
    public void visit(File file) &#123;
        System.out.println(currentDir + &quot;/&quot; + file);
    &#125;

    @Override
    public void visit(Directory directory) &#123;
        System.out.println(currentDir + &quot;/&quot; + directory);
        String saveDir = currentDir;
        currentDir = currentDir + &quot;/&quot; + directory.getName();
        Iterator it = directory.iterator();
        while (it.hasNext())&#123;
            Entry entry = (Entry)it.next();
            entry.accept(this);
        &#125;
        currentDir = saveDir;
    &#125;
&#125;</code></pre></div><h2 id="4-抽象类-File类和Directory类的父类-实现了Element接口"><a href="#4-抽象类-File类和Directory类的父类-实现了Element接口" class="headerlink" title="4 - 抽象类, File类和Directory类的父类, 实现了Element接口"></a>4 - 抽象类, File类和Directory类的父类, 实现了Element接口</h2><div class="code-wrapper"><pre><code>public abstract class Entry implements Element&#123;
    public abstract String getName();   // 获取名字
    public abstract int getSize();      // 获取大小
    public Entry add(Entry entry) throws FileTreatMeantException &#123; // 加入条目目录
        throw new FileTreatMeantException();
    &#125;

    public Iterator iterator() throws FileTreatMeantException &#123; // 生成Iterator
        throw new FileTreatMeantException();
    &#125;
                                                        // 显示条目一览
    @Override                                           // 显示代表类的文字
    public String toString()&#123;
        return getName() + &quot; (&quot; + getSize() + &quot;)&quot;;
    &#125;
&#125;</code></pre></div><h2 id="5-表示文件的类"><a href="#5-表示文件的类" class="headerlink" title="5 - 表示文件的类"></a>5 - 表示文件的类</h2><div class="code-wrapper"><pre><code>public class File extends Entry&#123;
    private String name;
    private int size;

    public File(String name, int size)&#123;
        this.name = name;
        this.size = size;
    &#125;

    @Override
    public String getName() &#123;
        return name;
    &#125;

    @Override
    public int getSize() &#123;
        return size;
    &#125;

    @Override
    public void accept(Visitor v) &#123;
        v.visit(this);
    &#125;
&#125;</code></pre></div><h2 id="6-表示文件夹的类"><a href="#6-表示文件夹的类" class="headerlink" title="6 - 表示文件夹的类"></a>6 - 表示文件夹的类</h2><div class="code-wrapper"><pre><code>public class Directory extends Entry&#123;
    private String name;
    private ArrayList directory = new ArrayList();
    public Directory(String name)&#123;
        this.name = name;
    &#125;

    @Override
    public String getName() &#123;
        return name;
    &#125;

    @Override
    public int getSize() &#123;
        int size = 0;
        for (Object o : directory) &#123;
            Entry entry = (Entry) o;
            size += entry.getSize();
        &#125;
        return size;
    &#125;

    public Entry add(Entry entry)&#123;
        directory.add(entry);
        return this;
    &#125;

    public Iterator iterator()&#123;
        return directory.iterator();
    &#125;

    @Override
    public void accept(Visitor v) &#123;
        v.visit(this);
    &#125;
&#125;</code></pre></div><h2 id="7-表示向文件中增加Entry时发生的异常的类"><a href="#7-表示向文件中增加Entry时发生的异常的类" class="headerlink" title="7 - 表示向文件中增加Entry时发生的异常的类"></a>7 - 表示向文件中增加Entry时发生的异常的类</h2><div class="code-wrapper"><pre><code>public class FileTreatMeantException extends RuntimeException&#123;

    public FileTreatMeantException()&#123;
    &#125;

    public FileTreatMeantException(String msg)&#123;
        super(msg);
    &#125;
&#125;</code></pre></div><h2 id="8-测试程序行为的类"><a href="#8-测试程序行为的类" class="headerlink" title="8 - 测试程序行为的类"></a>8 - 测试程序行为的类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        try &#123;
            System.out.println(&quot;Making root entries...&quot;);
            Directory rootDir = new Directory(&quot;root&quot;);
            Directory binDir = new Directory(&quot;bin&quot;);
            Directory tmpDir = new Directory(&quot;tmp&quot;);
            Directory usrDir = new Directory(&quot;usr&quot;);
            rootDir.add(binDir);
            rootDir.add(tmpDir);
            rootDir.add(usrDir);
            binDir.add(new File(&quot;vi&quot;, 10000));
            binDir.add(new File(&quot;latex&quot;, 20000));
            rootDir.accept(new ListVisitor());

            System.out.println(&quot;&quot;);
            System.out.println(&quot;Making user entries...&quot;);
            Directory yuki = new Directory(&quot;yuki&quot;);
            Directory hanako = new Directory(&quot;hanako&quot;);
            Directory tomura = new Directory(&quot;tomura&quot;);
            usrDir.add(yuki);
            usrDir.add(hanako);
            usrDir.add(tomura);
            yuki.add(new File(&quot;diary.html&quot;, 100));
            yuki.add(new File(&quot;Composite.java&quot;, 200));
            hanako.add(new File(&quot;memo.tex&quot;, 300));
            tomura.add(new File(&quot;game.doc&quot;, 400));
            tomura.add(new File(&quot;junk.mail&quot;, 500));
            rootDir.accept(new ListVisitor());

        &#125;catch (FileTreatMeantException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="9-输出样例"><a href="#9-输出样例" class="headerlink" title="9 - 输出样例"></a>9 - 输出样例</h2><div class="code-wrapper"><pre><code>Making root entries...
/root (30000)
/root/bin (30000)
/root/bin/vi (10000)
/root/bin/latex (20000)
/root/tmp (0)
/root/usr (0)

Making user entries...
/root (31500)
/root/bin (30000)
/root/bin/vi (10000)
/root/bin/latex (20000)
/root/tmp (0)
/root/usr (1500)
/root/usr/yuki (300)
/root/usr/yuki/diary.html (100)
/root/usr/yuki/Composite.java (200)
/root/usr/hanako (300)
/root/usr/hanako/memo.tex (300)
/root/usr/tomura (900)
/root/usr/tomura/game.doc (400)
/root/usr/tomura/junk.mail (500)</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Java使用缓存流进行文件的复制</title>
    <url>/2020/09/08/Java%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E6%B5%81%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="1-准备要复制的文件路径和复制后的路径"><a href="#1-准备要复制的文件路径和复制后的路径" class="headerlink" title="1- 准备要复制的文件路径和复制后的路径"></a>1- 准备要复制的文件路径和复制后的路径</h2><div class="code-wrapper"><pre><code>private static final String FilePath1 = &quot;D:/测试文件.txt&quot;;
private static final String FilePath2 = &quot;D:/测试文件_副本.txt&quot;;</code></pre></div><h2 id="2-导入IO库"><a href="#2-导入IO库" class="headerlink" title="2 - 导入IO库"></a>2 - 导入IO库</h2><p>   import java.io.*;</p>
<h2 id="3-拷贝方法"><a href="#3-拷贝方法" class="headerlink" title="3 - 拷贝方法"></a>3 - 拷贝方法</h2><div class="code-wrapper"><pre><code>/**
* 使用缓存流拷贝文件
* @return 拷贝的耗时
*/
private static long copyFileByBufferedStream() throws IOException &#123;
    File file = new File(FilePath1);
    if (!file.exists())&#123;
        System.out.println(&quot;文件不存在,复制失败!&quot;);
    &#125;
    // 记录开始时间
    long startTime = System.currentTimeMillis();
    // 读取的缓存流
    InputStream inputStream = new FileInputStream(file);
    BufferedInputStream bInStream = new BufferedInputStream(inputStream);
    // 写入的缓存流
    OutputStream outputStream = new FileOutputStream(FilePath2);
    BufferedOutputStream bOutStream = new BufferedOutputStream(outputStream);
    // 逐个字节的复制
    int i = 1; // 读取的临时变量
    while ((i = bInStream.read()) != -1)&#123;
        bOutStream.write(i); // 读取一个字节,就写入缓存中!
    &#125;
    // 注意,一定要关闭缓存流对象,清空缓冲区,这样才可以复制成功
    bInStream.close();
    bOutStream.close();
    System.out.println(&quot;文件复制成功!&quot;);
    return System.currentTimeMillis() - startTime;
&#125;</code></pre></div><p>使用缓存流,在比较大的文件中可以看到明显的效率提升</p>
<h2 id="4-完整的代码"><a href="#4-完整的代码" class="headerlink" title="4 - 完整的代码"></a>4 - 完整的代码</h2><div class="code-wrapper"><pre><code>import java.io.*;

public class BufferedStreamDemo &#123;

    private static final String FilePath1 = &quot;D:/测试文件.txt&quot;;
    private static final String FilePath2 = &quot;D:/测试文件_副本.txt&quot;;

    public static void main(String[] args) throws IOException &#123;
    long time = copyFileByBufferedStream();
    System.out.println(&quot;拷贝耗时: &quot; + time + &quot;毫秒&quot;;
    &#125;

    /**
    * 使用缓存流拷贝文件
    * @return 拷贝的耗时
    */
    private static long copyFileByBufferedStream() throws IOException &#123;
        File file = new File(FilePath1);
        if (!file.exists())&#123;
            System.out.println(&quot;文件不存在,复制失败!&quot;);
        &#125;
        // 记录开始时间
        long startTime = System.currentTimeMillis();
        // 读取的缓存流
        InputStream inputStream = new FileInputStream(file);
        BufferedInputStream bInStream = new BufferedInputStream(inputStream);
        // 写入的缓存流
        OutputStream outputStream = new FileOutputStream(FilePath2);
        BufferedOutputStream bOutStream = new BufferedOutputStream(outputStream);
        // 逐个字节的复制
        int i = 1; // 读取的临时变量
        while ((i = bInStream.read()) != -1)&#123;
            bOutStream.write(i); // 读取一个字节,就写入缓存中!
        &#125;
        // 注意,一定要关闭缓存流对象,清空缓冲区,这样才可以复制成功
        bInStream.close();
        bOutStream.close();
        System.out.println(&quot;文件复制成功!&quot;);
        return System.currentTimeMillis() - startTime;
    &#125;
&#125;</code></pre></div><h2 id="5-输出示例"><a href="#5-输出示例" class="headerlink" title="5 - 输出示例"></a>5 - 输出示例</h2><div class="code-wrapper"><pre><code>文件复制成功!
拷贝耗时: 4019毫秒</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>文件复制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java单例模式Singleton</title>
    <url>/2020/09/11/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-单例类"><a href="#1-单例类" class="headerlink" title="1 -  单例类"></a>1 -  单例类</h2><div class="code-wrapper"><pre><code>public class Singleton &#123;
    private static Singleton singleton = new Singleton();
    private Singleton()&#123;
        System.out.println(&quot;生成了一个实例&quot;);
    &#125;

    public static Singleton getInstance()&#123;
        return singleton;
    &#125;
&#125;</code></pre></div><p>因为只允许存在一个实例,所以构造函数使用私有权限,可以利用getInstance来获得类的实例.</p>
<h2 id="2-测试主类"><a href="#2-测试主类" class="headerlink" title="2 - 测试主类"></a>2 - 测试主类</h2><div class="code-wrapper"><pre><code>public class Main &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;Start.&quot;);
        Singleton obj1 = Singleton.getInstance();
        Singleton obj2 = Singleton.getInstance();
        if (obj1 == obj2)&#123;
            System.out.println(&quot;obj1与obj2有相同的实列&quot;);
        &#125;else &#123;
            System.out.println(&quot;obj1与obj2有不同的实列&quot;);
        &#125;
        System.out.println(&quot;End.&quot;);
    &#125;
&#125;</code></pre></div><h2 id="3-输出示例"><a href="#3-输出示例" class="headerlink" title="3 - 输出示例"></a>3 - 输出示例</h2><div class="code-wrapper"><pre><code>Start.
生成了一个实例
obj1与obj2有相同的实列
End.</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Java对象的序列化</title>
    <url>/2020/08/16/Java%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="1-对象序列化"><a href="#1-对象序列化" class="headerlink" title="1 - 对象序列化"></a>1 - 对象序列化</h2><p>所谓的对象序列化（在某些书籍中也叫串行化），是指在内存之中保存的对象转化为二进制数据流的形式的一种操作。通过将对象序列化，可以方便地实现对象的传输及保存。但是在Java之中并不是所有的类的对象都可以被序列化，如果一个类对象需要被序列化，则此类一定要实现java. io.Serializable接口。但是这个接口里面也没有定义任何的方法，所以此接口依然属于标识接口，表示一种能力。</p>
<p>以上内容,引自&lt;&lt;Java从入门到精通(第二版)&gt;&gt; 张玉宏主编 </p>
<h2 id="2-具体代码的实现"><a href="#2-具体代码的实现" class="headerlink" title="2 - 具体代码的实现"></a>2 - 具体代码的实现</h2><h3 id="2-1-需要实现序列化的类"><a href="#2-1-需要实现序列化的类" class="headerlink" title="2.1 需要实现序列化的类"></a>2.1 需要实现序列化的类</h3><div class="code-wrapper"><pre><code>@SuppressWarnings(&quot;serial&quot;)
class Person implements Serializable&#123;
    private String name;
    private int age;

    public Person(String name, int age)&#123;
        this.name = name;
        this.age = age;
    &#125;

    @Override
    public String toString()&#123;
        return &quot;姓名: &quot; + this.name + &quot;, 年龄: &quot; + this.age;
    &#125;
&#125;;</code></pre></div><h3 id="2-2-进行序列化测试的主类"><a href="#2-2-进行序列化测试的主类" class="headerlink" title="2.2 进行序列化测试的主类"></a>2.2 进行序列化测试的主类</h3><div class="code-wrapper"><pre><code>public class SerializableDemo &#123;
    public static void main(String[] args) throws Exception&#123;

        String filePath = &quot;D:\\&quot;;

        File f = new File(filePath + &quot;SerializablePerson.txt&quot;);
        serialize(f);
        deserialize(f);
    &#125;

    // 使用以下方法为序列化对象方法
    public static void serialize(File f)throws Exception&#123;
        OutputStream outputFile = new FileOutputStream(f);
        ObjectOutputStream cout = new ObjectOutputStream(outputFile);
        cout.writeObject(new Person(&quot;张三&quot;, 25));
        cout.close();
    &#125;

    // 使用以下方法为反序列化对象方法
    public static void deserialize(File f)throws Exception&#123;
        InputStream inputStream = new FileInputStream(f);
        ObjectInputStream cin = new ObjectInputStream(inputStream);
        Person p = (Person)cin.readObject();
        System.out.println(p);
        cin.close();
    &#125;
&#125;</code></pre></div><h2 id="3-输出示例"><a href="#3-输出示例" class="headerlink" title="3 - 输出示例"></a>3 - 输出示例</h2><div class="code-wrapper"><pre><code>姓名: 张三, 年龄: 25</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程的同步问题</title>
    <url>/2020/08/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-synchronized关键字对代码块的同步"><a href="#1-synchronized关键字对代码块的同步" class="headerlink" title="1 - synchronized关键字对代码块的同步"></a>1 - synchronized关键字对代码块的同步</h2><div class="code-wrapper"><pre><code>public class ThreadSynchronization &#123;
    public static void main(String[] args) &#123;
        TestThread  t = new TestThread();
        // 启动四个线程,并实现资源共享

        new Thread(t).start();
        new Thread(t).start();
        new Thread(t).start();
        new Thread(t).start();
    &#125;
&#125;

class TestThread implements Runnable&#123;
    private int tickets = 5;
    @Override
    public void run()&#123;
        while (true) &#123;
            // 利用synchronized关键字对这一代码块进行同步,避免共享资源的随意访问
            synchronized (this) &#123;
                if (tickets &lt;= 0) break;
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;

                System.out.println(Thread.currentThread().getName()
                 + &quot;出售票&quot; + tickets);
                tickets -= 1;
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="2-synchronized关键字对方法的同步"><a href="#2-synchronized关键字对方法的同步" class="headerlink" title="2 - synchronized关键字对方法的同步"></a>2 - synchronized关键字对方法的同步</h2><div class="code-wrapper"><pre><code>public class ThreadSynchronization &#123;
    public static void main(String[] args) &#123;
        TestThread  t = new TestThread();
        // 启动四个线程,并实现资源共享

        new Thread(t).start();
        new Thread(t).start();
        new Thread(t).start();
        new Thread(t).start();
    &#125;
&#125;

class TestThread implements Runnable&#123;
    private int tickets = 5;
    @Override
    public void run()&#123;
        while (tickets &gt; 0)&#123;
            sale();
        &#125;
    &#125;
    // 利用synchronized关键字对这本方法进行同步,避免共享资源的随意访问
    public synchronized void sale() &#123;
        if (tickets &gt; 0) &#123;
            try &#123;
                Thread.sleep(1000);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;

            System.out.println(Thread.currentThread().getName() + &quot;出售票&quot; + tickets);
            tickets -= 1;
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="3-在Java中-synchronized方法在同一时刻只能被一个线程调用，因此性能很差，从JDK1-5开始Java的API中引入了另一个锁的机制，这种锁机制包含在java-util-concurrent-locks包中"><a href="#3-在Java中-synchronized方法在同一时刻只能被一个线程调用，因此性能很差，从JDK1-5开始Java的API中引入了另一个锁的机制，这种锁机制包含在java-util-concurrent-locks包中" class="headerlink" title="3 - 在Java中,synchronized方法在同一时刻只能被一个线程调用，因此性能很差，从JDK1.5开始Java的API中引入了另一个锁的机制，这种锁机制包含在java.util.concurrent.locks包中"></a>3 - 在Java中,synchronized方法在同一时刻只能被一个线程调用，因此性能很差，从JDK1.5开始Java的API中引入了另一个锁的机制，这种锁机制包含在java.util.concurrent.locks包中</h2><h2 id="4-当系统中出现不同的读、写线程同时访问某一资源时，需要考虑共享互斥问题，可使用-synchronized-解决问题。若对性能要求较高的情况下，可考虑使用-ReadWriteLock-接口及其-ReentrantReadWriteLock-实现类。此外，为了在高并发情况下获取较高的吞吐率，建议使用-Lock-接口及其-ReentrantLock-实现类来替换以前的-synchronized-方法或代码块"><a href="#4-当系统中出现不同的读、写线程同时访问某一资源时，需要考虑共享互斥问题，可使用-synchronized-解决问题。若对性能要求较高的情况下，可考虑使用-ReadWriteLock-接口及其-ReentrantReadWriteLock-实现类。此外，为了在高并发情况下获取较高的吞吐率，建议使用-Lock-接口及其-ReentrantLock-实现类来替换以前的-synchronized-方法或代码块" class="headerlink" title="4 - 当系统中出现不同的读、写线程同时访问某一资源时，需要考虑共享互斥问题，可使用 synchronized 解决问题。若对性能要求较高的情况下，可考虑使用 ReadWriteLock 接口及其 ReentrantReadWriteLock 实现类。此外，为了在高并发情况下获取较高的吞吐率，建议使用 Lock 接口及其 ReentrantLock 实现类来替换以前的 synchronized 方法或代码块"></a>4 - 当系统中出现不同的读、写线程同时访问某一资源时，需要考虑共享互斥问题，可使用 synchronized 解决问题。若对性能要求较高的情况下，可考虑使用 ReadWriteLock 接口及其 ReentrantReadWriteLock 实现类。此外，为了在高并发情况下获取较高的吞吐率，建议使用 Lock 接口及其 ReentrantLock 实现类来替换以前的 synchronized 方法或代码块</h2><p>以上, 3-4段内容,均引自&lt;&lt;Java从入门到精通(第二版)&gt;&gt; 张玉宏主编 </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>多线程同步</tag>
      </tags>
  </entry>
  <entry>
    <title>Java操作MySQL数据库</title>
    <url>/2020/08/22/Java%E6%93%8D%E4%BD%9CMySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="1-首先-Java要连接MySQL数据库需要安装驱动包mysql-connector-java-8-0-16-jar-并导入此包"><a href="#1-首先-Java要连接MySQL数据库需要安装驱动包mysql-connector-java-8-0-16-jar-并导入此包" class="headerlink" title="1 - 首先, Java要连接MySQL数据库需要安装驱动包mysql-connector-java-8.0.16.jar, 并导入此包"></a>1 - 首先, Java要连接MySQL数据库需要安装驱动包<a href="https://static.runoob.com/download/mysql-connector-java-8.0.16.jar">mysql-connector-java-8.0.16.jar</a>, 并导入此包</h2><h2 id="2-准备相应的数据"><a href="#2-准备相应的数据" class="headerlink" title="2 - 准备相应的数据"></a>2 - 准备相应的数据</h2><div class="code-wrapper"><pre><code>static final String USER = &quot;用户名&quot;;
static final String PASS = &quot;密码&quot;;
static final String JDBC_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;
static final String DB_URL = &quot;jdbc:mysql://localhost:3306/数据库名称
?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;;</code></pre></div><h2 id="3-连接数据库"><a href="#3-连接数据库" class="headerlink" title="3 - 连接数据库"></a>3 - 连接数据库</h2><h3 id="3-1-导入sql包"><a href="#3-1-导入sql包" class="headerlink" title="3.1 导入sql包"></a>3.1 导入sql包</h3><div class="code-wrapper"><pre><code>import java.sql.*;</code></pre></div><h3 id="3-2-连接数据库"><a href="#3-2-连接数据库" class="headerlink" title="3.2 连接数据库"></a>3.2 连接数据库</h3><div class="code-wrapper"><pre><code>Connection conn = null;
Statement stmt = null;
// 注册 JDBC 驱动
Class.forName(JDBC_DRIVER);
// 打开链接
System.out.println(&quot;连接数据库...&quot;);
conn = DriverManager.getConnection(DB_URL,USER,PASS);</code></pre></div><h3 id="3-3-执行sql语句"><a href="#3-3-执行sql语句" class="headerlink" title="3.3 执行sql语句"></a>3.3 执行sql语句</h3><div class="code-wrapper"><pre><code>// 执行查询
System.out.println(&quot; 实例化Statement对象...&quot;);
stmt = conn.createStatement();
String sql;
sql = &quot;SELECT * FROM students&quot;;
ResultSet rs = stmt.executeQuery(sql);</code></pre></div><h3 id="3-4-获取数据"><a href="#3-4-获取数据" class="headerlink" title="3.4 获取数据"></a>3.4 获取数据</h3><div class="code-wrapper"><pre><code>int id  = rs.getInt(&quot;id&quot;);
String name = rs.getString(&quot;name&quot;);
String age = rs.getString(&quot;age&quot;);</code></pre></div><h3 id="3-5-打印数据"><a href="#3-5-打印数据" class="headerlink" title="3.5 打印数据"></a>3.5 打印数据</h3><div class="code-wrapper"><pre><code>System.out.println(&quot;我是&quot; + id + &quot;号同学, 我的名字是: &quot; + name + &quot;,
 我今年&quot; + age + &quot;岁.&quot;);
// 输出结果
我是1号同学, 我的名字是: 刘德华, 我今年56岁.</code></pre></div><h2 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4 - 完整代码"></a>4 - 完整代码</h2><div class="code-wrapper"><pre><code>public class MySqlDemo &#123;
static final String USER = &quot;用户名&quot;;
static final String PASS = &quot;密码&quot;;
static final String JDBC_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;
static final String DB_URL = &quot;jdbc:mysql://localhost:3306/数据库名称
?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;;

public static void main(String[] args) &#123;
    Connection conn = null;
    Statement stmt = null;
    try&#123;
        // 注册 JDBC 驱动
        Class.forName(JDBC_DRIVER);

        // 打开链接
        System.out.println(&quot;连接数据库...&quot;);
        conn = DriverManager.getConnection(DB_URL,USER,PASS);

        // 执行查询
        System.out.println(&quot; 实例化Statement对象...&quot;);
        stmt = conn.createStatement();
        String sql;
        sql = &quot;SELECT * FROM students&quot;;
        ResultSet rs = stmt.executeQuery(sql);
        System.out.println(rs);
        // 展开结果集数据库
        while(rs.next())&#123;
            // 通过字段检索
            int id  = rs.getInt(&quot;id&quot;);
            String name = rs.getString(&quot;name&quot;);
            String age = rs.getString(&quot;age&quot;);

            // 输出数据
            System.out.println(&quot;我是&quot; + id +
                    &quot;号同学, 我的名字是: &quot; + name +
                    &quot;, 我今年&quot; + age + &quot;岁.&quot;);
        &#125;
        // 完成后关闭
        rs.close();
        stmt.close();
        conn.close();
    &#125;catch(SQLException se)&#123;
        // 处理 JDBC 错误
        se.printStackTrace();
    &#125;catch(Exception e)&#123;
        // 处理 Class.forName 错误
        e.printStackTrace();
    &#125;finally&#123;
        // 关闭资源
        try&#123;
            if(stmt!=null) stmt.close();
        &#125;catch(SQLException se2)&#123;
        &#125;// 什么都不做
        try&#123;
            if(conn!=null) conn.close();
        &#125;catch(SQLException se)&#123;
            se.printStackTrace();
        &#125;
    &#125;
    System.out.println(&quot;Goodbye!&quot;);
  &#125;
&#125;</code></pre></div>]]></content>
      <categories>
        <category>Java</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的注释接口</title>
    <url>/2020/08/07/Java%E7%9A%84%E6%B3%A8%E9%87%8A%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<blockquote>
<p>  注解 - 给编译器看的注释</p>
</blockquote>
<h2 id="1-Override注释用来告诉编译器这个方法是用来改写父类对应方法的"><a href="#1-Override注释用来告诉编译器这个方法是用来改写父类对应方法的" class="headerlink" title="1. @Override注释用来告诉编译器这个方法是用来改写父类对应方法的"></a>1. @Override注释用来告诉编译器这个方法是用来改写父类对应方法的</h2><div class="code-wrapper"><pre><code>class Message&#123;
    @Override
    public String toString()&#123;
        return &quot;Hello world!&quot;;
    &#125;
&#125;</code></pre></div><p>如果改写的方法名，参数，类型有错误编译器会报错，可以给程序员提示。</p>
<h2 id="2-Deprecated注释表示这个方法已经过时，不建议使用"><a href="#2-Deprecated注释表示这个方法已经过时，不建议使用" class="headerlink" title="2. @Deprecated注释表示这个方法已经过时，不建议使用"></a>2. @Deprecated注释表示这个方法已经过时，不建议使用</h2><div class="code-wrapper"><pre><code>class Info&#123;
    @Deprecated
    public String getInfo()&#123;
        return &quot;Hello world.&quot;;
    &#125;
&#125;</code></pre></div><p>被注释的方法仍然可以使用，只是编译器不推荐而已</p>
<h2 id="3-SuppressWarnings注释用来压制”某些”的警告信息"><a href="#3-SuppressWarnings注释用来压制”某些”的警告信息" class="headerlink" title="3. @SuppressWarnings注释用来压制”某些”的警告信息"></a>3. @SuppressWarnings注释用来压制”某些”的警告信息</h2><div class="code-wrapper"><pre><code>public class SuppressWarningsAnnotation &#123;
    public static void main(String[] args) &#123;
        // 用来压制&quot;未使用&quot;的警告信息
        @SuppressWarnings(&quot;unused&quot;)
        int i;
        System.out.println(&quot;Hello world.&quot;);
    &#125;
&#125;</code></pre></div><p>在这个例子中我们通过往注释中添加“unused”参数，来压制变量未使用这一警告信息</p>
<h2 id="4-实现我们自己自定义的注释，必须使用-interface接口来修饰"><a href="#4-实现我们自己自定义的注释，必须使用-interface接口来修饰" class="headerlink" title="4. 实现我们自己自定义的注释，必须使用@interface接口来修饰"></a>4. 实现我们自己自定义的注释，必须使用@interface接口来修饰</h2><div class="code-wrapper"><pre><code>@interface Anno&#123;
    public String key();
    public String value();
&#125;

public class TestAnno &#123;
    @Anno(key = &quot;var1&quot;, value = &quot;test&quot;)
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello world!&quot;);
    &#125;
&#125;</code></pre></div><p>我们可以在自己实现的注释里添加属性或方法</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>注解</tag>
        <tag>给编译器看的注释</tag>
      </tags>
  </entry>
  <entry>
    <title>Java简单实现多线程</title>
    <url>/2020/08/11/Java%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-直接继承Thread类-来实现多线程"><a href="#1-直接继承Thread类-来实现多线程" class="headerlink" title="1- 直接继承Thread类,来实现多线程"></a>1- 直接继承Thread类,来实现多线程</h2><div class="code-wrapper"><pre><code>public class ThreadDemo &#123;
    public static void main(String[] args) &#123;
        new TestThread().start(); // 激活一个线程

        // 循环输出
        for (int i = 0; i &lt; 5; i++) &#123;
            System.out.println(&quot;main线程在运行&quot;);

            try &#123;
                Thread.sleep(1000); // 睡眠1000毫秒,即一秒
            &#125;catch (InterruptedException ex)&#123;
                ex.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;

class TestThread extends Thread&#123;
    @Override
    public void run()&#123;
        for (int i = 0; i &lt; 5; i++) &#123;
            System.out.println(&quot;TestThread在运行!&quot;);

            try &#123;
                Thread.sleep(1000); // 睡眠1000毫秒,即一秒
            &#125; catch (InterruptedException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="2-利用Runnable接口-来实现多线程"><a href="#2-利用Runnable接口-来实现多线程" class="headerlink" title="2-利用Runnable接口,来实现多线程"></a>2-利用Runnable接口,来实现多线程</h2><div class="code-wrapper"><pre><code>public class RunnableThreadDemo &#123;
    public static void main(String[] args) &#123;
        TestThread t = new TestThread2();
        new Thread(t).start(); // 使用Thread类的start方法启动线程

        // 循环输出
        for (int i = 0; i &lt; 5; i++) &#123;
            System.out.println(&quot;main线程在运行&quot;);

            try &#123;
                Thread.sleep(1000); // 睡眠1000毫秒,即一秒
            &#125;catch (InterruptedException ex)&#123;
                ex.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;

class TestThread implements Runnable&#123;
    @Override
    public void run()&#123;
        for (int i = 0; i &lt; 5; i++) &#123;
            System.out.println(&quot;TestThread在运行!&quot;);

            try &#123;
                Thread.sleep(1000); // 睡眠1000毫秒,即一秒
            &#125; catch (InterruptedException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div><p>无论哪种方式实现多线程,最好覆写run()方法</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Liunx 一般配置与命令</title>
    <url>/2021/05/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-Liunx-常用命令"><a href="#1-Liunx-常用命令" class="headerlink" title="1 Liunx 常用命令"></a>1 Liunx 常用命令</h1><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><table>
<thead>
<tr>
<th>描述</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>编辑环境变量</td>
<td>vim /etc/profile</td>
</tr>
<tr>
<td>生效环境变量</td>
<td>source /etc/profile</td>
</tr>
<tr>
<td>检查目标服务的端口监听状态</td>
<td>netstat -ntlp | grep 3306</td>
</tr>
<tr>
<td>启动目标服务</td>
<td>systemctl start service</td>
</tr>
<tr>
<td>检查目标服务的状态</td>
<td>systemctl status service</td>
</tr>
<tr>
<td>停止目标服务</td>
<td>systemctl stop service</td>
</tr>
<tr>
<td>查看安装包</td>
<td>rpm -qa | grep Git</td>
</tr>
<tr>
<td>添加用户组 docker</td>
<td>sudo groupadd docker</td>
</tr>
<tr>
<td>将登陆用户加入到 docker 用户组中</td>
<td>sudo gpasswd -a $USER docker</td>
</tr>
<tr>
<td>更新用户组</td>
<td>newgrp docker</td>
</tr>
<tr>
<td>关闭防火墙</td>
<td>systemctl stop firewalld.service</td>
</tr>
<tr>
<td>永久关闭防火墙</td>
<td>systemctl disable firewalld.service</td>
</tr>
<tr>
<td>设置主机名</td>
<td>hostnamectl set-hostname pncalbl-pc</td>
</tr>
</tbody></table>
<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><table>
<thead>
<tr>
<th>描述</th>
<th>命令模式</th>
<th>底线命令模式</th>
</tr>
</thead>
<tbody><tr>
<td>移到最第一行</td>
<td>gg</td>
<td>:0或:1</td>
</tr>
<tr>
<td>移到最后一行</td>
<td>shift+g</td>
<td>:$</td>
</tr>
<tr>
<td>搜索字符串</td>
<td>查看下一个  按下 n<br>转到上一个  按下 N</td>
<td>:/字符串</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="2-设置快捷键"><a href="#2-设置快捷键" class="headerlink" title="2 设置快捷键"></a>2 设置快捷键</h1><ol>
<li>进入设置 / <code>settings</code></li>
<li>进入 <code>Keyboard</code></li>
<li>点击 添加按钮 <code>+</code></li>
<li>定义名称 <code>Open Terminal</code></li>
<li>输入命令 <code>/usr/bin/gnome-terminal</code></li>
</ol>
<h1 id="3-更换-yum-源"><a href="#3-更换-yum-源" class="headerlink" title="3 更换 yum 源"></a>3 更换 yum 源</h1><h2 id="1-下载wget的rpm包"><a href="#1-下载wget的rpm包" class="headerlink" title="1.下载wget的rpm包"></a>1.下载wget的rpm包</h2><p>首先去<a href="http://mirrors.163.com/centos/7/os/x86_64/Packages/找到wget的rpm包，复制链接，使用curl命令下载">http://mirrors.163.com/centos/7/os/x86_64/Packages/找到wget的rpm包，复制链接，使用curl命令下载</a></p>
<p><img src="/2021/05/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1089423-20191203231224175-577731216.png" alt="img"></p>
<p> 使用curl下载（注意相关的包版本可能已经变，请以最新的下载地址为准)）</p>
<div class="code-wrapper"><pre><code class="hljs shell">curl http://mirrors.163.com/centos/7/os/x86_64/Packages/wget-1.14-18.el7_6.1.x86_64.rpm</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs shell">rpm -ivh wget-1.14-18.el7_6.1.x86_64.rpm</code></pre></div>

<h2 id="2-安装yum"><a href="#2-安装yum" class="headerlink" title="2.安装yum"></a>2.安装yum</h2><p> 1.删除原有的yum</p>
<div class="code-wrapper"><pre><code class="hljs shell">rpm -aq|grep yum|xargs rpm -e --nodeps</code></pre></div>

<p> 2.下载yum,注意自己的LINUX系统版本，是什么版本就进相关版本目录去下载。但小版本的目录就不用进了。如版本是6.5，就只需进6 目录，版本是 7.2，只需进7目录</p>
<div class="code-wrapper"><pre><code class="hljs shell">1 yum-*.rpm
2 yum-metadata-parser-*.rpm
3 yum-plugin-fastestmirror-*.rpm
4 python-iniparse-*.rpm</code></pre></div>

<p>3.使用wget下载(注意相关的包版本可能已经变，请以最新的下载地址为准)</p>
<div class="code-wrapper"><pre><code class="hljs shell">wget https://mirrors.163.com/centos/7/os/x86_64/Packages/yum-3.4.3-168.el7.centos.noarch.rpm
wget https://mirrors.163.com/centos/7/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm
wget https://mirrors.163.com/centos/7/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpm
wget https://mirrors.163.com/centos/7/os/x86_64/Packages/python-iniparse-0.4-9.el7.noarch.rpm</code></pre></div>

<p>4.下载后安转yum依赖的包</p>
<div class="code-wrapper"><pre><code class="hljs shell">rpm -ivh python-iniparse-*.rpm
rpm -ivh yum-*.rpm  yum-metadata-parser-*.rpm  yum-plugin-fastestmirror-*.rpm</code></pre></div>

<h2 id="3-修改yum源"><a href="#3-修改yum源" class="headerlink" title="3.修改yum源"></a>3.修改yum源</h2><p> 1.进入到系统yum源的目录下：</p>
<div class="code-wrapper"><pre><code class="hljs shell">cd /etc/yum.repos.d</code></pre></div>

<p> 2.下载yum源</p>
<div class="code-wrapper"><pre><code class="hljs shell">wget http://mirrors.163.com/.help/CentOS7-Base-163.repo</code></pre></div>

<p> 3.修改源文件名（注意需要把之前的删掉，或者改为.bak文件）</p>
<div class="code-wrapper"><pre><code class="hljs shell">mv CentOS7-Base-163.repo CentOS-Base.repo</code></pre></div>

<p>4.运行makecache 生成缓存 使配置生效</p>
<div class="code-wrapper"><pre><code class="hljs shell">yum makecache</code></pre></div>

<p>5.验证yum源</p>
<div class="code-wrapper"><pre><code class="hljs shell">yum repolist
查看是否有163的标识 有则证明配置国内163镜像源成功</code></pre></div>

<p>7.运行yum clean all（等同于 yum cleanheaders ; yum cleanpackages）;</p>
<div class="code-wrapper"><pre><code class="hljs shell">yum clean all
yum 会把下载的软件包和header存储在cache中，而不自动删除。如果觉得占用磁盘空间，可以使用yum clean指令进行清除，更精确 的用法是yum clean headers清除header，yum clean packages清除下载的rpm包，yum clean all一全部清除。</code></pre></div>

<p>8.更新YUM文件 全部更新软件包</p>
<div class="code-wrapper"><pre><code class="hljs shell">yum  update</code></pre></div>

<p>10.yum常用操作</p>
<div class="code-wrapper"><pre><code class="hljs shell">yum install XXX

yum remove XXX

yum list

yum list installed</code></pre></div>

<h1 id="4-美化界面"><a href="#4-美化界面" class="headerlink" title="4 美化界面"></a>4 美化界面</h1><ol>
<li><p>先安装 gnome-tweak-tool</p>
<div class="code-wrapper"><pre><code class="hljs shell">yum install gnome-tweak-tool</code></pre></div>
</li>
<li><p>主题：<a href="mailto:git@gitzab.com">git@gitzab.com</a>:Anduin/GNOME-OSX-II-Theme.git </p>
<p>解压 GNOME-OSX-II-Theme-master.zip 到 /home/pncalbl/.themes </p>
<p>在 tweak 中切换主题 GNOME-OSX-II-Theme</p>
</li>
<li><p>图标：<a href="mailto:git@github.com">git@github.com</a>:keeferrourke/la-capitaine-icon-theme.git </p>
<p>解压 la-capitaine-icon-theme-master.zip 到 /home/pncalbl/.icons</p>
<p>在 tweak 中切换主题 图标</p>
</li>
<li><p>启动器：<a href="mailto:git@github.com">git@github.com</a>:micheleg/dash-to-dock.git</p>
</li>
</ol>
<h1 id="5-生成密钥"><a href="#5-生成密钥" class="headerlink" title="5 生成密钥"></a>5 生成密钥</h1><ol>
<li>生成秘钥</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs shell">//换成你自己的邮箱
ssh-keygen -t rsa -C &quot;pncalbl@qq.com&quot;
//一直next并记住生成的地址
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):
Created directory &#x27;/root/.ssh&#x27;.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.</code></pre></div>

<ol>
<li>进入.ssh 目录提出key</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs shell">[root@localhost ~]# cd .ssh
[root@localhost .ssh]# ls
id_rsa  id_rsa.pub
//把显示的内容复制到GitHub的SSHkey配置即可
[root@localhost .ssh]# cat id_rsa.pub</code></pre></div>

<ol>
<li>测试</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs shell">[root@localhost .ssh]# ssh -T git@github.com
The authenticity of host &#x27;github.com (192.30.255.113)&#x27; can&#x27;t be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)? y
Please type &#x27;yes&#x27; or &#x27;no&#x27;: yes
Warning: Permanently added &#x27;github.com,192.30.255.113&#x27; (RSA) to the list of known hosts.
Hi megoc! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</code></pre></div>

<h1 id="6-重载-VMware-tools"><a href="#6-重载-VMware-tools" class="headerlink" title="6 重载 VMware tools"></a>6 重载 VMware tools</h1><p>以下命令都在 root 权限下进行</p>
<ol>
<li>卸载   <code>yum remove open-vm-tools</code></li>
<li>使用 VM 安装 <code>VMware Tools</code></li>
<li>从光盘复制出 VMwareTools-10.3.21-14772444.tar.gz</li>
<li>解压缩 tar -zxvf  VMwareTools-10.3.21-14772444.tar.gz -C ./</li>
<li>执行  <code>./vmware-install.pl</code></li>
<li><code>第一步输入: y</code>, 剩下的按回车默认即可</li>
</ol>
]]></content>
      <categories>
        <category>Help</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Liunx 配置静态IP</title>
    <url>/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/</url>
    <content><![CDATA[<h1 id="Liunx-配置静态IP-基于CentOS-7"><a href="#Liunx-配置静态IP-基于CentOS-7" class="headerlink" title="Liunx 配置静态IP (基于CentOS  7)"></a>Liunx 配置静态IP (基于CentOS  7)</h1><blockquote>
<p>  只要Vmware的虚拟网络编辑器配置好, 其他liunx系统配置基本一样, 只是有些命令不同而已</p>
</blockquote>
<h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1 原理"></a>1 原理</h2><ul>
<li>先看看虚拟机和主机连接的条件：</li>
</ul>
<ul>
<li>需要主机的Vmware8的ip、Vmware8网关ip、虚拟机(centOs)网卡eth0的ip在同一网段下，如图（都是192.168.145.x）：</li>
</ul>
<p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/20201201012406421.png" alt="img"></p>
<p>图片来自网络, 侵权请联系<a href="pncalbl@qq.com">author</a>删除</p>
<ul>
<li>一般地，如果虚拟机与主机通信走的是虚线，访问外网则走的实线，其控制程序在虚拟机网关设备中实现</li>
</ul>
<ul>
<li>但是，一般由于工作环境的变化，导致网络的改变，有时候会导致虚拟机网段改变，从而与主机连不通，在CentOs下使用ifconfig发现ens33 ip不再192.168.145这个段上，这时，重置eth0的ip即可，方法：ifconfig ens33 192.168.145.xxx</li>
</ul>
<h2 id="2-修改虚拟机网络编辑器"><a href="#2-修改虚拟机网络编辑器" class="headerlink" title="2 修改虚拟机网络编辑器"></a>2 修改虚拟机网络编辑器</h2><ul>
<li><p>点击 编辑-&gt;虚拟机网络编辑器</p>
<p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430180711181.png" alt="image-20210430180711181"></p>
<p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430181747517.png" alt="image-20210430181747517"></p>
</li>
</ul>
<p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430181845286.png" alt="image-20210430181845286"></p>
<ul>
<li><p>如果子网不对, 可以还原默认设置</p>
<p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430182036414.png" alt="image-20210430182036414"></p>
</li>
</ul>
<h2 id="3-更改网络适配器"><a href="#3-更改网络适配器" class="headerlink" title="3 更改网络适配器"></a>3 更改网络适配器</h2><blockquote>
<p>  VMware Virtual Ethernet Adapter for VMnet8 (NAT)</p>
</blockquote>
<ul>
<li><p>点击IPv4</p>
<p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430190450485.png" alt="image-20210430190450485"></p>
</li>
<li><p>修改</p>
<p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430190551654.png" alt="image-20210430190551654"></p>
</li>
</ul>
<h2 id="4-修改ens33"><a href="#4-修改ens33" class="headerlink" title="4 修改ens33"></a>4 修改ens33</h2><ul>
<li><p>进入 网卡配置</p>
<ul>
<li><p>centOS</p>
<div class="code-wrapper"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>sysconfig<span class="hljs-regexp">/network-scripts/i</span>fcfg-ens33</code></pre></div>
</li>
<li><p>ubunto</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">gedit</span> /etc/netplan/<span class="hljs-number">01</span>-network-manager-<span class="hljs-literal">all</span>.yaml</code></pre></div>
</li>
</ul>
</li>
<li><p>修改参数</p>
<ul>
<li><p>centOS</p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">HWADDR</span>=<span class="hljs-number">00</span>:<span class="hljs-number">0</span>C:<span class="hljs-number">29</span>:<span class="hljs-number">0</span>D:<span class="hljs-number">73</span>:CF
<span class="hljs-attr">TYPE</span>=Ethernet
<span class="hljs-attr">PROXY_METHOD</span>=none
<span class="hljs-attr">BROWSER_ONLY</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">BOOTPROTO</span>=static	<span class="hljs-comment"># 静态IP</span>
<span class="hljs-attr">DEFROUTE</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span>
<span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span>
<span class="hljs-attr">IPV6_ADDR_GEN_MODE</span>=stable-privacy
<span class="hljs-attr">NAME</span>=ens33
<span class="hljs-attr">UUID</span>=<span class="hljs-number">13000</span>fee-<span class="hljs-number">503</span>a-<span class="hljs-number">350</span>c-<span class="hljs-number">9462</span>-d70dd1ede195
<span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span>	<span class="hljs-comment">#开机启用本配置</span>
<span class="hljs-attr">AUTOCONNECT_PRIORITY</span>=-<span class="hljs-number">999</span>
<span class="hljs-attr">IPADDR</span>=ipv4	<span class="hljs-comment">#ipv4</span>
<span class="hljs-attr">PREFIX</span>=<span class="hljs-number">24</span>
<span class="hljs-attr">GATEWAY</span>=网关 <span class="hljs-comment">#网关</span>
<span class="hljs-attr">DNS1</span>=<span class="hljs-number">119.29</span>.<span class="hljs-number">29.29</span>	<span class="hljs-comment"># 域名解析</span></code></pre></div>
</li>
<li><p>ubunto</p>
<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span>
  <span class="hljs-attr">ethernets:</span>
          <span class="hljs-attr">ens33:</span>
                  <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span>
                  <span class="hljs-attr">dhcp6:</span> <span class="hljs-literal">no</span>
                  <span class="hljs-attr">addresses:</span> [<span class="hljs-string">ipv4</span>]
                  <span class="hljs-attr">gateway4:</span> <span class="hljs-string">网关</span>
                  <span class="hljs-attr">nameservers:</span>
                          <span class="hljs-attr">addresses:</span> [<span class="hljs-number">119.29</span><span class="hljs-number">.29</span><span class="hljs-number">.29</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>]</code></pre></div>
</li>
</ul>
</li>
<li><p>重启网络服务</p>
<div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">service network restart</span></code></pre></div>
</li>
<li><p>查看ip</p>
<div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span></code></pre></div>
</li>
<li><p>测试</p>
<div class="code-wrapper"><pre><code class="hljs autoit"><span class="hljs-built_in">ping</span> www.baidu.com</code></pre></div>



</li>
</ul>
]]></content>
      <categories>
        <category>Help</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>静态IP</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 学习</title>
    <url>/2021/05/01/MongoDB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="MongoDB-学习"><a href="#MongoDB-学习" class="headerlink" title="MongoDB 学习"></a>MongoDB 学习</h1>]]></content>
      <categories>
        <category>Technical</category>
        <category>DB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js的安装和环境变量的配置</title>
    <url>/2021/04/13/NodeJs%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1, 下载安装包"></a>1, 下载安装包</h2><p>去 <a href="https://nodejs.org/en/">nodejs官网</a> 下载 找到 <a href="https://nodejs.org/dist/latest-v12.x/">node-v12</a> 的下载清单，找到 node-v12.22.1-x64.msi，下载即可。</p>
<p><img src="/2021/04/13/NodeJs%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/image-20210413131804825.png" alt="image-20210413131804825"></p>
<h2 id="2，安装"><a href="#2，安装" class="headerlink" title="2，安装"></a>2，安装</h2><p>除了要修改安装路径之外， 其他一切默认即可。</p>
<p><img src="/2021/04/13/NodeJs%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/20200224001033440.png" alt="img"></p>
<h2 id="3，环境配置"><a href="#3，环境配置" class="headerlink" title="3，环境配置"></a>3，环境配置</h2><ul>
<li>一般默认安装，都会将路径添加系统变量的path里，所以可以通过，node -v 和 npm -v 查看版本号。</li>
</ul>
<p><img src="/2021/04/13/NodeJs%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/image-20210413132613848.png" alt="image-20210413132613848"></p>
<ul>
<li><p>一般开始安装的npm 都是6.x 版本， 我们之后可以通过 npm install -g npm 来做npm的全局升级。</p>
</li>
<li><p>之后我们需要在 D:\PNCA\environment\nodejs\node-v12.22.0\ 新建两个包</p>
<ul>
<li><strong>node_cache</strong></li>
<li><strong>node_global</strong></li>
<li>因为开始默认是在 C:\Users\Administrator\AppData\Roaming\npm\node_modules 下，安装全局包的，所以我们修改到D盘下。</li>
<li>可以通过 <strong>npm root -g</strong> 来查看全局包的路径</li>
</ul>
</li>
<li><p>然后在命令行里运行两条命令</p>
<ul>
<li>npm config set prefix “D:\PNCA\environment\nodejs\node-v12.22.0\node_global”</li>
<li>npm config set cache “D:\PNCA\environment\nodejs\node-v12.22.0\node_cache”</li>
</ul>
</li>
<li><p>找到 D:\PNCA\environment\nodejs\node-v12.22.0\node_modules\npm\ 下的 .npmrc。</p>
<p><img src="/2021/04/13/NodeJs%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/image-20210413133432356.png" alt="image-20210413133432356"></p>
<ul>
<li>修改其内容为：</li>
<li>prefix=D:\PNCA\environment\nodejs\node-v12.22.0\node_global</li>
<li>cache=D:\PNCA\environment\nodejs\node-v12.22.0\node_cache</li>
</ul>
</li>
<li><p>修改用户变量</p>
<p>D:\PNCA\environment\nodejs\node-v12.22.0\node_global</p>
</li>
<li><p>在系统变量里</p>
<p>添加 NODE_HOME: D:\PNCA\environment\nodejs\node-v12.22.0\node_modules\</p>
</li>
</ul>
<h2 id="4，测试"><a href="#4，测试" class="headerlink" title="4，测试"></a>4，测试</h2><p>npm install express -g</p>
]]></content>
      <categories>
        <category>Help</category>
        <category>Win</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Python使用协程做离散事件仿真</title>
    <url>/2020/08/28/Python%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%81%9A%E7%A6%BB%E6%95%A3%E4%BA%8B%E4%BB%B6%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<h2 id="1-需要导入的库"><a href="#1-需要导入的库" class="headerlink" title="1 - 需要导入的库"></a>1 - 需要导入的库</h2><div class="code-wrapper"><pre><code>import collections
import queue
Event = collections.namedtuple(&apos;Event&apos;, &apos;time proc action&apos;)</code></pre></div><h2 id="2-主类和主程序"><a href="#2-主类和主程序" class="headerlink" title="2 - 主类和主程序"></a>2 - 主类和主程序</h2><div class="code-wrapper"><pre><code>def taxi_process(ident, trips, start_time=0):
    &quot;&quot;&quot;每次改变状态时创建事件,把控制权让给仿真器&quot;&quot;&quot;
    time = yield Event(start_time, ident, &apos;leave garage&apos;)
    for i in range(trips):
        time = yield Event(time, ident, &apos;pick up passenger&apos;)
        time = yield Event(time, ident, &apos;drop off passenger&apos;)
    yield Event(time, ident, &apos;going home&apos;)
    # 出租车进程结束

def compute_duration(previous_action):
    print()
    # 未完成功能
    pass

class Simulator:
def __init__(self, procs_map):
    self.events = queue.PriorityQueue()
    self.procs = dict(procs_map)

def run(self, end_time):
    &quot;&quot;&quot;排定并显示事件,直到时间结束&quot;&quot;&quot;

    # 排定各俩出租车的第一个事件
    for _, proc in sorted(self.procs.items()):
        first_event = next(proc)
        self.events.put(first_event)

    # 这个仿真系统的主循环
    sim_time = 0
    while sim_time &lt; end_time:
        if self.events.empty():
            print(&apos;*** end of events ***&apos;)
            break
        current_event = self.events.get()
        sim_time, proc_id, previous_action = current_event
        print(&apos;taxi: &apos;, proc_id, proc_id * &apos; &apos;, current_event)
        active_proc = self.procs[proc_id]
        next_time = sim_time + compute_duration(previous_action)

        try:
            next_event = active_proc.send(next_time)
        except StopIteration:
            del self.procs[proc_id]
        else:
            self.events.put(next_event)
    else:
        msg = &apos;*** end of simulation time:&#123;&#125; events pending ***&apos;
        print(msg.format(self.events.qsize()))</code></pre></div><h2 id="3-启动函数"><a href="#3-启动函数" class="headerlink" title="3 - 启动函数"></a>3 - 启动函数</h2><div class="code-wrapper"><pre><code>if __name__ == &apos;__main__&apos;:
    taxi = taxi_process(ident=13, trips=2, start_time=0)
    print(next(taxi))
    print(taxi.send(_.time + 7))</code></pre></div>]]></content>
      <tags>
        <tag>出租车队运营仿真</tag>
      </tags>
  </entry>
  <entry>
    <title>Python使用@property装饰器</title>
    <url>/2020/09/09/Python%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h3 id="1-1-这里已经使用特性的设值方法了，确保所创建实例的weight属性不能为负值。2-property装饰读值方法。3-实现特性的方法，其名称都与公开属性的名称一样——weight。4-真正的值存储在私有属性-weight中"><a href="#1-1-这里已经使用特性的设值方法了，确保所创建实例的weight属性不能为负值。2-property装饰读值方法。3-实现特性的方法，其名称都与公开属性的名称一样——weight。4-真正的值存储在私有属性-weight中" class="headerlink" title="1 - 1 这里已经使用特性的设值方法了，确保所创建实例的weight属性不能为负值。2@property装饰读值方法。3 实现特性的方法，其名称都与公开属性的名称一样——weight。4 真正的值存储在私有属性__weight中"></a>1 - 1 这里已经使用特性的设值方法了，确保所创建实例的weight属性不能为负值。2@property装饰读值方法。3 实现特性的方法，其名称都与公开属性的名称一样——weight。4 真正的值存储在私有属性__weight中</h3><div class="code-wrapper"><pre><code>class LineItem:
    &quot;&quot;&quot;使用@property装饰器实现可读写的特性&quot;&quot;&quot;
    &quot;&quot;&quot;表示订单中商品的类&quot;&quot;&quot;
    def __init__(self, description, weight, price):
        self.description = description
        self.weight = weight
        self.price = price

    def subtotal(self):
        return self.weight * self.price

    @property
    def weight(self):
        return self.__weight

    @weight.setter
    def weight(self, value):
        if value &gt; 0:
            self.__weight = value
        else:
            raise ValueError(&apos;value must be &gt; 0&apos;)</code></pre></div><h3 id="2-5-被装饰的读值方法有个-setter属性，这个属性也是装饰器；这个装饰器把读值方法和设值方法绑定在一起。6-如果值大于零，设置私有属性-weight。7-否则，抛出ValueError异常"><a href="#2-5-被装饰的读值方法有个-setter属性，这个属性也是装饰器；这个装饰器把读值方法和设值方法绑定在一起。6-如果值大于零，设置私有属性-weight。7-否则，抛出ValueError异常" class="headerlink" title="2 - 5 被装饰的读值方法有个.setter属性，这个属性也是装饰器；这个装饰器把读值方法和设值方法绑定在一起。6 如果值大于零，设置私有属性__weight。7 否则，抛出ValueError异常"></a>2 - 5 被装饰的读值方法有个.setter属性，这个属性也是装饰器；这个装饰器把读值方法和设值方法绑定在一起。6 如果值大于零，设置私有属性__weight。7 否则，抛出ValueError异常</h3>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
        <tag>可读性</tag>
      </tags>
  </entry>
  <entry>
    <title>Python使用覆盖型描述符</title>
    <url>/2020/09/10/Python%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E5%9E%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="1-导入模块"><a href="#1-导入模块" class="headerlink" title="1- 导入模块"></a>1- 导入模块</h2><div class="code-wrapper"><pre><code>import abc</code></pre></div><h2 id="2-主要的几个基础类"><a href="#2-主要的几个基础类" class="headerlink" title="2 - 主要的几个基础类"></a>2 - 主要的几个基础类</h2><div class="code-wrapper"><pre><code>class AutoStorage:
    __counter = 0
    def __init__(self, ):
        cls = self.__class__
        prefix = cls.__name__
        index = cls.__counter
        self.storage_name = &apos;_&#123;&#125;#&#123;&#125;&apos;.format(prefix, index)
        cls.__counter += 1

    def __get__(self, instance, owner):
        if instance is None:
            return self
        else:
            return getattr(instance, self.storage_name)

    def __set__(self, instance, value):
        if value &gt; 0:
            setattr(instance, self.storage_name, value)
        else:
            raise ValueError(&apos;value must be &gt; 0&apos;)


class Validated(abc.ABC, AutoStorage):
    def __set__(self, instance, value):
        value = self.validate(instance, value)
        super().__set__(instance, value)
    @abc.abstractmethod
    def validate(self, instance, value):
        &quot;&quot;&quot;return validated value or raise ValueError&quot;&quot;&quot;

class Quantity(Validated):
    &quot;&quot;&quot;a number greater than zero&quot;&quot;&quot;
    def validate(self, instance, value):
        if value &lt;= 0:
            raise ValueError(&apos;value must be &gt; 0&apos;)
        return value

class NonBlank(Validated):
&quot;&quot;&quot;a string with at least one non-space character&quot;&quot;&quot;
def validate(self, instance, value):
    value = value.strip()
    if len(value) == 0:
        raise ValueError(&apos;value cannot be empty or blank&apos;)
    return value</code></pre></div><p>AutoStorage自动管理储存属性的描述符类。Validated扩展AutoStorage类的抽象子类，覆盖<strong>set</strong>方法，调用必须由子类实现的validate方法。</p>
<h2 id="3-主要实现的类"><a href="#3-主要实现的类" class="headerlink" title="3 - 主要实现的类"></a>3 - 主要实现的类</h2><div class="code-wrapper"><pre><code>class LineItem:
    description = NonBlank()
    weight = Quantity()
    price = Quantity()

    def __init__(self, description, weight, price):
        self.description = description
        self.weight = weight
        self.price = price

    def subtotal(self):
        return self.weight * self.price</code></pre></div>]]></content>
  </entry>
  <entry>
    <title>Python关于迭代器和生成器</title>
    <url>/2020/08/24/Python%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="1-使用迭代器实现Sentence类"><a href="#1-使用迭代器实现Sentence类" class="headerlink" title="1 - 使用迭代器实现Sentence类"></a>1 - 使用迭代器实现Sentence类</h2><h3 id="1-1-具体的实现代码"><a href="#1-1-具体的实现代码" class="headerlink" title="1.1 具体的实现代码"></a>1.1 具体的实现代码</h3><div class="code-wrapper"><pre><code>import re
import reprlib

RE_WORD = re.compile(&apos;\w+&apos;)

class Sentence:
    &quot;&quot;&quot;定义了一个Sentence类，通过索引从文本中提取单词&quot;&quot;&quot;
    def __init__(self, text):
        self.text = text
        # re.findall函数返回一个字符串列表，里面的元素是正则表达式的
        全部非重叠匹配
        self.words = RE_WORD.findall(text)

    def __getitem__(self, index):
        return self.words[index]

    def __len__(self):
        return len(self.words)

    def __repr__(self):
        # reprlib.repr这个实用函数用于生成大型数据结构的简略字符串表示形式
        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)</code></pre></div><h3 id="1-2-测试用例"><a href="#1-2-测试用例" class="headerlink" title="1.2 测试用例"></a>1.2 测试用例</h3><div class="code-wrapper"><pre><code>if __name__ == &apos;__main__&apos;:
    s = Sentence(&apos;&quot;The times has come, &quot; Walrus said,&apos;)
    print(s)
    for word in s:
        print(word)
    print(list(s))</code></pre></div><h3 id="1-3-输出示例"><a href="#1-3-输出示例" class="headerlink" title="1.3 输出示例"></a>1.3 输出示例</h3><div class="code-wrapper"><pre><code>Sentence(&apos;&quot;The times h... Walrus said,&apos;)
The
times
has
come
Walrus
said
[&apos;The&apos;, &apos;times&apos;, &apos;has&apos;, &apos;come&apos;, &apos;Walrus&apos;, &apos;said&apos;]</code></pre></div><h2 id="2-使用生成器函数实现Sentence类"><a href="#2-使用生成器函数实现Sentence类" class="headerlink" title="2 - 使用生成器函数实现Sentence类"></a>2 - 使用生成器函数实现Sentence类</h2><h3 id="2-1-具体的实现代码"><a href="#2-1-具体的实现代码" class="headerlink" title="2.1 具体的实现代码"></a>2.1 具体的实现代码</h3><div class="code-wrapper"><pre><code>import re
import reprlib
RE_WORD = re.compile(&apos;\w+&apos;)

class Sentence:
 &quot;&quot;&quot;定义了一个Sentence类，通过索引从文本中提取单词&quot;&quot;&quot;
    def __init__(self, text):
        self.text = text
        self.words = RE_WORD.findall(text)

    def __repr__(self):
        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)

    def __iter__(self):
        for word in self.words:
            yield word
        return

# 惰性实现
import re
import reprlib
RE_WORD = re.compile(&apos;\w+&apos;)

class Sentence:
 &quot;&quot;&quot;定义了一个Sentence类，通过索引从文本中提取单词&quot;&quot;&quot;
    def __init__(self, text):
        self.text = text

    def __repr__(self):
        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)

    def __iter__(self):
        for match in RE_WORD.finditer(self.text):
            yield match.group()</code></pre></div><h3 id="2-2-测试用例和输出示例和上面一样"><a href="#2-2-测试用例和输出示例和上面一样" class="headerlink" title="2.2 测试用例和输出示例和上面一样"></a>2.2 测试用例和输出示例和上面一样</h3><h2 id="3-使用生成器表达式实现Sentence类"><a href="#3-使用生成器表达式实现Sentence类" class="headerlink" title="3 - 使用生成器表达式实现Sentence类"></a>3 - 使用生成器表达式实现Sentence类</h2><h3 id="3-1-具体的实现代码"><a href="#3-1-具体的实现代码" class="headerlink" title="3.1 具体的实现代码"></a>3.1 具体的实现代码</h3><div class="code-wrapper"><pre><code>class Sentence:
    def __init__(self, text):
        self.text = text

    def __repr__(self):
        return &apos;Sentence(%s)&apos; % reprlib.repr(self.text)

    def __iter__(self):
        return (match.group() for match in RE_WORD.finditer(self.text))</code></pre></div><h3 id="3-2-测试用例和输出示例和上面一样"><a href="#3-2-测试用例和输出示例和上面一样" class="headerlink" title="3.2 测试用例和输出示例和上面一样"></a>3.2 测试用例和输出示例和上面一样</h3><p>生成器表达式是语法糖：完全可以替换成生成器函数，不过有时使用生成器表达式更便利</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>函数参数的使用</title>
    <url>/2020/07/25/Python%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一，Python函数参数的使用"><a href="#一，Python函数参数的使用" class="headerlink" title="一，Python函数参数的使用"></a>一，Python函数参数的使用</h2><h2 id="1-不可变参数"><a href="#1-不可变参数" class="headerlink" title="1.不可变参数"></a>1.不可变参数</h2><h3 id="1-1-位置实参-参数顺序要一致"><a href="#1-1-位置实参-参数顺序要一致" class="headerlink" title="1.1 位置实参(参数顺序要一致)"></a>1.1 位置实参(参数顺序要一致)</h3><div class="code-wrapper"><pre><code>def describe_pet(animal_type, pet_name):
   &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;
   print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)
   print(&quot;My &quot; + animal_type + &quot;&apos;s name is &quot; + pet_name.title() + &quot;.&quot;)

describe_pet(&apos;hamster&apos;, &apos;harry&apos;)
describe_pet(&apos;dog&apos;, &apos;willie&apos;)</code></pre></div><p>在参数的顺序上，实参与位置参数要一致，不然会出现一些无法预料到错误。</p>
<h3 id="1-2-关键字参数"><a href="#1-2-关键字参数" class="headerlink" title="1.2 关键字参数"></a>1.2 关键字参数</h3><div class="code-wrapper"><pre><code>def describe_pet(animal_type, pet_name):
&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;
print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)
print(&quot;My &quot; + animal_type + &quot;&apos;s name is &quot; + pet_name.title() + &quot;.&quot;)

describe_pet(animal_type=&apos;hamster&apos;, pet_name=&apos;harry&apos;)
describe_pet(animal_type=&apos;dog&apos;, pet_name=&apos;willie&apos;)</code></pre></div><p>关键字参数顺序可以改变，在没有默认值的情况下,必须提供全部的参数。</p>
<h3 id="1-3-位置参数与关键字混用"><a href="#1-3-位置参数与关键字混用" class="headerlink" title="1.3 位置参数与关键字混用"></a>1.3 位置参数与关键字混用</h3><div class="code-wrapper"><pre><code>def describe_pet(pet_name, animal_type):
    &quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;
    print(&quot;\nI have a &quot; + animal_type + &quot;.&quot;)
    print(&quot;My &quot; + animal_type + &quot;&apos;s name is &quot; + pet_name.title() + &quot;.&quot;)

describe_pet(&apos;wille&apos;,animal_type=&apos;dog&apos;)</code></pre></div><p>关键字参数必须在位置参数之后</p>
<h2 id="2-可变参数"><a href="#2-可变参数" class="headerlink" title="2.可变参数"></a>2.可变参数</h2><h3 id="1-1使用任意数量的位置实参"><a href="#1-1使用任意数量的位置实参" class="headerlink" title="1. 1使用任意数量的位置实参"></a>1. 1使用任意数量的位置实参</h3><div class="code-wrapper"><pre><code>def make_pizza(size, *toppings):
    &quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;
    print(&quot;\nMaking a &quot; + str(size) + &quot;-inch pizza with the following       toppings:&quot;)
    for topping in toppings:
        print(&quot;-&quot; + topping)

make_pizza(16, &apos;pepperoni&apos;)
make_pizza(12, &apos;mushrooms&apos;, &apos;green peppers&apos;, &apos;extra cheese&apos;)</code></pre></div><p> ‘*’ 是分隔符，可变参数实际上是将其组装成元组</p>
<h3 id="1-2使用任意数量的关键字实参"><a href="#1-2使用任意数量的关键字实参" class="headerlink" title="1. 2使用任意数量的关键字实参"></a>1. 2使用任意数量的关键字实参</h3><div class="code-wrapper"><pre><code>def build_profile(first, last, **user_info):
    &quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切&quot;&quot;&quot;
    profile = &#123;&#125;
    profile[&apos;first_name&apos;] = first
    profile[&apos;last_name&apos;] = last
    for  key, value in user_info.items():
        profile[key] = value
    return profile

user_profile = build_profile(&apos;albert&apos;, &apos;einstein&apos;,
                            location=&apos;princeton&apos;,
                            field=&apos;physics&apos;)
print(user_profile)</code></pre></div><p> 参数组合在实际书写中，需要遵循一定的顺序：<br>位置参数-&gt;默认参数-&gt;边长参数-&gt;关键字参数-&gt;命名关键字参数</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>参数</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程实现程序并发</title>
    <url>/2020/08/10/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h3 id="第一步·导入相应的线程模块"><a href="#第一步·导入相应的线程模块" class="headerlink" title="第一步·导入相应的线程模块"></a>第一步·导入相应的线程模块</h3><div class="code-wrapper"><pre><code>import threading
import time</code></pre></div><h3 id="第二步·编写两个测试函数"><a href="#第二步·编写两个测试函数" class="headerlink" title="第二步·编写两个测试函数"></a>第二步·编写两个测试函数</h3><div class="code-wrapper"><pre><code>def sing():
    for i in range(3):
        print(&apos;唱歌...&apos;)
        time.sleep(0.5)

def dance():
    for i in range(3):
        print(&apos;跳舞...&apos;)
        time.sleep(0.5)</code></pre></div><h3 id="第三步·使用进程类创建线程对象"><a href="#第三步·使用进程类创建线程对象" class="headerlink" title="第三步·使用进程类创建线程对象"></a>第三步·使用进程类创建线程对象</h3><div class="code-wrapper"><pre><code>sing_thread = threading.Thread(target=sing)
dance_thread = threading.Thread(target=dance)</code></pre></div><h3 id="第四步·使用线程对象启动执行指定任务"><a href="#第四步·使用线程对象启动执行指定任务" class="headerlink" title="第四步·使用线程对象启动执行指定任务"></a>第四步·使用线程对象启动执行指定任务</h3><div class="code-wrapper"><pre><code>sing_thread.start()
dance_thread.start()</code></pre></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多进程实现程序并发</title>
    <url>/2020/08/08/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h3 id="第一步·导入相应的进程模块"><a href="#第一步·导入相应的进程模块" class="headerlink" title="第一步·导入相应的进程模块"></a>第一步·导入相应的进程模块</h3><div class="code-wrapper"><pre><code>import multiprocessing
import time</code></pre></div><h3 id="第二步·编写两个测试函数"><a href="#第二步·编写两个测试函数" class="headerlink" title="第二步·编写两个测试函数"></a>第二步·编写两个测试函数</h3><div class="code-wrapper"><pre><code>def sing():
    for i in range(3):
        print(&apos;唱歌...&apos;)
        time.sleep(0.5)

def dance():
    for i in range(3):
        print(&apos;跳舞...&apos;)
        time.sleep(0.5)</code></pre></div><h3 id="第三步·使用进程类创建进程对象"><a href="#第三步·使用进程类创建进程对象" class="headerlink" title="第三步·使用进程类创建进程对象"></a>第三步·使用进程类创建进程对象</h3><div class="code-wrapper"><pre><code>sing_process = multiprocessing.Process(target=sing)
dance_process = multiprocessing.Process(target=dance)</code></pre></div><h3 id="第四步·使用进程对象启动执行指定任务"><a href="#第四步·使用进程对象启动执行指定任务" class="headerlink" title="第四步·使用进程对象启动执行指定任务"></a>第四步·使用进程对象启动执行指定任务</h3><div class="code-wrapper"><pre><code>sing_process.start()
dance_process.start()</code></pre></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现实时动态曲线</title>
    <url>/2021/04/09/Python%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%8A%A8%E6%80%81%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="1-效果展示"><a href="#1-效果展示" class="headerlink" title="1, 效果展示"></a>1, 效果展示</h2><p><img src="/2021/04/09/Python%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E5%8A%A8%E6%80%81%E6%9B%B2%E7%BA%BF/image-20210409214308795.png" alt="image-20210409214308795"></p>
<h2 id="2-主要使用了三个包"><a href="#2-主要使用了三个包" class="headerlink" title="2, 主要使用了三个包"></a>2, 主要使用了三个包</h2><div class="code-wrapper"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> pyqtgraph <span class="hljs-keyword">as</span> pg
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> array</code></pre></div>

<h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3, 注意事项"></a>3, 注意事项</h2><ul>
<li>因为 <strong>pyqtgraph</strong> 需要 PyQt5/6 的支持, 但是Pycharm 安装老是失败。所以我推荐先在 \python环境根目录\Lib\site-packages\下，手动安装PyQt5</li>
</ul>
<h2 id="4，-源码"><a href="#4，-源码" class="headerlink" title="4， 源码"></a>4， 源码</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pyqtgraph <span class="hljs-keyword">as</span> pg
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> array

app = pg.mkQApp()  <span class="hljs-comment"># 创建应用程序实例app</span>

data = array.array(<span class="hljs-string">&#x27;d&#x27;</span>)  <span class="hljs-comment"># 可动态改变数组的大小,double型数组</span>
N = <span class="hljs-number">200</span>  <span class="hljs-comment"># 一个屏幕显示的数据点数</span>
win = pg.GraphicsWindow()  <span class="hljs-comment"># 创建一个图形显示窗口win，设置窗口属性，如窗口标题、窗口大小</span>
<span class="hljs-comment"># win.setwindowTitle(u&#x27;pyqtgraph逐点画波形图&#x27;)</span>
win.resize(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>)

p = win.addPlot()  <span class="hljs-comment"># 在win上添加一个画图对象p，设置各种属性，如网格，X、Y轴范围、X、Y轴label及图形标题</span>
p.showGrid(x=<span class="hljs-literal">True</span>, y=<span class="hljs-literal">True</span>)
p.setRange(xRange=[<span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>], yRange=[-<span class="hljs-number">1.2</span>, <span class="hljs-number">1.2</span>], padding=<span class="hljs-number">0</span>)
p.setLabels(left=<span class="hljs-string">&#x27;y / V&#x27;</span>, bottom=<span class="hljs-string">&#x27;x / point&#x27;</span>, title=<span class="hljs-string">&#x27;y = sin(x)&#x27;</span>)

curve = p.plot(pen=<span class="hljs-string">&#x27;y&#x27;</span>)  <span class="hljs-comment"># 在p上创建1条黄色曲线curve，idx为产生正弦波形数据的变量</span>
idx = <span class="hljs-number">0</span>


<span class="hljs-comment"># 定时器超时函数plotData，内部不断产生一个正弦数据点tmp，</span>
<span class="hljs-comment"># 当数据点数小于N时，data数组使用append动态添加tmp，</span>
<span class="hljs-comment"># 否则，将tmp设为data的最后一个元素，前N-1个元素为上次数组中的最后N-1个数。</span>
<span class="hljs-comment"># 使用setData函数更新curve的数据并刷新绘图</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plotData</span>():</span>
    <span class="hljs-keyword">global</span> idx
    tmp = np.cos(np.pi / <span class="hljs-number">50</span> * idx)
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) &lt; N:
        data.append(tmp)
    <span class="hljs-keyword">else</span>:
        data[:-<span class="hljs-number">1</span>] = data[<span class="hljs-number">1</span>:]
        data[-<span class="hljs-number">1</span>] = tmp
    curve.setData(data)
    idx += <span class="hljs-number">1</span>


<span class="hljs-comment"># 定义一个定时器timer，并连接超时函数plotData，每隔30ms刷新一次波形</span>
timer = pg.QtCore.QTimer()
timer.timeout.connect(plotData)
timer.start(<span class="hljs-number">30</span>)

<span class="hljs-comment"># 使用app.exec_()函数运行实例，进入消息循环</span>
app.exec_()</code></pre></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>visualization</tag>
      </tags>
  </entry>
  <entry>
    <title>Python操控Mysql数据库</title>
    <url>/2020/07/22/Python%E6%93%8D%E6%8E%A7Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="1-首先导入所需要的包"><a href="#1-首先导入所需要的包" class="headerlink" title="1. 首先导入所需要的包"></a>1. 首先导入所需要的包</h2><div class="code-wrapper"><pre><code>import pymysql</code></pre></div><h2 id="2-链接mysql数据库服务"><a href="#2-链接mysql数据库服务" class="headerlink" title="2. 链接mysql数据库服务"></a>2. 链接mysql数据库服务</h2><div class="code-wrapper"><pre><code>connc = pymysql.Connect(
# 默认只写用户名和密码以及数据库名称就足够了
user=&apos;root&apos;,
password=&quot;password&quot;,
database=&apos;mydatabase&apos;,
)</code></pre></div><h2 id="3-创建游标对象"><a href="#3-创建游标对象" class="headerlink" title="3. 创建游标对象"></a>3. 创建游标对象</h2><div class="code-wrapper"><pre><code>cur = connc.cursor()</code></pre></div><h2 id="4-编写SQL语句"><a href="#4-编写SQL语句" class="headerlink" title="4. 编写SQL语句"></a>4. 编写SQL语句</h2><div class="code-wrapper"><pre><code>sql = &apos;select * from students&apos;</code></pre></div><h2 id="5-使用游标对象去调用SQL"><a href="#5-使用游标对象去调用SQL" class="headerlink" title="5. 使用游标对象去调用SQL"></a>5. 使用游标对象去调用SQL</h2><div class="code-wrapper"><pre><code>cur.execute(sql)</code></pre></div><h2 id="6-获取查询结果并打印"><a href="#6-获取查询结果并打印" class="headerlink" title="6. 获取查询结果并打印"></a>6. 获取查询结果并打印</h2><div class="code-wrapper"><pre><code>result = cur.fetchall()
print(result)</code></pre></div><h2 id="7-关闭游标和链接对象"><a href="#7-关闭游标和链接对象" class="headerlink" title="7. 关闭游标和链接对象"></a>7. 关闭游标和链接对象</h2><div class="code-wrapper"><pre><code>cur.close()
connc.close()</code></pre></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫的简单使用</title>
    <url>/2020/08/26/Python%E7%88%AC%E8%99%AB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-导入所需要的库"><a href="#1-导入所需要的库" class="headerlink" title="1 - 导入所需要的库"></a>1 - 导入所需要的库</h2><div class="code-wrapper"><pre><code># 时间库 
import time

# 获取网页请求的库
import requests
# 解析网页数据的库
from lxml import html
# 抵御反爬虫的用户申请头的库
from fake_useragent import UserAgent</code></pre></div><h2 id="2-两个主要的爬取函数"><a href="#2-两个主要的爬取函数" class="headerlink" title="2 - 两个主要的爬取函数"></a>2 - 两个主要的爬取函数</h2><h2 id="2-1-获取请求页的text对象"><a href="#2-1-获取请求页的text对象" class="headerlink" title="2.1 获取请求页的text对象"></a>2.1 获取请求页的text对象</h2><div class="code-wrapper"><pre><code># 参数为需要请求网页的url
# 本例中url = https://movie.douban.com/top250
def get_html(url):
user_agent = UserAgent()
headers = &#123;&apos;user-agent&apos;: user_agent.random&#125;
response = requests.get(url, headers=headers)
if response.status_code != 200:
    raise Exception(&apos;请检查传入url: &apos;, url)
print(response.status_code)
return response.text</code></pre></div><h2 id="2-2-主函数"><a href="#2-2-主函数" class="headerlink" title="2.2 主函数"></a>2.2 主函数</h2><div class="code-wrapper"><pre><code>if __name__ == &apos;__main__&apos;:

    html_str = get_html(url)
    # 构造解析树对象
    etree = html.etree
    html = etree.HTML(html_str)

    //*[@id=&quot;content&quot;]/div/div[1]/ol/li[1]/div/div[2]/div[1]/a/span[1] # 排名第一的电影
    //*[@id=&quot;content&quot;]/div/div[1]/ol/li[2]/div/div[2]/div[1]/a/span[1] # 排名第二的电影
    //*[@id=&quot;content&quot;]/div/div[1]/ol/li[1]/div/div[2]/div[2]/p[1] # 电影的信息的xpath路径
    //*[@id=&quot;content&quot;]/div/div[1]/ol/li[1]/div/div[2]/div[2]/div/span[2] # 电影的评分的xpath路径
    //*[@id=&quot;content&quot;]/div/div[1]/ol/li[1]/div/div[2]/div[2]/p[2]/span # 电影简评
    spans = html.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/ol/li[1]/div/div[2]/div[1]/a/span&apos;)

    # 以下xpath路径,均为相对路径
    li_movies = html.xpath(&apos;//*[@id=&quot;content&quot;]/div/div[1]/ol/li&apos;)
    for li in li_movies:
        spans = li.xpath(&apos;./div/div[2]/div[1]/a/span&apos;)
        movie_title = &apos;&apos;
        for span in spans:
            movie_title += span.text
        # 电影信息
        movie_info = li.xpath(&apos;./div/div[2]/div[2]/p[1]&apos;)[0].text

        # 电影评分
        movie_score = li.xpath(&apos;./div/div[2]/div[2]/div/span[2]/text()&apos;)[0]

        # 电影简评
        movie_intro = li.xpath(&apos;./div/div[2]/div[2]/p[2]/span/text()&apos;)[0]

        print(movie_title, movie_info,
        &apos;\n电影评分: &apos;, movie_score,
        &apos;\n一句话简评: &apos;, movie_intro, &apos;\n&apos;)</code></pre></div><h2 id="3-输出示例"><a href="#3-输出示例" class="headerlink" title="3 - 输出示例"></a>3 - 输出示例</h2><div class="code-wrapper"><pre><code>肖申克的救赎 / The Shawshank Redemption / 月黑高飞(港)  /  刺激1995(台) 
                        导演: 弗兰克·德拉邦特 Frank Darabont   主演: 蒂姆·罗宾斯 Tim Robbins /... 
电影评分:  9.7 
一句话简评:  希望让人自由。

霸王别姬 / 再见，我的妾  /  Farewell My Concubine 
                        导演: 陈凯歌 Kaige Chen   主演: 张国荣 Leslie Cheung / 张丰毅 Fengyi Zha... 
电影评分:  9.6 
一句话简评:  风华绝代。

阿甘正传 / Forrest Gump / 福雷斯特·冈普 
                        导演: 罗伯特·泽米吉斯 Robert Zemeckis   主演: 汤姆·汉克斯 Tom Hanks / ... 
电影评分:  9.5 
一句话简评:  一部美国近现代史。

这个杀手不太冷 / Léon / 杀手莱昂  /  终极追杀令(台) 
                        导演: 吕克·贝松 Luc Besson   主演: 让·雷诺 Jean Reno / 娜塔莉·波特曼 ... 
电影评分:  9.4 
一句话简评:  怪蜀黍和小萝莉不得不说的故事。

泰坦尼克号 / Titanic / 铁达尼号(港 / 台) 
                        导演: 詹姆斯·卡梅隆 James Cameron   主演: 莱昂纳多·迪卡普里奥 Leonardo... 
电影评分:  9.4 
一句话简评:  失去的才是永恒的。 

美丽人生 / La vita è bella / 一个快乐的传说(港)  /  Life Is Beautiful 
                        导演: 罗伯托·贝尼尼 Roberto Benigni   主演: 罗伯托·贝尼尼 Roberto Beni... 
电影评分:  9.5 
一句话简评:  最美的谎言。

千与千寻 / 千と千尋の神隠し / 神隐少女(台)  /  千与千寻的神隐 
                        导演: 宫崎骏 Hayao Miyazaki   主演: 柊瑠美 Rumi Hîragi / 入野自由 Miy... 
电影评分:  9.4 
一句话简评:  最好的宫崎骏，最好的久石让。

辛德勒的名单 / Schindler&apos;s List / 舒特拉的名单(港)  /  辛德勒名单 
                        导演: 史蒂文·斯皮尔伯格 Steven Spielberg   主演: 连姆·尼森 Liam Neeson... 
电影评分:  9.5 
一句话简评:  拯救一个人，就是拯救整个世界。

盗梦空间 / Inception / 潜行凶间(港)  /  全面启动(台) 
                        导演: 克里斯托弗·诺兰 Christopher Nolan   主演: 莱昂纳多·迪卡普里奥 Le... 
电影评分:  9.3 
一句话简评:  诺兰给了我们一场无法盗取的梦。
................................</code></pre></div>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>豆瓣 250</tag>
      </tags>
  </entry>
  <entry>
    <title>SSBuild创建遇到的问题</title>
    <url>/2021/03/28/SSMBuild%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="1，项目结构"><a href="#1，项目结构" class="headerlink" title="1，项目结构"></a>1，项目结构</h1><p><img src="/2021/03/28/SSMBuild%E9%A1%B9%E7%9B%AE/image-20210328154204364.png" alt="image-20210328154204364"></p>
<h1 id="2，资源导出问题"><a href="#2，资源导出问题" class="headerlink" title="2，资源导出问题"></a>2，资源导出问题</h1><p>开始没有配置好,导致 target/classes/ 下没有各种资源配置文件。其次在用非模板创建web项目，com/pnca/只有dao层的BookMapper文件，其他文件没有打包不知道为什么？</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div>

<p>在pom.xml中配置静态资源导出</p>
<h1 id="3，一些注解问题"><a href="#3，一些注解问题" class="headerlink" title="3，一些注解问题"></a>3，一些注解问题</h1><p>在Controller层中，对于IDEA的提示，尤其是error最好立即处理，不要试图通过修改警告级别来掩饰错误。</p>
<h1 id="4，spring-mvc-xml的beans出错"><a href="#4，spring-mvc-xml的beans出错" class="headerlink" title="4，spring-mvc.xml的beans出错"></a>4，spring-mvc.xml的beans出错</h1><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="hljs-tag">	<span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/mvc</span></span>
<span class="hljs-tag"><span class="hljs-string">https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>由于IDEA一般会自动导入</p>
<p><a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a><br><a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></p>
<p>但是我们还需要手动导入</p>
<p><a href="http://www.springframework.org/schema/mvc">http://www.springframework.org/schema/mvc</a><br><a href="https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;">https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Stm32-F103-mini 学习</title>
    <url>/2021/01/18/STM32F103MiNi/</url>
    <content><![CDATA[<h1 id="stm32-F103-mini-学习"><a href="#stm32-F103-mini-学习" class="headerlink" title="stm32 F103 mini 学习"></a>stm32 F103 mini 学习</h1><h2 id="1-Stm32初探"><a href="#1-Stm32初探" class="headerlink" title="1 Stm32初探"></a>1 Stm32初探</h2><h3 id="1-1-stm32的优点"><a href="#1-1-stm32的优点" class="headerlink" title="1.1 stm32的优点"></a>1.1 stm32的优点</h3><ol>
<li>使用ARM公司专为微控制器设计的Cortex-M内核;</li>
<li>高性能,低电压,低功耗,创新的内核以及外设</li>
<li>简单,易用</li>
</ol>
<h3 id="1-2-Cortex内核"><a href="#1-2-Cortex内核" class="headerlink" title="1.2 Cortex内核"></a>1.2 Cortex内核</h3><p>ARM架构定义了三个系列</p>
<ol>
<li>“A”: 面向操作系统和用户界面</li>
<li>“R”: 针对实时系统</li>
<li>“M”: 对微控制器</li>
</ol>
<p>STM32F1属于Cortex-M系列中的Cortex-M3内核,采用了ARMv7-M架构。Cortex-A5/A8采用了ARMv7-A架构。而传统的ARM7采用的是之前的ARMv4T架构,已经被逐渐淘汰。</p>
<h3 id="1-3-STM32和ARM7"><a href="#1-3-STM32和ARM7" class="headerlink" title="1.3 STM32和ARM7"></a>1.3 STM32和ARM7</h3><p><img src="/2021/01/18/STM32F103MiNi/Stm32%E5%92%8CARM7%E6%AF%94%E8%BE%83.png" alt="image-20210118133817724"></p>
<h2 id="2-STM32芯片解读"><a href="#2-STM32芯片解读" class="headerlink" title="2 STM32芯片解读"></a>2 STM32芯片解读</h2><h3 id="2-1-芯片内部资源"><a href="#2-1-芯片内部资源" class="headerlink" title="2.1 芯片内部资源"></a>2.1 芯片内部资源</h3><ul>
<li>内核：Cortex-M3，高达72M，支持单周期乘法和硬件除法</li>
<li>IO口：64引脚 51个IO， 大部分耐5v（模拟通道除外）</li>
<li>存储器容量：256K FLASH ，48k SRAM</li>
<li>时钟，复位和电源管理： 2.0-3.6v电源和IO电压；上电复位，掉电复位；强大的时钟系统</li>
<li>低功耗</li>
<li>AD：3个12位AD模数转换</li>
<li>DA：2个12位的DA数模转换</li>
<li>DMA：12个DMA通道</li>
<li>定时器：多达11个定时器</li>
<li>通信接口：多达13个通信接口</li>
</ul>
<h3 id="2-2-芯片内部结构"><a href="#2-2-芯片内部结构" class="headerlink" title="2.2 芯片内部结构"></a>2.2 芯片内部结构</h3>]]></content>
      <categories>
        <category>Technical</category>
        <category>Hardware</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC 学习</title>
    <url>/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="SpringMVC-学习"><a href="#SpringMVC-学习" class="headerlink" title="SpringMVC 学习"></a>SpringMVC 学习</h1><p>SSM：mybatis + Spring + SpringMVC MVC三层架构</p>
<p>Vue + SpringBoot + SpringCloud + Linux</p>
<h2 id="1-创建一个简单的web项目"><a href="#1-创建一个简单的web项目" class="headerlink" title="1, 创建一个简单的web项目"></a>1, 创建一个简单的web项目</h2><h3 id="1-方法1"><a href="#1-方法1" class="headerlink" title="1, 方法1"></a>1, 方法1</h3><blockquote>
<p>  直接利用IDEA提供的Maven Web框架模板创建一个Web项目</p>
</blockquote>
<h4 id="1-选择对应的模板创建"><a href="#1-选择对应的模板创建" class="headerlink" title="1, 选择对应的模板创建"></a>1, 选择对应的模板创建</h4><p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403163506030-1617438930946-1617443221206.png" alt="image-20210403163506030"></p>
<h4 id="2-设置项目名称和域名"><a href="#2-设置项目名称和域名" class="headerlink" title="2, 设置项目名称和域名"></a>2, 设置项目名称和域名</h4><p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403163937279-1617443223726.png" alt="image-20210403163937279"></p>
<h4 id="3-最后确认"><a href="#3-最后确认" class="headerlink" title="3, 最后确认"></a>3, 最后确认</h4><p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403164445502-1617443226225.png" alt="image-20210403164445502"></p>
<h4 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4, 注意点"></a>4, 注意点</h4><ul>
<li><p>利用此模板创建的Web项目一般版本过低为 <strong>2.3</strong> 版本,但可以通过修改web.xml 文件来升级版本为 <strong>5.0</strong> 或 <strong>4.0</strong></p>
<div class="code-wrapper"><pre><code class="hljs xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns&#x3D;&quot;https:&#x2F;&#x2F;jakarta.ee&#x2F;xml&#x2F;ns&#x2F;jakartaee&quot;
         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;
         xsi:schemaLocation&#x3D;&quot;https:&#x2F;&#x2F;jakarta.ee&#x2F;xml&#x2F;ns&#x2F;jakartaee https:&#x2F;&#x2F;jakarta.ee&#x2F;xml&#x2F;ns&#x2F;jakartaee&#x2F;web-app_5_0.xsd&quot;
         version&#x3D;&quot;5.0&quot;&gt;
&lt;&#x2F;web-app&gt;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_4_0.xsd&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre></div>
</li>
<li><p>创建成功后的Web项目的webapp目录 <strong>(即web主项目文件)</strong>  在 <strong>src/main/</strong> 目录下</p>
<p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403165107956-1617443229679.png" alt="image-20210403165107956"></p>
</li>
<li><p>我么可以删除pom.xml文件的一些内容,来保持其整洁性</p>
<p>删除后的 pom.xml 文件</p>
<p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403165306730.png" alt="image-20210403165306730"></p>
</li>
<li><p>最后利用此模板创建的项目依赖的jar包,会被IDEA自动导入 lib 目录</p>
</li>
<li><p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403170146322-1617443231832.png" alt="image-20210403170146322"></p>
</li>
</ul>
<h3 id="2-方法2"><a href="#2-方法2" class="headerlink" title="2, 方法2"></a>2, 方法2</h3><blockquote>
<p>   在Maven项目中添加Web框架支持</p>
</blockquote>
<h4 id="1-添加框架"><a href="#1-添加框架" class="headerlink" title="1, 添加框架"></a>1, 添加框架</h4><p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403170425237-1617443233880.png" alt="image-20210403170425237"></p>
<h4 id="2-完成选项"><a href="#2-完成选项" class="headerlink" title="2, 完成选项"></a>2, 完成选项</h4><p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403170646920-1617443235504.png" alt="image-20210403170646920"></p>
<h4 id="3-创建完成"><a href="#3-创建完成" class="headerlink" title="3, 创建完成"></a>3, 创建完成</h4><p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403170714857-1617443237535.png" alt="image-20210403170714857"></p>
<h4 id="4-注意点-1"><a href="#4-注意点-1" class="headerlink" title="4, 注意点"></a>4, 注意点</h4><ul>
<li><p>利用此方法创建的Web支持,必须在 <strong>WEB-INF</strong> 目录下手动创建 <strong>lib</strong> 目录,将依赖的jar包导入</p>
<p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403171013990-1617443238941.png" alt="image-20210403171013990"></p>
<p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403171121111-1617443240962.png" alt="image-20210403171121111"></p>
</li>
</ul>
<p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403171139972-1617443242607.png" alt="image-20210403171139972"></p>
<p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403171148679-1617443244675.png" alt="image-20210403171148679"></p>
<h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3, 注意"></a>3, 注意</h3><blockquote>
<p>  如果在IDEA web目录没有被小蓝点标记,说明没有此web没有被IDEA托管,解决办法是</p>
</blockquote>
<p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403171720842-1617443246812.png" alt="image-20210403171720842"></p>
<p>一般安照默认选择即可</p>
<p><img src="/2021/02/20/SpringMVC%E5%AD%A6%E4%B9%A0/image-20210403172042085-1617443248640.png" alt="image-20210403172042085"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>创建一个简单的web项目</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL和VM不兼容</title>
    <url>/2021/05/01/WSL%E5%92%8CVM/</url>
    <content><![CDATA[<h3 id="WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭"><a href="#WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭" class="headerlink" title="WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭"></a>WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭</h3><ul>
<li>CMD管理员模式启动，输入</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs arduino">bcdedit /set hypervisorlaunchtype <span class="hljs-keyword">auto</span></code></pre></div>

<ul>
<li>开启，则可以使用WSL</li>
</ul>
<ul>
<li>CMD管理员模式启动，输入</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cmake">bcdedit /<span class="hljs-keyword">set</span> hypervisorlaunchtype <span class="hljs-keyword">off</span></code></pre></div>

<ul>
<li>关闭，则可以使用VMware</li>
</ul>
<p>注意：不管是开还是关都需要重启电脑</p>
]]></content>
      <categories>
        <category>Help</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>WSL</tag>
        <tag>VM</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora快捷键</title>
    <url>/2021/04/09/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><h2 id="windows快捷键："><a href="#windows快捷键：" class="headerlink" title="windows快捷键："></a>windows快捷键：</h2><ul>
<li>无序列表：输入-之后输入空格</li>
<li>有序列表：输入数字+“.”之后输入空格</li>
<li>任务列表：-[空格]空格 文字</li>
<li>隐藏侧边栏：ctrl+shift+L</li>
<li>标题：ctrl+数字</li>
<li>表格：ctrl+t</li>
<li>生成目录：<code>[TOC]</code>按回车</li>
<li>选中一整行：ctrl+l</li>
<li>选中单词：ctrl+d</li>
<li>选中相同格式的文字：ctrl+e</li>
<li>跳转到文章开头：ctrl+home</li>
<li>跳转到文章结尾：ctrl+end</li>
<li>搜索：ctrl+f</li>
<li>替换：ctrl+h</li>
<li>引用：输入&gt;之后输入空格</li>
<li>代码块：ctrl+alt+f</li>
<li>加粗：ctrl+b</li>
<li>倾斜：ctrl+i</li>
<li>下划线：ctrl+u</li>
<li>删除线：alt+shift+5</li>
<li>插入图片：直接拖动到指定位置即可或者ctrl+shift+i</li>
<li>插入链接：ctrl + k</li>
</ul>
<h2 id="给代码块设置快捷键"><a href="#给代码块设置快捷键" class="headerlink" title="给代码块设置快捷键:"></a>给代码块设置快捷键:</h2><p>偏好设置-&gt;打开高级设置-&gt;conf.user.json文件</p>
<div class="code-wrapper"><pre><code class="hljs awk"> <span class="hljs-string">&quot;keyBinding&quot;</span>: &#123;
   <span class="hljs-regexp">//</span> <span class="hljs-keyword">for</span> example: 
   <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Always on Top&quot;</span>: <span class="hljs-string">&quot;Ctrl+Shift+P&quot;</span>
<span class="hljs-string">&quot;Always on Top&quot;</span>: <span class="hljs-string">&quot;Ctrl+Shift+P&quot;</span>,  
   <span class="hljs-string">&quot;Code Fences&quot;</span>: <span class="hljs-string">&quot;Ctrl+Shift+F&quot;</span>,  
   <span class="hljs-string">&quot;Ordered List&quot;</span>:<span class="hljs-string">&quot;Ctrl+Alt+o&quot;</span>,  
   <span class="hljs-string">&quot;Unordered List&quot;</span>: <span class="hljs-string">&quot;Ctrl+Alt+u&quot;</span>  
 &#125;,</code></pre></div>

<p>Code Fences 代码块</p>
<p>Ordered List 数字有序列表</p>
<p>Unordered List 无序列表</p>
<h2 id="表情："><a href="#表情：" class="headerlink" title="表情："></a>表情：</h2><p>输出表情需要借助 <code>：</code>符号。</p>
<p>栗子：<code>:smile</code> 显示为 😄,记住是左右两边都要冒号。</p>
<p>使用者可以通过使用<code>ESC</code>键触发表情建议补全功能，也可在功能面板启用后自动触发此功能。同时，直接从菜单栏<code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code>插入UTF8表情符号也是可以的。</p>
<p>或者使用下面的方法</p>
<p>访问网站 <a href="https://emojikeyboard.org/，找到需要的符号，鼠标左键单击，然后粘贴到需要的地方就行了！🆗">https://emojikeyboard.org/，找到需要的符号，鼠标左键单击，然后粘贴到需要的地方就行了！🆗</a></p>
]]></content>
      <categories>
        <category>Help</category>
        <category>Win</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10 搭建 PyTorch 环境</title>
    <url>/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="Win10-搭建-PyTorch-环境"><a href="#Win10-搭建-PyTorch-环境" class="headerlink" title="Win10 搭建 PyTorch 环境"></a>Win10 搭建 PyTorch 环境</h1><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0 说明"></a>0 说明</h2><p>为了进行深度学习，需要电脑上安装相应的软件，pytorch 就是其中一种。至于 pytorch 是什么的科普，建议去网上搜索。</p>
<p>而为了安装好 pytorch，需要安装众多软件，网上一搜一大把流程。但事实上随着技术的更新，很多流程都会变得过时，就像我现在这篇，因此我也特意标注了时间。</p>
<p>本流程的目的是：在 win 10 上安装 pytorch 且能调用 GPU（你需要英伟达的显卡）。</p>
<p>本流程涉及的程序有：conda，CUDA，cuDNN，pytorch。注意一定要按流程来，如果跳过了 cuDNN 安装 pytorch，是不会成功调用 GPU 的。</p>
<h2 id="1-Miniconda3"><a href="#1-Miniconda3" class="headerlink" title="1 Miniconda3"></a>1 Miniconda3</h2><p>清华源镜像已经没有维护 miniconda，所以我们使用北外源。</p>
<ul>
<li><p><strong>下载地址</strong></p>
<p><a href="https://mirrors.bfsu.edu.cn/anaconda/miniconda/">Index of /anaconda/miniconda</a></p>
<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521111325301.png" alt="image-20210521111325301"></p>
</li>
<li><p><strong>配置环境变量</strong></p>
<p>一般来说，安装程序会自动把四个 path 变量，写入系统变量的path变量中，但是会写入第一行，我们可以手动下移位置。</p>
<ul>
<li><p>打开 cmd（win+R，输入 cmd 后回车），输入 conda info，如果正确无误的话，会显示 conda 的信息。</p>
</li>
<li><p>为了 conda 的下载速度，需要添加国内的北外源，输入：</p>
<div class="code-wrapper"><pre><code class="hljs shell">conda config --set show_channel_urls yes</code></pre></div>

<p>创建配置文件 .condarc，该文件位于：C:\Users\你的用户名\ 下。</p>
<p>用文本编辑器打开它，然后复制以下内容完全覆盖已有内容：</p>
<div class="code-wrapper"><pre><code class="hljs shell">channels:
  - defaults
show_channel_urls: true
default_channels:
  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/main
  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/r
  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/msys2
custom_channels:
  conda-forge: https://mirrors.bfsu.edu.cn/anaconda/cloud
  msys2: https://mirrors.bfsu.edu.cn/anaconda/cloud
  bioconda: https://mirrors.bfsu.edu.cn/anaconda/cloud
  menpo: https://mirrors.bfsu.edu.cn/anaconda/cloud
  pytorch: https://mirrors.bfsu.edu.cn/anaconda/cloud
  simpleitk: https://mirrors.bfsu.edu.cn/anaconda/cloud</code></pre></div>
</li>
</ul>
</li>
<li><p><strong>生成并进入环境</strong></p>
<ul>
<li><p>使用命令创建环境：</p>
<div class="code-wrapper"><pre><code class="hljs shell">conda create --name py37 python=3.7</code></pre></div>
</li>
<li><p>即创建了名为 py37 的环境，你可以自定义名字，python 设定用的版本。</p>
<p>随后进入环境</p>
<div class="code-wrapper"><pre><code class="hljs shell">conda activate py37</code></pre></div>
</li>
<li><p><strong>避坑：操作需要在 cmd 里做，而不是 powershell，不知道原理，但会报错。</strong></p>
<p>如果在 powershell 里运行的话，会报错：</p>
<div class="code-wrapper"><pre><code class="hljs powershell">CommandNotFoundError: Your shell has not been properly configured to use <span class="hljs-string">&#x27;conda activate&#x27;</span>.</code></pre></div>

<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/v2-e641b91a6a360410b575d83c3030daf4_1440w.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p><strong>安装 ipython</strong></p>
<ul>
<li><p>ipython 的操作比 python 用起来舒服多了，具体介绍搜索网上</p>
<div class="code-wrapper"><pre><code class="hljs shell">conda install ipython</code></pre></div>
</li>
<li><p>之后输入 ipython 进入 python。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-CUDA"><a href="#2-CUDA" class="headerlink" title="2 CUDA"></a>2 CUDA</h2><ul>
<li><p>下载</p>
<p>链接：<a href="https://developer.nvidia.com/cuda-10.2-download-archive">https://developer.nvidia.com/cuda-downloads</a></p>
<p>依次选择：Windows -&gt; x86_64 -&gt; 10 -&gt; exe(local)，点击 Download。下载的为适合PyTorch的 <em>cuda_10.2.89_441.22_win10.exe</em></p>
<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521112724889.png" alt="image-20210521112724889"></p>
<p><strong>避坑：复制下载链接后用迅雷下载，比直接下载快数倍。</strong></p>
</li>
<li><p>安装</p>
<ul>
<li><p>注意，不要修改安装路径，因为改了没有用，安装程序还是会安装在 C盘下的 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA</p>
</li>
<li><p>必须手动添加环境变量。一般来说，CUDA_PATH，安装程序会自动写入。</p>
<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521113202277.png" alt="image-20210521113202277"></p>
<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521113121745.png" alt="image-20210521113121745"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>测试</strong></p>
<ul>
<li><p>如果安装成功，在 cmd 里输入：</p>
<div class="code-wrapper"><pre><code class="hljs shell">nvcc -V</code></pre></div>

<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521113321717.png" alt="image-20210521113321717"></p>
</li>
</ul>
</li>
</ul>
<h2 id="3-cuDNN"><a href="#3-cuDNN" class="headerlink" title="3 cuDNN"></a>3 cuDNN</h2><ul>
<li><p><strong>下载</strong></p>
<p><strong>避坑：建议在翻墙的情况下操作，注册时的验证码是谷歌的。</strong></p>
<p>你需要注册账号后才能继续。现在可以<strong>微信登录</strong>，方便了不少。</p>
<p>链接：<a href="/compute/machine-learning/cudnn/secure/8.0.2.39/10.2_20200724/cudnn-10.2-windows10-x64-v8.0.2.39.zip">https://developer.nvidia.com</a></p>
</li>
<li><p><strong>安装</strong></p>
<p>说是安装，其实是复制文件。</p>
<p>下载后是一个压缩文件夹，解压文件夹，将里面的 3 个文件夹：bin，include，lib 里面的内容分别放入 CUDA 安装位置的对应文件夹。</p>
<p>CUDA 安装的位置在：</p>
<p>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0</p>
<p>不会出现覆盖的警告，因为是新增的文件。</p>
</li>
</ul>
<h2 id="4-PyTorch"><a href="#4-PyTorch" class="headerlink" title="4 PyTorch"></a>4 PyTorch</h2><ul>
<li><p><strong>1. 下载与安装</strong></p>
<p><strong>避坑：务必在完成以上步骤后才进行。</strong></p>
<p>网址：<a href="https://link.zhihu.com/?target=https%3A//pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a>，根据实际情况选择。</p>
<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114119171.png" alt="image-20210521114119171"></p>
<p>得到下载安装的命令：</p>
<div class="code-wrapper"><pre><code class="hljs shell">conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch</code></pre></div>

<p>使用 cmd 进入了我们之前设置的环境 py37 后，输入以上命令，开始安装 pytorch，如下图：</p>
<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/v2-58b3d7c11020aca95ab177253cf5d1b0_1440w.jpg" alt="img"></p>
<p><strong>避坑：很多教程里说，去掉 -c pytorch 后，可以加速下载。可以加速没错，但下载的东西却不是我们要的 gpu 版本，而是 cpu 版本，这也是很多人照着教程做，最终都无法使用 gpu 的，却百思不得其解。</strong></p>
</li>
<li><p><strong>2. 测试</strong></p>
<ul>
<li><p>等待安装完成后，输入 ipython 进入 python，输入：</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch
torch.cuda.is_available()</code></pre></div>

<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/v2-6acee085f9449a931afaee3cdd36336a_1440w.jpg" alt="img"></p>
</li>
<li><p>显示 True 即表明启用了 pytorch 的 gpu，到此安装结束。</p>
</li>
<li><p>如果 torch.cuda.isavailable() 是 False，你可能需要看看前面哪个步骤不对。</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-Pycharm"><a href="#5-Pycharm" class="headerlink" title="5 Pycharm"></a>5 Pycharm</h2><ul>
<li><p>创建一个项目 PyTorchTest</p>
</li>
<li><p>打开设置 Ctrl + Alt + s</p>
<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114808829.png" alt="image-20210521114808829"></p>
</li>
<li><p>引入 py37 </p>
<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114859777.png" alt="image-20210521114859777"></p>
</li>
<li><p>切换环境为 py37</p>
<p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114957218.png" alt="image-20210521114957218"></p>
</li>
<li><p>重启 Pycharm</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Help</category>
        <category>Win</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>Win10</tag>
        <tag>Deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Stm32CubeMx + Clion环境搭建</title>
    <url>/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="环境和所需工具"><a href="#环境和所需工具" class="headerlink" title="环境和所需工具"></a>环境和所需工具</h1><h2 id="一，-软件环境"><a href="#一，-软件环境" class="headerlink" title="一， 软件环境"></a>一， 软件环境</h2><h3 id="1-Windows-10"><a href="#1-Windows-10" class="headerlink" title="1. Windows 10"></a>1. Windows 10</h3><h3 id="2-stm32cubemx"><a href="#2-stm32cubemx" class="headerlink" title="2. stm32cubemx"></a>2. <a href="https://www.st.com/en/development-tools/stm32cubemx.html">stm32cubemx</a></h3><h3 id="3-CLion-2020"><a href="#3-CLion-2020" class="headerlink" title="3. CLion-2020"></a>3. <a href="https://www.jetbrains.com/clion/">CLion-2020</a></h3><h3 id="4-MinGW"><a href="#4-MinGW" class="headerlink" title="4. MinGW"></a>4. <a href="http://www.mingw-w64.org/doku.php">MinGW</a></h3><h3 id="5-arm-none-eabi-gcc"><a href="#5-arm-none-eabi-gcc" class="headerlink" title="5. arm-none-eabi-gcc"></a>5. <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">arm-none-eabi-gcc</a></h3><h3 id="6-openOCD"><a href="#6-openOCD" class="headerlink" title="6. openOCD"></a>6. <a href="https://gnutoolchains.com/arm-eabi/openocd/">openOCD</a></h3><h3 id="7-stlink-v2"><a href="#7-stlink-v2" class="headerlink" title="7. stlink-v2"></a>7. <a href="https://www.st.com/en/development-tools/st-link-v2.html">stlink-v2</a></h3><h2 id="二，硬件环境"><a href="#二，硬件环境" class="headerlink" title="二，硬件环境"></a>二，硬件环境</h2><h3 id="1-单片机：正点原子STM32F103RCT6"><a href="#1-单片机：正点原子STM32F103RCT6" class="headerlink" title="1. 单片机：正点原子STM32F103RCT6"></a>1. 单片机：正点原子STM32F103RCT6</h3><h3 id="2-下载器：-StLink-V2"><a href="#2-下载器：-StLink-V2" class="headerlink" title="2. 下载器： StLink-V2"></a>2. 下载器： StLink-V2</h3><h2 id="三，工具安装"><a href="#三，工具安装" class="headerlink" title="三，工具安装"></a>三，工具安装</h2><p>工具安装部分正常安装就好了，注意安装目录的选择，尽量不要出现中文。</p>
<h3 id="1，STM32CubeMX"><a href="#1，STM32CubeMX" class="headerlink" title="1，STM32CubeMX"></a>1，STM32CubeMX</h3><p>直接去官网下在就可以，安装之前需要安装Java运行环境</p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421142019511.png" alt="image-20210421142019511"></p>
<h3 id="2，CLion"><a href="#2，CLion" class="headerlink" title="2，CLion"></a>2，CLion</h3><p>官网下载2019以后的版本</p>
<h3 id="3，MinGW"><a href="#3，MinGW" class="headerlink" title="3，MinGW"></a>3，MinGW</h3><p>Clion是基于CMake来管理项目的，所以首选需要配置好预设的MinGW和CMake环境。</p>
<p>检查是否配置好环境</p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421142250730.png" alt="image-20210421142250730"></p>
<h3 id="4，arm-none-eabi-gcc4"><a href="#4，arm-none-eabi-gcc4" class="headerlink" title="4，arm-none-eabi-gcc4"></a>4，arm-none-eabi-gcc4</h3><p>需要编译arm架构的程序，所以编译工具使用这个。</p>
<p>检查是否配置好环境</p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421142358791.png" alt="image-20210421142358791"></p>
<h3 id="5，openOCD"><a href="#5，openOCD" class="headerlink" title="5，openOCD"></a>5，openOCD</h3><p>OpenOCD是用于对STM32进行下载仿真的工具，是一个开源软件包，Windows版本下从这里下载，下载好解压到一个目录就行。</p>
<p>注意，添加环境变量</p>
<h3 id="6，CLion配置"><a href="#6，CLion配置" class="headerlink" title="6，CLion配置"></a>6，CLion配置</h3><p><strong>【重点】</strong></p>
<p>Clion是基于CMake来管理项目的，所以首选我们需要配置好预设的MinGW和CMake环境。</p>
<p>打开File-Settings-Build,Execution,Deployment选项卡，在Toolchains下面添加一个MinGW环境：</p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421192108480.png" alt="image-20210421192108480"></p>
<p>打开CMake选项栏查看工具链是否正确</p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421192217660.png" alt="image-20210421192217660"></p>
<p>至此Clion环境配置完成，可以创建STM32项目了。</p>
<h2 id="四，CLion使用"><a href="#四，CLion使用" class="headerlink" title="四，CLion使用"></a>四，CLion使用</h2><h3 id="1，STM32CubeMX创建工程模板"><a href="#1，STM32CubeMX创建工程模板" class="headerlink" title="1，STM32CubeMX创建工程模板"></a>1，STM32CubeMX创建工程模板</h3><p>这里创建一个普通的STM32Cube工程。</p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421192506773.png" alt="image-20210421192506773"></p>
<p>接下来由于 OpenOCD 报错 Error: init mode failed (unable to connect to the target)</p>
<hr>
<p>** OpenOCD init failed **</p>
<p>解决方法：这里是由于PA13和PA14被错误配置导致的。首先修复STM32CubeMX中的SYS设置，在SYS-Debug中选择Serial Wire。然后拉高Boot0和Boot1烧写一个正常固件，然后拉低他们，就能正常烧写了。</p>
<p>所以需要在MX中设置SYS</p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421192911551.png" alt="image-20210421192911551"></p>
<p>修改项目名称和Toolchain /IDE </p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193052041.png" alt="image-20210421193052041"></p>
<p>然后创建完成</p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193114717.png" alt="image-20210421193114717"></p>
<h3 id="2，通过CLion导入工程"><a href="#2，通过CLion导入工程" class="headerlink" title="2，通过CLion导入工程"></a>2，通过CLion导入工程</h3><p>通过CLion 导入此项目，直接Open打开即可</p>
<p>第一次进入，需要设置对应的单片机设置</p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193243099.png" alt="image-20210421193243099"></p>
<p>根据自己的单片机，选择最接近的型号</p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193312527.png" alt="image-20210421193312527"></p>
<p>然后 Copy to Project &amp; Use</p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193345457.png" alt="image-20210421193345457"></p>
<p>其中的内容原本为</p>
<div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment"># This is an ST NUCLEO F103RB board with a single STM32F103RBT6 chip.</span>
<span class="hljs-comment"># http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF259875</span>

source [<span class="hljs-builtin-name">find</span> interface/stlink.cfg]

transport select hla_swd

source [<span class="hljs-builtin-name">find</span> target/stm32f1x.cfg]

reset_config srst_only</code></pre></div>

<p>修改为</p>
<div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment"># This is an ST NUCLEO F103RB board with a single STM32F103RBT6 chip.</span>
<span class="hljs-comment"># http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF259875</span>

source [<span class="hljs-builtin-name">find</span> interface/stlink-v2.cfg]

transport select hla_swd

source [<span class="hljs-builtin-name">find</span> target/stm32f1x.cfg]

<span class="hljs-comment"># reset_config srst_only </span></code></pre></div>

<h3 id="3，调试"><a href="#3，调试" class="headerlink" title="3，调试"></a>3，调试</h3><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193854055.png" alt="image-20210421193854055"></p>
<p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193935417.png" alt="image-20210421193935417"></p>
<p>出现** Programming Finished ** 就表示下载到开发板上了，不用管那些警告，只要不报错就OK！</p>
]]></content>
      <categories>
        <category>Help</category>
        <category>Win</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Help</category>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>分析开源项目</title>
    <url>/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="分析开源项目-EL-ADMIN"><a href="#分析开源项目-EL-ADMIN" class="headerlink" title="分析开源项目 (EL-ADMIN)"></a>分析开源项目 (EL-ADMIN)</h1><h2 id="1-观察开源项目"><a href="#1-观察开源项目" class="headerlink" title="1 观察开源项目"></a>1 观察开源项目</h2><ul>
<li>后端</li>
</ul>
<p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210509215359473.png" alt="image-20210509215359473"></p>
<ul>
<li>前端</li>
</ul>
<p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210509215706676.png" alt="image-20210509215706676"></p>
<h2 id="2-开源项目下载"><a href="#2-开源项目下载" class="headerlink" title="2 开源项目下载"></a>2 开源项目下载</h2><p>下载完毕 ==&gt; 解压 ==&gt; 不要着急运行</p>
<p><strong>观察</strong></p>
<ul>
<li>用了那些技术 (Spring Boot 2.1.0 、 Spring Boot Jpa、 JWT、Spring Security、Redis、Vue、Element-UI)</li>
<li>是否有数据库 (MySQL)</li>
<li>你的环境是否匹配 (java， maven，npm，nodejs，redis)</li>
</ul>
<p>通过了，然后想办法运行</p>
<h2 id="3-跑起来是第一步"><a href="#3-跑起来是第一步" class="headerlink" title="3 跑起来是第一步"></a>3 跑起来是第一步</h2><ol>
<li><p>安装数据库，执行SQL（注意：有没有建库语句）</p>
</li>
<li><p>前端需要跑起来(npm 版本最好 6.x.xx)</p>
</li>
<li><p>后端项目导入</p>
</li>
<li><p>启动后端项目</p>
<p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210509231414116.png" alt="image-20210509231414116"></p>
<p>只要发现了 Swagger, 那么跑起来的第一步就是先进入 Swagger-ui 界面! 因为这里面都是接口! </p>
<p>进而查看配置文件! 默认端口….</p>
<p>前端就是安装依赖, 启动测试, 看接口是否正常</p>
</li>
</ol>
<h2 id="4-前后端分离项目的固定套路"><a href="#4-前后端分离项目的固定套路" class="headerlink" title="4 前后端分离项目的固定套路"></a>4 前后端分离项目的固定套路</h2><ol>
<li><p>从前端开始分析。打开控制台，点一个接口，分析一波调用关系！</p>
</li>
<li><p>前后端端口调用不一致 8013 - - 8000，怎么操作的</p>
<ul>
<li><p>封装了接口请求    ajax    axios    request</p>
</li>
<li><p>找到配置</p>
<p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510005019305.png" alt="image-20210510005019305"></p>
</li>
<li><p>前后端 分离项目：找到接口的调用关系</p>
<p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510005313002.png" alt="image-20210510005313002"></p>
</li>
<li><p>SpringBoot提供服务！前端调用接口获取数据！Vue负责渲染页面！</p>
</li>
<li><p>前端项目固定套路</p>
<p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510005527489.png" alt="image-20210510005527489"></p>
</li>
<li><p>通过抓取前端的请求，找到后端对应的接口</p>
<p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510014254626.png" alt="image-20210510014254626"></p>
</li>
<li><p>后端分析</p>
<p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510014559981.png" alt="image-20210510014559981"></p>
</li>
<li><p>Controller — Service — Dao/Mapper</p>
</li>
<li><p>现在从前到后就可以分析了！但是如何渲染到视图上？看前端</p>
<p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510014916833.png" alt="image-20210510014916833"></p>
</li>
<li><p>Vue 标准套路</p>
<p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510015129858.png" alt="image-20210510015129858"></p>
</li>
</ul>
</li>
</ol>
<h2 id="5-如何找到一个好的开源项目"><a href="#5-如何找到一个好的开源项目" class="headerlink" title="5 如何找到一个好的开源项目"></a>5 如何找到一个好的开源项目</h2><ol>
<li>按分类</li>
<li>看收藏</li>
<li>看具有价值</li>
</ol>
]]></content>
      <categories>
        <category>Help</category>
        <category>Win</category>
      </categories>
      <tags>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>如何高效的在Github 上寻找项目</title>
    <url>/2021/03/29/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84Github%E4%B8%8A%E5%AF%BB%E6%89%BE%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>条件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>in:name 爬虫</td>
<td>搜索名字中带有”爬虫”的</td>
</tr>
<tr>
<td>in:readme 爬虫</td>
<td>搜索readme中带有”爬虫”的</td>
</tr>
<tr>
<td>in:description 爬虫</td>
<td>搜索描述中带有”爬虫”的</td>
</tr>
<tr>
<td>stars:&gt;1000</td>
<td>搜索stars&gt;1000的</td>
</tr>
<tr>
<td>forks:&gt;1000</td>
<td>搜索forks&gt;1000的</td>
</tr>
<tr>
<td>pushed:&gt;2019-09-01</td>
<td>搜索最近更新于2019年9月1日之后的</td>
</tr>
<tr>
<td>language:Python</td>
<td>搜索Python的项目</td>
</tr>
</tbody></table>
<p><strong>以上条件可以组合使用, 每个条件以空格区分</strong></p>
]]></content>
      <categories>
        <category>Help</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2019/12/15/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>“list” 是给这个结构体起的别名，</p>
<span id="more"></span>
<p>为了使用方便。</p>
<p>其次，这个结构体中的date是数值域，next是指针域。</p>
<p>在这里我使用了递归定义。</p>
<!-- more -->]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的压缩文件压缩和解压缩</title>
    <url>/2021/04/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h2 id="常见的压缩文件压缩和解压缩"><a href="#常见的压缩文件压缩和解压缩" class="headerlink" title="常见的压缩文件压缩和解压缩"></a>常见的压缩文件压缩和解压缩</h2><table>
<thead>
<tr>
<th>文件后缀名</th>
<th>说明</th>
<th>压缩</th>
<th>解压缩</th>
</tr>
</thead>
<tbody><tr>
<td>*.zip</td>
<td>zip 程序打包压缩的文件</td>
<td>zip fileName.zip dirName</td>
<td>unzip fileName.zip</td>
</tr>
<tr>
<td>*.rar</td>
<td>rar 程序压缩的文件</td>
<td>rar a fileName.rar dirName</td>
<td>rar x fileName.rar</td>
</tr>
<tr>
<td>*.7z</td>
<td>7zip 程序压缩的文件</td>
<td>7z a fileName.7z dirName</td>
<td>7z x fileName.7z</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar 程序打包，未压缩的文件</td>
<td>tar cvf fileName.tar dirName</td>
<td>tar xvf fileName.tar</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip 程序 (GNU zip) 压缩的文件</td>
<td>gzip fileName</td>
<td>gzip -d fileName.gz</td>
</tr>
<tr>
<td>*.bz2</td>
<td>tar 打包，gzip 程序压缩的文件</td>
<td>bzip2 -z FileName</td>
<td>bzip2 -d FileName.bz2</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar打包，gzip程序压缩的文件</td>
<td>tar zcvf FileName.tar.gz dirName</td>
<td>tar zxvf FileName.tar.gz</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>tar打包，xz程序压缩的文件</td>
<td>tar cvJf fileName.tar.xz dirName</td>
<td>tar -xvJf fileName.tar.xz</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar打包，bzip2程序压缩的文件</td>
<td>tar jcvf FileName.tar.bz2 dirName</td>
<td>tar jxvf FileName.tar.bz2</td>
</tr>
<tr>
<td>*.Z</td>
<td>compress命令解压缩rar文件</td>
<td>compress fileName</td>
<td>uncompress fileName.Z</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Help</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟机 Ubuntu 安装 Tensorflow</title>
    <url>/2021/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%AE%89%E8%A3%85Tensorflow/</url>
    <content><![CDATA[<h2 id="1-软件环境"><a href="#1-软件环境" class="headerlink" title="1 软件环境"></a>1 软件环境</h2><h5 id="1-1-ubuntu-18-04-desktop-amd64-iso"><a href="#1-1-ubuntu-18-04-desktop-amd64-iso" class="headerlink" title="1.1 ubuntu-18.04-desktop-amd64.iso"></a>1.1 <a href="https://releases.ubuntu.com/18.04/ubuntu-18.04.5-desktop-amd64.iso">ubuntu-18.04-desktop-amd64.iso</a></h5><h5 id="1-2-python3-7-10"><a href="#1-2-python3-7-10" class="headerlink" title="1.2 python3.7.10"></a>1.2 <a href="https://www.python.org/ftp/python/3.7.10/Python-3.7.10.tgz">python3.7.10</a></h5><h2 id="2-安装-ubuntu"><a href="#2-安装-ubuntu" class="headerlink" title="2 安装 ubuntu"></a>2 安装 ubuntu</h2><h5 id="2-1-由于存在简易安装，所以基本上都是傻瓜式操作"><a href="#2-1-由于存在简易安装，所以基本上都是傻瓜式操作" class="headerlink" title="2.1 由于存在简易安装，所以基本上都是傻瓜式操作"></a>2.1 由于存在简易安装，所以基本上都是傻瓜式操作</h5><h5 id="2-2-配置国内源"><a href="#2-2-配置国内源" class="headerlink" title="2.2 配置国内源"></a>2.2 配置国内源</h5><ul>
<li><p>国内源</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 阿里云源</span>
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
<span class="hljs-comment">##測試版源</span>
deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
<span class="hljs-comment"># 源碼</span>
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
<span class="hljs-comment">##測試版源</span>
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse

<span class="hljs-comment"># 清华大学源</span>
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
<span class="hljs-comment">##測試版源</span>
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
<span class="hljs-comment"># 源碼</span>
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
<span class="hljs-comment">##測試版源</span>
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre></div>



</li>
</ul>
<ul>
<li><p>Ubuntu 的源存放在在 /etc/apt/ 目录下的 sources.list 文件中，修改前我们先备份，在终端中执行以下命令：</p>
<div class="code-wrapper"><pre><code class="hljs python">sudo cp /etc/apt/sources.<span class="hljs-built_in">list</span> /etc/apt/sources.<span class="hljs-built_in">list</span>.bcakup</code></pre></div>


</li>
</ul>
<ul>
<li><p>然后执行下面的命令打开 sources.list 文件，清空里面的内容，把上面阿里云与清华大学的 Ubuntu 源复制进去，保存后退出。</p>
<div class="code-wrapper"><pre><code class="hljs python">sudo gedit /etc/apt/sources.<span class="hljs-built_in">list</span></code></pre></div>
</li>
<li><p>接着在终端上执行以下命令更新软件列表，检测出可以更新的软件：</p>
<div class="code-wrapper"><pre><code class="hljs python">sudo apt-get update</code></pre></div>
</li>
<li><p>最后在终端上执行以下命令进行软件更新：</p>
<div class="code-wrapper"><pre><code class="hljs python">sudo apt-get upgrade</code></pre></div>

</li>
</ul>
<h2 id="3-安装-python"><a href="#3-安装-python" class="headerlink" title="3 安装 python"></a>3 安装 python</h2><ul>
<li><p>ubuntu 本身带有python 2.7 和 python 3.6，如果没有可以执行以下命令</p>
<div class="code-wrapper"><pre><code class="hljs python">sudo apt-get update
sudo apt-get install python2<span class="hljs-number">.7</span>
sudo apt-get update
sudo apt-get install python3<span class="hljs-number">.6</span></code></pre></div>

</li>
</ul>
<h2 id="4-切换-python-版本"><a href="#4-切换-python-版本" class="headerlink" title="4 切换 python 版本"></a>4 切换 python 版本</h2><ul>
<li><p>我们可以使用 update-alternatives 来为整个系统更改Python 版本。以 root 身份登录，首先罗列出所有可用的python 替代版本信息：</p>
<div class="code-wrapper"><pre><code class="hljs python">update-alternatives --<span class="hljs-built_in">list</span> python
update-alternatives: error: no alternatives <span class="hljs-keyword">for</span> python</code></pre></div>
</li>
<li><p>如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被update-alternatives 命令识别。想解决这个问题，我们需要更新一下替代列表，将python2.7 和 python3.6放入其中。</p>
<div class="code-wrapper"><pre><code class="hljs python">sudo update-alternatives --install /usr/<span class="hljs-built_in">bin</span>/python python /usr/<span class="hljs-built_in">bin</span>/python2<span class="hljs-number">.7</span> <span class="hljs-number">1</span>
sudo update-alternatives --install /usr/<span class="hljs-built_in">bin</span>/python python /usr/<span class="hljs-built_in">bin</span>/python3<span class="hljs-number">.6</span> <span class="hljs-number">2</span></code></pre></div>
</li>
<li><p>–install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先 级的选项就会被选中。这个例子中，我们为/usr/bin/python3.6 设置的优先级为2，所以update-alternatives 命 令会自动将它设置为默认 Python 版本。</p>
<div class="code-wrapper"><pre><code class="hljs python">python --version
Python <span class="hljs-number">3.6</span><span class="hljs-number">.9</span></code></pre></div>
</li>
<li><p>接下来，我们再次列出可用的 Python 替代版本。</p>
<div class="code-wrapper"><pre><code class="hljs python">update-alternatives --<span class="hljs-built_in">list</span> python
/usr/<span class="hljs-built_in">bin</span>/python2<span class="hljs-number">.7</span>
/usr/<span class="hljs-built_in">bin</span>/python3<span class="hljs-number">.6</span></code></pre></div>
</li>
<li><p>现在开始，我们就可以使用下方的命令随时在列出的 Python 替代版本中任意切换了。（这一步是最关键的）</p>
<div class="code-wrapper"><pre><code class="hljs python">update-alternatives --config python</code></pre></div>
</li>
<li><p>以后我们就可以用 python 代替 python3</p>
</li>
</ul>
<h2 id="5-设置pip"><a href="#5-设置pip" class="headerlink" title="5 设置pip"></a>5 设置pip</h2><h3 id="5-1-安装pip3"><a href="#5-1-安装pip3" class="headerlink" title="5.1 安装pip3"></a>5.1 安装pip3</h3><ul>
<li><p>由于 ubuntu pip有问题，在导mian包有问题，网上的教程也没用，所以使用pip3</p>
<div class="code-wrapper"><pre><code class="hljs python">sudo apt-get install python3-pip</code></pre></div>
</li>
<li><p>查看pip3版本</p>
<div class="code-wrapper"><pre><code class="hljs python">pip3 --version
pip <span class="hljs-number">9.0</span><span class="hljs-number">.1</span> <span class="hljs-keyword">from</span> /usr/lib/python3/dist-packages (python <span class="hljs-number">3.6</span>)</code></pre></div>
</li>
<li><p>升级 pip 为最新版本，不然下载包的会出问题</p>
<div class="code-wrapper"><pre><code class="hljs python">sudo pip3 install --upgrade pip</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs python">root@pncalbl-pc:/home/pncalbl<span class="hljs-comment"># pip -V</span>
pip <span class="hljs-number">21.0</span><span class="hljs-number">.1</span> <span class="hljs-keyword">from</span> /usr/local/lib/python3<span class="hljs-number">.6</span>/dist-packages/pip (python <span class="hljs-number">3.6</span>)
root@pncalbl-pc:/home/pncalbl<span class="hljs-comment"># pip3 -V</span>
pip <span class="hljs-number">21.0</span><span class="hljs-number">.1</span> <span class="hljs-keyword">from</span> /usr/local/lib/python3<span class="hljs-number">.6</span>/dist-packages/pip (python <span class="hljs-number">3.6</span>)</code></pre></div>
</li>
<li><p>如果系统只安装了一个 pip3， 可以通pip来直接使用 pip3，而不是 pip3</p>
</li>
</ul>
<h3 id="5-2-更换pip源"><a href="#5-2-更换pip源" class="headerlink" title="5.2 更换pip源"></a>5.2 更换pip源</h3><ul>
<li><p>创建目录：</p>
<div class="code-wrapper"><pre><code class="hljs python">sudo mkdir ~/.pip</code></pre></div>
</li>
<li><p>创建文件：</p>
<div class="code-wrapper"><pre><code class="hljs python">sudo gedit ~/.pip/pip.conf</code></pre></div>
</li>
<li><p>将以下内容保存到文件中，建议使用清华的源</p>
<div class="code-wrapper"><pre><code class="hljs python">[<span class="hljs-keyword">global</span>]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install] 
trusted-host=pypi.tuna.tsinghua.edu.cn</code></pre></div>

</li>
</ul>
<h3 id="5-3-pip-install"><a href="#5-3-pip-install" class="headerlink" title="5.3 pip install"></a>5.3 pip install</h3><p><code>可能出现的问题</code></p>
<ul>
<li><p>hostname</p>
<p>可能是配置了系统代理,此时我们可以暂时关闭代理</p>
</li>
</ul>
<h2 id="6-安装-Tensorflow"><a href="#6-安装-Tensorflow" class="headerlink" title="6  安装 Tensorflow"></a>6  安装 Tensorflow</h2><p>这里使用 <strong>douban</strong> 的源，是因为他下载 <strong>tensorflow</strong> 比较快，不影响我们之前配pip源</p>
<ul>
<li><p>由于之前已经配好了 <strong>pip</strong> 的源，所以只需要进行下载即可</p>
<div class="code-wrapper"><pre><code class="hljs python">pip install tensorflow-cpu==<span class="hljs-number">2.4</span><span class="hljs-number">.0</span> -i https://pypi.douban.com/simple/</code></pre></div>
</li>
<li><p>安装中可能会有1~2个包，安装失败，我们可以手动安装</p>
<div class="code-wrapper"><pre><code class="hljs python">python -m pip install launchpadlib</code></pre></div>
</li>
<li><p>继续安装 <strong>matplotlib</strong> 和 <strong>notebook</strong>（matplotlib是Python 的绘图库，jupyter notebook是基于网页的用于交互计算的应用程序）</p>
<div class="code-wrapper"><pre><code class="hljs python">pip install matplotlib notebook -i https://pypi.douban.com/simple/</code></pre></div>
</li>
<li><p>在安装 <strong>notebook</strong>中，会出现一些问题<br><strong>Running as root is not recommended. Use –allow-root to bypass.</strong></p>
<ul>
<li><p>首先查看配置文件位置，</p>
<div class="code-wrapper"><pre><code class="hljs python">jupyter notebook --generate-config --allow-root</code></pre></div>
</li>
<li><p>接下来打开配置文件：</p>
<div class="code-wrapper"><pre><code class="hljs python">gedit /root/.jupyter/jupyter_notebook_config.py</code></pre></div>
</li>
<li><p>找到”#c.NotebookApp.allow_root = False “;去掉#，并修改成True即可解决root权限运行的问题</p>
<div class="code-wrapper"><pre><code class="hljs python">c.NotebookApp.allow_root =<span class="hljs-literal">True</span>
jupyter notebook <span class="hljs-comment"># 保存，重新运行程序:</span></code></pre></div>
</li>
</ul>
</li>
<li><p>设置访问密码, 打开 <strong>ipython</strong> 输入</p>
<div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> notebook.auth <span class="hljs-keyword">import</span> passwd
passwd()

然后根据提示输入<span class="hljs-number">2</span>次密码
Enter password: ········
Verify password: ········</code></pre></div>

<ul>
<li><p>ipthon需要自己安装</p>
<div class="code-wrapper"><pre><code class="hljs python">apt-get install ipython3</code></pre></div>
</li>
</ul>
</li>
<li><p>复制密码，粘贴至配置文件（记得去掉 #）</p>
<div class="code-wrapper"><pre><code class="hljs python">c.NotebookApp.password = <span class="hljs-string">u&#x27;sha1:f5*****************************&#x27;</span></code></pre></div>
</li>
<li><p>更多设置</p>
<div class="code-wrapper"><pre><code class="hljs python">c.NotebookApp.ip = ‘localhost’
c.NotebookApp.open_browser = <span class="hljs-literal">True</span>（<span class="hljs-literal">True</span>：启动时自动打开浏览器，<span class="hljs-literal">False</span>：需手动打开浏览器访问http://localhost:<span class="hljs-number">8888</span>/tree）
c.NotebookApp.port = <span class="hljs-number">8888</span>（端口设置）</code></pre></div>



</li>
</ul>
<h2 id="7-测试-Tensorflow"><a href="#7-测试-Tensorflow" class="headerlink" title="7 测试 Tensorflow"></a>7 测试 Tensorflow</h2><p>安装成功后，执行jupyter notebook命令进入网页界面，界面如下：</p>
<p><img src="/2021/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%AE%89%E8%A3%85Tensorflow/image-20210423154621327.png" alt="image-20210423154621327"></p>
<p>新建1个界面，可以输入如下来验证，如下图：</p>
<p><img src="/2021/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%AE%89%E8%A3%85Tensorflow/image-20210423154640279.png" alt="image-20210423154640279"></p>
]]></content>
      <categories>
        <category>Help</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
        <tag>Tensorflow</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>覆写Python的内置方法</title>
    <url>/2020/08/06/%E8%A6%86%E5%86%99Python%E7%9A%84%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-我们可以通过覆写类的内置方法str，来控制print-函数的打印格式"><a href="#1-我们可以通过覆写类的内置方法str，来控制print-函数的打印格式" class="headerlink" title="1.我们可以通过覆写类的内置方法str，来控制print()函数的打印格式"></a>1.我们可以通过覆写类的内置方法<strong>str</strong>，来控制print()函数的打印格式</h2><div class="code-wrapper"><pre><code>class Point:
&quot;&quot;&quot;简单的坐标类&quot;&quot;&quot;
def __init__(self, x=0, y=0):
    self.x = x
    self.y = y
def __str__(self):
    return &quot;&lt;&#123;&#125;,&#123;&#125;&gt;&quot;.format(self.x, self.y)

    if __name__ == &apos;__main__&apos;:
point = Point(1, 1)
print(point)</code></pre></div><h3 id="1-1-没有覆写内置方法str时，print-函数的打印结果："><a href="#1-1-没有覆写内置方法str时，print-函数的打印结果：" class="headerlink" title="1.1 没有覆写内置方法str时，print()函数的打印结果："></a>1.1 没有覆写内置方法<strong>str</strong>时，print()函数的打印结果：</h3><div class="code-wrapper"><pre><code>&lt;__main__.Point object at 0x000001D7FD4EB610&gt;
仅仅只会显示类Point的实例对象point的地址</code></pre></div><h3 id="1-2-覆写内置方法str时，print-函数的打印结果："><a href="#1-2-覆写内置方法str时，print-函数的打印结果：" class="headerlink" title="1.2 覆写内置方法str时，print()函数的打印结果："></a>1.2 覆写内置方法<strong>str</strong>时，print()函数的打印结果：</h3><div class="code-wrapper"><pre><code>&lt;1,1&gt;
就会打印出我们预想的结果</code></pre></div><h2 id="2-我们可以通过覆写类内置方法init，来获得类似于C-Java的访问限制"><a href="#2-我们可以通过覆写类内置方法init，来获得类似于C-Java的访问限制" class="headerlink" title="2.我们可以通过覆写类内置方法init，来获得类似于C++/Java的访问限制"></a>2.我们可以通过覆写类内置方法<strong>init</strong>，来获得类似于C++/Java的访问限制</h2><h3 id="2-1-私有属性的设置"><a href="#2-1-私有属性的设置" class="headerlink" title="2.1 私有属性的设置"></a>2.1 私有属性的设置</h3><div class="code-wrapper"><pre><code>class Point:
&quot;&quot;&quot;简单的坐标类&quot;&quot;&quot;
def __init__(self, x=0, y=0):
    self.__x = x
    self.__y = y</code></pre></div><p> 前面加两个下划线，表示该属性只能直接在类里面直接访问，或者由类自己的方法来直接访问，类以外的不可以直接访问，但是我们同样可以向C++/Java那样书写Set和Get方法来间接的访问类的私有属性。</p>
<h3 id="2-2-受保护属性的设置"><a href="#2-2-受保护属性的设置" class="headerlink" title="2.2 受保护属性的设置"></a>2.2 受保护属性的设置</h3><div class="code-wrapper"><pre><code>class Point:
&quot;&quot;&quot;简单的坐标类&quot;&quot;&quot;
def __init__(self, x=0, y=0):
    self._x = x
    self._y = y</code></pre></div><p>受保护属性前面只用加一个下划线，其他的和私有属性基本一致</p>
<h3 id="2-3-以上设置，均属于程序员自己的自我约束-规定，Python并没有强制要求这样书写，但大多数Python程序员都遵守此约定，所以我推荐各位也按照这样来书写，方便以后的阅读。"><a href="#2-3-以上设置，均属于程序员自己的自我约束-规定，Python并没有强制要求这样书写，但大多数Python程序员都遵守此约定，所以我推荐各位也按照这样来书写，方便以后的阅读。" class="headerlink" title="2.3 以上设置，均属于程序员自己的自我约束/规定，Python并没有强制要求这样书写，但大多数Python程序员都遵守此约定，所以我推荐各位也按照这样来书写，方便以后的阅读。"></a>2.3 以上设置，均属于程序员自己的自我约束/规定，Python并没有强制要求这样书写，但大多数Python程序员都遵守此约定，所以我推荐各位也按照这样来书写，方便以后的阅读。</h3>]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>链表之创建空链表</title>
    <url>/2019/12/14/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="链表之创建空链表"><a href="#链表之创建空链表" class="headerlink" title="链表之创建空链表"></a>链表之创建空链表</h3><span id="more"></span>
<h2 id="首先：定义一个结构体"><a href="#首先：定义一个结构体" class="headerlink" title="首先：定义一个结构体."></a>首先：定义一个结构体.</h2><div class="code-wrapper"><pre><code>typedef struct node &#123;
int date;
struct node *next;
&#125;list;</code></pre></div><h4 id="说明一下："><a href="#说明一下：" class="headerlink" title="说明一下："></a>说明一下：</h4><p>“list” 是给这个结构体起的别名，为了使用方便。</p>
<p>其次，这个结构体中的date是数值域，next是指针域。</p>
<p>在这里我使用了递归定义。</p>
<hr>
<h2 id="第二：创建一个空链表"><a href="#第二：创建一个空链表" class="headerlink" title="第二：创建一个空链表."></a>第二：创建一个空链表.</h2><div class="code-wrapper"><pre><code>list *createlinklist()
&#123;
    list *phead;

    phead = (list *)malloc(sizeof(list));
    phead-&gt;next = NULL;
    return phead;
&#125;</code></pre></div><h4 id="这里简单说明一下"><a href="#这里简单说明一下" class="headerlink" title="这里简单说明一下:"></a>这里简单说明一下:</h4><p>第一：这个函数的返回值是指向list这个结构体类型的指针，</p>
<p>第二：在函数内部我建立了一个头指针(它的类型是指向list这个结构体类型的指针)，</p>
<p>使用它可以方便我们操作链表。</p>
<p>第三：我使用了“malloc”这个函数(它在&lt;stdlib.0&gt;这个库中)来申请一段存储空间，</p>
<p>其大小是一个list的结构体。</p>
<p>第四：我让头指针指向这段空间，让next指向“NULL”(在c语言中它被预处理器宏定义为实的空指针常量)</p>
<p>其值为0；</p>
<p>第五：返回头指针。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.pncalbl.com">www.pncalbl.com</a></p>
]]></content>
      <categories>
        <category>Technical</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>MybatisPlus 学习</title>
    <url>/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="MybatisPlus-学习"><a href="#MybatisPlus-学习" class="headerlink" title="MybatisPlus 学习"></a>MybatisPlus 学习</h1><h2 id="1-特性"><a href="#1-特性" class="headerlink" title="1 特性"></a>1 特性</h2><ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑。</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul>
<h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2 快速入门"></a>2 快速入门</h2><p>地址: <a href="https://baomidou.com/guide/quick-start.html#初始化工程">快速开始 | MyBatis-Plus (baomidou.com)</a></p>
<p>使用第三方插件</p>
<ul>
<li>导入依赖</li>
<li>研究依赖如何配置</li>
<li>代码如何编写</li>
<li>提高扩展技术能力</li>
</ul>
<blockquote>
<p>  步骤</p>
</blockquote>
<ol>
<li><p>创建数据库 <code>mybatis_plus</code></p>
</li>
<li><p>创建user表</p>
<div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-keyword">user</span>;

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>
(
	id <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;主键ID&#x27;</span>,
	<span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,
	age <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;年龄&#x27;</span>,
	email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;邮箱&#x27;</span>,
	<span class="hljs-keyword">PRIMARY KEY</span> (id)
);
# 插入数据
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (id, <span class="hljs-type">name</span>, age, email) <span class="hljs-keyword">VALUES</span>
(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Jone&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;test1@baomidou.com&#x27;</span>),
(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;test2@baomidou.com&#x27;</span>),
(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&#x27;test3@baomidou.com&#x27;</span>),
(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Sandy&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;test4@baomidou.com&#x27;</span>),
(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;Billie&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;test5@baomidou.com&#x27;</span>);</code></pre></div>
</li>
<li><p>编写项目, 使用springBoot初始化!</p>
</li>
<li><p>导入依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>说明: 我们使用mybatis-plus可以节省我们大量的代码, 尽量不要同时导入 mybatis 和 mybatis-plus, 可能会产生版本差异!</p>
</li>
<li><p>连接数据库</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis_plus?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=GMT</span></code></pre></div>
</li>
<li><p>pojo dao-service-controller</p>
<ul>
<li><p>pojo</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
	<span class="hljs-keyword">private</span> Long id;
	<span class="hljs-keyword">private</span> String name;
	<span class="hljs-keyword">private</span> Integer age;
	<span class="hljs-keyword">private</span> String email;
&#125;</code></pre></div>
</li>
<li><p>mapper</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 在对应的Mapper上面继承基本的类 BaseMapper</span>
<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;
	<span class="hljs-comment">//	所有的CRUD操作都已经编写完成</span>
&#125;</code></pre></div>
</li>
<li><p>启动类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 扫描我们的 mapper 文件夹</span>
<span class="hljs-meta">@MapperScan(&quot;com.pnca.mapper&quot;)</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusApplication</span> </span>&#123;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      SpringApplication.run(MybatisPlusApplication.class, args);
   &#125;

&#125;</code></pre></div>
</li>
<li><p>test</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusApplicationTests</span> </span>&#123;

   <span class="hljs-comment">//    继承了 BaseMapper, 所有的方法都来自于父类</span>
   <span class="hljs-comment">// 我们也可以编写自己的扩展方法</span>

   <span class="hljs-meta">@Resource</span>
   <span class="hljs-keyword">private</span> UserMapper userMapper;

   <span class="hljs-meta">@Test</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-comment">// 参数是一个 queryWrapper, 条件构造器</span>
      List&lt;User&gt; users = userMapper.selectList(<span class="hljs-keyword">null</span>);
      users.forEach(System.out::println);
   &#125;

&#125;</code></pre></div>

<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210508023409052-1620412451084.png" alt="image-20210508023409052"></p>
</li>
</ul>
</li>
</ol>
<h2 id="3-配置日志"><a href="#3-配置日志" class="headerlink" title="3 配置日志"></a>3 配置日志</h2><p>我们所有的sqld现在都是不可见的，我们希望知道它是怎么执行的，所以我们必须要看日志！</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># 配置日志 (系统自带的，控制台输出)</span>
<span class="hljs-attr">mybatis-plus:</span>
  <span class="hljs-attr">configuration:</span>
    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span></code></pre></div>

<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210511230039334.png" alt="image-20210511230039334"></p>
<p>配置完毕日志之后，后面的学习就需要注意这个自动生成的SQL，你们就会喜欢上MyBatis-Plus !</p>
<h2 id="4-CRUD"><a href="#4-CRUD" class="headerlink" title="4 CRUD"></a>4 CRUD</h2><h3 id="4-1-插入操作"><a href="#4-1-插入操作" class="headerlink" title="4.1 插入操作"></a>4.1 插入操作</h3><blockquote>
<p>  Insert 插入</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;
		User user = <span class="hljs-keyword">new</span> User();
		user.setName(<span class="hljs-string">&quot;Daniel&quot;</span>);
		user.setAge(<span class="hljs-number">3</span>);
		user.setEmail(<span class="hljs-string">&quot;daniel@alibaba.com&quot;</span>);

		<span class="hljs-keyword">int</span> result = userMapper.insert(user);   <span class="hljs-comment">//帮我们自动生成id</span>
		System.out.println(result); <span class="hljs-comment">// 受影响的行数</span>
		System.out.println(user);   <span class="hljs-comment">// 发现: id自动回填</span>
	&#125;</code></pre></div>

<blockquote>
<p>  数据库插入的id默认值为：全局的唯一id</p>
</blockquote>
<h3 id="4-2-主键生成策略"><a href="#4-2-主键生成策略" class="headerlink" title="4.2 主键生成策略"></a>4.2 主键生成策略</h3><blockquote>
<p>  默认 ID_WORKER 全局唯一id</p>
</blockquote>
<p>分布式系统唯一id生成：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p>
<p><strong>雪花算法：</strong></p>
<p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！</p>
<blockquote>
<p>  主键自增</p>
</blockquote>
<p>我们需要配置主键自增：</p>
<ol>
<li><p>实体类字段上 <code>@TableId(type = IdType.AUTO)</code></p>
</li>
<li><p>数据库字段上一定是自增的</p>
<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210511231840472.png" alt="image-20210511231840472"></p>
</li>
<li><p>再次测试即可</p>
<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210511232040319.png" alt="image-20210511232040319"></p>
</li>
</ol>
<blockquote>
<p>  其余的源码解释</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">IdType</span> </span>&#123;
    AUTO(<span class="hljs-number">0</span>), <span class="hljs-comment">// 数据库id自增</span>
    NONE(<span class="hljs-number">1</span>), <span class="hljs-comment">// 未设置主键</span>
    INPUT(<span class="hljs-number">2</span>), <span class="hljs-comment">// 手动输入，自己写id</span>
    ID_WORKER(<span class="hljs-number">3</span>), <span class="hljs-comment">// 默认的全局唯一id</span>
    UUID(<span class="hljs-number">4</span>), <span class="hljs-comment">// 全局唯一id uuid</span>
    ID_WORKER_STR(<span class="hljs-number">5</span>); <span class="hljs-comment">// ID_WORKER 字符串表示法</span>
&#125;</code></pre></div>

<h3 id="4-3-更新操作"><a href="#4-3-更新操作" class="headerlink" title="4.3 更新操作"></a>4.3 更新操作</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试更新</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span></span>&#123;
    User user = <span class="hljs-keyword">new</span> User();
    <span class="hljs-comment">// 通过条件自动拼接动态sql</span>
    user.setId(<span class="hljs-number">6L</span>);
    user.setName(<span class="hljs-string">&quot;关注我的微信公众号&quot;</span>);
    user.setAge(<span class="hljs-number">18</span>);
    <span class="hljs-comment">// 注意： updateById 但是参数是一个 对象</span>
    <span class="hljs-keyword">int</span> i = userMapper.updateById(user);
    System.out.println(i);
&#125;</code></pre></div>

<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210512000742878.png" alt="image-20210512000742878"></p>
<p>所有的sql都是自动帮你动态配置的！</p>
<h3 id="4-4-自动填充"><a href="#4-4-自动填充" class="headerlink" title="4.4 自动填充"></a>4.4 自动填充</h3><p>创建时间、修改时间！这些个操作一般都是自动化完成的，我们不希望手动更新！</p>
<p><strong>阿里巴巴开发手册：</strong>所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需要自动化！</p>
<blockquote>
<p>  方式一：数据库级别（工作中不允许修改数据库）</p>
</blockquote>
<ol>
<li>在表中新增字段 create_time,update_time</li>
</ol>
<ol start="2">
<li><p>再次测试插入方法，我们需要先把实体类同步</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Date createTime;
<span class="hljs-keyword">private</span> Date updateTime;</code></pre></div>



</li>
</ol>
<ol start="3">
<li>再次查看更新结果即可</li>
</ol>
<blockquote>
<p>  方式二：代码级别</p>
</blockquote>
<ol>
<li><p>删除数据库中的默认值、更新操作</p>
</li>
<li><p>实体类的字段属性上需要增加注解</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//字段添加填充内容</span>
<span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span>
<span class="hljs-keyword">private</span> LocalDateTime createTime;

<span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span>
<span class="hljs-keyword">private</span> LocalDateTime updateTime;</code></pre></div>
</li>
<li><p>编写处理器来处理这个注解即可</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Log4j2</span>
<span class="hljs-meta">@Component</span>  <span class="hljs-comment">// 一定不要忘记把处理器加到IOC容器中</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MetaObjectHandler</span> </span>&#123;
	<span class="hljs-comment">// 插入时的填充策略</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;
		log.info(<span class="hljs-string">&quot;start insert fill.........&quot;</span>);
		<span class="hljs-keyword">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;createTime&quot;</span>, LocalDateTime::now, LocalDateTime.class); <span class="hljs-comment">// 起始版本 3.3.3(推荐)</span>
		<span class="hljs-keyword">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime::now, LocalDateTime.class);

	&#125;

	<span class="hljs-comment">// 更新时的填充策略</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;
		log.info(<span class="hljs-string">&quot;start update fill.........&quot;</span>);
		<span class="hljs-keyword">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime::now, LocalDateTime.class); <span class="hljs-comment">// 起始版本 3.3.3(推荐)</span>
	&#125;
&#125;</code></pre></div>

</li>
</ol>
<h3 id="4-5-乐观锁"><a href="#4-5-乐观锁" class="headerlink" title="4.5 乐观锁"></a>4.5 乐观锁</h3><p>在面试过程中，我们经常会被问到乐观锁，悲观锁。</p>
<ul>
<li>乐观锁：顾名思义，它总是认为不会出现问题，无论干什么都不去上锁！如果出现了问题，再次更新值测试！</li>
</ul>
<ul>
<li>悲观锁：顾名思义，它总是认为总是出现问题，无论干什么都上锁！再去操作！</li>
</ul>
<p>乐观锁实现方式：</p>
<ul>
<li><p>取出记录时，获取当前version</p>
</li>
<li><p>更新时，带上这个version</p>
</li>
<li><p>执行更新时， set version = newVersion where version = oldVersion</p>
</li>
<li><p>如果version不对，就更新失败</p>
<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210516214644902.png" alt="image-20210516214644902"></p>
</li>
<li><p>测试一下MyBatisPlus的插件：</p>
<ul>
<li><p>增加 version 字段</p>
<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210516214935863.png" alt="image-20210516214935863"></p>
</li>
<li><p>我们给实体类增加相应的字段</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Version</span>    <span class="hljs-comment">// 乐观锁 Version 注解</span>
<span class="hljs-keyword">private</span> Integer version;</code></pre></div>
</li>
<li><p>注册组件, 编写配置类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 扫描我们的 mapper 文件夹</span>
<span class="hljs-meta">@MapperScan(&quot;com.pnca.mapper&quot;)</span>
<span class="hljs-meta">@EnableTransactionManagement</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;

	<span class="hljs-comment">/**</span>
<span class="hljs-comment">	 * 新版</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-meta">@Bean</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title">mybatisPlusInterceptor</span><span class="hljs-params">()</span> </span>&#123;
		MybatisPlusInterceptor mybatisPlusInterceptor = <span class="hljs-keyword">new</span> MybatisPlusInterceptor();
		mybatisPlusInterceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> OptimisticLockerInnerInterceptor());
		<span class="hljs-keyword">return</span> mybatisPlusInterceptor;
	&#125;
&#125;</code></pre></div>



</li>
</ul>
</li>
</ul>
<h3 id="4-6-查询操作"><a href="#4-6-查询操作" class="headerlink" title="4.6 查询操作"></a>4.6 查询操作</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试查询</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectById</span><span class="hljs-params">()</span> </span>&#123;
    User user = userMapper.selectById(<span class="hljs-number">1L</span>);
    System.out.println(<span class="hljs-string">&quot;查询的用户为: &quot;</span> + user);
&#125;

<span class="hljs-comment">// 批量查询</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectByBatchId</span><span class="hljs-params">()</span> </span>&#123;
    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));
    users.forEach(System.out::println);
&#125;

<span class="hljs-comment">// 条件查询, 使用map</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectByMap</span><span class="hljs-params">()</span> </span>&#123;
    HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-comment">// 自定义查询</span>
    map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>);
    map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">28</span>);
    List&lt;User&gt; users = userMapper.selectByMap(map);
    users.forEach(System.out::println);
&#125;</code></pre></div>

<h3 id="4-7-分页查询"><a href="#4-7-分页查询" class="headerlink" title="4.7 分页查询"></a>4.7 分页查询</h3><p>分页网站频繁使用</p>
<ol>
<li>原始使用limit进行分页</li>
<li>pageHelper第三方插件</li>
<li>MybatisPlus内置了分页插件</li>
</ol>
<blockquote>
<p>  如何使用？</p>
</blockquote>
<ol>
<li><p>配置拦截器</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 分页插件</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title">paginationInterceptor</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PaginationInterceptor();
&#125;</code></pre></div>
</li>
<li><p>直接使用Page对象即可</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试分页查询</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPage</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-comment">// 参数一: 当前页</span>
    <span class="hljs-comment">// 参数二： 页面大小</span>
    <span class="hljs-comment">// 使用了分页插件之后，所有的分页操作变得简单了</span>
    Page&lt;User&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);
    userMapper.selectPage(page, <span class="hljs-keyword">null</span>);

    page.getRecords().forEach(System.out::println);
    System.out.println(page.getTotal());
&#125;</code></pre></div>

</li>
</ol>
<h3 id="4-8-删除操作"><a href="#4-8-删除操作" class="headerlink" title="4.8 删除操作"></a>4.8 删除操作</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试删除</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testdelete</span><span class="hljs-params">()</span></span>&#123;
    userMapper.deleteById(<span class="hljs-number">6L</span>);
&#125;

<span class="hljs-comment">// 测试批量删除</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testdeleteBatchId</span><span class="hljs-params">()</span></span>&#123;
    userMapper.deleteBatchIds(Arrays.asList(<span class="hljs-number">1287326823914405893L</span>,<span class="hljs-number">1287326823914405894L</span>));
&#125;

<span class="hljs-comment">//通过map删除</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteByMap</span><span class="hljs-params">()</span></span>&#123;
    HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;KUANG&quot;</span>);
    userMapper.deleteByMap(map);
&#125;</code></pre></div>

<p>我们在工作中会遇到一些问题：逻辑删除！</p>
<h3 id="4-9-逻辑删除"><a href="#4-9-逻辑删除" class="headerlink" title="4.9 逻辑删除"></a>4.9 逻辑删除</h3><blockquote>
<p>  物理删除：从数据库中直接移除</p>
<p>  逻辑删除：在数据库中没有被移除，而是通过一个变量让他生效！deleted=0 –&gt; deleted=1</p>
</blockquote>
<p>管理员可以查看被删除的记录！防止数据的丢失！类似于回收站！</p>
<p><strong>测试：</strong></p>
<ol>
<li><p>在数据库表中增加一个deleted字段</p>
<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210518235020299.png" alt="image-20210518235020299"></p>
</li>
<li><p>实体类中增加属性</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@TableLogic</span> <span class="hljs-comment">// 逻辑删除</span>
<span class="hljs-keyword">private</span> Integer deleted;</code></pre></div>
</li>
<li><p>配置</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 逻辑删除组件</span>
<span class="hljs-comment">// 高版本不用配置,直接注解即可</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ISqlInjector <span class="hljs-title">sqlInjector</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogicSqlInjector();
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">global-config:</span>
  <span class="hljs-attr">db-config:</span>
    <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span>
    <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span></code></pre></div>
</li>
<li><p>测试删除</p>
<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210519000137360.png" alt="image-20210519000137360"></p>
</li>
<li><p>测试查询</p>
<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210519000241200.png" alt="image-20210519000241200"></p>
</li>
</ol>
<blockquote>
<p>  以上所有的CRUD操作及其扩展操作，我们必须精通掌握！会大大提高工作效率！</p>
</blockquote>
<h2 id="5-性能分析插件"><a href="#5-性能分析插件" class="headerlink" title="5 性能分析插件"></a>5 性能分析插件</h2><p>我们在平时的开发中，会遇到一些慢sql。解决方案：测试，druid监控…</p>
<p><strong>作用：性能分析拦截器，用于输出每条SQL语句及其执行时间</strong></p>
<p>MyBatisPlus也提供性能分析插件，如果超过这个时间就停止运行！</p>
<ol>
<li><p>导入插件</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// SQL执行效率插件</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> PerformanceInterceptor <span class="hljs-title">performanceInterceptor</span><span class="hljs-params">()</span></span>&#123;
    PerformanceInterceptor performanceInterceptor = <span class="hljs-keyword">new</span> PerformanceInterceptor();
    performanceInterceptor.setMaxTime(<span class="hljs-number">100</span>); <span class="hljs-comment">//ms 设置sql执行的最大时间，如果超过了则不执行</span>
    performanceInterceptor.setFormat(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 是否格式化</span>
    <span class="hljs-keyword">return</span> performanceInterceptor;
&#125;</code></pre></div>

<p>记住，要在SpringBoot中配置环境为dev或者test环境！</p>
</li>
<li><p>测试使用</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试查询</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectById</span><span class="hljs-params">()</span></span>&#123;
    User user = userMapper.selectById(<span class="hljs-number">3</span>);
    System.out.println(user);
&#125;</code></pre></div>
</li>
<li><p><strong>注意</strong>：此插件在 3.2.0 版本被移除，推荐使用第三方扩展，执行 SQL 分析打印。</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/p6spy/p6spy --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>p6spy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>p6spy<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522160038875.png" alt="image-20210522160038875"></p>
</li>
</ol>
<h2 id="6-条件构造器"><a href="#6-条件构造器" class="headerlink" title="6 条件构造器"></a>6 条件构造器</h2><p>十分重要：wrapper</p>
<p>我们写一些复杂的sql就可以使用它来代替！</p>
<ul>
<li><p>测试1</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-comment">// 查询 name 不为空的用户, 并且邮箱不为空的用户, 年龄大于等于12</span>
		QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();
		wrapper.isNotNull(<span class="hljs-string">&quot;name&quot;</span>).isNotNull(<span class="hljs-string">&quot;email&quot;</span>).ge(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">12</span>);
		<span class="hljs-comment">// 参数是一个 queryWrapper, 条件构造器</span>
		List&lt;User&gt; users = userMapper.selectList(wrapper);
		users.forEach(System.out::println);
	&#125;</code></pre></div>

<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522162040245.png" alt="image-20210522162040245"></p>
</li>
<li><p>测试2</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testEqName</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-comment">// 查询名字为 pncalbl</span>
   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();
   wrapper.eq(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;pncalbl&quot;</span>);
   <span class="hljs-comment">// 参数是一个 queryWrapper, 条件构造器</span>
   User user = userMapper.selectOne(wrapper);
   System.out.println(user);
&#125;</code></pre></div>

<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522162009883.png" alt="image-20210522162009883"></p>
</li>
<li><p>测试3</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCount</span><span class="hljs-params">()</span> </span>&#123;
   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();
   wrapper.between(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 区间</span>
   userMapper.selectCount(wrapper);
&#125;</code></pre></div>

<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522162331965.png" alt="image-20210522162331965"></p>
</li>
<li><p>测试4</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testLike</span><span class="hljs-params">()</span> </span>&#123;
   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();
   <span class="hljs-comment">// 左和右 %e%，例如 t%</span>
   wrapper.notLike(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;pncalbl&quot;</span>)
         .likeRight(<span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>);
   List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);
   maps.forEach(System.out::println);
&#125;</code></pre></div>

<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522163022658.png" alt="image-20210522163022658"></p>
</li>
<li><p>测试5</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSelectObjects</span><span class="hljs-params">()</span> </span>&#123;
   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();
   <span class="hljs-comment">// id 在子查询中查出来</span>
   wrapper.inSql(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;select id from user where id &lt; 3&quot;</span>);

   List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);

   objects.forEach(System.out::println);
&#125;</code></pre></div>

<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522163345953.png" alt="image-20210522163345953"></p>
</li>
<li><p>测试6</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testOrder</span><span class="hljs-params">()</span> </span>&#123;
   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();
   <span class="hljs-comment">// 通过 id 进行排序</span>
   wrapper.orderByDesc(<span class="hljs-string">&quot;id&quot;</span>);

   List&lt;User&gt; users = userMapper.selectList(wrapper);
   users.forEach(System.out::println);
&#125;</code></pre></div>

<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522163715836.png" alt="image-20210522163715836"></p>
</li>
</ul>
<h2 id="7-代码生成器"><a href="#7-代码生成器" class="headerlink" title="7 代码生成器"></a>7 代码生成器</h2><p>dao、pojo、service、controller都给我自己去编写完成！</p>
<p>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p>
<blockquote>
<p>  特别说明:</p>
<p>  自定义模板有哪些可用参数？<a href="https://github.com/baomidou/generator/blob/develop/mybatis-plus-generator/src/main/java/com/baomidou/mybatisplus/generator/engine/AbstractTemplateEngine.java">Github (opens new window)</a>AbstractTemplateEngine 类中方法 getObjectMap 返回 objectMap 的所有值都可用。</p>
</blockquote>
<h3 id="演示效果图："><a href="#演示效果图：" class="headerlink" title="演示效果图："></a>演示效果图：</h3><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/generator.gif" alt="relationship"></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeGenerator</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * &lt;p&gt;</span>
<span class="hljs-comment">     * 读取控制台内容</span>
<span class="hljs-comment">     * &lt;/p&gt;</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">scanner</span><span class="hljs-params">(String tip)</span> </span>&#123;
        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);
        StringBuilder help = <span class="hljs-keyword">new</span> StringBuilder();
        help.append(<span class="hljs-string">&quot;请输入&quot;</span> + tip + <span class="hljs-string">&quot;：&quot;</span>);
        System.out.println(help.toString());
        <span class="hljs-keyword">if</span> (scanner.hasNext()) &#123;
            String ipt = scanner.next();
            <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;
                <span class="hljs-keyword">return</span> ipt;
            &#125;
        &#125;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MybatisPlusException(<span class="hljs-string">&quot;请输入正确的&quot;</span> + tip + <span class="hljs-string">&quot;！&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 代码生成器</span>
        AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();

        <span class="hljs-comment">// 全局配置</span>
        GlobalConfig gc = <span class="hljs-keyword">new</span> GlobalConfig();
        String projectPath = System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>);
        gc.setOutputDir(projectPath + <span class="hljs-string">&quot;/src/main/java&quot;</span>);
        gc.setAuthor(<span class="hljs-string">&quot;jobob&quot;</span>);
        gc.setOpen(<span class="hljs-keyword">false</span>);
        <span class="hljs-comment">// gc.setSwagger2(true); 实体属性 Swagger2 注解</span>
        mpg.setGlobalConfig(gc);

        <span class="hljs-comment">// 数据源配置</span>
        DataSourceConfig dsc = <span class="hljs-keyword">new</span> DataSourceConfig();
        dsc.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/ant?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);
        <span class="hljs-comment">// dsc.setSchemaName(&quot;public&quot;);</span>
        dsc.setDriverName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);
        dsc.setUsername(<span class="hljs-string">&quot;root&quot;</span>);
        dsc.setPassword(<span class="hljs-string">&quot;密码&quot;</span>);
        mpg.setDataSource(dsc);

        <span class="hljs-comment">// 包配置</span>
        PackageConfig pc = <span class="hljs-keyword">new</span> PackageConfig();
        pc.setModuleName(scanner(<span class="hljs-string">&quot;模块名&quot;</span>));
        pc.setParent(<span class="hljs-string">&quot;com.baomidou.ant&quot;</span>);
        mpg.setPackageInfo(pc);

        <span class="hljs-comment">// 自定义配置</span>
        InjectionConfig cfg = <span class="hljs-keyword">new</span> InjectionConfig() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-comment">// to do nothing</span>
            &#125;
        &#125;;

        <span class="hljs-comment">// 如果模板引擎是 freemarker</span>
        String templatePath = <span class="hljs-string">&quot;/templates/mapper.xml.ftl&quot;</span>;
        <span class="hljs-comment">// 如果模板引擎是 velocity</span>
        <span class="hljs-comment">// String templatePath = &quot;/templates/mapper.xml.vm&quot;;</span>

        <span class="hljs-comment">// 自定义输出配置</span>
        List&lt;FileOutConfig&gt; focList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-comment">// 自定义配置会被优先输出</span>
        focList.add(<span class="hljs-keyword">new</span> FileOutConfig(templatePath) &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">outputFile</span><span class="hljs-params">(TableInfo tableInfo)</span> </span>&#123;
                <span class="hljs-comment">// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span>
                <span class="hljs-keyword">return</span> projectPath + <span class="hljs-string">&quot;/src/main/resources/mapper/&quot;</span> + pc.getModuleName()
                        + <span class="hljs-string">&quot;/&quot;</span> + tableInfo.getEntityName() + <span class="hljs-string">&quot;Mapper&quot;</span> + StringPool.DOT_XML;
            &#125;
        &#125;);
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">        cfg.setFileCreate(new IFileCreate() &#123;</span>
<span class="hljs-comment">            @Override</span>
<span class="hljs-comment">            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) &#123;</span>
<span class="hljs-comment">                // 判断自定义文件夹是否需要创建</span>
<span class="hljs-comment">                checkDir(&quot;调用默认方法创建的目录，自定义目录用&quot;);</span>
<span class="hljs-comment">                if (fileType == FileType.MAPPER) &#123;</span>
<span class="hljs-comment">                    // 已经生成 mapper 文件判断存在，不想重新生成返回 false</span>
<span class="hljs-comment">                    return !new File(filePath).exists();</span>
<span class="hljs-comment">                &#125;</span>
<span class="hljs-comment">                // 允许生成模板文件</span>
<span class="hljs-comment">                return true;</span>
<span class="hljs-comment">            &#125;</span>
<span class="hljs-comment">        &#125;);</span>
<span class="hljs-comment">        */</span>
        cfg.setFileOutConfigList(focList);
        mpg.setCfg(cfg);

        <span class="hljs-comment">// 配置模板</span>
        TemplateConfig templateConfig = <span class="hljs-keyword">new</span> TemplateConfig();

        <span class="hljs-comment">// 配置自定义输出模板</span>
        <span class="hljs-comment">//指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别</span>
        <span class="hljs-comment">// templateConfig.setEntity(&quot;templates/entity2.java&quot;);</span>
        <span class="hljs-comment">// templateConfig.setService();</span>
        <span class="hljs-comment">// templateConfig.setController();</span>

        templateConfig.setXml(<span class="hljs-keyword">null</span>);
        mpg.setTemplate(templateConfig);

        <span class="hljs-comment">// 策略配置</span>
        StrategyConfig strategy = <span class="hljs-keyword">new</span> StrategyConfig();
        strategy.setNaming(NamingStrategy.underline_to_camel);
        strategy.setColumnNaming(NamingStrategy.underline_to_camel);
        strategy.setSuperEntityClass(<span class="hljs-string">&quot;你自己的父类实体,没有就不用设置!&quot;</span>);
        strategy.setEntityLombokModel(<span class="hljs-keyword">true</span>);
        strategy.setRestControllerStyle(<span class="hljs-keyword">true</span>);
        <span class="hljs-comment">// 公共父类</span>
        strategy.setSuperControllerClass(<span class="hljs-string">&quot;你自己的父类控制器,没有就不用设置!&quot;</span>);
        <span class="hljs-comment">// 写于父类中的公共字段</span>
        strategy.setSuperEntityColumns(<span class="hljs-string">&quot;id&quot;</span>);
        strategy.setInclude(scanner(<span class="hljs-string">&quot;表名，多个英文逗号分割&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>));
        strategy.setControllerMappingHyphenStyle(<span class="hljs-keyword">true</span>);
        strategy.setTablePrefix(pc.getModuleName() + <span class="hljs-string">&quot;_&quot;</span>);
        mpg.setStrategy(strategy);
        mpg.setTemplateEngine(<span class="hljs-keyword">new</span> FreemarkerTemplateEngine());
        mpg.execute();
    &#125;

&#125;</code></pre></div>

<h3 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h3><h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1 添加依赖"></a>1 添加依赖</h4><p>MyBatis-Plus 从 <code>3.0.3</code> 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖：</p>
<ul>
<li><p>添加 代码生成器 依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>添加 模板引擎 依赖，MyBatis-Plus 支持 Velocity（默认）、Freemarker、Beetl，用户可以选择自己熟悉的模板引擎，如果都不满足您的要求，可以采用自定义模板引擎。</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity-engine-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>注意！如果您选择了非默认引擎，需要在 AutoGenerator 中 设置模板引擎。</p>
<div class="code-wrapper"><pre><code class="hljs java">AutoGenerator generator = <span class="hljs-keyword">new</span> AutoGenerator();

<span class="hljs-comment">// set freemarker engine</span>
generator.setTemplateEngine(<span class="hljs-keyword">new</span> FreemarkerTemplateEngine());

<span class="hljs-comment">// set beetl engine</span>
generator.setTemplateEngine(<span class="hljs-keyword">new</span> BeetlTemplateEngine());

<span class="hljs-comment">// set custom engine (reference class is your custom engine class)</span>
generator.setTemplateEngine(<span class="hljs-keyword">new</span> CustomTemplateEngine());

<span class="hljs-comment">// other config</span>
...</code></pre></div>

</li>
</ul>
<h4 id="2-编写配置"><a href="#2-编写配置" class="headerlink" title="2 编写配置"></a>2 编写配置</h4><p>MyBatis-Plus 的代码生成器提供了大量的自定义参数供用户选择，能够满足绝大部分人的使用需求。</p>
<ul>
<li><p>配置 GlobalConfig</p>
<div class="code-wrapper"><pre><code class="hljs java">GlobalConfig globalConfig = <span class="hljs-keyword">new</span> GlobalConfig();
globalConfig.setOutputDir(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;/src/main/java&quot;</span>);
globalConfig.setAuthor(<span class="hljs-string">&quot;jobob&quot;</span>);
globalConfig.setOpen(<span class="hljs-keyword">false</span>);</code></pre></div>
</li>
<li><p>配置 DataSourceConfig</p>
<div class="code-wrapper"><pre><code class="hljs java">DataSourceConfig dataSourceConfig = <span class="hljs-keyword">new</span> DataSourceConfig();
dataSourceConfig.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/ant?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);
dataSourceConfig.setDriverName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);
dataSourceConfig.setUsername(<span class="hljs-string">&quot;root&quot;</span>);
dataSourceConfig.setPassword(<span class="hljs-string">&quot;password&quot;</span>);</code></pre></div>

</li>
</ul>
<h4 id="3-自定义模板引擎"><a href="#3-自定义模板引擎" class="headerlink" title="3 自定义模板引擎"></a>3 自定义模板引擎</h4><p>请继承类 com.baomidou.mybatisplus.generator.engine.AbstractTemplateEngine</p>
<ul>
<li><p>自定义代码模板</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//指定自定义模板路径, 位置：/resources/templates/entity2.java.ftl(或者是.vm)</span>
<span class="hljs-comment">//注意不要带上.ftl(或者是.vm), 会根据使用的模板引擎自动识别</span>
TemplateConfig templateConfig = <span class="hljs-keyword">new</span> TemplateConfig()
    .setEntity(<span class="hljs-string">&quot;templates/entity2.java&quot;</span>);

AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();
<span class="hljs-comment">//配置自定义模板</span>
mpg.setTemplate(templateConfig);</code></pre></div>
</li>
<li><p>自定义属性注入</p>
<div class="code-wrapper"><pre><code class="hljs java">InjectionConfig injectionConfig = <span class="hljs-keyword">new</span> InjectionConfig() &#123;
    <span class="hljs-comment">//自定义属性注入:abc</span>
    <span class="hljs-comment">//在.ftl(或者是.vm)模板中，通过$&#123;cfg.abc&#125;获取属性</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span><span class="hljs-params">()</span> </span>&#123;
        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        map.put(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-keyword">this</span>.getConfig().getGlobalConfig().getAuthor() + <span class="hljs-string">&quot;-mp&quot;</span>);
        <span class="hljs-keyword">this</span>.setMap(map);
    &#125;
&#125;;
AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();
<span class="hljs-comment">//配置自定义属性注入</span>
mpg.setCfg(injectionConfig);</code></pre></div>
</li>
<li><p>字段其他信息查询注入</p>
<p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/custom-fields.png" alt="relationship"></p>
</li>
</ul>
<div class="code-wrapper"><pre><code><pre><code class="hljs java"><span class="hljs-keyword">new</span> DataSourceConfig().setDbQuery(<span class="hljs-keyword">new</span> MySqlQuery() &#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 重写父类预留查询自定义字段&lt;br&gt;</span>
<span class="hljs-comment">     * 这里查询的 SQL 对应父类 tableFieldsSql 的查询字段，默认不能满足你的需求请重写它&lt;br&gt;</span>
<span class="hljs-comment">     * 模板中调用：  table.fields 获取所有字段信息，</span>
<span class="hljs-comment">     * 然后循环字段获取 field.customMap 从 MAP 中获取注入字段如下  NULL 或者 PRIVILEGES</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String[] fieldCustom() &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;NULL&quot;</span>, <span class="hljs-string">&quot;PRIVILEGES&quot;</span>&#125;;
    &#125;
&#125;)</code></pre></div></code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>Spring5 学习</title>
    <url>/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Spring5-学习"><a href="#Spring5-学习" class="headerlink" title="Spring5 学习"></a>Spring5 学习</h1><h2 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1 Spring"></a>1 Spring</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><ul>
<li><p>Spring: 春天—-&gt;给软件行业带来了春天!</p>
</li>
<li><p>2002,首次推出了Spring框架的雏形:interface21框架!</p>
</li>
<li><p>Spring框架即以interface21框架为基础，经过重新设计，并不断丰富其内涵。最终于2004年3月24日，发布了1.0正式版。</p>
</li>
<li><p>Rod Johnson</p>
</li>
<li><p>spring理念: 使现有的技术更加容易使用,本事是一个大杂烩,整合了现有的技术框架!</p>
</li>
<li><p>SSH: Spring2 + Spring + Hibernate</p>
</li>
<li><p>SSM: SpringMVC + Spring + Mybatis</p>
</li>
</ul>
<p>官网: <a href="https://spring.io/projects/spring-framework">https://spring.io/projects/spring-framework</a></p>
<p>官方下载地址: <a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a></p>
<p>GitHub地址: <a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul>
<li>Spring是一个开源免费的框架(容器)!</li>
<li>Spring是一个轻量级的,非入侵式的框架!</li>
<li>控制反转(IOC), 面向切面编程(AOP)!</li>
<li>支持事务处理,对框架整合的支持!</li>
</ul>
<p>总结: Spring就是一个轻量级的控制反转(IOC)和面向切面编程(AOP)的框架!</p>
<h3 id="1-3-组成"><a href="#1-3-组成" class="headerlink" title="1.3 组成"></a>1.3 组成</h3><p><img src="/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/1219227-20170930225010356-45057485.gif" alt="img"></p>
<h3 id="1-4-拓展"><a href="#1-4-拓展" class="headerlink" title="1.4 拓展"></a>1.4 拓展</h3><p><img src="/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/image-20210117211901759.png" alt="image-20210117211901759"></p>
<ul>
<li><p>spring Boot</p>
<ul>
<li>一个快速开发的脚手架。</li>
<li>基于SpringBoot可以快速的开发单个微服务。</li>
<li>约定大于配置！</li>
</ul>
</li>
<li><p>Spring Cloud</p>
<ul>
<li>Spring Cloud 是基于SpringBoot实现的。</li>
</ul>
</li>
</ul>
<p>因为现在大多数公司都在使用SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！</p>
<p><strong>弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱！”</strong></p>
<h2 id="2-IOC理论推导"><a href="#2-IOC理论推导" class="headerlink" title="2 IOC理论推导"></a>2 IOC理论推导</h2><ol>
<li>UserDao 接口</li>
<li>UserDaoImpl 实现类</li>
<li>UserService 业务接口</li>
<li>UserServiceImpl 业务实现类</li>
</ol>
<p><img src="/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/image-20210118212202438.png" alt="image-20210118212202438"></p>
<p>在我们之前的业务中,用户的需求可能会影响我们原来的代码,我们需要根据用户的需求去修改源代码!如果程序代码量十分大,修改一次的成本十分昂贵!</p>
<p>我们使用一个set接口实现</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> UserDao userDao;

<span class="hljs-comment">// 利用set进行动态实现值的注入</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.userDao = userDao;
&#125;</code></pre></div>

<ul>
<li>之前,程序是主动创建对象!控制权在程序员手上!</li>
<li>使用了set注入后,程序不再具有主动性,而是变成了被动的接受对象！</li>
</ul>
<p>这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注的在业务的实现上！这就是IOC的原型！</p>
<p><img src="/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/image-20210118212213658.png" alt="image-20210118212213658"></p>
<h4 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a><strong>IOC本质</strong></h4><p><strong>控制反转(inversion of control),</strong> 是一种设计思想,DI(dependency injection依赖注入)是IOC的一种方法.未使用IOC的程序中,我们使用面向对象编程,对象的创建和对象之间的依赖关系完全硬编码在程序中,对象的创建是由程序自己控制的.控制反转就是将对象的创建转移给了第三方.IOC就我认为是:获得依赖对象的方式反转了</p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
<h2 id="3-HelloSpring"><a href="#3-HelloSpring" class="headerlink" title="3 HelloSpring"></a>3 HelloSpring</h2><ol>
<li>书写Hello类</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;
	<span class="hljs-keyword">private</span> String str;

	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStr</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> str;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStr</span><span class="hljs-params">(String str)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.str = str;
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&#123;&quot;</span> +
				<span class="hljs-string">&quot;str=&#x27;&quot;</span> + str + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
				<span class="hljs-string">&#x27;&#125;&#x27;</span>;
	&#125;
&#125;</code></pre></div>

<p>必须，有set方法</p>
<ol start="2">
<li>编写配置文件</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--使用Spring来创建对象,在Spring中,这些都称为Bean</span>
<span class="hljs-comment">类型  变量名 = new 类型();</span>
<span class="hljs-comment">Hello hello = new Hello();</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">id = 变量名</span>
<span class="hljs-comment">class = new 的对象</span>
<span class="hljs-comment">property 相当于给对象中的属性设置一个值!</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.Hello&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;str&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>讲Hello交由Spring托管。</p>
<ol start="3">
<li>测试</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBean</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-comment">// 获取Spring的上下文对象!</span>
    ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);
    <span class="hljs-comment">// 我们的对象现在都在Spring的管理了,我们要使用,直接从里面取出来即可</span>
    Object hello = context.getBean(<span class="hljs-string">&quot;hello&quot;</span>);
    System.out.println(hello);
&#125;</code></pre></div>



<p>这个过程就叫控制反转：</p>
<p>控制：谁来控制对象的创建，传统应用程序的对象由程序本身控制创建的，使用Spring后，对象由Spring来创建的。</p>
<p>反转：程序本身不创建对象，而变成被动的接受对象。</p>
<p>依赖注入：就是利用ser方法来注入的。</p>
<p>IOC是一种编程思想，由主动的编程变成被动的接受。</p>
<p>可以通过newClassPathXmlApplicationContext去浏览一下底层源码。</p>
<p>Ok，到了现在，我们彻底不用再程序中去改动了，要实现不同的操作，只需要再xml配置文件中去修改，所谓Ioc，一句话搞定：对象由Spring来创建，管理，装配！</p>
<h2 id="4-IOC创建对象的方式"><a href="#4-IOC创建对象的方式" class="headerlink" title="4 IOC创建对象的方式"></a>4 IOC创建对象的方式</h2><ol>
<li><p>使用无参构造创建对象，默认！</p>
</li>
<li><p>假设我们要使用有参构造创建对象。</p>
<ol>
<li><p>下标赋值</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第一种,下标赋值--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pnca1&quot;</span>/&gt;</span></code></pre></div>
</li>
<li><p>类型赋值</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第二种,类型赋值,不建议使用--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pnca2&quot;</span>/&gt;</span></code></pre></div>
</li>
<li><p>引用赋值</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第三种,引用赋值--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pnca3&quot;</span>/&gt;</span></code></pre></div>

</li>
</ol>
</li>
</ol>
<p>总结：在配置文件加载的时候，容器中管理的对象就已经开始初始化了！</p>
<h2 id="5-Spring配置"><a href="#5-Spring配置" class="headerlink" title="5 Spring配置"></a>5 Spring配置</h2><h3 id="5-1-别名"><a href="#5-1-别名" class="headerlink" title="5.1 别名"></a>5.1 别名</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--别名,如果添加了别名,我们也可以使用别名获取到这个对象--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;userT23&quot;</span>/&gt;</span></code></pre></div>

<h3 id="5-2-Bean的配置"><a href="#5-2-Bean的配置" class="headerlink" title="5.2 Bean的配置"></a>5.2 Bean的配置</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">   id: bean 的唯一标识符,也就相当于对象名</span>
<span class="hljs-comment">   class: bean 对象所对应的全限定名: 包名 + 类型</span>
<span class="hljs-comment">   name: 也是别名</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.UserT&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userT2 u2,u3&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;虚拟实现&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<h3 id="5-3-import"><a href="#5-3-import" class="headerlink" title="5.3 import"></a>5.3 import</h3><p>这个import，一般用于团队开发使用，它可以将多个配置文件，导入合并为一个</p>
<p>假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bena中，我们可以利用import将所有人的beans.xml合并为一个总的！</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;beans.xml&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;beans1.xml&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;beans2.xml&quot;</span>/&gt;</span></code></pre></div>

<p>使用的时候使用总的，就可以</p>
<h2 id="6-依赖注入"><a href="#6-依赖注入" class="headerlink" title="6 依赖注入"></a>6 依赖注入</h2><h3 id="6-1-构造器注入"><a href="#6-1-构造器注入" class="headerlink" title="6.1 构造器注入"></a>6.1 构造器注入</h3><h3 id="6-2-Set方法注入"><a href="#6-2-Set方法注入" class="headerlink" title="6.2 Set方法注入"></a>6.2 Set方法注入</h3><ul>
<li>依赖注入：Set注入！<ul>
<li>依赖： bean对象的创建依赖于容器！</li>
<li>注入： bena对象中所有属性，由容器注入！</li>
</ul>
</li>
</ul>
<p>环境搭建</p>
<ul>
<li><p>复杂类型</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;
	<span class="hljs-keyword">private</span> String address;

	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> address;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.address = address;
	&#125;
&#125;</code></pre></div>
</li>
<li><p>主要类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
	<span class="hljs-keyword">private</span> String name;
	<span class="hljs-keyword">private</span> Address address;
	<span class="hljs-keyword">private</span> String[] books;
	<span class="hljs-keyword">private</span> List&lt;String&gt; hobby;
	<span class="hljs-keyword">private</span> Map&lt;String, String&gt; card;
	<span class="hljs-keyword">private</span> Set&lt;String&gt; games;
	<span class="hljs-keyword">private</span> String wife;
	<span class="hljs-keyword">private</span> Properties info;
&#125;</code></pre></div>
</li>
<li><p>beans.xml</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.Student&quot;</span>&gt;</span>
    <span class="hljs-comment">&lt;!--第一种, 普通值注入--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pnca&quot;</span>/&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

</li>
</ul>
<p>完善注入信息</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>

	<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.Address&quot;</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;西安&quot;</span>/&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.Student&quot;</span>&gt;</span>
		<span class="hljs-comment">&lt;!--第一种, 普通值注入--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pnca&quot;</span>/&gt;</span>
		
		<span class="hljs-comment">&lt;!--第二种, Bean注入, ref--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span>
		
		<span class="hljs-comment">&lt;!--第三种, 数组注入, ref--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;books&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>红楼梦<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>西游记<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>水浒传<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>三国演义<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--第四种, List注入, ref--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>听歌<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>敲代码<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>看电影<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--第五种, Map注入, ref--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;253235235235&quot;</span>/&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;银行卡&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2352355252&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--第六种, Set注入, ref--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;games&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>LOL<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>COC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BOB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--第七种, null注入, ref--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wife&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--第八种, props注入, ref--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;学号&quot;</span>&gt;</span>23453343<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;性别&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>23543<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
		
	<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
	
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>



<h3 id="6-3-拓展方式注入"><a href="#6-3-拓展方式注入" class="headerlink" title="6.3 拓展方式注入"></a>6.3 拓展方式注入</h3><p>我们可以使用c命名空间和p命名空间进行注入</p>
<p>官方解释</p>
<p><img src="/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/image-20210122221223919.png" alt="image-20210122221223919"></p>
<p>使用</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--p命名空间注入,可以直接注入属性的值: property--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.User&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;pnca&quot;</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span>

<span class="hljs-comment">&lt;!--c命名空间注入,通过构造器注入:construct-args--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.User&quot;</span> <span class="hljs-attr">c:age</span>=<span class="hljs-string">&quot;19&quot;</span> <span class="hljs-attr">c:name</span>=<span class="hljs-string">&quot;pnca2&quot;</span>/&gt;</span></code></pre></div>

<p>测试</p>
<div class="code-wrapper"><pre><code class="hljs java">ApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;userbeans.xml&quot;</span>);
User user = applicationContext.getBean(<span class="hljs-string">&quot;user&quot;</span>, User.class);
System.out.println(user);

User user2 = applicationContext.getBean(<span class="hljs-string">&quot;user2&quot;</span>, User.class);
System.out.println(user2);</code></pre></div>

<p>注意点,p和c命名空间不能直接使用,需要导入xml约束</p>
<div class="code-wrapper"><pre><code class="hljs xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</code></pre></div>

<h3 id="6-4-bean的作用域"><a href="#6-4-bean的作用域" class="headerlink" title="6.4 bean的作用域"></a>6.4 bean的作用域</h3><p><img src="/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/image-20210124204057994.png" alt="image-20210124204057994"></p>
<ol>
<li><p>单例模式(Spring的默认机制)</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.User&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;pnca&quot;</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>/&gt;</span></code></pre></div>
</li>
<li><p>原型模式: 每次从容器中get的时候,都会产生一个新对象</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.User&quot;</span> <span class="hljs-attr">c:age</span>=<span class="hljs-string">&quot;19&quot;</span> <span class="hljs-attr">c:name</span>=<span class="hljs-string">&quot;pnca2&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;</span></code></pre></div>
</li>
<li><p>其余的request,session,application,这些只能在web开发中使用</p>
</li>
</ol>
<h2 id="7-bean的自动装配"><a href="#7-bean的自动装配" class="headerlink" title="7 bean的自动装配"></a>7 bean的自动装配</h2><ul>
<li>自动装配是Spring满足bean依赖的一种方式!</li>
<li>Spring会在上下文中自动寻找,并自动给bean装配属性!</li>
</ul>
<p>在Spring中有三种装配方式</p>
<ol>
<li>在xml中显示的配置</li>
<li>在java中显示的配置</li>
<li>隐式的自动装配bean(重要)</li>
</ol>
<h3 id="7-1-测试"><a href="#7-1-测试" class="headerlink" title="7.1 测试"></a>7.1 测试</h3><p>环境搭建 :一个人有两个宠物</p>
<h3 id="7-2-ByName自动装配"><a href="#7-2-ByName自动装配" class="headerlink" title="7.2 ByName自动装配"></a>7.2 ByName自动装配</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment"> byName: 会自动在容器上下文中查找,和自己对象set方法后面的值对应的bean的id</span>
<span class="hljs-comment"> --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.Person&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pnca&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<h3 id="7-3-ByType自动装配"><a href="#7-3-ByType自动装配" class="headerlink" title="7.3 ByType自动装配"></a>7.3 ByType自动装配</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.Cat&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog11&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.Dog&quot;</span>/&gt;</span>

<span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">byName: 会自动在容器上下文中查找,和自己对象set方法后面的值对应的bean的id</span>
<span class="hljs-comment">byType: 会自动在容器上下文中查找,和自己对象set方法参数类型相同对应的bean</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.pojo.Person&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pnca&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>

<p>小结:</p>
<ul>
<li>byname的时候,需要保证所有的bean的id唯一,并且这个bean需要和自动注入的属性的set方法的值一致!</li>
<li>bytype的时候,需要保证bean的class唯一,并且这个bean需要和自动注入的set方法参数的类型一致!</li>
</ul>
<h3 id="7-4-注解自动装配"><a href="#7-4-注解自动装配" class="headerlink" title="7.4 注解自动装配"></a>7.4 注解自动装配</h3><p> 要使用注解的须知:</p>
<ol>
<li><p>导入约束:context 约束</p>
</li>
<li><p>配置注解的支持 <a href="context:annotation-config/">context:annotation-config/</a></p>
<p><img src="/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/image-20210125203726431.png" alt="image-20210125203726431"></p>
</li>
</ol>
<p><strong>@Autowired</strong></p>
<ul>
<li>直接在属性上使用即可!也可以在set方法上使用!</li>
<li>使用@Autowired 我们可以不用编写set方法,前提是自动装配的属性在IOC(Spring)容器中存在,且符合命名规则!</li>
</ul>
<p>科普:</p>
<p><strong>@Nullable</strong> 字段标记了这个注解,说明这个字段可以为null</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果显示定义了Autowired的required属性为false,</span>
<span class="hljs-comment">// 说明这个对象可以为null,否则不允许为null</span>
<span class="hljs-meta">@Autowired(required = false)</span>
<span class="hljs-keyword">private</span> Cat cat;</code></pre></div>

<p>如果@Autowired自动装配的环境比较复杂,自动装配无法通过一个注解[@Autowired]完成时,我们可以使用@Qualifier(value = “xxx”)去配和@AutowiredD使用,指定唯一的bean对象注入!</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Qualifier(value = &quot;dog&quot;)</span>
<span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> Dog dog;</code></pre></div>

<p><strong>@Resource</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name = &quot;dog&quot;)</span>
<span class="hljs-keyword">private</span> Dog dog2;</code></pre></div>

<p><strong>@Resource</strong>和<strong>@Autowired</strong>的区别:</p>
<ul>
<li>都可以用来自动装配,都可以放在属性字段上</li>
<li>@Autowired  默认通过byType的方式实现，而且必须要求这个对象存在！【常用】</li>
<li>@Resource 默认通过byName的方式实现,如果找不到名字,则通过byType的方式实现!如果两种方式都找不到则报错。【常用】</li>
<li>执行顺序不同：@Autowired  默认通过byType的方式实现，@Resource 默认通过byName的方式实现。</li>
</ul>
<h2 id="8-使用注解开发"><a href="#8-使用注解开发" class="headerlink" title="8 使用注解开发"></a>8 使用注解开发</h2><p>在Spring4之后，要使用注解开发，必须要保证aop的包导入</p>
<p><img src="/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/image-20210126222529084.png" alt="image-20210126222529084"></p>
<p>使用注解需要导入contex约束，增加注解开发的支持<br><img src="/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/image-20210126222910962.png" alt="image-20210126222910962">)<img src="/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/image-20210126223130849.png" alt="image-20210126223130849"></p>
<ol>
<li><p>bean</p>
</li>
<li><p>属性如何注入</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;

   <span class="hljs-comment">// 相当于 &lt;property name=&quot;name&quot; value=&quot;pnca&quot;/&gt;</span>
   <span class="hljs-meta">@Value(&quot;pnca&quot;)</span>
   <span class="hljs-keyword">public</span> String name;
   
   <span class="hljs-comment">// 相当于 &lt;property name=&quot;name&quot; value=&quot;pnca&quot;/&gt;</span>
   <span class="hljs-meta">@Value(&quot;pnca&quot;)</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.name = name;
   &#125;
&#125;</code></pre></div>
</li>
<li><p>衍生的解释</p>
<p>@Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层！</p>
<ul>
<li>dao [@Repository]</li>
<li>service [@Service]</li>
<li>controller [@Controller]</li>
</ul>
<p>这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean</p>
</li>
<li><p>自动装配设置</p>
<div class="code-wrapper"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> @Autowired ： 自动装配通过类型，名字。
<span class="hljs-code">    如果Autowired不能通过唯一自动装配属性，</span>
<span class="hljs-code">    则需要通过@Qualifier(value = &quot;xxx&quot;)去配和@AutowiredD使用,指定唯一的bean对象注入!</span>
<span class="hljs-code">- @Nullable  :  字段标记了这个注解,说明这个字段可以为null。</span>
<span class="hljs-code">- @Resource ： 自动装配通过名字，类型。</span>
<span class="hljs-code">- @Component : 组件，放在类上，说明这个类被Spring管理了，就是bean！</span></code></pre></div>
</li>
<li><p>作用域</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Scope(&quot;prototype&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;

   <span class="hljs-comment">// 相当于 &lt;property name=&quot;name&quot; value=&quot;pnca&quot;/&gt;</span>
<span class="hljs-comment">// @Value(&quot;pnca&quot;)</span>
   <span class="hljs-keyword">public</span> String name;

   <span class="hljs-comment">// 相当于 &lt;property name=&quot;name&quot; value=&quot;pnca&quot;/&gt;</span>
   <span class="hljs-meta">@Value(&quot;pnca&quot;)</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.name = name;
   &#125;
&#125;</code></pre></div>
</li>
<li><p>小结</p>
<p>xml与注解：</p>
<ul>
<li>xml更加万能，适用于任何场合！维护简单</li>
<li>注解 不是自己的类，使用不了，维护相对复杂！</li>
</ul>
<p>xml与注解的最佳实践：</p>
<ul>
<li><p>xml用来管理bean</p>
</li>
<li><p>注解只负责完成属性的注入</p>
</li>
<li><p>我们在使用的过程中，只需要注意一个问题，必须让注解生效，就需要开启注解的支持</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.pnca&quot;</span>/&gt;</span>
<span class="hljs-comment">&lt;!--开启注解的支持--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span></code></pre></div>

</li>
</ul>
</li>
</ol>
<h2 id="9-使用Java的方式配置Spring"><a href="#9-使用Java的方式配置Spring" class="headerlink" title="9 使用Java的方式配置Spring"></a>9 使用Java的方式配置Spring</h2><p>我们现在要完全不使用Spring的xml配置，全权交给Java！</p>
<p>配置类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这个也会被Spring容器托管,注册到容器中,</span>
<span class="hljs-comment">// 因为他本来就是一个@Component,@Configuration代表这是一个配置类,就和我们之前看的beans.xml</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(&quot;com.pnca.pojo&quot;)</span>
<span class="hljs-meta">@Import(PncaConfig2.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PncaConfig</span> </span>&#123;

	<span class="hljs-comment">// 注册一个bean,就相当于我们之前写的一个bean标签</span>
	<span class="hljs-comment">// 这个方法的名字,就相当于bean标签中的id属性</span>
	<span class="hljs-comment">// 这个方法的返回值,就相当于bean标签中的class属性</span>
	<span class="hljs-meta">@Bean</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();  <span class="hljs-comment">// 就是返回要注入到bean的对象!</span>
	&#125;
&#125;</code></pre></div>

<p>实体类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
   <span class="hljs-keyword">private</span> String name;

   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> name;
   &#125;

   <span class="hljs-meta">@Value(&quot;pnca&quot;)</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
      <span class="hljs-keyword">this</span>.name = name;
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +
            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
            <span class="hljs-string">&#x27;&#125;&#x27;</span>;
   &#125;
&#125;</code></pre></div>

<p>测试类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;

   <span class="hljs-meta">@Test</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAppConfig</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-comment">// 如果完全使用了配置类方式去做,我们就只能通过AnnotationConfig上下文来获取容器,通过配置类的class对象加载!</span>
      ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(PncaConfig.class);
      User user = (User) context.getBean(<span class="hljs-string">&quot;getUser&quot;</span>);
      System.out.println(user);
   &#125;
&#125;</code></pre></div>

<p>这种纯Java的配置方式，在SpringBoot中随处可见!</p>
<h2 id="10-代理模式"><a href="#10-代理模式" class="headerlink" title="10 代理模式"></a>10 代理模式</h2><p>为什么要学习代理模式?因为这是SpringAOP的底层! <strong>[SpringAOP 和 SpringMVC]</strong></p>
<h4 id="10-1-静态代理"><a href="#10-1-静态代理" class="headerlink" title="10.1 静态代理"></a>10.1 静态代理</h4><p>角色分析:</p>
<ul>
<li>抽象角色: 一般会使用接口或者抽象类来解决</li>
<li>真实角色: 被代理的角色</li>
<li>代理角色:代理真实角色,代理真实角色后,我们一般会做一些附属操作</li>
<li>客户: 访问代理对象的人</li>
</ul>
<p>代理模式的好处</p>
<ul>
<li>可以使真实角色的操作更加纯粹!不用去关注一些公共的业务</li>
<li>公共也就交给代理角色!实现了业务的分工!</li>
<li>公共业务发生扩展的时候,方便集中管理!</li>
</ul>
<p>缺点</p>
<ul>
<li>一个真实角色就会产生一个代理角色,代码量就是翻倍,开发效率变低</li>
</ul>
<h4 id="10-2-动态代理"><a href="#10-2-动态代理" class="headerlink" title="10.2 动态代理"></a>10.2 动态代理</h4><ul>
<li><p>动态代理和静态代理角色一样</p>
</li>
<li><p>动态代理的代理类是动态生成的,不是我们直接写好的</p>
</li>
<li><p>动态代理分为两大类: 基于接口的代理,基于类的代理</p>
<ul>
<li>基于接口——JDK动态代理</li>
<li>基于类: cglib</li>
<li>java字节码实现: javassist</li>
</ul>
<p>需要了解两个类:：Proxy:代理，invocationHandler：调用处理程序</p>
</li>
</ul>
<p>动态代理的好处</p>
<ul>
<li>一个动态代理类代理的是一个接口，一般就是对应一类业务</li>
<li>一个动态代理类可以代理多个类，只要实现了同一个接口</li>
</ul>
<h2 id="11-AOP"><a href="#11-AOP" class="headerlink" title="11 AOP"></a>11 AOP</h2><h3 id="11-1-什么是AOP"><a href="#11-1-什么是AOP" class="headerlink" title="11.1 什么是AOP"></a>11.1 什么是AOP</h3><p>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方 式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个 热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑 的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高 了开发的效率。</p>
<h3 id="11-2-AOP在Spring中的使用"><a href="#11-2-AOP在Spring中的使用" class="headerlink" title="11.2 AOP在Spring中的使用"></a>11.2 AOP在Spring中的使用</h3><p><strong>提供声明式事务,允许用户自定义切面</strong></p>
<ul>
<li><p><code>横切关注点</code>：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p>
</li>
<li><p><code>Aspect</code>（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</p>
</li>
<li><p><code>Joint point</code>（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</p>
</li>
<li><p><code>Pointcut</code>（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</p>
</li>
<li><p><code>Advice</code>（增强）：Advice 定义了在 <code>Pointcut</code> 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</p>
</li>
<li><p><code>Target</code>（目标对象）：织入 <code>Advice</code> 的目标对象.。</p>
</li>
<li><p><code>Weaving</code>（织入）：将 <code>Aspect</code> 和其他对象连接起来, 并创建 <code>Advice</code>d object 的过程</p>
</li>
<li><p><code>proxy</code>(代理)：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类</p>
</li>
</ul>
<p>SpringAOP中,通过Advice定义横切逻辑,Spring中支持5中类型的Advice:</p>
<p><img src="/2021/01/17/Spring5%E5%AD%A6%E4%B9%A0/image-20210201201037020.png" alt="image-20210201201037020"></p>
<h3 id="11-3-使用Spring实现AOP"><a href="#11-3-使用Spring实现AOP" class="headerlink" title="11.3 使用Spring实现AOP"></a>11.3 使用Spring实现AOP</h3><ol>
<li><p>导包</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>方法一: 使用原生的Spring API接口</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--方法1: 使用原生的Spring API接口--&gt;</span>
	<span class="hljs-comment">&lt;!--配置aop: 需要导入aop约束--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
		<span class="hljs-comment">&lt;!--切入点: expression 表达式, execution(要执行的位置!****)--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.pnca.service.UserServiceIml.*(..))&quot;</span>/&gt;</span>
		
		<span class="hljs-comment">&lt;!--执行环绕增加--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span>
		
	<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></div>
</li>
<li><p>方法二: 自定义类</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--方法2: 自定义类--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.diy.DiyPoint&quot;</span>/&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
		<span class="hljs-comment">&lt;!--自定义切面，ref 要引用的类--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;diy&quot;</span>&gt;</span>
			<span class="hljs-comment">&lt;!--切入点--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;point&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.pnca.service.UserServiceIml.*(..))&quot;</span>/&gt;</span>
			<span class="hljs-comment">&lt;!--通知--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;point&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;point&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></div>
</li>
<li><p>方法三：使用注解实现</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--方法3: 使用注解--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;annoyPointCut&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.diy.AnnoyPointCut&quot;</span>/&gt;</span>
<span class="hljs-comment">&lt;!--开启注解支持--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span></code></pre></div>



</li>
</ol>
<h2 id="12-整合Mybatis"><a href="#12-整合Mybatis" class="headerlink" title="12 整合Mybatis"></a>12 整合Mybatis</h2><p>步骤:</p>
<ol>
<li><p>导入相关的jar包</p>
<ul>
<li>junit</li>
<li>mybatis</li>
<li>mysql数据库</li>
<li>spring相关的</li>
<li>aop植入</li>
<li>mybatis-spring(new)</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

		
		<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

</li>
</ol>
<h3 id="12-1-回忆mybatis"><a href="#12-1-回忆mybatis" class="headerlink" title="12.1 回忆mybatis"></a>12.1 回忆mybatis</h3><ol>
<li>编写实体类</li>
<li>编写核心配置文件</li>
<li>编写接口</li>
<li>编写Mapper.xml</li>
<li>测试</li>
</ol>
<h3 id="12-2-Mybatis-Spring"><a href="#12-2-Mybatis-Spring" class="headerlink" title="12.2 Mybatis-Spring"></a>12.2 Mybatis-Spring</h3><ol>
<li><p>编写数据源配置</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--DataSource: 使用Spring的数据源替换Mybatis的位置 cp30 dbcp druid</span>
<span class="hljs-comment"> 我们这里使用Spring提供的JDBC</span>
<span class="hljs-comment"> --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;datasource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8<span class="hljs-symbol">&amp;amp;</span>serverTimezone=GMT&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>
</li>
<li><p>sqlSessionFactory</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sqlSessionFactory--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;datasource&quot;</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--绑定Mybatis配置文件--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:com/pnca/mapper/*.xml&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>
</li>
<li><p>sqlSessionTemplate</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SqlSessionTemplate: 就是我们使用的sql--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span>
    <span class="hljs-comment">&lt;!--只能使用构造器注入sqlSessionFactory,因为它没有set方法--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>
</li>
<li><p>需要给接口添加实现类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserMapper</span></span>&#123;

	<span class="hljs-comment">// 我们所有操作,在原来都使用sqlSession来执行,</span>
	<span class="hljs-comment">// 而现在使用SqlSessionTemplate</span>

	<span class="hljs-keyword">private</span> SqlSessionTemplate sqlSession;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">selectUser</span><span class="hljs-params">()</span> </span>&#123;
		UserMapper mapper = sqlSession.getMapper(UserMapper.class);
		<span class="hljs-keyword">return</span> mapper.selectUser();
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSqlSession</span><span class="hljs-params">(SqlSessionTemplate sqlSession)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.sqlSession = sqlSession;
	&#125;
&#125;</code></pre></div>
</li>
<li><p>将自己写的类注入到Spring中</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.mapper.UserMapperImpl&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSession&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div>
</li>
<li><p>测试</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;ApplicationContext.xml&quot;</span>);
    UserMapper userMapper = context.getBean(<span class="hljs-string">&quot;userMapper&quot;</span>, UserMapper.class);
    <span class="hljs-keyword">for</span> (User user : userMapper.selectUser()) &#123;
        System.out.println(user);
    &#125;
&#125;</code></pre></div>

</li>
</ol>
<h2 id="13-声明式事务"><a href="#13-声明式事务" class="headerlink" title="13 声明式事务"></a>13 声明式事务</h2><h3 id="1-回顾事务"><a href="#1-回顾事务" class="headerlink" title="1 回顾事务"></a>1 回顾事务</h3><ul>
<li>要么都成功,要么都失败</li>
<li>事务在项目开发中,十分重要,涉及数据的一致性问题</li>
<li>确保完整性和一致性</li>
</ul>
<p>事务的ACIO原则:</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<h3 id="2-Spring中的事务管理"><a href="#2-Spring中的事务管理" class="headerlink" title="2 Spring中的事务管理"></a>2 Spring中的事务管理</h3><ul>
<li>声明式事务：AOP</li>
<li>编程式事务：需要在代码中，进行事务的管理</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置声明式事务--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!--结合AOP实现事务的置入--&gt;</span>
<span class="hljs-comment">&lt;!--配置事务的通知--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span>
	<span class="hljs-comment">&lt;!--给那些方法配置事务--&gt;</span>
	<span class="hljs-comment">&lt;!--配置事务的传播特性: new propagation--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;query&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span>/&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span>

<span class="hljs-comment">&lt;!--配置事务切入--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txPointCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.pnca.mapper.*.*(..))&quot;</span>/&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;txPointCut&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre></div>

]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>基于物联网(IoT)的太阳能跟踪器</title>
    <url>/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/</url>
    <content><![CDATA[<h1 id="基于物联网-IoT-的太阳能跟踪器"><a href="#基于物联网-IoT-的太阳能跟踪器" class="headerlink" title="基于物联网(IoT)的太阳能跟踪器"></a>基于物联网(IoT)的太阳能跟踪器</h1><h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1 项目概述"></a>1 项目概述</h2><ul>
<li><p>该项目提供了一个简单和低成本的 IoT 解决方案，用于监控和控制智能双轴太阳能跟踪系统，用于性能评估。</p>
</li>
<li><p>项目中的基于 IoT 的太阳能跟踪系统在图 1 中进行了描述。它是一种双轴太阳能跟踪器，可以自动旋转，使用LDR传感器跟踪太阳的位置，或者用户通过物理控制的仪表板手动跟踪太阳的位置。系统从 LDR 传感器检测太阳位置（光的强度）开始，并将数据发送到控制器（Arduino Mega 板）。后者然后处理这些数据以命令保存器 （SM1 和 SM2），这些存储器将光伏面板旋转到太阳。产生的光伏电压值和电流、温度和湿度也通过相关传感器发送到 Arduino。</p>
</li>
<li><p>接下来，安装在 Arduino 并允许其连接到 Internet 的以太网扩展模块将把Arduino正在获取或处理的数据发送到云（Webserver）。最后，通过预制的小部件实时显示太阳跟踪器数据，包括LDR传感器、光伏功率、温度和湿度。物联网监控应用程序是使用我的设备卡宴。一旦用户从计算机或智能手机连接到互联网，他可以在物联网应用程序的仪表板中在其相关小部件中可视化所有太阳能跟踪器数据。因此，用户拥有与光伏面板的环境和性能相关的必要数据。</p>
</li>
<li><p>此外，在手动模式下，伺服运动器将从仪表板中的相关小部件中获取角度方向。因此，用户可以控制自己的系统，以寻求最佳的环境条件，并从光伏面板中提取最大能量。物联网应用程序还被编程为在senor达到预定阈值时发送通知警报（短信或电子邮件）。</p>
</li>
</ul>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/clip_image002.png" alt="图1. 项目总体设计图。"></p>
<p>​                                            </p>
<h2 id="2-硬件设计"><a href="#2-硬件设计" class="headerlink" title="2 硬件设计"></a>2 硬件设计</h2><ul>
<li>如图2所示，物联网太阳能跟踪系统由光伏电池板、两台伺服电机、四个LDR传感器、电压分频器电路、温度和湿度传感器、Led和Arduino Mega 板组成。</li>
</ul>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/electronic_circuit_of_the_iot-based_solar_tracker_system_9ORL3xysVy.png" alt="图2. 基于物联网（IoT）的太阳能跟踪器的硬件电路图。"></p>
<ul>
<li><p>使用的光伏面板尺寸为 115 mm 乘 85mm，输出为 1.6 W，可产生高达 6 V 的电压。两个180度的伺服器用于使太阳能跟踪器电机化，它们由阿尔杜伊诺板通过PWM引脚5和6控制。左右 （L-R） 伺服电机 （MG996R） 在垂直轴上（东/西）旋转太阳跟踪器，而上下 （U-D） 伺服电机 （SG90） 在水平轴 （南/北） 上旋转太阳跟踪器。</p>
</li>
<li><p>四个LDR（Cds GL5528）用于感应太阳的位置，这些位置已固定在面板的四个角落。LDR 传感器通过 A0 到 A3 的模拟引脚连接到阿尔杜伊诺。LDR 是一种电阻器，其值随着表面光强度事件的增加而降低。LDR 传感器设计为电压分流器电路，如图 2 所见。分频器输出电压由 Arduino Mega 的微控制器从模拟值转换为 0 到 1023 之间的数字值。因为微控制器的模拟数字转换器 （ADC） 编码为 10 位。LDR 传感器电路中的系列电阻器值为 330 Ω。</p>
</li>
<li><p>温度和湿度通过 DHT22 传感器测量。DHT22 内嵌有一个热电容器和电容湿度传感器，可测量温度和相对湿度。其温度范围为 -40 至 80 °C，准确度为 &lt; ±0.5°C，湿度范围为 0 至 100%，±2%（最大±5%）准确性。此传感器使用一根信号线将数据传输到 Arduino（数字引脚 2）和两根用于电源的电线。</p>
</li>
<li><p>光伏电压和电流通过电压分隔电路测量，该分频器也作为负载，由两个 10 Ohms 的系列电阻器组成。分频器电路输出与阿尔杜伊诺的模拟引脚 A4 相连。此外，连接到数字引脚 3 的 LED 在系统电路中反映了太阳能跟踪器（手动或自动）的模式状态。</p>
</li>
<li><p>Arduino Mega 与ATmega2560 微控制器用作嵌入式控制器，与阿尔杜伊诺以太网屏蔽以及监控平台交互。安装在 Arduino 板上方的以太网防护罩必须通过图 3 中显示的 RJ45 电缆与 Wi-Fi 路由器 （或 PC） 连接。以太网盾基于 Wiznet W5100 以太网芯片，该芯片为 TCP 和 UDP 协议提供了网络 （IP） 堆栈。</p>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/image2_7PtCrbSgOy.png" alt="图3. arduino 和以太网扩展模块之间的硬件连接图。"></p>
</li>
</ul>
<h2 id="3-软件设计"><a href="#3-软件设计" class="headerlink" title="3 软件设计"></a>3 软件设计</h2><h3 id="3-1-Arduino-IDE"><a href="#3-1-Arduino-IDE" class="headerlink" title="3.1 Arduino IDE"></a>3.1 Arduino IDE</h3><p>Arduino 是一个开源电子原型平台，具有易于使用的硬件和软件。Arduino 平台提供集成开发环境 （IDE），其中包括对 C 和C++编程语言的支持。本作品中使用的 Arduino 板由 IDE 编程，该 IDE 充当代码编辑器，程序代码可以通过 USB 电缆上传到微控制器，如图 3 所示。Arduino 巨型板用于实现基于物联网的太阳能跟踪器的所有软件要求。</p>
<h3 id="3-2-myDevices-Cayenne-我的设备卡宴"><a href="#3-2-myDevices-Cayenne-我的设备卡宴" class="headerlink" title="3.2 myDevices Cayenne (我的设备卡宴)"></a>3.2 myDevices Cayenne (我的设备卡宴)</h3><ul>
<li>MyDevices 是一家提供完美的物联网解决方案的公司。它为 IoT 提供了端到端平台。在我们的项目中，我们将专注于卡宴，这是来自我的设备的解决方案之一。此工具允许开发人员、设计师和工程师构建物机原型。卡宴使用消息排队电信传输 （MQTT） 协议将任何设备与卡延内克云连接起来。连接后，用户可以通过创建的小部件将设备中的数据发送并接收到 Cayenne 仪表板。MQTT 是基于 TCP/IP 协议的发布订阅消息协议。发布订阅方法使用负责向客户端传递消息的消息代理。MQTT 是用于向卡宴云或卡宴控制的设备发送信息的 API。此连接中的消息代理是云，它管理发送和接收数据的不同客户端（传感器和执行器）。</li>
<li>要使用 MQTT 与卡宴， 我们需要使用卡宴库。对于阿尔杜伊诺，可以从 IDE 的图书馆经理安装卡延内MQTT 库。要对基于 Cayenne 物联网平台的物联网应用进行编程，我们将利用预先定义的功能。例如，为了建立 Cayenne 云和配备以太网模块的 Arduino Mega 之间的连接，我们调用 CayenneMQTT 以太网库，在那里我们声明我们的身份验证信息（用户名、密码和客户 ID），这些信息应从 Cayenne 仪表板获得。然后，在程序的设置部分，我们调用 <em>Cayenne.开始 （）</em>功能来建立与 Cayenne 仪表板的连接。对于每个执行器，我们创建一个功能，其整数参数在 0 到 31 之间，称为 <em>CAYENNE IN（虚拟通道）。</em>对于每个传感器，我们创建一个功能，其整数参数在 0 到 31 之间，称为<em>CAYENNE_OUT （VIRTUAL_CHANNEL）</em>。在程序的循环部分，我们称为预先定义的函数 <em>Cayenne.loop （），</em>该函数本身称为功能<em>CAYENNE_OUT</em>和<em>CAYENNE_IN。</em>虚拟通道，因为它的名称建议是一个通道，没有物理存在，它的特点是可视化或命令小部件。它允许它们与相应的传感器或执行器连接。</li>
</ul>
<h3 id="3-3-The-embedded-software-design-嵌入式软件设计"><a href="#3-3-The-embedded-software-design-嵌入式软件设计" class="headerlink" title="3.3 The embedded software design(嵌入式软件设计)"></a>3.3 The embedded software design(嵌入式软件设计)</h3><p>嵌入式软件将嵌入到 Arduino Mega 中，以便在以太网模块和 Cayenne 云之间进行交互（参见附录）。其设计如下：</p>
<h4 id="1-功能模式"><a href="#1-功能模式" class="headerlink" title="1 功能模式"></a>1 功能模式</h4><ul>
<li><p>基于物联网的太阳能跟踪器具有两种功能模式：手动和自动。在 Cayenne 仪表板中创建的按钮具有在两种模式之间切换的作用。非活动时，选择手动模式，否则自动模式。此外，在 Arduino 代码中还建立了一个功能，允许恢复按钮的状态。系统电路中的 LED 反映了此开关的状态。</p>
</li>
<li><p>因此，要使控制器了解所选的操作模式，我们只需要测试 LED 连接的引脚状态。例如，如果 LED 状态较低，控制器将调用手动模式功能执行，否则将调用自动功能。</p>
</li>
</ul>
<h4 id="2-手动模式"><a href="#2-手动模式" class="headerlink" title="2 手动模式"></a>2 手动模式</h4><ul>
<li><p>如果选择手动模式，用户可以直接控制伺服器的位置，通过 L-R 伺服器将光伏板从东向西定向，或通过 U-D 伺服器从南向北定向。该控制由物联网应用程序仪表板中服务器运动器的相关小部件组成。</p>
</li>
<li><p>在此模式下，控制器调用 <strong><em>Cayenne.loop（）</em></strong>功能，该函数本身调用所有<strong><em>功能CAYENNE_IN（</em></strong>包括与伺服器相关的功能）执行。 <strong>Cayenne.loop（）</strong>功能还将调用与传感器相连的所有功能CAYENNE_OUT执行。如果将与 LDR 传感器、光伏电流、电压和功率、温度和湿度相关的数据发送到服务器，以便在物联网应用程序中的相关小部件中可视化这些数据。</p>
</li>
</ul>
<h4 id="3-自动模式"><a href="#3-自动模式" class="headerlink" title="3 自动模式"></a>3 自动模式</h4><ul>
<li><p>如果选择自动模式，将执行图 4 中显示的算法。该算法首先阅读 LDR 传感器返回的模拟值。然后，它会处理这些数据以命令将光伏面板移向太阳位置的伺服运动器。考虑到基于垂直轴的太阳能跟踪器运动，比较了左侧两个LDR和右侧两个LDR的平均值，如果左侧接收到更多的光，光伏电池板将朝这个方向（顺时针方向）穿过L-R伺服器。当差额结果在 -10 和 10 之间时，后者将停止。此范围用于稳定控制器并降低伺服器的功耗。否则，如果正确的LDR集接收更多的光，光伏面板将朝这个方向移动（逆时针）通过L-R伺服器，并将继续旋转，直到差异结果在范围内[−10，10]。同一方法用于基于水平轴的太阳能跟踪器运动，比较顶部两个LDR和底部两个LDR的平均值。</p>
</li>
<li><p>除了在自动模式下，控制器还将调用 <strong><em>Cayenne.loop（）</em></strong>功能将太阳能跟踪器数据发送到 IoT 应用程序。</p>
</li>
</ul>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/image_3_pZv5s80gr2.png" alt="图4. 太阳能跟踪器自动模式的流程图。"></p>
<h3 id="3-4-Development-of-the-IoT-monitoring-application-开发-IoT-监控应用程序"><a href="#3-4-Development-of-the-IoT-monitoring-application-开发-IoT-监控应用程序" class="headerlink" title="3.4 Development of the IoT monitoring application(开发 IoT 监控应用程序)"></a>3.4 Development of the IoT monitoring application(开发 IoT 监控应用程序)</h3><h4 id="1-硬件与卡宴-IoT-平台的连接"><a href="#1-硬件与卡宴-IoT-平台的连接" class="headerlink" title="1 硬件与卡宴 IoT 平台的连接"></a>1 硬件与卡宴 IoT 平台的连接</h4><p>要将硬件（包括传感器和执行器）与物联网络平台对接，我们需要遵循以下步骤：</p>
<ul>
<li><p>创建帐户后登录卡宴我的Device网站（图5（a））。</p>
</li>
<li><p>然后，单击 Cayenne API 中的”自带东西”（图 5（b））。</p>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig5_jaSC4EBHxI.png" alt="图5. 卡宴IoT平台注册（a）。卡宴API（b）。"></p>
</li>
<li><p>从克里特岛应用程序（图6）复制 MQTT 凭据（用户名、密码和客户 ID），并将其粘贴到 Arduino 源代码中，如前所述。在成功编译并上传整个代码到 Arduino Mega 后，在 Arduino IDE 中打开串行监视器以获取 Cayenne 日志打印（图 7）。一旦我们的设备上线并连接到 Cayenne，上一页（图 6）将自动更新，我们将在在线仪表板中看到我们的设备，如图 8 所见。</p>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig6_qCu0wEtQwz.png" alt="图6. MQTT凭据和设备连接到卡宴。"></p>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fige_yYB61wSOY4.png" alt="图7. 卡宴日志打印在串行监视器上。"></p>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig8_lQi9h5PnKM.png" alt="图8. 设备设置。"></p>
</li>
<li><p>然后，要接口传感器和执行器，即创建其小部件，单击”添加新…”，选择”设备/小部件”，然后单击”自定义小部件”（图 9）。然后，选择小部件并填充相关设置（通道号必须与代码相同），最后单击”添加小部件”将其添加到设备的仪表板。对于我们来说，我们为所有传感器选择了”价值”小部件，为模式切换选择了”按钮”小部件，为伺服器选择了”滑块”小部件。</p>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig9_0KAhjvvj5M.png" alt="图9. 卡宴自定义小部件。"></p>
</li>
</ul>
<p>最后，图10说明了用于监测太阳能跟踪器数据的设计物联网应用程序。与太阳跟踪器系统建立连接后，传感器数据可以在其相关部件上可视化，跟踪模式（自动或手动）可以从开关按钮中选择，并通过小部件控制伺服者的角度。还可以通过修改其设置中的表示类型或单击小部件上方的图形图标以图形形式获取传感器数据。</p>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig10_Om7yhhrJcO.png" alt="图10. 太阳能跟踪系统的IoT监控应用。"></p>
<h4 id="2-警报创建"><a href="#2-警报创建" class="headerlink" title="2 警报创建"></a>2 警报创建</h4><p>监控系统中最重要的标准之一是，当发生与其监控设备相关的事件时，它能够发送通知警报通知用户。为此，我们利用 Cayenne 的一个功能为我们的物联网应用程序添加警报，在那里我们可以预先编程我们的应用程序以发送通知警报（短信、电子邮件或两者兼有）或执行指定操作。例如，创建温度警报，以便在监控温度达到阈值时向用户（或收件人）发送电子邮件通知，如图 11 所示。要创建警报，请单击”添加新。”然后选择”触发”，然后设置事件及其操作，最后单击”保存”将其添加到仪表板。</p>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig11_HcTpIiwQOI.png" alt="图11. 温度警报设置。"></p>
<h2 id="4-原型设计"><a href="#4-原型设计" class="headerlink" title="4 原型设计"></a>4 原型设计</h2><p>图12展示了太阳能跟踪器原型在其分离和组装状态。它由光伏面板、R 和 U-D 伺服器和 LDR 传感器组成。该面板一侧连接到 U-Dservomotor，另一侧有轴承，以确保当太阳能跟踪器围绕水平轴旋转时更好的灵活性。装配连接到 L-R 伺服器。LDR 传感器固定在空心气缸内面板的四个角落。如果面板不垂直于太阳，则至少有一个 LDR 将被周围圆柱体造成的阴影覆盖。因此，光强度会有差异。最佳方向是当光的特性在所有LDR传感器中是相等的。图13显示了基于 IoT 的太阳能跟踪系统的整个原型，很明显，硬件部分中的所有报告组件都已用于构建它。</p>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/solar_tracker_prototype_in_its_detached_and_assembled_state_zbScjRgUaK.png" alt="图12. 太阳能跟踪器原型处于组装和分离状态"></p>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/iot_based_solar_tracker_prototype__PG9L9gMmwr.png" alt="图13. 基于IOT的太阳能跟踪器原型"></p>
<p>有关所获结果的更多详细信息，请参阅本链接中的论文： <a href="https://link.springer.com/chapter/10.1007%2F978-3-030-64565-6_4">https://link.springer.com/chapter/10.1007%2F978-3-030-64565-6_4</a></p>
<h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5 代码"></a>5 代码</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/***************************************************************</span>
<span class="hljs-comment"> PROJECT: IoT based solar tracker system / the embedded software</span>
<span class="hljs-comment"> Aboubakr El Hammoumi/ aboubakr.elhammoumi@usmba.ac.ma</span>
<span class="hljs-comment">***************************************************************/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CAYENNE_PRINT Serial</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;CayenneMQTTEthernet.h&gt;</span>    <span class="hljs-comment">//CayenneMQTT library </span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Servo.h&gt;</span>                  <span class="hljs-comment">//Servo motor library </span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;DHT.h&gt;</span>                    <span class="hljs-comment">//DHT library </span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DHTTYPE DHT22</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DHTPIN 2</span>
<span class="hljs-function">DHT <span class="hljs-title">dht</span><span class="hljs-params">(DHTPIN,DHTTYPE)</span></span>;

<span class="hljs-comment">//MQTT credentials   </span>
<span class="hljs-keyword">char</span> username[]=<span class="hljs-string">&quot;498d2d00-afe2-11ea-883c-638d8ce4c23d&quot;</span>;
<span class="hljs-keyword">char</span> password[]=<span class="hljs-string">&quot;ab4a8f92d94033c01f6e18ce1d8a84d8c304c9c4&quot;</span>;
<span class="hljs-keyword">char</span> clientID[]=<span class="hljs-string">&quot;17798a40-b968-11ea-93bf-d33a96695544&quot;</span>;

Servo servo_x;                   <span class="hljs-comment">//up-down servomotor  </span>
<span class="hljs-keyword">int</span> servoh = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> servohLimitHigh = <span class="hljs-number">170</span>;     
<span class="hljs-keyword">int</span> servohLimitLow = <span class="hljs-number">10</span>;       

Servo servo_z;                   <span class="hljs-comment">//left-right servomotor </span>
<span class="hljs-keyword">int</span> servov = <span class="hljs-number">0</span>; 
<span class="hljs-keyword">int</span> servovLimitHigh = <span class="hljs-number">170</span>;
<span class="hljs-keyword">int</span> servovLimitLow = <span class="hljs-number">10</span>;

<span class="hljs-keyword">int</span> topl,topr,botl,botr;
<span class="hljs-keyword">int</span> threshold_value=<span class="hljs-number">10</span>;        
<span class="hljs-keyword">float</span> Vout;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123; Serial.begin(<span class="hljs-number">9600</span>);
  Cayenne.begin(username, password, clientID);
  servo_x.attach(<span class="hljs-number">5</span>);
  servo_z.attach(<span class="hljs-number">6</span>);
  dht.begin();
  pinMode(<span class="hljs-number">3</span>,OUTPUT);
  digitalWrite(<span class="hljs-number">3</span>,LOW); 
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123; topr= analogRead(A2);       
  topl= analogRead(A3);         
  botl= analogRead(A4);         
  botr= analogRead(A5);        
  Vout=(analogRead(A1) * <span class="hljs-number">5.0</span>) / <span class="hljs-number">1023</span>;
  Serial.println(<span class="hljs-string">&quot; Manual-mode&quot;</span>);
  Cayenne.loop();
  
  <span class="hljs-keyword">if</span> (digitalRead(<span class="hljs-number">3</span>)==HIGH)&#123;
    Serial.println(<span class="hljs-string">&quot; Automatic-mode&quot;</span>);
    servoh = servo_x.read();
    servov = servo_z.read();
    <span class="hljs-keyword">int</span> avgtop = (topr + topl) / <span class="hljs-number">2</span>;     
    <span class="hljs-keyword">int</span> avgbot = (botr + botl) / <span class="hljs-number">2</span>;   
    <span class="hljs-keyword">int</span> avgright = (topr + botr) / <span class="hljs-number">2</span>;   
    <span class="hljs-keyword">int</span> avgleft = (topl + botl) / <span class="hljs-number">2</span>;    
    <span class="hljs-keyword">int</span> diffhori= avgtop - avgbot;      
    <span class="hljs-keyword">int</span> diffverti= avgleft - avgright;    
    
    <span class="hljs-comment">/*tracking according to horizontal axis*/</span> 
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(diffhori) &lt;= threshold_value)
    &#123;
     servo_x.write(servoh);            <span class="hljs-comment">//stop the servo up-down</span>
    &#125;<span class="hljs-keyword">else</span> &#123;
       <span class="hljs-keyword">if</span> (diffhori &gt; threshold_value)
          &#123; Serial.println(<span class="hljs-string">&quot; x - 2 &quot;</span>);
          servo_x.write(servoh <span class="hljs-number">-2</span>);    <span class="hljs-comment">//Clockwise rotation CW</span>
          <span class="hljs-keyword">if</span> (servoh &gt; servohLimitHigh)
          &#123;
           servoh = servohLimitHigh;
          &#125;
          delay(<span class="hljs-number">10</span>);
          &#125;<span class="hljs-keyword">else</span> &#123;
           servo_x.write(servoh +<span class="hljs-number">2</span>);   <span class="hljs-comment">//CCW</span>
           <span class="hljs-keyword">if</span> (servoh &lt; servohLimitLow)
           &#123;
           servoh = servohLimitLow;
           &#125;
           delay(<span class="hljs-number">10</span>);
           &#125;
      &#125;      
    <span class="hljs-comment">/*tracking according to vertical axis*/</span> 
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(diffverti) &lt;= threshold_value)
    &#123;     
     servo_z.write(servov);       <span class="hljs-comment">//stop the servo left-right</span>
    &#125;<span class="hljs-keyword">else</span>&#123;
       <span class="hljs-keyword">if</span> (diffverti &gt; threshold_value)
       &#123; 
       servo_z.write(servov <span class="hljs-number">-2</span>);  <span class="hljs-comment">//CW</span>
       <span class="hljs-keyword">if</span> (servov &gt; servovLimitHigh) 
       &#123; 
       servov = servovLimitHigh;
       &#125;
       delay(<span class="hljs-number">10</span>);
       &#125;<span class="hljs-keyword">else</span>&#123; 
        servo_z.write(servov +<span class="hljs-number">2</span>);  <span class="hljs-comment">//CCW</span>
        <span class="hljs-keyword">if</span> (servov &lt; servovLimitLow) 
        &#123;
        servov = servovLimitLow;
        &#125;
        delay(<span class="hljs-number">10</span>);
        &#125;
     &#125;
  &#125;
&#125;
<span class="hljs-comment">// Cayenne Functions</span>
CAYENNE_IN(<span class="hljs-number">8</span>)&#123;
  <span class="hljs-keyword">int</span> value = getValue.asInt();
  CAYENNE_LOG(<span class="hljs-string">&quot;Channel %d, pin %d, value %d&quot;</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, value);
  digitalWrite(<span class="hljs-number">3</span>,value);
&#125;
CAYENNE_IN(<span class="hljs-number">7</span>)&#123; <span class="hljs-comment">//up-down servo motor</span>
  <span class="hljs-keyword">if</span> (digitalRead(<span class="hljs-number">3</span>)==HIGH)&#123; <span class="hljs-comment">//Automatic_mode</span>
  &#125;
  <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//Manual_mode</span>
  servo_x.write(getValue.asDouble() * <span class="hljs-number">180</span>);
  &#125;
&#125;
CAYENNE_IN(<span class="hljs-number">6</span>)&#123; <span class="hljs-comment">//left-right servo motor</span>
  <span class="hljs-keyword">if</span> (digitalRead(<span class="hljs-number">3</span>)==HIGH)&#123;
  &#125;  
  <span class="hljs-keyword">else</span>&#123;
  servo_z.write(getValue.asDouble() * <span class="hljs-number">180</span>);
  &#125;
&#125;

CAYENNE_OUT(<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//Current</span>
  <span class="hljs-keyword">float</span> current = Vout/<span class="hljs-number">10</span>;
  Cayenne.virtualWrite(<span class="hljs-number">0</span>, current);
  Serial.print(<span class="hljs-string">&quot;Current: &quot;</span>);
  Serial.println(current);
&#125;
CAYENNE_OUT(<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//Voltage</span>
  <span class="hljs-keyword">float</span> voltage = Vout * <span class="hljs-number">2</span>;
  Cayenne.virtualWrite(<span class="hljs-number">1</span>, voltage);
  Serial.print(<span class="hljs-string">&quot;Voltage: &quot;</span>);
  Serial.println(voltage);
&#125;
CAYENNE_OUT(<span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//LDR Top-right</span>
  Cayenne.virtualWrite(<span class="hljs-number">2</span>, topr);
&#125;
CAYENNE_OUT(<span class="hljs-number">3</span>)&#123; <span class="hljs-comment">//LDR Top-left</span>
  Cayenne.virtualWrite(<span class="hljs-number">3</span>,topl);
&#125;
CAYENNE_OUT(<span class="hljs-number">4</span>)&#123; <span class="hljs-comment">//LDR Bot-left</span>
  Cayenne.virtualWrite(<span class="hljs-number">4</span>,botl);
&#125;
CAYENNE_OUT(<span class="hljs-number">5</span>)&#123; <span class="hljs-comment">//LDR Bot-right</span>
  Cayenne.virtualWrite(<span class="hljs-number">5</span>,botr);
&#125;
CAYENNE_OUT(<span class="hljs-number">10</span>) &#123; <span class="hljs-comment">//Power</span>
  <span class="hljs-keyword">float</span> power = (Vout * <span class="hljs-number">2</span> * Vout)/<span class="hljs-number">10</span> ;
  Cayenne.virtualWrite(<span class="hljs-number">10</span>, power);
  Serial.print(<span class="hljs-string">&quot;Power: &quot;</span>);
  Serial.println(power);
&#125;
CAYENNE_OUT(<span class="hljs-number">11</span>)&#123; <span class="hljs-comment">//Temperature</span>
  <span class="hljs-keyword">float</span> t = dht.readTemperature();
  <span class="hljs-comment">//int chk = dht.read(DHT11PIN);</span>
  Cayenne.virtualWrite(<span class="hljs-number">11</span>, t, TYPE_TEMPERATURE, UNIT_CELSIUS);
  Serial.print(<span class="hljs-string">&quot;temperature: &quot;</span>);
  Serial.println(t);
&#125;
CAYENNE_OUT(<span class="hljs-number">12</span>)&#123; <span class="hljs-comment">//Huidity</span>
  <span class="hljs-keyword">float</span> h = dht.readHumidity();
  <span class="hljs-comment">//int chk = dht.read(DHT11PIN);</span>
  Cayenne.virtualWrite(<span class="hljs-number">12</span>, h);
  Serial.print(<span class="hljs-string">&quot;  humidity: &quot;</span>);
  Serial.println(h);
&#125;</code></pre></div>

<h2 id="6-发展示例"><a href="#6-发展示例" class="headerlink" title="6 发展示例"></a>6 发展示例</h2><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/img_3581_XDaDENY3ax.JPG" alt="太阳能电池板太阳跟踪器 - 手机充电器"></p>
<p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/image-20210607020629991.png" alt="巨型太阳能跟踪器"></p>
]]></content>
      <categories>
        <category>Technical</category>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>太阳能</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo 学习</title>
    <url>/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Dubbo-学习"><a href="#Dubbo-学习" class="headerlink" title="Dubbo 学习"></a>Dubbo 学习</h1><h2 id="1-分布式简要说明"><a href="#1-分布式简要说明" class="headerlink" title="1 分布式简要说明"></a>1 分布式简要说明</h2><h3 id="1-1-什么是分布式？"><a href="#1-1-什么是分布式？" class="headerlink" title="1.1 什么是分布式？"></a>1.1 什么是分布式？</h3><ul>
<li><p>Dubbo是用于分布式系统的框架所以我们要先了解什么是分布式<br>分布式系统是若干独立 计算机的集合，这些计算机对于用户来说就像单个相关系统。</p>
</li>
<li><p>老式系统(单一应用架构)就是把一个系统，统一放到一个服务器当中然后每一个服务器上放一个系统，如果说要更新代码的话，每一个服务器上的系统都要重新去部署十分的麻烦。</p>
</li>
</ul>
<ul>
<li>而分布式系统就是将一个完整的系统拆分成多个不同的服务，然后在将每一个服务单独的放到一个服务器当中。(三个臭皮匠赛过诸葛亮)</li>
</ul>
<h3 id="1-2-RPC-简介"><a href="#1-2-RPC-简介" class="headerlink" title="1.2 RPC 简介"></a>1.2 RPC 简介</h3><ul>
<li><p><strong>分布式应用架构(远程过程调用)</strong>：当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</p>
</li>
<li><p>什么叫RPC</p>
<ul>
<li>RPC [ Remote Procedure Call]是指远程过程调用，是一种进程问通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间(通常是共享网络的另一台机器上)的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</li>
<li>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</li>
</ul>
</li>
<li><p><strong>RPC工作原理</strong></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/2020061015260046.png" alt="img"></p>
<ol>
<li>Client像调用本地服务似的调用远程服务；</li>
<li>Client stub接收到调用后，将方法、参数序列化</li>
<li>客户端通过sockets将消息发送到服务端</li>
<li>Server stub 收到消息后进行解码（将消息对象反序列化）</li>
<li>Server stub 根据解码结果调用本地的服务</li>
<li>本地服务执行(对于服务端来说是本地执行)并将结果返回给Server stub</li>
<li>Server stub将返回结果打包成消息（将结果消息对象序列化）</li>
<li>服务端通过sockets将消息发送到客户端</li>
<li>Client stub接收到结果消息，并进行解码（将结果消息发序列化）</li>
<li>客户端得到最终结果。</li>
</ol>
</li>
<li><p><strong>RPC 调用分以下两种：</strong></p>
<ul>
<li><strong>同步调用</strong>：客户方等待调用执行完成并返回结果。</li>
<li><strong>异步调用</strong>：客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。</li>
</ul>
</li>
<li><p><strong>RPC步骤解析</strong></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610174636250.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>SOA</strong><br><strong>流动计算架构</strong>：在分布式应用架构的基础上增加了一个<strong>调度、治理中心</strong>基于访问压力实时管理集群容量、提高集群的利用率，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键 <strong>(不浪费计算机资源)</strong></p>
</li>
</ul>
<h2 id="2-Dubbo核心概念"><a href="#2-Dubbo核心概念" class="headerlink" title="2 Dubbo核心概念"></a>2 Dubbo核心概念</h2><p>Dubbo官网: <a href="http://dubbo.apache.org/en-us/index.html">http://dubbo.apache.org/en-us/index.html</a></p>
<p>Dubbo 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，服务自动注册和发现。分布式系统是将一个系统拆分为多个不同的服务。</p>
<h2 id="3-Dubbo特性一览"><a href="#3-Dubbo特性一览" class="headerlink" title="3 Dubbo特性一览"></a>3 Dubbo特性一览</h2><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610170234620.png" alt="img"></p>
<h3 id="Dubbo设计架构"><a href="#Dubbo设计架构" class="headerlink" title="Dubbo设计架构"></a>Dubbo设计架构</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610170317960.png" alt="在这里插入图片描述"></p>
<p>该图来自Dubbo官网，描述了服务注册中心、服务提供方、服务消费方、服务监控中心之间的调用关系。</p>
<ul>
<li><strong>服务提供者</strong>（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li><strong>服务消费者</strong>（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li><strong>注册中心</strong>（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li><strong>监控中心</strong>（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ul>
<h2 id="4-Dubbo的特性解析"><a href="#4-Dubbo的特性解析" class="headerlink" title="4 Dubbo的特性解析"></a>4 Dubbo的特性解析</h2><ul>
<li><p>服务注册中心</p>
<ul>
<li>相比Hessian类RPC框架，Dubbo有自己的服务中心， 写好的服务可以注册到服务中心， 客户端从服务中心寻找服务，然后再到相应的服务提供者机器获取服务。通过服务中心可以实现集群、负载均衡、高可用(容错) 等重要功能。</li>
<li>服务中心一般使用zookeeper实现，也有redis和其他一些方式。以使用zookeeper作为服务中心为例，服务提供者启动后会在zookeeper的/dubbo节点下创建提供的服务节点，包含服务提供者ip、port等信息。服务提供者关闭时会从zookeeper中移除对应的服务。</li>
<li>服务使用者会从注册中心zookeeper中寻找服务，同一个服务可能会有多个提供者，Dubbo会帮我们找到合适的服务提供者，也就是针对服务提供者的负载均衡。</li>
</ul>
</li>
<li><p>负载均衡</p>
<p>当同一个服务有多个提供者在提供服务时，客户端如何正确的选择提供者实 现负载均衡呢？dubbo也给我们提供了几种方案：</p>
<ul>
<li>random 随机选提供者，并可以给提供者设置权重</li>
<li>roundrobin 轮询选择提供者</li>
<li>leastactive 最少活跃调用数，相同活跃数的随机，活跃数：指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
<li>consistenthash 一致性hash，相同参数的请求发到同一台机器上。</li>
</ul>
</li>
<li><p>简化测试，允许直连提供者<br>在开发阶段为了方便测试，通常系统客户端能指定调用某个服务提供者，那么可以在引用服务时加一个url参数去指定服务提供者。 配置如下</p>
<div class="code-wrapper"><pre><code class="hljs dubbo">&lt;dubbo:reference id&#x3D;&quot;xxxService&quot;interface&#x3D;&quot;com.alibaba.xxx.XxxService&quot;url&#x3D;&quot;dubbo:&#x2F;&#x2F;localhost:20890&quot;&#x2F;&gt;</code></pre></div>
</li>
<li><p>服务版本，服务分组<br>在Dubbo配置文件中可以通过制定版本实现连接制定提供者，也就是通过服务版本可以控制服务的不兼容升级；当同一个服务有多种实现时，可以使用服务分组进行区分。</p>
</li>
</ul>
<h2 id="5-Dubbo-Zookeeper"><a href="#5-Dubbo-Zookeeper" class="headerlink" title="5 Dubbo + Zookeeper"></a>5 Dubbo + Zookeeper</h2><h3 id="5-1-搭建zookeeper注册中心环境"><a href="#5-1-搭建zookeeper注册中心环境" class="headerlink" title="5.1 搭建zookeeper注册中心环境"></a>5.1 搭建zookeeper注册中心环境</h3><p>Dubbo官方文档: <a href="http://dubbo.apache.org/en-us/docs/user/quick-start.html">http://dubbo.apache.org/en-us/docs/user/quick-start.html</a><br>在zookeeper官网下载zookeeper<br><a href="http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/">http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/</a></p>
<ul>
<li>在bin文件下，启动zkServer.cmd会有报错，处理需要在condif文件中将zoo_sample.cfg文件复制一份，将名字改为zoo.cfg。<br>在zookeeper的文件夹下创建data文件夹，打开zoo.cfg，修改datadir，将dataDir数据保存为我们自定义的文件中(此步骤可省略)</li>
</ul>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610173149263.png" alt="img"></p>
<ul>
<li>配置完毕后，我们再次在conf下启动zkServer.cmd，这次可以成功启动</li>
</ul>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610173356318.png" alt="img"></p>
<ul>
<li>继续运行zkCli.cmd，可以连接到zookeeper的服务器。</li>
</ul>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610173644649.png" alt="img"></p>
<ul>
<li>此时，我们zookeeper的注册中心及环境以及搭建完毕。</li>
</ul>
<h3 id="5-2-zookeeper监控中心的配置"><a href="#5-2-zookeeper监控中心的配置" class="headerlink" title="5.2 zookeeper监控中心的配置"></a>5.2 zookeeper监控中心的配置</h3><ul>
<li><p>下载dubbo-admin</p>
<p>dubbo-admin下载地址 ：<a href="https://github.com/apache/dubbo-admin/tree/master">https://github.com/apache/dubbo-admin/tree/master</a></p>
</li>
<li><p>解压后进入目录修改指定zookeeper地址<br>进入如下地址：dubbo-admin-master\dubbo-admin\src\main\resources\application.properties”<br>将zookeeper的监控中心的地址配置为本地端口</p>
<div class="code-wrapper"><pre><code class="hljs dubbo">#注册中心的地址
dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181</code></pre></div>

<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610175513207.png" alt="在这里插入图片描述"></p>
</li>
<li><p>配置完毕后，我们在dubo-zookeeper\dubbo-admin-master\dubbo-admin文件夹下cmd打包测试下。</p>
<div class="code-wrapper"><pre><code class="hljs dubbo">mvn clean package</code></pre></div>

<p>在target文件中打包完成的jar包</p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610175909584.png" alt="img"></p>
</li>
</ul>
<ul>
<li><p>cmd命令 <code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</code>运行打包好的jar包<br>启动成功后，可以看到一个7001的端口</p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610180201513-1620378376190.png" alt="在这里插入图片描述"></p>
</li>
<li><p>此时我们的zookeeper的服务都为启动状态，在浏览器中访问 localhost:7001，访问到注册中心，输入账号密码root。</p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610180358177.png" alt="img"></p>
</li>
</ul>
<blockquote>
<p>  此时，我们zookeeper监控中心的配置完成。注意，要访问到监控中心，一定要启动zookeeper注册中心的启动类</p>
</blockquote>
<h2 id="6-Dubbo环境搭建，创建提供者、消费者项目"><a href="#6-Dubbo环境搭建，创建提供者、消费者项目" class="headerlink" title="6 Dubbo环境搭建，创建提供者、消费者项目"></a>6 Dubbo环境搭建，创建提供者、消费者项目</h2><p>基于以下图实现服务 提供者、消费者</p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610195718980.png" alt="在这里插入图片描述"></p>
<h3 id="6-1-Dubbo服务提供者和消费者接口搭建"><a href="#6-1-Dubbo服务提供者和消费者接口搭建" class="headerlink" title="6.1 Dubbo服务提供者和消费者接口搭建"></a>6.1 Dubbo服务提供者和消费者接口搭建</h3><p><strong>创建Maven项目=&gt; <code>user-service-provider</code> 服务提供者</strong></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509014131477.png" alt="image-20210509014131477"></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509014149815.png" alt="image-20210509014149815"></p>
<ul>
<li><p><strong>UserAddress</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAddress</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String userAddress; <span class="hljs-comment">//用户地址</span>
    <span class="hljs-keyword">private</span> String userId; <span class="hljs-comment">//用户id</span>
    <span class="hljs-keyword">private</span> String consignee; <span class="hljs-comment">//收货人</span>
    <span class="hljs-keyword">private</span> String phoneNum; <span class="hljs-comment">//电话号码</span>
    <span class="hljs-keyword">private</span> String isDefault; <span class="hljs-comment">//是否为默认地址    Y-是     N-否</span>
    <span class="hljs-comment">//get     set </span>
    <span class="hljs-comment">//有参构造  无参构造</span>
  &#125;</code></pre></div>
</li>
<li><p><strong>UserService</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//用户服务</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;
	<span class="hljs-comment">/**</span>
<span class="hljs-comment">	 * 按照用户id返回所有的收货地址</span>
<span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> userId</span>
<span class="hljs-comment">	 * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span></span>;
&#125;</code></pre></div>
</li>
<li><p><strong>UserServiceImpl</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span> </span>&#123;

		UserAddress address1 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;河南省郑州巩义市宋陵大厦2F&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;安然&quot;</span>, <span class="hljs-string">&quot;150360313x&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>);
		UserAddress address2 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;北京市昌平区沙河镇沙阳路&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;情话&quot;</span>, <span class="hljs-string">&quot;1766666395x&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>);

		<span class="hljs-keyword">return</span> Arrays.asList(address1,address2);
	&#125;
&#125;</code></pre></div>

</li>
</ul>
<p><strong>创建Maven项目=&gt; <code>order-service-consumer</code> 服务消费者(订单服务)</strong></p>
<ul>
<li><p><strong>OrderService</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 初始化订单</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userID</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span></span>;
&#125;</code></pre></div>
</li>
<li><p><strong>OrderServiceImpl</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span> </span>&#123;
        <span class="hljs-comment">//查询用户的收货地址</span>

    &#125;
&#125;</code></pre></div>

</li>
</ul>
<p><strong>因服务消费者要拿到提供者的方法</strong></p>
<p>将服务提供者中的实体类及 UserService 复制到当前消费者同级文件中。</p>
<ul>
<li><p><strong>OrderServiceImpl</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;
    <span class="hljs-keyword">public</span> UserService userService;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span> </span>&#123;
        <span class="hljs-comment">//查询用户的收货地址</span>
        List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList(userID);
        System.out.println(userAddressList);
    &#125;
&#125;</code></pre></div>

</li>
</ul>
<p>此时我们调用 userservice 肯定是要报错的。这种面向接口的方式，我们这里只是调到了接口，而接口实际是在另外一个项目中，如果我们两个项目工程都创建共同的实体类，太过于麻烦了，我们可以将服务接口，服务模型等单独放在一个项目中，更为方便调用。</p>
<p><strong>创建Maven项目=&gt; gmail-interface 用于存放共同的服务接口</strong></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200611154037439.png" alt="在这里插入图片描述"></p>
<p>将 提供者 和 消费者 项目中的所有实体类复制到当前相关的文件包下，删除原有的实体类包及service包，也就是将实体类及service放在了当前公共的项目中。</p>
<p>把服务提供者和消费者项目中引入以下依赖，引入后项目不在报错.</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lemon.gmail<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmail-interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h3 id="6-2-服务提供者配置及测试"><a href="#6-2-服务提供者配置及测试" class="headerlink" title="6.2 服务提供者配置及测试"></a>6.2 服务提供者配置及测试</h3><p>在 <code>user-service-provider</code> 服务提供者项目中引入依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--注册中心是 zookeeper，引入zookeeper客户端--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>在<code>resource</code>文件中创建<code>provider.xml</code></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span>
	
	<span class="hljs-comment">&lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user-service-provider&quot;</span>/&gt;</span>
	
	<span class="hljs-comment">&lt;!-- 2、指定注册中心的位置 --&gt;</span>
	<span class="hljs-comment">&lt;!-- &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; --&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;zookeeper&quot;</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>/&gt;</span>
	
	<span class="hljs-comment">&lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20882&quot;</span>/&gt;</span>
	
 <span class="hljs-comment">&lt;!--4、暴露服务 让别人调用 ref指向服务的真正实现对象--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.lemon.gmail.service.UserService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span>

    <span class="hljs-comment">&lt;!--服务的实现--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userServiceImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.lemon.gmail.service.impl.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>编写一个<code>ProviderApplication</code>启动类程序，运行测试配置</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailApplication</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        ClassPathXmlApplicationContext applicationContext= <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;provider.xml&quot;</span>);
        applicationContext.start();
        System.inread();
    &#125;
&#125;</code></pre></div>

<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509015143656.png" alt="image-20210509015143656"></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509015205821.png" alt="image-20210509015205821"></p>
<h3 id="6-3-服务消费者配置及测试"><a href="#6-3-服务消费者配置及测试" class="headerlink" title="6.3 服务消费者配置及测试"></a>6.3 服务消费者配置及测试</h3><p>在 <code>order-service-consumer</code> 服务消费者项目中引入依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--注册中心是 zookeeper，引入zookeeper客户端--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>创建<code>consumer.xml</code></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.pnca.gmall&quot;</span>/&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order-service-consumer&quot;</span>/&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.pnca.gmall.service.UserService&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div>

<p>把当前<code>OrderServiceImpl</code>实现类中加上注解</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">public</span> UserService userService;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span> </span>&#123;
        <span class="hljs-comment">//查询用户的收货地址</span>
        List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList(userID);
        
        <span class="hljs-comment">//为了直观的看到得到的数据，以下内容也可不写</span>
        System.out.println(<span class="hljs-string">&quot;当前接收到的userId=&gt; &quot;</span>+userID);
        System.out.println(<span class="hljs-string">&quot;**********&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;查询到的所有地址为：&quot;</span>);
        <span class="hljs-keyword">for</span> (UserAddress userAddress : userAddressList) &#123;
            <span class="hljs-comment">//打印远程服务地址的信息</span>
            System.out.println(userAddress.getUserAddress());
        &#125;
        
    &#125;
&#125;</code></pre></div>

<p>编写一个<code>ConsumerApplication</code>启动类程序，运行测试配置</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ClassPathXmlApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;consumer.xml&quot;</span>);
        OrderService orderService = applicationContext.getBean(OrderService.class);

        <span class="hljs-comment">//调用方法查询出数据</span>
        orderService.initOrder(<span class="hljs-string">&quot;1&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;调用完成...&quot;</span>);
	    System.in.read();
    &#125;
&#125;</code></pre></div>

<p>注意：消费者的运行测试需要先启动提供者。<br>启动服务提供者、消费者。及zookeeper的和dubbo-admin，查看监控信息。<br>localhost:7001</p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512202425183.png" alt="image-20210512202425183"></p>
<h2 id="7-dubbo-monitor-simple-简易监控中心"><a href="#7-dubbo-monitor-simple-简易监控中心" class="headerlink" title="7 dubbo-monitor-simple 简易监控中心"></a>7 dubbo-monitor-simple 简易监控中心</h2><ul>
<li><p>进入dubbo-monitor-simple文件，执行cmd命令，mvn package打包成jar包</p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612083732691.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200612084630745.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>将 <code>dubbo-monitor-simple-2.0.0-assembly.tar.gz</code> 压缩包解压至当前文件夹，解压后config文件查看properties的配置是否是本地的zookeeper。</p>
</li>
<li><p>打开解压后的 <code>assembly.bin</code> 文件，<code>start.bat</code> 启动<code>dubbo-monitor-simple监控中心</code></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512203200864.png" alt="image-20210512203200864"></p>
<p>在浏览器 <code>localhost:8080</code> ，可以看到一个监控中心。<br>在服务提供者和消费者的xml中配置以下内容，再次启动服务提供和消费者启动类。</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo-monitor-simple监控中心发现的配置--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:monitor</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;registry&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:monitor</span>&gt;</span>
<span class="hljs-comment">&lt;!--&lt;dubbo:monitor address=&quot;127.0.0.1:7070&quot;&gt;&lt;/dubbo:monitor&gt;--&gt;</span></code></pre></div>

<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512203449002.png" alt="image-20210512203449002"></p>
</li>
</ul>
<h2 id="8-Dubbo-与-springboot-整合"><a href="#8-Dubbo-与-springboot-整合" class="headerlink" title="8 Dubbo 与 springboot 整合"></a>8 Dubbo 与 springboot 整合</h2><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612152443622.png" alt="在这里插入图片描述"></p>
<h3 id="8-1-boot-user-service-provider-服务提供者"><a href="#8-1-boot-user-service-provider-服务提供者" class="headerlink" title="8.1 boot-user-service-provider 服务提供者"></a>8.1 boot-user-service-provider 服务提供者</h3><ul>
<li><p><strong>创建 springboot 项目 <code>boot-user-service-provider</code></strong> 服务提供者</p>
</li>
<li><p>导入依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca.gmall<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmall_interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>把 <code>user-service-provider</code> 中的 service 拿到此项目中。注意，以此方法为返回的需要更改 interface 包中的 void为 List<UserAddress></UserAddress></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>    <span class="hljs-comment">// dubbo暴露服务</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span> </span>&#123;
		<span class="hljs-comment">// TODO Auto-generated method stub</span>
		System.out.println(<span class="hljs-string">&quot;UserServiceImpl..3.....&quot;</span>);
		UserAddress address1 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;北京市昌平区宏福科技园综合楼3层&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;李老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>);
		UserAddress address2 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;深圳市宝安区西部硅谷大厦B座3层（深圳分校）&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;王老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>);
		<span class="hljs-keyword">return</span> Arrays.asList(address1, address2);
	&#125;

&#125;</code></pre></div>
</li>
<li><p>配置 <code>application.properties</code></p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">boot_user_service_provider</span>
<span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">127.0.0.1:2181</span>
<span class="hljs-meta">dubbo.registry.protocol</span>=<span class="hljs-string">zookeeper</span>

<span class="hljs-meta">dubbo.protocol.name</span>=<span class="hljs-string">dubbo</span>
<span class="hljs-meta">dubbo.protocol.port</span>=<span class="hljs-string">20880</span>

<span class="hljs-comment">#连接监控中心</span>
<span class="hljs-meta">dubbo.monitor.protocol</span>=<span class="hljs-string">registry</span></code></pre></div>
</li>
<li><p>BootUserServiceProviderApplication启动类配置</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableDubbo</span>    <span class="hljs-comment">//开启基于注解的dubbo功能</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootUserServiceProviderApplication</span> </span>&#123;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		SpringApplication.run(BootUserServiceProviderApplication.class, args);
	&#125;

&#125;</code></pre></div>
</li>
<li><p>启动注册中心，启动当前服务提供者，可以在浏览器看到一个服务提供者。</p>
</li>
</ul>
<h3 id="8-2-boot-order-service-consumer-服务消费者"><a href="#8-2-boot-order-service-consumer-服务消费者" class="headerlink" title="8.2 boot-order-service-consumer 服务消费者"></a>8.2 boot-order-service-consumer 服务消费者</h3><ul>
<li><p><strong>创建springboot项目 <code>boot-order-service-consumer</code></strong> 服务消费者</p>
</li>
<li><p>导入依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca.gmall<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmall_interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>把 <code>order-service-consumer</code> 中的 service 拿到此项目中。注意，以此方法为返回的需要更改 interface 包中的 void 为 List<UserAddress></UserAddress></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;

	<span class="hljs-comment">// @Autowired</span>
	<span class="hljs-meta">@Reference</span>
	UserService userService;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">initOrder</span><span class="hljs-params">(String userId)</span> </span>&#123;
		<span class="hljs-comment">// TODO Auto-generated method stub</span>
		System.out.println(<span class="hljs-string">&quot;用户id：&quot;</span> + userId);
		<span class="hljs-comment">//1、查询用户的收货地址</span>
		List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId);
		<span class="hljs-keyword">for</span> (UserAddress userAddress : addressList) &#123;
			System.out.println(userAddress);
		&#125;
		<span class="hljs-keyword">return</span> addressList;
	&#125;
&#125;
</code></pre></div>
</li>
<li><p>创建 OrderController 控制器</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;

	<span class="hljs-meta">@Autowired</span>
	OrderService orderService;

	<span class="hljs-meta">@ResponseBody</span>
	<span class="hljs-meta">@RequestMapping(&quot;/initOrder&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">initOrder</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;uid&quot;)</span> String userId)</span> </span>&#123;
		<span class="hljs-keyword">return</span> orderService.initOrder(userId);
	&#125;
&#125;</code></pre></div>
</li>
<li><p>配置 <code>application.properties</code></p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span>

<span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">boot_order_service_consumer</span>
<span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">zookeeper://127.0.0.1:2181</span>
<span class="hljs-meta">dubbo.registry.protocol</span>=<span class="hljs-string">zookeeper</span>

<span class="hljs-comment">#连接监控中心</span>
<span class="hljs-meta">dubbo.monitor.protocol</span>=<span class="hljs-string">registry</span></code></pre></div>
</li>
<li><p>BootOrderServiceConsumerApplication启动类配置</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableDubbo</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootOrderServiceConsumerApplication</span> </span>&#123;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		SpringApplication.run(BootOrderServiceConsumerApplication.class, args);
	&#125;

&#125;</code></pre></div>
</li>
<li><p>配置完毕，此时启动zookeeper注册中心及监控。<br>启动springboot配置的服务提供者和消费者<br>在浏览器输入 localhost:7001 查看结果</p>
</li>
</ul>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512215907361.png" alt="image-20210512215907361"></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512215927876.png" alt="image-20210512215927876"></p>
<p>duboo的springboot整合配置完成。</p>
<h2 id="9-Dubbo-配置"><a href="#9-Dubbo-配置" class="headerlink" title="9 Dubbo 配置"></a>9 Dubbo 配置</h2><p>dubbo配置官网参考：<a href="http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html">http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html</a></p>
<h3 id="9-1-配置原则"><a href="#9-1-配置原则" class="headerlink" title="9.1 配置原则"></a>9.1 配置原则</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612152343133.png" alt="在这里插入图片描述"></p>
<ul>
<li>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</li>
<li>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</li>
<li>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</li>
</ul>
<h3 id="9-2-启动时检查"><a href="#9-2-启动时检查" class="headerlink" title="9.2 启动时检查"></a>9.2 启动时检查</h3><ul>
<li>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=“true”。</li>
</ul>
<ul>
<li>可以通过 check=“false” 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</li>
</ul>
<ul>
<li><p>另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=“false”，总是会返回引用，当服务恢复时，能自动连上。</p>
</li>
<li><p>以<code>order-service-consumer</code>消费者为例，在consumer.xml中添加配置</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置当前消费者的统一规则,当前所有的服务都不启动时检查--&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:consumer</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:consumer</span>&gt;</span></code></pre></div>
</li>
<li><p>添加后，即使服务提供者不启动，启动当前的消费者，也不会出现错误。</p>
</li>
</ul>
<h3 id="9-3-全局超时配置"><a href="#9-3-全局超时配置" class="headerlink" title="9.3 全局超时配置"></a>9.3 全局超时配置</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--全局超时配置--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:provider</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span> /&gt;</span>

指定接口以及特定方法超时配置
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:provider</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.foo.BarService&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;2000&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sayHello&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;3000&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:provider</span>&gt;</span></code></pre></div>

<p><strong>配置原则</strong></p>
<p>dubbo推荐在Provider上尽量多配置Consumer端属性</p>
<div class="code-wrapper"><pre><code class="hljs plain">1、作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等
2、在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</code></pre></div>

<p>配置的覆盖规则：</p>
<ul>
<li><p>方法级配置别优于接口级别，即小Scope优先</p>
</li>
<li><p>Consumer端配置 优于 Provider配置 优于 全局配置，</p>
</li>
<li><p>最后是Dubbo Hard Code的配置值（见配置文档）</p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612160853853.png" alt="在这里插入图片描述"></p>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html">http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html</a><br>在服务提供者中复制多个impl。起不同的名字</p>
</li>
</ul>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612163440781.png" alt="在这里插入图片描述"></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612163456305.png" alt="在这里插入图片描述"></p>
<p>配置多个文件的路径及信息。<br>服务消费者调用时，可自由配置版本</p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612163603598.png" alt="在这里插入图片描述"></p>
<h3 id="9-4-dubbo与springboot整合的三种方式"><a href="#9-4-dubbo与springboot整合的三种方式" class="headerlink" title="9.4 dubbo与springboot整合的三种方式"></a>9.4 dubbo与springboot整合的三种方式</h3><ul>
<li><p>将服务提供者注册到注册中心(如何暴露服务)</p>
<ul>
<li>导入Dubbo的依赖 和 zookeeper 客户端</li>
</ul>
</li>
<li><p>让服务消费者去注册中心订阅服务提供者的服务地址<br>Springboot与Dubbo整合的三种方式</p>
<ol>
<li><p>导入dubbo-starter。在application.properties配置属性，使用@Service【暴露服务】，使用@Reference【引用服务】</p>
</li>
<li><p>保留Dubbo 相关的xml配置文件</p>
<p> 导入dubbo-starter，使用@ImportResource导入Dubbo的xml配置文件</p>
</li>
<li><p>使用 注解API的方式</p>
<p>将每一个组件手动配置到容器中,让dubbo来扫描其他的组件</p>
</li>
</ol>
</li>
</ul>
<h2 id="10-高可用"><a href="#10-高可用" class="headerlink" title="10 高可用"></a>10 高可用</h2><p>zookeeper宕机与dubbo直连<br>现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。<br>原因：</p>
<p>健壮性</p>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
<li>高可用：通过设计，减少系统不能提供服务的时间；</li>
</ul>
<h3 id="集群下dubbo负载均衡配置"><a href="#集群下dubbo负载均衡配置" class="headerlink" title="集群下dubbo负载均衡配置"></a>集群下dubbo负载均衡配置</h3><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>
<p><strong>负载均衡策略如下</strong></p>
<ul>
<li><p><strong>Random LoadBalance 基于权重的随机负载均衡机制</strong></p>
<p>随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
</li>
</ul>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612180908789.png" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>RoundRobin LoadBalance 基于权重的轮询负载均衡机制</strong></p>
<p>轮循，按公约后的权重设置轮循比率。 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612180928170.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<ul>
<li><p><strong>LeastActive LoadBalance最少活跃数负载均衡机制</strong></p>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612180951468.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<ul>
<li><p><strong>ConsistentHash LoadBalance一致性hash 负载均衡机制</strong></p>
<ul>
<li>一致性 Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a> </li>
<li>缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=”hash.arguments” value=”0,1” /&gt; 缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=”hash.nodes” value=”320” /&gt;</li>
</ul>
</li>
</ul>
<div class="code-wrapper"><pre><code>![在这里插入图片描述](Dubbo学习/20200612181007825.png)</code></pre></div><h2 id="11-整合-hystrix-，服务熔断与降级处理"><a href="#11-整合-hystrix-，服务熔断与降级处理" class="headerlink" title="11 整合 hystrix ，服务熔断与降级处理"></a>11 整合 hystrix ，服务熔断与降级处理</h2><h3 id="11-1-服务降级"><a href="#11-1-服务降级" class="headerlink" title="11.1 服务降级"></a>11.1 服务降级</h3><p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</strong><br>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。<br>向注册中心写入动态配置覆盖规则：</p>
<div class="code-wrapper"><pre><code class="hljs java">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="hljs-string">&quot;zookeeper://10.20.153.10:2181&quot;</span>));
registry.register(URL.valueOf(<span class="hljs-string">&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;</span>));</code></pre></div>

<p>其中：<br>mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时，对调用方的影响。<br>还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时，对调用方的影响。</p>
<h3 id="11-2-集群容错"><a href="#11-2-集群容错" class="headerlink" title="11.2 集群容错"></a>11.2 集群容错</h3><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<ul>
<li><p><strong>集群容错模式</strong></p>
<ul>
<li><p><strong>Failover Cluster</strong><br>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。</p>
<p>重试次数配置如下：<br>&lt;dubbo:service retries=“2” /&gt;<br>或<br>&lt;dubbo:reference retries=“2” /&gt;<br>或<br>dubbo:reference<br>&lt;dubbo:method name=“findFoo” retries=“2” /&gt;<br></p>
</li>
<li><p><strong>Failfast Cluster</strong><br>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
</li>
<li><p><strong>Failsafe Cluster</strong><br>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
</li>
<li><p><strong>Failback Cluster</strong><br>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
</li>
<li><p><strong>Forking Cluster</strong><br>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</p>
</li>
<li><p><strong>Broadcast Cluster</strong><br>广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
</li>
</ul>
</li>
<li><p><strong>集群模式配置</strong><br>按照以下示例在服务提供方和消费方配置集群模式<br>&lt;dubbo:service cluster=“failsafe” /&gt;<br>或<br>&lt;dubbo:reference cluster=“failsafe” /&gt;</p>
</li>
</ul>
<h3 id="11-3-整合hystrix"><a href="#11-3-整合hystrix" class="headerlink" title="11.3 整合hystrix"></a>11.3 整合hystrix</h3><p>服务熔断错处理配置参考=&gt; <a href="https://www.cnblogs.com/xc-xinxue/p/12459861.html">https://www.cnblogs.com/xc-xinxue/p/12459861.html</a></p>
<p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能</p>
<ul>
<li><p><strong>配置spring-cloud-starter-netflix-hystrix</strong></p>
</li>
<li><p>spring boot官方提供了对<strong>hystrix</strong>的集成，直接在pom.xml里加入依赖：</p>
<div class="code-wrapper"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>然后在Application类上增加<strong>@EnableHystrix</strong>来启用hystrix starter：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableHystrix</span> <span class="hljs-comment">//开启服务容错功能</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderApplication</span> </span>&#123;
	...启动方法
&#125;</code></pre></div>
</li>
<li><p><strong>配置Provider端</strong></p>
<p>在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>    <span class="hljs-comment">// dubbo暴露服务</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;


	<span class="hljs-meta">@HystrixCommand</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span> </span>&#123;
		<span class="hljs-comment">// TODO Auto-generated method stub</span>
		System.out.println(<span class="hljs-string">&quot;UserServiceImpl..3.....&quot;</span>);
		UserAddress address1 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;北京市昌平区宏福科技园综合楼3层&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;李老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>);
		UserAddress address2 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;深圳市宝安区西部硅谷大厦B座3层（深圳分校）&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;王老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>);

		<span class="hljs-keyword">if</span> (Math.random() &gt; <span class="hljs-number">0.5</span>) &#123;
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();
		&#125;
		<span class="hljs-keyword">return</span> Arrays.asList(address1, address2);
	&#125;

&#125;</code></pre></div>
</li>
<li><p><strong>配置Consumer端</strong><br>对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod = “reliable”的调用里。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Reference(version = &quot;1.0.0&quot;)</span>
    <span class="hljs-keyword">private</span> HelloService demoService;

    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;reliable&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doSayHello</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">return</span> demoService.sayHello(name);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reliable</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hystrix fallback value&quot;</span>;
    &#125;</code></pre></div>
</li>
<li><p>测试</p>
<ul>
<li><p>失败<img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210523011440767.png" alt="image-20210523011440767"></p>
</li>
<li><p>成功</p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210523011523532.png" alt="image-20210523011523532"></p>
</li>
</ul>
</li>
</ul>
<h2 id="12-RPC-和-netty-原理分析"><a href="#12-RPC-和-netty-原理分析" class="headerlink" title="12 RPC 和 netty 原理分析"></a>12 RPC 和 netty 原理分析</h2><h3 id="12-1-RPC-原理"><a href="#12-1-RPC-原理" class="headerlink" title="12.1 RPC 原理"></a>12.1 RPC 原理</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613170846919.png" alt="在这里插入图片描述"></p>
<p>一次完整的RPC调用流程（同步调用，异步另说）如下：</p>
<ol>
<li><strong>服务消费方（client）调用以本地调用方式调用服务；</strong></li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li>
<li>client stub找到服务地址，并将消息发送到服务端；</li>
<li>server stub收到消息后进行解码；</li>
<li>server stub根据解码结果调用本地的服务；</li>
<li>本地服务执行并将结果返回给server stub；</li>
<li>server stub将返回结果打包成消息并发送至消费方；</li>
<li>client stub接收到消息，并进行解码；</li>
<li><strong>服务消费方得到最终结果。</strong></li>
</ol>
<p>dubbo只用了两步1和8，中间的过程是透明的看不到的。RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p>
<h3 id="12-2-netty-通信原理"><a href="#12-2-netty-通信原理" class="headerlink" title="12.2 netty 通信原理"></a>12.2 netty 通信原理</h3><p>Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p>
<p><strong>BIO：(Blocking IO)</strong></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171108394.png" alt="在这里插入图片描述"></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171138127.png" alt="在这里插入图片描述"></p>
<p>Selector 一般称 为选择器 ，也可以翻译为 多路复用器，<br>Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）</p>
<p><strong>Netty基本原理：</strong><br>netty基本原理，可参考<a href="https://www.sohu.com/a/272879207_463994">https://www.sohu.com/a/272879207_463994</a></p>
<p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171217369.png" alt="在这里插入图片描述"></p>
<h2 id="12-3-dubbo-原理"><a href="#12-3-dubbo-原理" class="headerlink" title="12.3 dubbo 原理"></a>12.3 dubbo 原理</h2><h3 id="1-dubbo原理-框架设计"><a href="#1-dubbo原理-框架设计" class="headerlink" title="1. dubbo原理 - 框架设计"></a>1. dubbo原理 - 框架设计</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171327533.png" alt="在这里插入图片描述"></p>
<ul>
<li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>
<li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>
<li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>
<li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>
<li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>
<li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>
<li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>
<li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
</ul>
<h3 id="2-dubbo原理-启动解析、加载配置信息"><a href="#2-dubbo原理-启动解析、加载配置信息" class="headerlink" title="2.dubbo原理 - 启动解析、加载配置信息"></a>2.dubbo原理 - 启动解析、加载配置信息</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171545504.png" alt="在这里插入图片描述"></p>
<h3 id="3-dubbo原理-服务暴露"><a href="#3-dubbo原理-服务暴露" class="headerlink" title="3.dubbo原理 - 服务暴露"></a>3.dubbo原理 - 服务暴露</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171614614.png" alt="在这里插入图片描述"></p>
<h3 id="4-dubbo原理-服务引用"><a href="#4-dubbo原理-服务引用" class="headerlink" title="4.dubbo原理 - 服务引用"></a>4.dubbo原理 - 服务引用</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171741579.png" alt="在这里插入图片描述"></p>
<h3 id="5-dubbo原理-服务调用"><a href="#5-dubbo原理-服务调用" class="headerlink" title="5.dubbo原理 - 服务调用"></a>5.dubbo原理 - 服务调用</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171806762.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Technical</category>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 学习</title>
    <url>/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="ElasticSearch-学习"><a href="#ElasticSearch-学习" class="headerlink" title="ElasticSearch 学习"></a>ElasticSearch 学习</h1><h2 id="0-聊聊DougCutting"><a href="#0-聊聊DougCutting" class="headerlink" title="0 聊聊DougCutting"></a>0 聊聊DougCutting</h2><p>为什么要讲这个人,后面要聊大数据</p>
<blockquote>
<p>  本故事内容来自公众号：新枣课堂</p>
</blockquote>
<p>1998年9月4号,google公司在美国硅谷成立.正如大家所知,它是一家搜索引擎起家的公司</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610550313.png" alt></p>
<p>无独有偶,一位名叫DougCutting的美国工程师,也迷上了搜索引擎.他做了一个用于文本搜索的函数库(姑且理解为软件的功能组件),命名为Lucene.</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610568104.png" alt></p>
<p>Lucene使用Java写的,目标是为各种中小型应用软件加入全文检索功能.因为好用而且开源(代码公开),非常受程序员们稀罕)</p>
<p>在这个过程中,google确实找到了不少好的办法,并且无私地分享了出来.</p>
<p>开源是一种精神!</p>
<p>2003年,google发表了一篇技术学术论文,公开介绍了自己的谷歌文件系统GFS(google File System).这是google公司为了存储海量搜素数据而设计的专用文件系统</p>
<p>第二年,2004年,Doug Cutting基于google的GFS论文,实现了分布式文件存储系统,并将它命名为NDFS(Nutch Distributed File System)</p>
<p>还是2004年,google又发表了一篇技术学术论文,介绍自己的MapReduce编程模型.这个编程模型,用于大规模数据集(大于1TB)的并行分析运算.</p>
<p>2005年,Doug Cutting 又基于MapReduce,在Nutch搜索引擎实现了该功能.</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610581999.png" alt></p>
<p>2006年,当时依然很厉害的Yahoo(雅虎)公司,招安了Doug Cutting</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610607769.png" alt></p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610720399.png" alt></p>
<p>我们继续往下说.</p>
<p>还是2006年,google有发表论文了</p>
<p>这次,他们介绍自己的BigTable,这是一种分布式的数据存储系统,一种用来处理海量数据的非关系型数据库.</p>
<p>Doug Cutting 当然没有放过,在自己的hadoop系统里面,引入了BigTable,并命名为HBase.</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610829469.png" alt></p>
<p>好吧,反正就是紧跟Google时代步伐,你出什么,我学什么</p>
<p>所有,Hadoop的核心部分,基本上都有Google的影子.</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610891867.png" alt></p>
<p>2008年1月,Hadoop成功上位,成为Apache基金会的顶级项目.</p>
<p>同年2月,Yahoo宣布建成了一个拥有1W个内核的Hadoop集群,并将自己的搜索引擎产品部署在上面.</p>
<p>7月,Hadoop打破世界纪录,成为最快排序1TB数据的系统,用时209秒.</p>
<h2 id="1-什么是Elasticsearch？"><a href="#1-什么是Elasticsearch？" class="headerlink" title="1 什么是Elasticsearch？"></a>1 什么是Elasticsearch？</h2><h3 id="1-1-Lucene简介"><a href="#1-1-Lucene简介" class="headerlink" title="1.1 Lucene简介"></a>1.1 Lucene简介</h3><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/lucene_logo_green_300.png" alt="Lucene Logo"></p>
<ul>
<li>Lucene是一套用于<strong>全文检索</strong>和<strong>搜寻</strong>的<strong>开源</strong>程序库，由Apache软件基金会支持和提供</li>
<li>Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放源代码工具</li>
<li>Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品</li>
<li>Lucene是一套信息检索工具包! jar包!不包含搜索引擎系统!<ul>
<li>Lucene包含:索引结构!读写索引的工具!排序,搜索规则…工具类!等</li>
</ul>
</li>
<li><strong>Lucene和ElasticSearch关系</strong>:<ul>
<li>简单来说，ElasticSearch是基于Lucene做了一些<strong>封装</strong>和*<em>增强 *</em></li>
</ul>
</li>
</ul>
<h3 id="1-2-ElasticSearch简介"><a href="#1-2-ElasticSearch简介" class="headerlink" title="1.2 ElasticSearch简介"></a>1.2 ElasticSearch简介</h3><ul>
<li><p>ElasticSearch是一个<strong>实时分布式搜索和分析引擎</strong>。它让你以前所未有的速度处理大数据成为可能。</p>
</li>
<li><p>它用于<strong>全文搜索、结构化搜索、分析</strong>以及将这三者混合使用:</p>
<ul>
<li>维基百科使用Elasticsearch提供<strong>全文搜索并高亮关键字</strong> ,以及<strong>输入实时搜索(search-asyou-type)</strong>和<strong>搜索纠错(did-you-mean)</strong>等搜索建议功能。</li>
<li>英国卫报使用Elasticsearch结合用户日志和社交网络数据提供给他们的编辑以<strong>实时的反馈</strong>,以便及时了解公众对新发表的文章的回应。</li>
<li>StackOverflow结合<strong>全文搜索</strong>与<strong>地理位置查询</strong>,以及more-like-this功能来找到相关的问题和答案。</li>
<li>Github使用Elasticsearch检索<strong>1300亿</strong>行的代码。</li>
</ul>
</li>
<li><p>并且Elasticsearch不仅用于大型企业,它还让像DataDog以及Klout这样的创业公司将最初的想法变成可扩展的解决方案。</p>
</li>
<li><p>Elasticsearch可以在你的笔记本。上运行，也可以在数以百计的服务器上<strong>处理PB级别的数据</strong>。</p>
</li>
<li><p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。 无论在开源还是专有领域, Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p>
</li>
<li><p>但是, Lucene只是一个库。想要使用它,你必须使用Java来作为开发语言并将其直接集成到你的应用中,更糟糕的是, Lucene非常复杂,你需要深入了解检索的相关知识来理解它是如何工作的。</p>
</li>
<li><p>Elasticsearch也使用<strong>Java</strong>开发并使用Lucene作为其核心来实现所有索引和搜索的功能,它的目的是通过简单的<strong>RESTful API</strong>（REST风格的网络接口，是当下主流的API）来隐藏Lucene的复杂性,从而让全文搜索变得简单。</p>
</li>
</ul>
<h3 id="1-3-ElasticSearch的应用场景"><a href="#1-3-ElasticSearch的应用场景" class="headerlink" title="1.3 ElasticSearch的应用场景"></a>1.3 ElasticSearch的应用场景</h3><ul>
<li><p>维基百科,类似百度百科,<strong>全文检索</strong>,<strong>高亮</strong>,<strong>搜索推荐</strong></p>
</li>
<li><p>The Guardian (国外新闻网站) , 类似搜狐新闻,用户行为日志(点击,浏览,收藏,评论) +社交网络数据(对某某新闻的相关看法) ,数据分析,给到每篇新闻文章的作者,让他知道他的文章的公众反馈</p>
</li>
<li><p>Stack Overflow (国外的程序异常讨论论坛) , IT问题,程序的报错, 提交上去,有人会跟你讨论和回答,全文检索,搜索相关问题和答案,程序报错了,就会将报错信息粘贴到里面去,搜索有没有对应的答案</p>
</li>
<li><p>GitHub (开源代码管理)</p>
</li>
<li><p>电商网站,<strong>检索商品</strong>.</p>
</li>
<li><p>日志数据分析, logstash采集日志, ES进行复杂的数据分析, <strong>ELK技术, elasticsearch（搜索）+logstash（过滤）+kibana（可视化分析）</strong></p>
</li>
<li><p>商品价格监控网站,用户设定某商品的价格阈值,当低于该阈值的时候,发送通知消息给用户,比如说订阅牙膏的监控：如果高露洁牙膏的家庭套装低于50块钱,就通知我,我就去买</p>
</li>
<li><p>BI系统 ,商业智能, Business Intelligence.比如说有个大型商场集团, BI分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成,产出相关的数张报表, 最近3年,每年消费金额呈现100%的增长,而且用户群体85%是高级白领。</p>
</li>
<li><p>国内:<strong>站内搜索</strong>(电商，招聘，门户，等等)，<strong>IT系统搜索</strong>(OA,CRM,ERP，等等)，<strong>数据分析</strong>(ES热门的一个使用场景)</p>
</li>
</ul>
<p>总而言之，Elasticsearch就是提供<strong>高效</strong>、<strong>个性化检索</strong>需求的一种解决方案</p>
<h3 id="1-4-ELK简介"><a href="#1-4-ELK简介" class="headerlink" title="1.4 ELK简介"></a>1.4 ELK简介</h3><ul>
<li><p>ELK是<strong>Elasticsearch、Logstash、Kibana</strong>三大开源框架首字母大写简称。市面上也被成为Elastic Stack。</p>
<ul>
<li>其中ElasticSearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架,可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为es.</li>
<li>Logstash是ELK的<strong>中央数据流引擎</strong>,用于<strong>从不同目标</strong>(文件/数据存储/MQ )<strong>收集的不同格式数据</strong>,经过过滤后支持输出以到不同目的地(文件/MQ/redis/elasticsearch/kafka等)。</li>
<li>Kibana可以将es的<strong>数据</strong>通过友好的页面<strong>展示</strong>出来 ,提供实时分析的功能。</li>
</ul>
</li>
<li><p>总结一下就是：<strong>收集清洗数据–&gt;建立索引，储存–&gt;Kibana分析</strong></p>
</li>
<li><p>市面上很多开发只要提到ELK能够一致说出它是一 个日志分析架构技术栈总称,但实际上ELK不仅仅适用于日志分析,它还可以<strong>支持其它任何数据分析和收集的场景</strong>,日志分析和收集只是更具有代表性，并非唯一性。</p>
</li>
</ul>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105031.png" alt></p>
<h2 id="2-其他搜索引擎"><a href="#2-其他搜索引擎" class="headerlink" title="2 其他搜索引擎"></a>2 其他搜索引擎</h2><h3 id="2-1-Solr简介"><a href="#2-1-Solr简介" class="headerlink" title="2.1 Solr简介"></a>2.1 Solr简介</h3><ul>
<li><p>Solr是Apache下的一个顶级开源项目,采用java开发,它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言,同时实现了可配置、可扩展，并对索引、搜索性能进行了优化</p>
</li>
<li><p>Solr可以独立运行在Jetty、Tomcat等这些Servlet容器中 , Solr索引的实现方法很简单,用POST方法向Solr服务器发送一个描述Field及其内容的XML文档，Solr根据xml文档添加、删除、更新索引。</p>
</li>
<li><p>列如：搜索name==dayceng&lt;&gt;</p>
<ul>
<li>Solr 搜索只需要发送HTTP GET请求,然后对Solr返回xml、<strong>json</strong>等格式的查询结果进行解析,组织页面布局。Solr不提供构建UI的功能, Solr提供了一个管理界面,通过管理界面可以查询Solr的配置和运行情况。</li>
</ul>
</li>
<li><p>solr是基于lucene开发企业级搜索服务器,实际上就是封装了lucene.</p>
</li>
<li><p>Solr是一个独立的企业级搜索应用服务器,它对外提供类似于Web-service的API接口。用户可以通过http请求,向搜索引擎服务器提交一定格式的文件,生成索引;也可以通过提出查找请求,并得到返回结果。</p>
</li>
</ul>
<h3 id="2-2-ES与Solr对比"><a href="#2-2-ES与Solr对比" class="headerlink" title="2.2 ES与Solr对比"></a>2.2 ES与Solr对比</h3><ul>
<li><p>单纯地对已有的数据进行搜索，Solr更快</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105035.png" alt></p>
</li>
<li><p>当建立<strong>实时索引</strong>时，Solr会产生IO阻塞，查询性能较差，此时ES具有明显优势</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105045.png" alt></p>
</li>
<li><p>随着搜索量的增加，Solr的劣势愈发明显，ES无明显变化</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105121.png" alt></p>
</li>
<li><p><strong>总结</strong></p>
<ul>
<li>ES基本是开箱即用，非常简单。Solr安装略微复杂</li>
<li>Solr 利用Zookeeper进行分布式管理，而Elasticsearch 自身带有分布式协调管理功能。</li>
<li>Solr 支持更多格式的数据，比如JSON、XML、 CSV ，而Elasticsearch仅支持JSON文件格式。</li>
<li>Solr 官方提供的功能更多，而Elasticsearch本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要kibana友好支撑</li>
<li>Solr 查询快，但更新索引时慢(即插入删除慢) ，用于电商等查询多的应用;<ul>
<li>ES建立索引快(即查询慢) ，即<strong>实时性查询快</strong>，用于facebook新浪等搜索。</li>
<li>Solr是传统搜索应用的有力解决方案，但Elasticsearch 更适用于新兴的实时搜索应用。</li>
</ul>
</li>
<li>Solr比较成熟，有一个更大，更成熟的用户、开发和贡献者社区,而Elasticsearch相对开发维护者较少，更新太快,<strong>学习使用成本较高</strong></li>
</ul>
</li>
</ul>
<h2 id="3-Elasticsearch安装"><a href="#3-Elasticsearch安装" class="headerlink" title="3 Elasticsearch安装"></a>3 Elasticsearch安装</h2><p>注意：java版本至少为JDK1.8或以上</p>
<p>Java开发,elasticsearch的版本和我们之后对应的Java的核心jar包! 版本对应! JDK环境是正常的</p>
<p>这里一定要保证</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596614089583.png" alt></p>
<h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p>下载：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p>
<p>windows下解压即可使用</p>
<h3 id="3-2-Elasticsearch目录介绍"><a href="#3-2-Elasticsearch目录介绍" class="headerlink" title="3.2 Elasticsearch目录介绍"></a>3.2 Elasticsearch目录介绍</h3><ul>
<li>bin 相关启动文件</li>
<li>config 配置文件</li>
<li>log4j2.properties 日志配置文件</li>
<li>jvm.options java虚拟机配置文件</li>
<li>elasticsearch.yml ES配置文件（默认端口：9200，这里在tpot中，docker默认分配的是1111，需要再映射到9200才行）</li>
<li>lib 相关jar包</li>
<li>logs 日志</li>
<li>modules 功能模块</li>
<li>plugins 插件</li>
</ul>
<h3 id="3-3-启动"><a href="#3-3-启动" class="headerlink" title="3.3 启动"></a>3.3 启动</h3><p>双击bin下的<strong>elasticsearch.bat</strong>即可</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105122.png" alt></p>
<h3 id="3-4-测试访问"><a href="#3-4-测试访问" class="headerlink" title="3.4 测试访问"></a>3.4 测试访问</h3><p>访问其暴露的端口进行验证（<a href="http://127.0.0.1:9200/）">http://127.0.0.1:9200/）</a></p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105123.png" alt></p>
<h3 id="3-5-安装可视化界面Elasticsearch-head"><a href="#3-5-安装可视化界面Elasticsearch-head" class="headerlink" title="3.5 安装可视化界面Elasticsearch-head"></a>3.5 安装可视化界面Elasticsearch-head</h3><p>1、请下载Node.js（<a href="https://nodejs.org/en/），并检查npm为较新的版本">https://nodejs.org/en/），并检查npm为较新的版本</a></p>
<p>2、安装npm淘宝镜像源（cnpm）</p>
<blockquote>
<p>  npm install -g cnpm <em>–registry=<a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></em></p>
</blockquote>
<p> 查看是否安装成功</p>
<blockquote>
<p>  cnpm -v</p>
</blockquote>
<p> 出现以下信息即可</p>
<blockquote>
<p>  C:\Users\XXXX&gt; cnpm -v</p>
<p>  <a href="mailto:cnpm@5.1.1">cnpm@5.1.1</a> (F:\Live\NODE\node_global\node_modules\cnpm\lib\parse_argv.js)<br>  <a href="mailto:npm@5.6.0">npm@5.6.0</a> (F:\Live\NODE\node_global\node_modules\cnpm\node_modules\npm\lib\npm.js)<br>  <a href="mailto:node@8.9.1">node@8.9.1</a> (F:\Live\NODE\node.exe)<br>  <a href="mailto:npminstall@3.2.1">npminstall@3.2.1</a> (F:\Live\NODE\node_global\node_modules\cnpm\node_modules\npminstall\lib\index.js)<br>  prefix=F:\Live\NODE\node_global<br>  win32 x64 10.0.16299<br>  registry=<a href="http://registry.npm.taobao.org">http://registry.npm.taobao.org</a></p>
</blockquote>
<p><strong>在ElasticSearch\elasticsearch-head-master即ES head目录下</strong></p>
<p> <strong>下载依赖</strong></p>
<blockquote>
<p>  cnpm install</p>
</blockquote>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105124.png" alt="image-20210131091020099"></p>
<p> <strong>运行</strong></p>
<blockquote>
<p>  npm run start</p>
</blockquote>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20210609005919167.png" alt></p>
<p> <strong>访问<a href="http://localhost:9100/">http://localhost:9100/</a></strong></p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105126.png" alt="image-20210131091312021"></p>
<p> <strong>此时因为跨域访问（跨端口）导致集群无法连接，要通过配置elasticsearch.yml来解决</strong></p>
<h3 id="3-6-解决跨域问题"><a href="#3-6-解决跨域问题" class="headerlink" title="3.6 解决跨域问题"></a>3.6 解决跨域问题</h3><p>配置es，打开elasticsearch.yml文件，在最后一行加入（注意yalm语法，冒号后要加一个空格）</p>
<blockquote>
<p>  http.cors.enabled: true<br>  http.cors.allow-origin: “*”</p>
</blockquote>
<p>使用elasticsearch.bat重启es，连接成功</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105127.png" alt="image-20210131092227531"></p>
<p>注1：Linux下可能会因为进程问题启动失败</p>
<p><em>#查看elastic的进程号 并杀死</em></p>
<div class="code-wrapper"><pre><code class="hljs perl">ps aux | <span class="hljs-keyword">grep</span> elasticsearch 

<span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span> 进程号</code></pre></div>

<p><em>#重启 -d 后台运行</em></p>
<div class="code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>elasticsearch -d</code></pre></div>

<p>注2：Linux下eshead启动失败，提示9100端口占用</p>
<p><em>#查看占用端口的进程id</em></p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">lsof</span> -i:<span class="hljs-number">9100</span></code></pre></div>

<p><em>#杀死进行</em></p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> -<span class="hljs-number">9</span> <span class="hljs-number">4852</span></code></pre></div>

<h2 id="4-Kibana安装"><a href="#4-Kibana安装" class="headerlink" title="4 Kibana安装"></a>4 Kibana安装</h2><p>Kibana是一个针对Elasticsearch的开源分析及可视化平台 ，用来搜索、查看交互存储在Elasticsearch索引中的数据。 使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板( dashboard )实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。</p>
<p>官网：<a href="https://www.elastic.co/cn/kibana">https://www.elastic.co/cn/kibana</a></p>
<p>注意：<strong>使用的ES版本要与Kibana的对应</strong></p>
<p>下载完成解压，双击kibana.bat启动即可</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105128.png" alt="image-20210131103309389"></p>
<p><strong>汉化</strong></p>
<p>在Kibana目录下的config中修改Kibana.yml文件，最后一行加上</p>
<blockquote>
<p>  i18n.locale: “zh-CN”</p>
</blockquote>
<p>重启即可</p>
<h2 id="5-ES核心概念"><a href="#5-ES核心概念" class="headerlink" title="5 ES核心概念"></a>5 ES核心概念</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>Elasticsearch是面向文档的一种数据库，这意味着其不再需要行列式的表格字段约束。</p>
<p>ES会存储整个构造好的数据或文档，然而不仅仅是储存数据，这使得文档中每个数据可以被标识，进而可以被检索。在ES中，执行index，search，sort或过滤文档等操作都不是传统意义上的行列式的数据。</p>
<p>ES从根本上对数据的不同思考方式也正是他能应对复杂数据结构的全文检索的原因之一。</p>
<p><strong>关系型数据库与Elasticsearch的对比</strong></p>
<p>以下数据格式均为JSON</p>
<table>
<thead>
<tr>
<th>Relational DB</th>
<th>Elasticsearch</th>
</tr>
</thead>
<tbody><tr>
<td>数据库（database）</td>
<td>索引（index）</td>
</tr>
<tr>
<td>表（tables）</td>
<td>类型（types，新版本中逐步弃用）</td>
</tr>
<tr>
<td>行（rows）</td>
<td>文档（documents）</td>
</tr>
<tr>
<td>字段（columns）</td>
<td>字段（file）</td>
</tr>
</tbody></table>
<p>Elasticsearch(一般为集群)中可以包含多个索引（对应数据库) ，每个索引中可以包含多个类型(对应表) ，每个类型下又包含多个文档(对应行)，每个文档中又包含多个字段(对应列)。</p>
<p><strong>物理设计</strong>:<br>Elasticsearch在后台<strong>把每个索引划分成多个分片</strong>,每分分片可以在集群中的不同服务器间迁移（方便集群的搭建）</p>
<p>实际上只建立一个索引它自己也是一个集群，默认名称就是elasticsearch</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105129.png" alt="image-20210202093954072"></p>
<p><strong>逻辑设计:</strong><br>一个索引类型中，包含多个文档，如文档1 ,文档2。</p>
<p>当我们索引一篇文档时，可以通过这样的一个顺序找到它:</p>
<p> 索引–&gt;类型–&gt;文档ID</p>
<p>通过这个组合我们就能索引到某个具体的文档。</p>
<p>（注:ID不必是整数,实际上它是个字符串。）</p>
<h3 id="5-2-文档"><a href="#5-2-文档" class="headerlink" title="5.2 文档"></a>5.2 文档</h3><p>Elasticsearch是面向文档的,那么就意味着索引和搜索数据的<strong>最小单位是文档</strong>, Elasticsearch中,文档有几个重要属性:</p>
<ul>
<li><p>自我包含，一篇文档同时包含字段和对应的值,也就是同时包含key:value</p>
</li>
<li><p>可以是层次型的，一个文档中包含着文档，复杂的逻辑实体就是这么来的（即文档就是JSON格式的对象，可用fastjson进行自动转换自动）</p>
</li>
<li><p>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在Elasticsearch中，对于字段是非常灵活的，有时候我们可以忽略该字段，或者动态的添加一个新的字段。</p>
</li>
</ul>
<p>我们可以随意的新增或者忽略某个字段，但每个字段的类型非常重要。比如一个年龄字段类型，可以是字符串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型,这也是为什么在elasticsearch中，类型有时候也称为<strong>映射类型</strong></p>
<p>文档就是<strong>一条条打好标签的数据</strong></p>
<p><strong>举个例子：</strong></p>
<blockquote>
<p>  user</p>
<p>  1 xiaoming 22</p>
<p>  2 liming 19</p>
<p>  。。。</p>
</blockquote>
<p>这是一个表，名称为user，里面的每一行就是一个文档，文档中包含着序号、名字、年龄等信息（有点像之前要使用TFIDF算法时做的那个设备文档）</p>
<h3 id="5-3-类型"><a href="#5-3-类型" class="headerlink" title="5.3 类型"></a>5.3 类型</h3><p>类型是文档的<strong>逻辑容器</strong>，就像关系型数据库一样，表格是行的容器。</p>
<p>类型中对于字段的定义称为<strong>映射</strong>，比如name可以映射为字符串类型。</p>
<p>我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段。那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18 ,那么elasticsearch会认为它是整形。</p>
<p>但是elasticsearch也可能猜不对 ，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用</p>
<p>类比MySQL中，建立一个表的时候需要设定的数据类型</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105130.png" alt="image-20210202095941630"></p>
<h3 id="5-4-索引"><a href="#5-4-索引" class="headerlink" title="5.4 索引"></a>5.4 索引</h3><p>索引是<strong>映射类型的容器</strong>， elasticsearch中的索引是一个非常大的文档集合（即数据库）。索引存储了映射类型的字段和其他设置。 然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的。</p>
<p><strong>物理设计: 节点和分片如何工作</strong></p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105131.png" alt="image-20210202100254208"></p>
<p>存在数据库的数据可以通过不同的分片放在不同的集群上</p>
<p>一个集群至少有一个节点，而一个节点就是一个elasricsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片( primary shard ,又称<strong>主分片</strong>)构成，每一个主分片会有一个副本( replica shard ,又称<strong>复制分片</strong>)</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105132.png" alt="image-20210202100505894"></p>
<p>上图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内（比如主分片P0和主分片的复制分片P1分别在节点1/3，同样的分片Px在每个至少有一个），当某个节点挂掉了，数据也不至于丢失。</p>
<p>实际上，一个分片是一个Lucene索引，一个包含<strong>倒排索引</strong>的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。什么是倒排索引？</p>
<h3 id="5-5-倒排索引"><a href="#5-5-倒排索引" class="headerlink" title="5.5 倒排索引"></a>5.5 倒排索引</h3><p>elasticsearch使用的是一种称为倒排索引的结构 ,采用<strong>Lucene倒排索引</strong>作为底层。这种结构适用于快速的全文搜索，一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。</p>
<p>例如，现在有两个文档，每个文档包含如下内容:</p>
<blockquote>
<p>  study every day, good good up to forever #文档1包含的内容<br>  To forever, study every day， good good up #文档2包含的内容</p>
</blockquote>
<p>为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens) ，然后创建一个包含所有不重复的词条的排序列表，然后列出每个词条出现在哪个文档:（大小写要区分，重复单词也要加入）</p>
<table>
<thead>
<tr>
<th>term</th>
<th>doc_1</th>
<th>doc_2</th>
</tr>
</thead>
<tbody><tr>
<td>Study</td>
<td>〇</td>
<td>X</td>
</tr>
<tr>
<td>To</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>forever</td>
<td>〇</td>
<td>〇</td>
</tr>
<tr>
<td>every</td>
<td>〇</td>
<td>〇</td>
</tr>
<tr>
<td>study</td>
<td>X</td>
<td>〇</td>
</tr>
<tr>
<td>day</td>
<td>〇</td>
<td>〇</td>
</tr>
<tr>
<td>good</td>
<td>〇</td>
<td>〇</td>
</tr>
<tr>
<td>up</td>
<td>〇</td>
<td>〇</td>
</tr>
<tr>
<td>to</td>
<td>〇</td>
<td>X</td>
</tr>
<tr>
<td>every</td>
<td>〇</td>
<td>〇</td>
</tr>
</tbody></table>
<p>现在，我们试图搜索to forever，只需要查看每个词条在对应文档是否出现即可。这里to和forever在doc1里面都有，而doc2中to没有，所以搜索结果为：doc1的<strong>权重</strong>更大，即“to forever”更可能出现在doc1</p>
<table>
<thead>
<tr>
<th>term</th>
<th>doc_1</th>
<th>doc_2</th>
</tr>
</thead>
<tbody><tr>
<td>to</td>
<td>〇</td>
<td>X</td>
</tr>
<tr>
<td>forever</td>
<td>〇</td>
<td>〇</td>
</tr>
<tr>
<td>SUM</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>这里的“权重”，即为文档的<strong>score</strong>，es搜索完成会对分数进行自动统计</p>
<p>两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，这两个包含关键字的文档都将返回。</p>
<p><strong>再举一个例子</strong></p>
<p>再来看一个示例比如我们通过博客标签来搜索博客文章。 那么倒排索引列表就是这样的一个结构:</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105133.png" alt="image-20210202111236177"></p>
<p>如果要搜索含有python标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要查看标签这一栏,然后获取相关的文章ID即可。比如这里搜索“Linux”就绝对不会出现1或者2</p>
<p><strong>elasticsearch的索引和Lucene的索引对比</strong></p>
<p>在elasticsearch中，索引（数据库）这个词被频繁使用。在elasticsearch中 ，索引被分为多个分片，每份分片是一个Lucene的索引。<strong>所以一个elasticsearch索引是由多个Lucene倒排索引组成的</strong>。（因为elasticsearch使用Lucene作为底层）</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105134.png" alt="image-20210202112920334"></p>
<p>如无特指，说起<strong>索引都是指elasticsearch的索引</strong>。</p>
<h2 id="6-IK分词器"><a href="#6-IK分词器" class="headerlink" title="6 IK分词器"></a>6 IK分词器</h2><h3 id="6-1-什么是IK分词器"><a href="#6-1-什么是IK分词器" class="headerlink" title="6.1 什么是IK分词器?"></a>6.1 <strong>什么是IK分词器?</strong></h3><p> <strong>分词</strong>:即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，比如“我爱黎明”会被分为”我”,”爱”,”“黎”,”明” 。这显然是不符合要求的，所以我们需要安装中文分词器IK来解决这个问题。</p>
<p>IK提供了两个分词算法: ik. smart和ik_max_ word</p>
<p>其中ik_smart为最少切分， ik _max_word为最细粒度划分</p>
<h3 id="6-2-安装-IK分词器"><a href="#6-2-安装-IK分词器" class="headerlink" title="6.2 安装 IK分词器"></a>6.2 安装 IK分词器</h3><p><strong>1、下载</strong></p>
<blockquote>
<p>  <a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
</blockquote>
<p><strong>2、安装</strong></p>
<p>解压后放入es的插件目录plugins下即可</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105135.png" alt="image-20210202144827745"></p>
<p><strong>3、重启es加载插件</strong></p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105136.png" alt="image-20210202145019120"></p>
<p>可使用以下命令查看插件列表</p>
<blockquote>
<p>  elasticsearch-plugin list</p>
</blockquote>
<p><strong>4、启动Kibana测试</strong></p>
<p>测试ik_smart（使用RESTful风格的语句发起GET请求，对我们提供的JSON数据进行分词）</p>
<blockquote>
  <div class="code-wrapper"><pre><code class="hljs json">GET _analyze
&#123;
<span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span>,
<span class="hljs-attr">&quot;text&quot;</span>: [<span class="hljs-string">&quot;新型冠状病毒&quot;</span>]
&#125;</code></pre></div>
</blockquote>
<p>运行结果：</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105137.png" alt="image-20210202150329532"></p>
<p>测试ik _max _word</p>
<blockquote>
  <div class="code-wrapper"><pre><code class="hljs json">GET _analyze
&#123;
<span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,
<span class="hljs-attr">&quot;text&quot;</span>: [<span class="hljs-string">&quot;新型冠状病毒&quot;</span>]
&#125;</code></pre></div>
</blockquote>
<p>运行结果：最细粒度划分会把所有可能的组合都划分出来（划分方式由某个字典规定）</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105138.png" alt="image-20210202150645756"></p>
<p>问题：当遇到自造词时，拆分结果不是我们想要的</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105139.png" alt="image-20210202151449769"></p>
<p>这时需要把关键词加入字典</p>
<h3 id="6-3-配置IK分词器"><a href="#6-3-配置IK分词器" class="headerlink" title="6.3 配置IK分词器"></a>6.3 配置IK分词器</h3><p><strong>添加自定义字典</strong></p>
<blockquote>
<p>  在 elasticsearch-7.12.1\plugins\ik\config</p>
</blockquote>
<p>中可以找到配置文件<strong>IKAnalyzer.cfg.xml</strong></p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105140.png" alt="image-20210202152120411"></p>
<p>只需要在config目录下新建一个自己的.dic字典文件并录入IKAnalyzer.cfg.xml中然后<strong>重启es</strong>即可</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105141.png" alt="image-20210202152518579"></p>
<p>测试能够识别自定义词语</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105142.png" alt="image-20210202153349063"></p>
<h2 id="7-REST风格"><a href="#7-REST风格" class="headerlink" title="7 REST风格"></a>7 REST风格</h2><h3 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 <strong>概念</strong></h3><p>一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>即<strong>通过不同的命令实现不同的操作</strong></p>
<h3 id="7-2-基本REST命令"><a href="#7-2-基本REST命令" class="headerlink" title="7.2 基本REST命令"></a>7.2 基本REST命令</h3><table>
<thead>
<tr>
<th>method</th>
<th>url地址</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PUT</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>创建文档(指定文档id )</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200/索弓|名称/类型名称</td>
<td>创建文档(随机文档id )</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200/索引名称/类型名称/文档id/_ update</td>
<td>修改文档</td>
</tr>
<tr>
<td>DELETE</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>删除文档</td>
</tr>
<tr>
<td>GET</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>查询文档（通过文档id）</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200/索弓|名称/类型名称/_ search</td>
<td>查询所有数据</td>
</tr>
</tbody></table>
<h2 id="8-测试"><a href="#8-测试" class="headerlink" title="8 测试"></a>8 测试</h2><h3 id="8-1-关于索引的操作"><a href="#8-1-关于索引的操作" class="headerlink" title="8.1 关于索引的操作"></a>8.1 关于索引的操作</h3><h4 id="1、创建一个索引"><a href="#1、创建一个索引" class="headerlink" title="1、创建一个索引"></a><strong>1、创建一个索引</strong></h4><blockquote>
  <div class="code-wrapper"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/索引名/</span>类型名（新版本逐步废弃）/文档ID
&#123;
	请求体
&#125;</code></pre></div>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/test1/</span>type/<span class="hljs-number">1</span>
&#123;
  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,
  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">13</span>
&#125;</code></pre></div>

<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105143.png" alt="image-20210203092727349"></p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105144.png" alt="image-20210203110817742"></p>
<p><strong>注意：</strong></p>
<p> 1、创建的索引名要<strong>小写</strong></p>
<p> 2、es head中数据浏览不显示内容就换个浏览器试试</p>
<h4 id="2、更新一个索引"><a href="#2、更新一个索引" class="headerlink" title="2、更新一个索引"></a>2、更新一个索引</h4><p>修改索引依旧可以使用PUT，此时返回的版本号会增加，”result”会提示update，但如果漏了一些信息，原始信息就会丢失，故现在一般<strong>使用POST来更新索引</strong></p>
<div class="code-wrapper"><pre><code class="hljs awk">POST <span class="hljs-regexp">/test1/</span>type1/<span class="hljs-number">1</span>
&#123;
 <span class="hljs-string">&quot;doc&quot;</span>:&#123;
   <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>
 &#125;
&#125;</code></pre></div>

<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105145.png" alt="image-20210203115556670"></p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105146.png" alt="image-20210203115639183"></p>
<p>没有写age，它就会保持原样（如果用PUT的话age就直接没了）</p>
<h4 id="3、删除一个索引"><a href="#3、删除一个索引" class="headerlink" title="3、删除一个索引"></a>3、删除一个索引</h4><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">DELETE</span> test<span class="hljs-number">1</span>（索引名或文档记录ID）</code></pre></div>

<h4 id="4、指定类型"><a href="#4、指定类型" class="headerlink" title="4、指定类型"></a>4、指定类型</h4><p><strong>常用的字段类型有：</strong></p>
<p>●字符串类型<br>text、keyword<br>●数值类型<br>long,. integer, short, byte, double, float, half float, scaled float<br>●日期类型<br>date<br>●te布尔值类型<br>boolean<br>●二进制类型<br>binary.</p>
<p>创建一个t2索引（或者说索引库）但不创建文档，此时称其为一个“规则”</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105147.png" alt="image-20210203111936090"></p>
<p>查看t2，里面没有值，后续可以往里面放数据</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105148.png" alt="image-20210203112007717"></p>
<p>通过GET可以查看规则信息</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105149.png" alt="image-20210203112304214"></p>
<p>GET请求很好用，除了规则，还可以查看索引、文档的信息</p>
<p><strong>注：</strong></p>
<p>1、新版本es中正在逐步弃用type，我们创建索引库的时候可以将原来的type换成_doc，这样es就会自动帮我们配置字段类型</p>
<p>如下面的新建的test3：</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105150.png" alt="image-20210203113420834"></p>
<p>2、查看默认配置命令 GET _cat/indices?v</p>
<p>可以使用这个命令查看集群健康状态等一些信息</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105151.png" alt="image-20210203114043227"></p>
<h3 id="8-2-关于文档的操作"><a href="#8-2-关于文档的操作" class="headerlink" title="8.2 关于文档的操作"></a>8.2 关于文档的操作</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>1、添加数据</strong></p>
<div class="code-wrapper"><pre><code class="hljs json">PUT /dayceng/user/1
&#123;
  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;DAYceng&quot;</span>,
  <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-string">&quot;22&quot;</span>,
  <span class="hljs-attr">&quot;desc&quot;</span>: <span class="hljs-string">&quot;如此生活三十年&quot;</span>,
  <span class="hljs-attr">&quot;tags&quot;</span>: [<span class="hljs-string">&quot;穷&quot;</span>,<span class="hljs-string">&quot;阿宅&quot;</span>,<span class="hljs-string">&quot;脚本小子&quot;</span>]
&#125;</code></pre></div>

<p><strong>2、查询（获取，GET）数据</strong></p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105152.png" alt="image-20210205094004174"></p>
<p><strong>3、简单搜索</strong>(GET条件查询)</p>
<div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search?q=name:条件</code></pre></div>

<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105153.png" alt="image-20210205095050550"></p>
<p>简单的条件查询可根据默认的映射规则产生基本查询结果</p>
<p>（这里的”_score”代表匹配度，分值越高，匹配度越高）</p>
<p>说明：</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105154.png" alt="image-20210205095252732"></p>
<p>字段name，它的类型是keyword，此时进行搜索，分词器不会对类型为keyword的name进行分词（即如果你搜“丹”是不会返回“丹霞”的结果的），如果类型是text则可以查到</p>
<h4 id="复杂操作（主要是搜索）"><a href="#复杂操作（主要是搜索）" class="headerlink" title="复杂操作（主要是搜索）"></a><strong>复杂操作（主要是搜索）</strong></h4><p><strong>复杂搜索select（排序、分页、模糊/精准查询、高亮）</strong></p>
<h5 id="1、使用请求体查询"><a href="#1、使用请求体查询" class="headerlink" title="1、使用请求体查询"></a><strong>1、使用请求体查询</strong></h5><p>一般来说，我们进行搜索不是直接写条件搜索，而是需要构建一个JSON格式的请求体，这样可以设置更多参数以实现定制化的搜索</p>
<div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search
&#123;
  <span class="hljs-attr">&quot;query&quot;</span>: &#123;
    <span class="hljs-attr">&quot;match&quot;</span>: &#123;
      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>
    &#125;
  &#125;
&#125;</code></pre></div>

<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105155.png" alt="image-20210205105110638"></p>
<p>如果有相似关键字的多个结果，他们的分数会有不同</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105156.png" alt="image-20210205110206156"></p>
<p>hits是我们比较关注的一部分，其中包含：</p>
<p> 索引和文档的信息</p>
<p> 查询的结果总数</p>
<p> 查询出来的具体的文档</p>
<p> 分数：用来判断哪个结果更加符合预期</p>
<p>通过hits我们可以把数据的信息遍历出来，让我们想要的结果优先显示出来</p>
<p>后面使用java操控es，所有的方法和对象就是这里的hits、source等key</p>
<h5 id="2、请求体参数"><a href="#2、请求体参数" class="headerlink" title="2、请求体参数"></a>2、请求体参数</h5><p>我们通过在请求体后添加参数的方式实现一些自定义的操作</p>
<h6 id="筛选结果"><a href="#筛选结果" class="headerlink" title="筛选结果"></a><strong>筛选结果</strong></h6><p>只返回特定结果</p>
<div class="code-wrapper"><pre><code class="hljs awk">GET <span class="hljs-regexp">/dayceng/u</span>ser/_search
&#123;
  <span class="hljs-string">&quot;query&quot;</span>: &#123;
    <span class="hljs-string">&quot;match&quot;</span>: &#123;
      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>
    &#125;
  &#125;,
   <span class="hljs-string">&quot;_source&quot;</span>:[<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;tags&quot;</span>]
&#125;</code></pre></div>

<p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105157.png" alt="image-20210205114109589"></p>
<h6 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h6><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search
&#123;
  <span class="hljs-attr">&quot;query&quot;</span>: &#123;
    <span class="hljs-attr">&quot;match&quot;</span>: &#123;
      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>
    &#125;
  &#125;,
  <span class="hljs-attr">&quot;sort&quot;</span>: [
    &#123;
      <span class="hljs-attr">&quot;age&quot;</span>: &#123;
        <span class="hljs-attr">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span>
      &#125;
    &#125;
  ]
&#125;</code></pre></div>

<p>注意：排序只能用于数值类型，我这里的age是text类型，运行就会报错</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105158.png" alt="image-20210205115918067"></p>
<blockquote>
<p>  “Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata=true on [age] in order to load field data by uninverting the inverted index. Note that this can use significant memory.”</p>
</blockquote>
<p>把“age”换成“age.keyword”即可正常排序</p>
<p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105159.png" alt="image-20210205120324780"></p>
<h6 id="分页"><a href="#分页" class="headerlink" title="分页"></a><strong>分页</strong></h6><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search
&#123;
  <span class="hljs-attr">&quot;query&quot;</span>: &#123;
    <span class="hljs-attr">&quot;match&quot;</span>: &#123;
      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞在&quot;</span>
    &#125;
  &#125;,
  <span class="hljs-attr">&quot;sort&quot;</span>: [
    &#123;
      <span class="hljs-attr">&quot;age.keyword&quot;</span>: &#123;
        <span class="hljs-attr">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span>
      &#125;
    &#125;
  ],
   &quot;from&quot;: 0,---从第几个数据开始
   &quot;size&quot;: 2 ---返回几个数据

&#125;</code></pre></div>

<p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105200.png" alt="image-20210206093248369"></p>
<h6 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a><strong>过滤</strong></h6><p>使用filter参数即可</p>
<p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105201.png" alt="image-20210206094548128"></p>
<p> gt：大于</p>
<p> gte：大于等于</p>
<p> lt：小于</p>
<p> lte：小于等于</p>
<p> （以上条件可混合使用）</p>
<h5 id="3、布尔值查询"><a href="#3、布尔值查询" class="headerlink" title="3、布尔值查询"></a>3、布尔值查询</h5><p>使用布尔值可进行多条件查询</p>
<p><strong>must</strong>：设置的所有match都要匹配才会返回结果</p>
<p><strong>must not</strong>：返回与设置条件相反的结果</p>
<p><strong>should</strong>：满足条件之一即可返回结果</p>
<div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search
&#123;
  <span class="hljs-attr">&quot;query&quot;</span>: &#123;
    <span class="hljs-attr">&quot;bool&quot;</span>: &#123;
      <span class="hljs-attr">&quot;must&quot;</span>: [
        &#123;
          <span class="hljs-attr">&quot;match&quot;</span>: &#123;
            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;DAYceng&quot;</span>
          &#125;
        &#125;,
        &#123;
          <span class="hljs-attr">&quot;match&quot;</span>: &#123;
            <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">22</span>
          &#125;
        &#125;
      ]
    &#125;
  &#125;

&#125;</code></pre></div>

<p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105202.png" alt="image-20210206093144473"></p>
<h5 id="4、精确查询"><a href="#4、精确查询" class="headerlink" title="4、精确查询"></a>4、精确查询</h5><p>term查询是直接使用倒排索引进行精确查询的</p>
<p><strong>term与match的比较</strong></p>
<p> ·term使用倒排索引直接进行精确查询</p>
<p> ·match则会使用分词器进行解析后再查询（先分析文档，在通过分析结果进行查询）</p>
<p><strong>类型text与keyword的比较</strong></p>
<p>text会使用分词器进行分词后再查询</p>
<p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105203.png" alt="image-20210206102310427"></p>
<p>keyword不会拆分特定词语</p>
<p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105204.png" alt="image-20210206102247047"></p>
<h5 id="5、高亮查询"><a href="#5、高亮查询" class="headerlink" title="5、高亮查询"></a>5、高亮查询</h5><p>使用highlight参数</p>
<div class="code-wrapper"><pre><code class="hljs awk">GET <span class="hljs-regexp">/dayceng/u</span>ser/_search
&#123;
  <span class="hljs-string">&quot;query&quot;</span>: &#123;
    <span class="hljs-string">&quot;match&quot;</span>: &#123;
      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>
    &#125;
  &#125;,
  <span class="hljs-string">&quot;highlight&quot;</span>: &#123;
    <span class="hljs-string">&quot;fields&quot;</span>: &#123;
      <span class="hljs-string">&quot;name&quot;</span>:&#123;&#125;
    &#125;
  &#125;
&#125;</code></pre></div>

<p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105205.png" alt="image-20210206104615060"></p>
<p>在highlight中也可以自定义高亮标签</p>
<div class="code-wrapper"><pre><code class="hljs awk">GET <span class="hljs-regexp">/dayceng/u</span>ser/_search
&#123;
  <span class="hljs-string">&quot;query&quot;</span>: &#123;
    <span class="hljs-string">&quot;match&quot;</span>: &#123;
      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>
    &#125;
  &#125;,
  <span class="hljs-string">&quot;highlight&quot;</span>: &#123;
    <span class="hljs-string">&quot;pre_tags&quot;</span>: <span class="hljs-string">&quot;&lt;p class=key style=&#x27;color:red&#x27;&gt;&quot;</span>, 
    <span class="hljs-string">&quot;post_tags&quot;</span>: <span class="hljs-string">&quot;&lt;/p&gt;&quot;</span>, 
    <span class="hljs-string">&quot;fields&quot;</span>: &#123;
      <span class="hljs-string">&quot;name&quot;</span>:&#123;&#125;
    &#125;
  &#125;
&#125;</code></pre></div>

<p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105206.png" alt="image-20210206105030939"></p>
<h2 id="9-Python-elasticsearch基本用法"><a href="#9-Python-elasticsearch基本用法" class="headerlink" title="9 Python-elasticsearch基本用法"></a>9 Python-elasticsearch基本用法</h2><p>官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html#_getting_a_document">https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html#_getting_a_document</a></p>
<h3 id="9-1-安装及初始化"><a href="#9-1-安装及初始化" class="headerlink" title="9.1 安装及初始化"></a>9.1 安装及初始化</h3><p>使用pip安装即可</p>
<div class="code-wrapper"><pre><code class="hljs shell">pip install elasticsearch
pip install elasticsearch[async]	#支持异步，可不安装</code></pre></div>

<h3 id="9-2-实例化es客户端"><a href="#9-2-实例化es客户端" class="headerlink" title="9.2 实例化es客户端"></a>9.2 <strong>实例化es客户端</strong></h3><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105207.png" alt="image-20210219115247238"></p>
<p>实际上这里文档中给了三种创建客户端的方式，我们选择HTTP authentication方式（看起来清晰一些，当然你也可以用别的）实例化es对象</p>
<div class="code-wrapper"><pre><code class="hljs python">es = Elasticsearch(
    [
        &#123;<span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">9200</span>&#125;,
    ],
    http_auth=(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;secret&quot;</span>),
    timeout=<span class="hljs-number">3600</span>
)</code></pre></div>

<p>ES提供了两种搜索的方式：　　</p>
<p>　 请求参数方式</p>
<p>　 请求体方式（带body 的那种查询，把查询的内容放入body中，会造成一定的开销，但是易于理解）</p>
<p>这里我们使用请求体方式进行搜索</p>
<p>配置一个body</p>
<div class="code-wrapper"><pre><code class="hljs python">body = &#123;
    <span class="hljs-string">&quot;settings&quot;</span>: &#123;
        <span class="hljs-string">&quot;number_of_shards&quot;</span>: <span class="hljs-number">3</span>,
        <span class="hljs-string">&quot;number_of_replicas&quot;</span>: <span class="hljs-number">2</span>
    &#125;,
    <span class="hljs-string">&quot;mappings&quot;</span>:&#123;
        <span class="hljs-comment"># &quot;_doc&quot;:&#123;</span>
        <span class="hljs-string">&quot;properties&quot;</span>:&#123;
            <span class="hljs-string">&quot;id&quot;</span>:&#123;
                <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;integer&quot;</span>,
            &#125;,
            <span class="hljs-string">&quot;text&quot;</span>: &#123;
                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,
                <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,  <span class="hljs-comment">#指定ik分词器，适用中文分词。</span>
                <span class="hljs-string">&quot;index&quot;</span>:<span class="hljs-literal">False</span>
            &#125;,
            <span class="hljs-string">&quot;userId&quot;</span>: &#123;
                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span>,
            &#125;,
            <span class="hljs-string">&quot;reprinted&quot;</span>: &#123;
                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,
            &#125;,
        &#125;</code></pre></div>

<p>注：可以看到，body中实际上就是之前我们使用请求体参数搜索时设置的一些东西</p>
<h3 id="9-3-单一操作"><a href="#9-3-单一操作" class="headerlink" title="9.3 单一操作"></a>9.3 单一操作</h3><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p><strong>create</strong></p>
<p>必须指定待查询的idnex、type、id和查询体body；缺一不可，否则报错</p>
<div class="code-wrapper"><pre><code class="hljs python">es.indices.create(index = <span class="hljs-string">&quot;testpy&quot;</span>, body = body)</code></pre></div>

<p><strong>index</strong>　</p>
<p>相比于create，index的用法就相对灵活很多；id并非是一个必选项，如果指定，则该文档的id就是指定值，若不指定，则系统会自动生成一个全局唯一的id赋给该文档。</p>
<div class="code-wrapper"><pre><code class="hljs python">es.index(index = <span class="hljs-string">&quot;testpy&quot;</span>, doc_type = <span class="hljs-string">&quot;_doc&quot;</span>, <span class="hljs-built_in">id</span> = <span class="hljs-number">1</span>, body = &#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;小明&quot;</span>&#125;)</code></pre></div>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>　　delete：删除指定index、type、id的文档</p>
<div class="code-wrapper"><pre><code class="hljs python">es.indices.delete(index = <span class="hljs-string">&#x27;test&#x27;</span>)</code></pre></div>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>　　get：获取指定index、type、id所对应的文档</p>
<div class="code-wrapper"><pre><code class="hljs python">es.get(index=<span class="hljs-string">&quot;testpy&quot;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>)</code></pre></div>

<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>　　update：跟新指定index、type、id所对应的文档</p>
<div class="code-wrapper"><pre><code class="hljs python">es.update(index=<span class="hljs-string">&#x27;testpy&#x27;</span>, doc_type=<span class="hljs-string">&#x27;_doc&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;2&#x27;</span>, body=&#123;待更新字段&#125;)</code></pre></div>

<h3 id="9-4-批量操作"><a href="#9-4-批量操作" class="headerlink" title="9.4 批量操作"></a>9.4 批量操作</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>search：查询满足条件的所有文档，没有id属性，且index，type和body均可为None。 body的语法格式必须符合DSL格式</p>
<div class="code-wrapper"><pre><code class="hljs python">es.search(index = <span class="hljs-string">&quot;test&quot;</span>, doc_type = <span class="hljs-string">&quot;_doc&quot;</span>, body = query)</code></pre></div>

<p>复合查询语句</p>
<div class="code-wrapper"><pre><code class="hljs python">query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;match_all&#x27;</span>: &#123;&#125;&#125;&#125;<span class="hljs-comment"># 查找所有文档</span>
query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;term&#x27;</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;jack&#x27;</span>&#125;&#125;&#125;<span class="hljs-comment"># 查找名字叫做jack的所有文档</span>
query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;range&#x27;</span>: &#123;<span class="hljs-string">&#x27;age&#x27;</span>: &#123;<span class="hljs-string">&#x27;gt&#x27;</span>: <span class="hljs-number">11</span>&#125;&#125;&#125;&#125;<span class="hljs-comment"># 查找年龄大于11的所有文档</span>
allDoc = es.search(index=<span class="hljs-string">&#x27;indexName&#x27;</span>, doc_type=<span class="hljs-string">&#x27;typeName&#x27;</span>, body=query)</code></pre></div>

<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>delete_by_query</p>
<div class="code-wrapper"><pre><code class="hljs python">query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;match&#x27;</span>: &#123;<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;famale&#x27;</span>&#125;&#125;&#125;<span class="hljs-comment"># 删除性别为女性的所有文档</span>
query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;range&#x27;</span>: &#123;<span class="hljs-string">&#x27;age&#x27;</span>: &#123;<span class="hljs-string">&#x27;lt&#x27;</span>: <span class="hljs-number">11</span>&#125;&#125;&#125;&#125;<span class="hljs-comment"># 删除年龄小于11的所有文档</span>
es.delete_by_query(index=<span class="hljs-string">&#x27;indexName&#x27;</span>, body=query, doc_type=<span class="hljs-string">&#x27;typeName&#x27;</span>)</code></pre></div>

<h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><p>update_by_query</p>
<div class="code-wrapper"><pre><code class="hljs python">query = &#123;
            <span class="hljs-string">&quot;script&quot;</span>: &#123;
            <span class="hljs-string">&quot;lang&quot;</span>: <span class="hljs-string">&quot;painless&quot;</span>,
            <span class="hljs-comment"># &quot;inline&quot;: &quot;if (ctx._source.test_code == null) &#123;ctx._source.test_code= &#x27;02&#x27;&#125;&quot;</span>
            <span class="hljs-string">&quot;inline&quot;</span>: <span class="hljs-string">&quot;ctx._source.kw_sourceType= &#x27;trueTime&#x27;&quot;</span>   <span class="hljs-comment">#新增字段kw_sourceType值为trueTime</span>
              &#125;
            &#125;
res = es.update_by_query(index=<span class="hljs-string">&quot;hot_rank&quot;</span>, doc_type=<span class="hljs-string">&quot;baidu_hot_search_rank&quot;</span>, body=query)</code></pre></div>

<h3 id="9-5-完整测试工程代码"><a href="#9-5-完整测试工程代码" class="headerlink" title="9.5 完整测试工程代码"></a>9.5 完整测试工程代码</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> elasticsearch <span class="hljs-keyword">import</span> Elasticsearch
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-comment">#from elasticsearch import AsyncElasticsearch</span>

<span class="hljs-comment">#es = Elasticsearch(host=&quot;localhost&quot;, port=9200)</span>

es = Elasticsearch(
    [
        &#123;<span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">9200</span>&#125;,
    ],
    http_auth=(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;secret&quot;</span>),
    timeout=<span class="hljs-number">3600</span>
)
body = &#123;
    <span class="hljs-string">&quot;settings&quot;</span>: &#123;
        <span class="hljs-string">&quot;number_of_shards&quot;</span>: <span class="hljs-number">3</span>,
        <span class="hljs-string">&quot;number_of_replicas&quot;</span>: <span class="hljs-number">2</span>
    &#125;,
    <span class="hljs-string">&quot;mappings&quot;</span>:&#123;
        <span class="hljs-comment"># &quot;_doc&quot;:&#123;</span>
        <span class="hljs-string">&quot;properties&quot;</span>:&#123;
            <span class="hljs-string">&quot;id&quot;</span>:&#123;
                <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;integer&quot;</span>,
            &#125;,
            <span class="hljs-string">&quot;text&quot;</span>: &#123;
                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,
                <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,  <span class="hljs-comment">#指定ik分词器，适用中文分词。</span>
                <span class="hljs-string">&quot;index&quot;</span>:<span class="hljs-literal">False</span>
            &#125;,
            <span class="hljs-string">&quot;userId&quot;</span>: &#123;
                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span>,
            &#125;,
            <span class="hljs-string">&quot;reprinted&quot;</span>: &#123;
                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,
            &#125;,
        &#125;
        <span class="hljs-comment"># &#125;</span>
    &#125;
&#125;
<span class="hljs-comment">#创建 index</span>
<span class="hljs-comment">#es.indices.create(index = &quot;testpy&quot;, body = body)</span>
<span class="hljs-comment">#删除 index</span>
<span class="hljs-comment">#es.indices.delete(index = &#x27;test&#x27;)</span>

<span class="hljs-comment">#插入数据</span>
<span class="hljs-comment">#es.index(index = &quot;testpy&quot;, doc_type = &quot;_doc&quot;, id = 1, body = &#123;&quot;id&quot;:1, &quot;name&quot;:&quot;小明&quot;&#125;)</span>
<span class="hljs-comment">#可以不用指定id，create会自动添加id。</span>
<span class="hljs-comment">#es.create(index=&quot;testpy&quot;, doc_type = &quot;_doc&quot;,id = 2, body = &#123;&quot;id&quot;:2, &quot;name&quot;:&quot;小红&quot;&#125;)</span>

<span class="hljs-string">&#x27;&#x27;&#x27;doc = &#123;</span>
<span class="hljs-string">    &#x27;author&#x27;: &#x27;author_name&#x27;,</span>
<span class="hljs-string">    &#x27;text&#x27;: &#x27;Interensting content...&#x27;,</span>
<span class="hljs-string">    &#x27;timestamp&#x27;: datetime.now(),</span>
<span class="hljs-string">&#125;&#x27;&#x27;&#x27;</span>

res = es.get(index=<span class="hljs-string">&quot;testpy&quot;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>)
<span class="hljs-comment">#es.search(index = &quot;test&quot;, doc_type = &quot;_doc&quot;, body = query)</span>
<span class="hljs-built_in">print</span>(res[<span class="hljs-string">&#x27;_source&#x27;</span>])</code></pre></div>

]]></content>
      <categories>
        <category>Technical</category>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 学习</title>
    <url>/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Kafka-学习"><a href="#Kafka-学习" class="headerlink" title="Kafka 学习"></a>Kafka 学习</h1><h2 id="1-Kafka-入门"><a href="#1-Kafka-入门" class="headerlink" title="1 Kafka 入门"></a>1 Kafka 入门</h2><h3 id="1-1-文档"><a href="#1-1-文档" class="headerlink" title="1.1 文档"></a>1.1 文档</h3><ul>
<li><p><a href="http://kafka.apache.org/">Kafka官网主页</a></p>
</li>
<li><p><a href="http://kafka.apache.org/documentation/">Kafka官方文档</a></p>
</li>
</ul>
<h3 id="1-2-什么是-Kafka"><a href="#1-2-什么是-Kafka" class="headerlink" title="1.2 什么是 Kafka"></a>1.2 什么是 Kafka</h3><p>Kafka 是一个<strong>分布式</strong>的基于<strong>发布/订阅模式</strong>的<strong>消息队列</strong>（Message Queue），主要应用于大数据实时处理领域。</p>
<h3 id="1-3-消息队列"><a href="#1-3-消息队列" class="headerlink" title="1.3 消息队列"></a>1.3 消息队列</h3><h4 id="传统消息队列的应用场景"><a href="#传统消息队列的应用场景" class="headerlink" title="传统消息队列的应用场景"></a>传统消息队列的应用场景</h4><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/01.png" alt></p>
<h4 id="使用消息队列的好处"><a href="#使用消息队列的好处" class="headerlink" title="使用消息队列的好处"></a>使用消息队列的好处</h4><ol>
<li><p>解耦（类似Spring的IOC）</p>
<p>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p>
</li>
<li><p>可恢复性</p>
<p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p>
</li>
<li><p>缓冲</p>
<p>有助于控制和优化数据流经过系统的速度， 解决生产消息和消费消息的处理速度不一致的情况。</p>
</li>
<li><p>灵活性 &amp; 峰值处理能力（削峰）</p>
<p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p>
</li>
<li><p>异步通信</p>
<p>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p>
</li>
</ol>
<h3 id="1-4-消费模式"><a href="#1-4-消费模式" class="headerlink" title="1.4 消费模式"></a>1.4 消费模式</h3><p>消息队列的两种模式</p>
<h4 id="1-4-1-点对点模式"><a href="#1-4-1-点对点模式" class="headerlink" title="1.4.1 点对点模式"></a>1.4.1 点对点模式</h4><p><strong>一对一，消费者主动拉取数据，消息收到后消息清除</strong></p>
<p>消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费以后， queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/02.png" alt></p>
<h4 id="1-4-2-发布-订阅模式"><a href="#1-4-2-发布-订阅模式" class="headerlink" title="1.4.2 发布/订阅模式"></a>1.4.2 发布/订阅模式</h4><p><strong>一对多，消费者消费数据之后不会清除消息</strong></p>
<p>消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。</p>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/03.png" alt></p>
<h3 id="1-5-基础架构"><a href="#1-5-基础架构" class="headerlink" title="1.5 基础架构"></a>1.5 基础架构</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/04.png" alt></p>
<ol>
<li><strong>Producer</strong> ： 消息生产者，就是向 Kafka ；</li>
<li><strong>Consumer</strong> ： 消息消费者，向 Kafka broker 取消息的客户端；</li>
<li><strong>Consumer Group （CG）</strong>： 消费者组，由多个 consumer 组成。 消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。 所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li>
<li><strong>Broker</strong> ：经纪人 一台 Kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker可以容纳多个 topic。</li>
<li><strong>Topic</strong> ： 话题，可以理解为一个队列， 生产者和消费者面向的都是一个 topic；</li>
<li><strong>Partition</strong>： 为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；</li>
<li><strong>Replica</strong>： 副本（Replication），为保证集群中的某个节点发生故障时， 该节点上的 partition 数据不丢失，且 Kafka仍然能够继续工作， Kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。</li>
<li><strong>Leader</strong>： 每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 leader。</li>
<li><strong>Follower</strong>： 每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据的同步。 leader 发生故障时，某个 Follower 会成为新的 leader。</li>
</ol>
<blockquote>
<p>  replica 英 [ˈreplɪkə] 美 [ˈreplɪkə] n.复制品;仿制品</p>
</blockquote>
<blockquote>
<p>  topic 英 [ˈtɒpɪk] 美 [ˈtɑːpɪk] n.话题;题目;标题</p>
</blockquote>
<h3 id="1-6-安装-amp-启动-amp-关闭"><a href="#1-6-安装-amp-启动-amp-关闭" class="headerlink" title="1.6 安装&amp;启动&amp;关闭"></a>1.6 安装&amp;启动&amp;关闭</h3><h4 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h4><p>本次安装学习在Windows操作系统进行。（Linux版本的差别不大，运行脚本文件后缀从<code>bat</code>改为<code>sh</code>，配置路径改用Unix风格的）</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23quickstart">本节教程来源</a></p>
<h4 id="Step-1-Download-the-code"><a href="#Step-1-Download-the-code" class="headerlink" title="Step 1: Download the code"></a>Step 1: Download the code</h4><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2Fdownloads">下载代码</a>并解压</p>
<p>下载<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farchive.apache.org%2Fdist%2Fkafka%2F0.11.0.0%2Fkafka_2.11-0.11.0.0.tgz">kafka 0.11.0.0</a>版本，解压到<code>C:\Kafka\</code>路径下，Kafka主目录文件为<code>C:\Kafka\kafka_2.11-0.11.0.0</code>（下文用KAFKA_HOME表示）。</p>
<h4 id="Step-2-Start-the-server"><a href="#Step-2-Start-the-server" class="headerlink" title="Step 2: Start the server"></a>Step 2: Start the server</h4><p>Kafka 用到 ZooKeeper 功能，所以要预先运行ZooKeeper。了解更多ZooKeeper信息，可点击阅读<a href="https://my.oschina.net/jallenkwong/blog/4405741">ZooKeeper学习笔记</a>。</p>
<ul>
<li>首先，修改<code>%KAFKA_HOME%\conf\zookeeper.properties</code>中的<code>dataDir=/tmp/zookeeper</code>，改为<code>dataDir=C:\\Kafka\\data\\zookeeper</code>。</li>
<li>创建新目录<code>C:\\Kafka\\data\\zookeeper</code>。</li>
<li>启动cmd，工作目录切换到<code>%KAFKA_HOME%</code>，执行命令行：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">start</span> bin\windows\zookeeper-server-<span class="hljs-built_in">start</span>.bat config\zookeeper.properties</code></pre></div>

<ul>
<li>修改<code>%KAFKA_HOME%\conf\server.properties</code>中的<code>log.dirs=/tmp/kafka-logs</code>，改为<code>log.dirs=C:\\Kafka\\data\\kafka-logs</code>。</li>
<li>创建新目录<code>C:\\Kafka\\data\\kafka-logs</code>。</li>
<li>另启动cmd，工作目录切换到<code>%KAFKA_HOME%</code>，执行命令行：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">start</span> bin\windows\kafka-server-<span class="hljs-built_in">start</span>.bat config\server.properties</code></pre></div>

<ul>
<li><p>可写一脚本，一键启动</p>
</li>
<li><p>关闭服务，<code>bin\windows\kafka-server-stop.bat</code>和<code>bin\windows\zookeeper-server-stop.bat</code></p>
</li>
</ul>
<p>TODO:<strong>一个问题</strong>，通过<code>kafka-server-stop.bat</code>或右上角关闭按钮来关闭Kafka服务后，马上下次再启动Kafka，抛出异常，说某文件被占用，需清空<code>log.dirs</code>目录下文件，才能重启Kafka。</p>
<div class="code-wrapper"><pre><code class="hljs shell">[2020-07-21 21:43:26,755] ERROR There was an error in one of the threads during logs loading: java.nio.file.FileSystemException: C:\Kafka\data\kafka-logs-0\my-replicated-topic-0\00000000000000000000.timeindex: 另一个程序正在使用此文件，进程无法访问。
 (kafka.log.LogManager)
...</code></pre></div>

<p>参阅网络，这可能是在windows下的一个Bug，没有更好的解决方案，暂时写个py脚本用来对kafka的log文件进行删除。下次启动kafka，先运行这个删除脚本吧。</p>
<p><strong>好消息</strong>，当你成功启动kafka，然后在对应的命令行窗口用<code>Ctrl + C</code>结束Kakfa，下次不用清理kafka日志，也能正常启动。</p>
<h4 id="Step-3-Create-a-topic"><a href="#Step-3-Create-a-topic" class="headerlink" title="Step 3: Create a topic"></a>Step 3: Create a topic</h4><ul>
<li>用单一partition和单一replica创建一个名为<code>test</code>的topic:</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --create --zookeeper localhost:<span class="hljs-number">2181</span> --replication-factor <span class="hljs-number">1</span> --partitions <span class="hljs-number">1</span> --topic test</code></pre></div>

<ul>
<li>查看已创建的topic，也就刚才创建的名为<code>test</code>的topic：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --list --zookeeper localhost:<span class="hljs-number">2181</span></code></pre></div>

<p>或者，你可配置你的broker去自动创建未曾发布过的topic，代替手动创建topic</p>
<h4 id="Step-4-Send-some-messages"><a href="#Step-4-Send-some-messages" class="headerlink" title="Step 4: Send some messages"></a>Step 4: Send some messages</h4><p>运行producer，然后输入几行文本，发至服务器：</p>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="hljs-number">9092</span> --topic test
&gt;hello, kafka.
&gt;what a nice day!
&gt;to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div>

<p>请勿关闭窗口，下面步骤需要用到</p>
<h4 id="Step-5-Start-a-consumer"><a href="#Step-5-Start-a-consumer" class="headerlink" title="Step 5: Start a consumer"></a>Step 5: Start a consumer</h4><p>运行consumer，将Step 4中输入的几行句子，标准输出。</p>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9092</span> --topic test --from-beginning
hello, kafka.
what a nice day!
to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div>

<p>若你另启cmd，执行命令行<code>bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning</code>来运行consumer，然后在<a href="https://my.oschina.net/jallenkwong/blog/4449224#">Step 4</a>中producer窗口输入一行句子，如<code>I must admit, I can&#39;t help but feel a twinge of envy.</code>，两个consumer也会同时输出<code>I must admit, I can&#39;t help but feel a twinge of envy.</code>。</p>
<h4 id="Step-6-Setting-up-a-multi-broker-cluster"><a href="#Step-6-Setting-up-a-multi-broker-cluster" class="headerlink" title="Step 6: Setting up a multi-broker cluster"></a>Step 6: Setting up a multi-broker cluster</h4><p>目前为止，我们仅作为一个单一broker，这不好玩。让我们弄个有三个节点的集群来玩玩。</p>
<ul>
<li>首先，在<code>%KAFKA%\config\server.properties</code>的基础上创建两个副本<code>server-1.properties</code>和<code>server-2.properties</code>。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">copy</span> config\server.properties config\server-<span class="hljs-number">1</span>.properties
<span class="hljs-built_in">copy</span> config\server.properties config\server-<span class="hljs-number">2</span>.properties</code></pre></div>

<ul>
<li>打开副本，编辑如下属性</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#config/server-1.properties:</span>
<span class="hljs-meta">broker.id</span>=<span class="hljs-string">1</span>
<span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://127.0.0.1:9093</span>
<span class="hljs-meta">log.dir</span>=<span class="hljs-string">C:\\Kafka\\data\\kafka-logs-1</span>
 
<span class="hljs-comment">#config/server-2.properties:</span>
<span class="hljs-meta">broker.id</span>=<span class="hljs-string">2</span>
<span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://127.0.0.1:9094</span>
<span class="hljs-meta">log.dir</span>=<span class="hljs-string">C:\\Kafka\\data\\kafka-logs-2</span></code></pre></div>

<p>这个<code>broker.id</code>属性是集群中每个节点的唯一永久的名称。</p>
<p>我们必须重写端口和日志目录，只是因为我们在同一台机器上运行它们，并且我们希望阻止brokers试图在同一个端口上注册或覆盖彼此的数据。</p>
<ul>
<li>我们已经启动了Zookeeper和我们的单个节点，所以我们只需要启动两个新节点：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">start</span> bin\windows\kafka-server-<span class="hljs-built_in">start</span>.bat config\server-<span class="hljs-number">1</span>.properties
<span class="hljs-built_in">start</span> bin\windows\kafka-server-<span class="hljs-built_in">start</span>.bat config\server-<span class="hljs-number">2</span>.properties</code></pre></div>

<ul>
<li>创建一个replication-factor为3的topic:</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --create --zookeeper localhost:<span class="hljs-number">2181</span> --replication-factor <span class="hljs-number">3</span> --partitions <span class="hljs-number">1</span> --topic my-replicated-topic</code></pre></div>

<ul>
<li>OK，现在我们有了一个集群，但是我们怎么知道哪个broker在做什么呢？那就运行<code>describe topics</code>命令：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --describe --zookeeper localhost:<span class="hljs-number">2181</span> --topic my-replicated-topic

<span class="hljs-function">Topic:<span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>       <span class="hljs-title">PartitionCount</span>:1        <span class="hljs-title">ReplicationFactor</span>:3</span>
<span class="hljs-function"><span class="hljs-title">Configs</span>:</span>
<span class="hljs-function">		<span class="hljs-title">Topic</span>: <span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>      <span class="hljs-title">Partition</span>: 0    <span class="hljs-title">Leader</span>: 0       </span>
<span class="hljs-function">		<span class="hljs-title">Replicas</span>: 0,1,2        <span class="hljs-title">Isr</span>: 0,1,2</span></code></pre></div>

<ul>
<li>以下是输出的说明。第一行给出所有Partition的摘要，每一行提供有关一个Partition的信息。因为这个Topic只有一个Partition，所以只有一行。<ul>
<li>“leader”是负责给定Partition的所有读写的节点。每个节点都可能成为Partition随机选择的leader。</li>
<li>“replicas”是复制此Partition日志的节点列表，无论它们是leader还是当前处于存活状态。</li>
<li>“isr”是一组 “in-sync” replicas。这是replicas列表的一个子集，它当前处于存活状态，并补充leader。</li>
</ul>
</li>
</ul>
<p>注意，<strong>在我的示例中，node 0是Topic唯一Partition的leader</strong>。（下面操作需要用到）</p>
<ul>
<li>让我们为我们的新Topic发布一些信息：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="hljs-number">9092</span> --topic my-replicated-topic

&gt;There&#x27;s sadness <span class="hljs-keyword">in</span> your eyes, I don&#x27;t want to say goodbye to you.
&gt;Love is a big illusion, I should try to forget, but there&#x27;s something left <span class="hljs-keyword">in</span> m
y head.
&gt;</code></pre></div>

<ul>
<li>让我们接收刚刚发布的信息吧！</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9092</span> --from-beginning --topic my-replicated-topic

There&#x27;s sadness <span class="hljs-keyword">in</span> your eyes, I don&#x27;t want to say goodbye to you.
Love is a big illusion, I should try to forget, but there&#x27;s something left <span class="hljs-keyword">in</span> my head.</code></pre></div>

<ul>
<li>让我们测试一下容错性，由上文可知，Broker 0 身为 leader，因此，让我们干掉它吧：<ul>
<li>先找出 Broker 0 的进程pid。</li>
<li>杀掉 Broker 0 的进程。</li>
</ul>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat">wmic process where &quot;caption=&#x27;java.exe&#x27; and commandline like &#x27;<span class="hljs-variable">%server.properties%</span>&#x27;&quot; get processid,caption
Caption   ProcessId
java.exe  <span class="hljs-number">7528</span>

<span class="hljs-built_in">taskkill</span> /pid <span class="hljs-number">7528</span> /f
成功: 已终止 PID 为 <span class="hljs-number">7528</span> 的进程。</code></pre></div>

<ul>
<li>原leader已被替换成它的flowers中的其中一个，并且 node 0 不在 in-sync replica 集合当中。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --describe --zookeeper localhost:<span class="hljs-number">2181</span> --topic my-replicated-topic

<span class="hljs-function">Topic:<span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>       <span class="hljs-title">PartitionCount</span>:1        <span class="hljs-title">ReplicationFactor</span>:3</span>
<span class="hljs-function"><span class="hljs-title">Configs</span>:</span>
<span class="hljs-function">		<span class="hljs-title">Topic</span>: <span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>      <span class="hljs-title">Partition</span>: 0    <span class="hljs-title">Leader</span>: 1       <span class="hljs-title">Replicas</span>: 0,1,2 <span class="hljs-title">Isr</span>: 1,2</span></code></pre></div>

<ul>
<li>尽管原leader已逝，当原来消息依然可以接收。（注意，参数<code>--bootstrap-server localhost:9093</code>，而不是<code>--bootstrap-server localhost:9092</code>）</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9093</span> --from-beginning --topic my-replicated-topic

There&#x27;s sadness <span class="hljs-keyword">in</span> your eyes, I don&#x27;t want to say goodbye to you.
Love is a big illusion, I should try to forget, but there&#x27;s something left <span class="hljs-keyword">in</span> my head.
I don&#x27;t forget the way your kissing, the feeling &#x27;s so strong which is lasting <span class="hljs-keyword">for</span> so long.</code></pre></div>

<h4 id="server-properties一瞥"><a href="#server-properties一瞥" class="headerlink" title="server.properties一瞥"></a>server.properties一瞥</h4><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#broker 的全局唯一编号，不能重复</span>
<span class="hljs-meta">broker.id</span>=<span class="hljs-string">0</span>
<span class="hljs-comment">#删除 topic 功能使能</span>
<span class="hljs-meta">delete.topic.enable</span>=<span class="hljs-string">true</span>
<span class="hljs-comment">#处理网络请求的线程数量</span>
<span class="hljs-meta">num.network.threads</span>=<span class="hljs-string">3</span>
<span class="hljs-comment">#用来处理磁盘 IO 的现成数量</span>
<span class="hljs-meta">num.io.threads</span>=<span class="hljs-string">8</span>
<span class="hljs-comment">#发送套接字的缓冲区大小</span>
<span class="hljs-meta">socket.send.buffer.bytes</span>=<span class="hljs-string">102400</span>
<span class="hljs-comment">#接收套接字的缓冲区大小</span>
<span class="hljs-meta">socket.receive.buffer.bytes</span>=<span class="hljs-string">102400</span>
<span class="hljs-comment">#请求套接字的缓冲区大小</span>
<span class="hljs-meta">socket.request.max.bytes</span>=<span class="hljs-string">104857600</span>
<span class="hljs-comment">#kafka 运行日志存放的路径</span>
<span class="hljs-meta">log.dirs</span>=<span class="hljs-string">/opt/module/kafka/logs</span>
<span class="hljs-comment">#topic 在当前 broker 上的分区个数</span>
<span class="hljs-meta">num.partitions</span>=<span class="hljs-string">1</span>
<span class="hljs-comment">#用来恢复和清理 data 下数据的线程数量</span>
<span class="hljs-meta">num.recovery.threads.per.data.dir</span>=<span class="hljs-string">1</span>
<span class="hljs-comment">#segment 文件保留的最长时间，超时将被删除</span>
<span class="hljs-meta">log.retention.hours</span>=<span class="hljs-string">168</span>
<span class="hljs-comment">#配置连接 Zookeeper 集群地址</span>
<span class="hljs-meta">zookeeper.connect</span>=<span class="hljs-string">hadoop102:2181,hadoop103:2181,hadoop104:2181</span></code></pre></div>

<h3 id="1-7-命令行操作Topic增删查"><a href="#1-7-命令行操作Topic增删查" class="headerlink" title="1.7 命令行操作Topic增删查"></a>1.7 命令行操作Topic增删查</h3><h4 id="查看当前服务器中的所有-topic"><a href="#查看当前服务器中的所有-topic" class="headerlink" title="查看当前服务器中的所有 topic"></a>查看当前服务器中的所有 topic</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --list --zookeeper localhost:<span class="hljs-number">2181</span></code></pre></div>

<h4 id="创建-topic"><a href="#创建-topic" class="headerlink" title="创建 topic"></a>创建 topic</h4><div class="code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">bin\windows\kafka</span><span class="hljs-literal">-</span><span class="hljs-comment">topics</span><span class="hljs-string">.</span><span class="hljs-comment">bat</span> --<span class="hljs-comment">create</span> --<span class="hljs-comment">zookeeper</span> <span class="hljs-comment">localhost:2181</span> --<span class="hljs-comment">replication</span><span class="hljs-literal">-</span><span class="hljs-comment">factor</span> <span class="hljs-comment">3</span> --<span class="hljs-comment">partitions</span> <span class="hljs-comment">1</span> --<span class="hljs-comment">topic</span> <span class="hljs-comment">my</span><span class="hljs-literal">-</span><span class="hljs-comment">replicated</span><span class="hljs-literal">-</span><span class="hljs-comment">topic</span></code></pre></div>

<p>选项说明：</p>
<ul>
<li>–topic 定义 topic 名</li>
<li>–replication-factor 定义副本数</li>
<li>–partitions 定义分区数</li>
</ul>
<blockquote>
<p>  为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；</p>
<p>  a broker = a kafka server a broker can contain N topic a topic can contain N partition a broker can contain a part of a topic (a broker can contain M(N&gt;M) partition)</p>
</blockquote>
<h4 id="删除-topic"><a href="#删除-topic" class="headerlink" title="删除 topic"></a>删除 topic</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --zookeeper localhost:<span class="hljs-number">2181</span> --delete --topic my-replicated-topic</code></pre></div>

<p>需要 server.properties 中设置 <code>delete.topic.enable=true</code> 否则只是标记删除。</p>
<h4 id="查看某个-Topic-的详情"><a href="#查看某个-Topic-的详情" class="headerlink" title="查看某个 Topic 的详情"></a>查看某个 Topic 的详情</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --zookeeper localhost:<span class="hljs-number">2181</span> --describe --topic first</code></pre></div>

<h4 id="修改分区数"><a href="#修改分区数" class="headerlink" title="修改分区数"></a>修改分区数</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --zookeeper localhost:<span class="hljs-number">2181</span> --alter --topic first --partitions <span class="hljs-number">6</span></code></pre></div>

<h3 id="1-8-命令行控制台生产者消费者测试"><a href="#1-8-命令行控制台生产者消费者测试" class="headerlink" title="1.8 命令行控制台生产者消费者测试"></a>1.8 命令行控制台生产者消费者测试</h3><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="hljs-number">9092</span> --topic test

&gt;hello, kafka.
&gt;what a nice day!
&gt;to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div>

<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9092</span> --topic test --from-beginning

hello, kafka.
what a nice day!
to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div>

<ul>
<li>–from-beginning： 会把主题中以往所有的数据都读取出来。</li>
</ul>
<h3 id="1-9-数据日志分离"><a href="#1-9-数据日志分离" class="headerlink" title="1.9 数据日志分离"></a>1.9 数据日志分离</h3><h3 id="1-10-回顾"><a href="#1-10-回顾" class="headerlink" title="1.10 回顾"></a>1.10 回顾</h3><h2 id="2-Kafka高级"><a href="#2-Kafka高级" class="headerlink" title="2 Kafka高级"></a>2 Kafka高级</h2><h3 id="2-1-工作流程"><a href="#2-1-工作流程" class="headerlink" title="2.1 工作流程"></a>2.1 工作流程</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/05.png" alt></p>
<ul>
<li><p>Kafka 中消息是以 topic 进行分类的， producer生产消息，consumer消费消息，都是面向 topic的。(从命令行操作看出)</p>
<div class="code-wrapper"><pre><code class="hljs shell">bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic test

bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning</code></pre></div>
</li>
<li><p>topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文件，该 log 文件中存储的就是 producer 生产的数据。（topic = N partition，partition = log）</p>
</li>
<li><p>Producer 生产的数据会被不断追加到该log 文件末端，且每条数据都有自己的 offset。 consumer组中的每个consumer， 都会实时记录自己消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。（producer -&gt; log with offset -&gt; consumer(s)）</p>
</li>
</ul>
<h3 id="2-2-文件存储"><a href="#2-2-文件存储" class="headerlink" title="2.2 文件存储"></a>2.2 文件存储</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/06.png" alt></p>
<ul>
<li><p>由于生产者生产的消息会不断追加到 log 文件末尾， 为防止 log 文件过大导致数据定位效率低下， Kafka 采取了<strong>分片</strong>和<strong>索引</strong>机制，将每个 partition 分为多个 segment。</p>
</li>
<li><p>每个 segment对应两个文件——“.index”文件和“.log”文件。 这些文件位于一个文件夹下， 该文件夹的命名规则为： topic 名称+分区序号。例如， first 这个 topic 有三个分区，则其对应的文件夹为 first-0,first-1,first-2。</p>
<div class="code-wrapper"><pre><code class="hljs shell">00000000000000000000.index
00000000000000000000.log
00000000000000170410.index
00000000000000170410.log
00000000000000239430.index
00000000000000239430.log</code></pre></div>
</li>
<li><p>index 和 log 文件以当前 segment 的第一条消息的 offset 命名。下图为 index 文件和 log文件的结构示意图。</p>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/07.png" alt></p>
</li>
<li><p><strong>“.index”文件存储大量的索引信息，“.log”文件存储大量的数据</strong>，索引文件中的元数据指向对应数据文件中 message 的物理偏移地址。</p>
<blockquote>
<p>  segment 英 [ˈseɡmənt , seɡˈment] 美 [ˈseɡmənt , seɡˈment]<br>  n.部分;份;片;段;(柑橘、柠檬等的)瓣;弓形;圆缺 v.分割;划分</p>
</blockquote>
</li>
</ul>
<h3 id="2-3-生产者分区策略"><a href="#2-3-生产者分区策略" class="headerlink" title="2.3 生产者分区策略"></a>2.3 生产者分区策略</h3><h4 id="1-分区的原因"><a href="#1-分区的原因" class="headerlink" title="1 分区的原因"></a>1 分区的原因</h4><ul>
<li><strong>方便在集群中扩展</strong>，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic又可以有多个 Partition 组成，因此整个集群就可以适应适合的数据了；</li>
<li><strong>可以提高并发</strong>，因为可以以 Partition 为单位读写了。（联想到ConcurrentHashMap在高并发环境下读写效率比HashTable的高效）</li>
</ul>
<h4 id="2-分区的原则"><a href="#2-分区的原则" class="headerlink" title="2 分区的原则"></a>2 分区的原则</h4><p>我们需要将 producer 发送的数据封装成一个 <code>ProducerRecord</code> 对象。</p>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/08.png" alt></p>
<ol>
<li>指明 partition 的情况下，直接将指明的值直接作为 partiton 值；</li>
<li>没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值；</li>
<li>既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition值，也就是常说的 round-robin 算法。</li>
</ol>
<h3 id="2-4-生产者ISR"><a href="#2-4-生产者ISR" class="headerlink" title="2.4 生产者ISR"></a>2.4 生产者ISR</h3><p>为保证 producer 发送的数据，能可靠的发送到指定的 topic， topic 的每个 partition 收到producer 发送的数据后，都需要向 producer 发送 ack（acknowledgement 确认收到），如果producer 收到 ack， 就会进行下一轮的发送，否则重新发送数据。</p>
<blockquote>
<p>  acknowledgement 英 [əkˈnɒlɪdʒmənt] 美 [əkˈnɑːlɪdʒmənt]<br>  n.(对事实、现实、存在的)承认;感谢;谢礼;<strong>收件复函</strong></p>
</blockquote>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/09.png" alt></p>
<p><strong>何时发送ack？</strong></p>
<p>确保有follower与leader同步完成，leader再发送ack，这样才能保证leader挂掉之后，能在follower中选举出新的leader。</p>
<p><strong>多少个follower同步完成之后发送ack？</strong></p>
<ol>
<li>半数以上的follower同步完成，即可发送ack继续发送重新发送</li>
<li>全部的follower同步完成，才可以发送ack</li>
</ol>
<h4 id="1-副本数据同步策略"><a href="#1-副本数据同步策略" class="headerlink" title="1 副本数据同步策略"></a>1 副本数据同步策略</h4><table>
<thead>
<tr>
<th>序号</th>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>半数以上完成同步， 就发送 ack</td>
<td>延迟低</td>
<td>选举新的 leader 时，容忍 n 台节点的故障，需要 2n+1 个副本。（如果集群有2n+1台机器，选举leader的时候至少需要半数以上即n+1台机器投票，那么能容忍的故障，最多就是n台机器发生故障）容错率：1/2</td>
</tr>
<tr>
<td>2</td>
<td>全部完成同步，才发送ack</td>
<td>选举新的 leader 时， 容忍 n 台节点的故障，需要 n+1 个副本（如果集群有n+1台机器，选举leader的时候只要有一个副本就可以了）容错率：1</td>
<td>延迟高</td>
</tr>
</tbody></table>
<p>Kafka 选择了第二种方案，原因如下：</p>
<ol>
<li>同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1 个副本，而 Kafka 的每个分区都有大量的数据， 第一种方案会造成大量数据的冗余。</li>
<li>虽然第二种方案的网络延迟会比较高，但网络延迟对 Kafka 的影响较小。</li>
</ol>
<h4 id="2-ISR"><a href="#2-ISR" class="headerlink" title="2 ISR"></a>2 ISR</h4><p>采用第二种方案之后，设想以下情景： leader 收到数据，所有 follower 都开始同步数据，但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去，直到它完成同步，才能发送 ack。这个问题怎么解决呢？</p>
<p>Leader 维护了一个动态的 <strong>in-sync replica set</strong> (ISR)，意为和 leader 保持同步的 follower 集合。当 ISR 中的 follower 完成数据的同步之后，就会给 leader 发送 ack。如果 follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由<code>replica.lag.time.max.ms</code>参数设定。 Leader 发生故障之后，就会从 ISR 中选举新的 leader。</p>
<blockquote>
<p>  <strong>replica.lag.time.max.ms</strong></p>
<p>  <strong>DESCRIPTION</strong>: If a follower hasn’t sent any fetch requests or hasn’t consumed up to the leaders log end offset for at least this time, the leader will remove the follower from isr</p>
<p>  <strong>TYPE</strong>: long</p>
<p>  <strong>DEFAULT</strong>: 10000</p>
<p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23brokerconfigs">Source</a></p>
</blockquote>
<h3 id="2-5-生产者ACK机制"><a href="#2-5-生产者ACK机制" class="headerlink" title="2.5 生产者ACK机制"></a>2.5 生产者ACK机制</h3><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等 ISR 中的 follower 全部接收成功。</p>
<p>所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，选择以下的配置。</p>
<h4 id="acks-参数配置："><a href="#acks-参数配置：" class="headerlink" title="acks 参数配置："></a><strong>acks 参数配置</strong>：</h4><ul>
<li>0： producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟， broker 一接收到还没有写入磁盘就已经返回，当 broker 故障时有可能<strong>丢失数据</strong>；</li>
<li>1： producer 等待 broker 的 ack， partition 的 leader 落盘成功后返回 ack，如果在 follower同步成功之前 leader 故障，那么将会<strong>丢失数据</strong>；</li>
</ul>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/10.png" alt></p>
<ul>
<li>-1（all） ： producer 等待 broker 的 ack， partition 的 leader 和 ISR 的follower 全部落盘成功后才返回 ack。但是如果在 follower 同步完成后， broker 发送 ack 之前， leader 发生故障，那么会造成<strong>数据重复</strong>。</li>
</ul>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/11.png" alt></p>
<p><strong>助记：返ACK前，0无落盘，1一落盘，-1全落盘，（落盘：消息存到本地）</strong></p>
<blockquote>
<p>  <strong>acks</strong></p>
<p>  <strong>DESCRIPTION</strong>:</p>
<p>  The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. The following settings are allowed:</p>
<ul>
<li><code>acks=0</code> If set to zero then the producer will not wait for any acknowledgment from the server at all. The record will be immediately added to the socket buffer and considered sent. No guarantee can be made that the server has received the record in this case, and the retries configuration will not take effect (as the client won’t generally know of any failures). The offset given back for each record will always be set to -1.</li>
<li><code>acks=1</code> This will mean the leader will write the record to its local log but will respond without awaiting full acknowledgement from all followers. In this case should the leader fail immediately after acknowledging the record but before the followers have replicated it then the record will be lost.</li>
<li><code>acks=all</code> This means the leader will wait for the full set of in-sync replicas to acknowledge the record. This guarantees that the record will not be lost as long as at least one in-sync replica remains alive. This is the strongest available guarantee. This is equivalent to the acks=-1 setting.</li>
</ul>
<p>  <strong>TYPE</strong>:string</p>
<p>  <strong>DEFAULT</strong>:1</p>
<p>  <strong>VALID VALUES</strong>:[all, -1, 0, 1]</p>
<p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23producerconfigs">Source</a></p>
</blockquote>
<h3 id="2-6-数据一致性问题"><a href="#2-6-数据一致性问题" class="headerlink" title="2.6 数据一致性问题"></a>2.6 数据一致性问题</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/12.png" alt></p>
<ul>
<li>LEO：（Log End Offset）每个副本的最后一个offset</li>
<li>HW：（High Watermark）高水位，指的是消费者能见到的最大的 offset， ISR 队列中最小的 LEO</li>
</ul>
<h4 id="follower-故障和-leader-故障"><a href="#follower-故障和-leader-故障" class="headerlink" title="follower 故障和 leader 故障"></a>follower 故障和 leader 故障</h4><ul>
<li><strong>follower 故障</strong>：follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后， follower 会读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重新加入 ISR 了。</li>
<li><strong>leader 故障</strong>：leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性， 其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader同步数据。</li>
</ul>
<p>注意： 这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p>
<h3 id="2-7-ExactlyOnce"><a href="#2-7-ExactlyOnce" class="headerlink" title="2.7 ExactlyOnce"></a>2.7 ExactlyOnce</h3><p>将服务器的 ACK 级别设置为-1（all），可以保证 Producer 到 Server 之间不会丢失数据，即 <strong>At Least Once</strong> 语义。</p>
<p>相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被发送一次，即 <strong>At Most Once</strong> 语义。</p>
<p>At Least Once 可以保证数据不丢失，但是不能保证数据不重复；相对的， At Most Once可以保证数据不重复，但是不能保证数据不丢失。 但是，对于一些非常重要的信息，比如说<strong>交易数据</strong>，下游数据消费者要求数据既不重复也不丢失，即 <strong>Exactly Once</strong> 语义。</p>
<blockquote>
<ul>
<li><p>At least once—Messages are <strong>never lost</strong> but may be redelivered.</p>
</li>
<li><p>At most once—Messages <strong>may be lost</strong> but are never redelivered.</p>
</li>
<li><p>Exactly once—this is what people actually want, each message is delivered once and only once.</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23semantics">Source</a></p>
</li>
</ul>
</blockquote>
<p>在 0.11 版本以前的 Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p>
<p>0.11 版本的 Kafka，引入了一项重大特性：<strong>幂等性</strong>。<strong>所谓的幂等性就是指 Producer 不论向 Server 发送多少次重复数据， Server 端都只会持久化一条</strong>。幂等性结合 At Least Once 语义，就构成了 Kafka 的 Exactly Once 语义。即：</p>
<div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">At</span> <span class="hljs-variable">Least</span> <span class="hljs-built_in">Once</span> <span class="hljs-operator">+</span> 幂等性 <span class="hljs-operator">=</span> <span class="hljs-variable">Exactly</span> <span class="hljs-built_in">Once</span></code></pre></div>

<p>要启用幂等性，只需要将 Producer 的参数中 <code>enable.idempotence</code> 设置为 true 即可。 Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 Producer 在初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而Broker 端会对<code>&lt;PID, Partition, SeqNumber&gt;</code>做缓存，当具有相同主键的消息提交时， Broker 只会持久化一条。</p>
<p>但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨分区跨会话的 Exactly Once。</p>
<blockquote>
<p>  <strong>enable.idempotence</strong></p>
<p>  DESCRIPTION:When set to ‘true’, the producer will ensure that exactly one copy of each message is written in the stream. If ‘false’, producer retries due to broker failures, etc., may write duplicates of the retried message in the stream. This is set to ‘false’ by default. Note that enabling idempotence requires <code>max.in.flight.requests.per.connection</code> to be set to 1 and <code>retries</code> cannot be zero. Additionally acks must be set to ‘all’. If these values are left at their defaults, we will override the default to be suitable. If the values are set to something incompatible with the idempotent producer, a ConfigException will be thrown.</p>
<p>  TYPE:boolean</p>
<p>  DEFAULT:false</p>
<p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23producerconfigs">Source</a></p>
</blockquote>
<h3 id="2-8-生产者总结"><a href="#2-8-生产者总结" class="headerlink" title="2.8 生产者总结"></a>2.8 生产者总结</h3><h3 id="2-9-消费者分区分配策略"><a href="#2-9-消费者分区分配策略" class="headerlink" title="2.9 消费者分区分配策略"></a>2.9 消费者分区分配策略</h3><h4 id="1-消费方式"><a href="#1-消费方式" class="headerlink" title="1 消费方式"></a>1 消费方式</h4><p><strong>consumer 采用 pull（拉） 模式从 broker 中读取数据</strong>。</p>
<p><strong>push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的</strong>。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</p>
<p><strong>pull 模式不足之处</strong>是，如果 kafka 没有数据，消费者可能会陷入循环中， 一直返回空数据。 针对这一点， Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有数据可供消费， consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23design_pull">Push vs. pull</a></p>
<h4 id="2-分区分配策略"><a href="#2-分区分配策略" class="headerlink" title="2 分区分配策略"></a>2 分区分配策略</h4><p>一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以必然会涉及到 partition 的分配问题，即确定那个 partition 由哪个 consumer 来消费。</p>
<p>Kafka 有两种分配策略：</p>
<ul>
<li>round-robin循环</li>
<li>range</li>
</ul>
<blockquote>
<p>  <strong>partition.assignment.strategy</strong></p>
<p>  Select between the “range” or “roundrobin” strategy for assigning分配 partitions to consumer streams.</p>
<p>  The <strong>round-robin</strong> partition assignor lays out规划 all the available partitions and all the available consumer threads. It then proceeds to do接着做 a round-robin assignment from partition to consumer thread. If the subscriptions订阅 of all consumer instances are identical完全同样的, then the partitions will be uniformly 均匀地distributed. (i.e.也就是说, the partition ownership counts will be within a delta of exactly one across all consumer threads.) Round-robin assignment is permitted only if:</p>
<ol>
<li>Every topic has the same number of streams within a consumer instance</li>
<li>The set of subscribed topics is identical for every consumer instance within the group.</li>
</ol>
<p>  <strong>Range</strong> partitioning works on a per-<strong>topic</strong> basis. For each topic, we lay out the available partitions in numeric order and the consumer threads in lexicographic词典式的 order. We then divide the number of partitions by the total number of consumer streams (threads) to determine the number of partitions to assign to each consumer. If it does not evenly divide, then the first few consumers will have one extra partition.</p>
<p>  <strong>DEFAULT</strong>:range</p>
<p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23oldconsumerconfigs">Source</a></p>
</blockquote>
<hr>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F86718818">Kafka再平衡机制详解</a></p>
<h4 id="3-Round-Robin"><a href="#3-Round-Robin" class="headerlink" title="3 Round Robin"></a>3 Round Robin</h4><p>关于Roudn Robin重分配策略，其主要采用的是一种轮询的方式分配所有的分区，该策略主要实现的步骤如下。这里我们首先假设有三个topic：t0、t1和t2，这三个topic拥有的分区数分别为1、2和3，那么总共有六个分区，这六个分区分别为：t0-0、t1-0、t1-1、t2-0、t2-1和t2-2。这里假设我们有三个consumer：C0、C1和C2，它们订阅情况为：C0订阅t0，C1订阅t0和t1，C2订阅t0、t1和t2。那么这些分区的分配步骤如下：</p>
<ul>
<li>首先将所有的partition和consumer按照字典序进行排序，所谓的字典序，就是按照其名称的字符串顺序，那么上面的六个分区和三个consumer排序之后分别为：</li>
</ul>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/16.png" alt></p>
<ul>
<li>然后依次以按顺序轮询的方式将这六个分区分配给三个consumer，如果当前consumer没有订阅当前分区所在的topic，则轮询的判断下一个consumer：</li>
<li>尝试将t0-0分配给C0，由于C0订阅了t0，因而可以分配成功；</li>
<li>尝试将t1-0分配给C1，由于C1订阅了t1，因而可以分配成功；</li>
<li>尝试将t1-1分配给C2，由于C2订阅了t1，因而可以分配成功；</li>
<li>尝试将t2-0分配给C0，由于C0没有订阅t2，因而会轮询下一个consumer；</li>
<li>尝试将t2-0分配给C1，由于C1没有订阅t2，因而会轮询下一个consumer；</li>
<li>尝试将t2-0分配给C2，由于C2订阅了t2，因而可以分配成功；</li>
<li>同理由于t2-1和t2-2所在的topic都没有被C0和C1所订阅，因而都不会分配成功，最终都会分配给C2。</li>
<li>按照上述的步骤将所有的分区都分配完毕之后，最终分区的订阅情况如下：</li>
</ul>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/17.png" alt></p>
<p>从上面的步骤分析可以看出，轮询的策略就是简单的将所有的partition和consumer按照字典序进行排序之后，然后依次将partition分配给各个consumer，如果当前的consumer没有订阅当前的partition，那么就会轮询下一个consumer，直至最终将所有的分区都分配完毕。但是从上面的分配结果可以看出，轮询的方式会导致每个consumer所承载的分区数量不一致，从而导致各个consumer压力不均一。</p>
<h4 id="4-Range"><a href="#4-Range" class="headerlink" title="4 Range"></a>4 Range</h4><p>所谓的Range重分配策略，就是首先会计算各个consumer将会承载的分区数量，然后将指定数量的分区分配给该consumer。这里我们假设有两个consumer：C0和C1，两个topic：t0和t1，这两个topic分别都有三个分区，那么总共的分区有六个：t0-0、t0-1、t0-2、t1-0、t1-1和t1-2。那么Range分配策略将会按照如下步骤进行分区的分配：</p>
<ul>
<li>需要注意的是，Range策略是按照topic依次进行分配的，比如我们以t0进行讲解，其首先会获取t0的所有分区：t0-0、t0-1和t0-2，以及所有订阅了该topic的consumer：C0和C1，并且会将这些分区和consumer按照字典序进行排序；</li>
<li>然后按照平均分配的方式计算每个consumer会得到多少个分区，如果没有除尽，则会将多出来的分区依次计算到前面几个consumer。比如这里是三个分区和两个consumer，那么每个consumer至少会得到1个分区，而3除以2后还余1，那么就会将多余的部分依次算到前面几个consumer，也就是这里的1会分配给第一个consumer，总结来说，那么C0将会从第0个分区开始，分配2个分区，而C1将会从第2个分区开始，分配1个分区；</li>
<li>同理，按照上面的步骤依次进行后面的topic的分配。</li>
<li>最终上面六个分区的分配情况如下：</li>
</ul>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/18.png" alt></p>
<p>可以看到，如果按照<code>Range</code>分区方式进行分配，其本质上是依次遍历每个topic，然后将这些topic的分区按照其所订阅的consumer数量进行平均的范围分配。这种方式从计算原理上就会导致排序在前面的consumer分配到更多的分区，从而导致各个consumer的压力不均衡。</p>
<p>TODO:我的问题：topic分多个partition，有些custom根据上述策略，分到topic的部分partition，难道不是要全部partition吗？是不是还要按照相同策略多分配多一次？</p>
<h3 id="2-10-消费者offset的存储"><a href="#2-10-消费者offset的存储" class="headerlink" title="2.10 消费者offset的存储"></a>2.10 消费者offset的存储</h3><p>由于 consumer 在消费过程中可能会出现断电宕机等故障， consumer 恢复后，需要从故障前的位置的继续消费，所以 <strong>consumer 需要实时记录自己消费到了哪个 offset</strong>，以便故障恢复后继续消费。</p>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/13.png" alt></p>
<p><strong>Kafka 0.9 版本之前， consumer 默认将 offset 保存在 Zookeeper 中，从 0.9 版本开始，consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为__consumer_offsets</strong>。</p>
<ol>
<li>修改配置文件 consumer.properties，<code>exclude.internal.topics=false</code>。</li>
<li>读取 offset<ul>
<li>0.11.0.0 之前版本 - <code>bin/kafka-console-consumer.sh --topic __consumer_offsets --zookeeper hadoop102:2181 --formatter &quot;kafka.coordinator.GroupMetadataManager\$OffsetsMessageFormatter&quot; --consumer.config config/consumer.properties --from-beginning</code></li>
<li>0.11.0.0 及之后版本 - <code>bin/kafka-console-consumer.sh --topic __consumer_offsets --zookeeper hadoop102:2181 --formatter &quot;kafka.coordinator.group.GroupMetadataManager\$OffsetsMessageFormatter&quot; --consumer.config config/consumer.properties --from-beginning</code></li>
</ul>
</li>
</ol>
<p>TODO:上机实验</p>
<h3 id="2-11-消费者组案例"><a href="#2-11-消费者组案例" class="headerlink" title="2.11 消费者组案例"></a>2.11 消费者组案例</h3><h4 id="1-需求"><a href="#1-需求" class="headerlink" title="1 需求"></a>1 需求</h4><p>测试同一个消费者组中的消费者， <strong>同一时刻只能有一个</strong>消费者消费。</p>
<h4 id="2-操作步骤"><a href="#2-操作步骤" class="headerlink" title="2 操作步骤"></a>2 操作步骤</h4><p>1.修改<code>%KAFKA_HOME\config\consumer.properties%</code>文件中的<code>group.id</code>属性。</p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">group.id</span>=<span class="hljs-string">shan-kou-zu</span></code></pre></div>

<p>2.打开两个cmd，分别启动两个消费者。（以<code>%KAFKA_HOME\config\consumer.properties%</code>作配置参数）</p>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --zookeeper <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2181</span> --topic test --consumer.config config\consumer.properties</code></pre></div>

<p>3.再打开一个cmd，启动一个生产者。</p>
<div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">9092</span> --topic test</code></pre></div>

<p>4.在生产者窗口输入消息，观察两个消费者窗口。<strong>会发现两个消费者窗口中，只有一个才会弹出消息</strong>。</p>
<h3 id="2-12-高效读写-amp-ZK作用"><a href="#2-12-高效读写-amp-ZK作用" class="headerlink" title="2.12 高效读写&amp;ZK作用"></a>2.12 高效读写&amp;ZK作用</h3><h4 id="1-顺序写磁盘"><a href="#1-顺序写磁盘" class="headerlink" title="1 顺序写磁盘"></a>1 顺序写磁盘</h4><p>Kafka 的 producer 生产数据，要写入到 log 文件中，写的过程是一直追加到文件末端，为顺序写。 官网有数据表明，同样的磁盘，顺序写能到 600M/s，而随机写只有 100K/s。这与磁盘的机械机构有关，顺序写之所以快，是因为其<strong>省去了大量磁头寻址的时间</strong>。</p>
<h4 id="2-零复制技术"><a href="#2-零复制技术" class="headerlink" title="2 零复制技术"></a>2 零复制技术</h4><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/14.png" alt></p>
<ul>
<li>NIC network interface controller 网络接口控制器</li>
</ul>
<h4 id="3-Zookeeper-在-Kafka-中的作用"><a href="#3-Zookeeper-在-Kafka-中的作用" class="headerlink" title="3 Zookeeper 在 Kafka 中的作用"></a>3 Zookeeper 在 Kafka 中的作用</h4><p>Kafka 集群中有一个 broker 会被选举为 Controller，负责管理集群 broker 的上下线，所有 topic 的分区副本分配和 leader 选举等工作。<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23design_replicamanagment">Reference</a></p>
<p>Controller 的管理工作都是依赖于 Zookeeper 的。</p>
<p>以下为 partition 的 leader 选举过程：</p>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/15.png" alt></p>
<h3 id="2-13-Ranger分区再分析"><a href="#2-13-Ranger分区再分析" class="headerlink" title="2.13 Ranger分区再分析"></a>2.13 Ranger分区再分析</h3><h3 id="2-14-事务"><a href="#2-14-事务" class="headerlink" title="2.14 事务"></a>2.14 事务</h3><p>Kafka 从 0.11 版本开始引入了事务支持。事务可以保证 Kafka 在 Exactly Once 语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p>
<h4 id="1-Producer-事务"><a href="#1-Producer-事务" class="headerlink" title="1 Producer 事务"></a>1 Producer 事务</h4><p>为了实现跨分区跨会话的事务，需要引入一个全局唯一的 Transaction ID，并将 Producer 获得的PID 和Transaction ID 绑定。这样当Producer 重启后就可以通过正在进行的 TransactionID 获得原来的 PID。</p>
<p>为了管理 Transaction， Kafka 引入了一个新的组件 Transaction Coordinator。 Producer 就是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。 Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p>
<h4 id="2-Consumer-事务"><a href="#2-Consumer-事务" class="headerlink" title="2 Consumer 事务"></a>2 Consumer 事务</h4><p>上述事务机制主要是从 Producer 方面考虑，对于 Consumer 而言，事务的保证就会相对较弱，尤其时无法保证 Commit 的信息被精确消费。这是由于 Consumer 可以通过 offset 访问任意信息，而且不同的 Segment File 生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p>
<h3 id="2-15-API生产者流程"><a href="#2-15-API生产者流程" class="headerlink" title="2.15 API生产者流程"></a>2.15 API生产者流程</h3><p>Kafka 的 Producer 发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了两个线程——main 线程和 Sender 线程，以及一个线程共享变量——RecordAccumulator。 main 线程将消息发送给 RecordAccumulator， Sender 线程不断从 RecordAccumulator 中拉取消息发送到 Kafka broker。</p>
<p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/19.png" alt></p>
<p>相关参数：</p>
<ul>
<li><strong>batch.size</strong>： 只有数据积累到 batch.size 之后， sender 才会发送数据。</li>
<li><strong>linger.ms</strong>： 如果数据迟迟未达到 batch.size， sender 等待 linger.time 之后就会发送数据。</li>
</ul>
<h3 id="2-16异步发送API普通生产者"><a href="#2-16异步发送API普通生产者" class="headerlink" title="2.16异步发送API普通生产者"></a>2.16异步发送API普通生产者</h3><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1 导入依赖"></a>1 导入依赖</h4><p><a href="https://my.oschina.net/jallenkwong/blog/pom.xml">pom.xml</a></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-clients<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h4 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2 编写代码"></a>2 编写代码</h4><p>需要用到的类：</p>
<ul>
<li>KafkaProducer：需要创建一个生产者对象，用来发送数据</li>
<li>ProducerConfig：获取所需的一系列配置参数</li>
<li>ProducerRecord：每条数据都要封装成一个 ProducerRecord 对象</li>
</ul>
<p><a href="https://gitee.com/jallenkwong/LearnKafka/blob/master/src/main/java/com/lun/kafka/producer/CustomProducer.java">CustomProducer.java</a></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Properties;

<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.Producer;
<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomProducer</span> </span>&#123;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		Properties props = <span class="hljs-keyword">new</span> Properties();
		<span class="hljs-comment">// kafka 集群， broker-list</span>
		
		props.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>);
		
		<span class="hljs-comment">//可用ProducerConfig.ACKS_CONFIG 代替 &quot;acks&quot;</span>
		<span class="hljs-comment">//props.put(ProducerConfig.ACKS_CONFIG, &quot;all&quot;);</span>
		props.put(<span class="hljs-string">&quot;acks&quot;</span>, <span class="hljs-string">&quot;all&quot;</span>);
		<span class="hljs-comment">// 重试次数</span>
		props.put(<span class="hljs-string">&quot;retries&quot;</span>, <span class="hljs-number">1</span>);
		<span class="hljs-comment">// 批次大小</span>
		props.put(<span class="hljs-string">&quot;batch.size&quot;</span>, <span class="hljs-number">16384</span>);
		<span class="hljs-comment">// 等待时间</span>
		props.put(<span class="hljs-string">&quot;linger.ms&quot;</span>, <span class="hljs-number">1</span>);
		<span class="hljs-comment">// RecordAccumulator 缓冲区大小</span>
		props.put(<span class="hljs-string">&quot;buffer.memory&quot;</span>, <span class="hljs-number">33554432</span>);
		props.put(<span class="hljs-string">&quot;key.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);
		props.put(<span class="hljs-string">&quot;value.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);
		Producer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> KafkaProducer&lt;&gt;(props);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;
			producer.send(<span class="hljs-keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;test-&quot;</span> + Integer.toString(i),
					<span class="hljs-string">&quot;test-&quot;</span> + Integer.toString(i)));
		&#125;
		producer.close();
	&#125;

&#125;</code></pre></div>

<h3 id="2-17-回顾"><a href="#2-17-回顾" class="headerlink" title="2.17 回顾"></a>2.17 回顾</h3>]]></content>
      <categories>
        <category>Technical</category>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 学习</title>
    <url>/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Mybatis-学习"><a href="#Mybatis-学习" class="headerlink" title="Mybatis 学习"></a>Mybatis 学习</h1><h2 id="1-第一个Mybatis程序"><a href="#1-第一个Mybatis程序" class="headerlink" title="1 第一个Mybatis程序"></a>1 第一个Mybatis程序</h2><p><strong>MyBatis框架学习第1天</strong></p>
<p> <strong>Time = 2020.11.20</strong></p>
<h3 id="1-1-mappers设置错误"><a href="#1-1-mappers设置错误" class="headerlink" title="1.1 mappers设置错误"></a>1.1 mappers设置错误</h3><p>在看视频的过程中,我发现除了视频博主指出的mappers没有指明Mybatis-config.xml即核心配置文件中写入</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/pnca/mapper/UserMapper.xml&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div>

<h3 id="1-2-资源导出错误"><a href="#1-2-资源导出错误" class="headerlink" title="1.2 资源导出错误"></a>1.2 资源导出错误</h3><p>初始化中资源UserMapper无法导出的问题需要在pom.xml加注一段bulid</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div>

<h3 id="1-3-时区问题和mysql-jdbc被弃用"><a href="#1-3-时区问题和mysql-jdbc被弃用" class="headerlink" title="1.3 时区问题和mysql.jdbc被弃用"></a>1.3 时区问题和mysql.jdbc被弃用</h3><p>一个是时区问题,需要在url中加入时区声明,另一个问题是需要使用cj.jadc,因为mysql.jdbc已经被弃用.</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC<span class="hljs-symbol">&amp;amp;</span>useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8&quot;</span>/&gt;</span></code></pre></div>

<h2 id="2-CRUD"><a href="#2-CRUD" class="headerlink" title="2 CRUD"></a>2 CRUD</h2><p><strong>MyBatis框架学习第2天</strong></p>
<p> <strong>Time = 2020.11.22 - 24</strong></p>
<h3 id="2-1-注释错误"><a href="#2-1-注释错误" class="headerlink" title="2.1  注释错误"></a>2.1  注释错误</h3><p>我发现,最好不要在配置文件里即.xml文件里,加入中文注释.可能会有一些错误,</p>
<h3 id="2-2-namespace"><a href="#2-2-namespace" class="headerlink" title="2.2 namespace"></a>2.2 namespace</h3><p>namespace中的包名要和mapper中接口的包名一致,例如</p>
<p><code>&lt;mapper namespace=&quot;com.pnca.mapper.UserMapper&quot;&gt;</code></p>
<h3 id="2-3-select"><a href="#2-3-select" class="headerlink" title="2.3 select"></a>2.3 select</h3><ul>
<li><p>id : 就是就是对应namespace中方法名;</p>
</li>
<li><p>resultType: sql语句执行的返回值;</p>
</li>
<li><p>parameterType: 参数类型</p>
</li>
</ul>
<ol>
<li><p>编写接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 根据ID查询用户</span>
<span class="hljs-function">User <span class="hljs-title">getUserById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;</code></pre></div>
</li>
<li><p>编写对应的mapper中sql语句</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.pnca.pojo.User&quot;</span>&gt;</span>
    select * from mybatis.user where id = #&#123;id&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div>
</li>
<li><p>测试</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUserById</span><span class="hljs-params">()</span> </span>&#123;
    SqlSession sqlSession = MybatisUtils.getSqlSession();
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    User user = mapper.getUserById(<span class="hljs-number">1</span>);
    System.out.println(user);
    sqlSession.close();
&#125;</code></pre></div>

</li>
</ol>
<h3 id="2-4-insert"><a href="#2-4-insert" class="headerlink" title="2.4 insert"></a>2.4 insert</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.pnca.pojo.User&quot;</span>&gt;</span>
    insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)
<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div>

<h3 id="2-5-update"><a href="#2-5-update" class="headerlink" title="2.5 update"></a>2.5 update</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.pnca.pojo.User&quot;</span>&gt;</span>
    update mybatis.user
    set name = #&#123;name&#125;, pwd = #&#123;pwd&#125;
    where id = #&#123;id&#125;;
<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></div>

<h3 id="2-6-delete"><a href="#2-6-delete" class="headerlink" title="2.6 delete"></a>2.6 delete</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> &gt;</span>
    delete from mybatis.user where id = #&#123;id&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span></code></pre></div>

<p>注意点: </p>
<ul>
<li>增删改需要提交事物</li>
</ul>
<h3 id="2-7-分析错误"><a href="#2-7-分析错误" class="headerlink" title="2.7, 分析错误"></a>2.7, 分析错误</h3><ul>
<li>标签不要匹配错误</li>
<li>resource绑定mapper,需要使用路径</li>
<li>程序配置文件必须符合规范</li>
<li>NullPointerException,没有注册到资源</li>
<li>输出的xml文件中存在中文乱码问题!</li>
<li>maven资源没有导出</li>
</ul>
<h3 id="2-8-万能的Map"><a href="#2-8-万能的Map" class="headerlink" title="2.8, 万能的Map"></a>2.8, 万能的Map</h3><p> 假设,我们的实体类,或者数据库中的表,字段或者参数过多,我们应该考虑使用Map!</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser2</span><span class="hljs-params">()</span> </span>&#123;
    SqlSession sqlSession = MybatisUtils.getSqlSession();

    UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();
    map.put(<span class="hljs-string">&quot;userId&quot;</span>, <span class="hljs-number">5</span>);
    map.put(<span class="hljs-string">&quot;userName&quot;</span>, <span class="hljs-string">&quot;dsie&quot;</span>);
    map.put(<span class="hljs-string">&quot;passWord&quot;</span>, <span class="hljs-string">&quot;224438&quot;</span>);
    mapper.addUser2(map);

    <span class="hljs-comment">// 提交事物</span>
    sqlSession.commit();
    sqlSession.close();
&#125;</code></pre></div>

<p>Map传递参数,直接在sql中取出key即可!    [parameterType=”map”]</p>
<p>对象传递参数,直接在sql中取对象的属性即可!    [parameterType=”Object”]</p>
<p>只有一个基本类型参数的情况下,可以直接在sql中取到!</p>
<p>多个参数用Map,或者注解!</p>
<h3 id="2-9-思考题"><a href="#2-9-思考题" class="headerlink" title="2.9, 思考题"></a>2.9, 思考题</h3><p>模糊查询怎么写?</p>
<ol>
<li>Java代码执行的时候,传递通配符% %<div class="code-wrapper"><pre><code class="hljs java">List&lt;User&gt; userList = userMapper.getUserLike(<span class="hljs-string">&quot;%hh%&quot;</span>);</code></pre></div></li>
<li>sql拼接中使用通配符!</li>
</ol>
<h2 id="3-配置解析"><a href="#3-配置解析" class="headerlink" title="3 配置解析"></a>3 配置解析</h2><p><strong>MyBatis框架学习第3天</strong></p>
<p> <strong>Time = 2020.11.26</strong></p>
<h3 id="3-1-核心配置文件"><a href="#3-1-核心配置文件" class="headerlink" title="3.1  核心配置文件"></a>3.1  核心配置文件</h3><ul>
<li><p>mybatis-config.xml</p>
</li>
<li><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</p>
<div class="code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">configuration</span>（配置）
<span class="hljs-title">properties</span>（属性）
<span class="hljs-title">settings</span>（设置）
typeAliases（类型别名）
typeHandlers（类型处理器）
<span class="hljs-title">objectFactory</span>（对象工厂）
<span class="hljs-title">plugins</span>（插件）
<span class="hljs-title">environments</span>（环境配置）
<span class="hljs-title">environment</span>（环境变量）
<span class="hljs-title">transactionManager</span>（事务管理器）
<span class="hljs-title">dataSource</span>（数据源）
<span class="hljs-title">databaseIdProvider</span>（数据库厂商标识）
<span class="hljs-title">mappers</span>（映射器）</code></pre></div>



</li>
</ul>
<h3 id="3-2-环境配置（environments）"><a href="#3-2-环境配置（environments）" class="headerlink" title="3.2 环境配置（environments）"></a>3.2 环境配置（environments）</h3><p>MyBatis 可以配置成适应多种环境</p>
<p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p>
<p>Mybatis默认的事务管理器是: JDBC, 连接池: POOLED</p>
<h3 id="3-3-属性（properties）"><a href="#3-3-属性（properties）" class="headerlink" title="3.3 属性（properties）"></a>3.3 属性（properties）</h3><p>我们可以通过properties属性来实现引用配置文件</p>
<p>这些属性可以在外部进行配置，并可以进行动态替换。既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。[db.properties]</p>
<ol>
<li><p>编写一个配置文件</p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">driver</span>=com.mysql.cj.jdbc.Driver
<span class="hljs-attr">url</span> =jdbc:mysql://localhost:<span class="hljs-number">3306</span>/mybatis?serverTimezone=UTC&amp;amp<span class="hljs-comment">;useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8</span>
<span class="hljs-attr">username</span>=root
<span class="hljs-attr">password</span>=root</code></pre></div>
</li>
<li><p>在核心配置文件引入</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入外部配置文件--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre></div>
</li>
</ol>
<ul>
<li>​    可以直接引入外部文件</li>
<li>可以在其中增加一些属性配置</li>
<li>如果两个文件有同一个字段,优先使用外部配置文件</li>
</ul>
<h3 id="3-4-类型别名（typeAliases）"><a href="#3-4-类型别名（typeAliases）" class="headerlink" title="3.4 类型别名（typeAliases）"></a>3.4 类型别名（typeAliases）</h3><p><strong>MyBatis框架学习第4天</strong></p>
<p> <strong>Time = 2020.11.27</strong></p>
<ul>
<li>类型别名是为Java类型设置一个短的名字.</li>
<li>存在的意义仅在于用来减少类完全限定名的冗余.</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--可以给实体类起个别名--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.pnca.pojo.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;User&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre></div>

<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean,</p>
<p>扫描实体类的包,它的默认别名就为这类的类名,首字母小写!</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--可以给实体类起个别名--&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.pnca.pojo&quot;</span>/&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre></div>

<p>在实体类比较少的时候,使用第一种方式.</p>
<p>如果实体类十分多,建议使用第二种.</p>
<p>第一种可以DIY别名,第二种不行,但可以加注解别名.</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Alias(&quot;user&quot;)</span> 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123; &#125;</code></pre></div>

<h3 id="3-5-设置"><a href="#3-5-设置" class="headerlink" title="3.5 设置"></a>3.5 设置</h3><p>这是Mybatis中极为重要的调整设置,它们会改变Mybatis的运行时行为.</p>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E6%97%A5%E5%BF%97%E7%9A%84%E8%AE%BE%E7%BD%AE.png" alt="image-20201127141656440"></p>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%BC%80%E5%90%AF%E7%BC%93%E5%AD%98%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD.png" alt="image-20201127141900461"></p>
<h3 id="3-6-其他配置"><a href="#3-6-其他配置" class="headerlink" title="3.6 其他配置"></a>3.6 其他配置</h3><ul>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）<ul>
<li>mybatis-generator-core</li>
<li>mybatis-plus</li>
<li>通用mapper</li>
</ul>
</li>
</ul>
<h3 id="3-7-映射器（mappers）"><a href="#3-7-映射器（mappers）" class="headerlink" title="3.7 映射器（mappers）"></a>3.7 映射器（mappers）</h3><p>MapperRegistry: 注册绑定我们的Mapper文件;</p>
<p>方式一: [推荐使用]</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册!--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/pnca/mapper/UserMapper.xml&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div>

<p>方式二:  使用class文件绑定注册</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.mapper.UserMapper&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div>

<p>注意点:</p>
<ul>
<li>接口和他的Mapper配置文件必须同名!</li>
<li>接口和他的Mapper配置文件必须在同一个包下!</li>
</ul>
<h3 id="3-8-生命周期和作用域"><a href="#3-8-生命周期和作用域" class="headerlink" title="3.8 生命周期和作用域"></a>3.8 生命周期和作用域</h3><p><strong>MyBatis框架学习第5天</strong></p>
<p> <strong>Time = 2020.11.29</strong></p>
<p>作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong>。</p>
<h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><ul>
<li>一旦创建了 SqlSessionFactory，就不再需要它了。</li>
<li>局部变量</li>
</ul>
<h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><ul>
<li>说白了就是可以想象成: 数据库连接池。</li>
<li>一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例。</strong></li>
<li>最佳作用域是应用作用域。</li>
<li>最简单的就是使用<strong>单例模式</strong>或者<strong>静态单例模式</strong>。</li>
</ul>
<h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><ul>
<li>连接到连接池的一个请求!</li>
<li>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。</li>
<li>用完之后需要赶紧关闭,否则资源被占用!</li>
</ul>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201129134709693.png" alt="image-20201129134709693"></p>
<p>这里面的每一个Mapper,都代表一个具体的业务!</p>
<h2 id="4-解决属性名和字段名不一致的问题"><a href="#4-解决属性名和字段名不一致的问题" class="headerlink" title="4 解决属性名和字段名不一致的问题"></a>4 解决属性名和字段名不一致的问题</h2><h3 id="4-1-问题"><a href="#4-1-问题" class="headerlink" title="4.1 问题"></a>4.1 问题</h3><p><strong>MyBatis框架学习第6天</strong></p>
<p> <strong>Time = 2020.12.1</strong></p>
<p>数据库中的字段</p>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201201145442549.png" alt="image-20201201145442549"></p>
<p>新建一个项目,拷贝之前的,测试实体类字段不一致的情况</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
	<span class="hljs-keyword">private</span> String name;
	<span class="hljs-keyword">private</span> String password;</code></pre></div>

<p>测试出现问题</p>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201201152804383.png" alt="image-20201201152804383"></p>
<div class="code-wrapper"><pre><code class="hljs xml">// select * from mybatis.user where id = #&#123;id&#125;
// 类型处理器
// select id, name, pwd from mybatis.user where id = #&#123;id&#125;</code></pre></div>

<p>解决方法:</p>
<ul>
<li>取别名</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.pnca.pojo.User&quot;</span>&gt;</span>
    select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div>

<h3 id="4-1-resultMap-结果集映射"><a href="#4-1-resultMap-结果集映射" class="headerlink" title="4.1 resultMap(结果集映射)"></a>4.1 resultMap(结果集映射)</h3><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">id</span> <span class="hljs-built_in">name</span> pwd
<span class="hljs-built_in">id</span> <span class="hljs-built_in">name</span> password</code></pre></div>

<ul>
<li><p><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。</p>
</li>
<li><p>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p>
</li>
<li><p><code>ResultMap</code> 的优秀之处在于, 虽然你已经对它相当了解,但是根本就不需要你用显式地配置它们。</p>
</li>
<li><p>如果这个世界总是这么简单就好了。</p>
</li>
</ul>
<h2 id="5-日志"><a href="#5-日志" class="headerlink" title="5 日志"></a>5 日志</h2><p><strong>MyBatis框架学习第7天</strong></p>
<p> <strong>Time = 2020.12.3</strong></p>
<h3 id="5-1-日志工厂"><a href="#5-1-日志工厂" class="headerlink" title="5.1 日志工厂"></a>5.1 日志工厂</h3><p>如果一个数据库操作,出现了异常,我们需要排错,日志就是最好的助手!</p>
<p>曾经: sout, debug</p>
<p>现在: 日志工厂</p>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201201160735296.png" alt="image-20201201160735296"></p>
<ul>
<li>SLF4J </li>
<li>LOG4J [掌握]</li>
<li>LOG4J2 </li>
<li>JDK_LOGGING </li>
<li>COMMONS_LOGGING </li>
<li>STDOUT_LOGGING [掌握]</li>
<li>NO_LOGGING</li>
</ul>
<p>在Mybatis中具体使用哪一个日志实现,有设置中设定!</p>
<p>在mybatis核心配置文件中, 配置我们的日志</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre></div>

<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201201161608537.png" alt="image-20201201161608537"></p>
<h3 id="5-2-Log4j"><a href="#5-2-Log4j" class="headerlink" title="5.2 Log4j"></a>5.2 Log4j</h3><p>什么是Log4j?</p>
<ul>
<li>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/控制台/2438626">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI">GUI</a>组件;</li>
<li>我们也可以控制每一条日志的输出格式；</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</li>
<li>通过一个<a href="https://baike.baidu.com/item/配置文件/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<ol>
<li>先导入log4j的包<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>



</li>
</ol>
<ol start="2">
<li><p>配置文件</p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 将等级为DEBUG的日志信息输出到console和file这两个目的地,</span>
<span class="hljs-comment"># console和file的定义在下面的代码</span>
<span class="hljs-meta">log4j.rootLogger</span> = <span class="hljs-string">DEBUG,console,file</span>

<span class="hljs-comment"># 控制台输出的相关控制</span>
<span class="hljs-meta">log4j.appender.console</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span>
<span class="hljs-meta">log4j.appender.console.Target</span> = <span class="hljs-string">System.out</span>
<span class="hljs-meta">log4j.appender.console.Threshold</span> = <span class="hljs-string">DEBUG</span>
<span class="hljs-meta">log4j.appender.console.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span>
<span class="hljs-meta">log4j.appender.console.layout.ConversionPattern</span> = <span class="hljs-string">[%c]-%m%n</span>

<span class="hljs-comment"># 文件输出的相关设置</span>
<span class="hljs-meta">log4j.appender.file</span> = <span class="hljs-string">org.apache.log4j.RollingFileAppender</span>
<span class="hljs-meta">log4j.appender.file.File</span> = <span class="hljs-string">./org/pnca.log</span>
<span class="hljs-meta">log4j.appender.file.MaxFileSize</span> = <span class="hljs-string">10mb</span>
<span class="hljs-meta">log4j.appender.file.Threshold</span> = <span class="hljs-string">DEBUG</span>
<span class="hljs-meta">log4j.appender.file.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span>
<span class="hljs-meta">log4j.appender.file.layout.ConversionPattern</span> = <span class="hljs-string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span>

<span class="hljs-comment"># 日志输出级别</span>
<span class="hljs-meta">log4j.logger.org.mybatis</span>=<span class="hljs-string">DEBUG</span>
<span class="hljs-meta">log4j.logger.java.sql</span>=<span class="hljs-string">DEBUG</span>
<span class="hljs-meta">log4j.logger.java.sql.Statement</span>=<span class="hljs-string">DEBUG</span>
<span class="hljs-meta">log4j.logger.java.sql.ResultSet</span>=<span class="hljs-string">DEBUG</span>
<span class="hljs-meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="hljs-string">DEBUG</span></code></pre></div>
</li>
<li><p>配置log4j为日志的实现</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>
    <span class="hljs-comment">&lt;!--标准日志工厂的实现--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre></div>
</li>
<li><p>log4j的使用!直接测试用例.<br><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201203132203905.png" alt="image-20201203132203905"></p>
</li>
</ol>
<p><strong>简单使用</strong></p>
<ol>
<li><p>要在使用Log4j的类中,导入包 Logger logger = Logger.getLogger(UserMapperTest.class);</p>
</li>
<li><p>日志对象,参数为当前类的class</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Logger logger = Logger.getLogger(UserMapperTest.class);</code></pre></div>
</li>
<li><p>日志级别</p>
<div class="code-wrapper"><pre><code class="hljs java">logger.info(<span class="hljs-string">&quot;info:进入了testLog4j&quot;</span>);
logger.debug(<span class="hljs-string">&quot;debug:进入了testLog4j&quot;</span>);
logger.error(<span class="hljs-string">&quot;error:进入了testLog4j&quot;</span>);</code></pre></div>

</li>
</ol>
<h2 id="6-分页"><a href="#6-分页" class="headerlink" title="6 分页"></a>6 分页</h2><h3 id="6-1-使用Limit分页"><a href="#6-1-使用Limit分页" class="headerlink" title="6.1 使用Limit分页"></a>6.1 使用Limit分页</h3><p><strong>MyBatis框架学习第8天</strong></p>
<p> <strong>Time = 2020.12.5</strong></p>
<p><strong>思考: 为什么要分页?</strong></p>
<ul>
<li>减少数据量</li>
</ul>
<ol>
<li><p>使用Limit分页</p>
<div class="code-wrapper"><pre><code class="hljs sql">语法: <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> limit startIndex, pageSize;
<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> limit <span class="hljs-number">3</span>;	# [<span class="hljs-number">0</span>,n]</code></pre></div>
</li>
<li><p>使用Mybatis实现分页,核心SQL</p>
<ol>
<li>接口</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 分页</span>
<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByLimit</span><span class="hljs-params">(Map&lt;String,Integer&gt; map)</span></span>;</code></pre></div>
</li>
<li><p>Mapper.xml</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--分页--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByLimit&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span>
    select * from mybatis.user limit #&#123;startIndex&#125;, #&#123;pageSize&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div>

</li>
</ol>
<p>不要使用parameterMap,已经弃用</p>
<ol start="3">
<li>测试</li>
</ol>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201204162403474.png" alt="image-20201204162403474"></p>
<h3 id="6-2-使用RowBounds分页"><a href="#6-2-使用RowBounds分页" class="headerlink" title="6.2 使用RowBounds分页"></a>6.2 使用RowBounds分页</h3><div class="code-wrapper"><pre><code>不推荐,在公司使用,没有纯sql快</code></pre></div><p>​    不在使用SQL实现分页,但底层也是Sql</p>
<ol>
<li><p>接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 分页2</span>
<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByRowBounds</span><span class="hljs-params">()</span></span>;</code></pre></div></li>
<li><p>mapper.xml</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--分页2--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByRowBounds&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span>
    select * from mybatis.user
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div>
</li>
<li><p>测试<br><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201205154113990.png" alt="image-20201205154113990"></p>
</li>
</ol>
<h3 id="6-3-分页插件"><a href="#6-3-分页插件" class="headerlink" title="6.3 分页插件"></a>6.3 分页插件</h3><p>Mybatis PageHelper - 了解即可</p>
<h2 id="7-使用注解开发"><a href="#7-使用注解开发" class="headerlink" title="7 使用注解开发"></a>7 使用注解开发</h2><p><strong>MyBatis框架学习第9天</strong></p>
<p> <strong>Time = 2020.12.7</strong></p>
<h3 id="7-1-面向接口编程"><a href="#7-1-面向接口编程" class="headerlink" title="7.1 面向接口编程"></a>7.1 面向接口编程</h3><p><strong>在真正的开发中,很多时候我们选择面向接口编程.</strong></p>
<p>根本原因: 解耦,可拓展,提高复用,分层开发,上层不用管具体的实现,大家都遵守共同的标准,使得开发变得容易,规范性更好.</p>
<p><strong>关于接口的理解</strong></p>
<ul>
<li>接口从更深层次的理解,应是定义(规范,约束)与现实(名实分离)的原则.</li>
<li>抽象体,抽象面</li>
</ul>
<p><strong>三个面向区别</strong></p>
<p>面向对象是指,我们考虑问题时,以对象为单位,考虑它的属性以及方法.</p>
<p>面向过程是指,我们考虑问题时,以一个具体的流程为单位,考虑它的实现.</p>
<h3 id="7-2-使用注解开发"><a href="#7-2-使用注解开发" class="headerlink" title="7.2 使用注解开发"></a>7.2 使用注解开发</h3><p>1.注解在接口上实现<br>    <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from user&quot;)</span>
<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUsers</span><span class="hljs-params">()</span></span>;</code></pre></div></p>
<p>2.需要在核心配置文件绑定接口<br>    <div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--绑定接口--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.pnca.mapper.UserMapper&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div></p>
<p>3.测试</p>
<div class="code-wrapper"><pre><code>本质: 反射机制实现

底层: 动态代理</code></pre></div><p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201206162236349.png" alt="image-20201206162236349"></p>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Mybatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Mybatis执行流程"></p>
<h3 id="7-3-CRUD"><a href="#7-3-CRUD" class="headerlink" title="7.3 CRUD"></a>7.3 CRUD</h3><p>我们可以在工具类创建的时候设置自动提交事务!</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession(<span class="hljs-keyword">true</span>);
&#125;</code></pre></div>

<p>编写接口,增加注解</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;

   <span class="hljs-meta">@Select(&quot;select * from user&quot;)</span>
   <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUsers</span><span class="hljs-params">()</span></span>;

   <span class="hljs-comment">// 方法存在多个参数,所有参数前面必须加上:@Param(&quot;id&quot;)注解</span>
   <span class="hljs-meta">@Select(&quot;select * from user where id=#&#123;id&#125;&quot;)</span>
   <span class="hljs-function">User <span class="hljs-title">getUserByID</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;

   <span class="hljs-meta">@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;

   <span class="hljs-meta">@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id = #&#123;id&#125;&quot;)</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;

   <span class="hljs-meta">@Delete(&quot;delete from user where id=#&#123;id&#125;&quot;)</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;
&#125;</code></pre></div>

<p>测试,注意我们必须将接口注册绑定到mybatis核心配置文件中.</p>
<p><strong>关于@Param()注解</strong></p>
<ul>
<li>基本类型的参数或者String类型,需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一个基本类型,可以忽略,但是建议大家加上.</li>
<li>我们在SQL中引用的就是我们这里的@Param()设定的属性名</li>
</ul>
<p>用#{}可以防止SQL注入,${}不可以,不安全</p>
<h2 id="8-Lombok"><a href="#8-Lombok" class="headerlink" title="8 Lombok"></a>8 Lombok</h2><p><strong>MyBatis框架学习第10天</strong></p>
<p> <strong>Time = 2020.12.10</strong></p>
<p>1.在IDEA中安装Lombok</p>
<p>2.在项目中导入lombok的包</p>
<div class="code-wrapper"><pre><code><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></code></pre><p>3.使用注解</p>
<div class="code-wrapper"><pre><code>在实体类上加上注解即可.

<pre><code class="hljs java"><span class="hljs-meta">@Getter</span> and <span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@FieldNameConstants</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-meta">@EqualsAndHashCode</span>
<span class="hljs-meta">@AllArgsConstructor</span>, <span class="hljs-meta">@RequiredArgsConstructor</span> and <span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@Log</span>, <span class="hljs-meta">@Log4j</span>, <span class="hljs-meta">@Log4j2</span>, <span class="hljs-meta">@Slf4j</span>, <span class="hljs-meta">@XSlf4j</span>, <span class="hljs-meta">@CommonsLog</span>, <span class="hljs-meta">@JBossLog</span>, <span class="hljs-meta">@Flogger</span>, <span class="hljs-meta">@CustomLog</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@SuperBuilder</span>
<span class="hljs-meta">@Singular</span>
<span class="hljs-meta">@Delegate</span>
<span class="hljs-meta">@Value</span>
<span class="hljs-meta">@Accessors</span>
<span class="hljs-meta">@Wither</span>
<span class="hljs-meta">@With</span>
<span class="hljs-meta">@SneakyThrows</span>
<span class="hljs-meta">@val</span>
<span class="hljs-meta">@var</span>
experimental <span class="hljs-meta">@var</span>
<span class="hljs-meta">@UtilityClass</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span>: 无参构造,get,set,toString,hashCode,equuals</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@AllArgsConstructor</span></code></pre></div></code></pre><p>4.能少用,就少用</p>
<h2 id="9-多对一处理"><a href="#9-多对一处理" class="headerlink" title="9 多对一处理"></a>9 多对一处理</h2><p><strong>MyBatis框架学习第11天</strong></p>
<p> <strong>Time = 2020.12.12</strong></p>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201212160301928.png" alt="image-20201212160301928"></p>
<ul>
<li>多个学生，对应一个老师</li>
<li>对于学生这边而言，关联..多个学生，关联一个老师【多对一】</li>
<li>对于老师而言，集合，一个老师，由很多学生【一对多】</li>
</ul>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201212163521289.png" alt="image-20201212163521289"></p>
<h4 id="1-测试环境搭建"><a href="#1-测试环境搭建" class="headerlink" title="1, 测试环境搭建"></a>1, 测试环境搭建</h4><ol>
<li>导入lombok</li>
<li>新建实体类Teacher, Student</li>
<li>建立Mapper接口</li>
<li>建立Mapper.xml文件</li>
<li>在核心配置文件中绑定注册我们的Mapper接口或文件!方式很多</li>
<li>测试查询是否能够成功</li>
</ol>
<h4 id="2-按照查询嵌套处理"><a href="#2-按照查询嵌套处理" class="headerlink" title="2, 按照查询嵌套处理"></a>2, 按照查询嵌套处理</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudent&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span>&gt;</span>
		select * from mybatis.student
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
	
<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>

    <span class="hljs-comment">&lt;!--复杂属性,我们需要单独处理, 对象: association, 集合: collection--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getTeacher&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span>
    select * from mybatis.teacher where id = #&#123;id&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div>

<h4 id="3-按照结果嵌套处理"><a href="#3-按照结果嵌套处理" class="headerlink" title="3, 按照结果嵌套处理"></a>3, 按照结果嵌套处理</h4><p>​    </p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudent2&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher2&quot;</span>&gt;</span>
    select s.id sid, s.name sname, t.name tname
    from mybatis.student s, mybatis.teacher t
    where s.tid = t.id;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
	
<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre></div>

<p>回顾Mysql多对一查询</p>
<h2 id="10-一对多处理"><a href="#10-一对多处理" class="headerlink" title="10 一对多处理"></a>10 一对多处理</h2><p><strong>MyBatis框架学习第12天</strong></p>
<p> <strong>Time = 2020.12.14</strong></p>
<ul>
<li>一个老师有多个学生</li>
<li>对于老师而言，就是一对多的关系</li>
</ul>
<h3 id="1-环境搭建-和刚才一样"><a href="#1-环境搭建-和刚才一样" class="headerlink" title="1 环境搭建,和刚才一样"></a>1 环境搭建,和刚才一样</h3><p>实体类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
	<span class="hljs-keyword">private</span> String name;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tid;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
	<span class="hljs-keyword">private</span> String name;
	<span class="hljs-comment">// 一个老师拥有多个学生</span>
	<span class="hljs-keyword">private</span> List&lt;Student&gt; students;
&#125;</code></pre></div>

<h3 id="2-按照结果嵌套处理"><a href="#2-按照结果嵌套处理" class="headerlink" title="2, 按照结果嵌套处理"></a>2, 按照结果嵌套处理</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--按结果嵌套查询--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span>&gt;</span>
	select s.id sid, s.name sname, t.name tname, t.id tid
	from mybatis.student s, mybatis.teacher t
	where s.tid = t.id and t.id = #&#123;tid&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span>
	<span class="hljs-comment">&lt;!--复杂属性,我们需要单独处理, 对象: association, 集合: collection--&gt;</span>
	<span class="hljs-comment">&lt;!--javaType=&quot;&quot; 指定属性的类型--&gt;</span>
	<span class="hljs-comment">&lt;!--集合中的泛型信息,我们使用ofType获取--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre></div>



<h3 id="3-按照查询嵌套处理"><a href="#3-按照查询嵌套处理" class="headerlink" title="3, 按照查询嵌套处理"></a>3, 按照查询嵌套处理</h3><div class="code-wrapper"><pre><code class="hljs xml-dtd">&lt;!--按照查询嵌套处理--&gt;
	&lt;select id&#x3D;&quot;getTeacher2&quot; resultMap&#x3D;&quot;TeacherStudent2&quot;&gt;
		select * from mybatis.teacher where id &#x3D; #&#123;tid&#125;
	&lt;&#x2F;select&gt;
	
	&lt;resultMap id&#x3D;&quot;TeacherStudent2&quot; type&#x3D;&quot;Teacher&quot;&gt;
		&lt;collection property&#x3D;&quot;students&quot; javaType&#x3D;&quot;ArrayList&quot; ofType&#x3D;&quot;Student&quot; select&#x3D;&quot;getStudentByTeacherId&quot; column&#x3D;&quot;id&quot;&#x2F;&gt;
	&lt;&#x2F;resultMap&gt;
	&lt;select id&#x3D;&quot;getStudentByTeacherId&quot; resultType&#x3D;&quot;Student&quot;&gt;
		select * from mybatis.student where tid &#x3D; #&#123;id&#125;
	&lt;&#x2F;select&gt;</code></pre></div>

<p><strong>小节</strong></p>
<div class="code-wrapper"><pre><code>1. 关联-association 【多对一】
2. 集合-collection 【一对多】
3. javaType &amp; ofType
      1. javaType 用来指定实体类中属性的类型
      2. ofType 用来指定映射到List或者集合中pojo类型，泛型中的约束类型！</code></pre></div><p>注意点</p>
<ul>
<li>保证SQL的可读性，尽量保证通俗易懂</li>
<li>注意一对多和多对一，属性名和字段的问题</li>
<li>如果问题不好排查，可以使用日志，建议Log4j</li>
</ul>
<p>避免慢SQL</p>
<p>面试高频</p>
<ul>
<li>Mysql引擎</li>
<li>InnoDB底层原理</li>
<li>索引</li>
<li>索引优化</li>
</ul>
<h2 id="11-动态SQL"><a href="#11-动态SQL" class="headerlink" title="11 动态SQL"></a>11 动态SQL</h2><p><strong>MyBatis框架学习第13天</strong></p>
<p> <strong>Time = 2020.12.16</strong></p>
<p>什么是动态SQL: 动态SQL就是根据不同的条件生成不同的SQL语句</p>
<div class="code-wrapper"><pre><code class="hljs pgsql">如果你之前用过 JSTL 或任何基于类 <span class="hljs-type">XML</span> 语言的文本处理器，你对动态 <span class="hljs-keyword">SQL</span> 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis <span class="hljs-number">3</span> 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。

-   <span class="hljs-keyword">if</span>
-   choose (<span class="hljs-keyword">when</span>, otherwise)
-   trim (<span class="hljs-keyword">where</span>, <span class="hljs-keyword">set</span>)
-   <span class="hljs-keyword">foreach</span></code></pre></div>

<p>搭建环境</p>
<p>创建一个基础工程</p>
<ol>
<li><p>导包</p>
</li>
<li><p>编写配置文件</p>
</li>
<li><p>编写实体类</p>
 <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blog</span> </span>&#123;
	<span class="hljs-keyword">private</span> String id;
	<span class="hljs-keyword">private</span> String title;
	<span class="hljs-keyword">private</span> String author;
	<span class="hljs-keyword">private</span> Date createTime;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> views;
&#125;</code></pre></div>
</li>
<li><p>编写实体类对应的Mapper接口和Mapper.xml文件</p>
</li>
</ol>
<h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogIF&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span>
    select * from mybatis.blog where 1 = 1
    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span>
        and title = #&#123;title&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span>
        and author = #&#123;author&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div>

<h3 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose (when, otherwise)"></a>choose (when, otherwise)</h3><div class="code-wrapper"><pre><code class="hljs xml-dtd">&lt;choose&gt;
    &lt;when test&#x3D;&quot;title !&#x3D; null&quot;&gt;
    	and title like #&#123;title&#125;
    &lt;&#x2F;when&gt;

    &lt;when test&#x3D;&quot;author !&#x3D; null&quot;&gt;
    	and author &#x3D; #&#123;author&#125;
    &lt;&#x2F;when&gt;

    &lt;otherwise&gt;
    	and views &#x3D; #&#123;views&#125;
    &lt;&#x2F;otherwise&gt;
&lt;&#x2F;choose&gt;</code></pre></div>



<h3 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim (where, set)"></a>trim (where, set)</h3><div class="code-wrapper"><pre><code class="hljs xml-dtd">select * from mybatis.blog
&lt;where&gt;
    &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;
    	and title &#x3D; #&#123;title&#125;
    &lt;&#x2F;if&gt;
    &lt;if test&#x3D;&quot;author !&#x3D; null&quot;&gt;
    	and author &#x3D; #&#123;author&#125;
    &lt;&#x2F;if&gt;
&lt;&#x2F;where&gt;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBlog&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span>
    update mybatis.blog
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span>
            title = #&#123;title&#125;,
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span>
            author = #&#123;author&#125;
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>
    where id = #&#123;id&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></div>

<p><strong>所谓的动态SQL,本质还是SQL语句,只是我们可以在SQL层面,去执行一个逻辑代码</strong></p>
<h3 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h3><p>有的时候,我们可能会将一些功能的部分抽取出来,方便复用!</p>
<ol>
<li><p>使用SQL标签抽取公共部分</p>
 <div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;if-title-author&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span>
    	and title = #&#123;title&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span>
    	and author = #&#123;author&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span></code></pre></div>
</li>
<li><p>在需要使用的地方使用include标签引用即可</p>
 <div class="code-wrapper"><pre><code class="hljs xml">select * from mybatis.blog
<span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;if-title-author&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span></code></pre></div>

</li>
</ol>
<p>注意事项:</p>
<ul>
<li>最好基于单表来定义SQL片段</li>
<li>不要存在where标签</li>
</ul>
<h3 id="Foreach"><a href="#Foreach" class="headerlink" title="Foreach"></a>Foreach</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogForeach&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span>
    select * from mybatis.blog
    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;and (&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span>
            id = #&#123;id&#125;
        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div>

<p><strong>动态SQL就是在拼接SQL语句,我们只要保证SQL正确性,按照SQL格式,去排列组合就可以了!</strong></p>
<p>建议:</p>
<ul>
<li>在Mysql中写出完整的sql,然后再去修改.</li>
</ul>
<h2 id="12-缓存"><a href="#12-缓存" class="headerlink" title="12 缓存"></a>12 缓存</h2><p><strong>MyBatis框架学习第14天</strong></p>
<p> <strong>Time = 2020.12.18</strong></p>
<h3 id="12-1-简介"><a href="#12-1-简介" class="headerlink" title="12.1 简介"></a>12.1 简介</h3><ol>
<li>什么是缓存[Cache]<ul>
<li>存在内存中的临时数据。</li>
<li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，提高查询效率，解决高并发系统的性能问题。</li>
</ul>
</li>
<li>为什么使用缓存？<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li>
</ul>
</li>
<li>什么样的数据使用缓存？<ul>
<li>经常查询并且不经常改变的数据，可以使用缓存。</li>
</ul>
</li>
</ol>
<h3 id="13-2-Mybatis缓存"><a href="#13-2-Mybatis缓存" class="headerlink" title="13.2 Mybatis缓存"></a>13.2 Mybatis缓存</h3><ul>
<li>Mybatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存，缓存可以极大的提高查询效率。</li>
<li>Mybatis 系统中默认定义了两级缓存： <strong>一级缓存</strong>和<strong>二级缓存</strong><ul>
<li>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）</li>
<li>二级缓存需要手动开启和配置，它是基于namsespace级别的缓存</li>
<li>为了提高扩展性，Mybatis定义了缓存接口Cache，我们可以通过Cache接口来定义二级缓存</li>
</ul>
</li>
</ul>
<h3 id="12-3-一级缓存"><a href="#12-3-一级缓存" class="headerlink" title="12.3  一级缓存"></a>12.3  一级缓存</h3><ul>
<li><p>一级缓存也叫本地缓存</p>
<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库；</li>
</ul>
</li>
<li><p>测试步骤：</p>
<ol>
<li><p>开启日志！</p>
</li>
<li><p>测试在一个Session中查询两次相同的记录!</p>
</li>
<li><p>查看日志输出</p>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201218141015726.png" alt="image-20201218141015726"></p>
</li>
</ol>
</li>
<li><p>缓存失效的情况：</p>
<ol>
<li><p>查询不同的东西</p>
</li>
<li><p>增删改操作，可能会改变原来的数据，所以必定会刷新缓存</p>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201218141946798.png" alt="image-20201218141946798"></p>
</li>
<li><p>查询不同的Mapper.xml</p>
</li>
<li><p>手动清理缓存</p>
<p><img src="/2020/11/20/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20201218142057925.png" alt="image-20201218142057925"></p>
</li>
</ol>
</li>
<li><p>小结： 一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接关闭连接这个区间！</p>
</li>
</ul>
<h3 id="12-4-二级缓存"><a href="#12-4-二级缓存" class="headerlink" title="12.4  二级缓存"></a>12.4  二级缓存</h3><p><strong>MyBatis框架学习第15天</strong></p>
<p> <strong>Time = 2020.12.22</strong></p>
<ul>
<li>二级缓存也叫全局缓存,一级缓存作用域太低了,所以诞生了二级缓存;</li>
<li>基于namespace级别的缓存,一个名称空间,对应一个二级缓存;</li>
<li>工作机制<ul>
<li>一个会话查询一条数据,这个数据就会被放在当前会话的一级缓存中;</li>
<li>如果当前会话关闭了,这个会话对应的一级缓存就没了;但是我们想要的是,会话关闭了,一级缓存中的数据被保存到二级缓存中;</li>
<li>新的会话查询消息,就可以从二级缓存中获取内容;</li>
<li>不同的mapper查出的数据会放在自己对应的缓存(map)中;</li>
</ul>
</li>
</ul>
<p>步骤:</p>
<p>1.开启全局缓存</p>
<div class="code-wrapper"><pre><code><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--显示开启全局缓存--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnable&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span></code></pre></div></code></pre><p>2.在要使用二级缓存的mapper开启</p>
<div class="code-wrapper"><pre><code><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在当前mapper.xml开启二级缓存--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span></code></pre></div>

也可以自定义参数

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在当前mapper.xml开启二级缓存--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span></code></pre></div></code></pre><p>3.测试</p>
<div class="code-wrapper"><pre><code>1.  问题: 我们需要将实体类序列化!否则就会报错!

    <pre><code class="hljs java">Caused by: java.io.NotSerializableException: com.pnca.pojo.User</code></pre></div></code></pre><p>小结:</p>
<ul>
<li><p>只要开启了二级缓存,在同一个Mapper下就有效</p>
</li>
<li><p>所有数据都会先放在一级缓存中;</p>
</li>
<li><p>只要当会话提交,或者关闭的时候,才会提交到二级缓存</p>
</li>
</ul>
<h3 id="12-5-缓存原理"><a href="#12-5-缓存原理" class="headerlink" title="12.5 缓存原理"></a>12.5 缓存原理</h3><p>缓存顺序</p>
<ol>
<li>先看二级缓存中有没有</li>
<li>再看一级缓存中有没有</li>
<li>查询数据库</li>
</ol>
<h3 id="12-6-自定义缓存"><a href="#12-6-自定义缓存" class="headerlink" title="12.6 自定义缓存"></a>12.6 自定义缓存</h3><p><strong>MyBatis框架学习第16天</strong></p>
<p> <strong>Time = 2020.12.24</strong></p>
<p>Ehcache是一种广泛使用的开源的Java分布式缓存。主要面向通用缓存。</p>
<p>要在程序中使用，需要导包。</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.caches<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>配置文件</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:noNamespaceSchemaLocation</span>=<span class="hljs-string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">updateCheck</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
	<span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">	   diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：</span>
<span class="hljs-comment">	   user.home – 用户主目录</span>
<span class="hljs-comment">	   user.dir  – 用户当前工作目录</span>
<span class="hljs-comment">	   java.io.tmpdir – 默认临时文件路径</span>
<span class="hljs-comment">	 --&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;./tmpdir/Tmp_EhCache&quot;</span>/&gt;</span>
	<span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">	   defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。</span>
<span class="hljs-comment">	 --&gt;</span>
	<span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">	  name:缓存名称。</span>
<span class="hljs-comment">	  maxElementsInMemory:缓存最大数目</span>
<span class="hljs-comment">	  maxElementsOnDisk：硬盘最大缓存个数。</span>
<span class="hljs-comment">	  eternal:对象是否永久有效，一但设置了，timeout将不起作用。</span>
<span class="hljs-comment">	  overflowToDisk:是否保存到磁盘，当系统宕机时</span>
<span class="hljs-comment">	  timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</span>
<span class="hljs-comment">	  timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</span>
<span class="hljs-comment">	  diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</span>
<span class="hljs-comment">	  diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</span>
<span class="hljs-comment">	  diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</span>
<span class="hljs-comment">	  memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</span>
<span class="hljs-comment">	  clearOnFlush：内存数量最大时是否清除。</span>
<span class="hljs-comment">	  memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。</span>
<span class="hljs-comment">	  FIFO，first in first out，这个是大家最熟的，先进先出。</span>
<span class="hljs-comment">	  LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。</span>
<span class="hljs-comment">	  LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。</span>
<span class="hljs-comment">   --&gt;</span>
	&lt;defaultCache
			eternal=&quot;false&quot;
			maxElementsInMemory=&quot;10000&quot;
			overflowToDisk=&quot;false&quot;
			diskPersistent=&quot;false&quot;
			timeToIdleSeconds=&quot;1800&quot;
			timeToLiveSeconds=&quot;259200&quot;
			memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;
	
	&lt;cache
			name=&quot;cloud_user&quot;
			eternal=&quot;false&quot;
			maxElementsInMemory=&quot;5000&quot;
			overflowToDisk=&quot;false&quot;
			diskPersistent=&quot;false&quot;
			timeToIdleSeconds=&quot;1800&quot;
			timeToLiveSeconds=&quot;1800&quot;
			memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;

<span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span></code></pre></div>

]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>JavaWeb 学习</title>
    <url>/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="JavaWeb-学习"><a href="#JavaWeb-学习" class="headerlink" title="JavaWeb 学习"></a>JavaWeb 学习</h1><h2 id="1-Tomcat"><a href="#1-Tomcat" class="headerlink" title="1, Tomcat"></a>1, Tomcat</h2><p> <strong>JavaWeb第1天</strong></p>
<p><strong>date: 2020.11.22</strong></p>
<h4 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h4><p>tomcat官网: <a href="http://tomcat.apache.org/index.html">Apache Tomcat® - Welcome!</a></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/tomcat%E4%B8%8B%E8%BD%BD.png" alt="image-20201122174747037"></p>
<p>下载完之后,解压至你想要安装的目录</p>
<h4 id="1-2-Tomcat的启动和配置"><a href="#1-2-Tomcat的启动和配置" class="headerlink" title="1.2 Tomcat的启动和配置"></a>1.2 Tomcat的启动和配置</h4><ol>
<li><p>文件夹的作用<br><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/tomcat%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6-1608621650571.png" alt="image-20201122170613953"></p>
</li>
<li><p>启动和关闭Tomcat<br><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/tomcat%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD-1608621650571.png" alt="tomcat启动和关闭"></p>
</li>
<li><p>访问测试: </p>
</li>
</ol>
<h4 id="1-3-配置"><a href="#1-3-配置" class="headerlink" title="1.3 配置"></a>1.3 配置</h4><p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/tomcat%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="image-20201122175818558"></p>
<ul>
<li><p>可以配置启动的端口号</p>
<ul>
<li><p>tomcat的默认端口号为: 8080</p>
</li>
<li><p>mysql: 3306</p>
</li>
<li><p>http: 80</p>
</li>
<li><p>https: 443</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span>
<span class="hljs-tag">           <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span>
<span class="hljs-tag">           <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span></code></pre></div>
</li>
</ul>
</li>
<li><p>可以配置主机的名称</p>
<ul>
<li>默认的主机名为: localhost - &gt; 127.0.0.1</li>
<li>默认的网站应用存放的位置: webapps</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localhost&quot;</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">&quot;webapps&quot;</span></span>
<span class="hljs-tag">      <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span></code></pre></div>
</li>
<li><p>可以配置一下环境变量</p>
<h5 id="题外话-网站是如何进行访问的"><a href="#题外话-网站是如何进行访问的" class="headerlink" title="题外话: 网站是如何进行访问的"></a>题外话: 网站是如何进行访问的</h5><ol>
<li><p>输入一个域名; 回车</p>
</li>
<li><p>检查本机的 C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射;</p>
<ol>
<li>有: 直接返回对应的ip地址,这个地址中,有我们需要访问的web程序,可以直接访问 127.0.0.1    <a href="http://www.baidu.com">www.baidu.com</a></li>
<li>没有: 去DNS服务器找,找到的话就返回,找不到就返回找不到<br><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="image-20201123000028908"></li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="1-4-发布一个Web网站"><a href="#1-4-发布一个Web网站" class="headerlink" title="1.4 发布一个Web网站"></a>1.4 发布一个Web网站</h4><p>将自己写发网站,放到服务器(Tomcat)中指定的web应用的文件夹(webapps)下,就可以访问网站应该有的结构</p>
<div class="code-wrapper"><pre><code class="hljs haml">-<span class="ruby">--webapps : Tomcat服务器的web目录</span>
<span class="ruby">	-ROOT</span>
<span class="ruby">	-Study</span>
<span class="ruby">	-WEB-INF</span>
<span class="ruby">			-<span class="hljs-symbol">Classes:</span> java程序</span>
<span class="ruby">			-<span class="hljs-symbol">lib:</span> web应用所依赖的jar包</span>
<span class="ruby">		-index.html 默认的首页</span>
<span class="ruby">		-static</span>
<span class="ruby">			-css</span>
<span class="ruby">				-style.css</span>
<span class="ruby">			-js</span>
<span class="ruby">			-img</span>
<span class="ruby">		-...</span></code></pre></div>

<p>HTTP协议: 面试</p>
<p>Maven: 构建工具</p>
<ul>
<li><p>Maven安装包</p>
<p>Servlet 入门</p>
</li>
<li><p>HelloWorld!</p>
</li>
<li><p>Servlet配置</p>
</li>
<li><p>原理</p>
</li>
</ul>
<h2 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2, HTTP"></a>2, HTTP</h2><p> <strong>JavaWeb第2天</strong></p>
<p><strong>date: 2020.11.24</strong></p>
<h3 id="2-1-是什么http"><a href="#2-1-是什么http" class="headerlink" title="2.1 是什么http"></a>2.1 是什么http</h3><p>HTTP(超文本传输协议)是一个简单的请求-响应协议，它通常运行在TCP之上</p>
<ul>
<li>文本: html, 字符串 …</li>
<li>超文本: 图片, 音乐, 视频, 定位, 地图 …</li>
</ul>
<p>Https:　安全的</p>
<ul>
<li>443</li>
</ul>
<h3 id="2-2-两个时代"><a href="#2-2-两个时代" class="headerlink" title="2.2 两个时代"></a>2.2 两个时代</h3><ul>
<li>http1.0<ul>
<li>HTTP/1.0: 客户端与web服务器连接后,只能获取一个web资源,断开连接</li>
</ul>
</li>
<li>http2.0<ul>
<li>HTTP/1.1: 客户端与web服务器连接后, 可以获取多个web资源</li>
</ul>
</li>
</ul>
<h3 id="2-3-Http请求"><a href="#2-3-Http请求" class="headerlink" title="2.3 Http请求"></a>2.3 Http请求</h3><ul>
<li>客户端—发请求(Request)— 服务器</li>
<li></li>
</ul>
<p>百度:</p>
<div class="code-wrapper"><pre><code class="hljs oxygene">Request URL: https:<span class="hljs-comment">//www.baidu.com	请求地址</span>
Request <span class="hljs-function"><span class="hljs-keyword">Method</span>:</span> GET		get方法/post方法
Status Code: <span class="hljs-number">200</span> OK		状态码: <span class="hljs-number">200</span>
Remote Address: <span class="hljs-number">14.215</span>.<span class="hljs-number">177.38</span>:<span class="hljs-number">443</span>	远程地址</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">Accept: text/html</span>
<span class="hljs-section">Accept-Encoding: gzip, deflate, br</span>
<span class="hljs-section">Accept-Language: zh-CN,zh;q=0.9</span>
<span class="hljs-section">Cache-Control:max-age=0</span>
<span class="hljs-section">Connection: keep-alive</span></code></pre></div>

<h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1, 请求行"></a>1, 请求行</h4><ul>
<li>请求行的请求方式: GET</li>
<li>请求方式: <strong>GET</strong>, <strong>POST</strong>, HEAD, DELETE, TRACT <ul>
<li>get: 请求能够携带的参数比较少,大小有限制,会在浏览器的URL地址栏显示数据内容,不安全,但高效</li>
<li>post: 请求能够携带的参数没有限制,大小没有限制,不会在浏览器的URL地址栏显示数据内容,安全,但不高效</li>
</ul>
</li>
</ul>
<h4 id="2-消息头"><a href="#2-消息头" class="headerlink" title="2, 消息头"></a>2, 消息头</h4><div class="code-wrapper"><pre><code class="hljs ldif"><span class="hljs-attribute">Accept</span>: 告诉浏览器,它所支持的数据类型
<span class="hljs-attribute">Accept-Encoding</span>: 支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1
<span class="hljs-attribute">Accept-Language</span>: 告诉浏览器,它的语言环境
<span class="hljs-attribute">Cache-Control:max-age=0</span>: 缓存控制
<span class="hljs-attribute">Connection</span>: 告诉浏览器,请求完成是断开还是保持连接
<span class="hljs-attribute">Host</span>: 主机</code></pre></div>

<h3 id="2-4-http响应"><a href="#2-4-http响应" class="headerlink" title="2.4 http响应"></a>2.4 http响应</h3><ul>
<li>服务器—响应— 客户端</li>
</ul>
<p>百度: </p>
<div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">Cache-Control: private	缓存控制</span>
<span class="hljs-section">Connection: keep-alive	连接</span>
<span class="hljs-section">Content-Encoding: gzip	编码类型</span>
<span class="hljs-section">Content-Type:text/html	类型</span></code></pre></div>

<h4 id="1-响应体"><a href="#1-响应体" class="headerlink" title="1, 响应体"></a>1, 响应体</h4><div class="code-wrapper"><pre><code class="hljs ldif"><span class="hljs-attribute">Accept</span>: 告诉浏览器,它所支持的数据类型
<span class="hljs-attribute">Accept-Encoding</span>: 支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1
<span class="hljs-attribute">Accept-Language</span>: 告诉浏览器,它的语言环境
<span class="hljs-attribute">Cache-Control:max-age=0</span>: 缓存控制
<span class="hljs-attribute">Connection</span>: 告诉浏览器,请求完成是断开还是保持连接
<span class="hljs-attribute">Host</span>: 主机
<span class="hljs-attribute">Refrush</span>: 告诉客户端,多久刷新一次
<span class="hljs-attribute">Location</span>: 让网页重新定位</code></pre></div>

<h4 id="2-响应状态码"><a href="#2-响应状态码" class="headerlink" title="2, 响应状态码"></a>2, 响应状态码</h4><p>200: 请求响应成功 200</p>
<p>3**: 请求重定向</p>
<ul>
<li>重定向: 你重新到我给你的新位置去</li>
</ul>
<p>4xx: 找不到资源 404</p>
<ul>
<li>资源不存在</li>
</ul>
<p>5xx: 服务器代码错 500 502: 网关错误</p>
<p><strong>常见面试题</strong></p>
<p>当你的浏览器中地址栏输入并回车的一瞬间到页面能够展示回来,经历了什么?</p>
<h2 id="3-Maven"><a href="#3-Maven" class="headerlink" title="3, Maven"></a>3, Maven</h2><p> <strong>JavaWeb第3天</strong></p>
<p><strong>date: 2020.11.26</strong></p>
<p><strong>我为什么要学习这个技术</strong></p>
<ol>
<li>在Java web开发中,需要使用大量的jar包,我们手动去导入;</li>
<li>如何能够让一个东西自动帮我导入和配置这个jar包.<br>由此,Maven诞生了</li>
</ol>
<h3 id="3-1-Maven项目架构管理工具"><a href="#3-1-Maven项目架构管理工具" class="headerlink" title="3.1 Maven项目架构管理工具"></a>3.1 Maven项目架构管理工具</h3><p>我们目前用来就是方便的导入jar包!</p>
<p>Maven的核心思想: <strong>约定大于配置</strong></p>
<ul>
<li>有约束,不要去违反</li>
</ul>
<p>Maven会规定好你如何去编写我们的Java代码,必须要按照这个规范;</p>
<h3 id="3-2-下载安装Maven"><a href="#3-2-下载安装Maven" class="headerlink" title="3.2 下载安装Maven"></a>3.2 下载安装Maven</h3><p>官网: <a href="https://maven.apache.org/">Maven – Welcome to Apache Maven</a></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/Maven%E4%B8%8B%E8%BD%BD.png" alt="image-20201126124710642"></p>
<p>下载完成后,解压即可</p>
<p>电脑上的环境,最后都放在一个文件夹里</p>
<h3 id="3-3-配置环境变量"><a href="#3-3-配置环境变量" class="headerlink" title="3.3 配置环境变量"></a>3.3 配置环境变量</h3><p>在我们的系统环境变量中</p>
<p>配置如下配置:</p>
<ul>
<li>M2_HOME     maven目录下的bin目录</li>
<li>MAVEN_HOME  maven目录</li>
</ul>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/maven%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.png" alt="image-20201126125928904"></p>
<p>测试Maven是否安装成功,保证必须配置完毕!</p>
<h3 id="3-4-阿里云镜像"><a href="#3-4-阿里云镜像" class="headerlink" title="3.4 阿里云镜像"></a>3.4 阿里云镜像</h3><ul>
<li>镜像: mirrors<ul>
<li>作用: 加速我们的下载</li>
</ul>
</li>
<li>国内建议使用阿里云的镜像</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*,!jeecg,!jeecg-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
                                			<span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre></div>

<h3 id="3-5-本地仓库"><a href="#3-5-本地仓库" class="headerlink" title="3.5 本地仓库"></a>3.5 本地仓库</h3><p>在本地的仓库,运程仓库;</p>
<p>建立一个本地仓库: localRepository</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\PNCA\environment\apache-maven-3.6.3\maven_repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre></div>

<h3 id="3-6-在IDEA中使用Maven"><a href="#3-6-在IDEA中使用Maven" class="headerlink" title="3.6 在IDEA中使用Maven"></a>3.6 在IDEA中使用Maven</h3><p> <strong>JavaWeb第4天</strong></p>
<p><strong>date: 2020.11.27</strong></p>
<ol>
<li>启动IDEA</li>
<li>创建一个Maven项目<br><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAMavenWeb%E9%A1%B9%E7%9B%AE.png" alt="image-20201127145100090"></li>
</ol>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201127145306228.png" alt="image-20201127145306228"></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201127145626430.png" alt="image-20201127145626430"></p>
<ol start="3">
<li><p>等待项目初始化完毕</p>
</li>
<li><p>观察Maven仓库多了什么东西?</p>
</li>
<li><p>IDEA中Maven设置<br>注意: IDEA项目创建成功后,看一眼Maven的配置,</p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/IDEA%E4%B8%ADMaven%E9%85%8D%E7%BD%AE.png" alt="image-20201127170603154"></p>
</li>
<li><p>到这里,Maven在IDEA中的配置和使用就OK了!</p>
</li>
</ol>
<h3 id="3-7-创建一个普通的Maven项目"><a href="#3-7-创建一个普通的Maven项目" class="headerlink" title="3.7 创建一个普通的Maven项目"></a>3.7 创建一个普通的Maven项目</h3><p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/%E6%99%AE%E9%80%9A%E7%9A%84Maven%E7%9B%AE%E5%BD%95.png" alt="image-20201127175143915"></p>
<p>这个只有在Web应用下才有1</p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/Web%E9%85%8D%E7%BD%AE.png" alt="image-20201127175510963"></p>
<h3 id="3-8-标记文件夹功能"><a href="#3-8-标记文件夹功能" class="headerlink" title="3.8 标记文件夹功能"></a>3.8 标记文件夹功能</h3><p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201127175908458.png" alt="image-20201127175908458"></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/%E6%A0%87%E8%AE%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8A%9F%E8%83%BD.png" alt="image-20201127180238889"></p>
<h3 id="3-9-在IDEA中配置Tomcat"><a href="#3-9-在IDEA中配置Tomcat" class="headerlink" title="3.9 在IDEA中配置Tomcat"></a>3.9 在IDEA中配置Tomcat</h3><p> <strong>JavaWeb第5天</strong></p>
<p><strong>date: 2020.11.29</strong></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201127180621196.png" alt="image-20201127180621196"></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201127180711490.png" alt="image-20201127180711490"></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201127181610015.png" alt="image-20201127181610015"></p>
<p>解决警告问题<br>必须要配置: <strong>为什么会有这个问题: 我们访问一个网站,需要指定一个文件夹名字;</strong></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201127181728157.png" alt="image-20201127181728157"></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201127182350573.png" alt="image-20201127182350573"></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201127182613164.png" alt="image-20201127182613164"></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201127235920783.png" alt="image-20201127235920783"></p>
<h3 id="3-10-pom文件"><a href="#3-10-pom文件" class="headerlink" title="3.10 pom文件"></a>3.10 pom文件</h3><p>pom.xml是Maven的核心配置文件</p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/Maven%E7%9A%84pom%E6%96%87%E4%BB%B6.png" alt="image-20201128210845128"></p>
<p>由于在IDEA的Maven项目中新建一个模块,它的Language Level总是自动变到5,所以可以在pom.xml加入下面的</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
<span class="hljs-comment">&lt;!--                    下面的source和target的版本要跟自己的jdk版本一样--&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>14<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>14<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--项目构建用的东西--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>javaWeb_01_Maven<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
          <span class="hljs-comment">&lt;!--下面的source和target的版本要跟自己的jdk版本一样--&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div>

<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/Maven%E7%9A%84%E4%BE%9D%E8%B5%96.png" alt="image-20201128220121858"></p>
<p>maven由于他的约定大于配置,我们之后可能遇到我们写的配置文件,无法被导出或者生效的问题,解决方案:</p>
<div class="code-wrapper"><pre><code class="hljs xml">    <span class="hljs-comment">&lt;!--在build中配置resources,来防止我们资源导出失败的问题--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div>

<h3 id="3-12-IDEA操作"><a href="#3-12-IDEA操作" class="headerlink" title="3.12 IDEA操作"></a>3.12 IDEA操作</h3><p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/maven%E7%9A%84%E4%BE%9D%E8%B5%96%E6%A0%91.png" alt="image-20201129132913845"></p>
<h3 id="3-13-解决遇到的问题"><a href="#3-13-解决遇到的问题" class="headerlink" title="3.13 解决遇到的问题"></a>3.13 解决遇到的问题</h3><p> <strong>JavaWeb第6天</strong></p>
<p><strong>date: 2020.12.1</strong></p>
<ol>
<li><p>Maven 3.6.2 不能导包</p>
</li>
<li><p>Tomcat闪退</p>
</li>
<li><p>IDEA中每次都要重复Maven</p>
<ul>
<li><p>在IDEA中全局默认配置中去配置</p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201201163402800.png" alt="image-20201201163402800"></p>
</li>
</ul>
</li>
<li><p>Maven项目中Tomcat无法配置</p>
</li>
<li><p>Maven项目Web项目中的web.xml版本问题<br><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201201164251107.png" alt="image-20201201164251107"></p>
</li>
<li><p>替换为webapps4.0版本和tomcat一致</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span>
<span class="hljs-tag"><span class="hljs-string">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">metadata-complete</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre></div>



</li>
</ol>
<p><a href="https://mvnrepository.com/search?q=servlet+api">Maven Repository: servlet api (mvnrepository.com)</a></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201201170540169.png" alt="image-20201201170540169"></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201201170637660.png" alt="image-20201201170637660"></p>
<h2 id="4-Servlet"><a href="#4-Servlet" class="headerlink" title="4, Servlet"></a>4, Servlet</h2><h3 id="4-1-Servlet简介"><a href="#4-1-Servlet简介" class="headerlink" title="4.1, Servlet简介"></a>4.1, Servlet简介</h3><ul>
<li>Servlet就是Sun公司开发动态web的一种技术</li>
<li>Sun在这些API中提供了一个接口叫做: Servlet, 如果你想开发一个Servlet程序,只需要完成两个小步骤:<ul>
<li>编一个类, 实现Servlet接口</li>
<li>把开发好的Java类部署到web服务器中.</li>
</ul>
</li>
</ul>
<p><strong>把实现了Servlet接口的java程序叫做,Servlet</strong></p>
<h3 id="4-2-HelloServlet"><a href="#4-2-HelloServlet" class="headerlink" title="4.2 HelloServlet"></a>4.2 HelloServlet</h3><p>Servlet接口Sun公司有两个默认的实现类: HttpServlet</p>
<ol>
<li><p>构建一个普通的Maven项目,删掉里面的src目录,以后我们的学习就在这个项目里面建立Moudel;这个空工程就是Maven的主工程</p>
</li>
<li><p>关于Maven父子工程的理解;<br>父母项目会有</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>servlet_01<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></code></pre></div>

<p>子项目会有</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javaWeb_02_servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre></div>

<p>父项目中的java子项目可以直接使用</p>
</li>
<li><p>Maven环境优化</p>
<ol>
<li>修改web.xml为最新的</li>
<li>将maven的结构搭建完整</li>
</ol>
</li>
<li><p>编写一个Servlet程序</p>
<ol>
<li><p>编写一个普通类</p>
</li>
<li><p>实现Servlet接口,这里我们直接继承HttpServlet</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;

   <span class="hljs-comment">// 由于get和post只是请求实现的不同方式,可以互相调用,业务逻辑都一样</span>
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
      PrintWriter writer = resp.getWriter();
      writer.print(<span class="hljs-string">&quot;Hello,Servlet&quot;</span>);
      <span class="hljs-keyword">super</span>.doGet(req, resp);
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
      <span class="hljs-keyword">super</span>.doPost(req, resp);
   &#125;
&#125;</code></pre></div>
</li>
</ol>
</li>
<li><p>编写Servlet的映射<br>为什么需要映射: 我们写的是Java程序,但是要通过浏览器访问,而浏览器需要连接web服务器,所以我们需要在web服务器中注册我们的Servlet,还需要给他一个浏览器能够访问的路径</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册Servlet--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.pnca.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
<span class="hljs-comment">&lt;!--Servlet的请求路径--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-comment">&lt;!--url-pattern要加/--&gt;</span>--&gt;
   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>
</li>
<li><p>配置tomcat<br>注意: 配置项目发布的路径,以及删除父类构造函数</p>
</li>
<li><p>启动测试</p>
</li>
</ol>
<h3 id="4-3-Servlet原理"><a href="#4-3-Servlet原理" class="headerlink" title="4.3, Servlet原理"></a>4.3, Servlet原理</h3><p> <strong>JavaWeb第7天</strong></p>
<p><strong>date: 2020.12.4</strong></p>
<p>Servlet是由Web服务器调用,web服务器在收到浏览器请求之后,会:</p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201204151036212.png" alt="image-20201204151036212"></p>
<h3 id="4-4-Mapping问题"><a href="#4-4-Mapping问题" class="headerlink" title="4.4, Mapping问题"></a>4.4, Mapping问题</h3><ol>
<li><p>一个Servlet可以指定一个映射路径</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>
</li>
<li><p>一个Servlet可以指定多个映射路径</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello3<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>
</li>
<li><p>一个Servlet可以指定通用映射路径</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>
</li>
<li><p>默认请求路径</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>
</li>
<li><p>指定一些后缀或者前缀…</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--可以自定义后缀实现请求映射</span>
<span class="hljs-comment">注意点,*前面并不能加项目映射的路径</span>
<span class="hljs-comment">hello/saifsf.pnca--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.pnca<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>
</li>
<li><p>优先级<br>指定了固有的映射路径优先级最高,如果找不到就会走默认的处理请求;</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--404--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.pnca.servlet.ErrorServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>

</li>
</ol>
<h3 id="4-5-ServletContext"><a href="#4-5-ServletContext" class="headerlink" title="4.5, ServletContext"></a>4.5, ServletContext</h3><p> <strong>JavaWeb第8天</strong></p>
<p><strong>date: 2020.12.6</strong></p>
<p>web容器在启动的时候,它会为每个web程序都创建一个对应的Servlet对象,他代表了当前的web应用;</p>
<h4 id="1-共享数据"><a href="#1-共享数据" class="headerlink" title="1. 共享数据"></a>1. 共享数据</h4><p>我在这个Servlet中保存的数据,可以在另外一个Servlet中拿到;</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
		System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);
<span class="hljs-comment">//		this.getInitParameter() // 初始化参数</span>
<span class="hljs-comment">//		this.getServletConfig() // Servlet配置</span>
<span class="hljs-comment">//		this.getServletContext() // Servlet上下文</span>
		ServletContext servletContext = <span class="hljs-keyword">this</span>.getServletContext();
		String username = <span class="hljs-string">&quot;pncalbl&quot;</span>;    <span class="hljs-comment">// 数据</span>
		servletContext.setAttribute(<span class="hljs-string">&quot;username&quot;</span>, username); <span class="hljs-comment">//将一个数据保存ServletContext中,名字为username</span>
	&#125;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
      doGet(req, resp);
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
      ServletContext servletContext = <span class="hljs-keyword">this</span>.getServletContext();
      String username = (String)servletContext.getAttribute(<span class="hljs-string">&quot;username&quot;</span>);
      resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);
      resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);
      resp.getWriter().print(<span class="hljs-string">&quot;名字&quot;</span> + username);
   &#125;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.pnca.servlet.GetServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/getc<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>

<ul>
<li><p>测试访问结果;</p>
<p><strong>注意,先执行/hello,存入数据.然后执行/getc,获取数据</strong></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201205173037189.png" alt="image-20201205173037189"></p>
</li>
</ul>
<h4 id="2-获取初始化参数"><a href="#2-获取初始化参数" class="headerlink" title="2, 获取初始化参数"></a>2, 获取初始化参数</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置一些web应用初始化参数--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
   ServletContext servletContext = <span class="hljs-keyword">this</span>.getServletContext();

   String url = servletContext.getInitParameter(<span class="hljs-string">&quot;url&quot;</span>);
   resp.getWriter().print(url);
&#125;</code></pre></div>

<h4 id="3-请求转发"><a href="#3-请求转发" class="headerlink" title="3, 请求转发"></a>3, 请求转发</h4><div class="code-wrapper"><pre><code class="hljs java">    <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
      System.out.println(<span class="hljs-string">&quot;进入了方法ServletDemo04&quot;</span>);
      ServletContext servletContext = <span class="hljs-keyword">this</span>.getServletContext();
<span class="hljs-comment">//    RequestDispatcher requestDispatcher = servletContext.getRequestDispatcher(&quot;/gp&quot;);   // 转发的请求路径</span>
<span class="hljs-comment">//    requestDispatcher.forward(req, resp);   // 调用forward方法实现请求转发</span>
      servletContext.getRequestDispatcher(<span class="hljs-string">&quot;/gp&quot;</span>).forward(req, resp);
   &#125;</code></pre></div>

<h4 id="4-读取资源文件"><a href="#4-读取资源文件" class="headerlink" title="4, 读取资源文件"></a>4, 读取资源文件</h4><p>properties</p>
<ul>
<li>在java目录下新建properties</li>
<li>在resource目录下新建properties</li>
</ul>
<p>发现: 都被打包到同一个路径下: classes,我们俗称这个路径为classespath</p>
<p>思路: 需要一个文件流</p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">username</span>=<span class="hljs-string">root566</span>
<span class="hljs-attr">password</span>=<span class="hljs-string">123456thhh</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
      ServletContext servletContext = <span class="hljs-keyword">this</span>.getServletContext();
<span class="hljs-comment">//    InputStream resourceAsStream = servletContext.getResourceAsStream(&quot;/WEB-INF/classes/db.properties&quot;);</span>
      InputStream resourceAsStream = servletContext.getResourceAsStream(<span class="hljs-string">&quot;/WEB-INF/classes/com/pnca/servlet/aa.properties&quot;</span>);
      Properties properties = <span class="hljs-keyword">new</span> Properties();
      properties.load(resourceAsStream);
      String user = properties.getProperty(<span class="hljs-string">&quot;username&quot;</span>);
      String pwd = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);
      resp.getWriter().print(user + <span class="hljs-string">&quot;: &quot;</span> + pwd);
   &#125;</code></pre></div>

<p>访问测试,即可</p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201206173710672.png" alt="image-20201206173710672"></p>
<h3 id="4-6-HttpServletResponce"><a href="#4-6-HttpServletResponce" class="headerlink" title="4.6, HttpServletResponce"></a>4.6, HttpServletResponce</h3><p> <strong>JavaWeb第9天</strong></p>
<p><strong>date: 2020.12.8</strong></p>
<p>web服务器接收到客户端的http请求时,针对这个请求,分别创建一个代表请求的HttpServletRequest对象,代表响应的一个HttpServletResponse对象;</p>
<ul>
<li>如果要获取客户端请求过来的参数: 找ServletRequest</li>
<li>如果要给客户端响应一些信息: 找HttpResponse</li>
</ul>
<h4 id="1-简单分类"><a href="#1-简单分类" class="headerlink" title="1, 简单分类"></a>1, 简单分类</h4><p>负责向浏览器发送数据的方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function">ServletOutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;
<span class="hljs-function">PrintWriter <span class="hljs-title">getWriter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;</code></pre></div>

<p>负责向浏览器发送响应头的方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCharacterEncoding</span><span class="hljs-params">(String var1)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContentLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContentLengthLong</span><span class="hljs-params">(<span class="hljs-keyword">long</span> var1)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContentType</span><span class="hljs-params">(String var1)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDateHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">long</span> var2)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addDateHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">long</span> var2)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setHeader</span><span class="hljs-params">(String var1, String var2)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addHeader</span><span class="hljs-params">(String var1, String var2)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setIntHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">int</span> var2)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIntHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">int</span> var2)</span></span>;
</code></pre></div>

<p>响应的状态码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> SC_CONTINUE = <span class="hljs-number">100</span>;
<span class="hljs-keyword">int</span> SC_SWITCHING_PROTOCOLS = <span class="hljs-number">101</span>;
<span class="hljs-keyword">int</span> SC_OK = <span class="hljs-number">200</span>;
<span class="hljs-keyword">int</span> SC_CREATED = <span class="hljs-number">201</span>;
<span class="hljs-keyword">int</span> SC_ACCEPTED = <span class="hljs-number">202</span>;
<span class="hljs-keyword">int</span> SC_NON_AUTHORITATIVE_INFORMATION = <span class="hljs-number">203</span>;
<span class="hljs-keyword">int</span> SC_NO_CONTENT = <span class="hljs-number">204</span>;
<span class="hljs-keyword">int</span> SC_RESET_CONTENT = <span class="hljs-number">205</span>;
<span class="hljs-keyword">int</span> SC_PARTIAL_CONTENT = <span class="hljs-number">206</span>;
<span class="hljs-keyword">int</span> SC_MULTIPLE_CHOICES = <span class="hljs-number">300</span>;
<span class="hljs-keyword">int</span> SC_MOVED_PERMANENTLY = <span class="hljs-number">301</span>;
<span class="hljs-keyword">int</span> SC_MOVED_TEMPORARILY = <span class="hljs-number">302</span>;
<span class="hljs-keyword">int</span> SC_FOUND = <span class="hljs-number">302</span>;
<span class="hljs-keyword">int</span> SC_SEE_OTHER = <span class="hljs-number">303</span>;
<span class="hljs-keyword">int</span> SC_NOT_MODIFIED = <span class="hljs-number">304</span>;
<span class="hljs-keyword">int</span> SC_USE_PROXY = <span class="hljs-number">305</span>;
<span class="hljs-keyword">int</span> SC_TEMPORARY_REDIRECT = <span class="hljs-number">307</span>;
<span class="hljs-keyword">int</span> SC_BAD_REQUEST = <span class="hljs-number">400</span>;
<span class="hljs-keyword">int</span> SC_UNAUTHORIZED = <span class="hljs-number">401</span>;
<span class="hljs-keyword">int</span> SC_PAYMENT_REQUIRED = <span class="hljs-number">402</span>;
<span class="hljs-keyword">int</span> SC_FORBIDDEN = <span class="hljs-number">403</span>;
<span class="hljs-keyword">int</span> SC_NOT_FOUND = <span class="hljs-number">404</span>;
<span class="hljs-keyword">int</span> SC_METHOD_NOT_ALLOWED = <span class="hljs-number">405</span>;
<span class="hljs-keyword">int</span> SC_NOT_ACCEPTABLE = <span class="hljs-number">406</span>;
<span class="hljs-keyword">int</span> SC_PROXY_AUTHENTICATION_REQUIRED = <span class="hljs-number">407</span>;
<span class="hljs-keyword">int</span> SC_REQUEST_TIMEOUT = <span class="hljs-number">408</span>;
<span class="hljs-keyword">int</span> SC_CONFLICT = <span class="hljs-number">409</span>;
<span class="hljs-keyword">int</span> SC_GONE = <span class="hljs-number">410</span>;
<span class="hljs-keyword">int</span> SC_LENGTH_REQUIRED = <span class="hljs-number">411</span>;
<span class="hljs-keyword">int</span> SC_PRECONDITION_FAILED = <span class="hljs-number">412</span>;
<span class="hljs-keyword">int</span> SC_REQUEST_ENTITY_TOO_LARGE = <span class="hljs-number">413</span>;
<span class="hljs-keyword">int</span> SC_REQUEST_URI_TOO_LONG = <span class="hljs-number">414</span>;
<span class="hljs-keyword">int</span> SC_UNSUPPORTED_MEDIA_TYPE = <span class="hljs-number">415</span>;
<span class="hljs-keyword">int</span> SC_REQUESTED_RANGE_NOT_SATISFIABLE = <span class="hljs-number">416</span>;
<span class="hljs-keyword">int</span> SC_EXPECTATION_FAILED = <span class="hljs-number">417</span>;
<span class="hljs-keyword">int</span> SC_INTERNAL_SERVER_ERROR = <span class="hljs-number">500</span>;
<span class="hljs-keyword">int</span> SC_NOT_IMPLEMENTED = <span class="hljs-number">501</span>;
<span class="hljs-keyword">int</span> SC_BAD_GATEWAY = <span class="hljs-number">502</span>;
<span class="hljs-keyword">int</span> SC_SERVICE_UNAVAILABLE = <span class="hljs-number">503</span>;
<span class="hljs-keyword">int</span> SC_GATEWAY_TIMEOUT = <span class="hljs-number">504</span>;
<span class="hljs-keyword">int</span> SC_HTTP_VERSION_NOT_SUPPORTED = <span class="hljs-number">505</span>;</code></pre></div>

<h4 id="2-下载文件"><a href="#2-下载文件" class="headerlink" title="2, 下载文件"></a>2, 下载文件</h4><p>1.向浏览器输出消息</p>
<p>2.下载文件</p>
<div class="code-wrapper"><pre><code>1.要获取下载文件的路径
2.下载的文件名
3.设置想办法让浏览器能够支持下载我们需要的东西
4.获取下载文件的输入流
5.创建缓冲区
6.获取OutPutStream对象
7.将FileOutPutStream流写入到Buffer缓冲区,使用OutPutStream将缓冲区中的数据输出到客户端
8.关闭流对象</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
    <span class="hljs-comment">//1.  要获取下载文件的路径</span>
    String realPath = <span class="hljs-string">&quot;D:\\PNCA\\Project\\Java_Project\\JavaWeb\\javaweb_02_servlet\\response\\src\\main\\resources\\1.png&quot;</span>;
    <span class="hljs-comment">//    String realPath = this.getServletContext().getRealPath(&quot;/1.png&quot;);</span>
    System.out.println(<span class="hljs-string">&quot;获取下载文件的路径: &quot;</span> + realPath);
    <span class="hljs-comment">//2.  下载的文件名</span>
    String fileName = realPath.substring(realPath.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>) + <span class="hljs-number">1</span>);
    <span class="hljs-comment">//3.  设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名,设置utf-8编码</span>
    resp.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment; filename=&quot;</span> + URLEncoder.encode(fileName, StandardCharsets.UTF_8));
    <span class="hljs-comment">//4.  获取下载文件的输入流</span>
    FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(realPath);
    <span class="hljs-comment">//5.  创建缓冲区</span>
    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];
    <span class="hljs-comment">//6.  获取OutPutStream对象</span>
    ServletOutputStream out = resp.getOutputStream();
    <span class="hljs-comment">//7.  将FileOutPutStream流写入到Buffer缓冲区,使用OutPutStream将缓冲区中的数据输出到客户端</span>
    <span class="hljs-keyword">while</span> ((len = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;
        out.write(buffer, <span class="hljs-number">0</span>, len);
    &#125;
    <span class="hljs-comment">//8.  关闭流对象</span>
    in.close();
    out.close();
&#125;</code></pre></div>

<h4 id="3-验证码"><a href="#3-验证码" class="headerlink" title="3,  验证码"></a>3,  验证码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
      <span class="hljs-comment">// 如何让浏览器3秒刷新一次</span>
      resp.setHeader(<span class="hljs-string">&quot;refresh&quot;</span> , <span class="hljs-string">&quot;3&quot;</span>);

      <span class="hljs-comment">// 在内存中创建一个图片</span>
      BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(<span class="hljs-number">80</span>, <span class="hljs-number">20</span>, BufferedImage.TYPE_INT_RGB);

      <span class="hljs-comment">// 得到图片</span>
      Graphics2D graphics = (Graphics2D) image.getGraphics();
      <span class="hljs-comment">// 设置图片的背景颜色</span>
      graphics.setColor(Color.white);
      graphics.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">80</span>, <span class="hljs-number">20</span>);
      <span class="hljs-comment">// 给图片写数据</span>
      graphics.setColor(Color.BLUE);
      graphics.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-keyword">null</span>, Font.BOLD, <span class="hljs-number">20</span>));
      graphics.drawString(makeNum(), <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);

      <span class="hljs-comment">// 告诉浏览器,这个请求用图片的方式打开</span>
      resp.setContentType(<span class="hljs-string">&quot;image/jpeg&quot;</span>);

      <span class="hljs-comment">// 网站存在缓存,不让浏览器缓存</span>
      resp.setDateHeader(<span class="hljs-string">&quot;expires&quot;</span>, -<span class="hljs-number">1</span>);
      resp.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);
      resp.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);

      <span class="hljs-comment">// 把图片写给浏览器</span>
      ImageIO.write(image, <span class="hljs-string">&quot;jpg&quot;</span>, resp.getOutputStream());
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
      doGet(req, resp);
	&#125;

   <span class="hljs-comment">// 生成随机数</span>
   <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">makeNum</span><span class="hljs-params">()</span> </span>&#123;
      Random random = <span class="hljs-keyword">new</span> Random();
      String num = random.nextInt(<span class="hljs-number">999999</span>) + <span class="hljs-string">&quot;&quot;</span>;
      StringBuffer stringBuffer = <span class="hljs-keyword">new</span> StringBuffer();

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span> - num.length(); i++) &#123; <span class="hljs-comment">// 保证七位数</span>
         stringBuffer.append(<span class="hljs-string">&quot;0&quot;</span>);
      &#125;
      <span class="hljs-keyword">return</span> stringBuffer.toString() + num;
   &#125;
&#125;</code></pre></div>

<p>注意,在web.xml中注册</p>
<h4 id="4-实现重定向"><a href="#4-实现重定向" class="headerlink" title="4, 实现重定向"></a>4, 实现重定向</h4><p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201211145312620.png" alt="image-20201211145312620"></p>
<p>B一个web资源收到客户端A的请求后,B会通知A客户端去访问另一个web资源,这个过程叫重定向</p>
<p>常见场景:</p>
<ul>
<li>用户登录</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendRedirect</span><span class="hljs-params">(String var1)</span> <span class="hljs-keyword">throws</span> IOException</span>;</code></pre></div>

<p>测试</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
   <span class="hljs-comment">/*resp.setHeader(&quot;Location&quot;, &quot;/rs/img&quot;);</span>
<span class="hljs-comment">   resp.setStatus(302);*/</span>
   resp.sendRedirect(<span class="hljs-string">&quot;/rs/img&quot;</span>);   <span class="hljs-comment">// 重定向</span>
&#125;</code></pre></div>

<p>面试题,请你聊聊重定向和转发的区别?</p>
<p>相同点</p>
<ul>
<li>页面都会实现跳转</li>
</ul>
<p>不同的</p>
<ul>
<li>请求转发的时候,url不会发生变化</li>
<li>重定向的时候,url地址栏会发生变化</li>
</ul>
<h3 id="4-7-HttpServletRequest"><a href="#4-7-HttpServletRequest" class="headerlink" title="4.7 , HttpServletRequest"></a>4.7 , HttpServletRequest</h3><p> <strong>JavaWeb第10天</strong></p>
<p><strong>date: 2020.12.12</strong></p>
<p>HttpServletRequest代表客户端的请求,用户通过http协议访问服务器,HTTP请求中的所有信息会被封装到HttpRequest,通过这个HttpRequest的方法,获得客户端的所有信息。</p>
<h4 id="1，-获取前端传递的参数"><a href="#1，-获取前端传递的参数" class="headerlink" title="1， 获取前端传递的参数"></a>1， 获取前端传递的参数</h4><p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201212150125276.png" alt="image-20201212150125276"></p>
<div class="code-wrapper"><pre><code class="hljs java">String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);
		String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);
		String[] hobbys = req.getParameterValues(<span class="hljs-string">&quot;hobbys&quot;</span>);
		System.out.println(<span class="hljs-string">&quot;==========================&quot;</span>);
		System.out.println(username);
		System.out.println(password);
		System.out.println(Arrays.toString(hobbys));
		System.out.println(<span class="hljs-string">&quot;==========================&quot;</span>);</code></pre></div>



<h4 id="2，-请求转发"><a href="#2，-请求转发" class="headerlink" title="2， 请求转发"></a>2， 请求转发</h4><div class="code-wrapper"><pre><code class="hljs java">req.getRequestDispatcher(<span class="hljs-string">&quot;/success.jsp&quot;</span>).forward(req, resp);
</code></pre></div>

<p>面试题,请你聊聊重定向和转发的区别?</p>
<p>相同点</p>
<ul>
<li>页面都会实现跳转</li>
</ul>
<p>不同的</p>
<ul>
<li>请求转发的时候,url不会发生变化 <strong>307</strong></li>
<li>重定向的时候,url地址栏会发生变化 <strong>302</strong></li>
</ul>
<h2 id="5-Cookie-Session（重点）"><a href="#5-Cookie-Session（重点）" class="headerlink" title="5, Cookie, Session（重点）"></a>5, Cookie, Session（重点）</h2><p> <strong>JavaWeb第11天</strong></p>
<p><strong>date: 2020.12.14</strong></p>
<h3 id="5-1-会话"><a href="#5-1-会话" class="headerlink" title="5.1, 会话"></a>5.1, 会话</h3><p><strong>会话</strong>: 用户打开一个浏览器,点击了很多的超链接,访问多个web资源,关闭浏览器,这个过程可以称之为会话.</p>
<p><strong>有状态会话</strong>: </p>
<p>一个网站,怎么证明你来过?</p>
<p>​    客户端                服务端</p>
<ol>
<li>服务端给客户端一个信件,客户端下次访问服务器带上信件就可以; cookie</li>
<li>服务器登记你来过了,下次你来的时候我来匹配你; session</li>
</ol>
<h3 id="5-2-保存会话的两种技术"><a href="#5-2-保存会话的两种技术" class="headerlink" title="5.2, 保存会话的两种技术"></a>5.2, 保存会话的两种技术</h3><p><strong>cookie</strong></p>
<ul>
<li>客户端技术(响应, 请求)</li>
</ul>
<p><strong>session</strong></p>
<ul>
<li>服务器技术,利用这个技术,可以保存会话的信息,我们可以把信息或者数据放在Session</li>
</ul>
<h3 id="5-3-Cookie"><a href="#5-3-Cookie" class="headerlink" title="5.3, Cookie"></a>5.3, Cookie</h3><ol>
<li>从请求中拿到cookie信息</li>
<li>服务器响应给客户端cookie</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java">Cookie[] cookies = req.getCookies();	<span class="hljs-comment">// 获得Cookie</span>
cookie.getName();	<span class="hljs-comment">// 获得cookie中的key</span>
cookie.getValue();	<span class="hljs-comment">// 获得cookie中的value</span>
<span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;LastLoginTime&quot;</span>, System.currentTimeMillis() + <span class="hljs-string">&quot;&quot;</span>);	<span class="hljs-comment">// 新建一个cookie</span>
cookie.setMaxAge(<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>);	<span class="hljs-comment">// 设置cookie的有效期</span>
resp.addCookie(cookie);	<span class="hljs-comment">// 响应给客户端一个cookie</span></code></pre></div>

<p><strong>cookie: 一般会保存在本地的用户目录下 AppData中;</strong></p>
<p>一个网站Cookie是否存在上限;</p>
<ul>
<li>一个Cookie只能保存一个信息</li>
<li>一个web站点可以给浏览器发送多个cookie,最多存放20个cookie</li>
<li>Cookie大小有限制,例如4kb</li>
<li>游览器有300个cookie上限</li>
</ul>
<p>删除Cookie</p>
<ul>
<li>不设置有效期,关闭浏览器,自动失效</li>
<li>设置有效期时间为0</li>
</ul>
<p>编码, 解码</p>
<div class="code-wrapper"><pre><code class="hljs java">URLEncoder.encode(<span class="hljs-string">&quot;年后&quot;</span>, StandardCharsets.UTF_8)
URLDecoder.decode(cookie.getValue(), StandardCharsets.UTF_8)</code></pre></div>

<h3 id="5-4-Session-重点"><a href="#5-4-Session-重点" class="headerlink" title="5.4 Session (重点)"></a>5.4 Session (重点)</h3><p> <strong>JavaWeb第12天</strong></p>
<p><strong>date: 2020.12.15</strong></p>
<p>什么是Session:</p>
<ul>
<li><p>服务器会给每个用户(浏览器),创建一个Session对象</p>
</li>
<li><p>一个Session独占一个浏览器,只要浏览器没有关闭,这个Session就存在</p>
</li>
<li><p>用户登录之后,整个网站都可以访问.</p>
</li>
</ul>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201215212325644.png" alt="image-20201215212325644"></p>
<p>Session和Cookie的区别</p>
<ul>
<li>Cookie是把用户的数据写给用户的浏览器,浏览器保存(可以保存多个)</li>
<li>Session把用户的数据写到用户独占的Session中,服务器端保存(保存重要信息,减少服务器资源的浪费)</li>
<li>Session对象由服务器创建</li>
</ul>
<p>使用场景: </p>
<ul>
<li>保存一个用户的登录信息</li>
<li>购物车信息</li>
<li>在整个网站中,经常会使用的数据,我们将它保存在Sesson中</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionDemo01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;

		<span class="hljs-comment">// 解决乱码问题</span>
		req.setCharacterEncoding(<span class="hljs-string">&quot;utf-16&quot;</span>);
		resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-16&quot;</span>);
		resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);

		<span class="hljs-comment">// 得到Session对象</span>
		HttpSession session = req.getSession();

		<span class="hljs-comment">// 给Session存东西</span>
		session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;PNCALBL&quot;</span>, <span class="hljs-number">10</span>));

		<span class="hljs-comment">// 获取Session的ID</span>
		String sessionId = session.getId();

		<span class="hljs-comment">// 判断Session是不是新创建</span>
		<span class="hljs-keyword">if</span> (session.isNew()) &#123;
			resp.getWriter().write(<span class="hljs-string">&quot;session创建成功,ID: &quot;</span> + sessionId);
		&#125;<span class="hljs-keyword">else</span>&#123;
			resp.getWriter().write(<span class="hljs-string">&quot;session已经在服务器中存在了,ID: &quot;</span> + sessionId);
		&#125;
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
		doGet(req, resp);
	&#125;
&#125;
</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;

		<span class="hljs-comment">// 解决乱码问题</span>
		req.setCharacterEncoding(<span class="hljs-string">&quot;utf-16&quot;</span>);
		resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-16&quot;</span>);
		resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);

		<span class="hljs-comment">// 得到Session对象</span>
		HttpSession session = req.getSession();

		Person person = (Person) session.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);

		System.out.println(person);
	&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;

		<span class="hljs-comment">// 解决乱码问题</span>
		req.setCharacterEncoding(<span class="hljs-string">&quot;utf-16&quot;</span>);
		resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-16&quot;</span>);
		resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);

		<span class="hljs-comment">// 得到Session对象</span>
		HttpSession session = req.getSession();
		session.removeAttribute(<span class="hljs-string">&quot;name&quot;</span>);
		session.invalidate();
	&#125;</code></pre></div>

<p>会话自动过期: web.xml配置</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--设置Session默认失效时间--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span>
    <span class="hljs-comment">&lt;!--1分钟后session失效,以分钟为单位--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span></code></pre></div>

<h2 id="6-JSP"><a href="#6-JSP" class="headerlink" title="6, JSP"></a>6, JSP</h2><p> <strong>JavaWeb第13天</strong></p>
<p><strong>date: 2020.12.17</strong></p>
<h3 id="6-1-什么是jsp"><a href="#6-1-什么是jsp" class="headerlink" title="6.1, 什么是jsp"></a>6.1, 什么是jsp</h3><p>Java Server Pages : Java服务器端页面,也和Servlet一样,用于动态web技术!</p>
<p>最大的特点: </p>
<ul>
<li>写JSP就像在写HTML</li>
<li>区别:<ul>
<li>HTML只给用户提供数据</li>
<li>jsp页面可以嵌入Java代码, 为用户提供动态数据</li>
</ul>
</li>
</ul>
<h3 id="6-2-JSP原理"><a href="#6-2-JSP原理" class="headerlink" title="6.2, JSP原理"></a>6.2, JSP原理</h3><p>思路: JSP到底怎么执行的!</p>
<ul>
<li><p>代码层面没有任何问题</p>
</li>
<li><p>服务器内部工作</p>
<p>tomcat中有一个work目录</p>
<p>IDEA中使用Tomcat的话,会在IDEA的Tomcat中产生一个work目录</p>
</li>
</ul>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201217202017270.png" alt="image-20201217202017270"></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20201217202109882.png" alt="image-20201217202109882"></p>
<p>发现了java程序!</p>
<p><strong>浏览器向服务器发送请求,不管访问什么,其实都是在访问Servlet!</strong></p>
<p>JSP最终也会被转换成一个java类</p>
<p>JSP本质上还是一个Servlet</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 初始化</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspInit</span><span class="hljs-params">()</span> </span>&#123;
&#125;
<span class="hljs-comment">// 销毁</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspDestroy</span><span class="hljs-params">()</span> </span>&#123;
&#125;
<span class="hljs-comment">// JSPService</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">_jspService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;&#125;</code></pre></div>

<ol>
<li><p>判断请求</p>
</li>
<li><p>内置了一些对象</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> javax.servlet.jsp.PageContext pageContext; <span class="hljs-comment">// 页面上下文</span>
javax.servlet.http.HttpSession session = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// session</span>
<span class="hljs-keyword">final</span> javax.servlet.ServletContext application; <span class="hljs-comment">// applicationContext</span>
<span class="hljs-keyword">final</span> javax.servlet.ServletConfig config; <span class="hljs-comment">// config</span>
javax.servlet.jsp.JspWriter out = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// out</span>
<span class="hljs-keyword">final</span> java.lang.Object page = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// page 当前</span>
javax.servlet.jsp.JspWriter _jspx_out = <span class="hljs-keyword">null</span>;
javax.servlet.jsp.PageContext _jspx_page_context = <span class="hljs-keyword">null</span>;</code></pre></div>
</li>
<li><p>输出页面前增加的代码</p>
<div class="code-wrapper"><pre><code class="hljs java">response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>); <span class="hljs-comment">// 设置响应的页面类型</span>
pageContext = _jspxFactory.getPageContext(<span class="hljs-keyword">this</span>, request, response,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">8192</span>, <span class="hljs-keyword">true</span>);
_jspx_page_context = pageContext;
application = pageContext.getServletContext();
config = pageContext.getServletConfig();
session = pageContext.getSession();
out = pageContext.getOut();
_jspx_out = out;</code></pre></div>
</li>
<li><p>以上的这些个对象我们可以直接在JSP页面中使用!</p>
</li>
</ol>
<p>在JSP页面中: </p>
<p>只要是JAVA代码就会原封不东的输出;</p>
<p>如果是HTML代码,就会被转换为</p>
<div class="code-wrapper"><pre><code class="hljs java">out.write(<span class="hljs-string">&quot;&lt;html&gt;\r\n&quot;</span>);</code></pre></div>

<p>这样的格式,输出到前端</p>
<h3 id="6-3-JSP的基础语法"><a href="#6-3-JSP的基础语法" class="headerlink" title="6.3, JSP的基础语法"></a>6.3, JSP的基础语法</h3><p> <strong>JavaWeb第14天</strong></p>
<p><strong>date: 2020.12.22</strong></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
		<span class="hljs-comment">&lt;!--JSP的依赖--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--Servlet的依赖--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--standard标签库--&gt;</span>
		<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/taglibs/standard --&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>standard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--JSTL表达式的依赖--&gt;</span>
		<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl-api --&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

<p>任何语言都有自己的语法,jsp作为java的技术的一种应用,它拥有一些自己扩充的语法,它支持所有的java语法.</p>
<h4 id="JSP表达式"><a href="#JSP表达式" class="headerlink" title="JSP表达式"></a><strong>JSP表达式</strong></h4><div class="code-wrapper"><pre><code class="hljs jsp">&lt;%--JSP表达式
作用: 用来将程序的输出,输出到客户端
&lt;%= 变量或者表达式%&gt;
--%&gt;
&lt;%= <span class="hljs-keyword">new</span> java.util.Date()%&gt;</code></pre></div>

<h4 id="jsp脚本片段"><a href="#jsp脚本片段" class="headerlink" title="jsp脚本片段"></a><strong>jsp脚本片段</strong></h4><div class="code-wrapper"><pre><code class="hljs jsp">&lt;%--jsp脚本片段--%&gt;
&lt;%
<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;
    sum += i;
&#125;
out.println(<span class="hljs-string">&quot;&lt;h1&gt;Sum=&quot;</span> + sum + <span class="hljs-string">&quot;&lt;/h1&gt;&quot;</span>);
%&gt;</code></pre></div>

<h4 id="脚本呢片段的再实现"><a href="#脚本呢片段的再实现" class="headerlink" title="脚本呢片段的再实现"></a>脚本呢片段的再实现</h4><div class="code-wrapper"><pre><code class="hljs jsp">&lt;%
  <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;
  out.println(x);
%&gt;
&lt;p&gt;这是一个JSP文档&lt;/p&gt;
&lt;%
  <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>;
  out.println(y);
%&gt;

&lt;hr&gt;

&lt;%--在代码中嵌入HTML元素--%&gt;
&lt;%
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
%&gt;
&lt;h1&gt;HeLLo, World &lt;%=i%&gt;&lt;/h1&gt;
&lt;%
  &#125;
%&gt;</code></pre></div>

<h4 id="JSP声明"><a href="#JSP声明" class="headerlink" title="JSP声明"></a><strong>JSP声明</strong></h4><div class="code-wrapper"><pre><code class="hljs jsp">&lt;%!
  <span class="hljs-keyword">static</span> &#123;
    System.out.println(<span class="hljs-string">&quot;Loading Servlet!&quot;</span>);
  &#125;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> globalVar = <span class="hljs-number">0</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pnca</span><span class="hljs-params">()</span> </span>&#123;
    System.out.println(<span class="hljs-string">&quot;进入了方法pnca&quot;</span>);
  &#125;
%&gt;</code></pre></div>

<p>JSP声明: 会被编译到JSP生成的Java类中!其他的,就会被生成到_jspService()方法中!</p>
<p>在JSP中,嵌入java代码即可!</p>
<p>JSP的注释,不会在客户端显示,HTML的就会!</p>
<h3 id="6-4-JSP指令"><a href="#6-4-JSP指令" class="headerlink" title="6.4, JSP指令"></a>6.4, JSP指令</h3><div class="code-wrapper"><pre><code class="hljs mel">&lt;%@page args .... %&gt;
&lt;%@include <span class="hljs-string">&quot;%&gt;</span></code></pre></div>

<h3 id="6-5，九大内置对象"><a href="#6-5，九大内置对象" class="headerlink" title="6.5，九大内置对象"></a>6.5，九大内置对象</h3><p> <strong>JavaWeb第15天</strong></p>
<p><strong>date: 2020.12.24</strong></p>
<ul>
<li>PageContext</li>
<li>Request</li>
<li>Response</li>
<li>Session</li>
<li>Application 【ServletContext】</li>
<li>config  【ServletConfig】</li>
<li>out</li>
<li>page</li>
<li>exception</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java">pageContext.setAttribute(<span class="hljs-string">&quot;name1&quot;</span>, <span class="hljs-string">&quot;pnca1&quot;</span>); <span class="hljs-comment">// 保存的数据只能在一个页面中有效</span>
	request.setAttribute(<span class="hljs-string">&quot;name2&quot;</span>, <span class="hljs-string">&quot;pnca2&quot;</span>); <span class="hljs-comment">// 保存的数据只能在一次请求中有效,请求转发会携带这个数据</span>
	session.setAttribute(<span class="hljs-string">&quot;name3&quot;</span>, <span class="hljs-string">&quot;pnca3&quot;</span>); <span class="hljs-comment">// 保存的数据只能在一次会话中有效,从打开浏览器到关闭浏览器</span>
	application.setAttribute(<span class="hljs-string">&quot;name4&quot;</span>, <span class="hljs-string">&quot;pnca4&quot;</span>); <span class="hljs-comment">// 保存的数据只在服务器中有效,从打开服务器到关闭服务器</span></code></pre></div>

<h3 id="6-6-JSP标签-JSTL标签-EL表达式"><a href="#6-6-JSP标签-JSTL标签-EL表达式" class="headerlink" title="6.6, JSP标签, JSTL标签,EL表达式"></a>6.6, JSP标签, JSTL标签,EL表达式</h3><p> <strong>JavaWeb第16天</strong></p>
<p><strong>date: 2021.01.17</strong></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>standard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-comment">&lt;!--JSTL表达式的依赖--&gt;</span>
<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl-api --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>EL表达式:    ${}</p>
<ul>
<li><strong>获取数据</strong></li>
<li><strong>执行运算</strong></li>
<li>获取web开发的常用对象</li>
</ul>
<p>JSP标签</p>
<div class="code-wrapper"><pre><code class="hljs xml">&lt;%--
http://localhost:8080/jsptag.jsp?name=pnca&amp;age=18
--%&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">jsp:forward</span> <span class="hljs-attr">page</span>=<span class="hljs-string">&quot;/jsptag2.jsp&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">jsp:param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pnca&quot;</span>/&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">jsp:param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">jsp:forward</span>&gt;</span></code></pre></div>

<p>JSTL标签</p>
<p>JSTL标签的使用就是为了弥补HTML标签的不足; 它自定义了许多标签,可以供我们使用标签的功能和Java代码一样!</p>
<p><strong>核心标签</strong>(掌握部分)</p>
<p><strong>格式化标签</strong></p>
<p><strong>SQL标签</strong></p>
<p><strong>XML标签</strong></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/jstl%E6%A0%B8%E5%BF%83%E6%A0%87%E7%AD%BE.png" alt="image-20210117194315738"></p>
<p>JSTL标签的使用方法</p>
<ul>
<li>引入对应的taglib</li>
<li>使用其中的方法</li>
<li>在Tomcat也需要引入jstl的包,否则会报错:JSTL解析错误</li>
</ul>
<p>c:if</p>
<div class="code-wrapper"><pre><code class="hljs jsp">&lt;%--判断如果提交的用户名是管理员,则登录成功--%&gt;
&lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;$&#123;param.username == &#x27;admin&#x27;&#125;&quot;</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;isAdmin&quot;</span>&gt;
   &lt;c:out value=<span class="hljs-string">&quot;管理员欢迎您!&quot;</span>/&gt;
&lt;/c:if&gt;
&lt;c:out value=<span class="hljs-string">&quot;$&#123;isAdmin&#125;&gt;&quot;</span>/&gt;</code></pre></div>

<p>c:when</p>
<div class="code-wrapper"><pre><code class="hljs jsp">&lt;c:choose&gt;
   &lt;c:when test=<span class="hljs-string">&quot;$&#123;score &gt;= 90&#125;&quot;</span>&gt;
      您的成绩为优秀
   &lt;/c:when&gt;

   &lt;c:when test=<span class="hljs-string">&quot;$&#123;score &gt;= 80&#125;&quot;</span>&gt;
      您的成绩为一般
   &lt;/c:when&gt;

   &lt;c:when test=<span class="hljs-string">&quot;$&#123;score &gt;= 70&#125;&quot;</span>&gt;
      您的成绩为良好
   &lt;/c:when&gt;

   &lt;c:when test=<span class="hljs-string">&quot;$&#123;score &gt;= 60&#125;&quot;</span>&gt;
      您的成绩为及格
   &lt;/c:when&gt;

   &lt;c:when test=<span class="hljs-string">&quot;$&#123;score &lt; 60&#125;&quot;</span>&gt;
      您的成绩为不及格
   &lt;/c:when&gt;

&lt;/c:choose&gt;</code></pre></div>

<p>c:foreach</p>
<div class="code-wrapper"><pre><code class="hljs jsp">&lt;c:forEach <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;people&quot;</span> items=<span class="hljs-string">&quot;$&#123;list&#125;&quot;</span>&gt;
   &lt;c:out value=<span class="hljs-string">&quot;$&#123;people&#125;&quot;</span>/&gt; &lt;br&gt;
&lt;/c:forEach&gt;

&lt;hr&gt;

&lt;c:forEach <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;people&quot;</span> items=<span class="hljs-string">&quot;$&#123;list&#125;&quot;</span> begin=<span class="hljs-string">&quot;1&quot;</span> end=<span class="hljs-string">&quot;3&quot;</span> step=<span class="hljs-string">&quot;2&quot;</span>&gt;
   &lt;c:out value=<span class="hljs-string">&quot;$&#123;people&#125;&quot;</span>/&gt; &lt;br&gt;
&lt;/c:forEach&gt;</code></pre></div>

<h2 id="7-JavaBen"><a href="#7-JavaBen" class="headerlink" title="7, JavaBen"></a>7, JavaBen</h2><p>实体类</p>
<p>JavaBean有特定的写法:</p>
<ul>
<li>必须有一个无参构造</li>
<li>属性必须私有化</li>
<li>必须有对应的get/set</li>
</ul>
<p>一般用来和数据库的字段做关系映射 ORM;</p>
<p>ORM:对象关系映射</p>
<ul>
<li>表—&gt;类</li>
<li>字段—&gt;属性</li>
<li>行记录—-&gt;对象</li>
</ul>
<p><strong>people表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>address</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>pnca1</td>
<td>12</td>
<td>西安</td>
</tr>
<tr>
<td>2</td>
<td>pnca2</td>
<td>23</td>
<td>西安</td>
</tr>
<tr>
<td>3</td>
<td>pnca3</td>
<td>22</td>
<td>西安</td>
</tr>
</tbody></table>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
	<span class="hljs-keyword">private</span> String name;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
	<span class="hljs-keyword">private</span> String address;
&#125;

Class A &#123;
	<span class="hljs-keyword">new</span> People(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;pnca1&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;西安&quot;</span>)
    <span class="hljs-keyword">new</span> People(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;pnca1&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;西安&quot;</span>)
    <span class="hljs-keyword">new</span> People(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;pnca1&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;西安&quot;</span>)
&#125;</code></pre></div>

<ul>
<li>过滤器</li>
<li>文件上传</li>
<li>邮件发送</li>
<li>JDBC复习: 如何使用JDBC, JDBC crud, JDBC事务</li>
</ul>
<h2 id="8-MVC三层架构"><a href="#8-MVC三层架构" class="headerlink" title="8, MVC三层架构"></a>8, MVC三层架构</h2><p>什么是MVC: Mode View Controller 模型，视图，控制器</p>
<h3 id="10-1，早些年"><a href="#10-1，早些年" class="headerlink" title="10.1，早些年"></a>10.1，早些年</h3><p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20210119202913484.png" alt="image-20210119202913484"></p>
<p>用户直接访问控制层，控制层就可以直接操作数据库；</p>
<div class="code-wrapper"><pre><code class="hljs mipsasm">servlet--CRUD--&gt;数据库
弊端：程序十分臃肿，不利于维护
servlet的代码中：处理请求，响应，视图跳转，处理<span class="hljs-keyword">JDBC，处理业务代码，处理逻辑代码</span>
<span class="hljs-keyword"></span>
<span class="hljs-keyword">架构：没有什么是加一层解决不了的！</span>
<span class="hljs-keyword">JDBC</span>
<span class="hljs-keyword"></span>
<span class="hljs-keyword">Mysql </span><span class="hljs-keyword">Oracle </span>SqlServer</code></pre></div>

<p>10.2，三层架构</p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20210119203732844.png" alt="image-20210119203732844"></p>
<p>Model</p>
<ul>
<li>业务处理：业务逻辑（Service）</li>
<li>数据持久层：CRUD（DAO）</li>
</ul>
<p>View</p>
<ul>
<li>展示数据</li>
<li>提供链接发起Servlet请求（a, form, img）</li>
</ul>
<p>Controller（Servlet）</p>
<ul>
<li>接收用户的请求：（req：请求参数，Session信息）</li>
<li>交给业务层处理对应的代码</li>
<li>控制视图的跳转</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">登录</span>--<span class="hljs-literal">-</span>&gt;<span class="hljs-comment">接受用户的登录请求</span>--<span class="hljs-literal">-</span>&gt;<span class="hljs-comment">处理用户的请求（获取用户登录的参数</span><span class="hljs-string">,</span><span class="hljs-comment">username，password）</span>--<span class="hljs-literal">-</span>&gt;<span class="hljs-comment">交给业务层处理登录业务（判断用户名密码是否正确：事务）</span>--<span class="hljs-literal">-</span>&gt;<span class="hljs-comment">DAO层查询用户名和密码是否正确</span>--<span class="hljs-literal">-</span>&gt;<span class="hljs-comment">数据库</span></code></pre></div>

<h2 id="9，Filter（重点）"><a href="#9，Filter（重点）" class="headerlink" title="9，Filter（重点）"></a>9，Filter（重点）</h2><p>Filter：过滤器，用来过滤网站的数据</p>
<ul>
<li>处理中文乱码</li>
<li>登录验证</li>
</ul>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20210120201328299.png" alt="image-20210120201328299"></p>
<ol>
<li>导包</li>
</ol>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20210120202413131.png" alt="image-20210120202413131"></p>
<ol start="2">
<li>编写过滤器,实现Filter接口，重写对应的方法即可</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharacterEncodingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;

	<span class="hljs-comment">// 初始化: web服务器启动,就已经开始初始化,随时等待过滤对象</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;
		System.out.println(<span class="hljs-string">&quot;CharacterEncodingFilter初始化&quot;</span>);
	&#125;

	<span class="hljs-comment">// Chain:链</span>
	<span class="hljs-comment">/*</span>
<span class="hljs-comment">	1.过滤器中的所有代码,在过滤特定请求的时候都会被执行</span>
<span class="hljs-comment">	2.必须让过滤器继续执行</span>
<span class="hljs-comment">	filterChain.doFilter(servletRequest, servletResponse);</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
		servletRequest.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);
		servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);
		servletResponse.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);

		System.out.println(<span class="hljs-string">&quot;CharacterEncodingFilter执行前...&quot;</span>);
		filterChain.doFilter(servletRequest, servletResponse); <span class="hljs-comment">// 让我们的请求继续走,如果不写,程序到这里就会被拦截!</span>
		System.out.println(<span class="hljs-string">&quot;CharacterEncodingFilter执行后...&quot;</span>);
	&#125;

	<span class="hljs-comment">// 销毁: web服务器关闭,过滤器才会销毁</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;
		System.out.println(<span class="hljs-string">&quot;CharacterEncodingFilter销毁&quot;</span>);
	&#125;
&#125;</code></pre></div>

<ol start="3">
<li>在web.xml中,配置Filter</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.pnca.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-comment">&lt;!--只要是/servlet的请求,都会经过这个过滤器--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/servlet/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
    <span class="hljs-comment">&lt;!--&lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div>

<h2 id="10，监听器"><a href="#10，监听器" class="headerlink" title="10，监听器"></a>10，监听器</h2><ol>
<li><p>实现一个监听器接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnlineCountListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span> </span>&#123;

	<span class="hljs-comment">// 创建session监听</span>
	<span class="hljs-comment">// 一旦创建Session就会触发一次这个事件</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;

		ServletContext servletContext = httpSessionEvent.getSession().getServletContext();
		System.out.println(httpSessionEvent.getSession().getId());
		Integer onlineCount = (Integer) servletContext.getAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>);
		<span class="hljs-keyword">if</span> (onlineCount == <span class="hljs-keyword">null</span>) &#123;
			onlineCount = <span class="hljs-number">1</span>;
		&#125;<span class="hljs-keyword">else</span>&#123;
			<span class="hljs-keyword">int</span> count = onlineCount;
			onlineCount = count + <span class="hljs-number">1</span>;
		&#125;
		servletContext.setAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>, onlineCount);
	&#125;

	<span class="hljs-comment">// 销毁session监听</span>
	<span class="hljs-comment">// 一旦销毁Session就会触发一次这个事件</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;
		ServletContext servletContext = httpSessionEvent.getSession().getServletContext();
		Integer onlineCount = (Integer) servletContext.getAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>);
		<span class="hljs-keyword">if</span> (onlineCount == <span class="hljs-keyword">null</span>) &#123;
			onlineCount = <span class="hljs-number">0</span>;
		&#125;<span class="hljs-keyword">else</span>&#123;
			<span class="hljs-keyword">int</span> count = onlineCount;
			onlineCount = count - <span class="hljs-number">1</span>;
		&#125;
		servletContext.setAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>, onlineCount);
	&#125;
&#125;</code></pre></div>
</li>
<li><p>web.xml中注册监听器</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册监听器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.pnca.listener.OnlineCountListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre></div>
</li>
<li><p>看情况是否使用</p>
</li>
</ol>
<h2 id="11，过滤器，监听器常见应用"><a href="#11，过滤器，监听器常见应用" class="headerlink" title="11，过滤器，监听器常见应用"></a>11，过滤器，监听器常见应用</h2><p><strong>监听器: GUI编程中经常使用</strong></p>
<p>用户登录之后才能进入主页!用户注销后就不能进入主页!</p>
<ol>
<li><p>用户登录之后,向Session中放入用户数据</p>
</li>
<li><p>进入主页的时候要判断用户是否已经登录;要求: 在过滤器中实现</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;

		HttpServletRequest request = (HttpServletRequest)servletRequest;
		HttpServletResponse response = (HttpServletResponse)servletResponse;

		<span class="hljs-keyword">if</span>(request.getSession().getAttribute(Constant.USER_SESSION) == <span class="hljs-keyword">null</span>) &#123;
			response.sendRedirect(<span class="hljs-string">&quot;/error.jsp&quot;</span>);
		&#125;

		filterChain.doFilter(servletRequest, servletResponse);
	&#125;</code></pre></div>



</li>
</ol>
<h2 id="12，JDBC"><a href="#12，JDBC" class="headerlink" title="12，JDBC"></a>12，JDBC</h2><p>什么是JDBC：java连接数据库</p>
<p>需要jar包的支持：</p>
<ul>
<li>java.spl</li>
<li>javax.sql</li>
<li>mysql-conneter-java… 连接驱动(必须要导入)</li>
</ul>
<p><strong>实验环境搭建</strong></p>
<ol>
<li><p>创建一个测试数据库和一个users表</p>
</li>
<li><p>导入数据库依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>IDEA中连接数据库,注意要设置时区   <strong>[serverTimezone=GMT]</strong></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20210124201810440.png" alt="image-20210124201810440"></p>
</li>
<li><p>JDBC一般步骤</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 配置信息</span>
String url = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT&quot;</span>; <span class="hljs-comment">// 注意点</span>
String username = <span class="hljs-string">&quot;****&quot;</span>;
String password = <span class="hljs-string">&quot;****&quot;</span>;

<span class="hljs-comment">// 1,加载驱动</span>
Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);
<span class="hljs-comment">// 2,连接数据库</span>
Connection connection = DriverManager.getConnection(url, username, password);
<span class="hljs-comment">// 3,向数据库发送SQL对象的Statement : CRUD</span>
Statement statement = connection.createStatement();
<span class="hljs-comment">// 4.编写sql</span>
String sql = <span class="hljs-string">&quot;select * from users&quot;</span>;
<span class="hljs-comment">// 5,执行查询sql,返回resultSet结果集</span>
ResultSet resultSet = statement.executeQuery(sql);

<span class="hljs-keyword">while</span> (resultSet.next())&#123;
    System.out.println(<span class="hljs-string">&quot;id=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;id&quot;</span>));
    System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;name&quot;</span>));
    System.out.println(<span class="hljs-string">&quot;password=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;password&quot;</span>));
    System.out.println(<span class="hljs-string">&quot;email=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;email&quot;</span>));
    System.out.println(<span class="hljs-string">&quot;birthday=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;birthday&quot;</span>));
    System.out.println();
&#125;

<span class="hljs-comment">// 6,关闭连接,释放资源,掀开的后关</span>
resultSet.close();
statement.close();
connection.close();
</code></pre></div>

</li>
</ol>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>要么都成功,要么都失败!</p>
<p>ACID: 保证数据的安全。</p>
<ul>
<li>开启事务</li>
<li>事务提交：commit()</li>
<li>事务回滚：rollback()</li>
<li>关闭事务</li>
</ul>
<p>Junit测试</p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20210125200341950.png" alt="image-20210125200341950"></p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20210125200414496.png" alt="image-20210125200414496"></p>
<p>搭建一个环境，测试事务</p>
<h2 id="13，SMBMS订单管理系统"><a href="#13，SMBMS订单管理系统" class="headerlink" title="13，SMBMS订单管理系统"></a>13，SMBMS订单管理系统</h2><h3 id="1-架构"><a href="#1-架构" class="headerlink" title="1 架构"></a>1 架构</h3><p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20210126210811332.png" alt="image-20210126210811332"></p>
<h3 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2 数据库"></a>2 数据库</h3><p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20210126210835622.png" alt="image-20210126210835622"></p>
<p><strong>SQL语句</strong></p>
<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE `smbms`;

USE `smbms`;

<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `smbms_address`;

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `smbms_address` (
  `id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,
  `contact` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;联系人姓名&#x27;</span>,
  `addressDesc` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;收货地址明细&#x27;</span>,
  `postCode` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;邮编&#x27;</span>,
  `tel` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;联系人电话&#x27;</span>,
  `createdBy` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建者&#x27;</span>,
  `creationDate` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,
  `modifyBy` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改者&#x27;</span>,
  `modifyDate` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,
  `userId` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户ID&#x27;</span>,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)
) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">7</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_unicode_ci;


<span class="hljs-keyword">INSERT</span>  <span class="hljs-keyword">INTO</span> `smbms_address`(`id`,`contact`,`addressDesc`,`postCode`,`tel`,`createdBy`,`creationDate`,`modifyBy`,`modifyDate`,`userId`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;王丽&#x27;</span>,<span class="hljs-string">&#x27;北京市东城区东交民巷44号&#x27;</span>,<span class="hljs-string">&#x27;100010&#x27;</span>,<span class="hljs-string">&#x27;13678789999&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-13 00:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;张红丽&#x27;</span>,<span class="hljs-string">&#x27;北京市海淀区丹棱街3号&#x27;</span>,<span class="hljs-string">&#x27;100000&#x27;</span>,<span class="hljs-string">&#x27;18567672312&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-13 00:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;任志强&#x27;</span>,<span class="hljs-string">&#x27;北京市东城区美术馆后街23号&#x27;</span>,<span class="hljs-string">&#x27;100021&#x27;</span>,<span class="hljs-string">&#x27;13387906742&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-13 00:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;曹颖&#x27;</span>,<span class="hljs-string">&#x27;北京市朝阳区朝阳门南大街14号&#x27;</span>,<span class="hljs-string">&#x27;100053&#x27;</span>,<span class="hljs-string">&#x27;13568902323&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-13 00:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;李慧&#x27;</span>,<span class="hljs-string">&#x27;北京市西城区三里河路南三巷3号&#x27;</span>,<span class="hljs-string">&#x27;100032&#x27;</span>,<span class="hljs-string">&#x27;18032356666&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-13 00:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;王国强&#x27;</span>,<span class="hljs-string">&#x27;北京市顺义区高丽营镇金马工业区18号&#x27;</span>,<span class="hljs-string">&#x27;100061&#x27;</span>,<span class="hljs-string">&#x27;13787882222&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-13 00:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">3</span>);


<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `smbms_bill`;

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `smbms_bill` (
  `id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,
  `billCode` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;账单编码&#x27;</span>,
  `productName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品名称&#x27;</span>,
  `productDesc` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品描述&#x27;</span>,
  `productUnit` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品单位&#x27;</span>,
  `productCount` <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">20</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品数量&#x27;</span>,
  `totalPrice` <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">20</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品总额&#x27;</span>,
  `isPayment` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;是否支付（1：未支付 2：已支付）&#x27;</span>,
  `createdBy` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建者（userId）&#x27;</span>,
  `creationDate` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,
  `modifyBy` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;更新者（userId）&#x27;</span>,
  `modifyDate` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,
  `providerId` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;供应商ID&#x27;</span>,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)
) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">19</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_unicode_ci;


<span class="hljs-keyword">INSERT</span>  <span class="hljs-keyword">INTO</span> `smbms_bill`(`id`,`billCode`,`productName`,`productDesc`,`productUnit`,`productCount`,`totalPrice`,`isPayment`,`createdBy`,`creationDate`,`modifyBy`,`modifyDate`,`providerId`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;BILL2016_002&#x27;</span>,<span class="hljs-string">&#x27;香皂、肥皂、药皂&#x27;</span>,<span class="hljs-string">&#x27;日用品-皂类&#x27;</span>,<span class="hljs-string">&#x27;块&#x27;</span>,<span class="hljs-string">&#x27;1000.00&#x27;</span>,<span class="hljs-string">&#x27;10000.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-03-23 04:20:40&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">13</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;BILL2016_003&#x27;</span>,<span class="hljs-string">&#x27;大豆油&#x27;</span>,<span class="hljs-string">&#x27;食品-食用油&#x27;</span>,<span class="hljs-string">&#x27;斤&#x27;</span>,<span class="hljs-string">&#x27;300.00&#x27;</span>,<span class="hljs-string">&#x27;5890.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2014-12-14 13:02:03&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">6</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;BILL2016_004&#x27;</span>,<span class="hljs-string">&#x27;橄榄油&#x27;</span>,<span class="hljs-string">&#x27;食品-进口食用油&#x27;</span>,<span class="hljs-string">&#x27;斤&#x27;</span>,<span class="hljs-string">&#x27;200.00&#x27;</span>,<span class="hljs-string">&#x27;9800.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2013-10-10 03:12:13&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">7</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;BILL2016_005&#x27;</span>,<span class="hljs-string">&#x27;洗洁精&#x27;</span>,<span class="hljs-string">&#x27;日用品-厨房清洁&#x27;</span>,<span class="hljs-string">&#x27;瓶&#x27;</span>,<span class="hljs-string">&#x27;500.00&#x27;</span>,<span class="hljs-string">&#x27;7000.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2014-12-14 13:02:03&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">9</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;BILL2016_006&#x27;</span>,<span class="hljs-string">&#x27;美国大杏仁&#x27;</span>,<span class="hljs-string">&#x27;食品-坚果&#x27;</span>,<span class="hljs-string">&#x27;袋&#x27;</span>,<span class="hljs-string">&#x27;300.00&#x27;</span>,<span class="hljs-string">&#x27;5000.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-14 06:08:09&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">4</span>),(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;BILL2016_007&#x27;</span>,<span class="hljs-string">&#x27;沐浴液、精油&#x27;</span>,<span class="hljs-string">&#x27;日用品-沐浴类&#x27;</span>,<span class="hljs-string">&#x27;瓶&#x27;</span>,<span class="hljs-string">&#x27;500.00&#x27;</span>,<span class="hljs-string">&#x27;23000.00&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-07-22 10:10:22&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">14</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;BILL2016_008&#x27;</span>,<span class="hljs-string">&#x27;不锈钢盘碗&#x27;</span>,<span class="hljs-string">&#x27;日用品-厨房用具&#x27;</span>,<span class="hljs-string">&#x27;个&#x27;</span>,<span class="hljs-string">&#x27;600.00&#x27;</span>,<span class="hljs-string">&#x27;6000.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-14 05:12:13&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">14</span>),(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;BILL2016_009&#x27;</span>,<span class="hljs-string">&#x27;塑料杯&#x27;</span>,<span class="hljs-string">&#x27;日用品-杯子&#x27;</span>,<span class="hljs-string">&#x27;个&#x27;</span>,<span class="hljs-string">&#x27;350.00&#x27;</span>,<span class="hljs-string">&#x27;1750.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-02-04 11:40:20&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">14</span>),(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;BILL2016_010&#x27;</span>,<span class="hljs-string">&#x27;豆瓣酱&#x27;</span>,<span class="hljs-string">&#x27;食品-调料&#x27;</span>,<span class="hljs-string">&#x27;瓶&#x27;</span>,<span class="hljs-string">&#x27;200.00&#x27;</span>,<span class="hljs-string">&#x27;2000.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2013-10-29 05:07:03&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">8</span>),(<span class="hljs-number">11</span>,<span class="hljs-string">&#x27;BILL2016_011&#x27;</span>,<span class="hljs-string">&#x27;海之蓝&#x27;</span>,<span class="hljs-string">&#x27;饮料-国酒&#x27;</span>,<span class="hljs-string">&#x27;瓶&#x27;</span>,<span class="hljs-string">&#x27;50.00&#x27;</span>,<span class="hljs-string">&#x27;10000.00&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-14 16:16:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">12</span>,<span class="hljs-string">&#x27;BILL2016_012&#x27;</span>,<span class="hljs-string">&#x27;芝华士&#x27;</span>,<span class="hljs-string">&#x27;饮料-洋酒&#x27;</span>,<span class="hljs-string">&#x27;瓶&#x27;</span>,<span class="hljs-string">&#x27;20.00&#x27;</span>,<span class="hljs-string">&#x27;6000.00&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-09-09 17:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">13</span>,<span class="hljs-string">&#x27;BILL2016_013&#x27;</span>,<span class="hljs-string">&#x27;长城红葡萄酒&#x27;</span>,<span class="hljs-string">&#x27;饮料-红酒&#x27;</span>,<span class="hljs-string">&#x27;瓶&#x27;</span>,<span class="hljs-string">&#x27;60.00&#x27;</span>,<span class="hljs-string">&#x27;800.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-11-14 15:23:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">14</span>,<span class="hljs-string">&#x27;BILL2016_014&#x27;</span>,<span class="hljs-string">&#x27;泰国香米&#x27;</span>,<span class="hljs-string">&#x27;食品-大米&#x27;</span>,<span class="hljs-string">&#x27;斤&#x27;</span>,<span class="hljs-string">&#x27;400.00&#x27;</span>,<span class="hljs-string">&#x27;5000.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-10-09 15:20:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">15</span>,<span class="hljs-string">&#x27;BILL2016_015&#x27;</span>,<span class="hljs-string">&#x27;东北大米&#x27;</span>,<span class="hljs-string">&#x27;食品-大米&#x27;</span>,<span class="hljs-string">&#x27;斤&#x27;</span>,<span class="hljs-string">&#x27;600.00&#x27;</span>,<span class="hljs-string">&#x27;4000.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-11-14 14:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">3</span>),(<span class="hljs-number">16</span>,<span class="hljs-string">&#x27;BILL2016_016&#x27;</span>,<span class="hljs-string">&#x27;可口可乐&#x27;</span>,<span class="hljs-string">&#x27;饮料&#x27;</span>,<span class="hljs-string">&#x27;瓶&#x27;</span>,<span class="hljs-string">&#x27;2000.00&#x27;</span>,<span class="hljs-string">&#x27;6000.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2012-03-27 13:03:01&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">17</span>,<span class="hljs-string">&#x27;BILL2016_017&#x27;</span>,<span class="hljs-string">&#x27;脉动&#x27;</span>,<span class="hljs-string">&#x27;饮料&#x27;</span>,<span class="hljs-string">&#x27;瓶&#x27;</span>,<span class="hljs-string">&#x27;1500.00&#x27;</span>,<span class="hljs-string">&#x27;4500.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-05-10 12:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;BILL2016_018&#x27;</span>,<span class="hljs-string">&#x27;哇哈哈&#x27;</span>,<span class="hljs-string">&#x27;饮料&#x27;</span>,<span class="hljs-string">&#x27;瓶&#x27;</span>,<span class="hljs-string">&#x27;2000.00&#x27;</span>,<span class="hljs-string">&#x27;4000.00&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2015-11-24 15:12:03&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">2</span>);

<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `smbms_provider`;

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `smbms_provider` (
  `id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,
  `proCode` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;供应商编码&#x27;</span>,
  `proName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;供应商名称&#x27;</span>,
  `proDesc` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;供应商详细描述&#x27;</span>,
  `proContact` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;供应商联系人&#x27;</span>,
  `proPhone` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;联系电话&#x27;</span>,
  `proAddress` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;地址&#x27;</span>,
  `proFax` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;传真&#x27;</span>,
  `createdBy` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建者（userId）&#x27;</span>,
  `creationDate` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,
  `modifyDate` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,
  `modifyBy` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;更新者（userId）&#x27;</span>,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)
) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">16</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_unicode_ci;


<span class="hljs-keyword">INSERT</span>  <span class="hljs-keyword">INTO</span> `smbms_provider`(`id`,`proCode`,`proName`,`proDesc`,`proContact`,`proPhone`,`proAddress`,`proFax`,`createdBy`,`creationDate`,`modifyDate`,`modifyBy`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;BJ_GYS001&#x27;</span>,<span class="hljs-string">&#x27;北京三木堂商贸有限公司&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品:茅台、五粮液、郎酒、酒鬼酒、泸州老窖、赖茅酒、法国红酒等&#x27;</span>,<span class="hljs-string">&#x27;张国强&#x27;</span>,<span class="hljs-string">&#x27;13566667777&#x27;</span>,<span class="hljs-string">&#x27;北京市丰台区育芳园北路&#x27;</span>,<span class="hljs-string">&#x27;010-58858787&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2013-03-21 16:52:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;HB_GYS001&#x27;</span>,<span class="hljs-string">&#x27;石家庄帅益食品贸易有限公司&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品:饮料、水饮料、植物蛋白饮料、休闲食品、果汁饮料、功能饮料等&#x27;</span>,<span class="hljs-string">&#x27;王军&#x27;</span>,<span class="hljs-string">&#x27;13309094212&#x27;</span>,<span class="hljs-string">&#x27;河北省石家庄新华区&#x27;</span>,<span class="hljs-string">&#x27;0311-67738876&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-13 04:20:40&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;GZ_GYS001&#x27;</span>,<span class="hljs-string">&#x27;深圳市泰香米业有限公司&#x27;</span>,<span class="hljs-string">&#x27;初次合作伙伴，主营产品：良记金轮米,龙轮香米等&#x27;</span>,<span class="hljs-string">&#x27;郑程瀚&#x27;</span>,<span class="hljs-string">&#x27;13402013312&#x27;</span>,<span class="hljs-string">&#x27;广东省深圳市福田区深南大道6006华丰大厦&#x27;</span>,<span class="hljs-string">&#x27;0755-67776212&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2014-03-21 16:56:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;GZ_GYS002&#x27;</span>,<span class="hljs-string">&#x27;深圳市喜来客商贸有限公司&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品：坚果炒货.果脯蜜饯.天然花茶.营养豆豆.特色美食.进口食品.海味零食.肉脯肉&#x27;</span>,<span class="hljs-string">&#x27;林妮&#x27;</span>,<span class="hljs-string">&#x27;18599897645&#x27;</span>,<span class="hljs-string">&#x27;广东省深圳市福龙工业区B2栋3楼西&#x27;</span>,<span class="hljs-string">&#x27;0755-67772341&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2013-03-22 16:52:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;JS_GYS001&#x27;</span>,<span class="hljs-string">&#x27;兴化佳美调味品厂&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品：天然香辛料、鸡精、复合调味料&#x27;</span>,<span class="hljs-string">&#x27;徐国洋&#x27;</span>,<span class="hljs-string">&#x27;13754444221&#x27;</span>,<span class="hljs-string">&#x27;江苏省兴化市林湖工业区&#x27;</span>,<span class="hljs-string">&#x27;0523-21299098&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2015-11-22 16:52:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;BJ_GYS002&#x27;</span>,<span class="hljs-string">&#x27;北京纳福尔食用油有限公司&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品：山茶油、大豆油、花生油、橄榄油等&#x27;</span>,<span class="hljs-string">&#x27;马莺&#x27;</span>,<span class="hljs-string">&#x27;13422235678&#x27;</span>,<span class="hljs-string">&#x27;北京市朝阳区珠江帝景1号楼&#x27;</span>,<span class="hljs-string">&#x27;010-588634233&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2012-03-21 17:52:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;BJ_GYS003&#x27;</span>,<span class="hljs-string">&#x27;北京国粮食用油有限公司&#x27;</span>,<span class="hljs-string">&#x27;初次合作伙伴，主营产品：花生油、大豆油、小磨油等&#x27;</span>,<span class="hljs-string">&#x27;王驰&#x27;</span>,<span class="hljs-string">&#x27;13344441135&#x27;</span>,<span class="hljs-string">&#x27;北京大兴青云店开发区&#x27;</span>,<span class="hljs-string">&#x27;010-588134111&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-13 00:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;ZJ_GYS001&#x27;</span>,<span class="hljs-string">&#x27;慈溪市广和绿色食品厂&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品：豆瓣酱、黄豆酱、甜面酱，辣椒，大蒜等农产品&#x27;</span>,<span class="hljs-string">&#x27;薛圣丹&#x27;</span>,<span class="hljs-string">&#x27;18099953223&#x27;</span>,<span class="hljs-string">&#x27;浙江省宁波市慈溪周巷小安村&#x27;</span>,<span class="hljs-string">&#x27;0574-34449090&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2013-11-21 06:02:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;GX_GYS001&#x27;</span>,<span class="hljs-string">&#x27;优百商贸有限公司&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品：日化产品&#x27;</span>,<span class="hljs-string">&#x27;李立国&#x27;</span>,<span class="hljs-string">&#x27;13323566543&#x27;</span>,<span class="hljs-string">&#x27;广西南宁市秀厢大道42-1号&#x27;</span>,<span class="hljs-string">&#x27;0771-98861134&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2013-03-21 19:52:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;JS_GYS002&#x27;</span>,<span class="hljs-string">&#x27;南京火头军信息技术有限公司&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品：不锈钢厨具等&#x27;</span>,<span class="hljs-string">&#x27;陈女士&#x27;</span>,<span class="hljs-string">&#x27;13098992113&#x27;</span>,<span class="hljs-string">&#x27;江苏省南京市浦口区浦口大道1号新城总部大厦A座903室&#x27;</span>,<span class="hljs-string">&#x27;025-86223345&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2013-03-25 16:52:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">11</span>,<span class="hljs-string">&#x27;GZ_GYS003&#x27;</span>,<span class="hljs-string">&#x27;广州市白云区美星五金制品厂&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品：海绵床垫、坐垫、靠垫、海绵枕头、头枕等&#x27;</span>,<span class="hljs-string">&#x27;梁天&#x27;</span>,<span class="hljs-string">&#x27;13562276775&#x27;</span>,<span class="hljs-string">&#x27;广州市白云区钟落潭镇福龙路20号&#x27;</span>,<span class="hljs-string">&#x27;020-85542231&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-12-21 06:12:17&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">12</span>,<span class="hljs-string">&#x27;BJ_GYS004&#x27;</span>,<span class="hljs-string">&#x27;北京隆盛日化科技&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品：日化环保清洗剂，家居洗涤专卖、洗涤用品网、墙体除霉剂、墙面霉菌清除剂等&#x27;</span>,<span class="hljs-string">&#x27;孙欣&#x27;</span>,<span class="hljs-string">&#x27;13689865678&#x27;</span>,<span class="hljs-string">&#x27;北京市大兴区旧宫&#x27;</span>,<span class="hljs-string">&#x27;010-35576786&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2014-11-21 12:51:11&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">13</span>,<span class="hljs-string">&#x27;SD_GYS001&#x27;</span>,<span class="hljs-string">&#x27;山东豪克华光联合发展有限公司&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品：洗衣皂、洗衣粉、洗衣液、洗洁精、消杀类、香皂等&#x27;</span>,<span class="hljs-string">&#x27;吴洪转&#x27;</span>,<span class="hljs-string">&#x27;13245468787&#x27;</span>,<span class="hljs-string">&#x27;山东济阳济北工业区仁和街21号&#x27;</span>,<span class="hljs-string">&#x27;0531-53362445&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2015-01-28 10:52:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">14</span>,<span class="hljs-string">&#x27;JS_GYS003&#x27;</span>,<span class="hljs-string">&#x27;无锡喜源坤商行&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品：日化品批销&#x27;</span>,<span class="hljs-string">&#x27;周一清&#x27;</span>,<span class="hljs-string">&#x27;18567674532&#x27;</span>,<span class="hljs-string">&#x27;江苏无锡盛岸西路&#x27;</span>,<span class="hljs-string">&#x27;0510-32274422&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-23 11:11:11&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">15</span>,<span class="hljs-string">&#x27;ZJ_GYS002&#x27;</span>,<span class="hljs-string">&#x27;乐摆日用品厂&#x27;</span>,<span class="hljs-string">&#x27;长期合作伙伴，主营产品：各种中、高档塑料杯，塑料乐扣水杯（密封杯）、保鲜杯（保鲜盒）、广告杯、礼品杯&#x27;</span>,<span class="hljs-string">&#x27;王世杰&#x27;</span>,<span class="hljs-string">&#x27;13212331567&#x27;</span>,<span class="hljs-string">&#x27;浙江省金华市义乌市义东路&#x27;</span>,<span class="hljs-string">&#x27;0579-34452321&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-08-22 10:01:30&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>);


<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `smbms_role`;

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `smbms_role` (
  `id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,
  `roleCode` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;角色编码&#x27;</span>,
  `roleName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;角色名称&#x27;</span>,
  `createdBy` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建者&#x27;</span>,
  `creationDate` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,
  `modifyBy` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改者&#x27;</span>,
  `modifyDate` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;修改时间&#x27;</span>,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)
) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_unicode_ci;


<span class="hljs-keyword">INSERT</span>  <span class="hljs-keyword">INTO</span> `smbms_role`(`id`,`roleCode`,`roleName`,`createdBy`,`creationDate`,`modifyBy`,`modifyDate`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;SMBMS_ADMIN&#x27;</span>,<span class="hljs-string">&#x27;系统管理员&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-13 00:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;SMBMS_MANAGER&#x27;</span>,<span class="hljs-string">&#x27;经理&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-13 00:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;SMBMS_EMPLOYEE&#x27;</span>,<span class="hljs-string">&#x27;普通员工&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-13 00:00:00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>);


<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `smbms_user`;

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `smbms_user` (
  `id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键ID&#x27;</span>,
  `userCode` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户编码&#x27;</span>,
  `userName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户名称&#x27;</span>,
  `userPassword` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户密码&#x27;</span>,
  `gender` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;性别（1:女、 2:男）&#x27;</span>,
  `birthday` <span class="hljs-type">DATE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;出生日期&#x27;</span>,
  `phone` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;手机&#x27;</span>,
  `address` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;地址&#x27;</span>,
  `userRole` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户角色（取自角色表-角色id）&#x27;</span>,
  `createdBy` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建者（userId）&#x27;</span>,
  `creationDate` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,
  `modifyBy` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;更新者（userId）&#x27;</span>,
  `modifyDate` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)
) ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">16</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_unicode_ci;

<span class="hljs-keyword">INSERT</span>  <span class="hljs-keyword">INTO</span> `smbms_user`(`id`,`userCode`,`userName`,`userPassword`,`gender`,`birthday`,`phone`,`address`,`userRole`,`createdBy`,`creationDate`,`modifyBy`,`modifyDate`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;系统管理员&#x27;</span>,<span class="hljs-string">&#x27;1234567&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;1983-10-10&#x27;</span>,<span class="hljs-string">&#x27;13688889999&#x27;</span>,<span class="hljs-string">&#x27;北京市海淀区成府路207号&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2013-03-21 16:52:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;liming&#x27;</span>,<span class="hljs-string">&#x27;李明&#x27;</span>,<span class="hljs-string">&#x27;0000000&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;1983-12-10&#x27;</span>,<span class="hljs-string">&#x27;13688884457&#x27;</span>,<span class="hljs-string">&#x27;北京市东城区前门东大街9号&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2014-12-31 19:52:09&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;hanlubiao&#x27;</span>,<span class="hljs-string">&#x27;韩路彪&#x27;</span>,<span class="hljs-string">&#x27;0000000&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;1984-06-05&#x27;</span>,<span class="hljs-string">&#x27;18567542321&#x27;</span>,<span class="hljs-string">&#x27;北京市朝阳区北辰中心12号&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2014-12-31 19:52:09&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;zhanghua&#x27;</span>,<span class="hljs-string">&#x27;张华&#x27;</span>,<span class="hljs-string">&#x27;0000000&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;1983-06-15&#x27;</span>,<span class="hljs-string">&#x27;13544561111&#x27;</span>,<span class="hljs-string">&#x27;北京市海淀区学院路61号&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2013-02-11 10:51:17&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;wangyang&#x27;</span>,<span class="hljs-string">&#x27;王洋&#x27;</span>,<span class="hljs-string">&#x27;0000000&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;1982-12-31&#x27;</span>,<span class="hljs-string">&#x27;13444561124&#x27;</span>,<span class="hljs-string">&#x27;北京市海淀区西二旗辉煌国际16层&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2014-06-11 19:09:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;zhaoyan&#x27;</span>,<span class="hljs-string">&#x27;赵燕&#x27;</span>,<span class="hljs-string">&#x27;0000000&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;1986-03-07&#x27;</span>,<span class="hljs-string">&#x27;18098764545&#x27;</span>,<span class="hljs-string">&#x27;北京市海淀区回龙观小区10号楼&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-21 13:54:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;sunlei&#x27;</span>,<span class="hljs-string">&#x27;孙磊&#x27;</span>,<span class="hljs-string">&#x27;0000000&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;1981-01-04&#x27;</span>,<span class="hljs-string">&#x27;13387676765&#x27;</span>,<span class="hljs-string">&#x27;北京市朝阳区管庄新月小区12楼&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2015-05-06 10:52:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">11</span>,<span class="hljs-string">&#x27;sunxing&#x27;</span>,<span class="hljs-string">&#x27;孙兴&#x27;</span>,<span class="hljs-string">&#x27;0000000&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;1978-03-12&#x27;</span>,<span class="hljs-string">&#x27;13367890900&#x27;</span>,<span class="hljs-string">&#x27;北京市朝阳区建国门南大街10号&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-11-09 16:51:17&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">12</span>,<span class="hljs-string">&#x27;zhangchen&#x27;</span>,<span class="hljs-string">&#x27;张晨&#x27;</span>,<span class="hljs-string">&#x27;0000000&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;1986-03-28&#x27;</span>,<span class="hljs-string">&#x27;18098765434&#x27;</span>,<span class="hljs-string">&#x27;朝阳区管庄路口北柏林爱乐三期13号楼&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-08-09 05:52:37&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-04-14 14:15:36&#x27;</span>),(<span class="hljs-number">13</span>,<span class="hljs-string">&#x27;dengchao&#x27;</span>,<span class="hljs-string">&#x27;邓超&#x27;</span>,<span class="hljs-string">&#x27;0000000&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;1981-11-04&#x27;</span>,<span class="hljs-string">&#x27;13689674534&#x27;</span>,<span class="hljs-string">&#x27;北京市海淀区北航家属院10号楼&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2016-07-11 08:02:47&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">14</span>,<span class="hljs-string">&#x27;yangguo&#x27;</span>,<span class="hljs-string">&#x27;杨过&#x27;</span>,<span class="hljs-string">&#x27;0000000&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;1980-01-01&#x27;</span>,<span class="hljs-string">&#x27;13388886623&#x27;</span>,<span class="hljs-string">&#x27;北京市朝阳区北苑家园茉莉园20号楼&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2015-02-01 03:52:07&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>),(<span class="hljs-number">15</span>,<span class="hljs-string">&#x27;zhaomin&#x27;</span>,<span class="hljs-string">&#x27;赵敏&#x27;</span>,<span class="hljs-string">&#x27;0000000&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;1987-12-04&#x27;</span>,<span class="hljs-string">&#x27;18099897657&#x27;</span>,<span class="hljs-string">&#x27;北京市昌平区天通苑3区12号楼&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2015-09-12 12:02:12&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>);</code></pre></div>

<h3 id="3-项目搭建"><a href="#3-项目搭建" class="headerlink" title="3 项目搭建"></a>3 项目搭建</h3><ol>
<li><p>搭建一个maven web项目</p>
</li>
<li><p>配置Tomcat</p>
</li>
<li><p>测试Tomcat服务器能否跑起来</p>
</li>
<li><p>导入项目中可能遇到的jar包</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>standard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>
</li>
<li><p>创建项目包结构</p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20210126212615538.png" alt="image-20210126212615538"></p>
</li>
<li><p>编写实体类</p>
<p>ORM映射：表-类映射</p>
</li>
<li><p>编写基础公共类</p>
<ol>
<li><p>数据库配置文件</p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
<span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT</span>
<span class="hljs-attr">username</span>=<span class="hljs-string">root</span>
<span class="hljs-attr">password</span>=<span class="hljs-string">root</span></code></pre></div>
</li>
<li><p>操作数据库的公共类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseDao</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String driver;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String url;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String username;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String password;

	<span class="hljs-comment">// 静态代码块,类加载的时候就初始化了</span>
	<span class="hljs-keyword">static</span> &#123;
		Properties properties = <span class="hljs-keyword">new</span> Properties();
		<span class="hljs-comment">// 通过类加载器读取对应的资源</span>
		InputStream is = BaseDao.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;db.properties&quot;</span>);
		<span class="hljs-keyword">try</span> &#123;
			properties.load(is);
			;
		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
			e.printStackTrace();
		&#125;

		driver = properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);
		url = properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);
		username = properties.getProperty(<span class="hljs-string">&quot;username&quot;</span>);
		password = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);
	&#125;

	<span class="hljs-comment">// 获取数据的连接</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;
		Connection connection = <span class="hljs-keyword">null</span>;
		<span class="hljs-keyword">try</span> &#123;
			Class.forName(driver);
			connection = DriverManager.getConnection(url, username, password);
		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
			e.printStackTrace();
		&#125;
		<span class="hljs-keyword">return</span> connection;
	&#125;

	<span class="hljs-comment">// 编写查询公共方法</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ResultSet <span class="hljs-title">execute</span><span class="hljs-params">(Connection connection, String sql, Object[] params, ResultSet resultSet, PreparedStatement preparedStatement)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
		<span class="hljs-comment">// 预编译的sql,在后面直接执行就可以了</span>
		preparedStatement = connection.prepareStatement(sql);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; params.length; i++) &#123;
			<span class="hljs-comment">// setObject,占位符从1开始,但是我们的数字时从0开始</span>
			preparedStatement.setObject(i + <span class="hljs-number">1</span>, params[i]);
		&#125;
		resultSet = preparedStatement.executeQuery();
		<span class="hljs-keyword">return</span> resultSet;
	&#125;

	<span class="hljs-comment">// 编写增删改公共方法</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">(Connection connection, String sql, Object[] params, PreparedStatement preparedStatement)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
		preparedStatement = connection.prepareStatement(sql);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; params.length; i++) &#123;
			<span class="hljs-comment">// setObject,占位符从1开始,但是我们的数字时从0开始</span>
			preparedStatement.setObject(i + <span class="hljs-number">1</span>, params[i]);
		&#125;
		<span class="hljs-keyword">return</span> preparedStatement.executeUpdate(); <span class="hljs-comment">// 返回更新的行数</span>
	&#125;
	
	<span class="hljs-comment">// 释放资源</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">closeResource</span><span class="hljs-params">(Connection connection, PreparedStatement preparedStatement, ResultSet resultSet)</span> </span>&#123;
		<span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;

		<span class="hljs-keyword">if</span> (resultSet != <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">try</span> &#123;
				resultSet.close();
				<span class="hljs-comment">// GC回收</span>
			&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;
				e.printStackTrace();
				flag = <span class="hljs-keyword">false</span>;
			&#125;
		&#125;

		<span class="hljs-keyword">if</span> (preparedStatement != <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">try</span> &#123;
				preparedStatement.close();
				<span class="hljs-comment">// GC回收</span>
			&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;
				e.printStackTrace();
				flag = <span class="hljs-keyword">false</span>;
			&#125;
		&#125;

		<span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">try</span> &#123;
				connection.close();
				<span class="hljs-comment">// GC回收</span>
			&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;
				e.printStackTrace();
				flag = <span class="hljs-keyword">false</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> flag;
	&#125;
&#125;</code></pre></div>
</li>
<li><p>编写字符编码过滤器</p>
</li>
</ol>
</li>
<li><p>导入静态资源</p>
</li>
</ol>
<h3 id="4-登录功能的实现"><a href="#4-登录功能的实现" class="headerlink" title="4 登录功能的实现"></a>4 登录功能的实现</h3><ol>
<li><p>编写前端页面</p>
</li>
<li><p>设置首页</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--设置欢迎页面--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>login.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span></code></pre></div>
</li>
<li><p>编写dao层登录用户登录的接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 得到要登陆的用户</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getLoginUser</span><span class="hljs-params">(Connection connection, String userCode)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</code></pre></div>
</li>
<li><p>编写dao接口的实现类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getLoginUser</span><span class="hljs-params">(Connection connection, String userCode)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;

		PreparedStatement pstm = <span class="hljs-keyword">null</span>;
		ResultSet rs = <span class="hljs-keyword">null</span>;
		User user = <span class="hljs-keyword">null</span>;

		<span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;
			String sql = <span class="hljs-string">&quot;select * from smbms_user where userCode=?&quot;</span>;
			Object[] params = &#123;userCode&#125;;

			rs = BaseDao.execute(connection, pstm, rs, sql, params);

			<span class="hljs-keyword">if</span> (rs.next()) &#123;
				user = <span class="hljs-keyword">new</span> User();
				user.setId(rs.getInt(<span class="hljs-string">&quot;id&quot;</span>));
				user.setUserCode(rs.getString(<span class="hljs-string">&quot;userCode&quot;</span>));
				user.setUserName(rs.getString(<span class="hljs-string">&quot;userName&quot;</span>));
				user.setUserPassword(rs.getString(<span class="hljs-string">&quot;userPassword&quot;</span>));
				user.setGender(rs.getInt(<span class="hljs-string">&quot;gender&quot;</span>));
				user.setBirthday(rs.getDate(<span class="hljs-string">&quot;birthday&quot;</span>));
				user.setPhone(rs.getString(<span class="hljs-string">&quot;phone&quot;</span>));
				user.setAddress(rs.getString(<span class="hljs-string">&quot;address&quot;</span>));
				user.setUserRole(rs.getInt(<span class="hljs-string">&quot;userRole&quot;</span>));
				user.setCreatedBy(rs.getInt(<span class="hljs-string">&quot;createdBy&quot;</span>));
				user.setCreationDate(rs.getTimestamp(<span class="hljs-string">&quot;creationDate&quot;</span>));
				user.setModifyBy(rs.getInt(<span class="hljs-string">&quot;modifyBy&quot;</span>));
				user.setModifyDate(rs.getTimestamp(<span class="hljs-string">&quot;modifyDate&quot;</span>));
			&#125;
			BaseDao.closeResource(<span class="hljs-keyword">null</span>, pstm, rs);

		&#125;
		<span class="hljs-keyword">return</span> user;
	&#125;
&#125;</code></pre></div>
</li>
<li><p>业务层接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 用户登录</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(String userCode, String password)</span></span>;</code></pre></div>
</li>
<li><p>业务层实现类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;

	<span class="hljs-comment">// 业务层都会调用dao层,所以我们要引入Dao层</span>
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDao userDao;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserServiceImpl</span><span class="hljs-params">()</span> </span>&#123;
		userDao = <span class="hljs-keyword">new</span> UserDaoImpl();
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(String userCode, String password)</span> </span>&#123;
		Connection connection = <span class="hljs-keyword">null</span>;
		User user = <span class="hljs-keyword">null</span>;

		<span class="hljs-keyword">try</span> &#123;
			connection = BaseDao.getConnection();
			<span class="hljs-comment">// 通过业务层调用对应的具体的数据库操作</span>
			user = userDao.getLoginUser(connection, userCode);
		&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;
			e.printStackTrace();
		&#125;<span class="hljs-keyword">finally</span> &#123;
			BaseDao.closeResource(connection, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
		&#125;
		<span class="hljs-keyword">return</span> user;
	&#125;
	
&#125;</code></pre></div>
</li>
<li><p>编写Servlet</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;

   <span class="hljs-comment">// Servlet: 控制层,调用业务层代码</span>

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
      System.out.println(<span class="hljs-string">&quot;LoginServlet---start....&quot;</span>);

      <span class="hljs-comment">// 获取用户名和密码</span>
      String userCode = req.getParameter(<span class="hljs-string">&quot;userCode&quot;</span>);
      String userPassword = req.getParameter(<span class="hljs-string">&quot;userPassword&quot;</span>);

      <span class="hljs-comment">// 和数据库中的密码进行对比,调用业务层</span>
      UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();
      User user = userService.login(userCode, userPassword);  <span class="hljs-comment">// 这里已经把登录的人给查出来了</span>
      <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 查由此人,可以登录</span>
         <span class="hljs-comment">// 将用户的信息放到Session中;</span>
         req.getSession().setAttribute(Constants.USER_SESSION, user);
         <span class="hljs-comment">// 跳转到主页</span>
         resp.sendRedirect(<span class="hljs-string">&quot;jsp/frame.jsp&quot;</span>);
      &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 查无此人,无法登录</span>
         <span class="hljs-comment">// 转发回登录页面,顺便提示他,用户名或密码错误</span>
         req.getRequestDispatcher(<span class="hljs-string">&quot;login.jsp&quot;</span>).forward(req, resp);

      &#125;
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
      doGet(req, resp);
   &#125;
&#125;</code></pre></div>
</li>
<li><p>注册Servlet</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Servlet--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>LoginServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.pnca.servlet.user.LoginServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>LoginServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/login.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>



</li>
</ol>
<h3 id="5-登录功能优化"><a href="#5-登录功能优化" class="headerlink" title="5 登录功能优化"></a>5 登录功能优化</h3><ul>
<li><p>注销</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogoutServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
		<span class="hljs-comment">// 移除用户的Constants.USER_SESSION</span>
		req.getSession().removeAttribute(Constants.USER_SESSION);
		resp.sendRedirect(req.getContextPath() + <span class="hljs-string">&quot;/login.jsp&quot;</span>); <span class="hljs-comment">// 返回登录页面</span>
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
		doGet(req, resp);
	&#125;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>LogoutServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.pnca.servlet.user.LogoutServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>LogoutServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/jsp/logout.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div>

</li>
</ul>
<p><strong>登录拦截优化</strong></p>
<ul>
<li><p>拦截过滤器</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;

	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;
		HttpServletRequest request = (HttpServletRequest) servletRequest;
		HttpServletResponse response = (HttpServletResponse) servletResponse;

		<span class="hljs-comment">// 过滤器,从Session中获取用户</span>
		User user = (User) request.getSession().getAttribute(Constants.USER_SESSION);
		<span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 已经被移除或者注销了,或者未登录</span>
			response.sendRedirect(<span class="hljs-string">&quot;/smbms/error.jsp&quot;</span>);
		&#125;<span class="hljs-keyword">else</span>&#123;
			filterChain.doFilter(servletRequest, servletResponse);
		&#125;
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;

	&#125;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--用户登录过滤器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>SysFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.pnca.filter.SysFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>SysFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/jsp/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre></div>

</li>
</ul>
<h3 id="6-密码修改"><a href="#6-密码修改" class="headerlink" title="6 密码修改"></a>6 密码修改</h3><ol>
<li><p>导入前端素材 </p>
</li>
<li><p>写项目，建议从底层向上写</p>
<p><img src="/2020/11/22/JavaWeb%E5%AD%A6%E4%B9%A0/image-20210131202002445.png" alt="image-20210131202002445"></p>
</li>
<li><p>UserDao接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 修改当前的用户密码</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updatePassword</span><span class="hljs-params">(Connection connection, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> password)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</code></pre></div>
</li>
<li><p>UserDao</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 修改当前的用户密码</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updatePassword</span><span class="hljs-params">(Connection connection, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> password)</span> <span class="hljs-keyword">throws</span> SQLException</span>&#123;
		PreparedStatement pstm = <span class="hljs-keyword">null</span>;
		<span class="hljs-keyword">int</span> execute = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;
			String sql = <span class="hljs-string">&quot;update smbms.smbms_user set userPassword = ? where id = ?&quot;</span>;
			Object[] params = &#123;password, id&#125;;
			execute = BaseDao.execute(connection, pstm, sql, params);
			BaseDao.closeResource(connection, pstm, <span class="hljs-keyword">null</span>);
		&#125;
		<span class="hljs-keyword">return</span> execute;
    &#125;</code></pre></div>
</li>
<li><p>UserService层</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 根据用户id修改当前的用户密码</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updatePassword</span><span class="hljs-params">( <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> password)</span></span>;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updatePassword</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> password)</span> </span>&#123;
		Connection connection = <span class="hljs-keyword">null</span>;
		<span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;

		<span class="hljs-keyword">try</span> &#123;
			connection = BaseDao.getConnection();
			<span class="hljs-comment">// 通过业务层调用对应的具体的数据库操作</span>
			<span class="hljs-keyword">if</span> (userDao.updatePassword(connection, id, password) &gt; <span class="hljs-number">0</span>) &#123;
				flag = <span class="hljs-keyword">true</span>;
			&#125;
		&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;
			e.printStackTrace();
		&#125; <span class="hljs-keyword">finally</span> &#123;
			BaseDao.closeResource(connection, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
		&#125;
		<span class="hljs-keyword">return</span> flag;
	&#125;</code></pre></div>
</li>
<li><p>UserServlet层</p>
<div class="code-wrapper"><pre><code class="hljs java">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
	<span class="hljs-comment">// 从Session里面拿id</span>
	Object attribute = req.getSession().getAttribute(Constants.USER_SESSION);
	<span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;
	String newpassword = req.getParameter(<span class="hljs-string">&quot;newpassword&quot;</span>);
	<span class="hljs-keyword">if</span> (attribute != <span class="hljs-keyword">null</span> &amp;&amp; !StringUtils.isNullOrEmpty(newpassword)) &#123;
		UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();
		flag = userService.updatePassword(((User) attribute).getId(), newpassword);
		<span class="hljs-keyword">if</span> (flag) &#123;
			req.setAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;修改密码成功,请退出,使用新密码登录&quot;</span>);
			<span class="hljs-comment">// 密码修改成功,移除Session</span>
			req.getSession().removeAttribute(Constants.USER_SESSION);
		&#125;<span class="hljs-keyword">else</span>&#123;
			req.setAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;修改密码失败&quot;</span>);
		&#125;
	&#125; <span class="hljs-keyword">else</span> &#123;
		req.setAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;新密码有问题!&quot;</span>);
	&#125;
	req.getRequestDispatcher(<span class="hljs-string">&quot;pwdmodify.jsp&quot;</span>).forward(req, resp);
&#125;</code></pre></div>
</li>
<li><p>记得实现复用，需要提取方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
		String method = req.getParameter(<span class="hljs-string">&quot;method&quot;</span>);
		<span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">&quot;savepwd&quot;</span>)) &#123;
			<span class="hljs-keyword">this</span>.updatePwd(req, resp);
		&#125;
	&#125;</code></pre></div>



</li>
</ol>
<h3 id="7-用户管理"><a href="#7-用户管理" class="headerlink" title="7 用户管理"></a>7 用户管理</h3><ol>
<li><p>UserDao接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 查询用户总数</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getUserCount</span><span class="hljs-params">(Connection connection, String username, <span class="hljs-keyword">int</span> userRole)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</code></pre></div>
</li>
<li><p>UserDaoImpl</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 根据用户名或者角色查询用户总数</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getUserCount</span><span class="hljs-params">(Connection connection, String username, <span class="hljs-keyword">int</span> userRole)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
		PreparedStatement pstm = <span class="hljs-keyword">null</span>;
		ResultSet rs = <span class="hljs-keyword">null</span>;
		<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;
			StringBuilder sql = <span class="hljs-keyword">new</span> StringBuilder();
			sql.append(<span class="hljs-string">&quot;select count(1) as count from smbms.smbms_user u, smbms.smbms_role r where u.userRole = r.id&quot;</span>);
			ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

			<span class="hljs-keyword">if</span> (!StringUtils.isNullOrEmpty(username)) &#123;
				sql.append(<span class="hljs-string">&quot; and u.userName like ?&quot;</span>);
				list.add(<span class="hljs-string">&quot;%&quot;</span> + username + <span class="hljs-string">&quot;%&quot;</span>);
			&#125;

			<span class="hljs-keyword">if</span> (userRole &gt; <span class="hljs-number">0</span>) &#123;
				sql.append(<span class="hljs-string">&quot; and u.userRole = ?&quot;</span>);
				list.add(userRole);
			&#125;
			Object[] params = list.toArray();
<span class="hljs-comment">//			System.out.println(&quot;UserDaoIml-&gt;getUserCount:&quot; + sql.toString());</span>
			rs = BaseDao.execute(connection, pstm, rs, sql.toString(), params);
			<span class="hljs-keyword">if</span> (rs.next()) &#123;
				count = rs.getInt(<span class="hljs-string">&quot;count&quot;</span>);
			&#125;
			BaseDao.closeResource(<span class="hljs-keyword">null</span>, pstm, rs);
		&#125;
		<span class="hljs-keyword">return</span> count;
	&#125;</code></pre></div>
</li>
<li><p>UserService层</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 查询记录数</span>
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getUserCount</span><span class="hljs-params">(String username, <span class="hljs-keyword">int</span> userRole)</span></span>;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getUserCount</span><span class="hljs-params">(String username, <span class="hljs-keyword">int</span> userRole)</span> </span>&#123;
		Connection connection = <span class="hljs-keyword">null</span>;
		<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

		<span class="hljs-keyword">try</span> &#123;
			connection = BaseDao.getConnection();
			count = userDao.getUserCount(connection, username, userRole);
		&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;
			e.printStackTrace();
		&#125; <span class="hljs-keyword">finally</span> &#123;
			BaseDao.closeResource(connection, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
		&#125;
		<span class="hljs-keyword">return</span> count;
	&#125;
</code></pre></div>
</li>
<li><p>UserServlet层</p>
<div class="code-wrapper"><pre><code class="hljs java">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
	<span class="hljs-comment">// 从Session里面拿id</span>
	Object attribute = req.getSession().getAttribute(Constants.USER_SESSION);
	<span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;
	String newpassword = req.getParameter(<span class="hljs-string">&quot;newpassword&quot;</span>);
	<span class="hljs-keyword">if</span> (attribute != <span class="hljs-keyword">null</span> &amp;&amp; !StringUtils.isNullOrEmpty(newpassword)) &#123;
		UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();
		flag = userService.updatePassword(((User) attribute).getId(), newpassword);
		<span class="hljs-keyword">if</span> (flag) &#123;
			req.setAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;修改密码成功,请退出,使用新密码登录&quot;</span>);
			<span class="hljs-comment">// 密码修改成功,移除Session</span>
			req.getSession().removeAttribute(Constants.USER_SESSION);
		&#125;<span class="hljs-keyword">else</span>&#123;
			req.setAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;修改密码失败&quot;</span>);
		&#125;
	&#125; <span class="hljs-keyword">else</span> &#123;
		req.setAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;新密码有问题!&quot;</span>);
	&#125;
	req.getRequestDispatcher(<span class="hljs-string">&quot;pwdmodify.jsp&quot;</span>).forward(req, resp);
&#125;</code></pre></div>
</li>
<li><p>记得实现复用，需要提取方法</p>
</li>
</ol>
<h2 id="14，文件上传"><a href="#14，文件上传" class="headerlink" title="14，文件上传"></a>14，文件上传</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>K8s 学习</title>
    <url>/2021/07/22/K8s%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="第1章-Kubernetes简介"><a href="#第1章-Kubernetes简介" class="headerlink" title="第1章 Kubernetes简介"></a>第1章 Kubernetes简介</h1><h2 id="1-来源"><a href="#1-来源" class="headerlink" title="1 来源"></a>1 来源</h2><p>bilibili尚硅谷K8s视频：<a href="https://www.bilibili.com/video/BV1GT4y1A756">https://www.bilibili.com/video/BV1GT4y1A756</a></p>
<p>中文官网：<a href="https://kubernetes.io/zh">https://kubernetes.io/zh</a></p>
<p>中文社区：<a href="https://www.kubernetes.org.cn/">https://www.kubernetes.org.cn/</a></p>
<h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2 介绍"></a>2 介绍</h2><p>K8s主要讲的就是Kubernetes，首先Kubernetes首字母为K，末尾为s，中间一共有8个字母，所以简称K8s</p>
<h2 id="3-前置知识"><a href="#3-前置知识" class="headerlink" title="3 前置知识"></a>3 前置知识</h2><ul>
<li>Linux操作系统</li>
<li>Docker</li>
</ul>
<h2 id="4-课程简介"><a href="#4-课程简介" class="headerlink" title="4 课程简介"></a>4 课程简介</h2><ul>
<li><p>K8s概念和架构</p>
</li>
<li><p>从零搭建K8s集群</p>
<ul>
<li>基于客户端工具kubeadm搭建（简单，最多半小时）</li>
<li>基于二进制包方式（能看到内部的架构）</li>
</ul>
</li>
<li><p>K8s核心概念</p>
<ul>
<li>Pod：K8s管理的最小单位级，是所有业务类型的基础</li>
<li>Controller：控制器，有状态，无状态，一次任务，定时任务，守护进程</li>
<li>Service Ingress：对外暴露端口</li>
<li>RBAC：安全机制，权限模型</li>
<li>Helm：下载机制</li>
<li>持久化存储</li>
</ul>
</li>
<li><p>搭建集群监控平台系统</p>
</li>
<li><p>从零搭建高可用K8s集群</p>
</li>
<li><p>在集群环境部署项目</p>
</li>
</ul>
<h2 id="5-K8s概念和特性"><a href="#5-K8s概念和特性" class="headerlink" title="5 K8s概念和特性"></a>5 K8s概念和特性</h2><h3 id="5-1-部署发展历程"><a href="#5-1-部署发展历程" class="headerlink" title="5.1 部署发展历程"></a>5.1 部署发展历程</h3><p>我们的项目部署也在经历下面的这样一个历程</p>
<blockquote>
<p>传统部署 -&gt; 虚拟化部署时代 -&gt; 容器部署时代</p>
</blockquote>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122104102715.png" alt="image-20201122104102715"></p>
<ul>
<li><strong>传统部署时代</strong>：早期，组织在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。例如，如果在物理服务器上运行多个应用程序，则可能会出现-一个应用程序占用大部分资源的情况，结果可能导致其他应用程序的性能下降。–种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展，并且组织维护许多物理服务器的成本很高。</li>
<li><strong>虚拟化部署时代</strong>：作为解决方案，引入了虚拟化功能，它允许您在单个物理服务器的CPU.上运行多个虚拟机（VM）。虚拟化功能允许应用程序在VM之间隔离，并提供安全级别，因为一一个应用程序的信息不能被另一应用程序自由地访问。因为虚拟化可以轻松地添加或更新应用程序、降低硬件成本等等，所以虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性。每个VM是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</li>
<li><strong>容器部署时代</strong>：容器类似于VM，但是它们具有轻量级的隔离属性，可以在应用程序之间共享操作系统<br>（OS），因此，容器被认为是轻量级的。容器与VM类似，具有自己的文件系统、CPU、内存、进程空间等。由于它们与基础架构分离，因此可以跨云和OS分发进行移植。</li>
</ul>
<p>容器因具有许多优势而变得流行起来。下面列出了容器的一些好处：</p>
<ul>
<li>敏捷应用程序的创建和部署：与使用VM镜像相比，提高了容器镜像创建的简便性和效率。</li>
<li>持续开发、集成和部署：通过简单的回滚（由于镜像不可变性），提供可靠且频繁的容器镜像构建和部署。</li>
<li>关注开发与运维的分离：在构建/时而不是在部署时创建应用程序容器镜像，将应用程序与基础架构分离。</li>
<li>可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li>
<li>跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。</li>
<li>云和操作系统分发的可移植性：可在Ubuntu、RHEL、RHEL、CoreOS、本地、Google Kubernetes Engine和其它任何其它地方运行。</li>
<li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行OS到使用逻辑资源在OS上运行应用程序。</li>
<li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分，并且可以动态部署和管理-而不是在一台大型单机上器体运行。</li>
<li>资源隔离：可预测的应用程序性能。</li>
</ul>
<h3 id="5-2-K8s概述"><a href="#5-2-K8s概述" class="headerlink" title="5.2 K8s概述"></a>5.2 K8s概述</h3><p>kubernetes，简称K8s，是用8 代替8 个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes 提供了应用部署，规划，更新，维护的一种机制。</p>
<p>传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新/回滚等操作，当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。</p>
<p>新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的。</p>
<blockquote>
<p>总结：</p>
<ul>
<li>K8s是谷歌在2014年发布的容器化集群管理系统</li>
<li>使用k8s进行容器化应用部署</li>
<li>使用k8s利于应用扩展</li>
<li>k8s目标实施让部署容器化应用更加简洁和高效</li>
</ul>
</blockquote>
<h3 id="5-3-K8s概述"><a href="#5-3-K8s概述" class="headerlink" title="5.3 K8s概述"></a>5.3 K8s概述</h3><p>Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes 能够进行应用的自动化部署和扩缩容。在Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。</p>
<p>Kubernetes 积累了作为Google 生产环境运行工作负载15 年的经验，并吸收了来自于社区的最佳想法和实践。</p>
<h3 id="5-4-K8s功能"><a href="#5-4-K8s功能" class="headerlink" title="5.4 K8s功能"></a>5.4 K8s功能</h3><h4 id="1-自动装箱"><a href="#1-自动装箱" class="headerlink" title="1 自动装箱"></a>1 自动装箱</h4><p>基于容器对应用运行环境的资源配置要求自动部署应用容器</p>
<h4 id="2-自我修复-自愈能力"><a href="#2-自我修复-自愈能力" class="headerlink" title="2 自我修复(自愈能力)"></a>2 自我修复(自愈能力)</h4><p>当容器失败时，会对容器进行重启</p>
<p>当所部署的Node节点有问题时，会对容器进行重新部署和重新调度</p>
<p>当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928101336750.png" alt="image-20200928101336750"></p>
<p>如果某个服务器上的应用不响应了，Kubernetes会自动在其它的地方创建一个</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122112241092.png" alt="image-20201122112241092"></p>
<h4 id="3-水平扩展"><a href="#3-水平扩展" class="headerlink" title="3 水平扩展"></a>3 水平扩展</h4><p>通过简单的命令、用户UI 界面或基于CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁</p>
<blockquote>
<p>当我们有大量的请求来临时，我们可以增加副本数量，从而达到水平扩展的效果</p>
</blockquote>
<p>当黄色应用过度忙碌，会来扩展一个应用</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122112301750.png" alt="image-20201122112301750"></p>
<h4 id="4-服务发现"><a href="#4-服务发现" class="headerlink" title="4 服务发现"></a>4 服务发现</h4><p>用户不需使用额外的服务发现机制，就能够基于Kubernetes 自身能力实现服务发现和负载均衡</p>
<blockquote>
<p>对外提供统一的入口，让它来做节点的调度和负载均衡， 相当于微服务里面的网关？</p>
</blockquote>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928101711968.png" alt="image-20200928101711968"></p>
<h4 id="5-滚动更新"><a href="#5-滚动更新" class="headerlink" title="5 滚动更新"></a>5 滚动更新</h4><p>可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新</p>
<blockquote>
<p>添加应用的时候，不是加进去就马上可以进行使用，而是需要判断这个添加进去的应用是否能够正常使用</p>
</blockquote>
<h4 id="6-版本回退"><a href="#6-版本回退" class="headerlink" title="6 版本回退"></a>6 版本回退</h4><p>可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</p>
<blockquote>
<p>类似于Git中的回滚</p>
</blockquote>
<h4 id="7-密钥和配置管理"><a href="#7-密钥和配置管理" class="headerlink" title="7 密钥和配置管理"></a>7 密钥和配置管理</h4><p>在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。</p>
<h4 id="8-存储编排"><a href="#8-存储编排" class="headerlink" title="8 存储编排"></a>8 存储编排</h4><p>自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要</p>
<p>存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务</p>
<h4 id="9-批处理"><a href="#9-批处理" class="headerlink" title="9 批处理"></a>9 批处理</h4><p>提供一次性任务，定时任务；满足批量数据处理和分析的场景</p>
<h2 id="6-K8s架构组件"><a href="#6-K8s架构组件" class="headerlink" title="6 K8s架构组件"></a>6 K8s架构组件</h2><h3 id="6-1-完整架构图"><a href="#6-1-完整架构图" class="headerlink" title="6.1 完整架构图"></a>6.1 完整架构图</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928103059652.png" alt="image-20200928103059652"></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928110124821.png" alt="image-20200928110124821"></p>
<h3 id="6-2-架构细节"><a href="#6-2-架构细节" class="headerlink" title="6.2 架构细节"></a>6.2 架构细节</h3><p>K8s架构主要包含两部分：Master（主控节点）和 node（工作节点）</p>
<p>master节点架构图</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122113057343.png" alt="image-20201122113057343"></p>
<p>Node节点架构图</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122155629990.png" alt="image-20201122155629990"></p>
<p>k8s 集群控制节点，对集群进行调度管理，接受集群外用户去集群操作请求；</p>
<ul>
<li><p><strong>master</strong>：主控节点</p>
<ul>
<li>API Server：集群统一入口，以restful风格进行操作，同时交给etcd存储<ul>
<li>提供认证、授权、访问控制、API注册和发现等机制</li>
</ul>
</li>
<li>scheduler：节点的调度，选择node节点应用部署</li>
<li>controller-manager：处理集群中常规后台任务，一个资源对应一个控制器</li>
<li>etcd：存储系统，用于保存集群中的相关数据</li>
</ul>
</li>
<li><p><strong>Work node</strong>：工作节点</p>
<ul>
<li>Kubelet：master派到node节点代表，管理本机容器<ul>
<li>一个集群中每个节点上运行的代理，它保证容器都运行在Pod中</li>
<li>负责维护容器的生命周期，同时也负责Volume(CSI) 和 网络(CNI)的管理</li>
</ul>
</li>
<li>kube-proxy：提供网络代理，负载均衡等操作</li>
</ul>
</li>
<li><p>容器运行环境【<strong>Container Runtime</strong>】</p>
<ul>
<li>容器运行环境是负责运行容器的软件</li>
<li>Kubernetes支持多个容器运行环境：Docker、containerd、cri-o、rktlet以及任何实现Kubernetes CRI (容器运行环境接口) 的软件。</li>
</ul>
</li>
<li><p>fluentd：是一个守护进程，它有助于提升 集群层面日志</p>
</li>
</ul>
<h2 id="7-K8s核心概念"><a href="#7-K8s核心概念" class="headerlink" title="7 K8s核心概念"></a>7 K8s核心概念</h2><h3 id="7-1-Pod"><a href="#7-1-Pod" class="headerlink" title="7.1 Pod"></a>7.1 Pod</h3><ul>
<li>Pod是K8s中最小的单元</li>
<li>一组容器的集合</li>
<li>共享网络【一个Pod中的所有容器共享同一网络】</li>
<li>生命周期是短暂的（服务器重启后，就找不到了）</li>
</ul>
<h3 id="7-2-Volume"><a href="#7-2-Volume" class="headerlink" title="7.2 Volume"></a>7.2 Volume</h3><ul>
<li>声明在Pod容器中可访问的文件目录</li>
<li>可以被挂载到Pod中一个或多个容器指定路径下</li>
<li>支持多种后端存储抽象【本地存储、分布式存储、云存储】</li>
</ul>
<h3 id="7-3-Controller"><a href="#7-3-Controller" class="headerlink" title="7.3 Controller"></a>7.3 Controller</h3><ul>
<li>确保预期的pod副本数量【ReplicaSet】</li>
<li>无状态应用部署【Depoltment】<ul>
<li>无状态就是指，不需要依赖于网络或者ip</li>
</ul>
</li>
<li>有状态应用部署【StatefulSet】<ul>
<li>有状态需要特定的条件</li>
</ul>
</li>
<li>确保所有的node运行同一个pod 【DaemonSet】</li>
<li>一次性任务和定时任务【Job和CronJob】</li>
</ul>
<h3 id="7-4-Deployment"><a href="#7-4-Deployment" class="headerlink" title="7.4 Deployment"></a>7.4 Deployment</h3><ul>
<li>定义一组Pod副本数目，版本等</li>
<li>通过控制器【Controller】维持Pod数目【自动回复失败的Pod】</li>
<li>通过控制器以指定的策略控制版本【滚动升级、回滚等】</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122161601349.png" alt="image-20201122161601349"></p>
<h3 id="7-5-Service"><a href="#7-5-Service" class="headerlink" title="7.5 Service"></a>7.5 Service</h3><ul>
<li>定义一组pod的访问规则</li>
<li>Pod的负载均衡，提供一个或多个Pod的稳定访问地址</li>
<li>支持多种方式【ClusterIP、NodePort、LoadBalancer】</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122161132055.png" alt="image-20201122161132055"></p>
<p>可以用来组合pod，同时对外提供服务</p>
<h3 id="7-6-Label"><a href="#7-6-Label" class="headerlink" title="7.6 Label"></a>7.6 Label</h3><p>label：标签，用于对象资源查询，筛选</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122161713638.png" alt="image-20201122161713638"></p>
<h3 id="7-7-Namespace"><a href="#7-7-Namespace" class="headerlink" title="7.7 Namespace"></a>7.7 Namespace</h3><p>命名空间，逻辑隔离</p>
<ul>
<li>一个集群内部的逻辑隔离机制【鉴权、资源】</li>
<li>每个资源都属于一个namespace</li>
<li>同一个namespace所有资源不能重复</li>
<li>不同namespace可以资源名重复</li>
</ul>
<h3 id="7-8-API"><a href="#7-8-API" class="headerlink" title="7.8 API"></a>7.8 API</h3><p>我们通过Kubernetes的API来操作整个集群</p>
<p>同时我们可以通过 kubectl 、ui、curl 最终发送 http + json/yaml 方式的请求给API Server，然后控制整个K8s集群，K8s中所有的资源对象都可以采用 yaml 或 json 格式的文件定义或描述</p>
<p>如下：使用yaml部署一个nginx的pod</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122162612448.png" alt="image-20201122162612448"></p>
<h2 id="8-完整流程"><a href="#8-完整流程" class="headerlink" title="8 完整流程"></a>8 完整流程</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122163512535.png" alt="image-20201122163512535"></p>
<ul>
<li>通过Kubectl提交一个创建RC（Replication Controller）的请求，该请求通过APlserver写入etcd</li>
<li>此时Controller Manager通过API Server的监听资源变化的接口监听到此RC事件</li>
<li>分析之后，发现当前集群中还没有它所对应的Pod实例</li>
<li>于是根据RC里的Pod模板定义一个生成Pod对象，通过APIServer写入etcd</li>
<li>此事件被Scheduler发现，它立即执行执行一个复杂的调度流程，为这个新的Pod选定一个落户的Node，然后通过API Server讲这一结果写入etcd中</li>
<li>目标Node上运行的Kubelet进程通过APiserver监测到这个”新生的Pod，并按照它的定义，启动该Pod并任劳任怨地负责它的下半生，直到Pod的生命结束</li>
<li>随后，我们通过Kubectl提交一个新的映射到该Pod的Service的创建请求</li>
<li>ControllerManager通过Label标签查询到关联的Pod实例，然后生成Service的Endpoints信息，并通过APIServer写入到etod中，</li>
<li>接下来，所有Node上运行的Proxy进程通过APIServer查询并监听Service对象与其对应的Endponts信息，建立一个软件方式的负载均衡器来实现Service访问到后端Pod的流量转发功能</li>
</ul>
<h1 id="第2章-搭建K8S集群"><a href="#第2章-搭建K8S集群" class="headerlink" title="第2章 搭建K8S集群"></a>第2章 搭建K8S集群</h1><h2 id="1-搭建k8s环境平台规划"><a href="#1-搭建k8s环境平台规划" class="headerlink" title="1 搭建k8s环境平台规划"></a>1 搭建k8s环境平台规划</h2><h3 id="单master集群"><a href="#单master集群" class="headerlink" title="单master集群"></a>单master集群</h3><p>单个master节点，然后管理多个node节点</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/2_%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/images/image-20200928110456495.png" alt="image-20200928110456495"></p>
<h3 id="多master集群"><a href="#多master集群" class="headerlink" title="多master集群"></a>多master集群</h3><p>多个master节点，管理多个node节点，同时中间多了一个负载均衡的过程</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/2_%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/images/image-20200928110543829.png" alt="image-20200928110543829"></p>
<h2 id="2-服务器硬件配置要求"><a href="#2-服务器硬件配置要求" class="headerlink" title="2 服务器硬件配置要求"></a>2 服务器硬件配置要求</h2><h3 id="2-1-测试环境"><a href="#2-1-测试环境" class="headerlink" title="2.1 测试环境"></a>2.1 测试环境</h3><p>master：2核  4G  20G</p>
<p>node：   4核  8G  40G</p>
<h3 id="2-2-生产环境"><a href="#2-2-生产环境" class="headerlink" title="2.2 生产环境"></a>2.2 生产环境</h3><p>master：8核  16G  100G</p>
<p>node：   16核  64G  200G</p>
<p>目前生产部署Kubernetes集群主要有两种方式</p>
<h3 id="2-3-kubeadm"><a href="#2-3-kubeadm" class="headerlink" title="2.3 kubeadm"></a>2.3 kubeadm</h3><p>kubeadm是一个K8S部署工具，提供kubeadm init 和 kubeadm join，用于快速部署Kubernetes集群</p>
<p>官网地址：<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">点我传送</a></p>
<h3 id="2-4-二进制包"><a href="#2-4-二进制包" class="headerlink" title="2.4 二进制包"></a>2.4 二进制包</h3><p>从github下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</p>
<p>Kubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p>
<h2 id="3-Kubeadm部署集群"><a href="#3-Kubeadm部署集群" class="headerlink" title="3 Kubeadm部署集群"></a>3 Kubeadm部署集群</h2><p>kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：</p>
<ul>
<li>创建一个Master 节点kubeadm init</li>
<li>将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;</li>
</ul>
<h2 id="4-安装要求"><a href="#4-安装要求" class="headerlink" title="4 安装要求"></a>4 安装要求</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件</p>
<ul>
<li>一台或多台机器，操作系统为Centos7.X</li>
<li>硬件配置：2GB或更多GAM，2个CPU或更多CPU，硬盘30G</li>
<li>集群中所有机器之间网络互通</li>
<li>可以访问外网，需要拉取镜像</li>
<li>禁止swap分区</li>
</ul>
<h1 id="第3章-使用kubeadm方式搭建K8S集群"><a href="#第3章-使用kubeadm方式搭建K8S集群" class="headerlink" title="第3章 使用kubeadm方式搭建K8S集群"></a>第3章 使用kubeadm方式搭建K8S集群</h1><p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。</p>
<p>这个工具能通过两条指令完成一个kubernetes集群的部署：</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建一个 Master 节点</span>
kubeadm init

<span class="hljs-meta">#</span><span class="bash"> 将一个 Node 节点加入到当前集群中</span>
kubeadm join &lt;Master节点的IP和端口 &gt;</code></pre></div>

<h2 id="1-Kubeadm方式搭建K8S集群"><a href="#1-Kubeadm方式搭建K8S集群" class="headerlink" title="1 Kubeadm方式搭建K8S集群"></a>1 Kubeadm方式搭建K8S集群</h2><p>使用kubeadm方式搭建K8s集群主要分为以下几步</p>
<ul>
<li>准备三台虚拟机，同时安装操作系统CentOS 7.x</li>
<li>对三个安装之后的操作系统进行初始化操作</li>
<li>在三个节点安装 docker kubelet kubeadm kubectl</li>
<li>在master节点执行kubeadm init命令初始化</li>
<li>在node节点上执行 kubeadm join命令，把node节点添加到当前集群</li>
<li>配置CNI网络插件，用于节点之间的连通【失败了可以多试几次】</li>
<li>通过拉取一个nginx进行测试，能否进行外网测试</li>
</ul>
<h2 id="2-安装要求"><a href="#2-安装要求" class="headerlink" title="2 安装要求"></a>2 安装要求</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件：</p>
<ul>
<li>一台或多台机器，操作系统 CentOS7.x-86_x64</li>
<li>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多【注意master需要两核】</li>
<li>可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像并导入节点</li>
<li>禁止swap分区</li>
</ul>
<h2 id="3-准备环境"><a href="#3-准备环境" class="headerlink" title="3 准备环境"></a>3 准备环境</h2><table>
<thead>
<tr>
<th>角色</th>
<th>IP</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>192.168.177.130</td>
</tr>
<tr>
<td>node1</td>
<td>192.168.177.131</td>
</tr>
<tr>
<td>node2</td>
<td>192.168.177.132</td>
</tr>
</tbody></table>
<p>然后开始在每台机器上执行下面的命令</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭防火墙</span>
systemctl stop firewalld
systemctl <span class="hljs-built_in">disable</span> firewalld

<span class="hljs-comment"># 关闭selinux</span>
<span class="hljs-comment"># 永久关闭</span>
sed -i <span class="hljs-string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  
<span class="hljs-comment"># 临时关闭</span>
setenforce 0  

<span class="hljs-comment"># 关闭swap</span>
<span class="hljs-comment"># 临时</span>
swapoff -a 
<span class="hljs-comment"># 永久关闭</span>
sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab

<span class="hljs-comment"># 根据规划设置主机名【master节点上操作】</span>
hostnamectl set-hostname k8smaster
<span class="hljs-comment"># 根据规划设置主机名【node1节点操作】</span>
hostnamectl set-hostname k8snode1
<span class="hljs-comment"># 根据规划设置主机名【node2节点操作】</span>
hostnamectl set-hostname k8snode2

<span class="hljs-comment"># 在master添加hosts</span>
cat &gt;&gt; /etc/hosts &lt;&lt; <span class="hljs-string">EOF</span>
<span class="hljs-string">192.168.177.130 k8smaster</span>
<span class="hljs-string">192.168.177.131 k8snode1</span>
<span class="hljs-string">192.168.177.132 k8snode2</span>
<span class="hljs-string">EOF</span>


<span class="hljs-comment"># 将桥接的IPv4流量传递到iptables的链</span>
cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="hljs-string">EOF</span>
<span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span>
<span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span>
<span class="hljs-string">EOF</span>
<span class="hljs-comment"># 生效</span>
sysctl --system  

<span class="hljs-comment"># 时间同步</span>
yum install ntpdate -y
ntpdate time.windows.com</code></pre></div>

<h2 id="4-安装Docker-kubeadm-kubelet"><a href="#4-安装Docker-kubeadm-kubelet" class="headerlink" title="4 安装Docker/kubeadm/kubelet"></a>4 安装Docker/kubeadm/kubelet</h2><p>所有节点安装Docker/kubeadm/kubelet ，Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker</p>
<h3 id="4-1-安装Docker"><a href="#4-1-安装Docker" class="headerlink" title="4.1 安装Docker"></a>4.1 安装Docker</h3><p>首先配置一下Docker的阿里yum源</p>
<div class="code-wrapper"><pre><code class="hljs bash">cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;<span class="hljs-string">EOF</span>
<span class="hljs-string">[docker-ce-edge]</span>
<span class="hljs-string">name=Docker CE Edge - \$basearch</span>
<span class="hljs-string">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\$basearch/edge</span>
<span class="hljs-string">enabled=1</span>
<span class="hljs-string">gpgcheck=1</span>
<span class="hljs-string">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span>
<span class="hljs-string">EOF</span></code></pre></div>

<p>然后yum方式安装docker</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># yum安装</span>
yum -y install docker-ce

<span class="hljs-comment"># 查看docker版本</span>
docker --version  

<span class="hljs-comment"># 启动docker</span>
systemctl <span class="hljs-built_in">enable</span> docker
systemctl start docker</code></pre></div>

<p>配置docker的镜像源</p>
<div class="code-wrapper"><pre><code class="hljs bash">cat &gt;&gt; /etc/docker/daemon.json &lt;&lt; <span class="hljs-string">EOF</span>
<span class="hljs-string">&#123;</span>
<span class="hljs-string">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span>
<span class="hljs-string">&#125;</span>
<span class="hljs-string">EOF</span></code></pre></div>

<p>然后重启docker</p>
<div class="code-wrapper"><pre><code class="hljs bash">systemctl restart docker</code></pre></div>

<h3 id="4-2-添加kubernetes软件源"><a href="#4-2-添加kubernetes软件源" class="headerlink" title="4.2 添加kubernetes软件源"></a>4.2 添加kubernetes软件源</h3><p>然后我们还需要配置一下yum的k8s软件源</p>
<div class="code-wrapper"><pre><code class="hljs bash">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; <span class="hljs-string">EOF</span>
<span class="hljs-string">[kubernetes]</span>
<span class="hljs-string">name=Kubernetes</span>
<span class="hljs-string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span>
<span class="hljs-string">enabled=1</span>
<span class="hljs-string">gpgcheck=0</span>
<span class="hljs-string">repo_gpgcheck=0</span>
<span class="hljs-string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span>
<span class="hljs-string">EOF</span></code></pre></div>

<h3 id="4-3-安装kubeadm，kubelet和kubectl"><a href="#4-3-安装kubeadm，kubelet和kubectl" class="headerlink" title="4.3 安装kubeadm，kubelet和kubectl"></a>4.3 安装kubeadm，kubelet和kubectl</h3><p>由于版本更新频繁，这里指定版本号部署：</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装kubelet、kubeadm、kubectl，同时指定版本</span>
yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0
<span class="hljs-comment"># 设置开机启动</span>
systemctl <span class="hljs-built_in">enable</span> kubelet</code></pre></div>

<h2 id="5-部署Kubernetes-Master【master节点】"><a href="#5-部署Kubernetes-Master【master节点】" class="headerlink" title="5 部署Kubernetes Master【master节点】"></a>5 部署Kubernetes Master【master节点】</h2><p>在   192.168.177.130  执行，也就是master节点</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubeadm init --apiserver-advertise-address=192.168.177.130 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</code></pre></div>

<p>由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址，【执行上述命令会比较慢，因为后台其实已经在拉取镜像了】，我们 docker images 命令即可查看已经拉取的镜像</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20200929094302491.png" alt="image-20200929094302491"></p>
<p>当我们出现下面的情况时，表示kubernetes的镜像已经安装成功</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20200929094620145.png" alt="image-20200929094620145"></p>
<p>使用kubectl工具 【master节点操作】</p>
<div class="code-wrapper"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kube
sudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config
sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</code></pre></div>

<p>执行完成后，我们使用下面命令，查看我们正在运行的节点</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl get nodes</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20200929094933142.png" alt="image-20200929094933142"></p>
<p>能够看到，目前有一个master节点已经运行了，但是还处于未准备状态</p>
<p>下面我们还需要在Node节点执行其它的命令，将node1和node2加入到我们的master节点上</p>
<h2 id="6-加入Kubernetes-Node【Slave节点】"><a href="#6-加入Kubernetes-Node【Slave节点】" class="headerlink" title="6 加入Kubernetes Node【Slave节点】"></a>6 加入Kubernetes Node【Slave节点】</h2><p>下面我们需要到 node1 和 node2服务器，执行下面的代码向集群添加新节点</p>
<p>执行在kubeadm init输出的kubeadm join命令：</p>
<blockquote>
<p>注意，以下的命令是在master初始化完成后，每个人的都不一样！！！需要复制自己生成的</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs bash">kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf \
    --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</code></pre></div>

<p>默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</p>
<div class="code-wrapper"><pre><code class="hljs gauss">kubeadm <span class="hljs-built_in">token</span> <span class="hljs-keyword">create</span> --<span class="hljs-keyword">print</span>-join-command</code></pre></div>

<p>当我们把两个节点都加入进来后，我们就可以去Master节点 执行下面命令查看情况</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl get node</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113165358663.png" alt="image-20201113165358663"></p>
<h2 id="7-部署CNI网络插件"><a href="#7-部署CNI网络插件" class="headerlink" title="7 部署CNI网络插件"></a>7 部署CNI网络插件</h2><p>上面的状态还是NotReady，下面我们需要网络插件，来进行联网访问</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 下载网络插件配置</span>
wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre></div>

<p>默认镜像地址无法访问，sed命令修改为docker hub镜像仓库。</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 添加</span>
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

<span class="hljs-comment">##①首先下载v0.13.1-rc2-amd64 镜像</span>
<span class="hljs-comment">##参考博客：https://www.cnblogs.com/pyxuexi/p/14288591.html</span>
<span class="hljs-comment">##② 导入镜像，命令，，特别提示，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，重要的事情说3遍。不然抱错。如果没有操作，报错后，需要删除节点，重置，在导入镜像，重新加入才行。本地就是这样操作成功的！</span>
docker load &lt; flanneld-v0.13.1-rc2-amd64.docker
<span class="hljs-comment">#####下载本地，替换将image: quay.io/coreos/flannel:v0.13.1-rc2 替换为 image: quay.io/coreos/flannel:v0.13.1-rc2-amd64</span>

<span class="hljs-comment"># 查看状态 【kube-system是k8s中的最小单元】</span>
kubectl get pods -n kube-system</code></pre></div>

<p>运行后的结果</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113165929510.png" alt="image-20201113165929510"></p>
<p>运行完成后，我们查看状态可以发现，已经变成了Ready状态了</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113194557147.png" alt="image-20201113194557147"></p>
<p>如果上述操作完成后，还存在某个节点处于NotReady状态，可以在Master将该节点删除</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># master节点将该节点删除</span>

<span class="hljs-comment">##20210223 yan 查阅资料添加###kubectl drain k8snode1 --delete-local-data --force --ignore-daemonsets</span>

kubectl delete node k8snode1
 
<span class="hljs-comment"># 然后到k8snode1节点进行重置</span>
 kubeadm reset
<span class="hljs-comment"># 重置完后在加入</span>
kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf     --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</code></pre></div>

<h2 id="8-测试kubernetes集群"><a href="#8-测试kubernetes集群" class="headerlink" title="8 测试kubernetes集群"></a>8 测试kubernetes集群</h2><p>我们都知道K8S是容器化技术，它可以联网去下载镜像，用容器的方式进行启动</p>
<p>在Kubernetes集群中创建一个pod，验证是否正常运行：</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 下载nginx 【会联网拉取nginx镜像】</span>
kubectl create deployment nginx --image=nginx
<span class="hljs-comment"># 查看状态</span>
kubectl get pod</code></pre></div>

<p>如果我们出现Running状态的时候，表示已经成功运行了</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113203537028.png" alt="image-20201113203537028"></p>
<p>下面我们就需要将端口暴露出去，让其它外界能够访问</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 暴露端口</span>
kubectl expose deployment nginx --port=80 --<span class="hljs-built_in">type</span>=NodePort
<span class="hljs-comment"># 查看一下对外的端口</span>
kubectl get pod,svc</code></pre></div>

<p>能够看到，我们已经成功暴露了 80端口  到 30529上</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113203840915.png" alt="image-20201113203840915"></p>
<p>我们到我们的宿主机浏览器上，访问如下地址</p>
<div class="code-wrapper"><pre><code class="hljs bash">http://192.168.177.130:30529/</code></pre></div>

<p>发现我们的nginx已经成功启动了</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113204056851.png" alt="image-20201113204056851"></p>
<p>到这里为止，我们就搭建了一个单master的k8s集群</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113204158884.png" alt="image-20201113204158884"></p>
<h2 id="9-错误汇总"><a href="#9-错误汇总" class="headerlink" title="9 错误汇总"></a>9 错误汇总</h2><h3 id="9-1-错误一"><a href="#9-1-错误一" class="headerlink" title="9.1 错误一"></a>9.1 错误一</h3><p>在执行Kubernetes  init方法的时候，出现这个问题</p>
<div class="code-wrapper"><pre><code class="hljs bash">error execution phase preflight: [preflight] Some fatal errors occurred:
	[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2</code></pre></div>

<p>是因为VMware设置的核数为1，而K8S需要的最低核数应该是2，调整核数重启系统即可</p>
<h3 id="9-2-错误二"><a href="#9-2-错误二" class="headerlink" title="9.2 错误二"></a>9.2 错误二</h3><p>我们在给node1节点使用 kubernetes join命令的时候，出现以下错误</p>
<div class="code-wrapper"><pre><code class="hljs bash">error execution phase preflight: [preflight] Some fatal errors occurred:
	[ERROR Swap]: running with swap on is not supported. Please <span class="hljs-built_in">disable</span> swap</code></pre></div>

<p>错误原因是我们需要关闭swap</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭swap</span>
<span class="hljs-comment"># 临时</span>
swapoff -a 
<span class="hljs-comment"># 临时</span>
sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</code></pre></div>

<h3 id="9-3-错误三"><a href="#9-3-错误三" class="headerlink" title="9.3 错误三"></a>9.3 错误三</h3><p>在给node1节点使用 kubernetes join命令的时候，出现以下错误</p>
<div class="code-wrapper"><pre><code class="hljs bash">The HTTP call equal to <span class="hljs-string">&#x27;curl -sSL http://localhost:10248/healthz&#x27;</span> failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused</code></pre></div>

<p>解决方法，首先需要到 master 节点，创建一个文件</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建文件夹</span>
mkdir /etc/systemd/system/kubelet.service.d

<span class="hljs-comment"># 创建文件</span>
vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf

<span class="hljs-comment"># 添加如下内容</span>
Environment=<span class="hljs-string">&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --fail-swap-on=false&quot;</span>

<span class="hljs-comment"># 重置</span>
kubeadm reset</code></pre></div>

<p>然后删除刚刚创建的配置目录</p>
<div class="code-wrapper"><pre><code class="hljs bash">rm -rf <span class="hljs-variable">$HOME</span>/.kube</code></pre></div>

<p>然后 在master重新初始化</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubeadm init --apiserver-advertise-address=202.193.57.11 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</code></pre></div>

<p>初始完成后，我们再到 node1节点，执行 kubeadm join命令，加入到master</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubeadm join 202.193.57.11:6443 --token c7a7ou.z00fzlb01d76r37s \
    --discovery-token-ca-cert-hash sha256:9c3f3cc3f726c6ff8bdff14e46b1a856e3b8a4cbbe30cab185f6c5ee453aeea5</code></pre></div>

<p>添加完成后，我们使用下面命令，查看节点是否成功添加</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl get nodes</code></pre></div>

<h3 id="9-4-错误四"><a href="#9-4-错误四" class="headerlink" title="9.4 错误四"></a>9.4 错误四</h3><p>我们再执行查看节点的时候，  kubectl get nodes 会出现问题</p>
<div class="code-wrapper"><pre><code class="hljs bash">Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of <span class="hljs-string">&quot;crypto/rsa: verification error&quot;</span> <span class="hljs-keyword">while</span> trying to verify candidate authority certificate <span class="hljs-string">&quot;kubernetes&quot;</span>)</code></pre></div>

<p>这是因为我们之前创建的配置文件还存在，也就是这些配置</p>
<div class="code-wrapper"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kube
sudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config
sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</code></pre></div>

<p>我们需要做的就是把配置文件删除，然后重新执行一下</p>
<div class="code-wrapper"><pre><code class="hljs bash">rm -rf <span class="hljs-variable">$HOME</span>/.kube</code></pre></div>

<p>然后再次创建一下即可</p>
<div class="code-wrapper"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kube
sudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config
sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</code></pre></div>

<p>这个问题主要是因为我们在执行 kubeadm reset 的时候，没有把 $HOME/.kube 给移除掉，再次创建时就会出现问题了</p>
<h3 id="9-5-错误五"><a href="#9-5-错误五" class="headerlink" title="9.5 错误五"></a>9.5 错误五</h3><p>安装的时候，出现以下错误</p>
<div class="code-wrapper"><pre><code class="hljs bash">Another app is currently holding the yum lock; waiting <span class="hljs-keyword">for</span> it to <span class="hljs-built_in">exit</span>...</code></pre></div>

<p>是因为yum上锁占用，解决方法</p>
<div class="code-wrapper"><pre><code class="hljs bash">yum -y install docker-ce</code></pre></div>

<h3 id="9-6-错误六"><a href="#9-6-错误六" class="headerlink" title="9.6 错误六"></a>9.6 错误六</h3><p>在使用下面命令，添加node节点到集群上的时候</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb  --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</code></pre></div>

<p>然后出现了这个错误</p>
<div class="code-wrapper"><pre><code class="hljs bash">[root@k8smaster ~]<span class="hljs-comment"># kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb     --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</span>
W1117 06:55:11.220907   11230 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not <span class="hljs-built_in">set</span>.
[preflight] Running pre-flight checks
	[WARNING IsDockerSystemdCheck]: detected <span class="hljs-string">&quot;cgroupfs&quot;</span> as the Docker cgroup driver. The recommended driver is <span class="hljs-string">&quot;systemd&quot;</span>. Please follow the guide at https://kubernetes.io/docs/setup/cri/
error execution phase preflight: [preflight] Some fatal errors occurred:
	[ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not <span class="hljs-built_in">set</span> to 1
[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`
To see the stack trace of this error execute with --v=5 or higher</code></pre></div>

<p>出于安全考虑，Linux系统<strong>默认是禁止数据包转发</strong>的。所谓<strong>转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包</strong>。这通常就是路由器所要实现的功能。也就是说  <strong>/proc/sys/net/ipv4/ip_forward</strong> 文件的值不支持转发</p>
<ul>
<li>0：禁止</li>
<li>1：转发</li>
</ul>
<p>所以我们需要将值修改成1即可</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> “1” &gt; /proc/sys/net/ipv4/ip_forward</code></pre></div>

<p>修改完成后，重新执行命令即可</p>
<h1 id="第4章-使用二进制方式搭建K8S集群"><a href="#第4章-使用二进制方式搭建K8S集群" class="headerlink" title="第4章 使用二进制方式搭建K8S集群"></a>第4章 使用二进制方式搭建K8S集群</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件</p>
<ul>
<li>一台或多台机器，操作系统CentOS 7.x</li>
<li>硬件配置：2GB ，2个CPU，硬盘30GB</li>
<li>集群中所有机器之间网络互通</li>
<li>可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像导入节点</li>
<li>禁止swap分区</li>
</ul>
<h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2 步骤"></a>2 步骤</h2><ul>
<li>创建多台虚拟机，安装Linux系统</li>
<li>操作系统的初始化</li>
<li>为etcd 和 apiserver 自签证书</li>
<li>部署etcd集群</li>
<li>部署master组件【安装docker、kube-apiserver、kube-controller-manager、kube-scheduler、etcd】</li>
<li>部署node组件【安装kubelet、kube-proxy、docker、etcd】</li>
<li>部署集群网络</li>
</ul>
<h2 id="3-准备虚拟机"><a href="#3-准备虚拟机" class="headerlink" title="3 准备虚拟机"></a>3 准备虚拟机</h2><p>首先我们准备了两台虚拟机，来进行安装测试</p>
<table>
<thead>
<tr>
<th>主机名</th>
<th>ip</th>
</tr>
</thead>
<tbody><tr>
<td>k8s_2_master</td>
<td>192.168.177.140</td>
</tr>
<tr>
<td>k8s_2_node</td>
<td>192.168.177.141</td>
</tr>
</tbody></table>
<h2 id="4-操作系统的初始化"><a href="#4-操作系统的初始化" class="headerlink" title="4 操作系统的初始化"></a>4 操作系统的初始化</h2><p>然后我们需要进行一些系列的初始化操作</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭防火墙</span>
systemctl stop firewalld
systemctl <span class="hljs-built_in">disable</span> firewalld

<span class="hljs-comment"># 关闭selinux</span>
<span class="hljs-comment"># 永久关闭</span>
sed -i <span class="hljs-string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  
<span class="hljs-comment"># 临时关闭</span>
setenforce 0  

<span class="hljs-comment"># 关闭swap</span>
<span class="hljs-comment"># 临时</span>
swapoff -a 
<span class="hljs-comment"># 永久关闭</span>
sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab

<span class="hljs-comment"># 根据规划设置主机名【master节点上操作】</span>
hostnamectl set-hostname k8s_2_master
<span class="hljs-comment"># 根据规划设置主机名【node1节点操作】</span>
hostnamectl set-hostname k8s_2_node1


<span class="hljs-comment"># 在master添加hosts</span>
cat &gt;&gt; /etc/hosts &lt;&lt; <span class="hljs-string">EOF</span>
<span class="hljs-string">192.168.177.140 k8s_2_master</span>
<span class="hljs-string">192.168.177.141 k8s_2_node1</span>
<span class="hljs-string">EOF</span>


<span class="hljs-comment"># 将桥接的IPv4流量传递到iptables的链</span>
cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="hljs-string">EOF</span>
<span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span>
<span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span>
<span class="hljs-string">EOF</span>
<span class="hljs-comment"># 生效</span>
sysctl --system  

<span class="hljs-comment"># 时间同步</span>
yum install ntpdate -y
ntpdate time.windows.com</code></pre></div>

<h2 id="5-部署Etcd集群"><a href="#5-部署Etcd集群" class="headerlink" title="5 部署Etcd集群"></a>5 部署Etcd集群</h2><p>Etcd是一个分布式键值存储系统，Kubernetes使用Etcd进行数据存储，所以先准备一个Etcd数据库，为了解决Etcd单点故障，应采用集群方式部署，这里使用3台组建集群，可容忍一台机器故障，当然也可以使用5台组件集群，可以容忍2台机器故障</p>
<h3 id="自签证书"><a href="#自签证书" class="headerlink" title="自签证书"></a>自签证书</h3><p>提到证书，我们想到的就是下面这个情况</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113213116353.png" alt="image-20201113213116353"></p>
<p>这个https证书，其实就是服务器颁发给网站的，代表这是一个安全可信任的网站。</p>
<p>而在我们K8S集群的内部，其实也是有证书的，如果不带证书，那么访问就会受限</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113213353267.png" alt="image-20201113213353267"></p>
<p>同时在集群内部 和 外部的访问，我们也需要签发证书</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113213416013.png" alt="image-20201113213416013"></p>
<p>如果我们使用二进制的方式，那么就需要自己手动签发证书。</p>
<p>自签证书：我们可以想象成在一家公司上班，然后会颁发一个门禁卡，同时一般门禁卡有两种，一个是内部员工的门禁卡，和外部访客门禁卡。这两种门禁卡的权限可能不同，员工的门禁卡可以进入公司的任何地方，而访客的门禁卡是受限的，这个门禁卡其实就是自签证书</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113214234194.png" alt="image-20201113214234194"></p>
<h3 id="准备cfssl证书生成工具"><a href="#准备cfssl证书生成工具" class="headerlink" title="准备cfssl证书生成工具"></a>准备cfssl证书生成工具</h3><p>cfssl是一个开源的证书管理工具，使用json文件生成证书，相比openssl 更方便使用。找任意一台服务器操作，这里用Master节点。</p>
<div class="code-wrapper"><pre><code class="hljs bash">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64
wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64
chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64
mv cfssl_linux-amd64 /usr/<span class="hljs-built_in">local</span>/bin/cfssl
mv cfssljson_linux-amd64 /usr/<span class="hljs-built_in">local</span>/bin/cfssljson
mv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</code></pre></div>

<h1 id="第5章-Kubeadm和二进制方式对比"><a href="#第5章-Kubeadm和二进制方式对比" class="headerlink" title="第5章 Kubeadm和二进制方式对比"></a>第5章 Kubeadm和二进制方式对比</h1><h2 id="1-Kubeadm方式搭建K8S集群-1"><a href="#1-Kubeadm方式搭建K8S集群-1" class="headerlink" title="1 Kubeadm方式搭建K8S集群"></a>1 Kubeadm方式搭建K8S集群</h2><ul>
<li><p>安装虚拟机，在虚拟机安装Linux操作系统【3台虚拟机】</p>
</li>
<li><p>对操作系统初始化操作</p>
</li>
<li><p>所有节点安装Docker、kubeadm、kubelet、kubectl【包含master和slave节点】</p>
<ul>
<li>安装docker、使用yum，不指定版本默认安装最新的docker版本</li>
<li>修改docker仓库地址，yum源地址，改为阿里云地址</li>
<li>安装kubeadm，kubelet 和 kubectl<ul>
<li>k8s已经发布最新的1.19版本，可以指定版本安装，不指定安装最新版本</li>
<li><code>yum install -y kubelet kubeadm kubectl</code></li>
</ul>
</li>
</ul>
</li>
<li><p>在master节点执行初始化命令操作</p>
<ul>
<li><code>kubeadm init</code></li>
<li>默认拉取镜像地址 K8s.gcr.io国内地址，需要使用国内地址</li>
</ul>
</li>
<li><p>安装网络插件(CNI)</p>
<ul>
<li><code>kubectl apply -f kube-flannel.yml</code></li>
<li></li>
</ul>
</li>
<li><p>在所有的node节点上，使用join命令，把node添加到master节点上</p>
</li>
<li><p>测试kubernetes集群</p>
</li>
</ul>
<h2 id="2-二进制方式搭建K8S集群"><a href="#2-二进制方式搭建K8S集群" class="headerlink" title="2 二进制方式搭建K8S集群"></a>2 二进制方式搭建K8S集群</h2><ul>
<li>安装虚拟机和操作系统，对操作系统进行初始化操作</li>
<li>生成cfssl 自签证书<ul>
<li><code>ca-key.pem</code>、<code>ca.pem</code></li>
<li><code>server-key.pem</code>、<code>server.pem</code></li>
</ul>
</li>
<li>部署Etcd集群<ul>
<li>部署的本质，就是把etcd集群交给 systemd 管理</li>
<li>把生成的证书复制过来，启动，设置开机启动</li>
</ul>
</li>
<li>为apiserver自签证书，生成过程和etcd类似</li>
<li>部署master组件，主要包含以下组件<ul>
<li>apiserver</li>
<li>controller-manager</li>
<li>scheduler</li>
<li>交给systemd管理，并设置开机启动</li>
<li>如果要安装最新的1.19版本，下载二进制文件进行安装</li>
</ul>
</li>
<li>部署node组件<ul>
<li>docker</li>
<li>kubelet</li>
<li>kube-proxy【需要批准kubelet证书申请加入集群】</li>
<li>交给systemd管理组件- 组件启动，设置开机启动</li>
</ul>
</li>
<li>批准kubelet证书申请 并加入集群</li>
<li>部署CNI网络插件</li>
<li>测试Kubernets集群【安装nginx测试】</li>
</ul>
<h1 id="第6章-Kubernetes集群管理工具kubectl"><a href="#第6章-Kubernetes集群管理工具kubectl" class="headerlink" title="第6章 Kubernetes集群管理工具kubectl"></a>第6章 Kubernetes集群管理工具kubectl</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>kubectl是Kubernetes集群的命令行工具，通过kubectl能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署</p>
<h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2 命令格式"></a>2 命令格式</h2><p>命令格式如下</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl [<span class="hljs-built_in">command</span>] [<span class="hljs-built_in">type</span>] [name] [flags]</code></pre></div>

<p>参数</p>
<ul>
<li>command：指定要对资源执行的操作，例如create、get、describe、delete</li>
<li>type：指定资源类型，资源类型是大小写敏感的，开发者能够以单数 、复数 和 缩略的形式</li>
</ul>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl get pod pod1
kubectl get pods pod1
kubectl get po pod1</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/6_Kubernetes%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7kubectl/images/image-20201114095544185.png" alt="image-20201114095544185"></p>
<ul>
<li>name：指定资源的名称，名称也是大小写敏感的，如果省略名称，则会显示所有的资源，例如</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods</code></pre></div>

<ul>
<li>flags：指定可选的参数，例如，可用 -s 或者 -server参数指定Kubernetes API server的地址和端口</li>
</ul>
<h2 id="3-常见命令"><a href="#3-常见命令" class="headerlink" title="3 常见命令"></a>3 常见命令</h2><h3 id="3-1-kubectl-help-获取更多信息"><a href="#3-1-kubectl-help-获取更多信息" class="headerlink" title="3.1 kubectl help 获取更多信息"></a>3.1 kubectl help 获取更多信息</h3><p>通过 help命令，能够获取帮助信息</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 获取kubectl的命令</span>
kubectl --<span class="hljs-built_in">help</span>

<span class="hljs-comment"># 获取某个命令的介绍和使用</span>
kubectl get --<span class="hljs-built_in">help</span></code></pre></div>

<h3 id="3-2-基础命令"><a href="#3-2-基础命令" class="headerlink" title="3.2 基础命令"></a>3.2 基础命令</h3><p>常见的基础命令</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">create</td>
<td align="center">通过文件名或标准输入创建资源</td>
</tr>
<tr>
<td align="center">expose</td>
<td align="center">将一个资源公开为一个新的Service</td>
</tr>
<tr>
<td align="center">run</td>
<td align="center">在集群中运行一个特定的镜像</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">在对象上设置特定的功能</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">显示一个或多个资源</td>
</tr>
<tr>
<td align="center">explain</td>
<td align="center">文档参考资料</td>
</tr>
<tr>
<td align="center">edit</td>
<td align="center">使用默认的编辑器编辑一个资源</td>
</tr>
<tr>
<td align="center">delete</td>
<td align="center">通过文件名，标准输入，资源名称或标签来删除资源</td>
</tr>
</tbody></table>
<h3 id="3-3-部署命令"><a href="#3-3-部署命令" class="headerlink" title="3.3 部署命令"></a>3.3 部署命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">rollout</td>
<td align="center">管理资源的发布</td>
</tr>
<tr>
<td align="center">rolling-update</td>
<td align="center">对给定的复制控制器滚动更新</td>
</tr>
<tr>
<td align="center">scale</td>
<td align="center">扩容或缩容Pod数量，Deployment、ReplicaSet、RC或Job</td>
</tr>
<tr>
<td align="center">autoscale</td>
<td align="center">创建一个自动选择扩容或缩容并设置Pod数量</td>
</tr>
</tbody></table>
<h3 id="3-4-集群管理命令"><a href="#3-4-集群管理命令" class="headerlink" title="3.4 集群管理命令"></a>3.4 集群管理命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>certificate</td>
<td>修改证书资源</td>
</tr>
<tr>
<td>cluster-info</td>
<td>显示集群信息</td>
</tr>
<tr>
<td>top</td>
<td>显示资源(CPU/M)</td>
</tr>
<tr>
<td>cordon</td>
<td>标记节点不可调度</td>
</tr>
<tr>
<td>uncordon</td>
<td>标记节点可被调度</td>
</tr>
<tr>
<td>drain</td>
<td>驱逐节点上的应用，准备下线维护</td>
</tr>
<tr>
<td>taint</td>
<td>修改节点taint标记</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-5-故障和调试命令"><a href="#3-5-故障和调试命令" class="headerlink" title="3.5 故障和调试命令"></a>3.5 故障和调试命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">describe</td>
<td align="center">显示特定资源或资源组的详细信息</td>
</tr>
<tr>
<td align="center">logs</td>
<td align="center">在一个Pod中打印一个容器日志，如果Pod只有一个容器，容器名称是可选的</td>
</tr>
<tr>
<td align="center">attach</td>
<td align="center">附加到一个运行的容器</td>
</tr>
<tr>
<td align="center">exec</td>
<td align="center">执行命令到容器</td>
</tr>
<tr>
<td align="center">port-forward</td>
<td align="center">转发一个或多个</td>
</tr>
<tr>
<td align="center">proxy</td>
<td align="center">运行一个proxy到Kubernetes API Server</td>
</tr>
<tr>
<td align="center">cp</td>
<td align="center">拷贝文件或目录到容器中</td>
</tr>
<tr>
<td align="center">auth</td>
<td align="center">检查授权</td>
</tr>
</tbody></table>
<h3 id="3-6-其它命令"><a href="#3-6-其它命令" class="headerlink" title="3.6 其它命令"></a>3.6 其它命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apply</td>
<td align="center">通过文件名或标准输入对资源应用配置</td>
</tr>
<tr>
<td align="center">patch</td>
<td align="center">使用补丁修改、更新资源的字段</td>
</tr>
<tr>
<td align="center">replace</td>
<td align="center">通过文件名或标准输入替换一个资源</td>
</tr>
<tr>
<td align="center">convert</td>
<td align="center">不同的API版本之间转换配置文件</td>
</tr>
<tr>
<td align="center">label</td>
<td align="center">更新资源上的标签</td>
</tr>
<tr>
<td align="center">annotate</td>
<td align="center">更新资源上的注释</td>
</tr>
<tr>
<td align="center">completion</td>
<td align="center">用于实现kubectl工具自动补全</td>
</tr>
<tr>
<td align="center">api-versions</td>
<td align="center">打印受支持的API版本</td>
</tr>
<tr>
<td align="center">config</td>
<td align="center">修改kubeconfig文件（用于访问API，比如配置认证信息）</td>
</tr>
<tr>
<td align="center">help</td>
<td align="center">所有命令帮助</td>
</tr>
<tr>
<td align="center">plugin</td>
<td align="center">运行一个命令行插件</td>
</tr>
<tr>
<td align="center">version</td>
<td align="center">打印客户端和服务版本信息</td>
</tr>
</tbody></table>
<h3 id="3-7-目前使用的命令"><a href="#3-7-目前使用的命令" class="headerlink" title="3.7 目前使用的命令"></a>3.7 目前使用的命令</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个nginx镜像</span>
kubectl create deployment nginx --image=nginx

<span class="hljs-comment"># 对外暴露端口</span>
kubectl expose deployment nginx --port=80 --<span class="hljs-built_in">type</span>=NodePort

<span class="hljs-comment"># 查看资源</span>
kubectl get pod, svc</code></pre></div>

<h1 id="第7章-Kubernetes集群YAML文件详解"><a href="#第7章-Kubernetes集群YAML文件详解" class="headerlink" title="第7章 Kubernetes集群YAML文件详解"></a>第7章 Kubernetes集群YAML文件详解</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h2><p>k8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，也就是可以把需要对资源对象操作编辑到YAML 格式文件中，我们把这种文件叫做资源清单文件，通过kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。一般在我们开发的时候，都是通过配置YAML文件来部署集群的。</p>
<p>YAML文件：就是资源清单文件，用于资源编排</p>
<h2 id="2-YAML文件介绍"><a href="#2-YAML文件介绍" class="headerlink" title="2 YAML文件介绍"></a>2 YAML文件介绍</h2><h3 id="2-1-YAML概述"><a href="#2-1-YAML概述" class="headerlink" title="2.1 YAML概述"></a>2.1 YAML概述</h3><p>YAML ：仍是一种标记语言。为了强调这种语言以数据做为中心，而不是以标记语言为重点。</p>
<p>YAML 是一个可读性高，用来表达数据序列的格式。</p>
<h3 id="2-2-YAML-基本语法"><a href="#2-2-YAML-基本语法" class="headerlink" title="2.2 YAML 基本语法"></a>2.2 YAML 基本语法</h3><ul>
<li>使用空格做为缩进</li>
<li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li>
<li>低版本缩进时不允许使用Tab 键，只允许使用空格</li>
<li>使用#标识注释，从这个字符一直到行尾，都会被解释器忽略</li>
<li>使用 — 表示新的yaml文件开始</li>
</ul>
<h3 id="2-3-YAML-支持的数据结构"><a href="#2-3-YAML-支持的数据结构" class="headerlink" title="2.3 YAML 支持的数据结构"></a>2.3 YAML 支持的数据结构</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>键值对的集合，又称为映射(mapping) / 哈希（hashes） / 字典（dictionary）</p>
<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 对象类型：对象的一组键值对，使用冒号结构表示</span>
<span class="hljs-attr">name:</span> <span class="hljs-string">Tom</span>
<span class="hljs-attr">age:</span> <span class="hljs-number">18</span>

<span class="hljs-comment"># yaml 也允许另一种写法，将所有键值对写成一个行内对象</span>
<span class="hljs-attr">hash:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">Tom</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">18</span>&#125;</code></pre></div>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 数组类型：一组连词线开头的行，构成一个数组</span>
People
- Tom
- Jack

<span class="hljs-comment"># 数组也可以采用行内表示法</span>
People: [Tom, Jack]</code></pre></div>

<h2 id="3-YAML文件组成部分"><a href="#3-YAML文件组成部分" class="headerlink" title="3 YAML文件组成部分"></a>3 YAML文件组成部分</h2><p>主要分为了两部分，一个是控制器的定义和被控制的对象</p>
<h3 id="3-1-控制器的定义"><a href="#3-1-控制器的定义" class="headerlink" title="3.1 控制器的定义"></a>3.1 控制器的定义</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114110444032.png" alt="image-20201114110444032"></p>
<h3 id="3-2-被控制的对象"><a href="#3-2-被控制的对象" class="headerlink" title="3.2 被控制的对象"></a>3.2 被控制的对象</h3><p>包含一些 镜像，版本、端口等</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114110600165.png" alt="image-20201114110600165"></p>
<h3 id="3-3-属性说明"><a href="#3-3-属性说明" class="headerlink" title="3.3 属性说明"></a>3.3 属性说明</h3><p>在一个YAML文件的控制器定义中，有很多属性名称</p>
<table>
<thead>
<tr>
<th align="center">属性名称</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">apiVersion</td>
<td align="center">API版本</td>
</tr>
<tr>
<td align="center">kind</td>
<td align="center">资源类型</td>
</tr>
<tr>
<td align="center">metadata</td>
<td align="center">资源元数据</td>
</tr>
<tr>
<td align="center">spec</td>
<td align="center">资源规格</td>
</tr>
<tr>
<td align="center">replicas</td>
<td align="center">副本数量</td>
</tr>
<tr>
<td align="center">selector</td>
<td align="center">标签选择器</td>
</tr>
<tr>
<td align="center">template</td>
<td align="center">Pod模板</td>
</tr>
<tr>
<td align="center">metadata</td>
<td align="center">Pod元数据</td>
</tr>
<tr>
<td align="center">spec</td>
<td align="center">Pod规格</td>
</tr>
<tr>
<td align="center">containers</td>
<td align="center">容器配置</td>
</tr>
</tbody></table>
<h2 id="4-如何快速编写YAML文件"><a href="#4-如何快速编写YAML文件" class="headerlink" title="4 如何快速编写YAML文件"></a>4 如何快速编写YAML文件</h2><p>一般来说，我们很少自己手写YAML文件，因为这里面涉及到了很多内容，我们一般都会借助工具来创建</p>
<h3 id="使用kubectl-create命令"><a href="#使用kubectl-create命令" class="headerlink" title="使用kubectl create命令"></a>使用kubectl create命令</h3><p>这种方式一般用于资源没有部署的时候，我们可以直接创建一个YAML配置文件</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 尝试运行,并不会真正的创建镜像</span>
kubectl create deployment web --image=nginx -o yaml --dry-run</code></pre></div>

<p>或者我们可以输出到一个文件中</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl create deployment web --image=nginx -o yaml --dry-run &gt; hello.yaml</code></pre></div>

<p>然后我们就在文件中直接修改即可</p>
<h3 id="使用kubectl-get命令导出yaml文件"><a href="#使用kubectl-get命令导出yaml文件" class="headerlink" title="使用kubectl get命令导出yaml文件"></a>使用kubectl get命令导出yaml文件</h3><p>可以首先查看一个目前已经部署的镜像</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl get deploy</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114113115649.png" alt="image-20201114113115649"></p>
<p>然后我们导出 nginx的配置</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 注意 --export在新版本中已经被去除了</span>
kubectl get deploy nginx -o=yaml --<span class="hljs-built_in">export</span> &gt; nginx.yaml</code></pre></div>

<p>然后会生成一个 <code>nginx.yaml</code> 的配置文件</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114184538797.png" alt="image-20201114184538797"></p>
<h1 id="第8章-Kubernetes核心技术Pod"><a href="#第8章-Kubernetes核心技术Pod" class="headerlink" title="第8章 Kubernetes核心技术Pod"></a>第8章 Kubernetes核心技术Pod</h1><h2 id="1-Pod概述"><a href="#1-Pod概述" class="headerlink" title="1 Pod概述"></a>1 Pod概述</h2><p>Pod是K8S系统中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最小资源对象模型，也是在K8S上运行容器化应用的资源对象，其它的资源对象都是用来支撑或者扩展Pod对象功能的，比如控制器对象是用来管控Pod对象的，Service或者Ingress资源对象是用来暴露Pod引用对象的，PersistentVolume资源对象是用来为Pod提供存储等等，K8S不会直接处理容器，而是Pod，Pod是由一个或多个container组成。</p>
<p>Pod是Kubernetes的最重要概念，每一个Pod都有一个特殊的被称为 “根容器”的Pause容器。Pause容器对应的镜像属于Kubernetes平台的一部分，除了Pause容器，每个Pod还包含一个或多个紧密相关的用户业务容器。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114185528215.png" alt="image-20201114185528215"></p>
<h3 id="Pod基本概念"><a href="#Pod基本概念" class="headerlink" title="Pod基本概念"></a>Pod基本概念</h3><ul>
<li>最小部署的单元</li>
<li>Pod里面是由一个或多个容器组成【一组容器的集合】</li>
<li>一个pod中的容器是共享网络命名空间</li>
<li>Pod是短暂的</li>
<li>每个Pod包含一个或多个紧密相关的用户业务容器</li>
</ul>
<h3 id="Pod存在的意义"><a href="#Pod存在的意义" class="headerlink" title="Pod存在的意义"></a>Pod存在的意义</h3><ul>
<li>创建容器使用docker，一个docker对应一个容器，一个容器运行一个应用进程</li>
<li>Pod是多进程设计，运用多个应用程序，也就是一个Pod里面有多个容器，而一个容器里面运行一个应用程序</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114190018948.png" alt="image-20201114190018948"></p>
<ul>
<li>Pod的存在是为了亲密性应用<ul>
<li>两个应用之间进行交互</li>
<li>网络之间的调用【通过127.0.0.1 或 socket】</li>
<li>两个应用之间需要频繁调用</li>
</ul>
</li>
</ul>
<p>Pod是在K8S集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。同时Pod对多容器的支持是K8S中最基础的设计理念。在生产环境中，通常是由不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。</p>
<p>Pod是K8S集群中所有业务类型的基础，可以把Pod看作运行在K8S集群上的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前K8S的业务主要可以分为以下几种</p>
<ul>
<li>长期伺服型：long-running</li>
<li>批处理型：batch</li>
<li>节点后台支撑型：node-daemon</li>
<li>有状态应用型：stateful application</li>
</ul>
<p>上述的几种类型，分别对应的小机器人控制器为：Deployment、Job、DaemonSet 和 StatefulSet  (后面将介绍控制器)</p>
<h2 id="2-Pod实现机制"><a href="#2-Pod实现机制" class="headerlink" title="2 Pod实现机制"></a>2 Pod实现机制</h2><p>主要有以下两大机制</p>
<ul>
<li>共享网络</li>
<li>共享存储</li>
</ul>
<h3 id="共享网络"><a href="#共享网络" class="headerlink" title="共享网络"></a>共享网络</h3><p>容器本身之间相互隔离的，一般是通过 <strong>namespace</strong> 和 <strong>group</strong> 进行隔离，那么Pod里面的容器如何实现通信？</p>
<ul>
<li>首先需要满足前提条件，也就是容器都在同一个<strong>namespace</strong>之间</li>
</ul>
<p>关于Pod实现原理，首先会在Pod会创建一个根容器： <code>pause容器</code>，然后我们在创建业务容器 【nginx，redis 等】，在我们创建业务容器的时候，会把它添加到 <code>info容器</code> 中</p>
<p>而在 <code>info容器</code> 中会独立出  ip地址，mac地址，port 等信息，然后实现网络的共享</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114190913859.png" alt="image-20201114190913859"></p>
<p>完整步骤如下</p>
<ul>
<li>通过 Pause 容器，把其它业务容器加入到Pause容器里，让所有业务容器在同一个名称空间中，可以实现网络共享</li>
</ul>
<h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>Pod持久化数据，专门存储到某个地方中</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114193124160.png" alt="image-20201114193124160"></p>
<p>使用 Volumn数据卷进行共享存储，案例如下所示</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114193341993.png" alt="image-20201114193341993"></p>
<h2 id="3-Pod镜像拉取策略"><a href="#3-Pod镜像拉取策略" class="headerlink" title="3 Pod镜像拉取策略"></a>3 Pod镜像拉取策略</h2><p>我们以具体实例来说，拉取策略就是 <code>imagePullPolicy</code></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114193605230.png" alt="image-20201114193605230"></p>
<p>拉取策略主要分为了以下几种</p>
<ul>
<li>IfNotPresent：默认值，镜像在宿主机上不存在才拉取</li>
<li>Always：每次创建Pod都会重新拉取一次镜像</li>
<li>Never：Pod永远不会主动拉取这个镜像</li>
</ul>
<h2 id="4-Pod资源限制"><a href="#4-Pod资源限制" class="headerlink" title="4 Pod资源限制"></a>4 Pod资源限制</h2><p>也就是我们Pod在进行调度的时候，可以对调度的资源进行限制，例如我们限制 Pod调度是使用的资源是 2C4G，那么在调度对应的node节点时，只会占用对应的资源，对于不满足资源的节点，将不会进行调度</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194057920.png" alt="image-20201114194057920"></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们在下面的地方进行资源的限制</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194245517.png" alt="image-20201114194245517"></p>
<p>这里分了两个部分</p>
<ul>
<li>request：表示调度所需的资源</li>
<li>limits：表示最大所占用的资源</li>
</ul>
<h2 id="5-Pod重启机制"><a href="#5-Pod重启机制" class="headerlink" title="5 Pod重启机制"></a>5 Pod重启机制</h2><p>因为Pod中包含了很多个容器，假设某个容器出现问题了，那么就会触发Pod重启机制</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194722125.png" alt="image-20201114194722125"></p>
<p>重启策略主要分为以下三种</p>
<ul>
<li>Always：当容器终止退出后，总是重启容器，默认策略 【nginx等，需要不断提供服务】</li>
<li>OnFailure：当容器异常退出（退出状态码非0）时，才重启容器。</li>
<li>Never：当容器终止退出，从不重启容器 【批量任务】</li>
</ul>
<h2 id="6-Pod健康检查"><a href="#6-Pod健康检查" class="headerlink" title="6 Pod健康检查"></a>6 Pod健康检查</h2><p>通过容器检查，原来我们使用下面的命令来检查</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl get pod</code></pre></div>

<p>但是有的时候，程序可能出现了 <strong>Java</strong> 堆内存溢出，程序还在运行，但是不能对外提供服务了，这个时候就不能通过 容器检查来判断服务是否可用了</p>
<p>这个时候就可以使用应用层面的检查</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 存活检查，如果检查失败，将杀死容器，根据Pod的restartPolicy【重启策略】来操作</span>
livenessProbe

<span class="hljs-comment"># 就绪检查，如果检查失败，Kubernetes会把Pod从Service endpoints中剔除</span>
readinessProbe</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114195807564.png" alt="image-20201114195807564"></p>
<p>Probe支持以下三种检查方式</p>
<ul>
<li>http Get：发送HTTP请求，返回200 - 400 范围状态码为成功</li>
<li>exec：执行Shell命令返回状态码是0为成功</li>
<li>tcpSocket：发起TCP Socket建立成功</li>
</ul>
<h2 id="7-Pod调度策略"><a href="#7-Pod调度策略" class="headerlink" title="7 Pod调度策略"></a>7 Pod调度策略</h2><h3 id="创建Pod流程"><a href="#创建Pod流程" class="headerlink" title="创建Pod流程"></a>创建Pod流程</h3><ul>
<li>首先创建一个pod，然后创建一个API Server 和 Etcd【把创建出来的信息存储在etcd中】</li>
<li>然后创建 Scheduler，监控API Server是否有新的Pod，如果有的话，会通过调度算法，把pod调度某个node上</li>
<li>在node节点，会通过 <code>kubelet -- apiserver</code> 读取etcd 拿到分配在当前node节点上的pod，然后通过docker创建容器</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114201611308.png" alt="image-20201114201611308"></p>
<h3 id="影响Pod调度的属性"><a href="#影响Pod调度的属性" class="headerlink" title="影响Pod调度的属性"></a>影响Pod调度的属性</h3><p>Pod资源限制对Pod的调度会有影响</p>
<h4 id="根据request找到足够node节点进行调度"><a href="#根据request找到足够node节点进行调度" class="headerlink" title="根据request找到足够node节点进行调度"></a>根据request找到足够node节点进行调度</h4><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194245517.png" alt="image-20201114194245517"></p>
<h4 id="节点选择器标签影响Pod调度"><a href="#节点选择器标签影响Pod调度" class="headerlink" title="节点选择器标签影响Pod调度"></a>节点选择器标签影响Pod调度</h4><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114202456151.png" alt="image-20201114202456151"></p>
<p>关于节点选择器，其实就是有两个环境，然后环境之间所用的资源配置不同</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114202643905.png" alt="image-20201114202643905"></p>
<p>我们可以通过以下命令，给我们的节点新增标签，然后节点选择器就会进行调度了</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl label node node1 env_role=prod</code></pre></div>

<h4 id="节点亲和性"><a href="#节点亲和性" class="headerlink" title="节点亲和性"></a>节点亲和性</h4><p>节点亲和性 <strong>nodeAffinity</strong> 和 之前nodeSelector 基本一样的，根据节点上标签约束来决定Pod调度到哪些节点上</p>
<ul>
<li>硬亲和性：约束条件必须满足</li>
<li>软亲和性：尝试满足，不保证</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114203433939.png" alt="image-20201114203433939"></p>
<p>支持常用操作符：in、NotIn、Exists、Gt、Lt、DoesNotExists</p>
<p>反亲和性：就是和亲和性刚刚相反，如 NotIn、DoesNotExists等</p>
<h2 id="8-污点和污点容忍"><a href="#8-污点和污点容忍" class="headerlink" title="8 污点和污点容忍"></a>8 污点和污点容忍</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><p>nodeSelector 和 NodeAffinity，都是Prod调度到某些节点上，属于Pod的属性，是在调度的时候实现的。</p>
<p>Taint 污点：节点不做普通分配调度，是节点属性</p>
<h3 id="8-2-场景"><a href="#8-2-场景" class="headerlink" title="8.2 场景"></a>8.2 场景</h3><ul>
<li>专用节点【限制ip】</li>
<li>配置特定硬件的节点【固态硬盘】</li>
<li>基于Taint驱逐【在node1不放，在node2放】</li>
</ul>
<h3 id="8-3-查看污点情况"><a href="#8-3-查看污点情况" class="headerlink" title="8.3 查看污点情况"></a>8.3 查看污点情况</h3><div class="code-wrapper"><pre><code class="hljs bash">kubectl describe node k8smaster | grep Taint</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114204124819.png" alt="image-20201114204124819"></p>
<p>污点值有三个</p>
<ul>
<li>NoSchedule：一定不被调度</li>
<li>PreferNoSchedule：尽量不被调度【也有被调度的几率】</li>
<li>NoExecute：不会调度，并且还会驱逐Node已有Pod</li>
</ul>
<h3 id="8-4-未节点添加污点"><a href="#8-4-未节点添加污点" class="headerlink" title="8.4 未节点添加污点"></a>8.4 未节点添加污点</h3><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node [node] key=value:污点的三个值</code></pre></div>

<p>举例：</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role=yes:NoSchedule</code></pre></div>

<h3 id="8-5-删除污点"><a href="#8-5-删除污点" class="headerlink" title="8.5 删除污点"></a>8.5 删除污点</h3><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role:NoSchedule-</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114210022883.png" alt="image-20201114210022883"></p>
<h3 id="8-6-演示"><a href="#8-6-演示" class="headerlink" title="8.6 演示"></a>8.6 演示</h3><p>我们现在创建多个Pod，查看最后分配到Node上的情况</p>
<p>首先我们创建一个 nginx 的pod</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl create deployment web --image=nginx</code></pre></div>

<p>然后使用命令查看</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods -o wide</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114204917548.png" alt="image-20201114204917548"></p>
<p>我们可以非常明显的看到，这个Pod已经被分配到 k8snode1 节点上了</p>
<p>下面我们把pod复制5份，在查看情况pod情况</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl scale deployment web --replicas=5</code></pre></div>

<p>我们可以发现，因为master节点存在污点的情况，所以节点都被分配到了 node1 和 node2节点上</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114205135282.png" alt="image-20201114205135282"></p>
<p>我们可以使用下面命令，把刚刚我们创建的pod都删除</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl delete deployment web</code></pre></div>

<p>现在给了更好的演示污点的用法，我们现在给 node1节点打上污点</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role=yes:NoSchedule</code></pre></div>

<p>然后我们查看污点是否成功添加</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl describe node k8snode1 | grep Taint</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114205516154.png" alt="image-20201114205516154"></p>
<p>然后我们在创建一个 pod</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建nginx pod</span>
kubectl create deployment web --image=nginx
<span class="hljs-comment"># 复制五次</span>
kubectl scale deployment web --replicas=5</code></pre></div>

<p>然后我们在进行查看</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods -o wide</code></pre></div>

<p>我们能够看到现在所有的pod都被分配到了 k8snode2上，因为刚刚我们给node1节点设置了污点</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114205654867.png" alt="image-20201114205654867"></p>
<p>最后我们可以删除刚刚添加的污点</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role:NoSchedule-</code></pre></div>

<h3 id="8-7-污点容忍"><a href="#8-7-污点容忍" class="headerlink" title="8.7 污点容忍"></a>8.7 污点容忍</h3><p>污点容忍就是某个节点可能被调度，也可能不被调度</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114210146123.png" alt="image-20201114210146123"></p>
<h1 id="第9章-Kubernetes核心技术-Controller"><a href="#第9章-Kubernetes核心技术-Controller" class="headerlink" title="第9章 Kubernetes核心技术-Controller"></a>第9章 Kubernetes核心技术-Controller</h1><h2 id="1-内容"><a href="#1-内容" class="headerlink" title="1 内容"></a>1 内容</h2><ul>
<li>什么是Controller</li>
<li>Pod和Controller的关系</li>
<li>Deployment控制器应用场景</li>
<li>yaml文件字段说明</li>
<li>Deployment控制器部署应用</li>
<li>升级回滚</li>
<li>弹性伸缩</li>
</ul>
<h2 id="2-什么是Controller"><a href="#2-什么是Controller" class="headerlink" title="2 什么是Controller"></a>2 什么是Controller</h2><p>Controller是在集群上管理和运行容器的对象，Controller是实际存在的，Pod是虚拟机的</p>
<h2 id="3-Pod和Controller的关系"><a href="#3-Pod和Controller的关系" class="headerlink" title="3 Pod和Controller的关系"></a>3 Pod和Controller的关系</h2><p>Pod是通过Controller实现应用的运维，比如弹性伸缩，滚动升级等</p>
<p>Pod 和 Controller之间是通过label标签来建立关系，同时Controller又被称为控制器工作负载</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116092431237.png" alt="image-20201116092431237"></p>
<h2 id="4-Deployment控制器应用"><a href="#4-Deployment控制器应用" class="headerlink" title="4 Deployment控制器应用"></a>4 Deployment控制器应用</h2><ul>
<li>Deployment控制器可以部署无状态应用</li>
<li>管理Pod和ReplicaSet</li>
<li>部署，滚动升级等功能</li>
<li>应用场景：web服务，微服务</li>
</ul>
<p>Deployment表示用户对K8S集群的一次更新操作。Deployment是一个比RS( Replica Set, RS) 应用模型更广的 API 对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧RS中的副本数减少到0的复合操作。</p>
<p>这样一个复合操作用一个RS是不好描述的，所以用一个更通用的Deployment来描述。以K8S的发展方向，未来对所有长期伺服型的业务的管理，都会通过Deployment来管理。</p>
<h2 id="5-Deployment部署应用"><a href="#5-Deployment部署应用" class="headerlink" title="5 Deployment部署应用"></a>5 Deployment部署应用</h2><p>之前我们也使用Deployment部署过应用，如下代码所示</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectrl create deployment web --image=nginx</code></pre></div>

<p>但是上述代码不是很好的进行复用，因为每次我们都需要重新输入代码，所以我们都是通过YAML进行配置</p>
<p>但是我们可以尝试使用上面的代码创建一个镜像【只是尝试，不会创建】</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl create deployment web --image=nginx --dry-run -o yaml &gt; nginx.yaml</code></pre></div>

<p>然后输出一个yaml配置文件 <code>nginx.yml</code> ，配置文件如下所示</p>
<div class="code-wrapper"><pre><code class="hljs bash">apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: web
  name: web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web
  strategy: &#123;&#125;
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: web
    spec:
      containers:
      - image: nginx
        name: nginx
        resources: &#123;&#125;
status: &#123;&#125;</code></pre></div>

<p>我们看到的 selector 和 label 就是我们Pod 和 Controller之间建立关系的桥梁</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116093638951.png" alt="image-20201116093638951"></p>
<h3 id="使用YAML创建Pod"><a href="#使用YAML创建Pod" class="headerlink" title="使用YAML创建Pod"></a>使用YAML创建Pod</h3><p>通过刚刚的代码，我们已经生成了YAML文件，下面我们就可以使用该配置文件快速创建Pod镜像了</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl apply -f nginx.yaml</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116094046007.png" alt="image-20201116094046007"></p>
<p>但是因为这个方式创建的，我们只能在集群内部进行访问，所以我们还需要对外暴露端口</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl expose deployment web --port=80 --<span class="hljs-built_in">type</span>=NodePort --target-port=80 --name=web1</code></pre></div>

<p>关于上述命令，有几个参数</p>
<ul>
<li>–port：就是我们内部的端口号</li>
<li>–target-port：就是暴露外面访问的端口号</li>
<li>–name：名称</li>
<li>–type：类型</li>
</ul>
<p>同理，我们一样可以导出对应的配置文件</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl expose deployment web --port=80 --<span class="hljs-built_in">type</span>=NodePort --target-port=80 --name=web1 -o yaml &gt; web1.yaml</code></pre></div>

<p>得到的web1.yaml如下所示</p>
<div class="code-wrapper"><pre><code class="hljs bash">apiVersion: v1
kind: Service
metadata:
  creationTimestamp: <span class="hljs-string">&quot;2020-11-16T02:26:53Z&quot;</span>
  labels:
    app: web
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:metadata:
        f:labels:
          .: &#123;&#125;
          f:app: &#123;&#125;
      f:spec:
        f:externalTrafficPolicy: &#123;&#125;
        f:ports:
          .: &#123;&#125;
          k:&#123;<span class="hljs-string">&quot;port&quot;</span>:80,<span class="hljs-string">&quot;protocol&quot;</span>:<span class="hljs-string">&quot;TCP&quot;</span>&#125;:
            .: &#123;&#125;
            f:port: &#123;&#125;
            f:protocol: &#123;&#125;
            f:targetPort: &#123;&#125;
        f:selector:
          .: &#123;&#125;
          f:app: &#123;&#125;
        f:sessionAffinity: &#123;&#125;
        f:<span class="hljs-built_in">type</span>: &#123;&#125;
    manager: kubectl
    operation: Update
    time: <span class="hljs-string">&quot;2020-11-16T02:26:53Z&quot;</span>
  name: web2
  namespace: default
  resourceVersion: <span class="hljs-string">&quot;113693&quot;</span>
  selfLink: /api/v1/namespaces/default/services/web2
  uid: d570437d-a6b4-4456-8dfb-950f09534516
spec:
  clusterIP: 10.104.174.145
  externalTrafficPolicy: Cluster
  ports:
  - nodePort: 32639
    port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: web
  sessionAffinity: None
  <span class="hljs-built_in">type</span>: NodePort
status:
  loadBalancer: &#123;&#125;</code></pre></div>

<p>然后我们可以通过下面的命令来查看对外暴露的服务</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods,svc</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116104021357.png" alt="image-20201116104021357"></p>
<p>然后我们访问对应的url，即可看到 nginx了 <code>http://192.168.177.130:32639/</code></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116104131968.png" alt="image-20201116104131968"></p>
<h2 id="6-升级回滚和弹性伸缩"><a href="#6-升级回滚和弹性伸缩" class="headerlink" title="6 升级回滚和弹性伸缩"></a>6 升级回滚和弹性伸缩</h2><ul>
<li>升级：  假设从版本为1.14 升级到 1.15 ，这就叫应用的升级【升级可以保证服务不中断】</li>
<li>回滚：从版本1.15 变成 1.14，这就叫应用的回滚</li>
<li>弹性伸缩：我们根据不同的业务场景，来改变Pod的数量对外提供服务，这就是弹性伸缩</li>
</ul>
<h3 id="应用升级和回滚"><a href="#应用升级和回滚" class="headerlink" title="应用升级和回滚"></a>应用升级和回滚</h3><p>首先我们先创建一个 1.14版本的Pod</p>
<div class="code-wrapper"><pre><code class="hljs bash">apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: web
  name: web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web
  strategy: &#123;&#125;
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: web
    spec:
      containers:
      - image: nginx:1.14
        name: nginx
        resources: &#123;&#125;
status: &#123;&#125;</code></pre></div>

<p>我们先指定版本为1.14，然后开始创建我们的Pod</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl apply -f nginx.yaml</code></pre></div>

<p>同时，我们使用docker images命令，就能看到我们成功拉取到了一个 1.14版本的镜像</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116105710966.png" alt="image-20201116105710966"></p>
<p>我们使用下面的命令，可以将nginx从 1.14 升级到 1.15</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">set</span> image deployment web nginx=nginx:1.15</code></pre></div>

<p>在我们执行完命令后，能看到升级的过程</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116105847069.png" alt="image-20201116105847069"></p>
<ul>
<li>首先是开始的nginx 1.14版本的Pod在运行，然后 1.15版本的在创建</li>
<li>然后在1.15版本创建完成后，就会暂停1.14版本</li>
<li>最后把1.14版本的Pod移除，完成我们的升级</li>
</ul>
<p>我们在下载 1.15版本，容器就处于ContainerCreating状态，然后下载完成后，就用 1.15版本去替换1.14版本了，这么做的好处就是：升级可以保证服务不中断</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116111614085.png" alt="image-20201116111614085"></p>
<p>我们到我们的node2节点上，查看我们的 docker images;</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116111315000.png" alt="image-20201116111315000"></p>
<p>能够看到，我们已经成功拉取到了 1.15版本的nginx了</p>
<h4 id="查看升级状态"><a href="#查看升级状态" class="headerlink" title="查看升级状态"></a>查看升级状态</h4><p>下面可以，查看升级状态</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout status deployment web</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116112139645.png" alt="image-20201116112139645"></p>
<h4 id="查看历史版本"><a href="#查看历史版本" class="headerlink" title="查看历史版本"></a>查看历史版本</h4><p>我们还可以查看历史版本</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout <span class="hljs-built_in">history</span> deployment web</code></pre></div>

<h4 id="应用回滚"><a href="#应用回滚" class="headerlink" title="应用回滚"></a>应用回滚</h4><p>我们可以使用下面命令，完成回滚操作，也就是回滚到上一个版本</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout undo deployment web</code></pre></div>

<p>然后我们就可以查看状态</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout status deployment web</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116112524601.png" alt="image-20201116112524601"></p>
<p>同时我们还可以回滚到指定版本</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout undo deployment web --to-revision=2</code></pre></div>

<h3 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h3><p>弹性伸缩，也就是我们通过命令一下创建多个副本</p>
<div class="code-wrapper"><pre><code class="hljs bash">kubectl scale deployment web --replicas=10</code></pre></div>

<p>能够清晰看到，我们一下创建了10个副本</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201117092841865.png" alt="image-20201117092841865"></p>
]]></content>
      <categories>
        <category>Technical</category>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习</title>
    <url>/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Docker-学习"><a href="#Docker-学习" class="headerlink" title="Docker 学习"></a>Docker 学习</h1><blockquote>
<p>  弱小和无知不是生存的障碍，傲慢才是。</p>
</blockquote>
<h2 id="1-Docker-概述"><a href="#1-Docker-概述" class="headerlink" title="1 Docker 概述"></a>1 Docker 概述</h2><h3 id="1-1-Docker-为什么出现"><a href="#1-1-Docker-为什么出现" class="headerlink" title="1.1 Docker 为什么出现?"></a>1.1 Docker 为什么出现?</h3><p>一款产品： 开发–上线 两套环境！应用环境，应用配置！</p>
<p>开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？</p>
<p>环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。</p>
<p>发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！</p>
<p>之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。</p>
<p>开发环境Windows，最后发布到Linux！</p>
<p>传统：开发jar，运维来做！</p>
<p>现在：开发打包部署上线，一套流程做完！</p>
<p>安卓流程：java — apk —发布（应用商店）一 张三使用apk一安装即可用！</p>
<p>docker流程： java-jar（环境） — 打包项目帯上环境（镜像） — ( Docker仓库：商店）—–</p>
<p>Docker给以上的问题，提出了解决方案!</p>
<p>Docker的思想就来自于集装箱！</p>
<p>JRE – 多个应用(端口冲突) – 原来都是交叉的！<br>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p>
<p>Docker通过隔离机制，可以将服务器利用到极致！</p>
<p>本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！</p>
<h3 id="1-2-Docker-历史"><a href="#1-2-Docker-历史" class="headerlink" title="1.2 Docker 历史"></a>1.2 Docker 历史</h3><p>2010年，几个的年轻人，就在美国成立了一家公司 dotcloud</p>
<p>做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！</p>
<p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p>
<p>他们将自己的技术（容器化技术）命名就是 Docker<br>Docker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！</p>
<blockquote>
<p>  开源</p>
</blockquote>
<p>2013年，Docker开源！</p>
<p>越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！</p>
<p>2014年4月9日，Docker1.0发布！</p>
<p>docker为什么这么火？十分的轻巧！</p>
<p>在容器技术出来之前，我们都是使用虚拟机技术！</p>
<p>虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！</p>
<p>虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">VMware : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟
docker: 隔离，镜像（最核心的环境 <span class="hljs-number">4</span>m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！</code></pre></div>

<p>Docker基于Go语言开发的！开源项目！</p>
<p>docker官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a> Docker的文档是超级详细的！</p>
<p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>比较Docker和虚拟机技术的不同：</p>
<p>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</p>
<p>容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</p>
<p>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响</p>
<p>应用更快速的交付和部署</p>
<p>传统：一对帮助文档，安装程序。</p>
<p>Docker：打包镜像发布测试一键运行。</p>
<p>更便捷的升级和扩缩容</p>
<p>使用了 Docker之后，我们部署应用就和搭积木一样<br>项目打包为一个镜像，扩展服务器A！服务器B</p>
<p>更简单的系统运维<br>在容器化之后，我们的开发，测试环境都是高度一致的</p>
<p>更高效的计算资源利用</p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</p>
<h2 id="2-Docker-安装"><a href="#2-Docker-安装" class="headerlink" title="2 Docker 安装"></a>2 Docker 安装</h2><h3 id="2-1-Docker-的基本组成"><a href="#2-1-Docker-的基本组成" class="headerlink" title="2.1 Docker 的基本组成"></a>2.1 Docker 的基本组成</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDE5NTgwNTQwMC5wbmc" alt="image-20200514195805400"></p>
<ul>
<li><p>镜像（image)：</p>
<p>docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像 ==&gt; run ==&gt; 容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p>
</li>
<li><p>容器(container)：</p>
<p>Docker 利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.<br>启动，停止，删除，基本命令<br>目前就可以把这个容器理解为就是一个简易的 Linux系统。</p>
</li>
<li><p>仓库(repository)：</p>
<p>仓库就是存放镜像的地方！<br>仓库分为公有仓库和私有仓库。(很类似git)<br>Docker Hub是国外的。<br>阿里云…都有容器服务器(配置镜像加速!)</p>
</li>
</ul>
<h3 id="2-2-安装-Docker"><a href="#2-2-安装-Docker" class="headerlink" title="2.2 安装 Docker"></a>2.2 安装 Docker</h3><blockquote>
<p>  环境准备</p>
</blockquote>
<ol>
<li>Linux要求内核3.0以上</li>
<li>CentOS 7</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs xml">[root@iZwz9chr22v1g8swsrgdagZ ~]# uname -r
3.10.0-1127.19.1.el7.x86_64
[root@iZwz9chr22v1g8swsrgdagZ ~]# cat /etc/os-release 
NAME=&quot;CentOS Linux&quot;
VERSION=&quot;7 (Core)&quot;
ID=&quot;centos&quot;
ID_LIKE=&quot;rhel fedora&quot;
VERSION_ID=&quot;7&quot;
PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;
ANSI_COLOR=&quot;0;31&quot;
CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;
HOME_URL=&quot;https://www.centos.org/&quot;
BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;

CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;
CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;
REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;
REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</code></pre></div>

<blockquote>
<p>  安装</p>
</blockquote>
<p>帮助文档：<a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a><br>卸载与安装</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.卸载旧版本</span>
yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
<span class="hljs-meta">#</span><span class="bash"> 2.需要的安装包</span>
yum install -y yum-utils

<span class="hljs-meta">#</span><span class="bash"> 3.设置镜像的仓库</span>
yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
<span class="hljs-meta">#</span><span class="bash">上述方法默认是从国外的，不推荐</span>

<span class="hljs-meta">#</span><span class="bash">推荐使用国内的</span>
yum-config-manager \
    --add-repo \
    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
    
<span class="hljs-meta">#</span><span class="bash">更新yum软件包索引</span>
yum makecache fast

<span class="hljs-meta">#</span><span class="bash"> 4.安装docker相关的 docker-ce 社区版 而ee是企业版</span>
yum install docker-ce docker-ce-cli containerd.io # 这里我们使用社区版即可 安装最新版
sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io-&lt;VERSION_STRING&gt; # 安装固定版本
sudo yum install docker-ce-18.09.1 docker-ce-cli-18.09.1 containerd.io-18.09.1 # 安装固定版本

<span class="hljs-meta">#</span><span class="bash"> 5.设置开机启动并启动docker</span>

systemctl enable docker &amp;&amp; systemctl start docker
y
<span class="hljs-meta">#</span><span class="bash"> 6. 使用docker version查看是否按照成功</span>
docker version</code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195237759.png" alt="image-20210509195237759"></p>
<div class="code-wrapper"><pre><code class="hljs xml"># 7. 测试
docker run hello-world
# 8.不要忘记配置阿里云镜像加速</code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195535948.png" alt="image-20210509195535948"></p>
<div class="code-wrapper"><pre><code class="hljs xml">#8.查看已经下载的镜像(从这里可以查看已有镜像的id)
docker images</code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195629675.png" alt="image-20210509195629675"></p>
<blockquote>
<p>  卸载docker</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs xml">#1. 卸载依赖
yum remove docker-ce docker-ce-cli containerd.io
#2. 删除资源
rm -rf /var/lib/docker
# /var/lib/docker 是docker的默认工作路径！</code></pre></div>

<h3 id="2-3-阿里云镜像加速"><a href="#2-3-阿里云镜像加速" class="headerlink" title="2.3 阿里云镜像加速"></a>2.3 阿里云镜像加速</h3><ol>
<li><p>登录阿里云找到容器服务</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509212735155.png" alt="image-20210509212735155"></p>
</li>
<li><p>找到镜像加速器</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509212755335.png" alt="image-20210509212755335"></p>
</li>
<li><p>配置使用</p>
<div class="code-wrapper"><pre><code class="hljs xml">sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;
&#123;
  &quot;registry-mirrors&quot;: [&quot;https://kdx6iqr6.mirror.aliyuncs.com&quot;]
&#125;
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker</code></pre></div>



</li>
</ol>
<h3 id="2-4-回顾HelloWorld流程"><a href="#2-4-回顾HelloWorld流程" class="headerlink" title="2.4 回顾HelloWorld流程"></a>2.4 回顾HelloWorld流程</h3><ul>
<li><p>docker run 流程图</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjYzNzI0Ni5wbmc" alt="image-20200515102637246"></p>
</li>
<li><p>底层原理</p>
<p>Docker<strong>是怎么工作的</strong>？</p>
<p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</p>
<p>Docker-Server接收到Docker-Client的指令，就会执行这个命令！</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjk0OTU1OC5wbmc" alt="image-20200515102949558"></p>
</li>
<li><p>为什么Docker比Vm快</p>
<p>1、docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>2、docker利用的是宿主机的内核,而不需要Guest OS。</p>
<div class="code-wrapper"><pre><code class="hljs xml">GuestOS： VM（虚拟机）里的的系统（OS）

HostOS：物理机里的系统（OS）</code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwNDExNzMyOS5wbmc" alt="image-20200515104117329"></p>
<p>因此,当新建一个 容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。因而避免引导、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了这个复杂的过程,因此新建一个docker容器只需要几秒钟。</p>
</li>
</ul>
<h2 id="3-Docker-命令"><a href="#3-Docker-命令" class="headerlink" title="3 Docker 命令"></a>3 Docker 命令</h2><h3 id="3-1-帮助命令"><a href="#3-1-帮助命令" class="headerlink" title="3.1 帮助命令"></a>3.1 帮助命令</h3><div class="code-wrapper"><pre><code class="hljs dockerfile">docker version    <span class="hljs-comment">#显示docker的版本信息。</span>
docker info       <span class="hljs-comment">#显示docker的系统信息，包括镜像和容器的数量</span>
docker 命令 --help <span class="hljs-comment">#帮助命令</span></code></pre></div>

<p>帮助文档的地址：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p>
<h3 id="3-2-镜像命令"><a href="#3-2-镜像命令" class="headerlink" title="3.2 镜像命令"></a>3.2 镜像命令</h3><div class="code-wrapper"><pre><code class="hljs dockerfile">docker images <span class="hljs-comment">#查看所有本地主机上的镜像 可以使用docker image ls代替</span>

docker search <span class="hljs-comment">#搜索镜像</span>

docker pull <span class="hljs-comment">#下载镜像 docker image pull</span>

docker rmi <span class="hljs-comment">#删除镜像 docker image rm</span></code></pre></div>

<ul>
<li><p>docker images查看所有本地的主机上的镜像</p>
<div class="code-wrapper"><pre><code class="hljs clean">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images
REPOSITORY            TAG                 IMAGE ID            CREATED           SIZE
hello-world           latest              bf756fb1ae65        <span class="hljs-number">4</span> months ago     <span class="hljs-number">13.3</span>kB
mysql                 <span class="hljs-number">5.7</span>                 b84d68d0a7db        <span class="hljs-number">6</span> days ago       <span class="hljs-number">448</span>MB

# 解释
#REPOSITORY			# 镜像的仓库源
#TAG				# 镜像的标签(版本)		---lastest 表示最新版本
#IMAGE ID			# 镜像的id
#CREATED			# 镜像的创建时间
#SIZE				# 镜像的大小

# 可选项
Options:
  -a, --all         Show all images (default hides intermediate images) #列出所有镜像
  -q, --quiet       Only show numeric IDs # 只显示镜像的id
  
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images -a  #列出所有镜像详细信息
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images -aq #列出所有镜像的id
d5f28a0bb0d0
f19c56ce92a8
<span class="hljs-number">1</span>b6b1fe7261e
<span class="hljs-number">1</span>b6b1fe7261e</code></pre></div>
</li>
<li><p>docker search 搜索镜像</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210512223558303.png" alt="image-20210512223558303"></p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker search mysql</span>

<span class="hljs-comment"># --filter=STARS=3000 #过滤，搜索出来的镜像收藏STARS数量大于3000的</span>
Options:
  -f, --filter filter   Filter output based on conditions provided
      --format string   Pretty-print search using a Go template
      --limit int       Max number of search results (default <span class="hljs-number">25</span>)
      --no-trunc        Don<span class="hljs-string">&#x27;t truncate output</span>
<span class="hljs-string">      </span>
<span class="hljs-string">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker search mysql --filter=STARS=3000</span>
<span class="hljs-string">NAME        DESCRIPTION         STARS            OFFICIAL        AUTOMATED</span>
<span class="hljs-string">mysql       MySQL IS ...        9520             [OK]                </span>
<span class="hljs-string">mariadb     MariaDB IS ...      3456             [OK]   </span></code></pre></div>
</li>
<li><p>docker pull 下载镜像</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 下载镜像 docker pull 镜像名[:tag]</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker pull tomcat:8</span>
<span class="hljs-number">8</span>: Pulling <span class="hljs-keyword">from</span> library/tomcat <span class="hljs-comment">#如果不写tag，默认就是latest</span>
<span class="hljs-number">90</span>fe46dd8199: Already exists   <span class="hljs-comment">#分层下载： docker image 的核心 联合文件系统</span>
<span class="hljs-number">35</span>a4f1977689: Already exists 
bbc37f14aded: Already exists 
<span class="hljs-number">74</span>e27dc593d4: Already exists 
<span class="hljs-number">93</span>a01fbfad7f: Already exists 
<span class="hljs-number">1478</span>df405869: Pull complete 
<span class="hljs-number">64</span>f0dd11682b: Pull complete 
<span class="hljs-number">68</span>ff4e050d11: Pull complete 
f576086003cf: Pull complete 
<span class="hljs-number">3</span>b72593ce10e: Pull complete 
Digest: sha256:<span class="hljs-number">0</span>c6234e7ec9d10ab32c06423ab829b32e3183ba5bf2620ee66de866df <span class="hljs-comment"># 签名防伪</span>
Status: Downloaded newer image for tomcat:<span class="hljs-number">8</span>
docker.io/library/tomcat:<span class="hljs-number">8</span> <span class="hljs-comment">#真实地址</span>

<span class="hljs-comment">#等价于</span>
docker pull tomcat:<span class="hljs-number">8</span>
docker pull docker.io/library/tomcat:<span class="hljs-number">8</span></code></pre></div>
</li>
<li><p>docker rmi 删除镜像</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">docker rmi -f 镜像id <span class="hljs-comment">#删除指定id的镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker rmi -f f19c56ce92a8</span>

docker rmi -f $(docker images -aq) <span class="hljs-comment">#删除全部的镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker stop $(docker ps -a -q)</span></code></pre></div>

</li>
</ul>
<h3 id="3-3-容器命令"><a href="#3-3-容器命令" class="headerlink" title="3.3 容器命令"></a>3.3 容器命令</h3><ul>
<li><p>镜像下载</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment">#docker中下载centos</span>
docker pull centos</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> 镜像id <span class="hljs-comment">#新建容器并启动</span></span>

docker ps 列出所有运行的容器 docker container list

docker rm 容器id <span class="hljs-comment">#删除指定容器</span>

docker start 容器id	<span class="hljs-comment">#启动容器</span>
docker restart 容器id	<span class="hljs-comment">#重启容器</span>
docker stop 容器id	<span class="hljs-comment">#停止当前正在运行的容器</span>
docker kill 容器id	<span class="hljs-comment">#强制停止当前容器</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs dockerfile">[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker container list  #h和docker ps相同</span></code></pre></div>
</li>
<li><p>新建容器并启动</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> [可选参数] image | docker container run [可选参数] image </span>
<span class="hljs-comment">#参书说明</span>
--name=<span class="hljs-string">&quot;Name&quot;</span>		<span class="hljs-comment">#容器名字 tomcat01 tomcat02 用来区分容器</span>
-d					<span class="hljs-comment">#后台方式运行</span>
-it 				<span class="hljs-comment">#使用交互方式运行，进入容器查看内容</span>
-p					<span class="hljs-comment">#指定容器的端口 -p 8080(宿主机):8080(容器)</span>
		-p ip:主机端口:容器端口
		-p 主机端口:容器端口(常用)
		-p 容器端口
		容器端口
-P(大写) 				随机指定端口

<span class="hljs-comment"># 测试、启动并进入容器</span>
[root@iz2zeak7sgj6i7hrb2g
[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker run -it centos /bin/bash</span>
[root@<span class="hljs-number">241</span>b5abce65e /]<span class="hljs-comment"># ls</span>
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  <span class="hljs-keyword">run</span><span class="bash">  sbin  srv  sys  tmp  usr  var</span>
[root@<span class="hljs-number">241</span>b5abce65e /]<span class="hljs-comment"># exit #从容器退回主机</span>
exit</code></pre></div>
</li>
<li><p>列出所有运行的容器</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">docker ps 命令  		<span class="hljs-comment">#列出当前正在运行的容器</span>
  -a, --all     	 <span class="hljs-comment">#列出当前正在运行的容器 + 带出历史运行过的容器</span>
  -n=?, --last int   <span class="hljs-comment">#列出最近创建的?个容器 ?为1则只列出最近创建的一个容器,为2则列出2个</span>
  -q, --quiet        <span class="hljs-comment">#只列出容器的编号</span></code></pre></div>
</li>
<li><p>退出容器</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">exit 		<span class="hljs-comment">#容器直接退出</span>
ctrl +P +Q  <span class="hljs-comment">#容器不停止退出 	---注意：这个很有用的操作</span></code></pre></div>
</li>
<li><p>删除容器</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">docker rm 容器id   				<span class="hljs-comment">#删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -rf</span>
docker rm -f $(docker ps -aq)  	 <span class="hljs-comment">#删除所有的容器</span>
docker ps -a -q|xargs docker rm  <span class="hljs-comment">#删除所有的容器</span></code></pre></div>
</li>
<li><p>启动和停止容器的操作</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">docker start 容器id	<span class="hljs-comment">#启动容器</span>
docker restart 容器id	<span class="hljs-comment">#重启容器</span>
docker stop 容器id	<span class="hljs-comment">#停止当前正在运行的容器</span>
docker kill 容器id	<span class="hljs-comment">#强制停止当前容器</span></code></pre></div>


</li>
</ul>
<h3 id="3-4-常用其他命令"><a href="#3-4-常用其他命令" class="headerlink" title="3.4 常用其他命令"></a>3.4 常用其他命令</h3><ul>
<li><p><strong>后台启动命令</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令 docker run -d 镜像名</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d centos
a8f922c255859622ac45ce3a535b7a0e8253329be4756ed6e32265d2dd2fac6c

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps    
CONTAINER ID      IMAGE       COMMAND    CREATED     STATUS   PORTS    NAMES
<span class="hljs-meta">#</span><span class="bash"> 问题docker ps. 发现centos 停止了</span>
<span class="hljs-meta">#</span><span class="bash"> 常见的坑，docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止</span>
<span class="hljs-meta">#</span><span class="bash"> nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span></code></pre></div>
</li>
<li><p><strong>查看日志</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell">docker logs --help
Options:
      --details        Show extra details provided to logs 
*  -f, --follow         Follow log output
      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)
*      --tail string    Number of lines to show from the end of the logs (default &quot;all&quot;)
*  -t, --timestamps     Show timestamps
      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)
➜  ~ docker run -d centos /bin/sh -c &quot;while true;do echo 6666;sleep 1;done&quot; #模拟日志      
<span class="hljs-meta">#</span><span class="bash">显示日志</span>
-tf		#显示日志信息（一直更新）
--tail number #需要显示日志条数
docker logs -t --tail n 容器id #查看n行日志
docker logs -ft 容器id #跟着日志</code></pre></div>
</li>
<li><p><strong>查看容器中进程信息ps</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令 docker top 容器id</span></code></pre></div>
</li>
<li><p><strong>查看镜像的元数据</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令</span>
docker inspect 容器id

<span class="hljs-meta">#</span><span class="bash">测试</span>
➜  ~ docker inspect 55321bcae33d
[
    &#123;
        &quot;Id&quot;: &quot;55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066&quot;,
        &quot;Created&quot;: &quot;2020-05-15T05:22:05.515909071Z&quot;,
        &quot;Path&quot;: &quot;/bin/sh&quot;,
        &quot;Args&quot;: [
            &quot;-c&quot;,
            &quot;while true;do echo 6666;sleep 1;done&quot;
        ],
        &quot;State&quot;: &#123;
            &quot;Status&quot;: &quot;running&quot;,
            &quot;Running&quot;: true,
            &quot;Paused&quot;: false,
            &quot;Restarting&quot;: false,
            &quot;OOMKilled&quot;: false,
            &quot;Dead&quot;: false,
            &quot;Pid&quot;: 22973,
            &quot;ExitCode&quot;: 0,
            &quot;Error&quot;: &quot;&quot;,
            &quot;StartedAt&quot;: &quot;2020-05-15T05:22:06.165904633Z&quot;,
            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;
        &#125;,
        &quot;Image&quot;: &quot;sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee&quot;,
        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/resolv.conf&quot;,
        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/hostname&quot;,
        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/hosts&quot;,
........</code></pre></div>
</li>
<li><p><strong>进入当前正在运行的容器</strong></p>
<p>我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</p>
<ul>
<li><p>docker exec -it 容器id bashshell</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">测试</span>
➜ ~ docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
55321bcae33d centos “/bin/sh -c &#x27;while t…” 10 minutes ago Up 10 minutes bold_bell
a7215824a4db centos “/bin/sh -c &#x27;while t…” 13 minutes ago Up 13 minutes zen_kepler
55a31b3f8613 centos “/bin/bash” 15 minutes ago Up 15 minutes lucid_clarke
➜ ~ docker exec -it 55321bcae33d /bin/bash
[root@55321bcae33d /]#</code></pre></div>
</li>
<li><p>方法2</p>
<div class="code-wrapper"><pre><code class="hljs shell">docker attach 容器id
<span class="hljs-meta">#</span><span class="bash">测试</span>
docker attach 55321bcae33d 
正在执行当前的代码...
区别
<span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> <span class="hljs-comment">#进入当前容器后开启一个新的终端，可以在里面操作。（常用）</span></span>
<span class="hljs-meta">#</span><span class="bash">docker attach <span class="hljs-comment"># 进入容器正在执行的终端</span></span></code></pre></div>
</li>
</ul>
</li>
<li><p><strong>从容器内拷贝到主机上</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell">docker cp 容器id:容器内路径  主机目的路径

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps
CONTAINER ID     IMAGE    COMMAND     CREATED         STATUS       PORTS      NAMES
56a5583b25b4     centos   &quot;/bin/bash&quot; 7seconds ago    Up 6 seconds      

<span class="hljs-meta">#</span><span class="bash">1. 进入docker容器内部</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 56a5583b25b4 /bin/bash
[root@55321bcae33d /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

<span class="hljs-meta">#</span><span class="bash">新建一个文件</span>
[root@55321bcae33d /]# echo &quot;hello&quot; &gt; java.java
[root@55321bcae33d /]# cat hello.java 
hello
[root@55321bcae33d /]# exit
exit

<span class="hljs-meta">#</span><span class="bash">hello.java拷贝到home文件加下</span>
[root@iz2zeak7sgj6i7hrb2g862z /]# docker cp 56a5583b25b4:/hello.java /home 
[root@iz2zeak7sgj6i7hrb2g862z /]# cd /home
[root@iz2zeak7sgj6i7hrb2g862z home]# ls -l	#可以看见java.java存在
total 8
-rw-r--r-- 1 root root    0 May 19 22:09 haust.java
-rw-r--r-- 1 root root    6 May 22 11:12 java.java
drwx------ 3 www  www  4096 May  8 12:14 www</code></pre></div>

</li>
</ul>
<p>学习方式：将我的所有笔记敲一遍，自己记录笔记！</p>
<h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDIxNDMxMzk2Mi5wbmc" alt="image-20200514214313962"></p>
<h3 id="3-6-命令大全"><a href="#3-6-命令大全" class="headerlink" title="3.6 命令大全"></a>3.6 <strong>命令大全</strong></h3><div class="code-wrapper"><pre><code class="hljs shell">attach      Attach local standard input, output, and error streams to a running container
<span class="hljs-meta">#</span><span class="bash">当前shell下 attach连接指定运行的镜像</span>
build       Build an image from a Dockerfile # 通过Dockerfile定制镜像
commit      Create a new image from a container&#x27;s changes #提交当前容器为新的镜像
cp          Copy files/folders between a container and the local filesystem #拷贝文件
create      Create a new container #创建一个新的容器
diff        Inspect changes to files or directories on a container&#x27;s filesystem #查看docker容器的变化
events      Get real time events from the server # 从服务获取容器实时时间
exec        Run a command in a running container # 在运行中的容器上运行命令
export      Export a container&#x27;s filesystem as a tar archive #导出容器文件系统作为一个tar归档文件[对应import]
history     Show the history of an image # 展示一个镜像形成历史
images      List images #列出系统当前的镜像
import      Import the contents from a tarball to create a filesystem image #从tar包中导入内容创建一个文件系统镜像
info        Display system-wide information # 显示全系统信息
inspect     Return low-level information on Docker objects #查看容器详细信息
kill        Kill one or more running containers # kill指定docker容器
load        Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载一个镜像[对应save]
login       Log in to a Docker registry #
logout      Log out from a Docker registry
logs        Fetch the logs of a container
pause       Pause all processes within one or more containers
port        List port mappings or a specific mapping for the container
ps          List containers
pull        Pull an image or a repository from a registry
push        Push an image or a repository to a registry
rename      Rename a container
restart     Restart one or more containers
rm          Remove one or more containers
rmi         Remove one or more images
run         Run a command in a new container
save        Save one or more images to a tar archive (streamed to STDOUT by default)
search      Search the Docker Hub for images
start       Start one or more stopped containers
stats       Display a live stream of container(s) resource usage statistics
stop        Stop one or more running containers
tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
top         Display the running processes of a container
unpause     Unpause all processes within one or more containers
update      Update configuration of one or more containers
version     Show the Docker version information
wait        Block until one or more containers stop, then print their exit codes</code></pre></div>



<h2 id="4-Docker-服务安装"><a href="#4-Docker-服务安装" class="headerlink" title="4 Docker 服务安装"></a>4 Docker 服务安装</h2><h3 id="4-1-安装-Nginx"><a href="#4-1-安装-Nginx" class="headerlink" title="4.1 安装 Nginx"></a>4.1 安装 Nginx</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">1. 搜索镜像 search 建议大家去docker搜索，可以看到帮助文档</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker search nginx

<span class="hljs-meta">#</span><span class="bash">2. 拉取下载镜像 pull</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull nginx

<span class="hljs-meta">#</span><span class="bash">3. 查看是否下载成功镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images

<span class="hljs-meta">#</span><span class="bash">3. 运行测试</span>
<span class="hljs-meta">#</span><span class="bash"> -d 后台运行</span>
<span class="hljs-meta">#</span><span class="bash"> --name 给容器命名</span>
<span class="hljs-meta">#</span><span class="bash"> -p 宿主机端口：容器内部端口</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name nginx01 -p 3344:80 nginx
aa664b0c8ed98f532453ce1c599be823bcc1f3c9209e5078615af416ccb454c2

<span class="hljs-meta">#</span><span class="bash">4. 查看正在启动的镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
75943663c116        nginx               &quot;nginx -g &#x27;daemon of…&quot;   41 seconds ago      Up 40 seconds       0.0.0.0:82-&gt;80/tcp   nginx00

<span class="hljs-meta">#</span><span class="bash">5. 进入容器</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it nginx01 /bin/bash #进入
root@aa664b0c8ed9:/# whereis nginx	#找到nginx位置
nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
root@aa664b0c8ed9:/# cd /etc/nginx/
root@aa664b0c8ed9:/etc/nginx# ls
conf.d	fastcgi_params	koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params	uwsgi_params  win-utf

<span class="hljs-meta">#</span><span class="bash">6. 退出容器</span>
root@aa664b0c8ed9:/etc/nginx# exit
exit

<span class="hljs-meta">#</span><span class="bash">7. 停止容器</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
aa664b0c8ed9        nginx               &quot;nginx -g &#x27;daemon of…&quot;   10 minutes ago      Up 10 minutes       0.0.0.0:3344-&gt;80/tcp   nginx01
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop aa664b0c8ed9</code></pre></div>

<p><strong>宿主机端口</strong> 和 <strong>容器内部端口</strong> 以及端口暴露：</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDIxNTkxNTY1MC5wbmc" alt="img"></p>
<p><strong>问题：</strong>我们每次改动nginx配置文件，都需要进入容器内部？十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器外部修改文件名，容器内部就可以自动修改？-v 数据卷 技术！</p>
<h3 id="4-3-安装-Tomcat"><a href="#4-3-安装-Tomcat" class="headerlink" title="4.3 安装 Tomcat"></a>4.3 安装 Tomcat</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载 tomcat9.0</span>
<span class="hljs-meta">#</span><span class="bash"> 之前的启动都是后台，停止了容器，容器还是可以查到， docker run -it --rm 镜像名 一般是用来测试，用完就删除</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -it --rm tomcat:9.0

--rm       Automatically remove the container when it exits 用完即删

<span class="hljs-meta">#</span><span class="bash">下载 最新版</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull tomcat

<span class="hljs-meta">#</span><span class="bash">查看下载的镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images

<span class="hljs-meta">#</span><span class="bash">以后台方式，暴露端口方式，启动运行</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 --name tomcat01 tomcat

<span class="hljs-meta">#</span><span class="bash">测试访问有没有问题</span>
curl localhost:8080

<span class="hljs-meta">#</span><span class="bash">根据容器id进入tomcat容器</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 645596565d3f /bin/bash
root@645596565d3f:/usr/local/tomcat# 
<span class="hljs-meta">#</span><span class="bash">查看tomcat容器内部内容：</span>
root@645596565d3f:/usr/local/tomcat# ls -l
total 152
-rw-r--r-- 1 root root 18982 May  5 20:40 BUILDING.txt
-rw-r--r-- 1 root root  5409 May  5 20:40 CONTRIBUTING.md
-rw-r--r-- 1 root root 57092 May  5 20:40 LICENSE
-rw-r--r-- 1 root root  2333 May  5 20:40 NOTICE
-rw-r--r-- 1 root root  3255 May  5 20:40 README.md
-rw-r--r-- 1 root root  6898 May  5 20:40 RELEASE-NOTES
-rw-r--r-- 1 root root 16262 May  5 20:40 RUNNING.txt
drwxr-xr-x 2 root root  4096 May 16 12:05 bin
drwxr-xr-x 1 root root  4096 May 21 11:04 conf
drwxr-xr-x 2 root root  4096 May 16 12:05 lib
drwxrwxrwx 1 root root  4096 May 21 11:04 logs
drwxr-xr-x 2 root root  4096 May 16 12:05 native-jni-lib
drwxrwxrwx 2 root root  4096 May 16 12:05 temp
drwxr-xr-x 2 root root  4096 May 16 12:05 webapps
drwxr-xr-x 7 root root  4096 May  5 20:37 webapps.dist
drwxrwxrwx 2 root root  4096 May  5 20:36 work
root@645596565d3f:/usr/local/tomcat# 
<span class="hljs-meta">#</span><span class="bash">进入webapps目录</span>
root@645596565d3f:/usr/local/tomcat# cd webapps
root@645596565d3f:/usr/local/tomcat/webapps# ls
root@645596565d3f:/usr/local/tomcat/webapps# 
<span class="hljs-meta">#</span><span class="bash"> 发现问题：1、linux命令少了。 2.webapps目录为空</span> 
<span class="hljs-meta">#</span><span class="bash"> 原因：阿里云镜像的原因，阿里云默认是最小的镜像，所以不必要的都剔除掉</span>
<span class="hljs-meta">#</span><span class="bash"> 保证最小可运行的环境！</span>
<span class="hljs-meta">#</span><span class="bash"> 解决方案：</span>
<span class="hljs-meta">#</span><span class="bash"> 将webapps.dist下的文件都拷贝到webapps下即可</span>
root@645596565d3f:/usr/local/tomcat# ls 找到webapps.dist
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs  temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin   lib   native-jni-lib  webapps  work

root@645596565d3f:/usr/local/tomcat# cd webapps.dist/ # 进入webapps.dist 
root@645596565d3f:/usr/local/tomcat/webapps.dist# ls # 查看内容
ROOT  docs  examples  host-manager  manager

root@645596565d3f:/usr/local/tomcat/webapps.dist# cd ..
root@645596565d3f:/usr/local/tomcat# cp -r webapps.dist/* webapps # 拷贝webapps.dist 内容给webapps
root@645596565d3f:/usr/local/tomcat# cd webapps #进入webapps
root@645596565d3f:/usr/local/tomcat/webapps# ls #查看拷贝结果
ROOT  docs  examples  host-manager  manager</code></pre></div>

<p>这样docker部署tomcat就可以访问了</p>
<p><strong>问题</strong>:我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？要是可以在容器外部提供一个映射路径，比如webapps，我们在外部放置项目，就自动同步内部就好了！</p>
<h3 id="4-3-部署elasticsearch-kibana"><a href="#4-3-部署elasticsearch-kibana" class="headerlink" title="4.3 部署elasticsearch+kibana"></a>4.3 部署elasticsearch+kibana</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> es 暴露的端口很多！</span>
<span class="hljs-meta">#</span><span class="bash"> es 十分耗内存</span>
<span class="hljs-meta">#</span><span class="bash"> es 的数据一般需要放置到安全目录！挂载</span>
<span class="hljs-meta">#</span><span class="bash"> --net somenetwork ? 网络配置</span>

<span class="hljs-meta">#</span><span class="bash"> 启动elasticsearch</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2

<span class="hljs-meta">#</span><span class="bash"> 测试一下es是否成功启动</span>
➜  ~ curl localhost:9200
&#123;
  &quot;name&quot; : &quot;d73ad2f22dd3&quot;,
  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,
  &quot;cluster_uuid&quot; : &quot;atFKgANxS8CzgIyCB8PGxA&quot;,
  &quot;version&quot; : &#123;
    &quot;number&quot; : &quot;7.6.2&quot;,
    &quot;build_flavor&quot; : &quot;default&quot;,
    &quot;build_type&quot; : &quot;docker&quot;,
    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,
    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;8.4.0&quot;,
    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,
    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;
  &#125;,
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
&#125;

<span class="hljs-meta">#</span><span class="bash">测试成功就关掉elasticSearch，防止耗内存</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop d834ce2bd306
d834ce2bd306

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stats  # 查看docker容器使用内存情况

<span class="hljs-meta">#</span><span class="bash"> 限制最大内存</span>
docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;Xms2m -Xmx512m&quot; elasticsearch:7.6.2
</code></pre></div>

<h3 id="4-4-Portainer-可视化面板安装"><a href="#4-4-Portainer-可视化面板安装" class="headerlink" title="4.4 Portainer 可视化面板安装"></a>4.4 Portainer 可视化面板安装</h3><ul>
<li><p>portainer(先用这个)</p>
<div class="code-wrapper"><pre><code class="hljs shell">docker run -d -p 8080:9000 \
--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre></div>
</li>
<li><p>Rancher(CI/CD再用)<br><strong>什么是portainer？</strong></p>
<p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装命令</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:9000 \
<span class="hljs-meta">&gt;</span><span class="bash"> --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="hljs-literal">true</span> portainer/portainer</span>

Unable to find image &#x27;portainer/portainer:latest&#x27; locally
latest: Pulling from portainer/portainer
d1e017099d17: Pull complete 
a7dca5b5a9e8: Pull complete 
Digest: sha256:4ae7f14330b56ffc8728e63d355bc4bc7381417fa45ba0597e5dd32682901080
Status: Downloaded newer image for portainer/portainer:latest
81753869c4fd438cec0e31659cbed0d112ad22bbcfcb9605483b126ee8ff306d</code></pre></div>

<p>测试访问： 外网：8080 ：<a href="http://123.56.247.59:8080/">http://123.56.247.59:8080/</a></p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE1NTAwNjA3OS5wbmc" alt></p>
<p>进入之后的面板</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210526004802841.png" alt></p>
</li>
</ul>
<h2 id="5-Docker-镜像讲解"><a href="#5-Docker-镜像讲解" class="headerlink" title="5 Docker 镜像讲解"></a>5 Docker 镜像讲解</h2><h3 id="5-1-镜像原理之联合文件系统"><a href="#5-1-镜像原理之联合文件系统" class="headerlink" title="5.1  镜像原理之联合文件系统"></a>5.1  镜像原理之联合文件系统</h3><h4 id="5-1-1-镜像是什么"><a href="#5-1-1-镜像是什么" class="headerlink" title="5.1.1 镜像是什么"></a>5.1.1 镜像是什么</h4><ul>
<li><p>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p>
</li>
<li><p>所有应用，直接打包docker镜像，就可以直接跑起来！</p>
</li>
</ul>
<h4 id="5-1-2-如何得到镜像"><a href="#5-1-2-如何得到镜像" class="headerlink" title="5.1.2 如何得到镜像"></a>5.1.2 如何得到镜像</h4><ul>
<li>从远程仓库下载</li>
<li>别人拷贝给你</li>
<li>自己制作一个镜像 DockerFile</li>
</ul>
<h3 id="5-2-Docker镜像加载原理"><a href="#5-2-Docker镜像加载原理" class="headerlink" title="5.2 Docker镜像加载原理"></a>5.2 Docker镜像加载原理</h3><blockquote>
<p>  UnionFs （联合文件系统）</p>
</blockquote>
<ul>
<li>UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像</li>
<li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</li>
</ul>
<blockquote>
<p>  Docker镜像加载原理</p>
</blockquote>
<ul>
<li>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</li>
<li>boots(boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。</li>
<li>rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。</li>
</ul>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzA0OTk1OS5wbmc" alt></p>
<ul>
<li>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</li>
</ul>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzE0MDU1OS5wbmc" alt></p>
<ul>
<li>对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs.</li>
</ul>
<ul>
<li>虚拟机是分钟级别，容器是秒级！</li>
</ul>
<h3 id="5-3-分层理解"><a href="#5-3-分层理解" class="headerlink" title="5.3 分层理解"></a>5.3 分层理解</h3><blockquote>
<p>  分层的镜像</p>
</blockquote>
<ul>
<li><p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzgzOTE4MC5wbmc" alt="img"></p>
</li>
</ul>
<p>思考：为什么Docker镜像要采用这种分层的结构呢？</p>
<ul>
<li>最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</li>
</ul>
<ul>
<li><p>查看镜像分层的方式可以通过docker image inspect 命令。</p>
<div class="code-wrapper"><pre><code class="hljs shell">➜  / docker image inspect redis          
[
    &#123;
        &quot;Id&quot;: &quot;sha256:f9b9909726890b00d2098081642edf32e5211b7ab53563929a47f250bcdc1d7c&quot;,
        &quot;RepoTags&quot;: [
            &quot;redis:latest&quot;
        ],
        &quot;RepoDigests&quot;: [
            &quot;redis@sha256:399a9b17b8522e24fbe2fd3b42474d4bb668d3994153c4b5d38c3dafd5903e32&quot;
        ],
        &quot;Parent&quot;: &quot;&quot;,
        &quot;Comment&quot;: &quot;&quot;,
        &quot;Created&quot;: &quot;2020-05-02T01:40:19.112130797Z&quot;,
        &quot;Container&quot;: &quot;d30c0bcea88561bc5139821227d2199bb027eeba9083f90c701891b4affce3bc&quot;,
        &quot;ContainerConfig&quot;: &#123;
            &quot;Hostname&quot;: &quot;d30c0bcea885&quot;,
            &quot;Domainname&quot;: &quot;&quot;,
            &quot;User&quot;: &quot;&quot;,
            &quot;AttachStdin&quot;: false,
            &quot;AttachStdout&quot;: false,
            &quot;AttachStderr&quot;: false,
            &quot;ExposedPorts&quot;: &#123;
                &quot;6379/tcp&quot;: &#123;&#125;
            &#125;,
            &quot;Tty&quot;: false,
            &quot;OpenStdin&quot;: false,
            &quot;StdinOnce&quot;: false,
            &quot;Env&quot;: [
                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,
                &quot;GOSU_VERSION=1.12&quot;,
                &quot;REDIS_VERSION=6.0.1&quot;,
                ]
 .......</code></pre></div>
</li>
<li><p><strong>理解：</strong></p>
<ul>
<li><p>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p>
</li>
<li><p>举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，<br>就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含3个镜像层，如下图所示</p>
</li>
<li><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合.</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTIzNDI3NC5wbmc" alt></p>
</li>
<li><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NDk1ODkzMi5wbmc" alt></p>
</li>
<li><p>上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件</p>
</li>
<li><p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版。</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTE0ODAwMi5wbmc" alt></p>
</li>
<li><p>在这种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中</p>
</li>
<li><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统</p>
</li>
<li><p>Linux上可用的存储引擎有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的<br>件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。</p>
</li>
<li><p>Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW 。</p>
</li>
<li><p>下图展示了与系统显示相同的三层镜像。所有镜像层堆并合井，对外提供统一的视图。</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTU1NzgwNy5wbmc" alt></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>  特点</p>
</blockquote>
<ul>
<li><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！</p>
</li>
<li><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MTUwNTg5Ny5wbmc" alt></p>
</li>
</ul>
<blockquote>
<p>  commit镜像</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs routeros">docker commit 提交容器成为一个新的副本

<span class="hljs-comment"># 命令和git原理类似</span>
docker commit <span class="hljs-attribute">-m</span>=<span class="hljs-string">&quot;描述信息&quot;</span> <span class="hljs-attribute">-a</span>=<span class="hljs-string">&quot;作者&quot;</span> 容器id 目标镜像名:[版本TAG]</code></pre></div>

<p>实战测试</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、启动一个默认的tomcat</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 tomcat
de57d0ace5716d27d0e3a7341503d07ed4695ffc266aef78e0a855b270c4064e

<span class="hljs-meta">#</span><span class="bash"> 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！</span>
<span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> -it 容器id /bin/bash</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it de57d0ace571 /bin/bash
root@de57d0ace571:/usr/local/tomcat# 

<span class="hljs-meta">#</span><span class="bash"> 3、从webapps.dist拷贝文件进去webapp</span>
root@de57d0ace571:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@de57d0ace571:/usr/local/tomcat# cd webapps
root@de57d0ace571:/usr/local/tomcat/webapps# ls
ROOT  docs  examples  host-manager  manager

<span class="hljs-meta">#</span><span class="bash"> 4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，而不需要每次都重新拷贝webapps.dist下的文件到webapps了，这就是我们自己的一个修改的镜像。</span>
docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]
docker commit -a=&quot;pncalbl&quot; -m=&quot;add webapps app&quot; 6c5381bbe865 tomcat02:1.0

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker commit -a=&quot;csp提交的&quot; -m=&quot;add webapps app&quot; de57d0ace571 tomcat02.1.0
sha256:d5f28a0bb0d0b6522fdcb56f100d11298377b2b7c51b9a9e621379b01cf1487e

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
tomcat02.1.0          latest              d5f28a0bb0d0        14 seconds ago      652MB
tomcat                latest              1b6b1fe7261e        5 days ago          647MB
nginx                 latest              9beeba249f3e        5 days ago          127MB
mysql                 5.7                 b84d68d0a7db        5 days ago          448MB
elasticsearch         7.6.2               f29a1ee41030        8 weeks ago         791MB
portainer/portainer   latest              2869fc110bf7        2 months ago        78.6MB
centos                latest              470671670cac        4 months ago        237MB
hello-world           latest              bf756fb1ae65        4 months ago        13.3kB</code></pre></div>

<h2 id="5-容器数据卷"><a href="#5-容器数据卷" class="headerlink" title="5 容器数据卷"></a>5 容器数据卷</h2><h3 id="5-1-什么是容器数据卷"><a href="#5-1-什么是容器数据卷" class="headerlink" title="5.1 什么是容器数据卷"></a>5.1 什么是容器数据卷</h3><p>将应用和环境打包成一个镜像！</p>
<p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p>
<p>MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！</p>
<p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p>
<p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEwNTI1ODQ1Ni5wbmc" alt></p>
<p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p>
<h3 id="5-2-使用数据卷"><a href="#5-2-使用数据卷" class="headerlink" title="5.2 使用数据卷"></a>5.2 使用数据卷</h3><blockquote>
<p>  方式一 ：直接使用命令挂载 -v</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs shell">-v, --volume list                    Bind mount a volume

docker run -it -v 主机目录:容器内目录  -p 主机端口:容器内端口
<span class="hljs-meta">#</span><span class="bash"> /home/ceshi：主机home目录下的ceshi文件夹  映射：centos容器中的/home</span>
[root@iz2zeak7 home]# docker run -it -v /home/ceshi:/home centos /bin/bash
<span class="hljs-meta">#</span><span class="bash">这时候主机的/home/ceshi文件夹就和容器的/home文件夹关联了,二者可以实现文件或数据同步了</span>

<span class="hljs-meta">#</span><span class="bash">通过 docker inspect 容器id 查看</span>
[root@iz2zeak7sgj6i7hrb2g862z home]# docker inspect 6064c490c371</code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601210704586.png" alt></p>
<p>测试文件的同步</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601210829068.png" alt="image-20210601210829068"></p>
<p>再来测试！</p>
<p>1、停止容器</p>
<p>2、宿主机修改文件</p>
<p>3、启动容器</p>
<p>4、容器内的数据依旧是同步的</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMDg1MDQzMS5wbmc" alt></p>
<p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p>
<h3 id="5-3-实战：安装MySQL"><a href="#5-3-实战：安装MySQL" class="headerlink" title="5.3 实战：安装MySQL"></a>5.3 实战：安装MySQL</h3><p><strong>思考：MySQL的数据持久化的问题</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 获取mysql镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z home]# docker pull mysql:5.7

<span class="hljs-meta">#</span><span class="bash"> 运行容器,需要做数据挂载 <span class="hljs-comment">#安装启动mysql，需要配置密码的，这是要注意点！</span></span>
<span class="hljs-meta">#</span><span class="bash"> 参考官网hub</span> 
docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag

<span class="hljs-meta">#</span><span class="bash">启动我们得</span>
-d 后台运行
-p 端口映射
-v 卷挂载
-e 环境配置
-- name 容器名字

docker run -p 3306:3306 --name docker-mysql
-v /usr/local/workspace/docker/mysql/conf:/etc/mysql
-v /usr/local/workspace/docker/mysql/data:/var/lib/mysql
-e MYSQL_ROOT_PASSWORD=12345678 -d mysql:5.6

<span class="hljs-meta">#</span><span class="bash"> 启动成功之后，我们在本地使用sqlyog来测试一下</span>
<span class="hljs-meta">#</span><span class="bash"> sqlyog-连接到服务器的3306--和容器内的3306映射</span> 

<span class="hljs-meta">#</span><span class="bash"> 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！</span></code></pre></div>

<p><strong>测试连接</strong>：注意3310端口要在阿里云服务器的安全组中打开，否则无法连接。</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601212226538.png" alt></p>
<p>当我们在本地用Navicat新建名称为test的数据库时候，容器容器也会创建</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601212456348.png" alt="image-20210601212456348"></p>
<p>假设我们将包含mysql的容器删除时，</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMjUzMjk1MC5wbmc" alt></p>
<p>发现，<strong>我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能</strong>。</p>
<h3 id="5-4-具名和匿名挂载"><a href="#5-4-具名和匿名挂载" class="headerlink" title="5.4 具名和匿名挂载"></a>5.4 具名和匿名挂载</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 匿名挂载</span>
-v 容器内路径!
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx01 -v /etc/nginx nginx</span>

<span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span>
<span class="hljs-meta">$</span><span class="bash"> docker volume ls</span>    
DRIVER              VOLUME NAME # 容器内的卷名(匿名卷挂载)
local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0
local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c
         
<span class="hljs-meta">#</span><span class="bash"> 这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路径！</span>

<span class="hljs-meta">#</span><span class="bash"> 具名挂载 -P:表示随机映射端口</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span>
9663cfcb1e5a9a1548867481bfddab9fd7824a6dc4c778bf438a040fe891f0ee

<span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span>
<span class="hljs-meta">$</span><span class="bash"> docker volume ls</span>                  
DRIVER              VOLUME NAME
local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0
local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c
local               juming-nginx #多了一个名字


<span class="hljs-meta">#</span><span class="bash"> 通过 -v 卷名：查看容器内路径</span>
<span class="hljs-meta">#</span><span class="bash"> 查看一下这个卷</span>
<span class="hljs-meta">$</span><span class="bash"> docker volume inspect juming-nginx</span>
[
    &#123;
        &quot;CreatedAt&quot;: &quot;2020-05-23T13:55:34+08:00&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: null,
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;, #默认目录
        &quot;Name&quot;: &quot;juming-nginx&quot;,
        &quot;Options&quot;: null,
        &quot;Scope&quot;: &quot;local&quot;
    &#125;
]</code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMzU0NTc0Ni5wbmc" alt></p>
<p>所有的docker容器内的卷，没有指定目录的情况下都是在<strong>/var/lib/docker/volumes/自定义的卷名/_data</strong>下，<strong>如果指定了目录，docker volume ls 是查看不到的</strong>。</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExNDIzMTQzNS5wbmc" alt></p>
<p><strong>区分三种挂载方式</strong></p>
<div class="code-wrapper"><pre><code class="hljs haml"># 三种挂载： 匿名挂载、具名挂载、指定路径挂载
-<span class="ruby">v 容器内路径			<span class="hljs-comment">#匿名挂载</span></span>
<span class="ruby">-v 卷名：容器内路径		  <span class="hljs-comment">#具名挂载</span></span>
<span class="ruby">-v /宿主机路径：容器内路径 <span class="hljs-comment">#指定路径挂载 docker volume ls 是查看不到的</span></span></code></pre></div>

<p>拓展：</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过 -v 容器内路径： ro rw 改变读写权限</span>
ro #readonly 只读
rw #readwrite 可读可写
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span>

<span class="hljs-meta">#</span><span class="bash"> ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</span></code></pre></div>

<h2 id="6-DockerFile"><a href="#6-DockerFile" class="headerlink" title="6 DockerFile"></a>6 DockerFile</h2><h3 id="6-1-初始Dockerfile"><a href="#6-1-初始Dockerfile" class="headerlink" title="6.1 初始Dockerfile"></a>6.1 初始Dockerfile</h3><p><strong>Dockerfile 就是用来构建docker镜像的构建文件</strong>！命令脚本！先体验一下！</p>
<p>通过这个<strong>脚本可以生成镜像</strong>，镜像是一层一层的，脚本是一个个的命令，每个命令都是一层！</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建一个dockerfile文件，名字可以随便 建议Dockerfile</span>
<span class="hljs-meta">#</span><span class="bash"> 文件中的内容： 指令(大写) + 参数</span>
<span class="hljs-meta">$</span><span class="bash"> vim dockerfile1</span>
    FROM centos 					# 当前这个镜像是以centos为基础的

    VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] 	# 挂载卷的卷目录列表(多个目录)

    CMD echo &quot;-----end-----&quot;		# 输出一下用于测试
    CMD /bin/bash					# 默认走bash控制台

<span class="hljs-meta">#</span><span class="bash"> 这里的每个命令，就是镜像的一层！</span>
<span class="hljs-meta">#</span><span class="bash"> 构建出这个镜像</span> 
-f dockerfile1 			# f代表file，指这个当前文件的地址(这里是当前目录下的dockerfile1)
-t caoshipeng/centos 	# t就代表target，指目标目录(注意caoshipeng镜像名前不能加斜杠‘/’)
. 						# 表示生成在当前目录下
<span class="hljs-meta">$</span><span class="bash"> docker build -f dockerfile1 -t caoshipeng/centos .</span>
Sending build context to Docker daemon   2.56kB
Step 1/4 : FROM centos
latest: Pulling from library/centos
8a29a15cefae: Already exists 
Digest: sha256:fe8d824220415eed5477b63addf40fb06c3b049404242b31982106ac204f6700
Status: Downloaded newer image for centos:latest
<span class="hljs-meta"> ---&gt;</span><span class="bash"> 470671670cac</span>
Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] 			# 卷名列表
<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> c18eefc2c233</span>
Removing intermediate container c18eefc2c233
<span class="hljs-meta"> ---&gt;</span><span class="bash"> 623ae1d40fb8</span>
Step 3/4 : CMD echo &quot;-----end-----&quot;					# 输出 脚本命令
<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 70e403669f3c</span>
Removing intermediate container 70e403669f3c
<span class="hljs-meta"> ---&gt;</span><span class="bash"> 0eba1989c4e6</span>
Step 4/4 : CMD /bin/bash
<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 4342feb3a05b</span>
Removing intermediate container 4342feb3a05b
<span class="hljs-meta"> ---&gt;</span><span class="bash"> f4a6b0d4d948</span>
Successfully built f4a6b0d4d948
Successfully tagged caoshipeng/centos:latest

<span class="hljs-meta">#</span><span class="bash"> 查看自己构建的镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker images</span>
REPOSITORY          TAG          IMAGE ID            CREATED              SIZE
caoshipeng/centos   latest       f4a6b0d4d948        About a minute ago   237MB</code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203148651.png" alt></p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203222615.png" alt></p>
<p><strong>启动自己写的容器镜像</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -it f4a6b0d4d948 /bin/bash	<span class="hljs-comment"># 运行自己写的镜像</span></span>
<span class="hljs-meta">$</span><span class="bash"> ls -l 								<span class="hljs-comment"># 查看目录</span></span></code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTQ1OTAyNi5wbmc" alt></p>
<p>这个卷和外部一定有一个同步的目录</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTUzMTYyNi5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker inspect 容器id</span>
<span class="hljs-meta">$</span><span class="bash"> docker inspect ca3b45913df5</span></code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTYzMDI5NS5wbmc" alt></p>
<p>测试一下刚才的文件是否同步出去了！</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203814945.png" alt></p>
<p>这种方式使用的十分多，因为我们通常会构建自己的镜像！</p>
<p>假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名：容器内路径！</p>
<h3 id="6-2-数据卷容器"><a href="#6-2-数据卷容器" class="headerlink" title="6.2 数据卷容器"></a>6.2 数据卷容器</h3><h4 id="1-多个MySQL同步数据"><a href="#1-多个MySQL同步数据" class="headerlink" title="1 多个MySQL同步数据"></a>1 多个MySQL同步数据</h4><p>命名的容器挂载数据卷！</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154518325.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># 测试 启动3个容器，通过刚才自己写的镜像启动</span>
<span class="hljs-comment"># 创建docker01：因为我本机是最新版，故这里用latest，狂神老师用的是1.0如下图</span>
$ docker run -it --name docker01 pnca/centos:latest

<span class="hljs-comment"># 查看容器docekr01内容</span>
$ ls
bin  home   lost+found	opt   run   sys  var
dev  lib    media	<span class="hljs-keyword">proc</span><span class="hljs-title">  sbin</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> volume01</span>
<span class="hljs-title">etc</span> <span class="hljs-title"> lib64</span> <span class="hljs-title"> mnt</span>	<span class="hljs-title">	root</span> <span class="hljs-title"> srv</span> <span class="hljs-title">  usr</span> <span class="hljs-title"> volume02</span>
<span class="hljs-title"></span>
<span class="hljs-title">#</span> 不关闭该容器退出
CTRL +<span class="hljs-title"> Q</span> +<span class="hljs-title"> P</span>  

# 创建docker02: 并且让docker02 继承<span class="hljs-title"> docker01</span>
<span class="hljs-title">$</span> docker<span class="hljs-title"> run</span> -it --name<span class="hljs-title"> docker02</span> --volumes-from<span class="hljs-title"> docker01</span> pnca/centos:latest

# 查看容器docker02内容
$<span class="hljs-title"> ls</span>
<span class="hljs-title">bin</span> <span class="hljs-title"> home</span> <span class="hljs-title">  lost+found</span>	opt<span class="hljs-title">   run</span> <span class="hljs-title">  sys</span> <span class="hljs-title"> var</span>
<span class="hljs-title">dev</span> <span class="hljs-title"> lib</span> <span class="hljs-title">   media</span>	<span class="hljs-keyword">proc</span><span class="hljs-title">  sbin</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> volume01</span>
<span class="hljs-title">etc</span> <span class="hljs-title"> lib64</span> <span class="hljs-title"> mnt</span>	<span class="hljs-title">	root</span> <span class="hljs-title"> srv</span> <span class="hljs-title">  usr</span> <span class="hljs-title"> volume02</span></code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMzAyMDA1MC5wbmc" alt></p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154539606.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 再新建一个docker03同样继承docker01</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -it --name docker03 --volumes-from docker01 caoshipeng/centos:latest</span>
<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> volume01	<span class="hljs-comment">#进入volume01 查看是否也同步docker01的数据</span></span>
<span class="hljs-meta">$</span><span class="bash"> ls</span> 
docker01.txt

<span class="hljs-meta">#</span><span class="bash"> 测试：可以删除docker01，查看一下docker02和docker03是否可以访问这个文件</span>
<span class="hljs-meta">#</span><span class="bash"> 测试发现：数据依旧保留在docker02和docker03中没有被删除</span></code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMzM1NTAzNC5wbmc" alt></p>
<h4 id="2-多个mysql实现数据共享"><a href="#2-多个mysql实现数据共享" class="headerlink" title="2 多个mysql实现数据共享"></a>2 多个mysql实现数据共享</h4><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span>

<span class="hljs-meta">$</span><span class="bash"> docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01  mysql:5.7</span>

<span class="hljs-meta">#</span><span class="bash"> 这个时候，可以实现两个容器数据同步！</span></code></pre></div>

<p>结论：</p>
<p><strong>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止</strong>。</p>
<p><strong>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的</strong>！</p>
<h3 id="6-3-DockerFile-具体使用"><a href="#6-3-DockerFile-具体使用" class="headerlink" title="6.3 DockerFile 具体使用"></a>6.3 DockerFile 具体使用</h3><h4 id="1-DockerFile介绍"><a href="#1-DockerFile介绍" class="headerlink" title="1 DockerFile介绍"></a>1 DockerFile介绍</h4><p>dockerfile是用来构建docker镜像的文件！命令参数脚本！</p>
<p>构建步骤：</p>
<ol>
<li>编写一个dockerfile文件</li>
<li>docker build 构建称为一个镜像</li>
<li>docker run运行镜像</li>
<li>docker push发布镜像（DockerHub 、阿里云仓库)</li>
</ol>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205738956.png" alt></p>
<p>点击后跳到一个Dockerfile</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205655544.png" alt></p>
<p>很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！</p>
<p>官方既然可以制作镜像，那我们也可以！</p>
<h4 id="2-DockerFile-构建过程"><a href="#2-DockerFile-构建过程" class="headerlink" title="2 DockerFile 构建过程"></a>2 DockerFile 构建过程</h4><p><strong>基础知识</strong>：</p>
<ol>
<li>每个保留关键字(指令）都是必须是大写字母</li>
<li>执行从上到下顺序</li>
<li>#表示注释</li>
<li>每一个指令都会创建提交一个新的镜像层，并提交！</li>
</ol>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEzMTc1Njk5Ny5wbmc" alt></p>
<ul>
<li>Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</li>
</ul>
<ul>
<li>Docker镜像逐渐成企业交付的标准，必须要掌握！</li>
</ul>
<ul>
<li>DockerFile：构建文件，定义了一切的步骤，源代码</li>
</ul>
<ul>
<li>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。</li>
</ul>
<ul>
<li>Docker容器：容器就是镜像运行起来提供服务。</li>
</ul>
<h4 id="3-DockerFile的指令"><a href="#3-DockerFile的指令" class="headerlink" title="3 DockerFile的指令"></a>3 DockerFile的指令</h4><div class="code-wrapper"><pre><code class="hljs shell">FROM				# from:基础镜像，一切从这里开始构建
MAINTAINER			# maintainer:镜像是谁写的， 姓名+邮箱
RUN					# run:镜像构建的时候需要运行的命令
ADD					# add:步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录
WORKDIR				# workdir:镜像的工作目录
VOLUME				# volume:挂载的目录
EXPOSE				# expose:保留端口配置
CMD					# cmd:指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代
ENTRYPOINT			# entrypoint:指定这个容器启动的时候要运行的命令，可以追加命令
ONBUILD				# onbuild:当构建一个被继承DockerFile这个时候就会运行onbuild的指令，触发指令
COPY				# copy:类似ADD，将我们文件拷贝到镜像中
ENV					# env:构建的时候设置环境变量！</code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154609624.png" alt></p>
<h4 id="4-实战测试"><a href="#4-实战测试" class="headerlink" title="4 实战测试"></a>4 实战测试</h4><p>scratch镜像</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> scratch
<span class="hljs-keyword">ADD</span><span class="bash"> centos-7-x86_64-docker.tar.xz /</span>

<span class="hljs-keyword">LABEL</span><span class="bash"> \</span>
<span class="bash">    org.label-schema.schema-version=<span class="hljs-string">&quot;1.0&quot;</span> \</span>
<span class="bash">    org.label-schema.name=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \</span>
<span class="bash">    org.label-schema.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \</span>
<span class="bash">    org.label-schema.license=<span class="hljs-string">&quot;GPLv2&quot;</span> \</span>
<span class="bash">    org.label-schema.build-date=<span class="hljs-string">&quot;20201113&quot;</span> \</span>
<span class="bash">    org.opencontainers.image.title=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \</span>
<span class="bash">    org.opencontainers.image.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \</span>
<span class="bash">    org.opencontainers.image.licenses=<span class="hljs-string">&quot;GPL-2.0-only&quot;</span> \</span>
<span class="bash">    org.opencontainers.image.created=<span class="hljs-string">&quot;2020-11-13 00:00:00+00:00&quot;</span></span>

<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>]</span></code></pre></div>

<p><strong>Docker Hub 中 99%的镜像都是从这个基础镜像过来的 FROM scratch</strong>，然后配置需要的软件和配置来进行构建。</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205655544.png" alt></p>
<p>创建一个自己的centos</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1./home下新建dockerfile目录</span>
<span class="hljs-meta">$</span><span class="bash"> mkdir dockerfile</span>

<span class="hljs-meta">#</span><span class="bash"> 2. dockerfile目录下新建mydockerfile-centos文件</span>
<span class="hljs-meta">$</span><span class="bash"> vim mydockerfile-centos</span>

<span class="hljs-meta">#</span><span class="bash"> 3.编写Dockerfile配置文件</span>
FROM centos							# 基础镜像是官方原生的centos
MAINTAINER pncalbl&lt;pncalbl@qq.com&gt; 	# 作者

ENV MYPATH /usr/local				# 配置环境变量的目录 
WORKDIR $MYPATH						# 将工作目录设置为 MYPATH

RUN yum -y install vim				# 给官方原生的centos 增加 vim指令
RUN yum -y install net-tools		# 给官方原生的centos 增加 ifconfig命令

EXPOSE 80							# 暴露端口号为80

CMD echo $MYPATH					# 输出下 MYPATH 路径
CMD echo &quot;-----end----&quot;				
CMD /bin/bash						# 启动后进入 /bin/bash

<span class="hljs-meta">#</span><span class="bash"> 4.通过这个文件构建镜像</span>
<span class="hljs-meta">#</span><span class="bash"> 命令： docker build -f 文件路径 -t 镜像名:[tag] .</span>
<span class="hljs-meta">$</span><span class="bash"> docker build -f mydockerfile-centos -t mycentos:0.1 .</span>

<span class="hljs-meta">#</span><span class="bash"> 5.出现下图后则构建成功</span></code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MDgzMTQ2NC5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker images</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mycentos            0.1                 cbf5110a646d        2 minutes ago       311MB

<span class="hljs-meta">#</span><span class="bash"> 6.测试运行</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -it mycentos:0.1 		<span class="hljs-comment"># 注意带上版本号，否则每次都回去找最新版latest</span></span>

<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">pwd</span></span>	
/usr/local							# 与Dockerfile文件中 WORKDIR 设置的 MYPATH 一致
<span class="hljs-meta">$</span><span class="bash"> vim								<span class="hljs-comment"># vim 指令可以使用</span></span>
<span class="hljs-meta">$</span><span class="bash"> ifconfig     						<span class="hljs-comment"># ifconfig 指令可以使用</span></span>

<span class="hljs-meta">#</span><span class="bash"> docker <span class="hljs-built_in">history</span> 镜像id 查看镜像构建历史步骤</span>
<span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">history</span> 镜像id</span></code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MTYyOTU4My5wbmc" alt></p>
<p>我们可以列出本地进行的变更历史</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MTg0MDcwNi5wbmc" alt></p>
<p>我们平时拿到一个镜像，可以用 “docker history 镜像id” 研究一下是什么做的</p>
<h4 id="5-CMD-和-ENTRYPOINT区别"><a href="#5-CMD-和-ENTRYPOINT区别" class="headerlink" title="5 CMD 和 ENTRYPOINT区别"></a>5 CMD 和 ENTRYPOINT区别</h4><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="bash">					<span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span></span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="bash">			<span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，可以追加命令</span></span></code></pre></div>

<p><strong>测试cmd</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编写dockerfile文件</span>
<span class="hljs-meta">$</span><span class="bash"> vim dockerfile-test-cmd</span>
FROM centos
CMD [&quot;ls&quot;,&quot;-a&quot;]					# 启动后执行 ls -a 命令

<span class="hljs-meta">#</span><span class="bash"> 构建镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker build  -f dockerfile-test-cmd -t cmd-test:0.1 .</span>

<span class="hljs-meta">#</span><span class="bash"> 运行镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker run cmd-test:0.1		<span class="hljs-comment"># 由结果可得，运行后就执行了 ls -a 命令</span></span>
.
..
.dockerenv
bin
dev
etc
home

<span class="hljs-meta">#</span><span class="bash"> 想追加一个命令  -l 成为ls -dockersal：展示列表详细数据</span>
<span class="hljs-meta">$</span><span class="bash"> docker run cmd-tesclet:0.1 -l</span>
docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused &quot;exec: \&quot;-l\&quot;:
executable file not found in $PATH&quot;: unknown.
ERRO[0000] error waiting for container: context canceled 

<span class="hljs-meta">#</span><span class="bash"> cmd的情况下 -l 替换了CMD[<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-l&quot;</span>] 而 -l  不是命令所以报错</span></code></pre></div>

<p><strong>测试ENTRYPOINT</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编写dockerfile文件</span>
<span class="hljs-meta">$</span><span class="bash"> vim dockerfile-test-entrypoint</span>
FROM centos
ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]

<span class="hljs-meta">#</span><span class="bash"> 构建镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker build  -f dockerfile-test-entrypoint -t entrypoint-test:0.1 .</span>

<span class="hljs-meta">#</span><span class="bash"> 运行镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker run entrypoint-test:0.1</span>
.
..
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found ...

<span class="hljs-meta">#</span><span class="bash"> 我们的命令，是直接拼接在我们得ENTRYPOINT命令后面的</span>
<span class="hljs-meta">$</span><span class="bash"> docker run entrypoint-test:0.1 -l</span>
total 56clea
drwxr-xr-x   1 root root 4096 May 16 06:32 .
drwxr-xr-x   1 root root 4096 May 16 06:32 ..
-rwxr-xr-x   1 root root    0 May 16 06:32 .dockerenv
lrwxrwxrwx   1 root root    7 May 11  2019 bin -&gt; usr/bin
drwxr-xr-x   5 root root  340 May 16 06:32 dev
drwxr-xr-x   1 root root 4096 May 16 06:32 etc
drwxr-xr-x   2 root root 4096 May 11  2019 home
lrwxrwxrwx   1 root root    7 May 11  2019 lib -&gt; usr/lib
lrwxrwxrwx   1 root root    9 May 11  2019 lib64 -&gt; usr/lib64 ....</code></pre></div>

<p>Dockerfile中很多命令都十分的相似，我们需要了解它们的区别，我们最好的学习就是对比他们然后测试效果！</p>
<h4 id="6-实战：Tomcat镜像"><a href="#6-实战：Tomcat镜像" class="headerlink" title="6 实战：Tomcat镜像"></a>6 实战：Tomcat镜像</h4><h5 id="6-1-准备镜像文件"><a href="#6-1-准备镜像文件" class="headerlink" title="6.1 准备镜像文件"></a>6.1 准备镜像文件</h5><div class="code-wrapper"><pre><code class="hljs mipsasm">准备tomcat 和 <span class="hljs-keyword">jdk </span>到当前目录，编写好README</code></pre></div>

<h5 id="6-2-编写-dokerfile"><a href="#6-2-编写-dokerfile" class="headerlink" title="6.2 编写 dokerfile"></a>6.2 编写 dokerfile</h5><div class="code-wrapper"><pre><code class="hljs dockerfile">$ vim dockerfile
<span class="hljs-keyword">FROM</span> centos 										<span class="hljs-comment"># 基础镜像centos</span>
<span class="hljs-keyword">MAINTAINER</span> pncalbl&lt;pncalbl@qq.com&gt;					<span class="hljs-comment"># 作者</span>
<span class="hljs-keyword">COPY</span><span class="bash"> README /usr/<span class="hljs-built_in">local</span>/README 						<span class="hljs-comment"># 复制README文件</span></span>
<span class="hljs-keyword">ADD</span><span class="bash"> jdk-8u231-linux-x64.tar.gz /usr/<span class="hljs-built_in">local</span>/ 			<span class="hljs-comment"># 添加jdk，ADD 命令会自动解压</span></span>
<span class="hljs-keyword">ADD</span><span class="bash"> apache-tomcat-9.0.35.tar.gz /usr/<span class="hljs-built_in">local</span>/ 		<span class="hljs-comment"># 添加tomcat，ADD 命令会自动解压</span></span>
<span class="hljs-keyword">RUN</span><span class="bash"> yum -y install vim								<span class="hljs-comment"># 安装 vim 命令</span></span>
<span class="hljs-keyword">ENV</span> MYPATH /usr/local 								<span class="hljs-comment"># 环境变量设置 工作目录</span>
<span class="hljs-keyword">WORKDIR</span><span class="bash"> <span class="hljs-variable">$MYPATH</span></span>

<span class="hljs-keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="hljs-number">8.0</span>_231 				<span class="hljs-comment"># 环境变量： JAVA_HOME环境变量</span>
<span class="hljs-keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar

<span class="hljs-keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">35</span> 	<span class="hljs-comment"># 环境变量： tomcat环境变量</span>
<span class="hljs-keyword">ENV</span> CATALINA_BASH /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">35</span>

<span class="hljs-comment"># 设置环境变量 分隔符是：</span>
<span class="hljs-keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin 	

<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span> 										<span class="hljs-comment"># 设置暴露的端口</span>

<span class="hljs-keyword">CMD</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/<span class="hljs-built_in">local</span>/apache-tomcat-9.0.35/logs/catalina.out 					<span class="hljs-comment"># 设置默认命令</span></span></code></pre></div>

<h5 id="6-3-构建镜像"><a href="#6-3-构建镜像" class="headerlink" title="6.3 构建镜像"></a>6.3 构建镜像</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 因为dockerfile命名使用默认命名 因此不用使用-f 指定文件</span>
<span class="hljs-meta">$</span><span class="bash"> docker build -t mytomcat:0.1 .</span></code></pre></div>

<h5 id="6-4-run镜像"><a href="#6-4-run镜像" class="headerlink" title="6.4 run镜像"></a>6.4 run镜像</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> -d:后台运行 -p:暴露端口 --name:别名 -v:绑定路径</span> 
<span class="hljs-meta">$</span><span class="bash"> docker run -d -p 8080:8080 --name tomcat01</span> 
-v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test 
-v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.35/logs</code></pre></div>

<h5 id="6-5-访问测试"><a href="#6-5-访问测试" class="headerlink" title="6.5 访问测试"></a>6.5 访问测试</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it 自定义容器的id /bin/bash</span>

<span class="hljs-meta">$</span><span class="bash"> cul localhost:8080</span></code></pre></div>

<h5 id="6-6-发布项目"><a href="#6-6-发布项目" class="headerlink" title="6.6 发布项目"></a>6.6 发布项目</h5><p>(由于做了卷挂载，我们直接在本地编写项目就可以发布了！)</p>
<p>发现：项目部署成功，可以直接访问！</p>
<p>我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！</p>
<h4 id="7-发布自己的镜像"><a href="#7-发布自己的镜像" class="headerlink" title="7 发布自己的镜像"></a>7 发布自己的镜像</h4><p><strong>发布到 Docker Hub</strong></p>
<ol>
<li><p>地址 <a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
</li>
<li><p>确定这个账号可以登录</p>
</li>
<li><p>登录</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker login --<span class="hljs-built_in">help</span></span>
Usage:  docker login [OPTIONS] [SERVER]

Log in to a Docker registry.
If no server is specified, the default is defined by the daemon.

Options:
  -p, --password string   Password
      --password-stdin    Take the password from stdin
  -u, --username string   Username

<span class="hljs-meta">$</span><span class="bash"> docker login -u 你的用户名 -p 你的密码</span></code></pre></div>
</li>
<li><p>提交 push镜像</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE2NDQzNDA0Mi5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 会发现push不上去，因为如果没有前缀的话默认是push到 官方的library</span>
<span class="hljs-meta">#</span><span class="bash"> 解决方法：</span>
<span class="hljs-meta">#</span><span class="bash"> 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了</span>
<span class="hljs-meta">$</span><span class="bash"> docker build -t kuangshen/mytomcat:0.1 .</span>

<span class="hljs-meta">#</span><span class="bash"> 第二种 使用docker tag <span class="hljs-comment">#然后再次push</span></span>
<span class="hljs-meta">$</span><span class="bash"> docker tag jid kuangshen/mytomcat:1.0 <span class="hljs-comment">#然后再次push</span></span>
<span class="hljs-meta">$</span><span class="bash"> docker push kuangshen/mytomcat:1.0</span></code></pre></div>

<p><strong>发布到 阿里云镜像服务上</strong></p>
<p>看官网 很详细<a href="https://cr.console.aliyun.com/repository/">https://cr.console.aliyun.com/repository/</a></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo docker login --username=zchengx registry.cn-shenzhen.aliyuncs.com</span>
<span class="hljs-meta">$</span><span class="bash"> sudo docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像版本号]</span>

<span class="hljs-meta">#</span><span class="bash"> 修改id 和 版本</span>
sudo docker tag a5ef1f32aaae registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:1.0
<span class="hljs-meta">#</span><span class="bash"> 修改版本</span>
<span class="hljs-meta">$</span><span class="bash"> sudo docker push registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像版本号]</span></code></pre></div>

</li>
</ol>
<h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8 小结"></a>8 小结</h4><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MTE1NTY2Ny5wbmc" alt></p>
<h2 id="7-Docker-网络原理"><a href="#7-Docker-网络原理" class="headerlink" title="7 Docker 网络原理"></a>7 Docker 网络原理</h2><h3 id="7-1-理解Docker-0"><a href="#7-1-理解Docker-0" class="headerlink" title="7.1 理解Docker 0"></a>7.1 理解Docker 0</h3><p>学习之前<strong>清空下前面的docker 镜像、容器</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除全部容器</span>
<span class="hljs-meta">$</span><span class="bash"> docker rm -f $(docker ps -aq)</span>

<span class="hljs-meta">#</span><span class="bash"> 删除全部镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker rmi -f $(docker images -aq)</span></code></pre></div>

<blockquote>
<p>  测试</p>
</blockquote>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTIyMzIzNjc3Mi5wbmc" alt></p>
<h4 id="1-三个网络"><a href="#1-三个网络" class="headerlink" title="1 三个网络"></a>1 三个网络</h4><blockquote>
<p>  问题： docker 是如果处理容器网络访问的？</p>
</blockquote>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MjA0MTk4NS5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试  运行一个tomcat</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span>

<span class="hljs-meta">#</span><span class="bash"> 查看容器内部网络地址</span>
<span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it 容器id ip addr</span>

<span class="hljs-meta">#</span><span class="bash"> 发现容器启动的时候会得到一个 eth0@if91 ip地址，docker分配！</span>
<span class="hljs-meta">$</span><span class="bash"> ip addr</span>
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
261: eth0@if91: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0
       valid_lft forever preferred_lft forever

       
<span class="hljs-meta">#</span><span class="bash"> 思考？ linux能不能ping通容器内部！ 可以 容器内部可以ping通外界吗？ 可以！</span>
<span class="hljs-meta">$</span><span class="bash"> ping 172.18.0.2</span>
PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.
64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.069 ms
64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.074 ms</code></pre></div>

<blockquote>
<p>  原理</p>
</blockquote>
<ol>
<li><p>我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个docker0桥接模式，使用的技术是veth-pair技术！</p>
<p><a href="https://www.cnblogs.com/bakari/p/10613710.html">https://www.cnblogs.com/bakari/p/10613710.html</a></p>
<p>再次测试 ip addr</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTIyNDAzNjg4My5wbmc" alt></p>
</li>
<li><p>再启动一个容器测试，发现又多了一对网络</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MzI1OTQ1OC5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 我们发现这个容器带来网卡，都是一对对的</span>
<span class="hljs-meta">#</span><span class="bash"> veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连</span>
<span class="hljs-meta">#</span><span class="bash"> 正因为有这个特性 veth-pair 充当一个桥梁，连接各种虚拟网络设备的</span>
<span class="hljs-meta">#</span><span class="bash"> OpenStac, Docker容器之间的连接，OVS的连接，都是使用evth-pair技术</span></code></pre></div>
</li>
<li><p>我们来测试下tomcat01和tomcat02是否可以ping通</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 获取tomcat01的ip 172.17.0.2</span>
<span class="hljs-meta">$</span><span class="bash"> docker-tomcat docker <span class="hljs-built_in">exec</span> -it tomcat01 ip addr</span>  
550: eth0@if551: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
       
<span class="hljs-meta">#</span><span class="bash"> 让tomcat02 ping tomcat01</span>       
<span class="hljs-meta">$</span><span class="bash"> docker-tomcat docker <span class="hljs-built_in">exec</span> -it tomcat02 ping 172.17.0.2</span>
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.098 ms
64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.071 ms

<span class="hljs-meta">#</span><span class="bash"> 结论：容器和容器之间是可以互相ping通</span></code></pre></div>

</li>
</ol>
<h4 id="2-网络模型图"><a href="#2-网络模型图" class="headerlink" title="2 网络模型图"></a>2 网络模型图</h4><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NDI0ODYyNi5wbmc" alt></p>
<p>结论：tomcat01和tomcat02公用一个路由器，docker0。</p>
<p>所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip。</p>
<blockquote>
<p>  小结</p>
</blockquote>
<p>Docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥 docker0</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NDcwMTA2My5wbmc" alt></p>
<p>Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件）</p>
<p>只要容器删除，对应的网桥一对就没了！</p>
<p><strong>思考一个场景：我们编写了一个微服务，database url=ip: 项目不重启，数据ip换了，我们希望可以处理这个问题，可以通过名字来进行访问容器</strong>？</p>
<h3 id="7-2-容器互联-–link"><a href="#7-2-容器互联-–link" class="headerlink" title="7.2  容器互联 –link"></a>7.2  容器互联 –link</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it tomcat02 ping tomca01   <span class="hljs-comment"># ping不通</span></span>
ping: tomca01: Name or service not known

<span class="hljs-meta">#</span><span class="bash"> 运行一个tomcat03 --link tomcat02</span> 
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat03 --link tomcat02 tomcat</span>
5f9331566980a9e92bc54681caaac14e9fc993f14ad13d98534026c08c0a9aef

<span class="hljs-meta">#</span><span class="bash"> 3连接2</span>
<span class="hljs-meta">#</span><span class="bash"> 用tomcat03 ping tomcat02 可以ping通</span>
<span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it tomcat03 ping tomcat02</span>
PING tomcat02 (172.17.0.3) 56(84) bytes of data.
64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.115 ms
64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.080 ms

<span class="hljs-meta">#</span><span class="bash"> 2连接3</span>
<span class="hljs-meta">#</span><span class="bash"> 用tomcat02 ping tomcat03 ping不通</span></code></pre></div>

<p><strong>探究：</strong></p>
<p>docker network inspect 网络id 网段相同</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NTkwNDU1MS5wbmc" alt></p>
<p>docker inspect tomcat03</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE4MDMwODUzMC5wbmc" alt></p>
<p>查看tomcat03里面的/etc/hosts发现有tomcat02的配置</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE4MDYyOTAxMi5wbmc" alt></p>
<p>–link 本质就是在hosts配置中添加映射</p>
<p>现在使用Docker已经不建议使用–link了！</p>
<p>自定义网络，不适用docker0！</p>
<p>docker0问题：不支持容器名连接访问！</p>
<h3 id="7-3-自定义网络"><a href="#7-3-自定义网络" class="headerlink" title="7.3 自定义网络"></a>7.3 自定义网络</h3><div class="code-wrapper"><pre><code class="hljs shell">docker network
connect     -- Connect a container to a network
create      -- Creates a new network with a name specified by the
disconnect  -- Disconnects a container from a network
inspect     -- Displays detailed information on a network
ls          -- Lists all the networks created by the user
prune       -- Remove all unused networks
rm          -- Deletes one or more networks</code></pre></div>

<blockquote>
<p>  查看所有的docker网络</p>
</blockquote>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MDMxNjA3My5wbmc" alt></p>
<p><strong>网络模式</strong></p>
<p>bridge ：桥接 docker（默认，自己创建也是用bridge模式）</p>
<p>none ：不配置网络，一般不用</p>
<p>host ：和所主机共享网络</p>
<p>container ：容器网络连通（用得少！局限很大）</p>
<p>测试</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 我们直接启动的命令 --net bridge,而这个就是我们得docker0</span>
<span class="hljs-meta">#</span><span class="bash"> bridge就是docker0</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span>
等价于 =&gt; docker run -d -P --name tomcat01 --net bridge tomcat

<span class="hljs-meta">#</span><span class="bash"> docker0，特点：默认，域名不能访问。 --link可以打通连接，但是很麻烦！</span>
<span class="hljs-meta">#</span><span class="bash"> 我们可以 自定义一个网络</span>
<span class="hljs-meta">$</span><span class="bash"> docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span></code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTEzOTk0NC5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker network inspect mynet</span></code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTQwNzA2NS5wbmc" alt></p>
<p>启动两个tomcat,再次查看网络情况</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTg0NDI0MC5wbmc" alt></p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MjAwNzM3MS5wbmc" alt></p>
<p>在自定义的网络下，服务可以互相ping通，不用使用 –link</p>
<p>我们自定义的网络docker当我们维护好了对应的关系，推荐我们平时这样使用网络！</p>
<p>好处：</p>
<ul>
<li><p>redis -不同的集群使用不同的网络，保证集群是安全和健康的</p>
</li>
<li><p>mysql-不同的集群使用不同的网络，保证集群是安全和健康的</p>
</li>
</ul>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MjUwNDM2Ny5wbmc" alt></p>
<h3 id="7-4-网络连通"><a href="#7-4-网络连通" class="headerlink" title="7.4 网络连通"></a>7.4 网络连通</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzI0MzE0Ni5wbmc" alt></p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzI1OTE4NS5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试两个不同的网络连通  再启动两个tomcat 使用默认网络，即docker0</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat02 tomcat</span>
<span class="hljs-meta">#</span><span class="bash"> 此时ping不通</span></code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzU1NDkzMS5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 要将tomcat01 连通 tomcat—net-01 ，连通就是将 tomcat01加到 mynet网络</span>
<span class="hljs-meta">#</span><span class="bash"> 一个容器两个ip（tomcat01）</span></code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5Mzg0ODMzNy5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 01连通 ，加入后此时，已经可以tomcat01 和 tomcat-01-net ping通了</span>
<span class="hljs-meta">#</span><span class="bash"> 02是依旧不通的</span></code></pre></div>

<p>结论：假设要跨网络操作别人，就需要使用docker network connect 连通！</p>
<h2 id="8-实战：部署Redis集群"><a href="#8-实战：部署Redis集群" class="headerlink" title="8 实战：部署Redis集群"></a>8 实战：部署Redis集群</h2><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5NDQxOTQ3MS5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建网卡</span>
docker network create redis --subnet 172.38.0.0/16
<span class="hljs-meta">#</span><span class="bash"> 通过脚本创建六个redis配置</span>
for port in $(seq 1 6);\
do \
mkdir -p /mydata/redis/node-$&#123;port&#125;/conf
touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf
cat &lt;&lt; EOF &gt;&gt; /mydata/redis/node-$&#123;port&#125;/conf/redis.conf
port 6379
bind 0.0.0.0
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.38.0.1$&#123;port&#125;
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes
EOF
done

<span class="hljs-meta">#</span><span class="bash"> 通过脚本运行六个redis</span>
for port in $(seq 1 6);\
docker run -p 637$&#123;port&#125;:6379 -p 1667$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \
-v /mydata/redis/node-$&#123;port&#125;/data:/data \
-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

<span class="hljs-meta">#</span><span class="bash"> 单个启动</span>
docker run -p 6376:6379 -p 16376:16379 --name redis-6 \
    -v /mydata/redis/node-6/data:/data \
    -v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \
    -d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
    
<span class="hljs-meta">#</span><span class="bash"> 配置集群</span>
docker exec -it redis-1 /bin/sh #redis默认没有bash
redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379  --cluster-replicas 1
</code></pre></div>

<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjIwMjkwMjI0MS5wbmc" alt></p>
<p>docker搭建redis集群完成！</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjIwMzMyMzk3MS5wbmc" alt></p>
<p>我们使用docker之后，所有的技术都会慢慢变得简单起来！</p>
<h2 id="9-IDEA整合Docker"><a href="#9-IDEA整合Docker" class="headerlink" title="9 IDEA整合Docker"></a>9 IDEA整合Docker</h2><ol>
<li><p>构建SpringBoot项目</p>
</li>
<li><p>打包运行</p>
<div class="code-wrapper"><pre><code class="hljs shell">mvn package</code></pre></div>
</li>
<li><p>编写dockerfile</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span>
<span class="hljs-keyword">COPY</span><span class="bash"> *.jar /app.jar</span>
<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;--server.port=8080&quot;</span>]</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;app.jar&quot;</span>]</span></code></pre></div>
</li>
<li><p>构建镜像</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.复制jar和DockerFIle到服务器</span>
<span class="hljs-meta">#</span><span class="bash"> 2.构建镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker build -t xxxxx:xx  .</span></code></pre></div>
</li>
<li><p>发布运行</p>
<p>以后我们使用了Docker之后，给别人交付就是一个镜像即可！</p>
</li>
</ol>
<h2 id="10-Docker-compose"><a href="#10-Docker-compose" class="headerlink" title="10 Docker compose"></a>10 Docker compose</h2><h3 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173610891.png" alt></p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173621230.png" alt></p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/2020120517363870.png" alt></p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173652461.png" alt></p>
<h3 id="10-2-安装"><a href="#10-2-安装" class="headerlink" title="10.2 安装"></a>10.2 安装</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173738412.png" alt></p>
<ul>
<li><p>下载</p>
<div class="code-wrapper"><pre><code class="hljs shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></pre></div>
</li>
<li><p>授权</p>
<div class="code-wrapper"><pre><code class="hljs shell">sudo chmod +x docker-compose</code></pre></div>
</li>
<li><p>查看版本</p>
<div class="code-wrapper"><pre><code class="hljs shell">docker-compose version</code></pre></div>

</li>
</ul>
<h3 id="10-3-体验"><a href="#10-3-体验" class="headerlink" title="10.3 体验"></a>10.3 体验</h3><p>官方文档：<a href="https://docs.docker.com/compose/gettingstarted/">https://docs.docker.com/compose/gettingstarted/</a></p>
<ol>
<li><p>创建文件夹 composetest</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir composetest</span>
<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> composetest</span></code></pre></div>
</li>
<li><p>创建 app.py</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim app.py</span>

import time

import redis
from flask import Flask

app = Flask(__name__)
cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)

def get_hit_count():
    retries = 5
    while True:
        try:
            return cache.incr(&#x27;hits&#x27;)
        except redis.exceptions.ConnectionError as exc:
            if retries == 0:
                raise exc
            retries -= 1
            time.sleep(0.5)

@app.route(&#x27;/&#x27;)
def hello():
    count = get_hit_count()
    return &#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;.format(count)</code></pre></div>
</li>
<li><p>创建 requirements.txt</p>
<div class="code-wrapper"><pre><code class="hljs txt">$ vim requirements.txt

flask
redis</code></pre></div>
</li>
<li><p>创建 Dockerfile</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">$ vim Dockerfile

<span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>-alpine
<span class="hljs-keyword">RUN</span><span class="bash"> sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories </span>
<span class="hljs-keyword">WORKDIR</span><span class="bash"> /code</span>
<span class="hljs-keyword">ENV</span> FLASK_APP=app.py
<span class="hljs-keyword">ENV</span> FLASK_RUN_HOST=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>
<span class="hljs-keyword">RUN</span><span class="bash"> apk add --no-cache gcc musl-dev linux-headers</span>
<span class="hljs-keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span>
<span class="hljs-keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span>
<span class="hljs-keyword">COPY</span><span class="bash"> . .</span>
<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;flask&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span></code></pre></div>
</li>
<li><p>创建 docker-compose.yml</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim docker-compose.yml</span>

version: &quot;3.8&quot;
services:
  web:
    build: .
    ports:
      - &quot;5000:5000&quot;
  redis:
    image: &quot;redis:alpine&quot;</code></pre></div>
</li>
<li><p>启动</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker-compose build</span>
<span class="hljs-meta">$</span><span class="bash"> docker-compose up</span></code></pre></div>
</li>
<li><p>停止</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161110869.png" alt></p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161121213.png" alt></p>
</li>
<li><p>小结</p>
<p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161135882.png" alt></p>
</li>
</ol>
<h3 id="10-4-yaml-规则"><a href="#10-4-yaml-规则" class="headerlink" title="10.4 yaml 规则"></a>10.4 yaml 规则</h3><p><strong>docker-compose.yaml 核心！</strong><br>官方文档：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<h3 id="10-5-开源项目-博客"><a href="#10-5-开源项目-博客" class="headerlink" title="10.5 开源项目 - 博客"></a>10.5 开源项目 - 博客</h3><h2 id="11-Docker-Swarm"><a href="#11-Docker-Swarm" class="headerlink" title="11 Docker Swarm"></a>11 Docker Swarm</h2><h3 id="11-1-什么是Docker-Swarm"><a href="#11-1-什么是Docker-Swarm" class="headerlink" title="11.1 什么是Docker Swarm"></a>11.1 什么是Docker Swarm</h3><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181018165124850-1417419249.png" alt="img"></p>
<ul>
<li><p>Swarm是Docker公司推出的用来管理docker集群的平台，几乎全部用GO语言来完成的开发的，代码开源在<a href="https://github.com/docker/swarm，">https://github.com/docker/swarm，</a> 它是将一群Docker宿主机变成一个单一的虚拟主机，Swarm使用标准的Docker API接口作为其前端的访问入口，换言之，各种形式的Docker</p>
</li>
<li><p>Client(compose,docker-py等)均可以直接与Swarm通信，甚至Docker本身都可以很容易的与Swarm集成，这大大方便了用户将原本基于单节点的系统移植到Swarm上，同时Swarm内置了对Docker网络插件的支持，用户也很容易的部署跨主机的容器集群服务。</p>
</li>
<li><p>Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。</p>
</li>
<li><p>从 Docker 1.12.0 版本开始，Docker Swarm 已经包含在 Docker 引擎中（docker swarm），并且已经内置了服务发现工具，我们就不需要像之前一样，再配置 Etcd 或者 Consul 来进行服务发现配置了。</p>
</li>
<li><p>Swarm deamon只是一个调度器(Scheduler)加路由器(router),Swarm自己不运行容器，它只是接受Docker客户端发来的请求，调度适合的节点来运行容器，这就意味着，即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，放Swarm重新恢复运行之后，他会收集重建集群信息。</p>
</li>
</ul>
<h3 id="11-2-Docker-Swarm-基本结构图"><a href="#11-2-Docker-Swarm-基本结构图" class="headerlink" title="11.2 Docker Swarm 基本结构图"></a>11.2 Docker Swarm 基本结构图</h3><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181018163339198-1499005562.png" alt="img"></p>
<p>在结构图可以看出 Docker Client使用Swarm对 集群(Cluster)进行调度使用。</p>
<p>上图可以看出，Swarm是典型的master-slave结构，通过发现服务来选举manager。manager是中心管理节点，各个node上运行agent接受manager的统一管理，集群会自动通过Raft协议分布式选举出manager节点，无需额外的发现服务支持，避免了单点的瓶颈问题，同时也内置了DNS的负载均衡和对外部负载均衡机制的集成支持</p>
<h3 id="11-3-Swarm的几个关键概念"><a href="#11-3-Swarm的几个关键概念" class="headerlink" title="11.3 Swarm的几个关键概念"></a>11.3 Swarm的几个关键概念</h3><h4 id="1-Swarm"><a href="#1-Swarm" class="headerlink" title="1 Swarm"></a>1 Swarm</h4><p>集群的管理和编排是使用嵌入docker引擎的SwarmKit，可以在docker初始化时启动swarm模式或者加入已存在的swarm</p>
<h4 id="2-Node"><a href="#2-Node" class="headerlink" title="2 Node"></a>2 Node</h4><ul>
<li>一个节点是docker引擎集群的一个实例。您还可以将其视为Docker节点。您可以在单个物理计算机或云服务器上运行一个或多个节点，但生产群集部署通常包括分布在多个物理和云计算机上的Docker节点。</li>
<li>要将应用程序部署到swarm，请将服务定义提交给 管理器节点。管理器节点将称为任务的工作单元分派 给工作节点。</li>
<li>Manager节点还执行维护所需群集状态所需的编排和集群管理功能。Manager节点选择单个领导者来执行编排任务。</li>
<li>工作节点接收并执行从管理器节点分派的任务。默认情况下，管理器节点还将服务作为工作节点运行，但您可以将它们配置为仅运行管理器任务并且是仅管理器节点。代理程序在每个工作程序节点上运行，并报告分配给它的任务。工作节点向管理器节点通知其分配的任务的当前状态，以便管理器可以维持每个工作者的期望状态。</li>
</ul>
<h4 id="3-Service"><a href="#3-Service" class="headerlink" title="3 Service"></a>3 Service</h4><p>一个服务是任务的定义，管理机或工作节点上执行。它是群体系统的中心结构，是用户与群体交互的主要根源。创建服务时，你需要指定要使用的容器镜像。</p>
<h4 id="4-Task"><a href="#4-Task" class="headerlink" title="4 Task"></a>4 Task</h4><p>任务是在docekr容器中执行的命令，Manager节点根据指定数量的任务副本分配任务给worker节点</p>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>docker swarm：集群管理，子命令有init, join, leave, update。（docker swarm –help查看帮助）<br>docker service：服务创建，子命令有create, inspect, update, remove, tasks。（docker service–help查看帮助）<br>docker node：节点管理，子命令有accept, promote, demote, inspect, update, tasks, ls, rm。（docker node –help查看帮助）</p>
<p>node是加入到swarm集群中的一个docker引擎实体，可以在一台物理机上运行多个node，node分为：<br>manager nodes，也就是管理节点<br>worker nodes，也就是工作节点</p>
<ul>
<li>manager node管理节点：执行集群的管理功能，维护集群的状态，选举一个leader节点去执行调度任务。</li>
<li>worker node工作节点：接收和执行任务。参与容器集群负载调度，仅用于承载task。</li>
<li>service服务：一个服务是工作节点上执行任务的定义。创建一个服务，指定了容器所使用的镜像和容器运行的命令。<ul>
<li>service是运行在worker nodes上的task的描述，service的描述包括使用哪个docker 镜像，以及在使用该镜像的容器中执行什么命令。</li>
</ul>
</li>
<li>task任务：一个任务包含了一个容器及其运行的命令。task是service的执行实体，task启动docker容器并在容器中执行任务。</li>
</ul>
<h3 id="11-4-Swarm的工作模式"><a href="#11-4-Swarm的工作模式" class="headerlink" title="11.4 Swarm的工作模式"></a>11.4 Swarm的工作模式</h3><ol>
<li>Node</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220250190-271703054.png" alt="img"></p>
<ol start="2">
<li>Service</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220303428-146351236.png" alt="img"></p>
<ol start="3">
<li>任务与调度</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220312417-120406041.png" alt="img"></p>
<ol start="4">
<li>服务副本与全局服务</li>
</ol>
<p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220320789-1157117261.png" alt="img"></p>
<h3 id="11-5-Swarm的调度策略"><a href="#11-5-Swarm的调度策略" class="headerlink" title="11.5 Swarm的调度策略"></a>11.5 Swarm的调度策略</h3><p>Swarm在调度(scheduler)节点（leader节点）运行容器的时候，会根据指定的策略来计算最适合运行容器的节点，目前支持的策略有：spread, binpack, random.</p>
<ul>
<li><p>Random<br>顾名思义，就是随机选择一个Node来运行容器，一般用作调试用，spread和binpack策略会根据各个节点的可用的CPU, RAM以及正在运<br>行的容器的数量来计算应该运行容器的节点。</p>
</li>
<li><p>Spread<br>在同等条件下，Spread策略会选择运行容器最少的那台节点来运行新的容器，binpack策略会选择运行容器最集中的那台机器来运行新的节点。<br>使用Spread策略会使得容器会均衡的分布在集群中的各个节点上运行，一旦一个节点挂掉了只会损失少部分的容器。</p>
</li>
<li><p>Binpack<br>Binpack策略最大化的避免容器碎片化，就是说binpack策略尽可能的把还未使用的节点留给需要更大空间的容器运行，尽可能的把容器运行在<br>一个节点上面。</p>
</li>
</ul>
<h3 id="11-6-Swarm-Cluster模式特性"><a href="#11-6-Swarm-Cluster模式特性" class="headerlink" title="11.6 Swarm Cluster模式特性"></a>11.6 Swarm Cluster模式特性</h3><h4 id="1-批量创建服务"><a href="#1-批量创建服务" class="headerlink" title="1 批量创建服务"></a>1 批量创建服务</h4><p>建立容器之前先创建一个overlay的网络，用来保证在不同主机上的容器网络互通的网络模式</p>
<h4 id="2-强大的集群的容错性"><a href="#2-强大的集群的容错性" class="headerlink" title="2 强大的集群的容错性"></a>2 强大的集群的容错性</h4><p>当容器副本中的其中某一个或某几个节点宕机后，cluster会根据自己的服务注册发现机制，以及之前设定的值–replicas n，<br>在集群中剩余的空闲节点上，重新拉起容器副本。整个副本迁移的过程无需人工干预，迁移后原本的集群的load balance依旧好使！<br>不难看出，docker service其实不仅仅是批量启动服务这么简单，而是在集群中定义了一种状态。Cluster会持续检测服务的健康状态<br>并维护集群的高可用性。</p>
<h4 id="3-服务节点的可扩展性"><a href="#3-服务节点的可扩展性" class="headerlink" title="3 服务节点的可扩展性"></a>3 服务节点的可扩展性</h4><p>Swarm Cluster不光只是提供了优秀的高可用性，同时也提供了节点弹性扩展或缩减的功能。当容器组想动态扩展时，只需通过scale<br>参数即可复制出新的副本出来。</p>
<ul>
<li><p>仔细观察的话，可以发现所有扩展出来的容器副本都run在原先的节点下面，如果有需求想在每台节点上都run一个相同的副本，方法<br>其实很简单，只需要在命令中将”–replicas n”更换成”–mode=global”即可！</p>
</li>
<li><p>复制服务（–replicas n）<br>将一系列复制任务分发至各节点当中，具体取决于您所需要的设置状态，例如“–replicas 3”。</p>
</li>
<li><p>全局服务（–mode=global）<br>适用于集群内全部可用节点上的服务任务，例如“–mode global”。如果大家在 Swarm 集群中设有 7 台 Docker 节点，则全部节点之上都将存在对应容器。</p>
</li>
</ul>
<h4 id="4-调度机制"><a href="#4-调度机制" class="headerlink" title="4 调度机制"></a>4 调度机制</h4><p>所谓的调度其主要功能是cluster的server端去选择在哪个服务器节点上创建并启动一个容器实例的动作。它是由一个装箱算法和过滤器<br>组合而成。每次通过过滤器（constraint）启动容器的时候，swarm cluster 都会调用调度机制筛选出匹配约束条件的服务器，并在这上面运行容器。</p>
<h4 id="5-Swarm-cluster的创建过程包含以下三个步骤"><a href="#5-Swarm-cluster的创建过程包含以下三个步骤" class="headerlink" title="5 Swarm cluster的创建过程包含以下三个步骤-"></a>5 Swarm cluster的创建过程包含以下三个步骤-</h4><ul>
<li>发现Docker集群中的各个节点，收集节点状态、角色信息，并监视节点状态的变化</li>
<li>初始化内部调度（scheduler）模块</li>
<li>创建并启动API监听服务模块</li>
</ul>
<p>一旦创建好这个cluster，就可以用命令docker service批量对集群内的容器进行操作，非常方便！</p>
<p>在启动容器后，docker 会根据当前每个swarm节点的负载判断，在负载最优的节点运行这个task任务，用”docker service ls” 和”docker service ps + taskID”<br>可以看到任务运行在哪个节点上。容器启动后，有时需要等待一段时间才能完成容器创建。</p>
<h2 id="11-CI-CD-Jenkins"><a href="#11-CI-CD-Jenkins" class="headerlink" title="11 CI\CD Jenkins"></a>11 CI\CD Jenkins</h2>]]></content>
      <categories>
        <category>Technical</category>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC 学习</title>
    <url>/2020/11/22/JUCStudy/</url>
    <content><![CDATA[<h1 id="JUC-学习"><a href="#JUC-学习" class="headerlink" title="JUC 学习"></a>JUC 学习</h1><h2 id="1-什么是-JUC"><a href="#1-什么是-JUC" class="headerlink" title="1 什么是 JUC ?"></a>1 什么是 JUC ?</h2><p><img src="/2020/11/22/JUCStudy/image-20210517153831370.png" alt></p>
<ul>
<li>java.util 工具包，包，分类</li>
<li>业务：普通的线程代码 <strong>Thread</strong></li>
<li><strong>Runnable</strong> 没有返回值，效率相比 Callable 相对较低</li>
</ul>
<p><img src="/2020/11/22/JUCStudy/image-20210517154146055.png" alt></p>
<p><img src="/2020/11/22/JUCStudy/image-20210517154250014.png" alt></p>
<h2 id="2-线程和进程"><a href="#2-线程和进程" class="headerlink" title="2 线程和进程"></a>2 线程和进程</h2><h3 id="2-1-进程"><a href="#2-1-进程" class="headerlink" title="2.1 进程"></a>2.1 进程</h3><p>进程：一个进程往往可以包含几个线程，至少包含一个！</p>
<p>java默认有几个线程？2个：main， GC</p>
<p>对于Java 而言： Thread，Runable，Callable</p>
<p>Java真的可以开启线程吗？<strong>开不了</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * This method is not invoked for the main method thread or &quot;system&quot;</span>
<span class="hljs-comment">         * group threads created/set up by the VM. Any new functionality added</span>
<span class="hljs-comment">         * to this method in the future may have to also be added to the VM.</span>
<span class="hljs-comment">         *</span>
<span class="hljs-comment">         * A zero status value corresponds to state &quot;NEW&quot;.</span>
<span class="hljs-comment">         */</span>
    <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();

    <span class="hljs-comment">/* Notify the group that this thread is about to be started</span>
<span class="hljs-comment">         * so that it can be added to the group&#x27;s list of threads</span>
<span class="hljs-comment">         * and the group&#x27;s unstarted count can be decremented. */</span>
    group.add(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">try</span> &#123;
        start0();
        started = <span class="hljs-keyword">true</span>;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span> (!started) &#123;
                group.threadStartFailed(<span class="hljs-keyword">this</span>);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;
            <span class="hljs-comment">/* do nothing. If start0 threw a Throwable then</span>
<span class="hljs-comment">                  it will be passed up the call stack */</span>
        &#125;
    &#125;
&#125;
<span class="hljs-comment">// 本地方法，底层C++,Java无法操作硬件</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start0</span><span class="hljs-params">()</span></span>;</code></pre></div>

<h3 id="2-2-并发和并行"><a href="#2-2-并发和并行" class="headerlink" title="2.2 并发和并行"></a>2.2 并发和并行</h3><p>并发（多个线程操作同一个资源）</p>
<ul>
<li>CPU 一个内核，模拟出来的多线程，快速交替</li>
</ul>
<p>并行（多个人一起行走）</p>
<ul>
<li>CPU 多个内核，多个线程可以同时执行</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		<span class="hljs-comment">// 获取CPU核数</span>
		<span class="hljs-comment">// CPU 密集型, IO 密集型</span>
		System.out.println(Runtime.getRuntime().availableProcessors());
	&#125;
&#125;</code></pre></div>

<p>并发编程的本质：<strong>充分利用CPU的资源</strong></p>
<h3 id="2-3-线程的状态"><a href="#2-3-线程的状态" class="headerlink" title="2.3 线程的状态"></a>2.3 线程的状态</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span> </span>&#123;
    <span class="hljs-comment">// 新生</span>
	NEW,
	
    <span class="hljs-comment">// 运行中</span>
	RUNNABLE,

    <span class="hljs-comment">// 阻塞</span>
	BLOCKED,

	<span class="hljs-comment">// 等待,死死等</span>
    WAITING,

    <span class="hljs-comment">// 超时等待</span>
    TIMED_WAITING,

    <span class="hljs-comment">// 终止</span>
	TERMINATED;
&#125;</code></pre></div>

<h3 id="2-4-wait-sleep的区别"><a href="#2-4-wait-sleep的区别" class="headerlink" title="2.4 wait/sleep的区别"></a>2.4 wait/sleep的区别</h3><ul>
<li>来自不同的类<ul>
<li>wait =&gt; Object</li>
<li>sleep =&gt; Thread</li>
</ul>
</li>
<li>关于锁的释放<ul>
<li>wait会释放锁</li>
<li>sleep 抱着锁睡觉,不会释放</li>
</ul>
</li>
<li>使用范围不同<ul>
<li>wait 必须在同步代码块</li>
<li>sleep 可以在任何地方睡</li>
</ul>
</li>
</ul>
<h2 id="3-Lock"><a href="#3-Lock" class="headerlink" title="3 Lock"></a>3 Lock</h2><ul>
<li><p>Lock 接口</p>
<p><img src="/2020/11/22/JUCStudy/image-20210519203835290.png" alt></p>
<p><img src="/2020/11/22/JUCStudy/image-20210519204141776.png" alt></p>
</li>
<li><p>公平锁: 十分公平, 可以先来后到</p>
</li>
<li><p>非公平锁: 可以插队</p>
</li>
<li><p>synchronized</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.demo01;


<span class="hljs-keyword">import</span> lombok.Synchronized;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 真正的多线程, 公司中的开发</span>
<span class="hljs-comment"> * 线程就是一个单独的资源类, 没有任何的附属操作</span>
<span class="hljs-comment"> * 1 属性, 方法</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaleTicketDemo01</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		<span class="hljs-comment">// 并发: 多线程操作同一个资源类, 把资源类丢入线程</span>
		Ticket ticket = <span class="hljs-keyword">new</span> Ticket();

		<span class="hljs-comment">// @FunctionalInterface 函数式接口. jdk1.8  lambda 表达式 (参数) -&gt; &#123; 代码 &#125;</span>
		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;
				ticket.sale();
			&#125;
		&#125;, <span class="hljs-string">&quot;A&quot;</span>).start();

		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;
				ticket.sale();
			&#125;
		&#125;, <span class="hljs-string">&quot;B&quot;</span>).start();

		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;
				ticket.sale();
			&#125;
		&#125;, <span class="hljs-string">&quot;C&quot;</span>).start();

	&#125;
&#125;

<span class="hljs-comment">// 资源类 OOP</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> </span>&#123;
	<span class="hljs-comment">// 属性 方法</span>
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">50</span>;

	<span class="hljs-comment">// 卖票的方法</span>
	<span class="hljs-comment">// synchronized 本质: 队列, 锁</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span>) &#123;
			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;卖出了第&quot;</span> + (number--) + <span class="hljs-string">&quot;票, 剩余: &quot;</span> + number + <span class="hljs-string">&quot;票!&quot;</span>);
		&#125;

	&#125;
&#125;</code></pre></div>
</li>
<li><p>Lock</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.demo01;


<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/5/19 20:39</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaleTicketDemo02</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		<span class="hljs-comment">// 并发: 多线程操作同一个资源类, 把资源类丢入线程</span>
		Ticket2 ticket = <span class="hljs-keyword">new</span> Ticket2();

		<span class="hljs-comment">// @FunctionalInterface 函数式接口. jdk1.8  lambda 表达式 (参数) -&gt; &#123; 代码 &#125;</span>
		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;
				ticket.sale();
			&#125;
		&#125;, <span class="hljs-string">&quot;A&quot;</span>).start();

		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;
				ticket.sale();
			&#125;
		&#125;, <span class="hljs-string">&quot;B&quot;</span>).start();

		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;
				ticket.sale();
			&#125;
		&#125;, <span class="hljs-string">&quot;C&quot;</span>).start();

	&#125;
&#125;

<span class="hljs-comment">// 资源类 OOP</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket2</span> </span>&#123;
	<span class="hljs-comment">// 属性 方法</span>
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">50</span>;

	Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

	<span class="hljs-comment">// 卖票的方法</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>&#123;

		lock.lock();
		<span class="hljs-keyword">try</span> &#123;
			<span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span>) &#123;
				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;卖出了第&quot;</span> + (number--) + <span class="hljs-string">&quot;票, 剩余: &quot;</span> + number + <span class="hljs-string">&quot;票!&quot;</span>);
			&#125;
		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
			e.printStackTrace();
		&#125; <span class="hljs-keyword">finally</span> &#123;
			lock.unlock();
		&#125;

	&#125;
&#125;</code></pre></div>
</li>
<li><p>synchronized 和 lock 的区别</p>
<ul>
<li>synchronized 内置的 Java 关键字, Lock 是一个 Java 类</li>
<li>synchronized 无法判断获取锁的状态, Lock 可以判断是否获取到了锁</li>
<li>synchronized 会自动释放锁, Lock 必须要手动释放锁! 如果不释放锁, 就会导致<strong>死锁</strong></li>
<li>synchronized 线程1(获得锁, 阻塞), 线程2(等待, 傻傻的等); Lock 锁就不一定会等待下去</li>
<li>synchronized 可重入锁, 不可以中断, 非公平; Lock, 可重入锁, 可以判断锁, 自己设置公平与非公平</li>
<li>synchronized 适合锁少量的代码, Lock 适合锁大量的同步代码</li>
</ul>
</li>
<li><p>锁是什么, 如何判断锁的是谁?</p>
</li>
</ul>
<h3 id="4-生产者和消费者问题"><a href="#4-生产者和消费者问题" class="headerlink" title="4 生产者和消费者问题"></a>4 生产者和消费者问题</h3><ul>
<li><p>单个生产者和消费者(synchronized)</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.pc;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/5/21 21:16</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * 线程之间的通信问题: 生产者和消费者问题! 等待唤醒, 通知唤醒</span>
<span class="hljs-comment"> * 线程交替执行 A B 操作同一个变量 num = 0</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		Data data = <span class="hljs-keyword">new</span> Data();
		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				<span class="hljs-keyword">try</span> &#123;
					data.increment();
				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;
		&#125;, <span class="hljs-string">&quot;A&quot;</span>).start();

		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				<span class="hljs-keyword">try</span> &#123;
					data.decrement();
				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;
		&#125;, <span class="hljs-string">&quot;B&quot;</span>).start();

	&#125;
&#125;


<span class="hljs-comment">// 等待 业务 通知</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

	<span class="hljs-comment">// +1</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
		<span class="hljs-keyword">if</span> (number != <span class="hljs-number">0</span>) &#123;
			<span class="hljs-comment">// 等待</span>
			<span class="hljs-keyword">this</span>.wait();
		&#125;
		number++;
		System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; &quot;</span> + number);
		<span class="hljs-comment">// 通知其他线程, 我 +1 完毕</span>
		<span class="hljs-keyword">this</span>.notifyAll();
	&#125;

	<span class="hljs-comment">// -1</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
		<span class="hljs-keyword">if</span> (number == <span class="hljs-number">0</span>) &#123;
			<span class="hljs-comment">// 等待</span>
			<span class="hljs-keyword">this</span>.wait();
		&#125;
		number--;
		System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; &quot;</span> + number);
		<span class="hljs-comment">// 通知其他线程, 我 -1 完毕</span>
		<span class="hljs-keyword">this</span>.notifyAll();
	&#125;
&#125;</code></pre></div>
</li>
<li><p>虚假唤醒</p>
<p><img src="/2020/11/22/JUCStudy/image-20210521213223425.png" alt></p>
</li>
<li><p>多个生产者和消费者(synchronized)</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.pc;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/5/21 21:16</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * 线程之间的通信问题: 生产者和消费者问题! 等待唤醒, 通知唤醒</span>
<span class="hljs-comment"> * 线程交替执行 A B 操作同一个变量 num = 0</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		Data data = <span class="hljs-keyword">new</span> Data();
		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				<span class="hljs-keyword">try</span> &#123;
					data.increment();
				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;
		&#125;, <span class="hljs-string">&quot;A&quot;</span>).start();

		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				<span class="hljs-keyword">try</span> &#123;
					data.decrement();
				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;
		&#125;, <span class="hljs-string">&quot;B&quot;</span>).start();

		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				<span class="hljs-keyword">try</span> &#123;
					data.increment();
				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;
		&#125;, <span class="hljs-string">&quot;C&quot;</span>).start();

		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				<span class="hljs-keyword">try</span> &#123;
					data.decrement();
				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;
		&#125;, <span class="hljs-string">&quot;D&quot;</span>).start();

	&#125;
&#125;


<span class="hljs-comment">// 等待 业务 通知</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

	<span class="hljs-comment">// +1</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
		<span class="hljs-keyword">while</span> (number != <span class="hljs-number">0</span>) &#123;
			<span class="hljs-comment">// 等待</span>
			<span class="hljs-keyword">this</span>.wait();
		&#125;
		number++;
		System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; &quot;</span> + number);
		<span class="hljs-comment">// 通知其他线程, 我 +1 完毕</span>
		<span class="hljs-keyword">this</span>.notifyAll();
	&#125;

	<span class="hljs-comment">// -1</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
		<span class="hljs-keyword">while</span> (number == <span class="hljs-number">0</span>) &#123;
			<span class="hljs-comment">// 等待</span>
			<span class="hljs-keyword">this</span>.wait();
		&#125;
		number--;
		System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; &quot;</span> + number);
		<span class="hljs-comment">// 通知其他线程, 我 -1 完毕</span>
		<span class="hljs-keyword">this</span>.notifyAll();
	&#125;
&#125;</code></pre></div>
</li>
<li><p>JUC版的生产者和消费者</p>
<p>通过 Lock 找到 Condition</p>
<p><img src="/2020/11/22/JUCStudy/image-20210521213938815.png" alt></p>
</li>
<li><p>代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.pc;

<span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/5/21 21:16</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * 线程之间的通信问题: 生产者和消费者问题! 等待唤醒, 通知唤醒</span>
<span class="hljs-comment"> * 线程交替执行 A B 操作同一个变量 num = 0</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		Data2 data = <span class="hljs-keyword">new</span> Data2();
		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				<span class="hljs-keyword">try</span> &#123;
					data.increment();
				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;
		&#125;, <span class="hljs-string">&quot;A&quot;</span>).start();

		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				<span class="hljs-keyword">try</span> &#123;
					data.decrement();
				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;
		&#125;, <span class="hljs-string">&quot;B&quot;</span>).start();

		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				<span class="hljs-keyword">try</span> &#123;
					data.increment();
				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;
		&#125;, <span class="hljs-string">&quot;C&quot;</span>).start();

		<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
				<span class="hljs-keyword">try</span> &#123;
					data.decrement();
				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;
		&#125;, <span class="hljs-string">&quot;D&quot;</span>).start();

	&#125;
&#125;


<span class="hljs-comment">// 等待 业务 通知</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data2</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();
	<span class="hljs-keyword">final</span> Condition notFull = lock.newCondition();
	<span class="hljs-keyword">final</span> Condition notEmpty = lock.newCondition();

	<span class="hljs-comment">// +1</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
		lock.lock();
		<span class="hljs-keyword">try</span> &#123;
			<span class="hljs-keyword">while</span> (number != <span class="hljs-number">0</span>) &#123;
				<span class="hljs-comment">// 等待</span>
				notFull.await();
			&#125;
			number++;
			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; &quot;</span> + number);
			<span class="hljs-comment">// 通知其他线程, +1 完毕</span>
			notEmpty.signalAll();
		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
			e.printStackTrace();
		&#125; <span class="hljs-keyword">finally</span> &#123;
			lock.unlock();
		&#125;
	&#125;

	<span class="hljs-comment">// -1</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
		lock.lock();
		<span class="hljs-keyword">try</span> &#123;
			<span class="hljs-keyword">while</span> (number == <span class="hljs-number">0</span>) &#123;
				<span class="hljs-comment">// 等待</span>
				notEmpty.await();
			&#125;
			number--;
			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; &quot;</span> + number);
			<span class="hljs-comment">// 通知其他线程, -1 完毕</span>
			notFull.signalAll();
		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
			e.printStackTrace();
		&#125; <span class="hljs-keyword">finally</span> &#123;
			lock.unlock();
		&#125;
	&#125;
&#125;</code></pre></div>
</li>
<li><p>Condation 精确唤醒</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.pc;

<span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/5/21 21:54</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-comment">/*</span>
<span class="hljs-comment">   依次调用 A -&gt; B -&gt; C</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      Data3 data = <span class="hljs-keyword">new</span> Data3();
      <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            data.printA();
         &#125;
      &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();
      <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            data.printB();
         &#125;
      &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();
      <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            data.printC();
         &#125;
      &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();
   &#125;
&#125;


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data3</span> </span>&#123;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();
   Condition condition1 = lock.newCondition();
   Condition condition2 = lock.newCondition();
   Condition condition3 = lock.newCondition();
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printA</span><span class="hljs-params">()</span> </span>&#123;
      lock.lock();
      <span class="hljs-keyword">try</span> &#123;
         <span class="hljs-comment">// 业务</span>
         <span class="hljs-keyword">while</span> (number != <span class="hljs-number">1</span>) &#123;
            condition1.await();
         &#125;
         System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; AAA&quot;</span>);
         number = <span class="hljs-number">2</span>;
         condition2.signal();
      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
         e.printStackTrace();
      &#125; <span class="hljs-keyword">finally</span> &#123;
         lock.unlock();
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printB</span><span class="hljs-params">()</span> </span>&#123;
      lock.lock();
      <span class="hljs-keyword">try</span> &#123;
         <span class="hljs-comment">// 业务</span>
         <span class="hljs-keyword">while</span> (number != <span class="hljs-number">2</span>) &#123;
            condition2.await();
         &#125;
         System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; BBB&quot;</span>);
         number = <span class="hljs-number">3</span>;
         condition3.signal();
      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
         e.printStackTrace();
      &#125; <span class="hljs-keyword">finally</span> &#123;
         lock.unlock();
      &#125;
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printC</span><span class="hljs-params">()</span> </span>&#123;
      lock.lock();
      <span class="hljs-keyword">try</span> &#123;
         <span class="hljs-comment">// 业务</span>
         <span class="hljs-keyword">while</span> (number != <span class="hljs-number">3</span>) &#123;
            condition3.await();
         &#125;
         System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; CCC&quot;</span>);
         number = <span class="hljs-number">1</span>;
         condition1.signal();
      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
         e.printStackTrace();
      &#125; <span class="hljs-keyword">finally</span> &#123;
         lock.unlock();
      &#125;
   &#125;
&#125;</code></pre></div>

</li>
</ul>
<h2 id="4-八锁现象"><a href="#4-八锁现象" class="headerlink" title="4 八锁现象"></a>4 八锁现象</h2><p>如何判断锁的是谁！锁到底锁的是谁？</p>
<p>锁会锁住：对象、Class。</p>
<p><strong>深刻理解我们的锁。</strong></p>
<p><strong>八</strong>个问题</p>
<ol>
<li><p><strong>两个同步方法，先执行发短信还是打电话</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dome01</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Phone phone = <span class="hljs-keyword">new</span> Phone();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123; phone.sendMs(); &#125;).start();
        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123; phone.call(); &#125;).start();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMs</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>输出结果为</p>
<p>发短信</p>
<p>打电话</p>
<p><strong>为什么？ 如果你认为是顺序在前？ 这个答案是错误的！</strong></p>
</li>
<li><p>我们再来看：<strong>我们让发短信 延迟4s</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dome01</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        Phone phone = <span class="hljs-keyword">new</span> Phone();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                phone.sendMs();
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();
        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123; phone.call(); &#125;).start();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);
        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>现在结果是什么呢？</p>
<p>结果：<strong>还是先发短信，然后再打电话！</strong></p>
<p><strong>why？</strong></p>
<blockquote>
<p>  原因：并不是顺序执行，而是synchronized 锁住的对象是方法的调用！对于两个方法用的是同一个锁，谁先拿到谁先执行，另外一个等待</p>
</blockquote>
</li>
<li><p><strong>加一个普通方法</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dome01</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        Phone phone = <span class="hljs-keyword">new</span> Phone();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                phone.sendMs();
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();
        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123; phone.hello(); &#125;).start();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);
        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>输出结果为</p>
<p>hello</p>
<p>发短信</p>
<blockquote>
<p>  原因：hello是一个普通方法，不受synchronized锁的影响，不用等待锁的释放</p>
</blockquote>
</li>
<li><p><strong>如果我们使用的是两个对象，一个调用发短信，一个调用打电话，那么整个顺序是怎么样的呢？</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dome01</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        Phone phone1 = <span class="hljs-keyword">new</span> Phone();
        Phone phone2 = <span class="hljs-keyword">new</span> Phone();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                phone1.sendMs();
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();
        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123; phone2.call(); &#125;).start();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);
        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>输出结果</p>
<p>打电话</p>
<p>发短信</p>
<blockquote>
<p>  原因：两个对象两把锁，不会出现等待的情况，发短信睡了4s,所以先执行打电话</p>
</blockquote>
</li>
<li><p>6.<strong>如果我们把synchronized的方法加上static变成静态方法！那么顺序又是怎么样的呢？</strong></p>
<ul>
<li><p>我们先来使用一个对象调用两个方法！</p>
<p>答案是：<strong>先发短信,后打电话</strong></p>
</li>
<li><p>如果我们使用两个对象调用两个方法！</p>
<p>答案是：<strong>还是先发短信，后打电话</strong></p>
</li>
<li><p>原因是什么呢？ <strong>为什么加了static就始终前面一个对象先执行呢！为什么后面会等待呢？</strong></p>
</li>
<li><p>原因是：对于static静态方法来说，对于整个类Class来说只有一份，对于不同的对象使用的是同一份方法，相当于这个方法是属于这个类的，如果静态static方法使用synchronized锁定，那么这个synchronized锁会锁住整个对象！不管多少个对象，对于静态的锁都只有一把锁，谁先拿到这个锁就先执行，其他的进程都需要等待！</p>
</li>
</ul>
</li>
<li><p><strong>如果我们使用一个静态同步方法、一个同步方法、一个对象调用顺序是什么？</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dome01</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        Phone phone1 = <span class="hljs-keyword">new</span> Phone();
<span class="hljs-comment">//        Phone phone2 = new Phone();</span>

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                phone1.sendMs();
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();
        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123; phone1.call(); &#125;).start();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);
        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>输出结果</p>
<p>打电话</p>
<p>发短信</p>
<blockquote>
<p>  原因：因为一个锁的是Class类的模板，一个锁的是对象的调用者。所以不存在等待，直接运行。</p>
</blockquote>
</li>
<li><p><strong>如果我们使用一个静态同步方法、一个同步方法、两个对象调用顺序是什么？</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dome01</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        Phone phone1 = <span class="hljs-keyword">new</span> Phone();
        Phone phone2 = <span class="hljs-keyword">new</span> Phone();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                phone1.sendMs();
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();
        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123; phone2.call(); &#125;).start();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);
        System.out.println(<span class="hljs-string">&quot;发短信&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;打电话&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>输出结果</p>
<p>打电话</p>
<p>发短信</p>
<blockquote>
<p>  原因：两把锁，锁的不是同一个东西</p>
</blockquote>
</li>
</ol>
<p><strong>小结</strong>：</p>
<p>​    <strong>new</strong> 出来的 this 是具体的一个对象</p>
<p>​    <strong>static Class</strong> 是唯一的一个模板</p>
<h2 id="6-集合不安全"><a href="#6-集合不安全" class="headerlink" title="6 集合不安全"></a>6 集合不安全</h2><h3 id="6-1-List-不安全"><a href="#6-1-List-不安全" class="headerlink" title="6.1 List 不安全"></a>6.1 List 不安全</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// java.util.ConcurrentModificationException 并发修改异常！</span>
<span class="hljs-comment">// jdk-11, 无法重新此报错</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        List&lt;Object&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;
            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
                arrayList.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));
                System.out.println(arrayList);
            &#125;,String.valueOf(i)).start();
        &#125;

    &#125;
&#125;</code></pre></div>

<p>会导致 java.util.ConcurrentModificationException 并发修改异常！</p>
<p><strong>ArrayList 在并发情况下是不安全的</strong></p>
<p>解决方案：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 解决方案</span>
<span class="hljs-comment">         * 1. List&lt;String&gt; list = new Vector&lt;&gt;();</span>
<span class="hljs-comment">         * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span>
<span class="hljs-comment">         * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="hljs-comment">         */</span>
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();
        

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));
                System.out.println(list);
            &#125;,String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p><strong>CopyOnWriteArrayList</strong>：写入时复制！ <strong>COW 计算机程序设计领域的一种优化策略</strong></p>
<ul>
<li>核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</li>
</ul>
<ul>
<li>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</li>
</ul>
<ul>
<li>多个线程调用的时候，list，读取的时候，固定的，写入（存在覆盖操作）；在写入的时候避免覆盖，造成数据错乱的问题；</li>
</ul>
<blockquote>
<p>  <strong>CopyOnWriteArrayList</strong>比<strong>Vector</strong>厉害在哪里？</p>
</blockquote>
<p><strong>Vector</strong>底层是使用<strong>synchronized</strong>关键字来实现的：效率特别低下。</p>
<p><img src="/2020/11/22/JUCStudy/image-20210525221212231.png" alt></p>
<p><strong>CopyOnWriteArrayList</strong>使用的是Lock锁，效率会更加高效！</p>
<p><img src="/2020/11/22/JUCStudy/image-20210525221105592.png" alt></p>
<h3 id="6-2-Set-不安全"><a href="#6-2-Set-不安全" class="headerlink" title="6.2 Set 不安全"></a>6.2 Set 不安全</h3><p><strong>Set和List同理可得:</strong> 多线程情况下，普通的Set集合是线程不安全的；</p>
<p>解决方案还是两种：</p>
<ul>
<li>使用Collections工具类的<strong>synchronized</strong>包装的Set类</li>
<li>使用CopyOnWriteArraySet 写入复制的<strong>JUC</strong>解决方案</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SetTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
<span class="hljs-comment">         * 2. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span>
<span class="hljs-comment">         */</span>
<span class="hljs-comment">//        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span>
        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                set.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));
                System.out.println(set);
            &#125;,String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p><strong>HashSet底层是什么？</strong></p>
<p>hashSet底层就是一个<strong>HashMap</strong>；</p>
<p><img src="/2020/11/22/JUCStudy/image-20210525221034800.png" alt></p>
<h3 id="6-3-Map不安全"><a href="#6-3-Map不安全" class="headerlink" title="6.3 Map不安全"></a>6.3 Map不安全</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//map 是这样用的吗？  不是，工作中不使用这个</span>
<span class="hljs-comment">//默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span>
Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
<span class="hljs-comment">//加载因子、初始化容量</span></code></pre></div>

<p>默认<strong>加载因子是0.75</strong>,默认的<strong>初始容量是16</strong></p>
<p>只有保证length的长度是<code>2^n</code>的话，才可以实现利用取模运算,计算哈希。而位运算(&amp;)效率要比代替取模运算(%)高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 使用位运算计算哈希值</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;
    <span class="hljs-keyword">int</span> h;
    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);
&#125;</code></pre></div>

<p><img src="/2020/11/22/JUCStudy/a35fac9739ec6cb78381f0a82c1a8927.png" alt></p>
<p>同样的HashMap基础类也存在<strong>并发修改异常</strong>！</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//map 是这样用的吗？  不是，工作中不使用这个</span>
        <span class="hljs-comment">//默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span>
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 解决方案</span>
<span class="hljs-comment">         * 1. Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</span>
<span class="hljs-comment">         *  Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span>
<span class="hljs-comment">         */</span>
        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();
        <span class="hljs-comment">//加载因子、初始化容量</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>));
                System.out.println(map);
            &#125;,String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>



<h2 id="7-Callable"><a href="#7-Callable" class="headerlink" title="7 Callable"></a>7 Callable</h2><ul>
<li><strong>可以有返回值；</strong></li>
<li><strong>可以抛出异常；</strong></li>
<li><strong>方法不同，run()/call()</strong></li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.callable;

<span class="hljs-keyword">import</span> java.util.concurrent.Callable;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;
<span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableTest</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
			MyThread myThread = <span class="hljs-keyword">new</span> MyThread();
			FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(myThread);
			<span class="hljs-comment">// 放入 Thread 中,使用, 结果会被缓存</span>
			<span class="hljs-keyword">new</span> Thread(futureTask, String.valueOf(i)).start();
			<span class="hljs-comment">// 这个 Get 方法可能会被阻塞,</span>
			<span class="hljs-comment">// 如果在call方法中是一个耗时的方法，</span>
			<span class="hljs-comment">// 所以一般情况我们会把这个放在最后，或者使用异步通信</span>
			Integer a = futureTask.get();
			System.out.println(<span class="hljs-string">&quot;返回值: &quot;</span> + a);
		&#125;
	&#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
		System.out.println(<span class="hljs-string">&quot;call()&quot;</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;
	&#125;
&#125;</code></pre></div>

<h2 id="8-常用的辅助类"><a href="#8-常用的辅助类" class="headerlink" title="8 常用的辅助类"></a>8 常用的辅助类</h2><h3 id="8-1-CountDownLatch"><a href="#8-1-CountDownLatch" class="headerlink" title="8.1 CountDownLatch"></a>8.1 CountDownLatch</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.utils;

<span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchDemo</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
		<span class="hljs-comment">// 总数是6</span>
		CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;
			<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ==&gt; Go Out&quot;</span>);
				countDownLatch.countDown(); <span class="hljs-comment">// 每个线程都数量减 1</span>
			&#125;, String.valueOf(i)).start();
		&#125;
		countDownLatch.await(); <span class="hljs-comment">// 等待计数器归零, 然后向下执行</span>
		System.out.println(<span class="hljs-string">&quot;close door&quot;</span>);
	&#125;
&#125;</code></pre></div>

<p>主要方法：</p>
<ul>
<li>countDown 减一操作；</li>
<li>await 等待计数器归零</li>
</ul>
<p>await 等待计数器归零，就唤醒，再继续向下运行</p>
<h3 id="8-2-CyclickBarrier"><a href="#8-2-CyclickBarrier" class="headerlink" title="8.2 CyclickBarrier"></a>8.2 CyclickBarrier</h3><p><img src="/2020/11/22/JUCStudy/dee6ef3d75096d41547b6729fcce3037.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.utils;

<span class="hljs-keyword">import</span> java.util.concurrent.BrokenBarrierException;
<span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierDemo</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		<span class="hljs-comment">// 主线程</span>
		CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">7</span>, () -&gt; System.out.println(<span class="hljs-string">&quot;召唤神龙成功&quot;</span>));

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; i++) &#123;
			<span class="hljs-comment">// 子线程</span>
			<span class="hljs-keyword">int</span> finalI = i;
			<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;收集了第 &quot;</span> + finalI + <span class="hljs-string">&quot; 颗龙珠!&quot;</span>);
				<span class="hljs-keyword">try</span> &#123;
					cyclicBarrier.await();  <span class="hljs-comment">// 加法计数 等待</span>
				&#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException | InterruptedException e) &#123;
					e.printStackTrace();
				&#125;
			&#125;).start();

		&#125;
	&#125;
&#125;</code></pre></div>

<h3 id="8-3-Semaphore"><a href="#8-3-Semaphore" class="headerlink" title="8.3 Semaphore"></a>8.3 Semaphore</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.utils;

<span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreDemo</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		<span class="hljs-comment">// 线程数量, 停车位, 限流</span>
		Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;
			<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
				<span class="hljs-comment">// acquire() 得到</span>
				<span class="hljs-keyword">try</span> &#123;
					semaphore.acquire();
					System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;强到车位&quot;</span>);
					TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
					System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;离开车位&quot;</span>);
				&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
					e.printStackTrace();
				&#125; <span class="hljs-keyword">finally</span> &#123;
					semaphore.release();    <span class="hljs-comment">// release 释放</span>
				&#125;
			&#125;).start();
		&#125;
	&#125;
&#125;</code></pre></div>

<p>原理：</p>
<p><strong>semaphore.acquire()获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！</strong></p>
<p><strong>semaphore.release()释放，会将当前的信号量释放+1，然后唤醒等待的线程！</strong></p>
<p>作用： 多个共享资源互斥的使用！ 并发限流，控制最大的线程数！</p>
<h2 id="9-读写锁"><a href="#9-读写锁" class="headerlink" title="9 读写锁"></a>9 读写锁</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">6</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;
            <span class="hljs-keyword">int</span> finalI = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

                myCache.write(String.valueOf(finalI), String.valueOf(finalI));

            &#125;,String.valueOf(i)).start();
        &#125;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;
            <span class="hljs-keyword">int</span> finalI = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

                myCache.read(String.valueOf(finalI));

            &#125;,String.valueOf(i)).start();
        &#125;
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> *  方法未加锁，导致写的时候被插队</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String key, String value)</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程开始写入&quot;</span>);
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程写入ok&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String key)</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程开始读取&quot;</span>);
        map.get(key);
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程写读取ok&quot;</span>);
    &#125;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs shell">6线程开始读取
3线程开始读取
2线程开始读取
6线程写读取ok
5线程开始读取
5线程开始写入
2线程开始写入
4线程开始写入
4线程开始读取
4线程写读取ok
1线程开始读取
5线程写读取ok
3线程写读取ok
3线程开始写入
3线程写入ok
1线程开始写入
2线程写读取ok
6线程开始写入
1线程写入ok
1线程写读取ok
2线程写入ok
4线程写入ok
5线程写入ok
6线程写入ok</code></pre></div>

<p>所以如果我们不加锁的情况，多线程的读写会造成数据不可靠的问题。</p>
<p>我们也可以采用<strong>synchronized</strong>这种重量锁和轻量锁 <strong>lock</strong>去保证数据的可靠。</p>
<p>但是这次我们采用更细粒度的锁：<strong>ReadWriteLock</strong> 读写锁来保证</p>
<p><img src="/2020/11/22/JUCStudy/8ee70d5ab31bef2c8afd95cdc32a381e.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        MyCache2 myCache = <span class="hljs-keyword">new</span> MyCache2();
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">6</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;
            <span class="hljs-keyword">int</span> finalI = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

                myCache.write(String.valueOf(finalI), String.valueOf(finalI));

            &#125;,String.valueOf(i)).start();
        &#125;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;
            <span class="hljs-keyword">int</span> finalI = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

                myCache.read(String.valueOf(finalI));

            &#125;,String.valueOf(i)).start();
        &#125;
    &#125;

&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache2</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">private</span> ReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String key, String value)</span> </span>&#123;
        lock.writeLock().lock(); <span class="hljs-comment">// 写锁</span>
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程开始写入&quot;</span>);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程写入ok&quot;</span>);

        &#125;<span class="hljs-keyword">finally</span> &#123;
            lock.writeLock().unlock(); <span class="hljs-comment">// 释放写锁</span>
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(String key)</span> </span>&#123;
        lock.readLock().lock(); <span class="hljs-comment">// 读锁</span>
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程开始读取&quot;</span>);
            map.get(key);
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程写读取ok&quot;</span>);
        &#125;<span class="hljs-keyword">finally</span> &#123;
            lock.readLock().unlock(); <span class="hljs-comment">// 释放读锁</span>
        &#125;
    &#125;
&#125;
</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs shell">1线程开始写入
1线程写入ok
4线程开始写入
4线程写入ok
2线程开始写入
2线程写入ok
5线程开始写入
5线程写入ok
6线程开始写入
6线程写入ok
3线程开始写入
3线程写入ok
2线程开始读取
1线程开始读取
6线程开始读取
4线程开始读取
2线程写读取ok
3线程开始读取
6线程写读取ok
5线程开始读取
4线程写读取ok
3线程写读取ok
1线程写读取ok
5线程写读取ok</code></pre></div>

<h2 id="10-阻塞队列"><a href="#10-阻塞队列" class="headerlink" title="10 阻塞队列"></a>10 阻塞队列</h2><p><img src="/2020/11/22/JUCStudy/3b6b0b33e6e9b0f2261a89b6e42e78ea.png" alt></p>
<p><img src="/2020/11/22/JUCStudy/d651ccc40069352ee6c8b86ae2cee8eb.png" alt></p>
<h3 id="10-1-BlockQueue"><a href="#10-1-BlockQueue" class="headerlink" title="10.1 BlockQueue"></a>10.1 BlockQueue</h3><p>是Collection的一个子类</p>
<p>什么情况下我们会使用阻塞队列</p>
<blockquote>
<p>  多线程并发处理、线程池</p>
</blockquote>
<p><img src="/2020/11/22/JUCStudy/cae49c50458adc0997d57b2044666ccb.png" alt></p>
<p>BlockingQueue 有四组api</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>不会抛出异常，有返回值</th>
<th>阻塞，等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add</td>
<td>offer</td>
<td>put</td>
<td>offer(timenum.timeUnit)</td>
</tr>
<tr>
<td>移出</td>
<td>remove</td>
<td>poll</td>
<td>take</td>
<td>poll(timenum,timeUnit)</td>
</tr>
<tr>
<td>判断队首元素</td>
<td>element</td>
<td>peek</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 抛出异常</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-comment">//需要初始化队列的大小</span>
        ArrayBlockingQueue blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);

        System.out.println(blockingQueue.add(<span class="hljs-string">&quot;a&quot;</span>));
        System.out.println(blockingQueue.add(<span class="hljs-string">&quot;b&quot;</span>));
        System.out.println(blockingQueue.add(<span class="hljs-string">&quot;c&quot;</span>));
        <span class="hljs-comment">//抛出异常：java.lang.IllegalStateException: Queue full</span>
<span class="hljs-comment">//        System.out.println(blockingQueue.add(&quot;d&quot;));</span>
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        <span class="hljs-comment">//如果多移除一个</span>
        <span class="hljs-comment">//这也会造成 java.util.NoSuchElementException 抛出异常</span>
        System.out.println(blockingQueue.remove());
    &#125;
=======================================================================================
<span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 不抛出异常，有返回值</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;
        ArrayBlockingQueue blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);
        System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;a&quot;</span>));
        System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;b&quot;</span>));
        System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;c&quot;</span>));
        <span class="hljs-comment">//添加 一个不能添加的元素 使用offer只会返回false 不会抛出异常</span>
        System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;d&quot;</span>));

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        <span class="hljs-comment">//弹出 如果没有元素 只会返回null 不会抛出异常</span>
        System.out.println(blockingQueue.poll());
    &#125;
=======================================================================================
<span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 等待 一直阻塞</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        ArrayBlockingQueue blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);

        <span class="hljs-comment">//一直阻塞 不会返回</span>
        blockingQueue.put(<span class="hljs-string">&quot;a&quot;</span>);
        blockingQueue.put(<span class="hljs-string">&quot;b&quot;</span>);
        blockingQueue.put(<span class="hljs-string">&quot;c&quot;</span>);

        <span class="hljs-comment">//如果队列已经满了， 再进去一个元素  这种情况会一直等待这个队列 什么时候有了位置再进去，程序不会停止</span>
<span class="hljs-comment">//        blockingQueue.put(&quot;d&quot;);</span>

        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        <span class="hljs-comment">//如果我们再来一个  这种情况也会等待，程序会一直运行 阻塞</span>
        System.out.println(blockingQueue.take());
    &#125;
=======================================================================================
<span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 等待 超时阻塞</span>
<span class="hljs-comment">     *  这种情况也会等待队列有位置 或者有产品 但是会超时结束</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        ArrayBlockingQueue blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);
        blockingQueue.offer(<span class="hljs-string">&quot;a&quot;</span>);
        blockingQueue.offer(<span class="hljs-string">&quot;b&quot;</span>);
        blockingQueue.offer(<span class="hljs-string">&quot;c&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;开始等待&quot;</span>);
        blockingQueue.offer(<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">2</span>, TimeUnit.SECONDS);  <span class="hljs-comment">//超时时间2s 等待如果超过2s就结束等待</span>
        System.out.println(<span class="hljs-string">&quot;结束等待&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;===========取值==================&quot;</span>);
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(<span class="hljs-string">&quot;开始等待&quot;</span>);
        blockingQueue.poll(<span class="hljs-number">2</span>,TimeUnit.SECONDS); <span class="hljs-comment">//超过两秒 我们就不要等待了</span>
        System.out.println(<span class="hljs-string">&quot;结束等待&quot;</span>);
    &#125;</code></pre></div>

<h3 id="10-2-同步队列"><a href="#10-2-同步队列" class="headerlink" title="10.2 同步队列"></a>10.2 同步队列</h3><p>同步队列 没有容量，也可以视为容量为1的队列；</p>
<p>进去一个元素，必须等待取出来之后，才能再往里面放入一个元素；</p>
<p>put方法 和 take方法；</p>
<p>Synchronized 和 其他的BlockingQueue 不一样 它不存储元素；</p>
<p>put了一个元素，就必须从里面先take出来，否则不能再put进去值！</p>
<p>并且SynchronousQueue 的take是使用了lock锁保证线程安全的。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronousQueue</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        BlockingQueue&lt;String&gt; synchronousQueue = <span class="hljs-keyword">new</span> java.util.concurrent.SynchronousQueue&lt;&gt;();
        <span class="hljs-comment">// 往queue中添加元素</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;put 01&quot;</span>);
                synchronousQueue.put(<span class="hljs-string">&quot;1&quot;</span>);
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;put 02&quot;</span>);
                synchronousQueue.put(<span class="hljs-string">&quot;2&quot;</span>);
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;put 03&quot;</span>);
                synchronousQueue.put(<span class="hljs-string">&quot;3&quot;</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();
        <span class="hljs-comment">// 取出元素</span>
        <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;take&quot;</span> + synchronousQueue.take());
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;take&quot;</span> + synchronousQueue.take());
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;take&quot;</span> + synchronousQueue.take());
            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();
    &#125;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs shell">Thread-0put 01
Thread-0put 02
Thread-1take1
Thread-0put 03
Thread-1take2
Thread-1take3</code></pre></div>

<h2 id="11-线程池"><a href="#11-线程池" class="headerlink" title="11 线程池"></a>11 线程池</h2><p>线程池：三大方式、七大参数、四种拒绝策略</p>
<blockquote>
<p>  池化技术</p>
</blockquote>
<p>程序的运行，本质：占用系统的资源！我们需要去优化资源的使用 ===&gt; 池化技术</p>
<p>线程池、JDBC的连接池、内存池、对象池 等等。。。。</p>
<p>资源的创建、销毁十分消耗资源</p>
<p>池化技术：事先准备好一些资源，如果有人要用，就来我这里拿，用完之后还给我，以此来提高效率。</p>
<h3 id="11-1-线程池的好处"><a href="#11-1-线程池的好处" class="headerlink" title="11.1 线程池的好处"></a>11.1 线程池的好处</h3><ul>
<li><p>降低资源的消耗；</p>
</li>
<li><p>提高响应的速度；</p>
</li>
<li><p>方便管理；</p>
</li>
</ul>
<p><strong>线程复用、可以控制最大并发数、管理线程；</strong></p>
<h3 id="11-2-线程池：三大方法"><a href="#11-2-线程池：三大方法" class="headerlink" title="11.2 线程池：三大方法"></a>11.2 线程池：三大方法</h3><ul>
<li>ExecutorService threadPool = Executors.newSingleThreadExecutor();    // 单个线程</li>
<li>ExecutorService threadPool2 = Executors.newFixedThreadPool(5);        // 创建一个固定的线程池的大小</li>
<li>ExecutorService threadPool3 = Executors.newCachedThreadPool();       // 可伸缩的</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//工具类 Executors 三大方法；</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        ExecutorService threadPool = Executors.newSingleThreadExecutor();<span class="hljs-comment">//单个线程</span>
        ExecutorService threadPool2 = Executors.newFixedThreadPool(<span class="hljs-number">5</span>); <span class="hljs-comment">//创建一个固定的线程池的大小</span>
        ExecutorService threadPool3 = Executors.newCachedThreadPool(); <span class="hljs-comment">//可伸缩的</span>

        <span class="hljs-comment">//线程池用完必须要关闭线程池</span>
        <span class="hljs-keyword">try</span> &#123;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">100</span> ; i++) &#123;
                <span class="hljs-comment">//通过线程池创建线程</span>
                threadPool.execute(()-&gt;&#123;
                    System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">&quot; ok&quot;</span>);
                &#125;);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            threadPool.shutdown();
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="11-3-七大参数"><a href="#11-3-七大参数" class="headerlink" title="11.3 七大参数"></a>11.3 七大参数</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,  //核心线程池大小</span></span>
<span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize, //最大的线程池大小</span></span>
<span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,  //超时了没有人调用就会释放</span></span>
<span class="hljs-function"><span class="hljs-params">                          TimeUnit unit, //超时单位</span></span>
<span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列</span></span>
<span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory, //线程工厂 创建线程的 一般不用动</span></span>
<span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler //拒绝策略</span></span>
<span class="hljs-function"><span class="hljs-params">                         )</span> </span>&#123;
    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||
        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();
    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;
    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;
    <span class="hljs-keyword">this</span>.workQueue = workQueue;
    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);
    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;
    <span class="hljs-keyword">this</span>.handler = handler;
&#125;</code></pre></div>

<p><img src="/2020/11/22/JUCStudy/920c376a11e2d90ad07013f5c509f174.png" alt></p>
<p>阿里巴巴的Java操作手册中明确说明：对于Integer.MAX_VALUE初始值较大，所以一般情况我们要使用底层的<strong>ThreadPoolExecutor</strong>来创建线程池。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PollDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 获取cpu 的核数</span>
        <span class="hljs-keyword">int</span> max = Runtime.getRuntime().availableProcessors();
        ExecutorService service =<span class="hljs-keyword">new</span> ThreadPoolExecutor(
                <span class="hljs-number">2</span>,
                max,
                <span class="hljs-number">3</span>,
                TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="hljs-number">3</span>),
                Executors.defaultThreadFactory(),
                <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy()
        );
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;
                service.execute(() -&gt; &#123;
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;ok&quot;</span>);
                &#125;);
            &#125;
        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">finally</span> &#123;
            service.shutdown();
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="11-4-拒绝策略"><a href="#11-4-拒绝策略" class="headerlink" title="11.4 拒绝策略"></a>11.4 拒绝策略</h3><ol>
<li><p>new ThreadPoolExecutor.AbortPolicy()： //该拒绝策略为：银行满了，还有人进来，不处理这个人的，并抛出异常</p>
<p> 超出最大承载，就会抛出异常：队列容量大小+maxPoolSize</p>
</li>
<li><p>new ThreadPoolExecutor.CallerRunsPolicy()： //该拒绝策略为：哪来的去哪里 main线程进行处理</p>
</li>
<li><p>new ThreadPoolExecutor.DiscardPolicy(): //该拒绝策略为：队列满了,丢掉异常，不会抛出异常。</p>
</li>
<li><p>new ThreadPoolExecutor.DiscardOldestPolicy()： //该拒绝策略为：队列满了，尝试去和最早的进程竞争，不会抛出异常</p>
</li>
</ol>
<h3 id="11-5-如何设置线程池的大小"><a href="#11-5-如何设置线程池的大小" class="headerlink" title="11.5 如何设置线程池的大小"></a>11.5 如何设置线程池的大小</h3><p><strong>1、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSize的大小</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获取cpu 的核数</span>
        <span class="hljs-keyword">int</span> max = Runtime.getRuntime().availableProcessors();
        ExecutorService service =<span class="hljs-keyword">new</span> ThreadPoolExecutor(
                <span class="hljs-number">2</span>,
                max,
                <span class="hljs-number">3</span>,
                TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="hljs-number">3</span>),
                Executors.defaultThreadFactory(),
                <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy()
        );</code></pre></div>

<p><strong>2、I/O密集型：</strong></p>
<p>在程序中有15个大型任务，io十分占用资源；I/O密集型就是判断我们程序中十分耗I/O的线程数量，大约是最大I/O数的一倍到两倍之间。</p>
<h2 id="12-四大函数式接口"><a href="#12-四大函数式接口" class="headerlink" title="12 四大函数式接口"></a>12 四大函数式接口</h2><p>新时代的程序员：<strong>lambda表达式、链式编程、函数式接口、Stream流式计算</strong></p>
<p>函数式接口：只有一个方法的接口</p>
<p><img src="/2020/11/22/JUCStudy/683398646b42b8c231d142c8ba7bfa2b.png" alt></p>
<p><img src="/2020/11/22/JUCStudy/a4bd596dc9a77d9da8821dd6312a4314.png" alt></p>
<h3 id="12-1-Function-函数型接口"><a href="#12-1-Function-函数型接口" class="headerlink" title="12.1 Function 函数型接口"></a>12.1 Function 函数型接口</h3><p><img src="/2020/11/22/JUCStudy/5012bef99a9082398d6791311edef491.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Function&lt;String, String&gt; function = (str) -&gt; &#123;<span class="hljs-keyword">return</span> str;&#125;;
        System.out.println(function.apply(<span class="hljs-string">&quot;aaaaaaaaaa&quot;</span>));
    &#125;
&#125;</code></pre></div>

<h3 id="12-2-Predicate-断定型接口"><a href="#12-2-Predicate-断定型接口" class="headerlink" title="12.2 Predicate 断定型接口"></a>12.2 Predicate 断定型接口</h3><p><img src="/2020/11/22/JUCStudy/12588446b54d93dc56bd005cfaa31a79.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PredicateDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Predicate&lt;String&gt; predicate = (str) -&gt; &#123;<span class="hljs-keyword">return</span> str.isEmpty();&#125;;
        <span class="hljs-comment">// false</span>
        System.out.println(predicate.test(<span class="hljs-string">&quot;aaa&quot;</span>));
        <span class="hljs-comment">// true</span>
        System.out.println(predicate.test(<span class="hljs-string">&quot;&quot;</span>));
    &#125;
&#125;</code></pre></div>

<h3 id="12-3-Suppier-供给型接口"><a href="#12-3-Suppier-供给型接口" class="headerlink" title="12.3 Suppier 供给型接口"></a>12.3 Suppier 供给型接口</h3><p><img src="/2020/11/22/JUCStudy/ff6aa0d95bf9f22b1f2dd5714f3db542.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 供给型接口，只返回，不输入</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Supplier&lt;String&gt; supplier = ()-&gt;&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1024&quot;</span>;&#125;;
        System.out.println(supplier.get());
    &#125;
&#125;</code></pre></div>

<h3 id="12-4-Consummer-消费型接口"><a href="#12-4-Consummer-消费型接口" class="headerlink" title="12.4 Consummer 消费型接口"></a>12.4 Consummer 消费型接口</h3><p><img src="/2020/11/22/JUCStudy/772c811d116f54e0c739929ab392de25.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 消费型接口 没有返回值！只有输入！</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Consumer&lt;String&gt; consumer = (str)-&gt;&#123;
            System.out.println(str);
        &#125;;
        consumer.accept(<span class="hljs-string">&quot;abc&quot;</span>);
    &#125;
&#125;</code></pre></div>

<h2 id="13-Stream-流式计算"><a href="#13-Stream-流式计算" class="headerlink" title="13 Stream 流式计算"></a>13 Stream 流式计算</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Description：</span>
<span class="hljs-comment"> * 题目要求： 用一行代码实现</span>
<span class="hljs-comment"> * 1. Id 必须是偶数</span>
<span class="hljs-comment"> * 2.年龄必须大于23</span>
<span class="hljs-comment"> * 3. 用户名转为大写</span>
<span class="hljs-comment"> * 4. 用户名倒序</span>
<span class="hljs-comment"> * 5. 只能输出一个用户</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiaoqianjin</span>
<span class="hljs-comment"> * Date: 2020/8/12 14:55</span>
<span class="hljs-comment"> **/</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        User u1 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">23</span>);
        User u2 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">23</span>);
        User u3 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">23</span>);
        User u4 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">24</span>);
        User u5 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-number">25</span>);

        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);
        <span class="hljs-comment">// lambda、链式编程、函数式接口、流式计算</span>
        list.stream()
                .filter(user -&gt; &#123;<span class="hljs-keyword">return</span> user.getId()%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>;&#125;)
                .filter(user -&gt; &#123;<span class="hljs-keyword">return</span> user.getAge() &gt; <span class="hljs-number">23</span>;&#125;)
                .map(user -&gt; &#123;<span class="hljs-keyword">return</span> user.getName().toUpperCase();&#125;)
                .sorted((user1, user2) -&gt; &#123;<span class="hljs-keyword">return</span> user2.compareTo(user1);&#125;)
                .limit(<span class="hljs-number">1</span>)
                .forEach(System.out::println);
    &#125;
&#125;</code></pre></div>

<h2 id="14-ForkJoin"><a href="#14-ForkJoin" class="headerlink" title="14 ForkJoin"></a>14 ForkJoin</h2><p>ForkJoin 在JDK1.7，并行执行任务！提高效率~。在大数据量速率会更快！</p>
<p>大数据中：<strong>MapReduce 核心思想-&gt;把大任务拆分为小任务！</strong></p>
<p><img src="/2020/11/22/JUCStudy/c2acd43fd3363e780aa9709a6fae2d8c.png" alt></p>
<h3 id="14-1-ForkJoin-特点：-工作窃取！"><a href="#14-1-ForkJoin-特点：-工作窃取！" class="headerlink" title="14.1 ForkJoin 特点： 工作窃取！"></a>14.1 ForkJoin 特点： 工作窃取！</h3><p>实现原理是：<strong>双端队列</strong>！从上面和下面都可以去拿到任务进行执行！\</p>
<p><img src="/2020/11/22/JUCStudy/7ccffb99e41ec5a89ef2118cf0c4f0f2.png" alt></p>
<h3 id="14-2-如何使用ForkJoin"><a href="#14-2-如何使用ForkJoin" class="headerlink" title="14.2 如何使用ForkJoin?"></a>14.2 如何使用ForkJoin?</h3><ul>
<li><p>通过<strong>ForkJoinPool</strong>来执行</p>
</li>
<li><p>计算任务 <strong>execute(ForkJoinTask&lt;?&gt; task)</strong></p>
</li>
<li><p>计算类要去继承ForkJoinTask；</p>
</li>
<li><p><strong>ForkJoin 的计算类</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.forkjoin;

<span class="hljs-keyword">import</span> java.util.concurrent.RecursiveTask;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/6/5 21:01</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJoinDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long start;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long end;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForkJoinDemo</span><span class="hljs-params">(Long start, Long end)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.start = start;
		<span class="hljs-keyword">this</span>.end = end;
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> Long <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-comment">// 临界值</span>
		<span class="hljs-keyword">long</span> temp = <span class="hljs-number">1000000L</span>;
		<span class="hljs-keyword">if</span> ((end - start) &lt; temp) &#123;
			<span class="hljs-keyword">long</span> sum = <span class="hljs-number">0L</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = start; i &lt; end; i++) &#123;
				sum += i;
			&#125;
			<span class="hljs-keyword">return</span> sum;
		&#125; <span class="hljs-keyword">else</span> &#123;
			<span class="hljs-comment">// 使用ForkJoin 分而治之 计算</span>
			<span class="hljs-comment">// 1. 计算平均值</span>
			<span class="hljs-keyword">long</span> middle = (start + end) / <span class="hljs-number">2</span>;
			ForkJoinDemo forkJoinDemo1 = <span class="hljs-keyword">new</span> ForkJoinDemo(start, middle);
			<span class="hljs-comment">// 2. 拆分任务,把任务压入线程队列</span>
			forkJoinDemo1.fork();
			ForkJoinDemo forkJoinDemo2 = <span class="hljs-keyword">new</span> ForkJoinDemo(middle, end);
			forkJoinDemo2.fork();

			<span class="hljs-keyword">long</span> taskSum;
			taskSum = forkJoinDemo1.join() + forkJoinDemo2.join();
			<span class="hljs-keyword">return</span> taskSum;

		&#125;
	&#125;
&#125;</code></pre></div>
</li>
<li><p><strong>测试类</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.kaungshen.forkjoin;

<span class="hljs-keyword">import</span> org.junit.Test;

<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;
<span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;
<span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinTask;
<span class="hljs-keyword">import</span> java.util.stream.LongStream;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/6/5 21:09</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJoinTest</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> SUM = <span class="hljs-number">20_0000_0000</span>;

	<span class="hljs-comment">/**</span>
<span class="hljs-comment">	 * 使用普通方法</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">long</span> star = System.currentTimeMillis();
		<span class="hljs-keyword">long</span> sum = <span class="hljs-number">0L</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">1</span>; i &lt; SUM; i++) &#123;
			sum += i;
		&#125;
		<span class="hljs-keyword">long</span> end = System.currentTimeMillis();
		System.out.println(sum);
		System.out.println(<span class="hljs-string">&quot;时间：&quot;</span> + (end - star) + <span class="hljs-string">&quot; ms&quot;</span>);
		System.out.println(<span class="hljs-string">&quot;----------------------&quot;</span>);
	&#125;

	<span class="hljs-comment">/**</span>
<span class="hljs-comment">	 * 使用ForkJoin 方法</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;
		<span class="hljs-keyword">long</span> star = System.currentTimeMillis();

		ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool();
		ForkJoinTask&lt;Long&gt; task = <span class="hljs-keyword">new</span> ForkJoinDemo(<span class="hljs-number">0L</span>, SUM);
		ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);
		Long along = submit.get();

		System.out.println(along);
		<span class="hljs-keyword">long</span> end = System.currentTimeMillis();
		System.out.println(<span class="hljs-string">&quot;时间：&quot;</span> + (end - star) + <span class="hljs-string">&quot; ms&quot;</span>);
		System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>);
	&#125;

	<span class="hljs-comment">/**</span>
<span class="hljs-comment">	 * 使用 Stream 流计算</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">long</span> star = System.currentTimeMillis();

		<span class="hljs-keyword">long</span> sum = LongStream.range(<span class="hljs-number">0L</span>, SUM).parallel().reduce(<span class="hljs-number">0</span>, Long::sum);
		System.out.println(sum);
		<span class="hljs-keyword">long</span> end = System.currentTimeMillis();
		System.out.println(<span class="hljs-string">&quot;时间：&quot;</span> + (end - star) + <span class="hljs-string">&quot; ms&quot;</span>);
		System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>);
	&#125;

&#125;</code></pre></div>

<p><img src="/2020/11/22/JUCStudy/image-20210605211639515.png" alt></p>
<p><strong>.parallel().reduce(0, Long::sum)使用一个并行流去计算整个计算，提高效率。</strong></p>
</li>
</ul>
<p><img src="/2020/11/22/JUCStudy/44c24ea717d569f1966ec8f14f6ce39f.png" alt></p>
<h2 id="15-异步回调"><a href="#15-异步回调" class="headerlink" title="15 异步回调"></a>15 异步回调</h2><blockquote>
<p>  Future 设计的初衷：对将来的某个事件结果进行建模！</p>
</blockquote>
<p>其实就是前端 –&gt; 发送 ajax 异步请求给后端</p>
<p><img src="/2020/11/22/JUCStudy/9f7114b8ef92f8bd5889d865ccf4707a.png" alt></p>
<p>但是我们平时都使用<strong>CompletableFuture</strong></p>
<h3 id="15-1-没有返回值的runAsync异步回调"><a href="#15-1-没有返回值的runAsync异步回调" class="headerlink" title="15.1 没有返回值的runAsync异步回调"></a>15.1 没有返回值的runAsync异步回调</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureDemo</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;
		<span class="hljs-comment">// 发起一个请求</span>
		System.out.println(System.currentTimeMillis());
		System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);
		CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;
			<span class="hljs-comment">//发起一个异步任务</span>
			<span class="hljs-keyword">try</span> &#123;
				TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
				e.printStackTrace();
			&#125;
			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;.....&quot;</span>);
		&#125;);
		System.out.println(System.currentTimeMillis());
		System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);
		<span class="hljs-comment">//输出执行结果</span>
		System.out.println(future.get());  <span class="hljs-comment">//获取执行结果</span>
	&#125;
&#125;</code></pre></div>

<h3 id="15-2-有返回值的异步回调supplyAsync"><a href="#15-2-有返回值的异步回调supplyAsync" class="headerlink" title="15.2 有返回值的异步回调supplyAsync"></a>15.2 有返回值的异步回调supplyAsync</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//有返回值的异步回调</span>
CompletableFuture&lt;Integer&gt; completableFuture=CompletableFuture.supplyAsync(()-&gt;&#123;
    System.out.println(Thread.currentThread().getName());
    <span class="hljs-keyword">try</span> &#123;
        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;
    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;
&#125;);
System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;
    <span class="hljs-comment">//success 回调</span>
    System.out.println(<span class="hljs-string">&quot;t=&gt;&quot;</span> + t); <span class="hljs-comment">//正常的返回结果</span>
    System.out.println(<span class="hljs-string">&quot;u=&gt;&quot;</span> + u); <span class="hljs-comment">//抛出异常的 错误信息</span>
&#125;).exceptionally((e) -&gt; &#123;
    <span class="hljs-comment">//error回调</span>
    System.out.println(e.getMessage());
    <span class="hljs-keyword">return</span> <span class="hljs-number">404</span>;
&#125;).get());</code></pre></div>

<p><strong>whenComplete</strong>: 有两个参数，一个是t 一个是u</p>
<p>T：是代表的 <strong>正常返回的结果</strong>；</p>
<p>U：是代表的 <strong>抛出异常的错误信息</strong>；</p>
<p>如果发生了异常，get可以获取到<strong>exceptionally</strong>返回的值；</p>
<h2 id="16-JMM"><a href="#16-JMM" class="headerlink" title="16  JMM"></a>16  JMM</h2><h3 id="16-1-对Volatile-的理解"><a href="#16-1-对Volatile-的理解" class="headerlink" title="16.1 对Volatile 的理解"></a>16.1 对Volatile 的理解</h3><p><strong>Volatile</strong> 是 Java 虚拟机提供 <strong>轻量级的同步机制</strong></p>
<ul>
<li>保证可见性</li>
<li><strong>不保证原子性</strong></li>
<li>禁止指令重排</li>
</ul>
<p><strong>如何实现可见性</strong></p>
<p>volatile变量修饰的共享变量在进行写操作的时候回多出一行汇编：</p>
<p>0x01a3de1d:movb $0×0，0×1104800（%esi）;0x01a3de24<strong>:lock</strong> addl $0×0,(%esp);</p>
<p>Lock前缀的指令在多核处理器下会引发两件事情。</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使其他cpu里缓存了该内存地址的数据无效。</li>
</ul>
<p><strong>多处理器总线嗅探：</strong></p>
<ul>
<li>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作不知道何时会写到内存。</li>
<li>如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</li>
<li>但是在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。</li>
</ul>
<h3 id="16-2-什么是JMM？"><a href="#16-2-什么是JMM？" class="headerlink" title="16.2 什么是JMM？"></a>16.2 什么是JMM？</h3><p>JMM：JAVA内存模型，不存在的东西，是一个概念，也是一个约定！</p>
<p><strong>关于JMM的一些同步的约定：</strong></p>
<ul>
<li>线程解锁前，必须把共享变量<strong>立刻</strong>刷回主存；</li>
<li>线程加锁前，必须<strong>读取主存</strong>中的最新值到工作内存中；</li>
<li>加锁和解锁是同一把锁；</li>
</ul>
<p>线程中分为 <strong>工作内存、主内存</strong></p>
<p><strong>8种操作</strong>：</p>
<ul>
<li><p><strong>Read（读取）</strong>：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；</p>
</li>
<li><p><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中；</p>
</li>
<li><p><strong>Use（使用）</strong>：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令；</p>
</li>
<li><p><strong>assign（赋值）</strong>：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中；</p>
</li>
<li><p><strong>store（存储）</strong>：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用；</p>
</li>
<li><p><strong>write（写入）</strong>：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；</p>
</li>
<li><p><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为线程独占状态；</p>
</li>
<li><p><strong>unlock（解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；</p>
</li>
</ul>
<p><img src="/2020/11/22/JUCStudy/fc90a45ebf58215709ae455e42df46a8.png" alt></p>
<p><img src="/2020/11/22/JUCStudy/be9ba7399d5a2031afe34b2b77e67313.png" alt></p>
<p><strong>JMM对这8种操作给了相应的规定</strong>：</p>
<ul>
<li><p>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write。</p>
</li>
<li><p>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存。</p>
</li>
<li><p>不允许一个线程将没有assign的数据从工作内存同步回主内存。</p>
</li>
<li><p>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作。</p>
</li>
<li><p>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁。lock和unlock必须成对出现。</p>
</li>
<li><p>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</p>
</li>
<li><p>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</p>
</li>
<li><p>对一个变量进行unlock操作之前，必须把此变量同步回主内存。</p>
</li>
</ul>
<p>遇到问题：<strong>程序不知道主存中的值已经被修改过了！；</strong></p>
<h2 id="17-volatile"><a href="#17-volatile" class="headerlink" title="17 volatile"></a>17 volatile</h2><h3 id="17-1-保证可见性"><a href="#17-1-保证可见性" class="headerlink" title="17.1 保证可见性"></a>17.1 保证可见性</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JMMDemo01</span> </span>&#123;

    <span class="hljs-comment">// 如果不加volatile 程序会死循环</span>
    <span class="hljs-comment">// 加了volatile是可以保证可见性的</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Integer number = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//main线程</span>
        <span class="hljs-comment">//子线程1</span>
        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
            <span class="hljs-keyword">while</span> (number==<span class="hljs-number">0</span>)&#123;
            &#125;
        &#125;).start();
        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-comment">//子线程2</span>
        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
            <span class="hljs-keyword">while</span> (number==<span class="hljs-number">0</span>)&#123;
            &#125;

        &#125;).start();
        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        number=<span class="hljs-number">1</span>;
        System.out.println(number);
    &#125;
&#125;</code></pre></div>

<h3 id="17-2-不保证原子性"><a href="#17-2-不保证原子性" class="headerlink" title="17.2 不保证原子性"></a>17.2 不保证原子性</h3><p>原子性：不可分割；</p>
<p>线程A在执行任务的时候，不能被打扰的，也不能被分割的，要么同时成功，要么同时失败。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 不保证原子性</span>
<span class="hljs-comment"> * number &lt;=2w</span>
<span class="hljs-comment"> * </span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VDemo02</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;
        number++; 
        <span class="hljs-comment">//++ 不是一个原子性操作，是两个~3个操作</span>
        <span class="hljs-comment">//</span>
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//理论上number  === 20000</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1000</span> ; j++) &#123;
                    add();
                &#125;
            &#125;).start();
        &#125;

        <span class="hljs-keyword">while</span> (Thread.activeCount()&gt;<span class="hljs-number">2</span>)&#123;
            <span class="hljs-comment">//main  gc</span>
            Thread.yield();
        &#125;
        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;,num=&quot;</span>+number);
    &#125;
&#125;</code></pre></div>

<p><strong>如果不加lock和synchronized ，怎么样保证原子性？</strong></p>
<p><img src="/2020/11/22/JUCStudy/db6345f3804fe7e529cdb71771c8e2f9.png" alt></p>
<p><strong>使用原子类</strong></p>
<p><img src="/2020/11/22/JUCStudy/2f3fbaf1a7d0705813f1388665cebfab.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VDemo02</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> AtomicInteger number = <span class="hljs-keyword">new</span> AtomicInteger();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;
<span class="hljs-comment">//        number++;</span>
        number.incrementAndGet();  <span class="hljs-comment">//底层是CAS保证的原子性</span>
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//理论上number  === 20000</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1000</span> ; j++) &#123;
                    add();
                &#125;
            &#125;).start();
        &#125;

        <span class="hljs-keyword">while</span> (Thread.activeCount()&gt;<span class="hljs-number">2</span>)&#123;
            <span class="hljs-comment">//main  gc</span>
            Thread.yield();
        &#125;
        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;,num=&quot;</span>+number);
    &#125;
&#125;</code></pre></div>

<p>这些类的底层都直接和操作系统挂钩！是在内存中修改值。</p>
<p>Unsafe类是一个很特殊的存在；</p>
<blockquote>
<p>  原子类为什么这么高级？</p>
</blockquote>
<h3 id="17-3-禁止指令重排"><a href="#17-3-禁止指令重排" class="headerlink" title="17.3 禁止指令重排"></a>17.3 禁止指令重排</h3><p><strong>什么是指令重排？</strong></p>
<p>我们写的程序，计算机并不是按照我们自己写的那样去执行的</p>
<p>源代码–&gt;编译器优化重排–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行</p>
<p><strong>处理器在进行指令重排的时候，会考虑数据之间的依赖性！</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>; <span class="hljs-comment">//1</span>
<span class="hljs-keyword">int</span> y=<span class="hljs-number">2</span>; <span class="hljs-comment">//2</span>
x=x+<span class="hljs-number">5</span>;   <span class="hljs-comment">//3</span>
y=x*x;   <span class="hljs-comment">//4</span>

<span class="hljs-comment">//我们期望的执行顺序是 1_2_3_4  可能执行的顺序会变成2134 1324</span>
<span class="hljs-comment">//可不可能是 4123？ 不可能的</span>
<span class="hljs-number">1234567</span></code></pre></div>

<p>可能造成的影响结果：前提：a b x y这四个值 默认都是0</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>x=a</td>
<td>y=b</td>
</tr>
<tr>
<td>b=1</td>
<td>a=2</td>
</tr>
</tbody></table>
<p>正常的结果： x = 0; y =0;</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>b=1</td>
<td>a=2</td>
</tr>
<tr>
<td>x=a</td>
<td>y=b</td>
</tr>
</tbody></table>
<p>可能在线程A中会出现，先执行b=1,然后再执行x=a；</p>
<p>在B线程中可能会出现，先执行a=2，然后执行y=b；</p>
<p>那么就有可能结果如下：x=2; y=1.</p>
<p><strong>volatile可以避免指令重排：</strong></p>
<p><strong>volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。</strong></p>
<p>内存屏障：CPU指令。作用：</p>
<ul>
<li><p>保证特定的操作的执行顺序；</p>
</li>
<li><p>可以保证某些变量的内存可见性（利用这些特性，就可以保证volatile实现的可见性）</p>
</li>
</ul>
<p><img src="/2020/11/22/JUCStudy/85fa53d83ee4f89d5a7202e9e5a98987.png" alt></p>
<h3 id="17-4-总结"><a href="#17-4-总结" class="headerlink" title="17.4 总结"></a>17.4 总结</h3><ul>
<li><strong>volatile可以保证可见性；</strong></li>
<li><strong>不能保证原子性</strong></li>
<li><strong>由于内存屏障，可以保证避免指令重排的现象产生</strong></li>
</ul>
<p>面试官：那么你知道在哪里用这个内存屏障用得最多呢？<strong>单例模式</strong></p>
<h2 id="18-玩转单例模式"><a href="#18-玩转单例模式" class="headerlink" title="18 玩转单例模式"></a>18 玩转单例模式</h2><p>饿汉式、DCL懒汉式</p>
<h3 id="18-1-饿汉式"><a href="#18-1-饿汉式" class="headerlink" title="18.1 饿汉式"></a>18.1 饿汉式</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 饿汉式单例</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hungry</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 可能会浪费空间</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] data1=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] data2=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] data3=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] data4=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];



    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Hungry</span><span class="hljs-params">()</span></span>&#123;

    &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Hungry hungry = <span class="hljs-keyword">new</span> Hungry();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Hungry <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> hungry;
    &#125;

&#125;</code></pre></div>

<h3 id="18-2-DCL懒汉式"><a href="#18-2-DCL懒汉式" class="headerlink" title="18.2 DCL懒汉式"></a>18.2 DCL懒汉式</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//懒汉式单例模式</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyMan</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> key = <span class="hljs-keyword">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazyMan</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">synchronized</span> (LazyMan.class)&#123;
            <span class="hljs-keyword">if</span> (key==<span class="hljs-keyword">false</span>)&#123;
                key=<span class="hljs-keyword">true</span>;
            &#125;
            <span class="hljs-keyword">else</span>&#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;不要试图使用反射破坏异常&quot;</span>);
            &#125;
        &#125;
        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; ok&quot;</span>);
    &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> LazyMan lazyMan;

    <span class="hljs-comment">//双重检测锁模式 简称DCL懒汉式</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-comment">//需要加锁</span>
        <span class="hljs-keyword">if</span>(lazyMan==<span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">synchronized</span> (LazyMan.class)&#123;
                <span class="hljs-keyword">if</span>(lazyMan==<span class="hljs-keyword">null</span>)&#123;
                    lazyMan=<span class="hljs-keyword">new</span> LazyMan();
                    <span class="hljs-comment">/**</span>
<span class="hljs-comment">                     * 1、分配内存空间</span>
<span class="hljs-comment">                     * 2、执行构造方法，初始化对象</span>
<span class="hljs-comment">                     * 3、把这个对象指向这个空间</span>
<span class="hljs-comment">                     *</span>
<span class="hljs-comment">                     *  就有可能出现指令重排问题</span>
<span class="hljs-comment">                     *  比如执行的顺序是1 3 2 等</span>
<span class="hljs-comment">                     *  我们就可以添加volatile保证指令重排问题</span>
<span class="hljs-comment">                     */</span>
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> lazyMan;
    &#125;
    <span class="hljs-comment">//单线程下 是ok的</span>
    <span class="hljs-comment">//但是如果是并发的</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;
        <span class="hljs-comment">//Java中有反射</span>
<span class="hljs-comment">//        LazyMan instance = LazyMan.getInstance();</span>
        Field key = LazyMan.class.getDeclaredField(<span class="hljs-string">&quot;key&quot;</span>);
        key.setAccessible(<span class="hljs-keyword">true</span>);
        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(<span class="hljs-keyword">null</span>);
        declaredConstructor.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//无视了私有的构造器</span>
        LazyMan lazyMan1 = declaredConstructor.newInstance();
        key.set(lazyMan1,<span class="hljs-keyword">false</span>);
        LazyMan instance = declaredConstructor.newInstance();

        System.out.println(instance);
        System.out.println(lazyMan1);
        System.out.println(instance == lazyMan1);
    &#125;
&#125;</code></pre></div>

<h3 id="18-3-静态内部类"><a href="#18-3-静态内部类" class="headerlink" title="18.3 静态内部类"></a>18.3 静态内部类</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//静态内部类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Holder</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Holder</span><span class="hljs-params">()</span></span>&#123;

    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Holder <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> InnerClass.holder;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span></span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Holder holder = <span class="hljs-keyword">new</span> Holder();
    &#125;
&#125;</code></pre></div>

<blockquote>
<p>  单例不安全, 因为反射</p>
</blockquote>
<h3 id="18-4-枚举"><a href="#18-4-枚举" class="headerlink" title="18.4 枚举"></a>18.4 枚举</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//enum 是什么？ enum本身就是一个Class 类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnumSingle</span> </span>&#123;
    INSTANCE;
    <span class="hljs-function"><span class="hljs-keyword">public</span> EnumSingle <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> INSTANCE;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;
        EnumSingle instance1 = EnumSingle.INSTANCE;
        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,<span class="hljs-keyword">int</span>.class);
        declaredConstructor.setAccessible(<span class="hljs-keyword">true</span>);
        <span class="hljs-comment">//java.lang.NoSuchMethodException: com.ogj.single.EnumSingle.&lt;init&gt;()</span>

        EnumSingle instance2 = declaredConstructor.newInstance();
        System.out.println(instance1);
        System.out.println(instance2);
    &#125;
&#125;</code></pre></div>

<p>使用枚举，我们就可以防止反射破坏了。</p>
<p><img src="/2020/11/22/JUCStudy/8d1a2e29d5ae9bb9421ee94ed7468f89.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnumSingle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span></span>
<span class="hljs-class"></span>&#123;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EnumSingle[] values()
    &#123;
        <span class="hljs-keyword">return</span> (EnumSingle[])$VALUES.clone();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EnumSingle <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> (EnumSingle)Enum.valueOf(com/ogj/single/EnumSingle, name);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">EnumSingle</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> i)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">super</span>(s, i);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> EnumSingle <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> INSTANCE;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EnumSingle INSTANCE;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EnumSingle $VALUES[];

    <span class="hljs-keyword">static</span> 
    &#123;
        INSTANCE = <span class="hljs-keyword">new</span> EnumSingle(<span class="hljs-string">&quot;INSTANCE&quot;</span>, <span class="hljs-number">0</span>);
        $VALUES = (<span class="hljs-keyword">new</span> EnumSingle[] &#123;
            INSTANCE
        &#125;);
    &#125;
&#125;</code></pre></div>

<h2 id="19-深入理解CAS"><a href="#19-深入理解CAS" class="headerlink" title="19 深入理解CAS"></a>19 深入理解CAS</h2><h3 id="19-1-什么是CAS？"><a href="#19-1-什么是CAS？" class="headerlink" title="19.1 什么是CAS？"></a>19.1 什么是CAS？</h3><p>大厂必须深入研究底层！！！！<strong>修内功！操作系统、计算机网络原理、组成原理、数据结构</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CasDemo</span> </span>&#123;
    <span class="hljs-comment">//CAS : compareAndSet 比较并交换</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">2020</span>);

        <span class="hljs-comment">//boolean compareAndSet(int expect, int update)</span>
        <span class="hljs-comment">//期望值、更新值</span>
        <span class="hljs-comment">//如果实际值 和 我的期望值相同，那么就更新</span>
        <span class="hljs-comment">//如果实际值 和 我的期望值不同，那么就不更新</span>
        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">2020</span>, <span class="hljs-number">2021</span>));
        System.out.println(atomicInteger.get());

        <span class="hljs-comment">//因为期望值是2020  实际值却变成了2021  所以会修改失败</span>
        <span class="hljs-comment">//CAS 是CPU的并发原语</span>
        atomicInteger.getAndIncrement(); <span class="hljs-comment">//++操作</span>
        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">2020</span>, <span class="hljs-number">2021</span>));
        System.out.println(atomicInteger.get());
    &#125;
&#125;</code></pre></div>

<p>Unsafe 类</p>
<p><img src="/2020/11/22/JUCStudy/1f7d8e96f4dabb579a5e71b4a06fde1f.png" alt></p>
<p><img src="/2020/11/22/JUCStudy/3af68de48cb80b17736da32d22b67af5.png" alt></p>
<h3 id="19-2-总结"><a href="#19-2-总结" class="headerlink" title="19.2 总结"></a>19.2 总结</h3><p>CAS：比较当前工作内存中的值 和 主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环，使用的是自旋锁。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>循环会耗时；</li>
<li>一次性只能保证一个共享变量的原子性；</li>
<li>它会存在ABA问题</li>
</ul>
<blockquote>
<p>  CAS：ABA问题？(狸猫换太子)</p>
</blockquote>
<p><img src="/2020/11/22/JUCStudy/4b9db8d951df5271f214561766442910.png" alt></p>
<p>线程1：期望值是1，要变成2；</p>
<p>线程2：两个操作：</p>
<ul>
<li>1、期望值是1，变成3</li>
<li>2、期望是3，变成1</li>
</ul>
<p>所以对于线程1来说，A的值还是1，所以就出现了问题，骗过了线程1；</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">casDemo</span> </span>&#123;
    <span class="hljs-comment">//CAS : compareAndSet 比较并交换</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">2020</span>);

        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">2020</span>, <span class="hljs-number">2021</span>));
        System.out.println(atomicInteger.get());

        <span class="hljs-comment">//boolean compareAndSet(int expect, int update)</span>
        <span class="hljs-comment">//期望值、更新值</span>
        <span class="hljs-comment">//如果实际值 和 我的期望值相同，那么就更新</span>
        <span class="hljs-comment">//如果实际值 和 我的期望值不同，那么就不更新</span>
        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">2021</span>, <span class="hljs-number">2020</span>));
        System.out.println(atomicInteger.get());

        <span class="hljs-comment">//因为期望值是2020  实际值却变成了2021  所以会修改失败</span>
        <span class="hljs-comment">//CAS 是CPU的并发原语</span>
<span class="hljs-comment">//        atomicInteger.getAndIncrement(); //++操作</span>
        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">2020</span>, <span class="hljs-number">2021</span>));
        System.out.println(atomicInteger.get());
    &#125;
&#125;</code></pre></div>

<h2 id="20-原子引用"><a href="#20-原子引用" class="headerlink" title="20 原子引用"></a>20 原子引用</h2><blockquote>
<p>  解决ABA问题，对应的思想：就是使用了<strong>乐观锁~</strong></p>
</blockquote>
<p>带版本号的 原子操作！</p>
<p><strong>Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。</strong></p>
<p><img src="/2020/11/22/JUCStudy/f0fa8dc692d7e89523bc334bebc58f15.png" alt></p>
<p><strong>带版本号的原子操作</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.marchsoft.lockdemo;

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASDemo</span> </span>&#123;
    <span class="hljs-comment">/**AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题</span>
<span class="hljs-comment">     * 正常在业务操作，这里面比较的都是一个个对象</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span>
            AtomicStampedReference&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);

    <span class="hljs-comment">// CAS compareAndSet : 比较并交换！</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp(); <span class="hljs-comment">// 获得版本号</span>
            System.out.println(<span class="hljs-string">&quot;a1=&gt;&quot;</span> + stamp);
            
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-comment">// 修改操作时，版本号更新 + 1</span>
            atomicStampedReference.compareAndSet(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>,
                    atomicStampedReference.getStamp(),
                    atomicStampedReference.getStamp() + <span class="hljs-number">1</span>);
            
            System.out.println(<span class="hljs-string">&quot;a2=&gt;&quot;</span> + atomicStampedReference.getStamp());
            <span class="hljs-comment">// 重新把值改回去， 版本号更新 + 1</span>
            System.out.println(atomicStampedReference.compareAndSet(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>,
                    atomicStampedReference.getStamp(),
                    atomicStampedReference.getStamp() + <span class="hljs-number">1</span>));
            System.out.println(<span class="hljs-string">&quot;a3=&gt;&quot;</span> + atomicStampedReference.getStamp());
        &#125;, <span class="hljs-string">&quot;a&quot;</span>).start();
        
        <span class="hljs-comment">// 乐观锁的原理相同！</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp(); <span class="hljs-comment">// 获得版本号</span>
            System.out.println(<span class="hljs-string">&quot;b1=&gt;&quot;</span> + stamp);
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(atomicStampedReference.compareAndSet(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>,
                    stamp, stamp + <span class="hljs-number">1</span>));
            System.out.println(<span class="hljs-string">&quot;b2=&gt;&quot;</span> + atomicStampedReference.getStamp());
        &#125;, <span class="hljs-string">&quot;b&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<h2 id="21-各种锁的理解"><a href="#21-各种锁的理解" class="headerlink" title="21 各种锁的理解"></a>21 各种锁的理解</h2><h3 id="21-1-公平锁，非公平锁"><a href="#21-1-公平锁，非公平锁" class="headerlink" title="21.1 公平锁，非公平锁"></a>21.1 公平锁，非公平锁</h3><ol>
<li><p>公平锁：非常公平，不能插队，必须先来后到</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Creates an instance of &#123;<span class="hljs-doctag">@code</span> ReentrantLock&#125;.</span>
<span class="hljs-comment"> * This is equivalent to using &#123;<span class="hljs-doctag">@code</span> ReentrantLock(false)&#125;.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;
    sync = <span class="hljs-keyword">new</span> NonfairSync();
&#125;</code></pre></div>
</li>
<li><p>非公平锁：非常不公平，允许插队，可以改变顺序</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Creates an instance of &#123;<span class="hljs-doctag">@code</span> ReentrantLock&#125; with the</span>
<span class="hljs-comment"> * given fairness policy.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fair &#123;<span class="hljs-doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;
    sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();
&#125;</code></pre></div>

</li>
</ol>
<h3 id="21-2-可重入锁"><a href="#21-2-可重入锁" class="headerlink" title="21.2 可重入锁"></a>21.2 可重入锁</h3><p><img src="/2020/11/22/JUCStudy/7d4760ea79ea1da834c16e04f6ae5c0d.png" alt></p>
<ol>
<li><p>Synchonized 锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Phone phone = <span class="hljs-keyword">new</span> Phone();
        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
            phone.sms();
        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();
        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
            phone.sms();
        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();
    &#125;

&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sms</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;=&gt; sms&quot;</span>);
        call();<span class="hljs-comment">//这里也有一把锁</span>
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;=&gt; call&quot;</span>);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>Lock 锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//lock</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Phone2 phone = <span class="hljs-keyword">new</span> Phone2();
        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
            phone.sms();
        &#125;,<span class="hljs-string">&quot;A&quot;</span>).start();
        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
            phone.sms();
        &#125;,<span class="hljs-string">&quot;B&quot;</span>).start();
    &#125;

&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone2</span></span>&#123;

    Lock lock=<span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sms</span><span class="hljs-params">()</span></span>&#123;
        lock.lock(); <span class="hljs-comment">//细节：这个是两把锁，两个钥匙</span>
        <span class="hljs-comment">//lock锁必须配对，否则就会死锁在里面</span>
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;=&gt; sms&quot;</span>);
            call();<span class="hljs-comment">//这里也有一把锁</span>
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;=&gt; call&quot;</span>);
        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;
            e.printStackTrace();
        &#125;
        <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
       &#125;
    &#125;
&#125;</code></pre></div>

<ul>
<li>lock锁必须配对，相当于lock和 unlock 必须数量相同；</li>
<li>在外面加的锁，也可以在里面解锁；在里面加的锁，在外面也可以解锁；</li>
</ul>
</li>
</ol>
<h3 id="21-3-自旋锁"><a href="#21-3-自旋锁" class="headerlink" title="21.3 自旋锁"></a>21.3 自旋锁</h3><ol>
<li><p>spinlock</p>
<div class="code-wrapper"><pre><code class="hljs javascript">public final int <span class="hljs-function"><span class="hljs-title">getAndAddInt</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> var1, long var2, int var4</span>)</span> &#123;
    int var5;
    <span class="hljs-keyword">do</span> &#123;
        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);
    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));
    <span class="hljs-keyword">return</span> var5;
&#125;</code></pre></div>
</li>
<li><p>自我设计自旋锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinlockDemo</span> </span>&#123;

    <span class="hljs-comment">// 默认</span>
    <span class="hljs-comment">// int 0</span>
    <span class="hljs-comment">//thread null</span>
    AtomicReference&lt;Thread&gt; atomicReference=<span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();

    <span class="hljs-comment">//加锁</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myLock</span><span class="hljs-params">()</span></span>&#123;
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName()+<span class="hljs-string">&quot;===&gt; mylock&quot;</span>);

        <span class="hljs-comment">//自旋锁</span>
        <span class="hljs-keyword">while</span> (!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>,thread))&#123;
            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; ==&gt; 自旋中~&quot;</span>);
        &#125;
    &#125;


    <span class="hljs-comment">//解锁</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myUnlock</span><span class="hljs-params">()</span></span>&#123;
        Thread thread=Thread.currentThread();
        System.out.println(thread.getName()+<span class="hljs-string">&quot;===&gt; myUnlock&quot;</span>);
        atomicReference.compareAndSet(thread,<span class="hljs-keyword">null</span>);
    &#125;

&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSpinLock</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        ReentrantLock reentrantLock = <span class="hljs-keyword">new</span> ReentrantLock();
        reentrantLock.lock();
        reentrantLock.unlock();


        <span class="hljs-comment">//使用CAS实现自旋锁</span>
        SpinlockDemo spinlockDemo=<span class="hljs-keyword">new</span> SpinlockDemo();
        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
            spinlockDemo.myLock();
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125; <span class="hljs-keyword">finally</span> &#123;
                spinlockDemo.myUnlock();
            &#125;
        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();

        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);


        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;
            spinlockDemo.myLock();
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125; <span class="hljs-keyword">finally</span> &#123;
                spinlockDemo.myUnlock();
            &#125;
        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p>运行结果：</p>
<p><strong>t2进程必须等待t1进程Unlock后，才能Unlock，在这之前进行自旋等待。。</strong></p>
</li>
</ol>
<h3 id="21-4-死锁"><a href="#21-4-死锁" class="headerlink" title="21.4 死锁"></a>21.4 死锁</h3><p><img src="/2020/11/22/JUCStudy/707c1f0130ce66a3ecb13ca178a881cc.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ogj.lock;

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        String lockA= <span class="hljs-string">&quot;lockA&quot;</span>;
        String lockB= <span class="hljs-string">&quot;lockB&quot;</span>;

        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread(lockA,lockB),<span class="hljs-string">&quot;t1&quot;</span>).start();
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread(lockB,lockA),<span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;

    <span class="hljs-keyword">private</span> String lockA;
    <span class="hljs-keyword">private</span> String lockB;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String lockA, String lockB)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.lockA = lockA;
        <span class="hljs-keyword">this</span>.lockB = lockB;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">synchronized</span> (lockA)&#123;
            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; lock&quot;</span>+lockA+<span class="hljs-string">&quot;===&gt;get&quot;</span>+lockB);
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-keyword">synchronized</span> (lockB)&#123;
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; lock&quot;</span>+lockB+<span class="hljs-string">&quot;===&gt;get&quot;</span>+lockA);
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>如何解开死锁</p>
<ol>
<li><p><strong>使用jps定位进程号，jdk的bin目录下： 有一个jps</strong></p>
<p>命令：<code>jps -l</code></p>
<p><img src="/2020/11/22/JUCStudy/32b977206fd43d9cd67cf7bf432b13e6.png" alt></p>
</li>
<li><p><strong>使用<code>jstack</code> 进程进程号 找到死锁信息</strong></p>
<p><img src="/2020/11/22/JUCStudy/e56c37006badbc1bbbae99dba5438172.png" alt></p>
<p><strong>一般情况信息在最后：</strong></p>
<p><img src="/2020/11/22/JUCStudy/814d63935d3d21ed799afcc2eccd20c9.png" alt></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Tool</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 学习</title>
    <url>/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Redis-学习"><a href="#Redis-学习" class="headerlink" title="Redis 学习"></a>Redis 学习</h1><h2 id="1-Nosql-概述"><a href="#1-Nosql-概述" class="headerlink" title="1  Nosql 概述"></a>1  Nosql 概述</h2><h3 id="1-1-为什么要使用-Nosql"><a href="#1-1-为什么要使用-Nosql" class="headerlink" title="1.1 为什么要使用 Nosql"></a>1.1 为什么要使用 Nosql</h3><blockquote>
<p>  1、单机Mysql时代</p>
</blockquote>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020082010365930.png" alt></p>
<p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题</p>
<ol>
<li>数据量增加到一定程度，单机数据库就放不下了</li>
<li>数据的索引（B+ Tree）,一个机器内存也存放不下</li>
<li>访问量变大后（读写混合），一台服务器承受不住。</li>
</ol>
<blockquote>
<p>  2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）</p>
</blockquote>
<p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103713734.png" alt></p>
<p>优化过程经历了以下几个过程：</p>
<p>优化数据库的数据结构和索引(难度大)</p>
<p>文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</p>
<p>MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</p>
<blockquote>
<p>  3、分库分表 + 水平拆分 + Mysql集群</p>
</blockquote>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103739584.png" alt></p>
<blockquote>
<p>  4、如今最近的年代</p>
</blockquote>
<p>如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。</p>
<h3 id="1-2-什么是-Nosql"><a href="#1-2-什么是-Nosql" class="headerlink" title="1.2 什么是 Nosql"></a>1.2 什么是 Nosql</h3><p><strong>NoSQL = Not Only SQL（不仅仅是SQL）</strong></p>
<p>Not Only Structured Query Language</p>
<p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p>
<p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p>
<p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p>
<h3 id="1-3-Nosql-特点"><a href="#1-3-Nosql-特点" class="headerlink" title="1.3 Nosql 特点"></a>1.3 Nosql 特点</h3><ol>
<li><p>方便扩展（数据之间没有关系，很好扩展！）</p>
</li>
<li><p>大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p>
</li>
<li><p>数据类型是多样型的！（不需要事先设计数据库，随取随用）</p>
</li>
<li><p>传统的 RDBMS 和 NoSQL</p>
<div class="code-wrapper"><pre><code class="hljs asciidoc">传统的 RDBMS(关系型数据库)
<span class="hljs-bullet">- </span>结构化组织
<span class="hljs-bullet">- </span>SQL
<span class="hljs-bullet">- </span>数据和关系都存在单独的表中 row col
<span class="hljs-bullet">- </span>操作，数据定义语言
<span class="hljs-bullet">- </span>严格的一致性
<span class="hljs-bullet">- </span>基础的事务
<span class="hljs-bullet">- </span>...</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs asciidoc">Nosql
<span class="hljs-bullet">- </span>不仅仅是数据
<span class="hljs-bullet">- </span>没有固定的查询语言
<span class="hljs-bullet">- </span>键值对存储，列存储，文档存储，图形数据库（社交关系）
<span class="hljs-bullet">- </span>最终一致性
<span class="hljs-bullet">- </span>CAP定理和BASE
<span class="hljs-bullet">- </span>高性能，高可用，高扩展
<span class="hljs-bullet">- </span>...</code></pre></div>

</li>
</ol>
<blockquote>
<p>  了解：3V + 3高</p>
</blockquote>
<p>大数据时代的3V ：主要是<strong>描述问题</strong>的</p>
<ol>
<li>海量Velume</li>
<li>多样Variety</li>
<li>实时Velocity</li>
</ol>
<p>大数据时代的3高 ： 主要是<strong>对程序的要求</strong></p>
<ol>
<li>高并发</li>
<li>高可扩</li>
<li>高性能</li>
</ol>
<p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p>
<h3 id="1-4-阿里巴巴演进分析"><a href="#1-4-阿里巴巴演进分析" class="headerlink" title="1.4 阿里巴巴演进分析"></a>1.4 阿里巴巴演进分析</h3><p>推荐阅读：阿里云的这群疯子<a href="https://yq.aliyun.com/articles/653511">https://yq.aliyun.com/articles/653511</a></p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103829446.png" alt></p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103851613.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 商品信息</span>
<span class="hljs-bullet">-</span> 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。

<span class="hljs-section"># 商品描述、评论(文字居多)</span>
<span class="hljs-bullet">-</span> 文档型数据库：MongoDB

<span class="hljs-section"># 图片</span>
<span class="hljs-bullet">-</span> 分布式文件系统 FastDFS
<span class="hljs-bullet">-</span> 淘宝：TFS
<span class="hljs-bullet">-</span> Google: GFS
<span class="hljs-bullet">-</span> Hadoop: HDFS
<span class="hljs-bullet">-</span> 阿里云: oss

<span class="hljs-section"># 商品关键字 用于搜索</span>
<span class="hljs-bullet">-</span> 搜索引擎：solr,elasticsearch
<span class="hljs-bullet">-</span> 阿里：Isearch 多隆

<span class="hljs-section"># 商品热门的波段信息</span>
<span class="hljs-bullet">-</span> 内存数据库：Redis，Memcache

<span class="hljs-section"># 商品交易，外部支付接口</span>
<span class="hljs-bullet">-</span> 第三方应用</code></pre></div>

<h3 id="1-5-Nosql-的四大分类"><a href="#1-5-Nosql-的四大分类" class="headerlink" title="1.5 Nosql 的四大分类"></a>1.5 Nosql 的四大分类</h3><blockquote>
<p>  <strong>KV键值对</strong></p>
</blockquote>
<ul>
<li>新浪：<strong>Redis</strong></li>
<li>美团：Redis + Tair</li>
<li>阿里、百度：Redis + Memcache</li>
</ul>
<blockquote>
<p>  <strong>文档型数据库（bson数据格式）：</strong></p>
</blockquote>
<ul>
<li><strong>MongoDB</strong>(掌握)<ul>
<li>基于分布式文件存储的数据库。C++编写，用于处理大量文档。</li>
<li>MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。</li>
</ul>
</li>
<li>ConthDB</li>
</ul>
<blockquote>
<p>  <strong>列存储数据库</strong></p>
</blockquote>
<ul>
<li><strong>HBase</strong>(大数据必学)</li>
<li>分布式文件系统</li>
</ul>
<blockquote>
<p>  <strong>图关系数据库</strong></p>
</blockquote>
<p>用于广告推荐，社交网络</p>
<ul>
<li><strong>Neo4j</strong>、InfoGrid</li>
</ul>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210512004919811.png" alt></p>
<h2 id="2-redis-入门"><a href="#2-redis-入门" class="headerlink" title="2 redis 入门"></a>2 redis 入门</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1  概述"></a>1  概述</h3><ul>
<li><p>Redis是什么？</p>
<ul>
<li><p>Redis（Remote Dictionary Server )，即远程字典服务。</p>
</li>
<li><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
</li>
<li><p>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
</li>
</ul>
</li>
<li><p>Redis能该干什么？</p>
<ul>
<li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li>
<li>高效率、用于高速缓冲</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器(eg：浏览量)</li>
</ul>
</li>
<li><p>特性</p>
<ul>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
</ul>
</li>
</ul>
<h3 id="1-2-环境搭建"><a href="#1-2-环境搭建" class="headerlink" title="1.2 环境搭建"></a>1.2 环境搭建</h3><p>官网：<a href="https://redis.io/">https://redis.io/</a></p>
<p>推荐使用Linux服务器学习。</p>
<p>windows版本的Redis已经停更很久了</p>
<h3 id="1-3-windows-安装"><a href="#1-3-windows-安装" class="headerlink" title="1.3 windows 安装"></a>1.3 windows 安装</h3><p><a href="https://github.com/dmajkic/redis">https://github.com/dmajkic/redis</a></p>
<ul>
<li><p>解压安装包</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103922318.png" alt></p>
</li>
<li><p>开启redis-server.exe</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103950934.png" alt></p>
</li>
<li><p>启动redis-cli.exe测试</p>
</li>
</ul>
<h3 id="1-4-Linux-安装"><a href="#1-4-Linux-安装" class="headerlink" title="1.4 Linux 安装"></a>1.4 Linux 安装</h3><ul>
<li><p>下载安装包！<code>redis-5.0.8.tar.gz</code></p>
</li>
<li><p>解压Redis的安装包！程序一般放在 <code>/usr/local/redis</code> 目录下</p>
</li>
<li><p>基本环境安装</p>
<div class="code-wrapper"><pre><code class="hljs shell">yum install gcc-c++
<span class="hljs-meta">#</span><span class="bash"> 然后进入redis目录下执行</span>
make
<span class="hljs-meta">#</span><span class="bash"> 然后执行</span>
make install</code></pre></div>

<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104048327.png" alt></p>
</li>
<li><p>将 REDIS 安装为系统服务并后台启动</p>
<div class="code-wrapper"><pre><code class="hljs shell">[root@localhost redis-5.0.8]# cd utils/ [root@localhost utils]# ./install_server.sh</code></pre></div>

<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214319345.png" alt></p>
</li>
<li><p>查看REDIS服务启动情况</p>
<div class="code-wrapper"><pre><code class="hljs shell">systemctl status redis_6379.service</code></pre></div>



</li>
</ul>
<h3 id="1-5-测试性能"><a href="#1-5-测试性能" class="headerlink" title="1.5 测试性能"></a>1.5 测试性能</h3><ul>
<li><p>启动REDIS客户端并测试</p>
<div class="code-wrapper"><pre><code class="hljs shell">redis-cli</code></pre></div>

<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214531489.png" alt></p>
</li>
<li><p>设置允许远程连接</p>
<div class="code-wrapper"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>redis/<span class="hljs-number">6379</span>.conf</code></pre></div>

<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214552849-1621086353677.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell">systemctl restart redis_6379.service</code></pre></div>
</li>
<li><p>设置访问密码</p>
<div class="code-wrapper"><pre><code class="hljs shell">vim /etc/redis/6379.conf</code></pre></div>

<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214651751.png" alt></p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214712651.png" alt></p>
</li>
<li><p>redis-benchmark：Redis官方提供的性能测试工具，参数选项如下：</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214125892.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试：100个并发连接 100000请求</span>
redis-benchmark -h localhost -p 6379 -c 100 -n 100000</code></pre></div>

<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104343472.png" alt></p>
</li>
</ul>
<h3 id="1-6-基础知识"><a href="#1-6-基础知识" class="headerlink" title="1.6 基础知识"></a>1.6 基础知识</h3><ul>
<li><p>redis默认有16个数据库</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104357466.png" alt></p>
<p>默认使用的第0个;</p>
<p>16个数据库为：DB 0~DB 15<br>默认使用DB 0 ，可以使用<code>select n</code>切换到DB n，<code>dbsize</code>可以查看当前数据库的大小，与key数量相关。</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; config get databases # 命令行查看数据库数量databases
1) &quot;databases&quot;
2) &quot;16&quot;

127.0.0.1:6379&gt; select 8 # 切换数据库 DB 8
OK
127.0.0.1:6379[8]&gt; dbsize # 查看数据库大小
(integer) 0

<span class="hljs-meta">#</span><span class="bash"> 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。</span>
127.0.0.1:6379&gt; set name sakura 
OK
127.0.0.1:6379&gt; SELECT 8
OK
127.0.0.1:6379[8]&gt; get name # db8中并不能获取db0中的键值对。
(nil)
127.0.0.1:6379[8]&gt; DBSIZE
(integer) 0
127.0.0.1:6379[8]&gt; SELECT 0
OK
127.0.0.1:6379&gt; keys *
1) &quot;counter:__rand_int__&quot;
2) &quot;mylist&quot;
3) &quot;name&quot;
4) &quot;key:__rand_int__&quot;
5) &quot;myset:__rand_int__&quot;
127.0.0.1:6379&gt; DBSIZE # size和key个数相关
(integer) 5</code></pre></div>

<p><code>keys *</code> ：查看当前数据库中所有的key。</p>
<p><code>flushdb</code>：清空当前数据库中的键值对。</p>
<p><code>flushall</code>：清空所有数据库的键值对。</p>
</li>
<li><p><strong>Redis是单线程的，Redis是基于内存操作的。</strong></p>
<ul>
<li>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</li>
<li>那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+</li>
</ul>
</li>
<li><p><strong>Redis为什么单线程还这么快</strong></p>
<ul>
<li>误区1：高性能的服务器一定是多线程的？</li>
<li>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</li>
<li>核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</li>
</ul>
</li>
</ul>
<h2 id="3-五大数据类型"><a href="#3-五大数据类型" class="headerlink" title="3 五大数据类型"></a>3 五大数据类型</h2><p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>
<h3 id="3-1-Redis-key"><a href="#3-1-Redis-key" class="headerlink" title="3.1 Redis-key"></a>3.1 Redis-key</h3><p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p>
<p>下面学习的命令：</p>
<ul>
<li><p><code>exists key</code>：判断键是否存在</p>
</li>
<li><p><code>del key</code>：删除键值对</p>
</li>
<li><p><code>move key db</code>：将键值对移动到指定数据库</p>
</li>
<li><p><code>expire key second</code>：设置键值对的过期时间</p>
</li>
<li><p><code>type key</code>：查看value的数据类型</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; keys * # 查看当前数据库所有key
(empty list or set)
127.0.0.1:6379&gt; set name qinjiang # set key
OK
127.0.0.1:6379&gt; set age 20
OK
127.0.0.1:6379&gt; keys *
1) &quot;age&quot;
2) &quot;name&quot;
127.0.0.1:6379&gt; move age 1 # 将键值对移动到指定数据库
(integer) 1
127.0.0.1:6379&gt; EXISTS age # 判断键是否存在
(integer) 0 # 不存在
127.0.0.1:6379&gt; EXISTS name
(integer) 1 # 存在
127.0.0.1:6379&gt; SELECT 1
OK
127.0.0.1:6379[1]&gt; keys *
1) &quot;age&quot;
127.0.0.1:6379[1]&gt; del age # 删除键值对
(integer) 1 # 删除个数
127.0.0.1:6379&gt; set age 20

OK

127.0.0.1:6379&gt; EXPIRE age 15 # 设置键值对的过期时间


(integer) 1 # 设置成功 开始计数

127.0.0.1:6379&gt; ttl age # 查看key的过期剩余时间

(integer) 13

127.0.0.1:6379&gt; ttl age

(integer) 11

127.0.0.1:6379&gt; ttl age

(integer) 9

127.0.0.1:6379&gt; ttl age

(integer) -2 # -2 表示key过期，-1表示key未设置过期时间


127.0.0.1:6379&gt; get age # 过期的key 会被自动delete

(nil)

127.0.0.1:6379&gt; keys *



&quot;name&quot;


127.0.0.1:6379&gt; type name # 查看value的数据类型

string</code></pre></div>
</li>
<li><p>关于TTL命令</p>
</li>
<li><p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p>
<ul>
<li>当前key没有设置过期时间，所以会返回-1.</li>
<li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li>
<li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li>
</ul>
</li>
<li><p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p>
<ul>
<li><code>RENAME key newkey</code>修改 key 的名称</li>
<li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li>
</ul>
</li>
</ul>
<h3 id="3-2-String"><a href="#3-2-String" class="headerlink" title="3.2 String"></a>3.2 String</h3><p>普通的set、get直接略过。</p>
<p>常用命令及其示例：</p>
<p><code>APPEND key value</code>: 向指定的key的value后追加字符串</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set msg hello 
OK 
127.0.0.1:6379&gt; append msg &quot; world&quot; 
(integer) 11 
127.0.0.1:6379&gt; get msg 
“hello world”</code></pre></div>

<p><code>DECR/INCR key</code>: 将指定key的value数值进行+1/-1(仅对于数字)</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set age 20 
OK 
127.0.0.1:6379&gt; incr age 
(integer) 21 
127.0.0.1:6379&gt; decr age 
(integer) 20</code></pre></div>

<p><code>INCRBY/DECRBY key n</code>: 按指定的步长对数值进行加减</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; INCRBY age 5
(integer) 25 
127.0.0.1:6379&gt; DECRBY age 10 
(integer) 15</code></pre></div>

<p><code>INCRBYFLOAT key n</code>: 为数值加上浮点型数值</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 
“20.2”</code></pre></div>

<p><code>STRLEN key</code>: 获取key保存值的字符串长度</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; get msg 
“hello world” 
127.0.0.1:6379&gt; STRLEN msg 
(integer) 11</code></pre></div>

<p><code>GETRANGE key start end</code>: 按起止位置获取字符串（闭区间，起止位置都取）</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; get msg 
“hello world” 
127.0.0.1:6379&gt; GETRANGE msg 3 9 
“lo worl”</code></pre></div>

<p><code>SETRANGE key offset value</code>:用指定的value 替换key中 offset开始的值</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set msg hello
OK
127.0.0.1:6379&gt; setrange msg 2 hello
(integer) 7
127.0.0.1:6379&gt; get msg
&quot;hehello&quot;
127.0.0.1:6379&gt; set msg2 world
OK
127.0.0.1:6379&gt; setrange msg2 2 ww
(integer) 5
127.0.0.1:6379&gt; get msg2
&quot;wowwd&quot;</code></pre></div>

<p><code>GETSET key value</code>: 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; GETSET msg test 
“hello world”</code></pre></div>

<p><code>SETNX key value</code>: 仅当key不存在时进行set</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; SETNX msg test 
(integer) 0 
127.0.0.1:6379&gt; SETNX name sakura 
(integer) 1</code></pre></div>

<p><code>SETEX key seconds value</code>: set 键值对并设置过期时间</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; setex name 10 root 
OK 
127.0.0.1:6379&gt; get name 
(nil)</code></pre></div>

<p><code>MSET key1 value1 [key2 value2..]</code>: 批量set键值对</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 
OK</code></pre></div>

<p><code>MSETNX key1 value1 [key2 value2..]</code>: 批量设置键值对，仅当参数中所有的key都不存在时执行</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 
(integer) 0</code></pre></div>

<p><code>MGET key1 [key2..]</code>: 批量获取多个key保存的值</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; MGET k1 k2 k3 
1) “v1” 
2) “v2” 
3) “v3”</code></pre></div>

<p><code>PSETEX key milliseconds value</code>: 和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间</p>
<p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量：uid:123666：follow 0</li>
<li>粉丝数</li>
<li>对象存储缓存</li>
</ul>
<h3 id="3-3-List"><a href="#3-3-List" class="headerlink" title="3.3 List"></a>3.3 List</h3><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
<p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等。</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104440398.png" alt></p>
<p>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p>
<ul>
<li><code>LPUSH/RPUSH key value1[value2..]</code>从左边/右边向列表中PUSH值(一个或者多个)。</li>
<li><code>LRANGE key start end</code> 获取list 起止元素== （索引从左往右 递增）==</li>
<li><code>LPUSHX/RPUSHX key value</code> 向已存在的列名中push值（一个或者多个）</li>
<li><code>LINSERT key BEFORE|AFTER pivot value</code> 在指定列表元素的前/后 插入value</li>
<li><code>LLEN key</code> 查看列表长度</li>
<li><code>LINDEX key index</code> 通过索引获取列表元素</li>
<li><code>LSET key index value</code> 通过索引为元素设值</li>
<li><code>LPOP/RPOP key</code> 从最左边/最右边移除值 并返回</li>
<li><code>RPOPLPUSH source destination</code> 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</li>
<li><code>LTRIM key start end</code> 通过下标截取指定范围内的列表</li>
<li><code>LREM key count value</code> List中是允许value重复的 count &gt; 0：从头部开始搜索 然后删除指定的value 至多删除count个 count &lt; 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。</li>
<li><code>BLPOP/BRPOP key1[key2] timout</code> 移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li>
<li><code>BRPOPLPUSH source destination timeout</code> 和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li>
</ul>
<p>代码示例</p>
<div class="code-wrapper"><pre><code class="hljs shell">---------------------------LPUSH---RPUSH---LRANGE--------------------------------
127.0.0.1:6379&gt; LPUSH mylist k1 # LPUSH mylist=&gt;&#123;1&#125;

(integer) 1

127.0.0.1:6379&gt; LPUSH mylist k2 # LPUSH mylist=&gt;&#123;2,1&#125;

(integer) 2

127.0.0.1:6379&gt; RPUSH mylist k3 # RPUSH mylist=&gt;&#123;2,1,3&#125;

(integer) 3

127.0.0.1:6379&gt; get mylist # 普通的get是无法获取list值的

(error) WRONGTYPE Operation against a key holding the wrong kind of value

127.0.0.1:6379&gt; LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素



&quot;k2&quot;

&quot;k1&quot;

&quot;k3&quot;

127.0.0.1:6379&gt; LRANGE mylist 0 2

&quot;k2&quot;

&quot;k1&quot;

&quot;k3&quot;

127.0.0.1:6379&gt; LRANGE mylist 0 1

&quot;k2&quot;

&quot;k1&quot;

127.0.0.1:6379&gt; LRANGE mylist 0 -1 # 获取全部元素

&quot;k2&quot;

&quot;k1&quot;

&quot;k3&quot;


---------------------------LPUSHX---RPUSHX-----------------------------------


127.0.0.1:6379&gt; LPUSHX list v1 # list不存在 LPUSHX失败

(integer) 0

127.0.0.1:6379&gt; LPUSHX list v1 v2

(integer) 0

127.0.0.1:6379&gt; LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5

(integer) 5

127.0.0.1:6379&gt; LRANGE mylist 0 -1



&quot;k5&quot;

&quot;k4&quot;

&quot;k2&quot;

&quot;k1&quot;

&quot;k3&quot;


---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------


127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1

(integer) 6

127.0.0.1:6379&gt; LRANGE mylist 0 -1



&quot;k5&quot;

&quot;k4&quot;

&quot;k2&quot;

&quot;ins_key1&quot;

&quot;k1&quot;

&quot;k3&quot;

127.0.0.1:6379&gt; LLEN mylist # 查看mylist的长度

(integer) 6

127.0.0.1:6379&gt; LINDEX mylist 3 # 获取下标为3的元素

&quot;ins_key1&quot;

127.0.0.1:6379&gt; LINDEX mylist 0

&quot;k5&quot;

127.0.0.1:6379&gt; LSET mylist 3 k6 # 将下标3的元素 set值为k6

OK

127.0.0.1:6379&gt; LRANGE mylist 0 -1

&quot;k5&quot;

&quot;k4&quot;

&quot;k2&quot;

&quot;k6&quot;

&quot;k1&quot;

&quot;k3&quot;


---------------------------LPOP--RPOP--------------------------


127.0.0.1:6379&gt; LPOP mylist # 左侧(头部)弹出

&quot;k5&quot;

127.0.0.1:6379&gt; RPOP mylist # 右侧(尾部)弹出

&quot;k3&quot;


---------------------------RPOPLPUSH--------------------------


127.0.0.1:6379&gt; LRANGE mylist 0 -1



&quot;k4&quot;

&quot;k2&quot;

&quot;k6&quot;

&quot;k1&quot;

127.0.0.1:6379&gt; RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部

&quot;k1&quot;

127.0.0.1:6379&gt; LRANGE newlist 0 -1

&quot;k1&quot;

127.0.0.1:6379&gt; LRANGE mylist 0 -1

&quot;k4&quot;

&quot;k2&quot;

&quot;k6&quot;


---------------------------LTRIM--------------------------


127.0.0.1:6379&gt; LTRIM mylist 0 1 # 截取mylist中的 0~1部分

OK

127.0.0.1:6379&gt; LRANGE mylist 0 -1



&quot;k4&quot;

&quot;k2&quot;


初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2

---------------------------LREM--------------------------


127.0.0.1:6379&gt; LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2

(integer) 3


删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2

127.0.0.1:6379&gt; LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2

(integer) 2


删除后：mylist: k2,k2,k2,k4,k2,k2

---------------------------BLPOP--BRPOP--------------------------


mylist: k2,k2,k2,k4,k2,k2

newlist: k1


127.0.0.1:6379&gt; BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选



&quot;newlist&quot; # 弹出

&quot;k1&quot;

127.0.0.1:6379&gt; BLPOP newlist mylist 30

&quot;mylist&quot; # 由于newlist空了 从mylist中弹出

&quot;k2&quot;

127.0.0.1:6379&gt; BLPOP newlist 30

(30.10s) # 超时了


127.0.0.1:6379&gt; BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。



&quot;newlist&quot;

&quot;test&quot;

(12.54s)</code></pre></div>

<p><strong>小结</strong></p>
<ul>
<li>list实际上是一个链表，before Node after , left, right 都可以插入值</li>
<li>如果key不存在，则创建新的链表</li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li>
</ul>
<p>应用：</p>
<p>消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）</p>
<h3 id="3-3-Set"><a href="#3-3-Set" class="headerlink" title="3.3 Set"></a>3.3 Set</h3><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<ul>
<li><code>SADD key member1[member2..]</code> 向集合中无序增加一个/多个成员</li>
<li><code>SCARD key</code> 获取集合的成员数</li>
<li><code>SMEMBERS key</code> 返回集合中所有的成员</li>
<li><code>SISMEMBER key member</code> 查询member元素是否是集合的成员,结果是无序的</li>
<li><code>SRANDMEMBER key [count]</code> 随机返回集合中count个成员，count缺省值为1</li>
<li><code>SPOP key [count]</code> 随机移除并返回集合中count个成员，count缺省值为1</li>
<li><code>SMOVE source destination member</code> 将source集合的成员member移动到destination集合</li>
<li><code>SREM key member1[member2..]</code> 移除集合中一个/多个成员</li>
<li><code>SDIFF key1[key2..]</code> 返回所有集合的差集 key1- key2 - …</li>
<li><code>SDIFFSTORE destination key1[key2..]</code> 在SDIFF的基础上，将结果保存到集合中<strong>(覆盖)</strong>。不能保存到其他类型key噢！</li>
<li><code>SINTER key1 [key2..]</code> 返回所有集合的交集</li>
<li><code>SINTERSTORE destination key1[key2..]</code> 在SINTER的基础上，存储结果到集合中。覆盖</li>
<li><code>SUNION key1 [key2..]</code> 返回所有集合的并集</li>
<li><code>SUNIONSTORE destination key1 [key2..]</code> 在SUNION的基础上，存储结果到及和张。覆盖</li>
<li><code>SSCAN KEY [MATCH pattern] [COUNT count]</code> 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</li>
</ul>
<p>代码示例</p>
<div class="code-wrapper"><pre><code class="hljs shell">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------
127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4
(integer) 4
127.0.0.1:6379&gt; SCARD myset # 获取集合的成员数目
(integer) 4
127.0.0.1:6379&gt; smembers myset # 获取集合中所有成员

&quot;m4&quot;
&quot;m3&quot;
&quot;m2&quot;
&quot;m1&quot;
127.0.0.1:6379&gt; SISMEMBER myset m5 # 查询m5是否是myset的成员
(integer) 0 # 不是，返回0
127.0.0.1:6379&gt; SISMEMBER myset m2
(integer) 1 # 是，返回1
127.0.0.1:6379&gt; SISMEMBER myset m3
(integer) 1

---------------------SRANDMEMBER--SPOP----------------------------------
127.0.0.1:6379&gt; SRANDMEMBER myset 3 # 随机返回3个成员

&quot;m2&quot;
&quot;m3&quot;
&quot;m4&quot;
127.0.0.1:6379&gt; SRANDMEMBER myset # 随机返回1个成员
&quot;m3&quot;
127.0.0.1:6379&gt; SPOP myset 2 # 随机移除并返回2个成员
&quot;m1&quot;
&quot;m4&quot;

将set还原到&#123;m1,m2,m3,m4&#125;
---------------------SMOVE--SREM----------------------------------------
127.0.0.1:6379&gt; SMOVE myset newset m3 # 将myset中m3成员移动到newset集合
(integer) 1
127.0.0.1:6379&gt; SMEMBERS myset

&quot;m4&quot;
&quot;m2&quot;
&quot;m1&quot;
127.0.0.1:6379&gt; SMEMBERS newset
&quot;m3&quot;
127.0.0.1:6379&gt; SREM newset m3 # 从newset中移除m3元素
(integer) 1
127.0.0.1:6379&gt; SMEMBERS newset
(empty list or set)

下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算
setx=&gt;&#123;m1,m2,m4,m6&#125;, sety=&gt;&#123;m2,m5,m6&#125;, setz=&gt;&#123;m1,m3,m6&#125;
-----------------------------SDIFF------------------------------------
127.0.0.1:6379&gt; SDIFF setx sety setz # 等价于setx-sety-setz

&quot;m4&quot;
127.0.0.1:6379&gt; SDIFF setx sety # setx - sety
&quot;m4&quot;
&quot;m1&quot;
127.0.0.1:6379&gt; SDIFF sety setx # sety - setx
&quot;m5&quot;

-------------------------SINTER---------------------------------------
共同关注（交集）
127.0.0.1:6379&gt; SINTER setx sety setz # 求 setx、sety、setx的交集

&quot;m6&quot;
127.0.0.1:6379&gt; SINTER setx sety # 求setx sety的交集
&quot;m2&quot;
&quot;m6&quot;

-------------------------SUNION---------------------------------------
127.0.0.1:6379&gt; SUNION setx sety setz # setx sety setz的并集

&quot;m4&quot;
&quot;m6&quot;
&quot;m3&quot;
&quot;m2&quot;
&quot;m1&quot;
&quot;m5&quot;
127.0.0.1:6379&gt; SUNION setx sety # setx sety 并集
&quot;m4&quot;
&quot;m6&quot;
&quot;m2&quot;
&quot;m1&quot;
&quot;m5&quot;</code></pre></div>

<h3 id="3-4-Hash"><a href="#3-4-Hash" class="headerlink" title="3.4 Hash"></a>3.4 Hash</h3><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p>
<ul>
<li><code>HSET key field value</code> 将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</li>
<li><code>HMSET key field1 value1 [field2 value2..]</code> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</li>
<li><code>HSETNX key field value</code> 只有在字段 field 不存在时，设置哈希表字段的值。</li>
<li><code>HEXISTS key field</code> 查看哈希表 key 中，指定的字段是否存在。</li>
<li><code>HGET key field value</code> 获取存储在哈希表中指定字段的值</li>
<li><code>HMGET key field1 [field2..]</code> 获取所有给定字段的值</li>
<li><code>HGETALL key</code> 获取在哈希表key 的所有字段和值</li>
<li><code>HKEYS key</code> 获取哈希表key中所有的字段</li>
<li><code>HLEN key</code> 获取哈希表中字段的数量</li>
<li><code>HVALS key</code> 获取哈希表中所有值</li>
<li><code>HDEL key field1 [field2..]</code> 删除哈希表key中一个/多个field字段</li>
<li><code>HINCRBY key field n</code> 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</li>
<li><code>HINCRBYFLOAT key field n</code> 为哈希表 key 中的指定字段的浮点数值加上增量 n。</li>
<li><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code> 迭代哈希表中的键值对。</li>
</ul>
<p>代码示例</p>
<div class="code-wrapper"><pre><code class="hljs shell">------------------------HSET--HMSET--HSETNX----------------
127.0.0.1:6379&gt; HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura
(integer) 1
127.0.0.1:6379&gt; HSET studentx name gyc # 重复设置field进行覆盖，并返回0
(integer) 0
127.0.0.1:6379&gt; HSET studentx age 20 # 设置studentx的age为20
(integer) 1
127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886
OK
127.0.0.1:6379&gt; HSETNX studentx name gyc # HSETNX 设置已存在的field
(integer) 0 # 失败
127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com
(integer) 1 # 成功
----------------------HEXISTS--------------------------------
127.0.0.1:6379&gt; HEXISTS studentx name # name字段在studentx中是否存在
(integer) 1 # 存在
127.0.0.1:6379&gt; HEXISTS studentx addr
(integer) 0 # 不存在
-------------------HGET--HMGET--HGETALL-----------
127.0.0.1:6379&gt; HGET studentx name # 获取studentx中name字段的value
&quot;gyc&quot;
127.0.0.1:6379&gt; HMGET studentx name age tel # 获取studentx中name、age、tel字段的value

&quot;gyc&quot;
&quot;20&quot;
&quot;15623667886&quot;
127.0.0.1:6379&gt; HGETALL studentx # 获取studentx中所有的field及其value
&quot;name&quot;
&quot;gyc&quot;
&quot;age&quot;
&quot;20&quot;
&quot;sex&quot;
&quot;1&quot;
&quot;tel&quot;
&quot;15623667886&quot;
&quot;email&quot;
&quot;12345@qq.com&quot;

--------------------HKEYS--HLEN--HVALS--------------
127.0.0.1:6379&gt; HKEYS studentx # 查看studentx中所有的field

&quot;name&quot;
&quot;age&quot;
&quot;sex&quot;
&quot;tel&quot;
&quot;email&quot;
127.0.0.1:6379&gt; HLEN studentx # 查看studentx中的字段数量
(integer) 5
127.0.0.1:6379&gt; HVALS studentx # 查看studentx中所有的value
&quot;gyc&quot;
&quot;20&quot;
&quot;1&quot;
&quot;15623667886&quot;
&quot;12345@qq.com&quot;

-------------------------HDEL--------------------------
127.0.0.1:6379&gt; HDEL studentx sex tel # 删除studentx 中的sex、tel字段
(integer) 2
127.0.0.1:6379&gt; HKEYS studentx

&quot;name&quot;
&quot;age&quot;
&quot;email&quot;

-------------HINCRBY--HINCRBYFLOAT------------------------
127.0.0.1:6379&gt; HINCRBY studentx age 1 # studentx的age字段数值+1
(integer) 21
127.0.0.1:6379&gt; HINCRBY studentx name 1 # 非整数字型字段不可用
(error) ERR hash value is not an integer
127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6
&quot;90.8&quot;</code></pre></div>

<p> Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！</p>
<h3 id="3-5-Zset-有序集合"><a href="#3-5-Zset-有序集合" class="headerlink" title="3.5 Zset(有序集合)"></a>3.5 Zset(有序集合)</h3><p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>score相同：按字典顺序排序</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<ul>
<li><code>ZADD key score member1 [score2 member2]</code> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</li>
<li><code>ZCARD key</code> 获取有序集合的成员数</li>
<li><code>ZCOUNT key min max</code> 计算在有序集合中指定区间score的成员数</li>
<li><code>ZINCRBY key n member</code> 有序集合中对指定成员的分数加上增量 n</li>
<li><code>ZSCORE key member</code> 返回有序集中，成员的分数值</li>
<li><code>ZRANK key member</code> 返回有序集合中指定成员的索引</li>
<li><code>ZRANGE key start end</code> 通过索引区间返回有序集合成指定区间内的成员</li>
<li><code>ZRANGEBYLEX key min max</code> 通过字典区间返回有序集合的成员</li>
<li><code>ZRANGEBYSCORE key min max</code> 通过分数返回有序集合指定区间内的成员 <strong>-inf 和 +inf</strong>分别表示最小最大值，只支持开区间() </li>
<li><code>ZLEXCOUNT key min max</code> 在有序集合中计算指定字典区间内成员数量</li>
<li><code>ZREM key member1 [member2..]</code> 移除有序集合中一个/多个成员</li>
<li><code>ZREMRANGEBYLEX key min max</code> 移除有序集合中给定的字典区间的所有成员</li>
<li><code>ZREMRANGEBYRANK key start stop</code> 移除有序集合中给定的排名区间的所有成员</li>
<li><code>ZREMRANGEBYSCORE key min max</code> 移除有序集合中给定的分数区间的所有成员</li>
<li><code>ZREVRANGE key start end</code> 返回有序集中指定区间内的成员，通过索引，分数从高到底</li>
<li><code>ZREVRANGEBYSCORRE key max min</code> 返回有序集中指定分数区间内的成员，分数从高到低排序</li>
<li><code>ZREVRANGEBYLEX key max min</code> 返回有序集中指定字典区间内的成员，按字典顺序倒序</li>
<li><code>ZREVRANK key member</code> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</li>
<li><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</li>
<li><code>ZUNIONSTORE destination numkeys key1 [key2..]</code> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</li>
<li><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code> 迭代有序集合中的元素（包括元素成员和元素分值）</li>
</ul>
<p>代码示例</p>
<div class="code-wrapper"><pre><code class="hljs shell">-------------------ZADD--ZCARD--ZCOUNT--------------
127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2..
(integer) 2
127.0.0.1:6379&gt; ZCARD myzset # 获取有序集合的成员数
(integer) 2
127.0.0.1:6379&gt; ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量
(integer) 1
127.0.0.1:6379&gt; ZCOUNT myzset 0 2
(integer) 2
----------------ZINCRBY--ZSCORE--------------------------
127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 # 将成员m2的score +5
&quot;7&quot;
127.0.0.1:6379&gt; ZSCORE myzset m1 # 获取成员m1的score
&quot;1&quot;
127.0.0.1:6379&gt; ZSCORE myzset m2
&quot;7&quot;
--------------ZRANK--ZRANGE-----------------------------------
127.0.0.1:6379&gt; ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加
(integer) 0
127.0.0.1:6379&gt; ZRANK myzset m2
(integer) 2
127.0.0.1:6379&gt; ZRANGE myzset 0 1 # 获取索引在 0~1的成员

&quot;m1&quot;
&quot;m3&quot;
127.0.0.1:6379&gt; ZRANGE myzset 0 -1 # 获取全部成员
&quot;m1&quot;
&quot;m3&quot;
&quot;m2&quot;

testset=&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0
------------------ZRANGEBYLEX---------------------------------
127.0.0.1:6379&gt; ZRANGEBYLEX testset - + # 返回所有成员

&quot;abc&quot;
&quot;add&quot;
&quot;amaze&quot;
&quot;apple&quot;
&quot;back&quot;
&quot;java&quot;
&quot;redis&quot;
127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录
&quot;abc&quot;
&quot;add&quot;
&quot;amaze&quot;
127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录
&quot;apple&quot;
&quot;back&quot;
&quot;java&quot;
127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员
&quot;abc&quot;
&quot;add&quot;
&quot;amaze&quot;
&quot;apple&quot;
127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员
&quot;apple&quot;
&quot;back&quot;
&quot;java&quot;

-----------------------ZRANGEBYSCORE---------------------
127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员

&quot;m1&quot;
&quot;m3&quot;
&quot;m2&quot;
127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 5
&quot;m1&quot;
&quot;m3&quot;

--------------------ZLEXCOUNT-----------------------------
127.0.0.1:6379&gt; ZLEXCOUNT testset - +
(integer) 7
127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java
(integer) 3
------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------
127.0.0.1:6379&gt; ZREM testset abc # 移除成员abc
(integer) 1
127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员
(integer) 3
127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员
(integer) 2
127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员
(integer) 2
testset=&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0
myzset=&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;
----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------
127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3

&quot;m9&quot;
&quot;m7&quot;
&quot;m4&quot;
&quot;m3&quot;
127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4
&quot;m4&quot;
&quot;m3&quot;
&quot;m2&quot;
127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员
&quot;m4&quot;
&quot;m3&quot;
&quot;m2&quot;
127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add # 按字典倒序 返回集合中(add,java]字典区间的成员
&quot;java&quot;
&quot;back&quot;
&quot;apple&quot;
&quot;amaze&quot;

-------------------------ZREVRANK------------------------------
127.0.0.1:6379&gt; ZREVRANK myzset m7 # 按score递减顺序，返回成员m7索引
(integer) 1
127.0.0.1:6379&gt; ZREVRANK myzset m2
(integer) 4
mathscore=&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩
enscore=&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩
-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------
127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore # 将mathscore enscore进行合并 结果存放到sumscore
(integer) 3
127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores # 合并后的score是之前集合中所有score的和

&quot;xm&quot;
&quot;160&quot;
&quot;xg&quot;
&quot;177&quot;
&quot;xh&quot;
&quot;188&quot;

127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN # 取两个集合的成员score最小值作为结果的
(integer) 3
127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores

&quot;xm&quot;
&quot;70&quot;
&quot;xg&quot;
&quot;87&quot;
&quot;xh&quot;
&quot;93&quot;</code></pre></div>

<p>应用案例：</p>
<ol>
<li>set排序 存储班级成绩表 工资表排序！</li>
<li>普通消息，1.重要消息 2.带权重进行判断</li>
<li>排行榜应用实现，取Top N测试</li>
</ol>
<h2 id="4-三种特殊的数据类型"><a href="#4-三种特殊的数据类型" class="headerlink" title="4 三种特殊的数据类型"></a>4 三种特殊的数据类型</h2><h3 id="4-1-Geospatial-地理位置"><a href="#4-1-Geospatial-地理位置" class="headerlink" title="4.1 Geospatial(地理位置)"></a>4.1 Geospatial(地理位置)</h3><p>使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用</p>
<ul>
<li><code>geoadd key longitud(经度) latitude(纬度) member [..]</code> 将具体经纬度的坐标存入一个有序集合</li>
<li><code>geopos key member [member..]</code> 获取集合中的一个/多个成员坐标</li>
<li><code>geodist key member1 member2 [unit]</code> 返回两个给定位置之间的距离。默认以米作为单位。</li>
<li><code>georadius key longitude latitude radius m|km|mi|ft [WITHCOORD][WITHDIST] [WITHHASH] [COUNT count]</code> 以给定的经纬度为中心， 返回集合包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</li>
<li><code>GEORADIUSBYMEMBER key member radius...</code> 功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</li>
<li><code>geohash key member1 [member2..]</code> 返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</li>
</ul>
<h4 id="有效经纬度"><a href="#有效经纬度" class="headerlink" title="有效经纬度"></a>有效经纬度</h4><ul>
<li>有效的经度从-180度到180度。</li>
<li>有效的纬度从-85.05112878度到85.05112878度。</li>
</ul>
<p><strong>指定单位的参数 unit 必须是以下单位的其中一个：</strong></p>
<ul>
<li>m 表示单位为米。</li>
</ul>
<ul>
<li>km 表示单位为千米。</li>
</ul>
<ul>
<li>mi 表示单位为英里。</li>
</ul>
<ul>
<li>ft 表示单位为英尺。</li>
</ul>
<h4 id="关于GEORADIUS的参数"><a href="#关于GEORADIUS的参数" class="headerlink" title="关于GEORADIUS的参数"></a>关于GEORADIUS的参数</h4><ul>
<li>通过georadius就可以完成 附近的人功能</li>
</ul>
<ul>
<li>withcoord:带上坐标</li>
</ul>
<ul>
<li>withdist:带上距离，单位与半径单位相同</li>
</ul>
<ul>
<li>COUNT n : 只显示前n个(按距离递增排序)</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs shell">----------------georadius---------------------
127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员
1) 1) &quot;hangzhou&quot;
   2) &quot;29.4151&quot;
   3) 1) &quot;120.20000249147415&quot;
      2) &quot;30.199999888333501&quot;
2) 1) &quot;shanghai&quot;
   2) &quot;205.3611&quot;
   3) 1) &quot;121.40000134706497&quot;
      2) &quot;31.400000253193539&quot;
------------geohash---------------------------
127.0.0.1:6379&gt; geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示

&quot;wmrjwbr5250&quot;
&quot;wtw6ds0y300&quot;</code></pre></div>

<h3 id="4-2-Hyperloglog-基数统计"><a href="#4-2-Hyperloglog-基数统计" class="headerlink" title="4.2 Hyperloglog(基数统计)"></a>4.2 Hyperloglog(基数统计)</h3><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p>
<p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>其底层使用string数据类型。</p>
<h4 id="什么是基数？"><a href="#什么是基数？" class="headerlink" title="什么是基数？"></a>什么是基数？</h4><p>数据集中不重复的元素的个数。</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p>
<p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。</p>
<ul>
<li><code>PFADD key element1 [elememt2..]</code> 添加指定元素到 HyperLogLog中</li>
<li><code>PFCOUNT key [key]</code> 返回给定 HyperLogLog 的基数估算值。</li>
<li><code>PFMERGE destkey sourcekey [sourcekey..]</code> 将多个 HyperLogLog 合并为一个 HyperLogLog</li>
</ul>
<p>代码示例</p>
<div class="code-wrapper"><pre><code class="hljs shell">----------PFADD--PFCOUNT---------------------
127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k # 添加元素
(integer) 1
127.0.0.1:6379&gt; type myelemx # hyperloglog底层使用String
string
127.0.0.1:6379&gt; PFCOUNT myelemx # 估算myelemx的基数
(integer) 11
127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s
(integer) 1
127.0.0.1:6379&gt; PFCOUNT myelemy
(integer) 11
----------------PFMERGE-----------------------
127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemz
OK
127.0.0.1:6379&gt; PFCOUNT myelemz # 估算基数
(integer) 17</code></pre></div>



<h3 id="4-3-BitMaps-位图"><a href="#4-3-BitMaps-位图" class="headerlink" title="4.3 BitMaps(位图)"></a>4.3 BitMaps(位图)</h3><p>使用位存储，信息状态只有 0 和 1</p>
<p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p>
<p>应用场景: 签到统计、状态统计</p>
<ul>
<li><code>setbit key offset value</code> 为指定key的offset位设置值</li>
<li><code>getbit key offset</code> 获取offset位的值</li>
<li><code>bitcount key [start end]</code> 统计字符串被设置为1的bit数，也可以指定统计范围按字节</li>
<li><code>bitop operration destkey key[key..]</code> 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</li>
<li><code>BITPOS key bit [start] [end]</code> 返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</li>
</ul>
<p>代码示例</p>
<div class="code-wrapper"><pre><code class="hljs shell">------------setbit--getbit--------------
127.0.0.1:6379&gt; setbit sign 0 1 # 设置sign的第0位为 1 
(integer) 0
127.0.0.1:6379&gt; setbit sign 2 1 # 设置sign的第2位为 1  不设置默认 是0
(integer) 0
127.0.0.1:6379&gt; setbit sign 3 1
(integer) 0
127.0.0.1:6379&gt; setbit sign 5 1
(integer) 0
127.0.0.1:6379&gt; type sign
string
127.0.0.1:6379&gt; getbit sign 2 # 获取第2位的数值
(integer) 1
127.0.0.1:6379&gt; getbit sign 3
(integer) 1
127.0.0.1:6379&gt; getbit sign 4 # 未设置默认是0
(integer) 0
-----------bitcount----------------------------
127.0.0.1:6379&gt; BITCOUNT sign # 统计sign中为1的位数
(integer) 4</code></pre></div>

<h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5 事务"></a>5 事务</h2><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p>
<div class="code-wrapper"><pre><code class="hljs shell">Redis事务本质：一组命令的集合。
----------------- 队列 set set set 执行 -------------------
事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。
一次性
顺序性
排他性
Redis事务没有隔离级别的概念
Redis单条命令是保证原子性的，但是事务不保证原子性！</code></pre></div>

<p>Redis事务操作过程</p>
<ul>
<li>开启事务（multi）</li>
<li>命令入队</li>
<li>执行事务（exec）</li>
</ul>
<p>所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p>
<h3 id="5-1-正常执行"><a href="#5-1-正常执行" class="headerlink" title="5.1 正常执行"></a>5.1 正常执行</h3><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi # 开启事务
OK
127.0.0.1:6379&gt; set k1 v1 # 命令入队
QUEUED
127.0.0.1:6379&gt; set k2 v2 # ..
QUEUED
127.0.0.1:6379&gt; get k1
QUEUED
127.0.0.1:6379&gt; set k3 v3
QUEUED
127.0.0.1:6379&gt; keys *
QUEUED
127.0.0.1:6379&gt; exec # 事务执行
1) OK
2) OK
3) &quot;v1&quot;
4) OK
5) 1) &quot;k3&quot;
   2) &quot;k2&quot;
   3) &quot;k1&quot;</code></pre></div>

<h3 id="5-2-取消事务-discurd"><a href="#5-2-取消事务-discurd" class="headerlink" title="5.2 取消事务(discurd)"></a>5.2 取消事务(discurd)</h3><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; set k1 v1
QUEUED
127.0.0.1:6379&gt; set k2 v2
QUEUED
127.0.0.1:6379&gt; DISCARD # 放弃事务
OK
127.0.0.1:6379&gt; EXEC 
(error) ERR EXEC without MULTI # 当前未开启事务
127.0.0.1:6379&gt; get k1 # 被放弃事务中命令并未执行
(nil)</code></pre></div>

<h3 id="5-3-事务错误"><a href="#5-3-事务错误" class="headerlink" title="5.3 事务错误"></a>5.3 事务错误</h3><blockquote>
<p>  代码语法错误（编译时异常）所有的命令都不执行</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; set k1 v1
QUEUED
127.0.0.1:6379&gt; set k2 v2
QUEUED
127.0.0.1:6379&gt; error k1 # 这是一条语法错误命令
(error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 
127.0.0.1:6379&gt; get k2
QUEUED
127.0.0.1:6379&gt; EXEC
(error) EXECABORT Transaction discarded because of previous errors. # 执行报错
127.0.0.1:6379&gt; get k1 
(nil) # 其他命令并没有被执行</code></pre></div>

<blockquote>
<p>  代码逻辑错误 (运行时异常) *<em>其他命令可以正常执行 *</em> &gt;&gt;&gt; 所以不保证事务原子性</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; set k1 v1
QUEUED
127.0.0.1:6379&gt; set k2 v2
QUEUED
127.0.0.1:6379&gt; INCR k1 # 这条命令逻辑错误（对字符串进行增量）
QUEUED
127.0.0.1:6379&gt; get k2
QUEUED
127.0.0.1:6379&gt; exec
1) OK
2) OK
3) (error) ERR value is not an integer or out of range # 运行时报错
4) &quot;v2&quot; # 其他命令正常执行
虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。
所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</code></pre></div>

<h3 id="5-4-监控"><a href="#5-4-监控" class="headerlink" title="5.4 监控"></a>5.4 监控</h3><p>悲观锁：</p>
<ul>
<li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li>
</ul>
<p>乐观锁：</p>
<ul>
<li>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<p>使用watch key监控指定数据，相当于乐观锁加锁。</p>
<blockquote>
<p>  正常执行</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set money 100 # 设置余额:100
OK
127.0.0.1:6379&gt; set use 0 # 支出使用:0
OK
127.0.0.1:6379&gt; watch money # 监视money (上锁)
OK
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; DECRBY money 20
QUEUED
127.0.0.1:6379&gt; INCRBY use 20
QUEUED
127.0.0.1:6379&gt; exec # 监视值没有被中途修改，事务正常执行
1) (integer) 80
2) (integer) 20</code></pre></div>

<p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）</p>
<p>我们启动另外一个客户端模拟插队线程。</p>
<p>线程1：</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; watch money # money上锁
OK
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; DECRBY money 20
QUEUED
127.0.0.1:6379&gt; INCRBY use 20
QUEUED
127.0.0.1:6379&gt;     # 此时事务并没有执行</code></pre></div>

<p>模拟线程插队，线程2：</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; INCRBY money 500 # 修改了线程一中监视的money
(integer) 600</code></pre></div>

<p>回到线程1，执行事务：</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败
(nil) # 没有结果，说明事务执行失败
127.0.0.1:6379&gt; get money # 线程2 修改生效
&quot;600&quot;
127.0.0.1:6379&gt; get use # 线程1事务执行失败，数值没有被修改
&quot;0&quot;</code></pre></div>

<p>解锁获取最新值，然后再加锁进行事务。</p>
<p>unwatch进行解锁。</p>
<p>注意：每次提交执行exec后都会自动释放锁，不管是否成功</p>
<h2 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6 Jedis"></a>6 Jedis</h2><p>使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。</p>
<p>1.导入依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入jredis的包--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--fastjson--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.70<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>2.编码测试</p>
<blockquote>
<p>  连接数据库<br>  操作命令<br>  断开连接</p>
</blockquote>
<p>代码示例</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPing</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.xx.xxx&quot;</span>, <span class="hljs-number">6379</span>);
        jedis.auth(<span class="hljs-string">&quot;p&quot;</span>);
        String response = jedis.ping();
        System.out.println(response); <span class="hljs-comment">// PONG</span>
    &#125;
&#125;</code></pre></div>

<p>输出PONG</p>
<h3 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h3><p>string、list、set、hash、zset</p>
<p>所有的api命令，就是我们对应的上面学习的指令，一个都没有变化！</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTX</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);
        jedis.flushDB();
        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();
        jsonObject.put(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);
        jsonObject.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;kuangshen&quot;</span>);
        <span class="hljs-comment">// 开启事务</span>
        Transaction multi = jedis.multi();
        String result = jsonObject.toJSONString();
        <span class="hljs-comment">// jedis.watch(result)</span>
        <span class="hljs-keyword">try</span> &#123;
            multi.set(<span class="hljs-string">&quot;user1&quot;</span>,result);
            multi.set(<span class="hljs-string">&quot;user2&quot;</span>,result);
            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span> ; <span class="hljs-comment">// 代码抛出异常事务，执行失败！</span>
            multi.exec(); <span class="hljs-comment">// 执行事务！</span>
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            multi.discard(); <span class="hljs-comment">// 放弃事务</span>
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            System.out.println(jedis.get(<span class="hljs-string">&quot;user1&quot;</span>));
            System.out.println(jedis.get(<span class="hljs-string">&quot;user2&quot;</span>));
            jedis.close(); <span class="hljs-comment">// 关闭连接</span>
        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="7-SpringBoot整合"><a href="#7-SpringBoot整合" class="headerlink" title="7 SpringBoot整合"></a>7 SpringBoot整合</h2><p>SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！</p>
<p>SpringData 也是和 SpringBoot 齐名的项目！</p>
<p>说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?</p>
<p>jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式</p>
<p>lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式</p>
<p>源码分析：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span> 
<span class="hljs-comment">// 我们可以自己定义一个redisTemplate来替换这个默认的！</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;
<span class="hljs-comment">// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！</span>
<span class="hljs-comment">// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt;</span>
    RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();
    template.setConnectionFactory(redisConnectionFactory);
    <span class="hljs-keyword">return</span> template;
&#125;
<span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">// 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;
    StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();
    template.setConnectionFactory(redisConnectionFactory);
    <span class="hljs-keyword">return</span> template;
&#125;</code></pre></div>

<h3 id="整合测试"><a href="#整合测试" class="headerlink" title="整合测试"></a>整合测试</h3><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1 导入依赖"></a>1 导入依赖</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。</p>
<p>jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式</p>
<p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p>
<p>我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214531573.png" alt></p>
<p>那么就一定还存在一个RedisProperties类<img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214607475.png" alt></p>
<p>@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的</p>
<p>然后再看Lettuce：</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214618179.png" alt></p>
<p>完美生效。</p>
<p>现在我们回到RedisAutoConfiguratio</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321462777.png" alt></p>
<p>只有两个简单的Bean</p>
<ul>
<li>RedisTemplate</li>
<li>StringRedisTemplate</li>
</ul>
<p>当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。</p>
<p>在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的</p>
<p>说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214638238.png" alt></p>
<p>这是一些基本的配置属性。</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214649380.png" alt></p>
<p>还有一些连接池相关的配置。注意使用时一定使用<strong>Lettuce</strong>的连接池。</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214700372.png" alt></p>
<h4 id="2-编写配置文件"><a href="#2-编写配置文件" class="headerlink" title="2 编写配置文件"></a>2 编写配置文件</h4><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 配置redis</span>
<span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">39.99.xxx.xx</span>
<span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span></code></pre></div>

<h4 id="3-使用RedisTemplate"><a href="#3-使用RedisTemplate" class="headerlink" title="3 使用RedisTemplate"></a>3 使用RedisTemplate</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis02SpringbootApplicationTests</span> </span>&#123;
<span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> RedisTemplate redisTemplate;

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;

    <span class="hljs-comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span>
    <span class="hljs-comment">// opsForValue 操作字符串 类似String</span>
    <span class="hljs-comment">// opsForList 操作List 类似List</span>
    <span class="hljs-comment">// opsForSet</span>
    <span class="hljs-comment">// opsForHash</span>
    <span class="hljs-comment">// opsForZSet</span>
    <span class="hljs-comment">// opsForGeo</span>
    <span class="hljs-comment">// opsForHyperLog</span>

    <span class="hljs-comment">// 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD</span>

    <span class="hljs-comment">// 获取连接对象</span>
    <span class="hljs-comment">//RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span>
    <span class="hljs-comment">//connection.flushDb();</span>
    <span class="hljs-comment">//connection.flushAll();</span>

    redisTemplate.opsForValue().set(&amp;quot;mykey&amp;quot;,&amp;quot;kuangshen&amp;quot;);
    System.out.println(redisTemplate.opsForValue().get(&amp;quot;mykey&amp;quot;));
&#125;

&#125;</code></pre></div>

<h4 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4 测试结果"></a>4 测试结果</h4><p>此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出。这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。</p>
<p>RedisTemplate内部的序列化配置是这样的</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214746506.png" alt></p>
<p>默认的序列化器是采用JDK序列化器</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B0.jpg" alt></p>
<p>后续我们定制RedisTemplate就可以对其进行修改。</p>
<p>RedisSerializer提供了多种序列化方案：</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214818682.png" alt></p>
<p>我们来编写一个自己的 RedisTemplete</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.config;

<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;
<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;
<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;
<span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;
<span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
<span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;


<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;
	<span class="hljs-comment">// 这是我给大家写好的一个固定模板，大家在企业中，拿去就可以直接使用！</span>
	<span class="hljs-comment">// 自己定义了一个 RedisTemplate</span>
	<span class="hljs-meta">@Bean</span>
	<span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;
		<span class="hljs-comment">// 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span>
		RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;String,
				Object&gt;();
		template.setConnectionFactory(factory);
		<span class="hljs-comment">// Json序列化配置</span>
		Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span>
				Jackson2JsonRedisSerializer(Object.class);
		ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();
		om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
		om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
		jackson2JsonRedisSerializer.setObjectMapper(om);
		<span class="hljs-comment">// String 的序列化</span>
		StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();

		<span class="hljs-comment">// key采用String的序列化方式</span>
		template.setKeySerializer(stringRedisSerializer);
		<span class="hljs-comment">// hash的key也采用String的序列化方式</span>
		template.setHashKeySerializer(stringRedisSerializer);
		<span class="hljs-comment">// value序列化方式采用jackson</span>
		template.setValueSerializer(jackson2JsonRedisSerializer);
		<span class="hljs-comment">// hash的value序列化方式采用jackson</span>
		template.setHashValueSerializer(jackson2JsonRedisSerializer);
		template.afterPropertiesSet();

		<span class="hljs-keyword">return</span> template;
	&#125;

&#125;</code></pre></div>

<p>所有的redis操作，其实对于java开发人员来说，十分的简单，更重要是要去理解redis的思想和每一种数据结构的用处和作用场景！</p>
<h2 id="8-Redis-conf"><a href="#8-Redis-conf" class="headerlink" title="8 Redis.conf"></a>8 Redis.conf</h2><ul>
<li><p>容量单位不区分大小写，G和GB有区别</p>
</li>
<li><p>可以使用 include 组合多个配置问题</p>
</li>
</ul>
<h3 id="8-1-网络配置"><a href="#8-1-网络配置" class="headerlink" title="8.1 网络配置"></a>8.1 网络配置</h3><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214912813.png" alt></p>
<h3 id="8-2-日志"><a href="#8-2-日志" class="headerlink" title="8.2 日志"></a>8.2 日志</h3><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># 日志</span>
<span class="hljs-comment"># Specify the server verbosity level.</span>
<span class="hljs-comment"># This can be one of:</span>
<span class="hljs-comment"># debug (a lot of information, useful for development/testing)</span>
<span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span>
<span class="hljs-comment"># notice (moderately verbose, what you want in production probably) 生产环境</span>
<span class="hljs-comment"># warning (only very important / critical messages are logged)</span>
loglevel notice
logfile &quot;&quot; # 日志的文件位置名
databases 16 # 数据库的数量，默认是 16 个数据库
always-show-logo yes # 是否总是显示LOGO</code></pre></div>

<p>日志输出级别</p>
<ul>
<li>debug</li>
<li>verbose</li>
<li>notice</li>
<li>waring</li>
</ul>
<h3 id="8-3-持久化规则"><a href="#8-3-持久化规则" class="headerlink" title="8.3 持久化规则"></a>8.3 持久化规则</h3><p>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof redis 是内存数据库，如果没有持久化，那么数据断电及失！</p>
<p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p>
<p>持久化方式：</p>
<ul>
<li>RDB</li>
<li>AOF</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span>
save 900 1
<span class="hljs-comment"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span>
save 300 10
<span class="hljs-comment"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</span>
save 60 10000
<span class="hljs-comment"># 我们之后学习持久化，会自己定义这个测试！</span>
stop-writes-on-bgsave-error yes # 持久化如果出错，是否还需要继续工作！
rdbcompression yes # 是否压缩 rdb 文件，需要消耗一些cpu资源！
rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验！
dir ./ # rdb 文件保存的目录！</code></pre></div>

<h3 id="8-4-SECURITY-安全"><a href="#8-4-SECURITY-安全" class="headerlink" title="8.4 SECURITY 安全"></a>8.4 SECURITY 安全</h3><p>可以在这里设置redis的密码，默认是没有密码！</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt; config get requirepass # 获取redis的密码
1) &quot;requirepass&quot;
2) &quot;&quot;
127.0.0.1:6379&gt; config set requirepass &quot;123456&quot; # 设置redis的密码
OK
127.0.0.1:6379&gt; config get requirepass # 发现所有的命令都没有权限了
(error) NOAUTH Authentication required.
127.0.0.1:6379&gt; ping
(error) NOAUTH Authentication required.
127.0.0.1:6379&gt; auth 123456 # 使用密码进行登录！
OK
127.0.0.1:6379&gt; config get requirepass
1) &quot;requirepass&quot;
2) &quot;123456&quot;</code></pre></div>

<h3 id="8-6-限制-CLIENTS（客户端连接相关）"><a href="#8-6-限制-CLIENTS（客户端连接相关）" class="headerlink" title="8.6 限制 CLIENTS（客户端连接相关）"></a>8.6 限制 CLIENTS（客户端连接相关）</h3><div class="code-wrapper"><pre><code class="hljs ini">maxclients 10000 # 设置能连接上redis的最大客户端的数量
maxmemory &lt;bytes&gt; # redis 配置最大的内存容量
maxmemory-policy noeviction # 内存到达上限之后的处理策略
1、volatile-lru：只对设置了过期时间的key进行LRU（默认值）
2、allkeys-lru ： 删除lru算法的key
3、volatile-random：随机删除即将过期key
4、allkeys-random：随机删除
5、volatile-ttl ： 删除即将过期的
6、noeviction ： 永不过期，返回错误</code></pre></div>

<h3 id="8-7-APPEND-ONLY-模式-aof配置"><a href="#8-7-APPEND-ONLY-模式-aof配置" class="headerlink" title="8.7 APPEND ONLY 模式 aof配置"></a>8.7 APPEND ONLY 模式 aof配置</h3><div class="code-wrapper"><pre><code class="hljs ini">appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，
rdb完全够用！
appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字
<span class="hljs-comment"># appendfsync always # 每次修改都会 sync。消耗性能</span>
appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！
<span class="hljs-comment"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，</span></code></pre></div>

<h2 id="9-Redis持久化——RDB"><a href="#9-Redis持久化——RDB" class="headerlink" title="9 Redis持久化——RDB"></a>9 Redis持久化——RDB</h2><p>面试和工作，持久化都是重点！<br>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p>
<h3 id="9-1-什么是RDB（Redis-DataBase）"><a href="#9-1-什么是RDB（Redis-DataBase）" class="headerlink" title="9.1 什么是RDB（Redis DataBase）"></a>9.1 什么是RDB（Redis DataBase）</h3><blockquote>
<p>  在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；<br>  默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p>
</blockquote>
<ul>
<li>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</li>
<li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。</li>
<li>这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！ 有时候在生产环境我们会将这个文件进行备份！</li>
<li>rdb保存的文件是dump.rdb 都是在我们的配置文件中快照中进行配置的！</li>
</ul>
<h3 id="9-2-工作原理"><a href="#9-2-工作原理" class="headerlink" title="9.2 工作原理"></a>9.2 工作原理</h3><p>在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作；</p>
<ol>
<li>Redis 调用forks。同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ol>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p>
<h3 id="9-3-触发机制"><a href="#9-3-触发机制" class="headerlink" title="9.3 触发机制"></a>9.3 触发机制</h3><ol>
<li>save的规则满足的情况下，会自动触发rdb原则</li>
<li>执行flushall命令，也会触发我们的rdb原则</li>
<li>退出redis，也会自动产生rdb文件</li>
</ol>
<h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 save 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p>
<blockquote>
<p>  由于 save 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求。</p>
</blockquote>
<p>示意图</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215150892.jpg" alt></p>
<h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><p>flushall 命令也会触发持久化 ；</p>
<p>触发持久化规则<br>满足配置条件中的触发条件 ；</p>
<blockquote>
<p>  可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</p>
</blockquote>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215205970.png" alt></p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215220858.jpg" alt></p>
<h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p>bgsave 是异步进行，进行持久化的时候，redis 还可以将继续响应客户端请求 ；</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321523151.jpg" alt></p>
<p>bgsave和save对比</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">save</th>
<th align="left">bgsave</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IO类型</td>
<td align="left">同步</td>
<td align="left">异步</td>
</tr>
<tr>
<td align="left">阻塞</td>
<td align="left">是</td>
<td align="left">是（阻塞发生在fock()，通常非常快）</td>
</tr>
<tr>
<td align="left">复杂度</td>
<td align="left">O(n)</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td align="left">优点</td>
<td align="left">不会消耗额外的内存</td>
<td align="left">不阻塞客户端命令</td>
</tr>
<tr>
<td align="left">缺点</td>
<td align="left">阻塞客户端命令</td>
<td align="left">需要fock子进程，消耗内存</td>
</tr>
</tbody></table>
<h4 id="如果恢复rdb文件！"><a href="#如果恢复rdb文件！" class="headerlink" title="如果恢复rdb文件！"></a>如果恢复rdb文件！</h4><ol>
<li>只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！</li>
<li>查看需要存在的位置</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; config get dir
<span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;dir&quot;</span>
<span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;/usr/local/bin&quot;</span> # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</code></pre></div>

<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote>
<p>  优点：</p>
</blockquote>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要求不高</li>
</ol>
<blockquote>
<p>  缺点：</p>
</blockquote>
<ol>
<li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li>
<li>fork进程的时候，会占用一定的内容空间。</li>
</ol>
<h2 id="10-Redis持久化——AOF"><a href="#10-Redis持久化——AOF" class="headerlink" title="10 Redis持久化——AOF"></a>10 Redis持久化——AOF</h2><p>Append Only File</p>
<p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍[<img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B005.jpg" alt></p>
<p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<h3 id="10-1-什么是AOF"><a href="#10-1-什么是AOF" class="headerlink" title="10.1 什么是AOF"></a>10.1 什么是AOF</h3><p> 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p>
<p>appendonly no yes则表示启用AOF</p>
<p>默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</p>
<p>如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件</p>
<p>redis给我们提供了一个工具redis-check-aof –fix</p>
<div class="code-wrapper"><pre><code class="hljs ini">appendonly yes  # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用
appendfilename &quot;appendonly.aof&quot;
appendfsync always # 每次修改都会sync 消耗性能
appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据
appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快</code></pre></div>

<h3 id="10-2-优缺点"><a href="#10-2-优缺点" class="headerlink" title="10.2 优缺点"></a>10.2 优缺点</h3><p><strong>优点</strong></p>
<ol>
<li>每一次修改都会同步，文件的完整性会更加好</li>
<li>每秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率最高</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！</li>
<li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li>
</ol>
<h3 id="10-3-扩展"><a href="#10-3-扩展" class="headerlink" title="10.3 扩展"></a>10.3 扩展</h3><ol>
<li>RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li>
<li>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</li>
<li>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</li>
<li>同时开启两种持久化方式<ul>
<li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</li>
</ul>
</li>
<li>性能建议<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。</li>
<li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li>
</ul>
</li>
</ol>
<h3 id="10-4-如何选择使用哪种持久化方式？"><a href="#10-4-如何选择使用哪种持久化方式？" class="headerlink" title="10.4 如何选择使用哪种持久化方式？"></a>10.4 如何选择使用哪种持久化方式？</h3><ul>
<li><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p>
</li>
<li><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
</li>
<li><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p>
</li>
</ul>
<h2 id="11-Redis发布订阅"><a href="#11-Redis发布订阅" class="headerlink" title="11 Redis发布订阅"></a>11 Redis发布订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、 微博、关注系统！ Redis 客户端可以订阅任意数量的频道。 订阅/发布消息图： 第一个：消息发送者， 第二个：频道 第三个：消息订阅者！</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215523258.png" alt></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321553483.png" alt></p>
<h3 id="11-1-命令"><a href="#11-1-命令" class="headerlink" title="11. 1 命令"></a>11. 1 命令</h3><ul>
<li><code>PSUBSCRIBE pattern [pattern..]</code> 订阅一个或多个符合给定模式的频道。</li>
<li><code>PUNSUBSCRIBE pattern [pattern..]</code> 退订一个或多个符合给定模式的频道。</li>
<li><code>PUBSUB subcommand [argument[argument]]</code> 查看订阅与发布系统状态。</li>
<li><code>PUBLISH channel message</code> 向指定频道发布消息</li>
<li><code>SUBSCRIBE channel [channel..]</code> 订阅给定的一个或多个频道。</li>
<li><code>UNSUBSCRIBE channel [channel..]</code> 退订一个或多个频道</li>
</ul>
<p><strong>代码示例</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell">------------订阅端----------------------
127.0.0.1:6379&gt; SUBSCRIBE pncalbl # 订阅sakura频道
Reading messages... (press Ctrl-C to quit) # 等待接收消息
1) &quot;subscribe&quot; # 订阅成功的消息
2) &quot;sakura&quot;
3) (integer) 1
1) &quot;message&quot; # 接收到来自sakura频道的消息 &quot;hello world&quot;
2) &quot;sakura&quot;
3) &quot;hello world&quot;
1) &quot;message&quot; # 接收到来自sakura频道的消息 &quot;hello i am sakura&quot;
2) &quot;sakura&quot;
3) &quot;hello i am sakura&quot;
--------------消息发布端-------------------
127.0.0.1:6379&gt; PUBLISH pncalbl &quot;hello world&quot; # 发布消息到sakura频道
(integer) 1
127.0.0.1:6379&gt; PUBLISH pncalbl &quot;hello i am pncalbl&quot; # 发布消息
(integer) 1
-----------------查看活跃的频道------------
127.0.0.1:6379&gt; PUBSUB channels

&quot;sakura&quot;</code></pre></div>

<h3 id="11-2-原理"><a href="#11-2-原理" class="headerlink" title="11.2 原理"></a>11.2 原理</h3><p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，借此加深对 Redis 的理解。</p>
<p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p>
<p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321554964.png" alt></p>
<p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p>
<h3 id="11-2-缺点"><a href="#11-2-缺点" class="headerlink" title="11.2 缺点"></a>11.2 缺点</h3><ol>
<li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li>
<li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</li>
</ol>
<h3 id="11-3-应用"><a href="#11-3-应用" class="headerlink" title="11.3 应用"></a>11.3 应用</h3><ol>
<li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li>
<li>多人在线聊天室。</li>
</ol>
<p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p>
<h2 id="12-Redis主从复制"><a href="#12-Redis主从复制" class="headerlink" title="12 Redis主从复制"></a>12 Redis主从复制</h2><h3 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h3><ul>
<li><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p>
</li>
<li><p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p>
</li>
</ul>
<h3 id="12-2-作用"><a href="#12-2-作用" class="headerlink" title="12.2 作用"></a>12.2 作用</h3><ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li>
<li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li>
<li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li>
</ol>
<h3 id="12-3-为什么使用集群"><a href="#12-3-为什么使用集群" class="headerlink" title="12.3 为什么使用集群"></a>12.3 为什么使用集群</h3><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p>
<ol>
<li><p>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</p>
</li>
<li><p>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。</p>
</li>
</ol>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
<p>对于这种场景，我们可以使如下这种架构：</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B007.jpg" alt></p>
<p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！</p>
<p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</p>
<p><strong>总结</strong></p>
<ol>
<li>单台服务器难以负载大量的请求</li>
<li>单台服务器故障率高，系统崩坏概率大</li>
<li>单台服务器内存容量有限。</li>
</ol>
<h3 id="12-4-环境配置"><a href="#12-4-环境配置" class="headerlink" title="12.4 环境配置"></a>12.4 环境配置</h3><p>只配置从库，不用配置主库！</p>
<div class="code-wrapper"><pre><code class="hljs ini">127.0.0.1:6379&gt; info replication
<span class="hljs-comment"># Replication</span>
role:master # 角色
connected_slaves:0 # 从机数量
master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0</code></pre></div>

<p>复制3个配置文件，然后修改对应的信息</p>
<ol>
<li>端口</li>
<li>pid名字</li>
<li>log文件名</li>
<li>dump.rdb名字</li>
</ol>
<p>启动单机多服务集群：</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215610163.png" alt></p>
<h4 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h4><p>默认情况下，每台Redis服务器都是主节点；我们一般情况下只用配置从机就好了！</p>
<p>认老大！一主（79）二从（80，81）</p>
<p>使用SLAVEOF host port就可以为从机配置主机了。</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215637483.png" alt></p>
<p><strong>说明</strong></p>
<ul>
<li><code>SLAVEOF host 6379</code> 找谁当自己的老大！</li>
<li><code>role:slave</code> # 当前角色是从机</li>
<li><code>master_host:127.0.0.1</code> # 可以的看到主机的信息</li>
<li>如果主机有密码，需要设置主机密码</li>
</ul>
<p>然后主机上也能看到从机的状态：</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215645778.png" alt></p>
<p><strong>说明</strong></p>
<ul>
<li><code>connected_slaves:1</code> # 多了从机的配置</li>
<li><code>slave0:ip=127.0.0.1,port=6380,state=online,offset=42,lag=1</code> # 多了从机的配置</li>
</ul>
<p>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！</p>
<h3 id="12-5-使用规则"><a href="#12-5-使用规则" class="headerlink" title="12.5 使用规则"></a>12.5 使用规则</h3><ol>
<li><p>从机只能读，不能写，主机可读可写但是多用于写。</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6381&gt; set name sakura # 从机6381写入失败
(error) READONLY You can&#x27;t write against a read only replica.
127.0.0.1:6380&gt; set name sakura # 从机6380写入失败
(error) READONLY You can&#x27;t write against a read only replica.
127.0.0.1:6379&gt; set name sakura
OK
127.0.0.1:6379&gt; get name
&quot;sakura&quot;</code></pre></div>
</li>
<li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p>
</li>
<li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p>
</li>
<li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p>
<ul>
<li>从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机</li>
<li>使用哨兵模式（自动选举）</li>
</ul>
</li>
<li><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p>
</li>
<li><p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么就重新连接！</p>
</li>
</ol>
<h3 id="12-6-复制原理"><a href="#12-6-复制原理" class="headerlink" title="12.6 复制原理"></a>12.6 复制原理</h3><p>Slave 启动成功连接到 master 后会发送一个sync同步命令</p>
<p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p>
<p><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p><strong>增量复制</strong>：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p>
<p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！</p>
<h2 id="13-哨兵模式"><a href="#13-哨兵模式" class="headerlink" title="13 哨兵模式"></a>13 哨兵模式</h2><p>（自动选举老大的模式）</p>
<h3 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h3><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。<strong>能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</strong></p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B008.jpg" alt></p>
<p>哨兵的作用：</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了<strong>多哨兵模式</strong>。</p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<h3 id="13-2-测试"><a href="#13-2-测试" class="headerlink" title="13.2 测试"></a>13.2 测试</h3><ol>
<li><p>配置哨兵配置文件 sentinel.conf</p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># sentinel monitor 被监控的名称 host port 1</span>
sentinel monitor myredis 127.0.0.1 6379 1</code></pre></div>

<p>后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！</p>
</li>
<li><p>启动哨兵！</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215752444.png" alt></p>
</li>
<li><p>此时哨兵监视着我们的主机6379，当我们断开主机后：</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215806972.png" alt></p>
</li>
</ol>
<h3 id="13-3-哨兵模式优缺点"><a href="#13-3-哨兵模式优缺点" class="headerlink" title="13.3 哨兵模式优缺点"></a>13.3 哨兵模式优缺点</h3><p>优点：</p>
<ol>
<li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li>
<li>主从可以切换，故障可以转移，系统的可用性更好</li>
<li>哨兵模式是主从模式的升级，手动到自动，更加健壮 缺点：</li>
<li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li>
</ol>
<h3 id="13-4-哨兵模式的全部配置"><a href="#13-4-哨兵模式的全部配置" class="headerlink" title="13.4 哨兵模式的全部配置"></a>13.4 哨兵模式的全部配置</h3><p>完整的哨兵模式配置文件 sentinel.conf</p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># Example sentinel.conf</span>
哨兵sentinel实例运行的端口 默认26379

port 26379


哨兵sentinel的工作目录

dir /tmp


哨兵sentinel监控的redis主节点的 ip port

master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。

quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了

sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;

sentinel monitor mymaster 127.0.0.1 6379 1


当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码

设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码

sentinel auth-pass &lt;master-name&gt; &lt;password&gt;

sentinel auth-pass mymaster MySUPER--secret-0123passw0rd


指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒

sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;

sentinel down-after-milliseconds mymaster 30000


这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，

这个数字越小，完成failover所需的时间就越长，

但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。

可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。


sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;

sentinel parallel-syncs mymaster 1


故障转移的超时时间 failover-timeout 可以用在以下这些方面：

1. 同一个sentinel对同一个master两次failover之间的间隔时间。

2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。

3.当想要取消一个正在进行的failover所需要的时间。

4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了

默认三分钟

sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;

sentinel failover-timeout mymaster 180000


SCRIPTS EXECUTION

配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。

对于脚本的运行结果有以下规则：

若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10

若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。

如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。

一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。

通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，

这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，

一个是事件的类型，

一个是事件的描述。

如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。

通知脚本

sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;

sentinel notification-script mymaster /var/redis/notify.sh


客户端重新配置主节点参数脚本

当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。

以下参数将会在调用脚本时传给脚本:

&lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;

目前&lt;state&gt;总是“failover”,

&lt;role&gt;是“leader”或者“observer”中的一个。

参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的

这个脚本应该是通用的，能被多次调用，不是针对性的。

sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;

sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</code></pre></div>

<h2 id="14-缓存穿透与雪崩"><a href="#14-缓存穿透与雪崩" class="headerlink" title="14 缓存穿透与雪崩"></a>14 缓存穿透与雪崩</h2><h3 id="14-1-缓存穿透（即查询不到）"><a href="#14-1-缓存穿透（即查询不到）" class="headerlink" title="14.1 缓存穿透（即查询不到）"></a>14.1 缓存穿透（即查询不到）</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h4><p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p>
<h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2 解决方案"></a>2 解决方案</h4><h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215824722.jpg" alt></p>
<h5 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a><strong>缓存空对象</strong></h5><p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215836317.jpg" alt></p>
<p>这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p>
<p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h3 id="14-2-缓存击穿（即量太大，缓存过期）"><a href="#14-2-缓存击穿（即量太大，缓存过期）" class="headerlink" title="14.2 缓存击穿（即量太大，缓存过期）"></a>14.2 缓存击穿（即量太大，缓存过期）</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1 概念"></a>1 概念</h4><ul>
<li><p>相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p>
</li>
<li><p>比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p>
</li>
</ul>
<h4 id="2-解决方案-1"><a href="#2-解决方案-1" class="headerlink" title="2 解决方案"></a>2 解决方案</h4><ol>
<li><p>设置热点数据永不过期</p>
<p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p>
</li>
<li><p>加互斥锁(分布式锁)</p>
<p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p>
</li>
</ol>
<h3 id="14-3-缓存雪崩"><a href="#14-3-缓存雪崩" class="headerlink" title="14.3 缓存雪崩"></a>14.3 缓存雪崩</h3><h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1 概念"></a>1 概念</h4><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>
<p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！</p>
<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215850428.jpeg" alt></p>
<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p>
<h4 id="2-解决方案-2"><a href="#2-解决方案-2" class="headerlink" title="2 解决方案"></a>2 解决方案</h4><blockquote>
<p>  redis高可用</p>
</blockquote>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p>
<blockquote>
<p>  限流降级</p>
</blockquote>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<blockquote>
<p>  数据预热</p>
</blockquote>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
]]></content>
      <categories>
        <category>Technical</category>
        <category>DB</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot 学习</title>
    <url>/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="SpringBoot-学习"><a href="#SpringBoot-学习" class="headerlink" title="SpringBoot 学习"></a>SpringBoot 学习</h1><h2 id="1-Spring-Boot-是什么"><a href="#1-Spring-Boot-是什么" class="headerlink" title="1 Spring Boot 是什么?"></a>1 Spring Boot 是什么?</h2><ul>
<li><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。</p>
</li>
<li><p>在 Spring 框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMVC 框架等，Spring 的核心内容在于控制反转( IOC )和依赖注入( DI ),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在 Spring 配置文件中创建，依赖注入即为由 Spring 容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。</p>
</li>
<li><p>Spring Boot 是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 Spring Boot 是一个服务于框架的框架，服务范围是简化配置文件。</p>
</li>
<li><p>Spring Boot 最明显的特点是，让文件配置变的相当简单、让应用部署变的简单（ Spring Boot 内置服务器，并装备启动类代码），可以快速开启一个 Web 容器进行开发。</p>
</li>
</ul>
<h3 id="1-1-程序打包"><a href="#1-1-程序打包" class="headerlink" title="1.1 程序打包"></a>1.1 程序打包</h3><ul>
<li><p>打包可能需要在 build 的 plugins 中加入以下插件，也可以通过降低 Spring Boot 的版本2.3。</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>

<span class="hljs-comment">&lt;!--spring-boot默认的配置,没有这个打包插件--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">skipTests</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">skipTests</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre></div>

</li>
</ul>
<h2 id="2-配置如何编写-yaml"><a href="#2-配置如何编写-yaml" class="headerlink" title="2 配置如何编写 yaml"></a>2 配置如何编写 yaml</h2><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">profiles:</span> <span class="hljs-string">default</span>
  <span class="hljs-attr">security:</span>
    <span class="hljs-attr">user:</span>
      <span class="hljs-attr">password:</span> <span class="hljs-string">weak</span></code></pre></div>

<p>注意：冒号之后必须加空格</p>
<h2 id="3-自动装配原理"><a href="#3-自动装配原理" class="headerlink" title="3 自动装配原理"></a>3 自动装配原理</h2><h3 id="3-1-自动配置"><a href="#3-1-自动配置" class="headerlink" title="3.1 自动配置"></a>3.1 自动配置</h3><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><ul>
<li>spring-boot-dependencies:  核心依赖在父工程中</li>
<li>我们在写或者引入一些 Spring Boot 依赖时候,不需要指定版本,就是因为有这些版本仓库</li>
</ul>
<h3 id="3-2-启动器"><a href="#3-2-启动器" class="headerlink" title="3.2 启动器"></a>3.2 启动器</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<ul>
<li>说白了,启动器就是 Spring Boot 启动场景。</li>
<li>比如 spring-boot-starter-web ，他就会帮我们自动导入 web 环境的所有依赖！</li>
<li>Spring Boot 会将所有的功能场景，都变成一个个启动器</li>
<li>我们要使用什么功能，就只需找到对应的启动器就可以 <strong>stater</strong></li>
</ul>
<h3 id="3-3-主程序"><a href="#3-3-主程序" class="headerlink" title="3.3 主程序"></a>3.3 主程序</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// @SpringBootApplication: 标注这个类是一个Spring Boot 应用</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot01HelloworldApplication</span> </span>&#123;

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      SpringApplication.run(Springboot01HelloworldApplication.class, args);
   &#125;

&#125;</code></pre></div>

<h3 id="3-4-注解"><a href="#3-4-注解" class="headerlink" title="3.4 注解"></a>3.4 注解</h3>   <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span>	<span class="hljs-comment">// Spring Boot 的配置</span>
	<span class="hljs-meta">@Configuration</span> 	<span class="hljs-comment">// Spring 的配置类</span>
		<span class="hljs-meta">@Component</span>		<span class="hljs-comment">// 说明这也是一个Spring的组件</span>
<span class="hljs-meta">@EnableAutoConfiguration</span>	  <span class="hljs-comment">// 自动配置包</span>
	<span class="hljs-meta">@AutoConfigurationPackage</span> <span class="hljs-comment">// 自动配置包</span>
	<span class="hljs-meta">@Import(&#123;AutoConfigurationPackages.Registrar.class&#125;)</span>	<span class="hljs-comment">// 自动配置包注册</span>
	<span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span>	<span class="hljs-comment">// 自动配置导入选择</span></code></pre></div>

   <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获取所有的配置</span>
List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</code></pre></div>

   <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;
    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());
    Assert.notEmpty(configurations, <span class="hljs-string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);
    <span class="hljs-keyword">return</span> configurations;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml">META-INF/spring.factories	// 自动配置的核心文件</code></pre></div>

<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210412222820485.png" alt="image-20210412222820485"></p>
<h2 id="4-Web开发"><a href="#4-Web开发" class="headerlink" title="4 Web开发"></a>4 Web开发</h2><h3 id="4-0-配置-log4j2"><a href="#4-0-配置-log4j2" class="headerlink" title="4.0 配置 log4j2"></a>4.0 配置 log4j2</h3><p><a href="https://zhuanlan.zhihu.com/p/244943401">参考文档</a></p>
<ul>
<li><p>修改 pom.xm</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--web--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-comment">&lt;!-- 去掉springboot默认配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-comment">&lt;!--log4j2--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-comment">&lt;!-- 引入log4j2依赖 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>编写配置文件</p>
<ul>
<li><p>需要加入 JVM 参数 ：-Dlog4j.skipJansi=false</p>
</li>
<li><p>如果自定义了文件名，需要在application.yml中配置</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span>
  <span class="hljs-attr">config:</span> <span class="hljs-string">xxxx.xml</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">cn.jay.repository:</span> <span class="hljs-string">trace</span></code></pre></div>
</li>
<li><p>可以直接在yml中配置日志输出格式</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span>
  <span class="hljs-comment">#  控制台打印格式</span>
  <span class="hljs-attr">pattern:</span>
    <span class="hljs-attr">console:</span> <span class="hljs-string">&quot;%style&#123;%d&#123;yyyy-MM-dd HH:mm:ss&#125;&#125;&#123;red&#125; %style&#123;[%thread]&#125;&#123;blue&#125; %style&#123;%-5level&#125;&#123;cyan&#125;:%highlight&#123;%m%n&#125;&quot;</span>
  <span class="hljs-comment">#    log文件输出路径</span>
  <span class="hljs-attr">file:</span>
    <span class="hljs-attr">path:</span> <span class="hljs-string">log</span></code></pre></div>

<p>这样就不用编写专门的log配置文件</p>
</li>
<li><p>默认文件名 log4j2-spring.xml</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span>
<span class="hljs-comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">monitorInterval</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span>
	<span class="hljs-comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span>
	
	<span class="hljs-comment">&lt;!--变量配置--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">Properties</span>&gt;</span>
		<span class="hljs-comment">&lt;!-- 格式化输出：%date表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符--&gt;</span>
		<span class="hljs-comment">&lt;!-- %logger&#123;36&#125; 表示 Logger 名字最长36个字符 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_PATTERN&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%style&#123;%d&#123;yyyy-MM-dd HH:mm:ss&#125;&#125;&#123;red&#125; %style&#123;[%thread]&#125;&#123;blue&#125; %style&#123;%-5level&#125;&#123;cyan&#125;:%highlight&#123;%m%n&#125;&quot;</span>/&gt;</span>
		<span class="hljs-comment">&lt;!-- 定义日志存储的路径 --&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_PATH&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;log&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_NAME&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;springboot_04_web_db&quot;</span>/&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">Properties</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">appenders</span>&gt;</span>
		
		<span class="hljs-tag">&lt;<span class="hljs-name">console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span>
			<span class="hljs-comment">&lt;!--输出日志的格式--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span>
			<span class="hljs-comment">&lt;!--控制台只输出level及其以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;DENY&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">console</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Filelog&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;FILE_PATH&#125;/test.log&quot;</span> <span class="hljs-attr">append</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileInfo&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;FILE_PATH&#125;/info.log&quot;</span></span>
<span class="hljs-tag">		             <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-INFO-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span>
			<span class="hljs-comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;DENY&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>
				<span class="hljs-comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;10MB&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>
			<span class="hljs-comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;15&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!-- 这个会打印出所有的warn及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileWarn&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;FILE_PATH&#125;/warn.log&quot;</span></span>
<span class="hljs-tag">		             <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-WARN-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span>
			<span class="hljs-comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;warn&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;DENY&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>
				<span class="hljs-comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;10MB&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>
			<span class="hljs-comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;15&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!-- 这个会打印出所有的error及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileError&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;FILE_PATH&#125;/error.log&quot;</span></span>
<span class="hljs-tag">		             <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-ERROR-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span>
			<span class="hljs-comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;DENY&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span>
				<span class="hljs-comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;10MB&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span>
			<span class="hljs-comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;15&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span>
	
	<span class="hljs-tag">&lt;/<span class="hljs-name">appenders</span>&gt;</span>
	
	<span class="hljs-comment">&lt;!--Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。--&gt;</span>
	<span class="hljs-comment">&lt;!--然后定义loggers，只有定义了logger并引入的appender，appender才会生效--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">loggers</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span>
		<span class="hljs-comment">&lt;!--监控系统信息--&gt;</span>
		<span class="hljs-comment">&lt;!--若是additivity设为false，则 子Logger 只会在自己的appender里输出，而不会在 父Logger 的appender里输出。--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span>
		
		<span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Filelog&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileInfo&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileWarn&quot;</span>/&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileError&quot;</span>/&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">loggers</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div>



</li>
</ul>
</li>
</ul>
<div class="code-wrapper"><pre><code>-   配置参数说明

    -   机制：如果一条日志信息的级别大于等于配置文件的级别，就记录。
    -   trace：追踪，就是程序推进一下，可以写个trace输出
    -   trace：追踪，就是程序推进一下，可以写个trace输出
    -   debug：调试，一般作为最低级别，trace基本不用。
    -   info：输出重要的信息，使用较多
    -   warn：警告，有些信息不是错误信息，但也要给程序员一些提示。
    -   error：错误信息。用的也很多。
    -   fatal：致命错误。

-   输出源

    -   CONSOLE（输出到控制台）
    -   FILE（输出到文件）

-   格式

    -   SimpleLayout：以简单的形式显示

    -   HTMLLayout：以HTML表格显示

    -   PatternLayout：自定义形式显示

        <pre><code class="hljs xml">%d&#123;yyyy-MM-dd HH:mm:ss, SSS&#125; : 日志生产时间,输出到毫秒的时间
%-5level : 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0
%c : logger的名称(%logger)
%t : 输出当前线程名称
%p : 日志输出格式
%m : 日志内容，即 logger.info(&quot;message&quot;)
%n : 换行符
%C : Java类名(%F)
%L : 行号
%M : 方法名
%l : 输出语句所在的行数, 包括类名、方法名、文件名、行数
hostName : 本地机器名
hostAddress : 本地ip地址</code></pre></div>



    -   示例

        <div class="code-wrapper"><pre><code class="hljs xml">PatternLayout pattern = &quot;&quot;%style&#123;%d&#123;yyyy-MM-dd HH:mm:ss&#125;&#125;&#123;red&#125; %style&#123;[%thread]&#125;&#123;blue&#125; %style&#123;%-5level&#125;&#123;cyan&#125;:%highlight&#123;%m%n&#125;&quot;</code></pre></div></code></pre><ul>
<li><p>使用</p>
<ul>
<li><p>获取logger对象</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> org.slf4j.Logger logger = LoggerFactory.getLogger(Log4j2Controller.class);</code></pre></div>
</li>
<li><p>使用 @Slf4j 注解 </p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 使用 @Slf4j 注解 , 可以简化 logger 的获取</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;

	<span class="hljs-meta">@Resource</span>
	<span class="hljs-keyword">private</span> UserMapper userMapper;


	<span class="hljs-meta">@GetMapping(value = &quot;/list&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryList</span><span class="hljs-params">()</span> </span>&#123;
		List&lt;User&gt; users = userMapper.queryUserList();
		log.info(<span class="hljs-string">&quot;查询所有用户成功.&quot;</span>);
		<span class="hljs-keyword">return</span> users;
	&#125;
&#125;</code></pre></div>



</li>
</ul>
</li>
</ul>
<h3 id="4-1-静态资源导入"><a href="#4-1-静态资源导入" class="headerlink" title="4.1 静态资源导入"></a>4.1 静态资源导入</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;
    <span class="hljs-keyword">super</span>.addResourceHandlers(registry);
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;
        logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        ServletContext servletContext = <span class="hljs-keyword">this</span>.getServletContext();
        <span class="hljs-keyword">this</span>.addResourceHandler(registry, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);
        <span class="hljs-keyword">this</span>.addResourceHandler(registry, <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;
            registration.addResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());
            <span class="hljs-keyword">if</span> (servletContext != <span class="hljs-keyword">null</span>) &#123;
                registration.addResourceLocations(<span class="hljs-keyword">new</span> Resource[]&#123;<span class="hljs-keyword">new</span> ServletContextResource(servletContext, <span class="hljs-string">&quot;/&quot;</span>)&#125;);
            &#125;

        &#125;);
    &#125;
&#125;</code></pre></div>

<p>总结:</p>
<ol>
<li><p>在springboot，我们可以使用以下方式处理静态资源</p>
<ul>
<li>webjars    <strong>localhost:8080/webjars/</strong></li>
<li>public, static, /**, resources    localhost:8080/</li>
</ul>
</li>
<li><p>优先级：resources &gt; static(默认) &gt; public</p>
</li>
</ol>
<h3 id="4-2-首页如何定制"><a href="#4-2-首页如何定制" class="headerlink" title="4.2 首页如何定制"></a>4.2 首页如何定制</h3><ul>
<li><p>模板引擎</p>
</li>
<li><p>使用thymeleaf， 只需要导入对应的依赖就行了</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Thymeleaf--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>在自己写的 controller 上加注解 @Controller </p>
</li>
<li><p>@RestController注解<br>相当于@Controller+@ResponseBody两个注解的结合，返回json数据不需要在方法前面加@ResponseBody注解了，但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 如果，你想自定义一些定制化功能，只要写这个组件，然后将它交给springboot，springboot就会帮我们自动装配</span>
<span class="hljs-comment">// 扩展springmvc配置</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;

   <span class="hljs-meta">@Bean</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> ViewResolver <span class="hljs-title">myViewResolver</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyViewResolver();
   &#125;

   <span class="hljs-comment">// 自定义了一个自己的视图解析器</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyViewResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewResolver</span> </span>&#123;

      <span class="hljs-meta">@Override</span>
      <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String s, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
      &#125;
   &#125;
&#125;</code></pre></div>



</li>
</ul>
<h3 id="4-3-国际化"><a href="#4-3-国际化" class="headerlink" title="4.3 国际化"></a>4.3 国际化</h3><ul>
<li><p>新建文件夹 i8n (international)</p>
</li>
<li><p>login.properties</p>
</li>
<li><p>login_zh_CN.properties</p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">login.btn</span>=<span class="hljs-string">登录</span>
<span class="hljs-meta">login.password</span>=<span class="hljs-string">密码</span>
<span class="hljs-meta">login.remember</span>=<span class="hljs-string">记住我</span>
<span class="hljs-meta">login.tip</span>=<span class="hljs-string">请登录</span>
<span class="hljs-meta">login.username</span>=<span class="hljs-string">用户名</span></code></pre></div>
</li>
<li><p>login_en_US.properties</p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">login.btn</span>=<span class="hljs-string">Sign in</span>
<span class="hljs-meta">login.password</span>=<span class="hljs-string">Password</span>
<span class="hljs-meta">login.remember</span>=<span class="hljs-string">Remember me</span>
<span class="hljs-meta">login.tip</span>=<span class="hljs-string">Please sign in</span>
<span class="hljs-meta">login.username</span>=<span class="hljs-string">Username</span></code></pre></div>
</li>
<li><p>编写自己的本地解析器 MyLocaleResolver </p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLocaleResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LocaleResolver</span> </span>&#123;

   <span class="hljs-comment">// 解析请求</span>
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest httpServletRequest)</span> </span>&#123;
      <span class="hljs-comment">// 获取请求中的参数</span>
      String language = httpServletRequest.getParameter(<span class="hljs-string">&quot;l&quot;</span>);
      Locale locale = Locale.getDefault();    <span class="hljs-comment">// 如果没有就使用默认的</span>

      <span class="hljs-comment">// 如果请求的链接携带了国际化的参数</span>
      <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(language)) &#123;
         <span class="hljs-comment">// zh_CN</span>
         String[] split = language.split(<span class="hljs-string">&quot;_&quot;</span>);
         <span class="hljs-comment">// 国家 地区</span>
         locale = <span class="hljs-keyword">new</span> Locale(split[<span class="hljs-number">0</span>], split[<span class="hljs-number">1</span>]);
      &#125;
      <span class="hljs-keyword">return</span> locale;
   &#125;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocale</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale)</span> </span>&#123;

   &#125;
&#125;</code></pre></div>
</li>
<li><p>在 MyMvcConfig 配置增加</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 自定义的国际化组件</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyLocaleResolver();
&#125;</code></pre></div>
</li>
<li><p>修改静态资源</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-signin&quot;</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/user/login&#125;&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mb-4&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/asserts/img/bootstrap-solid.svg&#125;&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;72&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;72&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;h3 mb-3 font-weight-normal&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;login.tip&#125;&quot;</span>&gt;</span>Please sign in<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

	<span class="hljs-comment">&lt;!--如果msg的值为空, 则不显示错误消息--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;msg&#125;&quot;</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sr-only&quot;</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">th:placeholder</span>=<span class="hljs-string">&quot;#&#123;login.username&#125;&quot;</span> <span class="hljs-attr">required</span>=<span class="hljs-string">&quot;&quot;</span></span>
<span class="hljs-tag">		       <span class="hljs-attr">autofocus</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sr-only&quot;</span>&gt;</span>Password<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">th:placeholder</span>=<span class="hljs-string">&quot;#&#123;login.password&#125;&quot;</span> <span class="hljs-attr">required</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;checkbox mb-3&quot;</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;remember-me&quot;</span>&gt;</span> [[#&#123;login.remember&#125;]]
		<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-lg btn-primary btn-block&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>[[#&#123;login.btn&#125;]]<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mt-5 mb-3 text-muted&quot;</span>&gt;</span>© 2020-2021<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;</span>&gt;</span>中文<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;</span>&gt;</span>English<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div>

</li>
</ul>
<h3 id="4-4-用户登录"><a href="#4-4-用户登录" class="headerlink" title="4.4 用户登录"></a>4.4 用户登录</h3><ul>
<li><p>编写 LoginController</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.controller;

<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;
<span class="hljs-keyword">import</span> org.springframework.ui.Model;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;
<span class="hljs-keyword">import</span> org.thymeleaf.util.StringUtils;

<span class="hljs-keyword">import</span> javax.servlet.http.HttpSession;


<span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;

   <span class="hljs-meta">@RequestMapping(value = &quot;/user/login&quot;)</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span>
<span class="hljs-function"><span class="hljs-params">                       <span class="hljs-meta">@RequestParam(&quot;password&quot;)</span> String password,</span></span>
<span class="hljs-function"><span class="hljs-params">                       Model model, HttpSession session)</span> </span>&#123;
      <span class="hljs-comment">// 具体的业务</span>
      <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(username) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(password)) &#123;
         session.setAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>, username);
         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/main.html&quot;</span>;
      &#125; <span class="hljs-keyword">else</span> &#123;
         <span class="hljs-comment">// 告诉用户, 你登陆失败</span>
         model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;用户名或者密码错误!&quot;</span>);
         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;
      &#125;
   &#125;
&#125;</code></pre></div>
</li>
<li><p>在 MyMvcConfig 配置增加</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;
   registry.addViewController(<span class="hljs-string">&quot;/&quot;</span>).setViewName(<span class="hljs-string">&quot;index&quot;</span>);
   registry.addViewController(<span class="hljs-string">&quot;/index.html&quot;</span>).setViewName(<span class="hljs-string">&quot;index&quot;</span>);
   registry.addViewController(<span class="hljs-string">&quot;/main.html&quot;</span>).setViewName(<span class="hljs-string">&quot;dashboard&quot;</span>);
&#125;</code></pre></div>

</li>
</ul>
<h3 id="4-5-登录拦截"><a href="#4-5-登录拦截" class="headerlink" title="4.5 登录拦截"></a>4.5 登录拦截</h3><ul>
<li><p>编写 LoginHandlerInterceptor 拦截器</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.config;

<span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;

<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginHandlerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;

   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
      <span class="hljs-comment">// 登录成功之后, 应该有用户的Session</span>
      Object loginUser = request.getSession().getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>);
      <span class="hljs-keyword">if</span> (loginUser == <span class="hljs-keyword">null</span>) &#123;
         request.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;没有权限, 请先登录!&quot;</span>);
         request.getRequestDispatcher(<span class="hljs-string">&quot;/index.html&quot;</span>).forward(request, response);
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;
&#125;</code></pre></div>
</li>
<li><p>在 MyMvcConfig 配置增加</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;
   registry.addInterceptor(<span class="hljs-keyword">new</span> LoginHandlerInterceptor())
         .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).excludePathPatterns(<span class="hljs-string">&quot;/index.html&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/user/login&quot;</span>, <span class="hljs-string">&quot;/asserts/**&quot;</span>);

&#125;</code></pre></div>

</li>
</ul>
<p>注意：看一下静态资源是否正常导出，以及所有的bean是否注入，以防止空指针异常。</p>
<h2 id="5-集成数据库-Druid"><a href="#5-集成数据库-Druid" class="headerlink" title="5 集成数据库: Druid"></a>5 集成数据库: Druid</h2><p>注意 thymeleaf 版本可能导致视图无法解析最好直接导入springboot的启动器</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Thymeleaf--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h3 id="5-0-Druid简介"><a href="#5-0-Druid简介" class="headerlink" title="5.0 Druid简介"></a>5.0 Druid简介</h3><p>Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。</p>
<p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。</p>
<p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p>
<p>Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p>
<p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p>
<p>Github地址：<a href="https://github.com/alibaba/druid/">https://github.com/alibaba/druid/</a></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/640" alt="图片"></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/640" alt="图片"></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/640" alt="图片"></p>
<h3 id="5-1-配置数据源"><a href="#5-1-配置数据源" class="headerlink" title="5.1 配置数据源"></a>5.1 配置数据源</h3><ol>
<li><p>添加上 Druid 数据源依赖。</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--druid--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springbootweb?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=GMT</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span></code></pre></div>
</li>
<li><p>数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换；</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210513213156118.png" alt="image-20210513213156118"></p>
</li>
</ol>
<ol start="4">
<li><p>切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span>
    <span class="hljs-comment">#?serverTimezone=UTC解决时区的报错</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>

    <span class="hljs-comment">#Spring Boot 默认是不注入这些属性值的，需要自己绑定</span>
    <span class="hljs-comment">#druid 数据源专有配置</span>
    <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span>
    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">5</span>
    <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span>
    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span>
    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span>
    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span>
    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span>
    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span>
    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span>
    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span>

    <span class="hljs-comment">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span>
    <span class="hljs-comment">#如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span>
    <span class="hljs-comment">#则导入 log4j2 依赖即可，需要加 虚拟机参数 ：-Dlog4j.skipJansi=false 彩色才能生效</span>
    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j2</span>
    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span>
    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></code></pre></div>
</li>
<li><p>现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性；</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;

   <span class="hljs-comment">/*</span>
<span class="hljs-comment">      将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建</span>
<span class="hljs-comment">      绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效</span>
<span class="hljs-comment">      @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中</span>
<span class="hljs-comment">      前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中</span>
<span class="hljs-comment">    */</span>
   <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span>
   <span class="hljs-meta">@Bean</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();
   &#125;

&#125;</code></pre></div>
</li>
<li><p>去测试类中测试一下；看是否成功！</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;
	<span class="hljs-comment">//看一下默认数据源</span>
	System.out.println(dataSource.getClass());
	<span class="hljs-comment">//获得连接</span>
	Connection connection = dataSource.getConnection();
	System.out.println(connection);
    
	DruidDataSource druidDataSource = (DruidDataSource) dataSource;
	System.out.println(<span class="hljs-string">&quot;druidDataSource 数据源最大连接数：&quot;</span> + druidDataSource.getMaxActive());
	System.out.println(<span class="hljs-string">&quot;druidDataSource 数据源初始化连接数：&quot;</span> + druidDataSource.getInitialSize());
    
	<span class="hljs-comment">//关闭连接</span>
	connection.close();
&#125;</code></pre></div>

<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210514000156060.png" alt="image-20210514000156060"></p>
</li>
</ol>
<h3 id="5-2-配置Druid数据源监控"><a href="#5-2-配置Druid数据源监控" class="headerlink" title="5.2 配置Druid数据源监控"></a>5.2 配置Druid数据源监控</h3><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。</p>
<ul>
<li><p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//配置 Druid 监控管理后台的Servlet；</span>
<span class="hljs-comment">//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">statViewServlet</span><span class="hljs-params">()</span> </span>&#123;
    ServletRegistrationBean bean = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> StatViewServlet(), <span class="hljs-string">&quot;/druid/*&quot;</span>);

    <span class="hljs-comment">// 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet </span>
    <span class="hljs-comment">// 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到</span>
    Map&lt;String, String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    initParams.put(<span class="hljs-string">&quot;loginUsername&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>); <span class="hljs-comment">//后台管理界面的登录账号</span>
    initParams.put(<span class="hljs-string">&quot;loginPassword&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>); <span class="hljs-comment">//后台管理界面的登录密码</span>

    <span class="hljs-comment">//后台允许谁可以访问</span>
    <span class="hljs-comment">//initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问</span>
    <span class="hljs-comment">//initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问</span>
    initParams.put(<span class="hljs-string">&quot;allow&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
    <span class="hljs-comment">//deny：Druid 后台拒绝谁访问</span>
    <span class="hljs-comment">//initParams.put(&quot;kuangshen&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问</span>

    <span class="hljs-comment">//设置初始化参数</span>
    bean.setInitParameters(initParams);
    <span class="hljs-keyword">return</span> bean;
&#125;</code></pre></div>

<ul>
<li><p>配置完毕后，我们可以选择访问 ：<a href="http://localhost:8080/druid/login.html">http://localhost:8080/druid/login.html</a></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210514011355470.png" alt="image-20210514011355470"></p>
</li>
<li><p>进入之后</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210514011404820.png" alt="image-20210514011404820"></p>
</li>
</ul>
</li>
<li><p><strong>配置 Druid web 监控 filter 过滤器</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//配置 Druid 监控 之  web 监控的 filter</span>
<span class="hljs-comment">//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">webStatFilter</span><span class="hljs-params">()</span> </span>&#123;
    FilterRegistrationBean bean = <span class="hljs-keyword">new</span> FilterRegistrationBean();
    bean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());

    <span class="hljs-comment">//exclusions：设置哪些请求进行过滤排除掉，从而不进行统计</span>
    Map&lt;String, String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    initParams.put(<span class="hljs-string">&quot;exclusions&quot;</span>, <span class="hljs-string">&quot;*.js,*.css,/druid/*,/jdbc/*&quot;</span>);
    bean.setInitParameters(initParams);

    <span class="hljs-comment">//&quot;/*&quot; 表示过滤所有请求</span>
    bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">&quot;/*&quot;</span>));
    <span class="hljs-keyword">return</span> bean;
&#125;</code></pre></div>

<p>平时在工作中，按需求进行配置即可，主要用作监控！</p>
</li>
</ul>
<h2 id="6-整合Mybatis框架"><a href="#6-整合Mybatis框架" class="headerlink" title="6 整合Mybatis框架"></a>6 整合Mybatis框架</h2><h3 id="6-1-POM"><a href="#6-1-POM" class="headerlink" title="6.1 POM"></a>6.1 POM</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>

    <span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">   依赖的顺序最后不要变,因为引入log4j2, 需要排除web自带的logging</span>
<span class="hljs-comment">   所以web在前, log4j2在后, 约定大于配置</span>
<span class="hljs-comment">  --&gt;</span>
    <span class="hljs-comment">&lt;!--web--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!--log4j2--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!--test--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!--lombok--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!--jdbc--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!--mybatis--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!--mysql--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!--druid--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!--Thymeleaf--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

<h3 id="6-2-写YML"><a href="#6-2-写YML" class="headerlink" title="6.2 写YML"></a>6.2 写YML</h3><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">banner:</span>
    <span class="hljs-attr">location:</span> <span class="hljs-string">banner.txt</span>
  <span class="hljs-attr">thymeleaf:</span>
    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=GMT</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>

    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j2</span>
    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span>
    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span>

<span class="hljs-attr">logging:</span>
  <span class="hljs-comment">#  控制台打印格式</span>
  <span class="hljs-attr">pattern:</span>
    <span class="hljs-attr">console:</span> <span class="hljs-string">&quot;%style&#123;%d&#123;yyyy-MM-dd HH:mm:ss&#125;&#125;&#123;red&#125; %style&#123;[%thread]&#125;&#123;blue&#125; %style&#123;%-5level&#125;&#123;cyan&#125;:%highlight&#123;%m%n&#125;&quot;</span>
  <span class="hljs-comment">#    log文件输出路径</span>
  <span class="hljs-attr">file:</span>
    <span class="hljs-attr">path:</span> <span class="hljs-string">log</span>

<span class="hljs-attr">mybatis:</span>
  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.pnca.pojo</span>
  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:com/pnca/mapper/*Mapper.xml</span></code></pre></div>

<p>测试数据能否连接</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210517200138052.png" alt="image-20210517200138052"></p>
<h3 id="6-3-实体类"><a href="#6-3-实体类" class="headerlink" title="6.3 实体类"></a>6.3 实体类</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.pojo;

<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;
<span class="hljs-keyword">import</span> lombok.Data;
<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/5/17 19:49</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
   <span class="hljs-keyword">private</span> String name;
   <span class="hljs-keyword">private</span> String pwd;
&#125;</code></pre></div>

<h3 id="6-4-Mapper"><a href="#6-4-Mapper" class="headerlink" title="6.4 Mapper"></a>6.4 Mapper</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// @Mapper, 表示这是一个 mybatis 的 mapper 类</span>
<span class="hljs-meta">@Mapper</span>
<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;
	<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">queryUserList</span><span class="hljs-params">()</span></span>;

	<span class="hljs-function">User <span class="hljs-title">queryUserById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>;

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span>
<span class="hljs-meta">		<span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span>
<span class="hljs-meta">		<span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.pnca.mapper.UserMapper&quot;</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>
		select u.id, u.name, u.pwd
		from mybatis.user u;
	<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>
		select u.id, u.name, u.pwd
		from mybatis.user u
		where u.id = #&#123;id&#125;
	<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>
		insert into mybatis.user (id, name, pwd)
		values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)
	<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span>
		update mybatis.user u
		set u.name = #&#123;name&#125;,
		    u.pwd  = #&#123;pwd&#125;
		where u.id = #&#123;id&#125;
	<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span>&gt;</span>
		delete
		from mybatis.user u
		where u.id = #&#123;id&#125;
	<span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div>

<h3 id="6-5-Controller"><a href="#6-5-Controller" class="headerlink" title="6.5 Controller"></a>6.5 Controller</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;

	<span class="hljs-meta">@Resource</span>
	<span class="hljs-keyword">private</span> UserMapper userMapper;

	<span class="hljs-meta">@GetMapping(value = &quot;/list&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryList</span><span class="hljs-params">(Model model)</span> </span>&#123;
		List&lt;User&gt; users = userMapper.queryUserList();
		log.info(<span class="hljs-string">&quot;=============&gt; 查询所有用户成功.&quot;</span>);
		log.info(String.valueOf(users));
		model.addAttribute(<span class="hljs-string">&quot;users&quot;</span>, users);
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user/list&quot;</span>;
	&#125;

	<span class="hljs-meta">@GetMapping(value = &quot;/query/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">queryUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model)</span> </span>&#123;
		User user = userMapper.queryUserById(id);
		log.info(<span class="hljs-string">&quot;=============&gt; 查询用户&quot;</span> + id + <span class="hljs-string">&quot; 成功.&quot;</span>);
		model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/list&quot;</span>;
	&#125;

	<span class="hljs-meta">@GetMapping(value = &quot;/add&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span> </span>&#123;
		<span class="hljs-keyword">int</span> i = userMapper.addUser(user);
		<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;
			log.info(<span class="hljs-string">&quot;=============&gt; 增加用户&quot;</span> + user.getName() + <span class="hljs-string">&quot;成功.&quot;</span>);
		&#125; <span class="hljs-keyword">else</span> &#123;
			log.info(<span class="hljs-string">&quot;=============&gt; 增加用户&quot;</span> + user.getName() + <span class="hljs-string">&quot;失败.&quot;</span>);
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/list&quot;</span>;
	&#125;

	<span class="hljs-meta">@GetMapping(value = &quot;/update&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span> </span>&#123;
		<span class="hljs-keyword">int</span> i = userMapper.updateUser(user);
		<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;
			log.info(<span class="hljs-string">&quot;=============&gt; 更新用户&quot;</span> + user.getName() + <span class="hljs-string">&quot; 成功.&quot;</span>);
		&#125; <span class="hljs-keyword">else</span> &#123;
			log.info(<span class="hljs-string">&quot;=============&gt; 更新用户&quot;</span> + user.getName() + <span class="hljs-string">&quot; 失败.&quot;</span>);
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/list&quot;</span>;
	&#125;

	<span class="hljs-meta">@GetMapping(value = &quot;/delete/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
		<span class="hljs-keyword">int</span> i = userMapper.deleteUser(id);
		<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;
			log.info(<span class="hljs-string">&quot;=============&gt; 删除用户&quot;</span> + id + <span class="hljs-string">&quot; 成功.&quot;</span>);
		&#125; <span class="hljs-keyword">else</span> &#123;
			log.info(<span class="hljs-string">&quot;=============&gt; 删除用户&quot;</span> + id + <span class="hljs-string">&quot; 失败.&quot;</span>);
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/list&quot;</span>;
	&#125;

&#125;</code></pre></div>

<p>list.html</p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>用户列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table-responsive&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table table-striped table-sm&quot;</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>ID<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;user:$&#123;users&#125;&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.getId()&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.getName()&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.getPwd()&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>



<h3 id="6-6-测试"><a href="#6-6-测试" class="headerlink" title="6.6 测试"></a>6.6 测试</h3><p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210518130701698.png" alt="image-20210518130701698"></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210518130726107.png" alt="image-20210518130726107"></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210518130754077.png" alt="image-20210518130754077"></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210518130802626.png" alt="image-20210518130802626"></p>
<h2 id="7-SpringSecurity"><a href="#7-SpringSecurity" class="headerlink" title="7 SpringSecurity"></a>7 SpringSecurity</h2><h3 id="7-1-为什么使用安全框架"><a href="#7-1-为什么使用安全框架" class="headerlink" title="7.1 为什么使用安全框架?"></a>7.1 为什么使用安全框架?</h3><ul>
<li><p>在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：</p>
<ul>
<li>一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；</li>
<li>另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</li>
</ul>
</li>
<li><p>市面上存在比较有名的：Shiro，Spring Security ！</p>
</li>
<li><p>这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？</p>
</li>
<li><p>首先我们看下它的官网介绍：Spring Security官网地址</p>
<ul>
<li>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</li>
<li>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。</li>
<li>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</li>
<li>Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求</li>
</ul>
</li>
<li><p>从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。</p>
</li>
<li><p>怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。</p>
</li>
<li><p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户（Authentication）和用户授权（Authorization）两个部分。</p>
<ul>
<li>用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。</li>
<li>用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</li>
</ul>
</li>
<li><p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。</p>
<ul>
<li>在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。</li>
<li>在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</li>
</ul>
</li>
</ul>
<h3 id="7-2-搭建基础环境"><a href="#7-2-搭建基础环境" class="headerlink" title="7.2 搭建基础环境"></a>7.2 搭建基础环境</h3><ul>
<li><p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml-dtd">&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;
		&lt;&#x2F;dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;
		&lt;&#x2F;dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;
		&lt;&#x2F;dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.thymeleaf.extras&lt;&#x2F;groupId&gt;
			&lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;&#x2F;artifactId&gt;
		&lt;&#x2F;dependency&gt;
		
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;
			&lt;scope&gt;test&lt;&#x2F;scope&gt;
		&lt;&#x2F;dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;
			&lt;artifactId&gt;spring-security-test&lt;&#x2F;artifactId&gt;
			&lt;scope&gt;test&lt;&#x2F;scope&gt;
		&lt;&#x2F;dependency&gt;
	&lt;&#x2F;dependencies&gt;</code></pre></div>
</li>
<li><p>导入静态资源</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210521000651281.png" alt="image-20210521000651281"></p>
</li>
<li><p>Controller</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.controller;

<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/5/20 23:46</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouterController</span> </span>&#123;

	<span class="hljs-meta">@RequestMapping(value = &#123;&quot;/&quot;, &quot;/index&quot;&#125;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;
	&#125;

	<span class="hljs-meta">@RequestMapping(value = &quot;/toLogin&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLogin</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;views/login&quot;</span>;
	&#125;

	<span class="hljs-meta">@RequestMapping(value = &quot;/level1/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLogin1</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;views/level1/&quot;</span> + id;
	&#125;

	<span class="hljs-meta">@RequestMapping(value = &quot;/level2/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLogin2</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;views/level2/&quot;</span> + id;
	&#125;

	<span class="hljs-meta">@RequestMapping(value = &quot;/level3/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLogin3</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;views/level3/&quot;</span> + id;
	&#125;
&#125;</code></pre></div>
</li>
<li><p>启动测试</p>
<ul>
<li><p>用户名: user</p>
</li>
<li><p>密码: 控制台打印</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210521000823763.png" alt="image-20210521000823763"></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210521000837727.png" alt="image-20210521000837727"></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210521000850040.png" alt="image-20210521000850040"></p>
</li>
</ul>
</li>
</ul>
<h3 id="7-3用户认证和授权"><a href="#7-3用户认证和授权" class="headerlink" title="7.3用户认证和授权"></a>7.3用户认证和授权</h3><p>认证: Authenticate</p>
<p>授权: Authorization</p>
<blockquote>
<p>  WebSecurityConfigAdapter: 自定义Security策略</p>
<p>  AuthenticationManagerBuilder: 自定义认证策略</p>
<p>  @EnableWebSecurity: 开启WebSecurity模式</p>
</blockquote>
<ul>
<li><p>自定义Security策略</p>
<ul>
<li><p>模板</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebSecurity</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
		<span class="hljs-keyword">super</span>.configure(http);
	&#125;
&#125;</code></pre></div>
</li>
<li><p>完整</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebSecurity</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;

	<span class="hljs-comment">// 授权</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
		<span class="hljs-comment">// 首页所有人可以访问, 功能页只有对应权限的人才能访问</span>
		<span class="hljs-comment">// 请求授权的规则</span>
		http.authorizeRequests()
				.antMatchers(<span class="hljs-string">&quot;/&quot;</span>).permitAll()
				.antMatchers(<span class="hljs-string">&quot;/level1/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip1&quot;</span>)
				.antMatchers(<span class="hljs-string">&quot;/level2/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip2&quot;</span>)
				.antMatchers(<span class="hljs-string">&quot;/level3/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip3&quot;</span>);

		<span class="hljs-comment">// 没有权限默认会跳到登录页面, 需要开启登录的页面</span>
		http.formLogin();
	&#125;

	<span class="hljs-comment">// 认证 springboot 2.1.x 可以直接使用</span>
	<span class="hljs-comment">// 过高版本, 密码需要编码: PasswordEncoder</span>
	<span class="hljs-comment">// 在 Spring Security 5.0+ 新增了很多的加密方法 MD5</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

		<span class="hljs-comment">// 这些数据正常应该从数据中读取</span>
		auth.inMemoryAuthentication().passwordEncoder(<span class="hljs-keyword">new</span> BCryptPasswordEncoder())
				.withUser(<span class="hljs-string">&quot;pnca&quot;</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>)).roles(<span class="hljs-string">&quot;vip2&quot;</span>, <span class="hljs-string">&quot;vip3&quot;</span>)
				.and().withUser(<span class="hljs-string">&quot;root&quot;</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>)).roles(<span class="hljs-string">&quot;vip1&quot;</span>, <span class="hljs-string">&quot;vip2&quot;</span>, <span class="hljs-string">&quot;vip3&quot;</span>)
				.and().withUser(<span class="hljs-string">&quot;guest&quot;</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>)).roles(<span class="hljs-string">&quot;vip1&quot;</span>);
	&#125;
&#125;</code></pre></div>

<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210521010431174.png" alt="image-20210521010431174"></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210521010441726.png" alt="image-20210521010441726"></p>
</li>
</ul>
</li>
<li><p>自定义认证策略</p>
</li>
</ul>
<h3 id="7-4-注销及权限控制"><a href="#7-4-注销及权限控制" class="headerlink" title="7.4 注销及权限控制"></a>7.4 注销及权限控制</h3><ol>
<li><p>开启自动配置的注销的功能</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//定制请求的授权规则</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
   <span class="hljs-comment">//....</span>
   <span class="hljs-comment">//开启自动配置的注销的功能</span>
      <span class="hljs-comment">// /logout 注销请求</span>
   http.logout();
&#125;</code></pre></div>
</li>
<li><p>我们在前端，增加一个注销的按钮，index.html 导航栏中</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/logout&#125;&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;address card icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 注销
<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div>
</li>
<li><p>我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！</p>
</li>
<li><p>但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页</span>
http.logout().logoutSuccessUrl(<span class="hljs-string">&quot;/&quot;</span>);</code></pre></div>
</li>
<li><p>测试，注销完毕后，发现跳转到首页OK</p>
</li>
<li><p>我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？</p>
<ul>
<li><p>我们需要结合thymeleaf中的一些功能</p>
</li>
<li><p>sec：authorize=”isAuthenticated()”:是否认证登录！来显示不同的页面</p>
</li>
<li><p>Maven依赖：</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
</ul>
</li>
<li><p>修改我们的 前端页面</p>
<ul>
<li><p>导入命名空间</p>
<div class="code-wrapper"><pre><code class="hljs xml">xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;</code></pre></div>
</li>
<li><p>修改导航栏，增加认证判断</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--登录注销--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right menu&quot;</span>&gt;</span>

   <span class="hljs-comment">&lt;!--如果未登录--&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">&quot;!isAuthenticated()&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/login&#125;&quot;</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;address card icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 登录
       <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

   <span class="hljs-comment">&lt;!--如果已登录--&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">&quot;isAuthenticated()&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;address card icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
          用户名：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">sec:authentication</span>=<span class="hljs-string">&quot;principal.username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          角色：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">sec:authentication</span>=<span class="hljs-string">&quot;principal.authorities&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">&quot;isAuthenticated()&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/logout&#125;&quot;</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;address card icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 注销
       <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>
</li>
</ul>
</li>
<li><p>重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面；</p>
</li>
<li><p>如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 <code>http.csrf().disable();</code></p>
<div class="code-wrapper"><pre><code class="hljs java">http.csrf().disable();<span class="hljs-comment">//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求</span>
http.logout().logoutSuccessUrl(<span class="hljs-string">&quot;/&quot;</span>);</code></pre></div>
</li>
<li><p>我们继续将下面的角色功能块认证完成！</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot; --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column&quot;</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">&quot;hasRole(&#x27;vip1&#x27;)&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui raised segment&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui&quot;</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Level 1<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level1/1&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-1-1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level1/2&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-1-2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level1/3&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-1-3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column&quot;</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">&quot;hasRole(&#x27;vip2&#x27;)&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui raised segment&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui&quot;</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Level 2<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level2/1&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-2-1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level2/2&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-2-2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level2/3&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-2-3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column&quot;</span> <span class="hljs-attr">sec:authorize</span>=<span class="hljs-string">&quot;hasRole(&#x27;vip3&#x27;)&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui raised segment&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui&quot;</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Level 3<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level3/1&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-3-1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level3/2&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-3-2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/level3/3&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bullhorn icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> Level-3-3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>
</li>
<li><p>测试一下！</p>
</li>
<li><p>权限控制和注销搞定！</p>
</li>
</ol>
<h3 id="7-5-记住我"><a href="#7-5-记住我" class="headerlink" title="7.5 记住我"></a>7.5 记住我</h3><p>现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单</p>
<ol>
<li><p>开启记住我功能</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//定制请求的授权规则</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
<span class="hljs-comment">//。。。。。。。。。。。</span>
   <span class="hljs-comment">//记住我</span>
   http.rememberMe();
&#125;</code></pre></div>
</li>
<li><p>我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！</p>
<p>思考：如何实现的呢？其实非常简单</p>
<p>我们可以查看浏览器的cookie</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/63340.png" alt="查看浏览器的cookie"></p>
</li>
<li><p>我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/640" alt></p>
</li>
<li><p>结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！</p>
</li>
</ol>
<h3 id="7-6-首页定制"><a href="#7-6-首页定制" class="headerlink" title="7.6 首页定制"></a>7.6 首页定制</h3><p>现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？</p>
<ol>
<li><p>在刚才的登录页配置后面指定 loginpage</p>
<div class="code-wrapper"><pre><code class="hljs java">http.formLogin().loginPage(<span class="hljs-string">&quot;/toLogin&quot;</span>);</code></pre></div>
</li>
<li><p>然后前端也需要指向我们自己定义的 login请求</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/toLogin&#125;&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;address card icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> 登录
<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div>
</li>
<li><p>我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post:</p>
<p>在 loginPage()源码中的注释上有写明：</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210523205655543.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/login&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;field&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui left icon input&quot;</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;user icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;field&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Password<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui left icon input&quot;</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lock icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ui blue submit button&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div>
</li>
<li><p>这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！</p>
<div class="code-wrapper"><pre><code class="hljs java">http.formLogin()
  .usernameParameter(<span class="hljs-string">&quot;username&quot;</span>)
  .passwordParameter(<span class="hljs-string">&quot;password&quot;</span>)
  .loginPage(<span class="hljs-string">&quot;/toLogin&quot;</span>)
  .loginProcessingUrl(<span class="hljs-string">&quot;/login&quot;</span>); <span class="hljs-comment">// 登陆表单提交请求</span></code></pre></div>
</li>
<li><p>在登录页增加记住我的多选框</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;remember&quot;</span>&gt;</span> 记住我</code></pre></div>
</li>
<li><p>后端验证处理！</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//定制记住我的参数！</span>
http.rememberMe().rememberMeParameter(<span class="hljs-string">&quot;remember&quot;</span>);</code></pre></div>

</li>
</ol>
<h2 id="8-Shiro"><a href="#8-Shiro" class="headerlink" title="8 Shiro"></a>8 Shiro</h2><h3 id="8-1-什么是-Shiro"><a href="#8-1-什么是-Shiro" class="headerlink" title="8.1 什么是 Shiro?"></a>8.1 什么是 Shiro?</h3><p>● <code>Apache Shiro</code> 是一个 Java 的安全(权限)框架。<br>● <code>Shiro</code> 可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。<br>● <code>Shiro</code> 可以完成，认证，授权，加密，会话管理，Web集成，缓存等。<br>● 下载地址: <code>http://shiro.apache.org/</code></p>
<h4 id="8-1-1-有哪些功能"><a href="#8-1-1-有哪些功能" class="headerlink" title="8.1.1 有哪些功能"></a>8.1.1 有哪些功能</h4><p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210316211939796.png" alt></p>
<p>● <code>Authentication</code>: 身份认证、登录，验证用户是不是拥有相应的身份；<br>● <code>Authorization</code>: 授权，即权限验证，验证某个已认证的用户是否拥有某个权限，即判断用户能否进行什么操作，如：验证某个用户是否拥有某个角色，或者细粒度的验证某个用户对某个资源是否具有某个权限!<br>● <code>Session Manager</code>: 会话管理，即用户登录后就是第一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通的JavaSE环境，也可以是Web环境；<br>● <code>Cryptography</code>: 加密，保护数据的安全性，如密码加密存储到数据库中，而不是明文存储；<br>● <code>Web Support</code> : Web支持，可以非常容易的集成到Web环境；<br>● <code>Caching</code> : 缓存，比如用户登录后，其用户信息，拥有的角色、权限不必每次去查，这样可以提高效率。<br>● <code>Concurrency</code>: Shiro支持多线程应用的并发验证，即：如在一个线程中开启另一个线程，能把权限自动的传播过去。<br>● <code>Testing</code>: 提供测试支持；<br>● <code>RunAs</code>: 允许一个用户假装为另一个用户(如果他们允许)的身份进行访问；<br>● <code>Remember Me</code>: 记住我，这个是非常常见的功能，即一次登录后， 下次再来的话不用登录了。</p>
<h4 id="8-1-2-Shiro架构-外部"><a href="#8-1-2-Shiro架构-外部" class="headerlink" title="8.1.2 Shiro架构(外部)"></a>8.1.2 Shiro架构(外部)</h4><p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210316212212655.png" alt></p>
<p>● <code>subject</code>: 应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject，Subject代表了当前的用户，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等，与Subject的所有交互都会委托给SecurityManager；Subject其实是一个门面，SecurityManageer 才是实际的执行者。<br>● <code>SecurityManager</code>: 安全管理器，即所有与安全有关的操作都会与SercurityManager交互，并且它管理着所有的Subject，可以看出它是Shiro的核心，它负责与Shiro的其他组件进行交互，它相当于SpringMVC的DispatcherServlet的角色。<br>● <code>Realm</code>: Shiro从Realm获取安全数据 (如用户,角色，权限)，就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较，来确定用户的身份是否合法;也需要从Realm得到用户相应的角色、权限，进行验证用户的操作是否能够进行，可以把Realm看DataSource。</p>
<h4 id="8-1-3-Shiro架构-内部"><a href="#8-1-3-Shiro架构-内部" class="headerlink" title="8.1.3 Shiro架构(内部)"></a>8.1.3 Shiro架构(内部)</h4><p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210316212357831.png" alt></p>
<p>● <code>Subject</code>: 任何可以与应用交互的用户;<br>● <code>Security Manager</code>: 相当于SpringMVC中的DispatcherSerlet；是Shiro的心脏， 所有具体的交互都通过Security Manager进行控制，它管理者所有的Subject, 且负责进行认证,授权，会话，及缓存的管理。<br>● <code>Authenticator</code>: 负责Subject认证， 是-一个扩展点，可以自定义实现;可以使用认证策略(Authentication Strategy)，即什么情况下算用户认证通过了;<br>● <code>Authorizer</code>: 授权器，即访问控制器，用来决定主体是否有权限进行相应的操作，即控制着用户能访问应用中的那些功能；<br>● <code>Realm</code>: 可以有一个或者多个的realm，可以认为是安全实体数据源，即用于获取安全实体的，可以用JDBC实现，也可以是内存实现等等，由用户提供；所以一般在应用中都需要实现自己的realm。<br>● <code>SessionManager</code>: 管理Session生命周期的组件，而Shiro并不仅仅可以用在Web环境，也可以用在普通的JavaSE环境中。<br>● <code>CacheManager</code>: 缓存控制器，来管理如用户，角色，权限等缓存的;因为这些数据基本上很少改变，放到缓存中后可以提高访问的性能。<br>● <code>Cryptography</code>: 密码模块，Shiro 提高了一些常见的加密组件用于密码加密， 解密等。</p>
<h3 id="8-2-Shiro快速开始"><a href="#8-2-Shiro快速开始" class="headerlink" title="8.2 Shiro快速开始"></a>8.2 Shiro快速开始</h3><p>创建一个普通<code>maven</code>项目<code>springboot-06-shiro</code>,然后删除src目录,这样的话就可以在这个项目里新建很多model.</p>
<p>在springboot-06-shiro里新建model <code>shiro-01-helloshiro</code><br>父依赖<code>pom.xml</code></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- configure logging --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

<p><code>log4j.properties</code></p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">INFO, stdout</span>

<span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span>
<span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span>
<span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">%d %p [%c] - %m %n</span>

<span class="hljs-comment"># General Apache libraries</span>
<span class="hljs-meta">log4j.logger.org.apache</span>=<span class="hljs-string">WARN</span>

<span class="hljs-comment"># Spring</span>
<span class="hljs-meta">log4j.logger.org.springframework</span>=<span class="hljs-string">WARN</span>

<span class="hljs-comment"># Default Shiro logging</span>
<span class="hljs-meta">log4j.logger.org.apache.shiro</span>=<span class="hljs-string">INFO</span>

<span class="hljs-comment"># Disable verbose logging</span>
<span class="hljs-meta">log4j.logger.org.apache.shiro.util.ThreadContext</span>=<span class="hljs-string">WARN</span>
<span class="hljs-meta">log4j.logger.org.apache.shiro.cache.ehcache.EhCache</span>=<span class="hljs-string">WARN</span>
</code></pre></div>

<p><code>shiro.ini</code></p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[users]</span>
<span class="hljs-comment"># user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; role</span>
<span class="hljs-attr">root</span> = secret, admin
<span class="hljs-comment"># user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; role</span>
<span class="hljs-attr">guest</span> = guest, guest
<span class="hljs-comment"># user &#x27;presidentskroob&#x27; with password &#x27;12345&#x27; (&quot;That&#x27;s the same combination on</span>
<span class="hljs-comment"># my luggage!!!&quot; ;)), and role &#x27;president&#x27;</span>
<span class="hljs-attr">presidentskroob</span> = <span class="hljs-number">12345</span>, president
<span class="hljs-comment"># user &#x27;darkhelmet&#x27; with password &#x27;ludicrousspeed&#x27; and roles &#x27;darklord&#x27; and &#x27;schwartz&#x27;</span>
<span class="hljs-attr">darkhelmet</span> = ludicrousspeed, darklord, schwartz
<span class="hljs-comment"># user &#x27;lonestarr&#x27; with password &#x27;vespa&#x27; and roles &#x27;goodguy&#x27; and &#x27;schwartz&#x27;</span>
<span class="hljs-attr">lonestarr</span> = vespa, goodguy, schwartz

<span class="hljs-comment"># -----------------------------------------------------------------------------</span>
<span class="hljs-comment"># Roles with assigned permissions</span>
<span class="hljs-comment"># </span>
<span class="hljs-comment"># Each line conforms to the format defined in the</span>
<span class="hljs-comment"># org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc</span>
<span class="hljs-comment"># -----------------------------------------------------------------------------</span>
<span class="hljs-section">[roles]</span>
<span class="hljs-comment"># &#x27;admin&#x27; role has all permissions, indicated by the wildcard &#x27;*&#x27;</span>
<span class="hljs-attr">admin</span> = *
<span class="hljs-comment"># The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:</span>
<span class="hljs-attr">schwartz</span> = lightsaber:*
<span class="hljs-comment"># The &#x27;goodguy&#x27; role is allowed to &#x27;drive&#x27; (action) the winnebago (type) with</span>
<span class="hljs-comment"># license plate &#x27;eagle5&#x27; (instance specific id)</span>
<span class="hljs-attr">goodguy</span> = winnebago:drive:eagle5</code></pre></div>

<p><code>Quickstart.java</code></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;
<span class="hljs-keyword">import</span> org.apache.shiro.authc.*;
<span class="hljs-keyword">import</span> org.apache.shiro.mgt.DefaultSecurityManager;
<span class="hljs-keyword">import</span> org.apache.shiro.realm.text.IniRealm;
<span class="hljs-keyword">import</span> org.apache.shiro.session.Session;
<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;


<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Simple Quickstart application showing how to use Shiro&#x27;s API.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 0.9 RC2</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quickstart</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> Logger log = LoggerFactory.getLogger(Quickstart.class);


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;


        DefaultSecurityManager defaultSecurityManager=<span class="hljs-keyword">new</span> DefaultSecurityManager();
        IniRealm iniRealm=<span class="hljs-keyword">new</span> IniRealm(<span class="hljs-string">&quot;classpath:shiro.ini&quot;</span>);
        defaultSecurityManager.setRealm(iniRealm);
        SecurityUtils.setSecurityManager(defaultSecurityManager);


        <span class="hljs-comment">// 获得当前用户对象 Subject</span>
        Subject currentUser = SecurityUtils.getSubject();

        <span class="hljs-comment">// 通过当前用户拿到session</span>
        Session session = currentUser.getSession();
        session.setAttribute(<span class="hljs-string">&quot;someKey&quot;</span>, <span class="hljs-string">&quot;aValue&quot;</span>);
        String value = (String) session.getAttribute(<span class="hljs-string">&quot;someKey&quot;</span>);
        <span class="hljs-keyword">if</span> (value.equals(<span class="hljs-string">&quot;aValue&quot;</span>)) &#123;
            log.info(<span class="hljs-string">&quot;Retrieved the correct value! [&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>);
        &#125;

        <span class="hljs-comment">// 判断当前用户是否被认证</span>
        <span class="hljs-keyword">if</span> (!currentUser.isAuthenticated()) &#123;
            <span class="hljs-comment">//Token:令牌</span>
            UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">&quot;lonestarr&quot;</span>, <span class="hljs-string">&quot;vespa&quot;</span>);
            token.setRememberMe(<span class="hljs-keyword">true</span>);
            <span class="hljs-keyword">try</span> &#123;
                currentUser.login(token); <span class="hljs-comment">//执行登录操作</span>
            &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException uae) &#123;
                log.info(<span class="hljs-string">&quot;There is no user with username of &quot;</span> + token.getPrincipal());
            &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException ice) &#123;
                log.info(<span class="hljs-string">&quot;Password for account &quot;</span> + token.getPrincipal() + <span class="hljs-string">&quot; was incorrect!&quot;</span>);
            &#125; <span class="hljs-keyword">catch</span> (LockedAccountException lae) &#123;
                log.info(<span class="hljs-string">&quot;The account for username &quot;</span> + token.getPrincipal() + <span class="hljs-string">&quot; is locked.  &quot;</span> +
                        <span class="hljs-string">&quot;Please contact your administrator to unlock it.&quot;</span>);
            &#125;
            <span class="hljs-comment">// ... catch more exceptions here (maybe custom ones specific to your application?</span>
            <span class="hljs-keyword">catch</span> (AuthenticationException ae) &#123;
                <span class="hljs-comment">//unexpected condition?  error?</span>
            &#125;
        &#125;

        <span class="hljs-comment">//say who they are:</span>
        <span class="hljs-comment">//print their identifying principal (in this case, a username):</span>
        log.info(<span class="hljs-string">&quot;User [&quot;</span> + currentUser.getPrincipal() + <span class="hljs-string">&quot;] logged in successfully.&quot;</span>);

        <span class="hljs-comment">//test a role:</span>
        <span class="hljs-keyword">if</span> (currentUser.hasRole(<span class="hljs-string">&quot;schwartz&quot;</span>)) &#123;
            log.info(<span class="hljs-string">&quot;May the Schwartz be with you!&quot;</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            log.info(<span class="hljs-string">&quot;Hello, mere mortal.&quot;</span>);
        &#125;

        <span class="hljs-comment">//粗粒度</span>
        <span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">&quot;lightsaber:wield&quot;</span>)) &#123;
            log.info(<span class="hljs-string">&quot;You may use a lightsaber ring.  Use it wisely.&quot;</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            log.info(<span class="hljs-string">&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;</span>);
        &#125;

        <span class="hljs-comment">//细粒度</span>
        <span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">&quot;winnebago:drive:eagle5&quot;</span>)) &#123;
            log.info(<span class="hljs-string">&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot;</span> +
                    <span class="hljs-string">&quot;Here are the keys - have fun!&quot;</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            log.info(<span class="hljs-string">&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;</span>);
        &#125;

        <span class="hljs-comment">//注销</span>
        currentUser.logout();

        <span class="hljs-comment">//结束</span>
        System.exit(<span class="hljs-number">0</span>);
    &#125;
&#125;</code></pre></div>

<p><code>执行</code></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210526182438396.png" alt></p>
<h3 id="8-3-springboot整合shiro"><a href="#8-3-springboot整合shiro" class="headerlink" title="8.3 springboot整合shiro"></a>8.3 springboot整合shiro</h3><h4 id="8-3-1-项目结构图"><a href="#8-3-1-项目结构图" class="headerlink" title="8.3.1 项目结构图"></a>8.3.1 项目结构图</h4><p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210317223239457.png" alt></p>
<h4 id="8-3-2-数据库"><a href="#8-3-2-数据库" class="headerlink" title="8.3.2 数据库"></a>8.3.2 数据库</h4><p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210317223311431.png" alt></p>
<h4 id="8-3-3-程序代码"><a href="#8-3-3-程序代码" class="headerlink" title="8.3.3 程序代码"></a>8.3.3 程序代码</h4><p>新建一个springboot项目，勾选web，thymeleaf模块</p>
<ul>
<li><p><strong>pom.xml</strong></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    	<span class="hljs-comment">&lt;!--shiro-thymeleaf--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.theborakompanioni<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-extras-shiro<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    
		<span class="hljs-comment">&lt;!--shiro--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--web--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
					<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
					<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--log4j2--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--test--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--lombok--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--jdbc--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--mybatis--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--mysql--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--Thymeleaf--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--druid--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>
</li>
<li><p><strong>application.yml</strong></p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">banner:</span>
    <span class="hljs-attr">location:</span> <span class="hljs-string">banner.txt</span>
  <span class="hljs-attr">thymeleaf:</span>
    <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span>
  <span class="hljs-comment"># 配置国际化</span>
  <span class="hljs-attr">messages:</span>
    <span class="hljs-attr">basename:</span> <span class="hljs-string">i18n.login</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springbootweb?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=GMT</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>

    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j2</span>
    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span>
    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span>

<span class="hljs-attr">logging:</span>
  <span class="hljs-comment">#  控制台打印格式</span>
  <span class="hljs-attr">pattern:</span>
    <span class="hljs-attr">console:</span> <span class="hljs-string">&quot;%style&#123;%d&#123;yyyy-MM-dd HH:mm:ss&#125;&#125;&#123;red&#125; %style&#123;[%thread]&#125;&#123;blue&#125; %style&#123;%-5level&#125;&#123;cyan&#125;:%highlight&#123;%m%n&#125;&quot;</span>
    
<span class="hljs-attr">mybatis:</span>
  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.pnca.pojo</span>
  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/*.xml</span></code></pre></div>
</li>
<li><p><strong>UserRealm.java</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.config;

<span class="hljs-keyword">import</span> com.pnca.pojo.User;
<span class="hljs-keyword">import</span> com.pnca.service.UserService;
<span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;
<span class="hljs-keyword">import</span> org.apache.shiro.authc.*;
<span class="hljs-keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;
<span class="hljs-keyword">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;
<span class="hljs-keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;
<span class="hljs-keyword">import</span> org.apache.shiro.session.Session;
<span class="hljs-keyword">import</span> org.apache.shiro.subject.PrincipalCollection;
<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    UserService userService;

    <span class="hljs-comment">//授权</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principalCollection)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;执行了授权&quot;</span>);

        SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo ();

        <span class="hljs-comment">//拿到当前登录的对象</span>
        Subject subject = SecurityUtils.getSubject();
        <span class="hljs-comment">//拿到user对象</span>
        User currentUser = (User) subject.getPrincipal();
        <span class="hljs-comment">//添加权限（数据库中拿的）</span>
        info.addStringPermission(currentUser.getPerms());
        <span class="hljs-keyword">return</span> info;
    &#125;

    <span class="hljs-comment">//认证</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;
        System.out.println(<span class="hljs-string">&quot;执行了认证&quot;</span>);

        UsernamePasswordToken userToken=(UsernamePasswordToken)token;

<span class="hljs-comment">//        //用户名、密码  模拟从数据库中获取</span>
<span class="hljs-comment">//        String name = &quot;root&quot;;</span>
<span class="hljs-comment">//        String password = &quot;1111&quot;;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//        //用户名认证</span>
<span class="hljs-comment">//        if (!userToken.getUsername().equals(name))&#123;</span>
<span class="hljs-comment">//            return null;//抛出异常 UnknownAccountException</span>
<span class="hljs-comment">//        &#125;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//        //密码认证，shiro做</span>
<span class="hljs-comment">//        return new SimpleAuthenticationInfo(&quot;&quot;,password,&quot;&quot;);</span>

        <span class="hljs-comment">//连接真实数据库</span>
        User user = userService.queryUserByName(userToken.getUsername());
        <span class="hljs-keyword">if</span> (user==<span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//没有这个人</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//抛出异常 UnknownAccountException</span>
        &#125;

        Subject subject = SecurityUtils.getSubject();
        Session session = subject.getSession();
        session.setAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>,user);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(user,user.getPwd(),<span class="hljs-string">&quot;&quot;</span>);
    &#125;
&#125;</code></pre></div>
</li>
<li><p><strong>ShiroConfig.java</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.config;

<span class="hljs-keyword">import</span> at.pollux.thymeleaf.shiro.dialect.ShiroDialect;
<span class="hljs-keyword">import</span> org.apache.shiro.realm.Realm;
<span class="hljs-keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;
<span class="hljs-keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;

<span class="hljs-keyword">import</span> java.util.LinkedHashMap;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span></span>&#123;

    <span class="hljs-comment">//ShiroFilterFactoryBean 第三步</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean  <span class="hljs-title">getShiroFilterBean</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;securityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span></span>&#123;
        ShiroFilterFactoryBean bean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();
        <span class="hljs-comment">//设置安全管理器</span>
        bean.setSecurityManager(defaultWebSecurityManager);

        Map&lt;String, String&gt; filterMap =<span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();
        
        <span class="hljs-comment">// 添加Shiro内置过滤器</span>
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * Shiro内置过滤器，可以实现权限相关的拦截器</span>
<span class="hljs-comment">         *  常用的过滤器：</span>
<span class="hljs-comment">         *      anon：无需认证（登陆）可以访问</span>
<span class="hljs-comment">         *      authc：必须认证才可以访问</span>
<span class="hljs-comment">         *      user：如果使用rememberMe的功能，可以直接访问</span>
<span class="hljs-comment">         *      perms：该资源必须得到资源权限才可以访问</span>
<span class="hljs-comment">         *      role：该资源必须得到角色权限才可以访问</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-comment">//拦截，必须有什么权限才能访问</span>
        filterMap.put(<span class="hljs-string">&quot;/user/add&quot;</span>,<span class="hljs-string">&quot;perms[user:add]&quot;</span>);
        filterMap.put(<span class="hljs-string">&quot;/user/update&quot;</span>,<span class="hljs-string">&quot;perms[user:update]&quot;</span>);
        
        <span class="hljs-comment">//拦截，必须认证才能访问</span>
        <span class="hljs-comment">//filterMap.put(&quot;/user/*&quot;,&quot;authc&quot;);</span>

        bean.setFilterChainDefinitionMap(filterMap);

        <span class="hljs-comment">//访问时用户未认证，跳转到登录界面</span>
        bean.setLoginUrl(<span class="hljs-string">&quot;/toLogin&quot;</span>);
        <span class="hljs-comment">//若访问时用户未被授权，则跳转至未授权页面</span>
        bean.setUnauthorizedUrl(<span class="hljs-string">&quot;/noauth&quot;</span>);

        <span class="hljs-keyword">return</span> bean;
    &#125;

    <span class="hljs-comment">//DefaultWebSecurityManager 第二步</span>
    <span class="hljs-meta">@Bean(name = &quot;securityManager&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">getDefaultWebSecurityManager</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;userRealm&quot;)</span> Realm realm)</span></span>&#123;
        DefaultWebSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager();
        <span class="hljs-comment">//关联userRealm</span>
        securityManager.setRealm(realm);
        <span class="hljs-keyword">return</span> securityManager;
    &#125;

    <span class="hljs-comment">//realm 第一步</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Realm <span class="hljs-title">userRealm</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserRealm();
    &#125;

    <span class="hljs-comment">//整合ShiroDialect:用来整合shiro thymeleaf</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroDialect <span class="hljs-title">getShiroDialect</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ShiroDialect();
    &#125;
&#125;</code></pre></div>
</li>
<li><p><strong>MyController.java</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.controller;

<span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;
<span class="hljs-keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;
<span class="hljs-keyword">import</span> org.apache.shiro.authc.UnknownAccountException;
<span class="hljs-keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;
<span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;
<span class="hljs-keyword">import</span> org.springframework.ui.Model;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;

<span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;

    <span class="hljs-meta">@RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toIndex</span><span class="hljs-params">(Model model)</span></span>&#123;
        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello,shiro&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;
    &#125;

    <span class="hljs-meta">@RequestMapping(&quot;/user/add&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user/add&quot;</span>;
    &#125;

    <span class="hljs-meta">@RequestMapping(&quot;/user/update&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user/update&quot;</span>;
    &#125;

    <span class="hljs-meta">@RequestMapping(&quot;/toLogin&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLogin</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;
    &#125;

    <span class="hljs-meta">@RequestMapping(&quot;/noauth&quot;)</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">unauthorized</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;未授权无法访问此页面&quot;</span>;
    &#125;

    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username,String password,Model model)</span> </span>&#123;
        <span class="hljs-comment">//获取当前用户</span>
        Subject subject = SecurityUtils.getSubject();
        <span class="hljs-comment">//封装用户的登录数据</span>
        UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(username, password);

        <span class="hljs-keyword">try</span> &#123;
            subject.login(token);<span class="hljs-comment">//执行登录的方法，如果没有异常就说明ok了</span>
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<span class="hljs-comment">//登录成功跳到首页</span>
        &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException e) &#123; <span class="hljs-comment">//用户名不存在</span>
            model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;用户名不存在！&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;
        &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException e) &#123;
            model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;密码错误！&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;
        &#125;

    &#125;

    <span class="hljs-meta">@RequestMapping(&quot;/logout&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">logout</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-comment">//获取当前用户</span>
        Subject subject = SecurityUtils.getSubject();
        subject.logout(); <span class="hljs-comment">// session 会销毁，在SessionListener监听session销毁，清理权限缓存</span>
        System.out.println(<span class="hljs-string">&quot;执行了退出&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:index&quot;</span>;
    &#125;

&#125;</code></pre></div>
</li>
<li><p><strong>User.java</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.pojo;

<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;
<span class="hljs-keyword">import</span> lombok.Data;
<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;

<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String pwd;
    <span class="hljs-keyword">private</span> String perms;
&#125;</code></pre></div>
</li>
<li><p><strong>UserMapper.java</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.mapper;

<span class="hljs-keyword">import</span> com.kuang.pojo.User;
<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;

<span class="hljs-meta">@Repository</span>
<span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserByName</span><span class="hljs-params">(String name)</span></span>;

&#125;</code></pre></div>
</li>
<li><p><strong>UserServiceImpl.java</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.service;

<span class="hljs-keyword">import</span> com.kuang.mapper.UserMapper;
<span class="hljs-keyword">import</span> com.kuang.pojo.User;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span>&#123;

    <span class="hljs-meta">@Autowired</span>
    UserMapper userMapper;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserByName</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">return</span> userMapper.queryUserByName(name);
    &#125;
&#125;</code></pre></div>
</li>
<li><p><strong>index.html</strong></p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span></span>
<span class="hljs-tag">      <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;https://www.thymeleaf.org&quot;</span></span>
<span class="hljs-tag">      <span class="hljs-attr">xmlns:shiro</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;session.loginUser==null&#125;&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/toLogin&#125;&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;session.loginUser!=null&#125;&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/logout&#125;&quot;</span>&gt;</span>注销<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">shiro:hasPermission</span>=<span class="hljs-string">&quot;user:add&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/user/add&#125;&quot;</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">shiro:hasPermission</span>=<span class="hljs-string">&quot;user:update&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/user/update&#125;&quot;</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>
</li>
<li><p><strong>login.html</strong></p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml?&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;msg&#125;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/login&#125;&quot;</span>&gt;</span>
    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>
</li>
<li><p><strong>add.html</strong></p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>
</li>
<li><p><strong>update.html</strong></p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>修改<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

</li>
</ul>
<h3 id="8-4-总结"><a href="#8-4-总结" class="headerlink" title="8.4 总结"></a>8.4 总结</h3><h4 id="8-4-1-Shiro-三大要素"><a href="#8-4-1-Shiro-三大要素" class="headerlink" title="8.4.1 Shiro 三大要素"></a>8.4.1 Shiro 三大要素</h4><ul>
<li><p><code>subject</code> -&gt; <code>ShiroFilterFactoryBean</code></p>
</li>
<li><p><code>securityManager</code> -&gt; <code>DefaultWebSecurityManager</code></p>
</li>
<li><p><code>realm</code> </p>
</li>
<li><p>实际操作中对象创建的顺序 ： <code>realm -&gt; securityManager -&gt; subject</code></p>
</li>
</ul>
<h4 id="8-4-2-流程梳理"><a href="#8-4-2-流程梳理" class="headerlink" title="8.4.2 流程梳理"></a>8.4.2 流程梳理</h4><ol>
<li><p>用户进入首页点击跳转，Shiro内置过滤器进行拦截，看过滤器的设置，未认证跳转到登录页面，未授权跳转到未授权界面；</p>
</li>
<li><p>认证</p>
<ul>
<li><p>用户进入登录页面，输入用户名密码准备进行认证，点击登录按钮后，会请求/login，</p>
</li>
<li><p>首先调用Subject.login(token) 进行登录，其会自动委托给SecurityManager，</p>
</li>
<li><p>SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator 进行身份验证；</p>
</li>
<li><p>Authenticator 才是真正的身份验证者，Authenticator 会把相应的token 传入Realm，从Realm 获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了，如果有就返回AuthenticationInfo验证信息，此信息中包含了身份（pricipals）及凭证，也就是账号密码。</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210318092122708.png" alt></p>
</li>
</ul>
</li>
<li><p>授权</p>
<ul>
<li>对subject进行授权，调用方法isPermitted（“permission串”），递交给SecurityManager</li>
<li>SecurityManager将权限检测操作委托给Authorizer授权管理器对象</li>
<li>Authorizer执行Realm（自定义的Realm）从数据库查询权限数据并封装</li>
<li>Authorizer对用户授权信息进行判定(判断用户访问资源时需要什么权限，假如用户所具有的权限包含这个资源访问时所需要的权限，那么用户就可以访问这个资源了)。</li>
</ul>
</li>
</ol>
<h2 id="9-swagger"><a href="#9-swagger" class="headerlink" title="9 swagger"></a>9 swagger</h2><h3 id="9-1-概念"><a href="#9-1-概念" class="headerlink" title="9.1 概念"></a>9.1 概念</h3><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。</p>
<h3 id="9-2-特点"><a href="#9-2-特点" class="headerlink" title="9.2  特点"></a>9.2  特点</h3><ul>
<li>号称世界上最流行的API框架</li>
<li>Restful Api 文档在线自动生成器 =&gt; API 文档 与API 定义同步更新</li>
<li>直接运行，在线测试API</li>
<li>支持多种语言 （如：Java，PHP等）</li>
<li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li>
</ul>
<h3 id="9-3-springboot-集成-swagger"><a href="#9-3-springboot-集成-swagger" class="headerlink" title="9.3 springboot 集成 swagger"></a>9.3 springboot 集成 swagger</h3><ul>
<li>1 引入依赖</li>
</ul>
<p>以maven为例：</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
		<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>

<ul>
<li>2 自定义配置信息</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//配置类</span>
<span class="hljs-meta">@EnableSwagger2</span><span class="hljs-comment">// 开启Swagger2的自动配置</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;  
&#125;</code></pre></div>

<ul>
<li>3 测试</li>
</ul>
<p>​    <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p>
<p>​    <img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210531203708046.png" alt="image-20210531203708046"></p>
<h4 id="1-配置swagger"><a href="#1-配置swagger" class="headerlink" title="1 配置swagger"></a>1 配置swagger</h4><ul>
<li><p>Swagger实例Bean是<code>Docket</code>，所以通过配置Docket实例来配置Swaggger。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span> <span class="hljs-comment">//配置docket以配置Swagger具体参数</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2);
&#125;</code></pre></div>
</li>
<li><p>可以通过<code>apiInfo()</code>属性配置文档信息</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//配置文档信息</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;
   Contact contact = <span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;联系人名字&quot;</span>, <span class="hljs-string">&quot;http://xxx.xxx.com/联系人访问链接&quot;</span>, <span class="hljs-string">&quot;联系人邮箱&quot;</span>);
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfo(
           <span class="hljs-string">&quot;Swagger学习&quot;</span>, <span class="hljs-comment">// 标题</span>
           <span class="hljs-string">&quot;学习演示如何配置Swagger&quot;</span>, <span class="hljs-comment">// 描述</span>
           <span class="hljs-string">&quot;v1.0&quot;</span>, <span class="hljs-comment">// 版本</span>
           <span class="hljs-string">&quot;http://terms.service.url/组织链接&quot;</span>, <span class="hljs-comment">// 组织链接</span>
           contact, <span class="hljs-comment">// 联系人信息</span>
           <span class="hljs-string">&quot;Apach 2.0 许可&quot;</span>, <span class="hljs-comment">// 许可</span>
           <span class="hljs-string">&quot;许可链接&quot;</span>, <span class="hljs-comment">// 许可连接</span>
           <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()<span class="hljs-comment">// 扩展</span>
  );
&#125;</code></pre></div>
</li>
<li><p>Docket 实例关联上 apiInfo()</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());
&#125;</code></pre></div>
</li>
<li><p>重启项目，访问测试 <code>http://localhost:8080/swagger-ui.html</code> 看下效果</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210531204628474.png" alt></p>
</li>
</ul>
<h4 id="2-配置扫描接口"><a href="#2-配置扫描接口" class="headerlink" title="2 配置扫描接口"></a>2 配置扫描接口</h4><ul>
<li><p>构建Docket时通过<code>select()</code>方法配置怎么扫描接口。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .select()<span class="hljs-comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span>
      .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.kuang.controller&quot;</span>))
      .build();
&#125;</code></pre></div>
</li>
<li><p>重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/image-20210531205542660.png" alt="image-20210531205542660"></p>
</li>
<li><p>除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//RequestHandlerSelectors 配置要扫描接口的方式</span>
<span class="hljs-comment">//basePackage 指定要扫描的包</span>
<span class="hljs-comment">//any() 扫描全部</span>
<span class="hljs-comment">//none() 不扫描</span>
<span class="hljs-comment">//withMethodAnnotation 扫描方法上的注解，参数是注解的反射对象（GetMapping.class）</span>
<span class="hljs-comment">//withClassAnnotation 扫描类上的注解（RestController.class）</span></code></pre></div>
</li>
<li><p>除此之外，我们还可以配置接口扫描过滤：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)
        .apiInfo(apiInfo())
        .select()
        .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.pnca.controller&quot;</span>))
        .paths(PathSelectors.ant(<span class="hljs-string">&quot;/pnca/**&quot;</span>)) <span class="hljs-comment">//请求中有pnca的</span>
        .build();
&#125;</code></pre></div>

<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210322222012279.png" alt="在这里插入图片描述"></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210322222052375.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="3-配置Swagger开关"><a href="#3-配置Swagger开关" class="headerlink" title="3 配置Swagger开关"></a>3 配置Swagger开关</h4><ul>
<li><p>通过<code>enable()</code>方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">(Environment environment)</span></span>&#123;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)
            .apiInfo(apiInfo())
            .enable(<span class="hljs-keyword">false</span>)
            .select()
            .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.pnca.controller&quot;</span>))
            .paths(PathSelectors.ant(<span class="hljs-string">&quot;/hello&quot;</span>))
            .build();
&#125;</code></pre></div>
</li>
<li><p>如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">(Environment environment)</span> </span>&#123;
   <span class="hljs-comment">// 设置要显示swagger的环境</span>
   Profiles of = Profiles.of(<span class="hljs-string">&quot;dev&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>);
   <span class="hljs-comment">// 判断当前是否处于该环境</span>
   <span class="hljs-comment">// 通过 enable() 接收此参数判断是否要显示</span>
   <span class="hljs-keyword">boolean</span> flag = environment.acceptsProfiles(of);
   
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .enable(flag) <span class="hljs-comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span>
      .select()<span class="hljs-comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span>
      .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.kuang.swagger.controller&quot;</span>))
       <span class="hljs-comment">// 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口</span>
      .paths(PathSelectors.ant(<span class="hljs-string">&quot;/kuang/**&quot;</span>))
      .build();
&#125;</code></pre></div>
</li>
<li><p>springboot切换使用环境，如果是<code>Profiles.of(&quot;dev&quot;, &quot;test&quot;)</code>这里有的环境，则正常显示，如果是这里没有的则无法使用。</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210329203939370.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="4-配置API分组"><a href="#4-配置API分组" class="headerlink" title="4 配置API分组"></a>4 配置API分组</h4><ol>
<li><p>如果没有配置分组，默认是default。通过<code>groupName()</code>方法即可配置分组</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210329204226225.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">(Environment environment)</span> </span>&#123;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())
      .groupName(<span class="hljs-string">&quot;hello&quot;</span>) <span class="hljs-comment">// 配置分组</span>
       <span class="hljs-comment">// 省略配置....</span>
&#125;</code></pre></div>
</li>
<li><p>如何<code>配置多个分组</code>？配置多个分组只需要配置多个docket即可</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">(Environment environment)</span></span>&#123;

    Profiles of = Profiles.of(<span class="hljs-string">&quot;dev&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>);
    <span class="hljs-keyword">boolean</span> flag = environment.acceptsProfiles(of);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)
            .apiInfo(apiInfo())
            .groupName(<span class="hljs-string">&quot;狂神&quot;</span>)
            .enable(f)
            .select()
            .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.kuang.controller&quot;</span>))
            .paths(PathSelectors.ant(<span class="hljs-string">&quot;/hello&quot;</span>))
            .build();
&#125;

<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket2</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;group1&quot;</span>);
&#125;

<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket3</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;group2&quot;</span>);
&#125;</code></pre></div>

<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210329204504750.png" alt></p>
</li>
</ol>
<h4 id="5-配置注释信息"><a href="#5-配置注释信息" class="headerlink" title="5 配置注释信息"></a>5 配置注释信息</h4><ul>
<li><p>实体类上注解</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ApiModel(&quot;用户实体类&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-meta">@ApiModelProperty(&quot;用户名&quot;)</span>
    <span class="hljs-keyword">public</span> String name;
    <span class="hljs-meta">@ApiModelProperty(&quot;密码&quot;)</span>
    <span class="hljs-keyword">public</span> String password;
&#125;</code></pre></div>
</li>
<li><p>方法返回值中有存在实体类，就会被扫描</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/user&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">hello2</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();
&#125;</code></pre></div>
</li>
<li><p>方法上注解</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(&quot;测试方法&quot;)</span>
<span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello3</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;用户名&quot;)</span> String name)</span></span>&#123;
    <span class="hljs-keyword">return</span> name;
&#125;</code></pre></div>
</li>
<li><p><strong>常用注解</strong></p>
<ul>
<li>@Api(tags = “xxx模块说明”)：作用在模块类上</li>
<li>@ApiOperation(“xxx接口说明”)：作用在接口方法上</li>
<li>@ApiModel(“xxxPOJO说明”)：作用在模型类上：如VO、BO</li>
<li>@ApiModelProperty(value = “xxx属性说明”,hidden = true)：作用在方法和属性上，hidden设置为true可以隐藏该属性</li>
<li>@ApiParam(“xxx参数说明”)：作用在参数、方法和字段上，类似@ApiModelProperty</li>
</ul>
</li>
<li><p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p>
</li>
<li><p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>
</li>
</ul>
<h4 id="6-其他皮肤"><a href="#6-其他皮肤" class="headerlink" title="6 其他皮肤"></a>6 其他皮肤</h4><ol>
<li><p>默认<code>访问</code><a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> 
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210329211653264.png" alt></p>
</li>
<li><p>bootstrap-ui 访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210329211712944.png" alt></p>
</li>
<li><p>Layui-ui 访问 <a href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.caspar-chen<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-ui-layer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210329211732856.png" alt></p>
</li>
<li><p>mg-ui 访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zyplayer<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-mg-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210329211751176.png" alt></p>
</li>
</ol>
<h2 id="10-任务"><a href="#10-任务" class="headerlink" title="10 任务"></a>10 任务</h2><h3 id="10-1-异步任务"><a href="#10-1-异步任务" class="headerlink" title="10.1 异步任务"></a>10.1 异步任务</h3><ol>
<li><p>创建一个AsuncService类</p>
<ul>
<li><p>异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。</p>
</li>
<li><p>编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况；</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncService</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">3000</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(<span class="hljs-string">&quot;业务进行中......&quot;</span>);
    &#125;
&#125;</code></pre></div>
</li>
</ul>
</li>
<li><p>创建一个AsyncController类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncController</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    AsyncService asyncService;

    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;
        asyncService.hello();
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sucess&quot;</span>;
    &#125;
&#125;</code></pre></div>
</li>
<li><p>测试，发现界面没有立即返回结果，而是等后台执行完才返回。</p>
</li>
<li><p>给hello方法添加@Async注解；</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncService</span> </span>&#123;

    <span class="hljs-meta">@Async</span> <span class="hljs-comment">//告诉spring这是一个异步方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">3000</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(<span class="hljs-string">&quot;业务进行中......&quot;</span>);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>SpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能；</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableAsync</span> <span class="hljs-comment">//开启异步注解功能</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot08TaskApplication</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(Springboot08TaskApplication.class, args);
    &#125;

&#125;</code></pre></div>

<p>重启测试，网页瞬间响应，后台代码继续执行！</p>
</li>
</ol>
<h3 id="10-2-定时任务"><a href="#10-2-定时任务" class="headerlink" title="10.2 定时任务"></a>10.2 定时任务</h3><p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。</p>
<ul>
<li>TaskExecutor接口</li>
<li>TaskScheduler接口</li>
</ul>
<p>两个注解：</p>
<ul>
<li>@EnableScheduling</li>
<li>@Scheduled</li>
</ul>
<p><strong>cron表达式：</strong></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210322204802554.jpg" alt></p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210322204802512.jpg" alt></p>
<ol>
<li><p>创建一个ScheduledService类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledService</span> </span>&#123;

	<span class="hljs-comment">//cron表达式</span>
    <span class="hljs-meta">@Scheduled(cron = &quot;0 9 20 * * 0-7&quot;)</span> <span class="hljs-comment">//每天20:09执行</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello Scheduled....&quot;</span>);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>需要在主程序上增加@EnableScheduling 开启定时任务功能</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableScheduling</span> <span class="hljs-comment">//开启基于注解的定时任务</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot08TaskApplication</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(Springboot08TaskApplication.class, args);
    &#125;

&#125;</code></pre></div>
</li>
<li><p>测试</p>
</li>
<li><p>了解下cron表达式</p>
<p><a href="http://www.bejson.com/othertools/cron/">http://www.bejson.com/othertools/cron/</a></p>
</li>
<li><p>常用的表达式</p>
<div class="code-wrapper"><pre><code class="hljs dns">（<span class="hljs-number">1</span>）<span class="hljs-number">0</span>/<span class="hljs-number">2</span> * * * * ?   表示每<span class="hljs-number">2</span>秒 执行任务
（<span class="hljs-number">1）0 0/2</span> * * * ?   表示每<span class="hljs-number">2</span>分钟 执行任务
（<span class="hljs-number">1）0 0 2</span> <span class="hljs-number">1</span> * ?   表示在每月的<span class="hljs-number">1</span>日的凌晨<span class="hljs-number">2</span>点调整任务
（<span class="hljs-number">2）0 15 10</span> ? * MON-FRI   表示周一到周五每天上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>执行作业
（<span class="hljs-number">3）0 15 10</span> ? <span class="hljs-number">6</span>L <span class="hljs-number">2002-2006</span>   表示<span class="hljs-number">2002-2006</span>年的每个月的最后一个星期五上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>执行作
（<span class="hljs-number">4）0 0 10</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span> * * ?   每天上午<span class="hljs-number">10</span>点，下午<span class="hljs-number">2</span>点，<span class="hljs-number">4</span>点
（<span class="hljs-number">5）0 0/30</span> <span class="hljs-number">9</span>-<span class="hljs-number">17</span> * * ?   朝九晚五工作时间内每半小时
（<span class="hljs-number">6）0 0 12</span> ? * WED   表示每个星期三中午<span class="hljs-number">12</span>点
（<span class="hljs-number">7）0 0 12</span> * * ?   每天中午<span class="hljs-number">12</span>点触发
（<span class="hljs-number">8）0 15 10</span> ? * *   每天上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发
（<span class="hljs-number">9）0 15 10</span> * * ?     每天上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发
（<span class="hljs-number">10）0 15 10</span> * * ?   每天上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发
（<span class="hljs-number">11）0 15 10</span> * * ? <span class="hljs-number">2005</span>   <span class="hljs-number">2005</span>年的每天上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发
（<span class="hljs-number">12</span>）<span class="hljs-number">0</span> * <span class="hljs-number">14</span> * * ?     在每天下午<span class="hljs-number">2</span>点到下午<span class="hljs-number">2</span>:<span class="hljs-number">59</span>期间的每<span class="hljs-number">1</span>分钟触发
（<span class="hljs-number">13）0 0/5</span> <span class="hljs-number">14</span> * * ?   在每天下午<span class="hljs-number">2</span>点到下午<span class="hljs-number">2</span>:<span class="hljs-number">55</span>期间的每<span class="hljs-number">5</span>分钟触发
（<span class="hljs-number">14）0 0/5</span> <span class="hljs-number">14</span>,<span class="hljs-number">18</span> * * ?     在每天下午<span class="hljs-number">2</span>点到<span class="hljs-number">2</span>:<span class="hljs-number">55</span>期间和下午<span class="hljs-number">6</span>点到<span class="hljs-number">6</span>:<span class="hljs-number">55</span>期间的每<span class="hljs-number">5</span>分钟触发
（<span class="hljs-number">15）0 0-5</span> <span class="hljs-number">14</span> * * ?   在每天下午<span class="hljs-number">2</span>点到下午<span class="hljs-number">2</span>:<span class="hljs-number">05</span>期间的每<span class="hljs-number">1</span>分钟触发
（<span class="hljs-number">16）0 10,44</span> <span class="hljs-number">14</span> ? <span class="hljs-number">3</span> WED   每年三月的星期三的下午<span class="hljs-number">2:10和2:44</span>触发
（<span class="hljs-number">17）0 15 10</span> ? * MON-FRI   周一至周五的上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发
（<span class="hljs-number">18）0 15 10</span> <span class="hljs-number">15</span> * ?   每月<span class="hljs-number">15</span>日上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发
（<span class="hljs-number">19）0 15 10</span> L * ?   每月最后一日的上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发
（<span class="hljs-number">20）0 15 10</span> ? * <span class="hljs-number">6</span>L   每月的最后一个星期五上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发
（<span class="hljs-number">21）0 15 10</span> ? * <span class="hljs-number">6</span>L <span class="hljs-number">2002-2005</span>   <span class="hljs-number">2002</span>年至<span class="hljs-number">2005</span>年的每月的最后一个星期五上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发
（<span class="hljs-number">22）0 15 10</span> ? * <span class="hljs-number">6</span>#<span class="hljs-number">3</span>   每月的第三个星期五上午<span class="hljs-number">10</span>:<span class="hljs-number">15</span>触发</code></pre></div>

</li>
</ol>
<h3 id="10-3-邮件发送"><a href="#10-3-邮件发送" class="headerlink" title="10.3 邮件发送"></a>10.3 邮件发送</h3><p>邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持</p>
<ul>
<li>邮件发送需要引入spring-boot-start-mail</li>
<li>SpringBoot 自动配置MailSenderAutoConfiguration</li>
<li>定义MailProperties内容，配置在application.yml中</li>
<li>自动装配JavaMailSender</li>
<li>测试邮件发送</li>
</ul>
<ol>
<li><p>引入依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>配置文件</p>
<p>查看一下MailProperties</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(</span>
<span class="hljs-meta">   prefix = &quot;spring.mail&quot;</span>
<span class="hljs-meta">)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailProperties</span> </span>&#123;
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset DEFAULT_CHARSET;
   <span class="hljs-keyword">private</span> String host;
   <span class="hljs-keyword">private</span> Integer port;
   <span class="hljs-keyword">private</span> String username;
   <span class="hljs-keyword">private</span> String password;
   <span class="hljs-keyword">private</span> String protocol = <span class="hljs-string">&quot;smtp&quot;</span>;
   <span class="hljs-keyword">private</span> Charset defaultEncoding;
   <span class="hljs-keyword">private</span> Map&lt;String, String&gt; properties;
   <span class="hljs-keyword">private</span> String jndiName;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.mail.username</span>=<span class="hljs-string">24736743@qq.com</span>
<span class="hljs-meta">spring.mail.password</span>=<span class="hljs-string">你的qq授权码</span>
<span class="hljs-meta">spring.mail.host</span>=<span class="hljs-string">smtp.qq.com</span>
<span class="hljs-comment"># qq需要配置ssl</span>
<span class="hljs-meta">spring.mail.properties.mail.smtp.ssl.enable</span>=<span class="hljs-string">true</span></code></pre></div>

<p>获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务</p>
<p><img src="/2021/04/04/SpringBoot%E5%AD%A6%E4%B9%A0/20210322205732662.jpg" alt></p>
</li>
<li><p>Spring单元测试</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot08TaskApplicationTests</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    JavaMailSenderImpl mailSender;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//方式一：简单的邮件</span>
        SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();
        message.setSubject(<span class="hljs-string">&quot;通知-明天放假&quot;</span>);
        message.setText(<span class="hljs-string">&quot;今晚7:30开会&quot;</span>);

        message.setTo(<span class="hljs-string">&quot;24736743@qq.com&quot;</span>);
        message.setFrom(<span class="hljs-string">&quot;24736743@qq.com&quot;</span>);
        mailSender.send(message);
    &#125;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;
        <span class="hljs-comment">//方式二：复杂的邮件</span>
        MimeMessage mimeMessage = mailSender.createMimeMessage();
        MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);

        helper.setSubject(<span class="hljs-string">&quot;通知-明天上课&quot;</span>);
        helper.setText(<span class="hljs-string">&quot;&lt;b style=&#x27;color:red&#x27;&gt;今天 7:30来开会&lt;/b&gt;&quot;</span>,<span class="hljs-keyword">true</span>);

        helper.addAttachment(<span class="hljs-string">&quot;1.jpg&quot;</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\Lenovo\\Desktop\\1.jpg&quot;</span>));
        <span class="hljs-comment">//helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;&quot;));</span>

        helper.setTo(<span class="hljs-string">&quot;24736743@qq.com&quot;</span>);
        helper.setFrom(<span class="hljs-string">&quot;24736743@qq.com&quot;</span>);

        mailSender.send(mimeMessage);
    &#125;
&#125;</code></pre></div>

<p>查看邮箱，邮件接收成功！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Java 面试</title>
    <url>/2021/07/30/Java%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="第一部分-Java-并发编程"><a href="#第一部分-Java-并发编程" class="headerlink" title="第一部分 Java 并发编程"></a>第一部分 Java 并发编程</h1><h1 id="第1章-谈谈Volatile"><a href="#第1章-谈谈Volatile" class="headerlink" title="第1章 谈谈Volatile"></a>第1章 谈谈Volatile</h1><h2 id="1-Volatile和JMM内存模型的可见性"><a href="#1-Volatile和JMM内存模型的可见性" class="headerlink" title="1 Volatile和JMM内存模型的可见性"></a>1 Volatile和JMM内存模型的可见性</h2><ul>
<li>JUC（java.util.concurrent）<ul>
<li>进程和线程<ul>
<li>进程：后台运行的程序（我们打开的一个软件，就是进程）</li>
<li>线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）</li>
</ul>
</li>
<li>并发和并行<ul>
<li>并发：同时访问某个东西，就是并发</li>
<li>并行：一起做某些事情，就是并行</li>
</ul>
</li>
</ul>
</li>
<li>JUC下的三个包<ul>
<li>java.util.concurrent<ul>
<li>java.util.concurrent.atomic</li>
<li>java.util.concurrent.locks</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Volatile在日常的单线程环境是应用不到的</p>
<ul>
<li>Volatile是Java虚拟机提供的<code>轻量级</code>的同步机制（三大特性）<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ul>
</li>
</ul>
<h3 id="1-1-谈谈对Volatile的理解"><a href="#1-1-谈谈对Volatile的理解" class="headerlink" title="1.1 谈谈对Volatile的理解"></a>1.1 谈谈对Volatile的理解</h3><h3 id="1-2-JMM是什么"><a href="#1-2-JMM是什么" class="headerlink" title="1.2 JMM是什么"></a>1.2 JMM是什么</h3><p>JMM是Java内存模型，也就是Java Memory Model，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p>
<p>JMM关于同步的规定：</p>
<ul>
<li>线程解锁前，必须把共享变量的值刷新回主内存</li>
<li>线程加锁前，必须读取主内存的最新值，到自己的工作内存</li>
<li>加锁和解锁是同一把锁</li>
</ul>
<p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，<code>但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存</code>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/1_Volatile%E5%92%8CJMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/images/image-20200309153225758.png" alt="image-20200309153225758"></p>
<p>数据传输速率：硬盘 &lt; 内存 &lt; &lt; cache &lt; CPU   </p>
<p>上面提到了两个概念：主内存  和 工作内存</p>
<ul>
<li><p>主内存：就是计算机的内存，也就是经常提到的8G内存，16G内存</p>
</li>
<li><p>工作内存：但我们实例化 new student，那么 age = 25 也是存储在主内存中</p>
<ul>
<li>当同时有三个线程同时访问 student中的age变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了变量的拷贝</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/1_Volatile%E5%92%8CJMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/images/image-20200309154435933.png" alt="image-20200309154435933"></p>
</li>
</ul>
<p>即：JMM内存模型的可见性，指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p>
<h3 id="1-3-缓存一致性"><a href="#1-3-缓存一致性" class="headerlink" title="1.3 缓存一致性"></a>1.3 缓存一致性</h3><p>为什么这里主线程中某个值被更改后，其它线程能马上知晓呢？其实这里是用到了总线嗅探技术</p>
<p>在说嗅探技术之前，首先谈谈缓存一致性的问题，就是当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一。</p>
<p>为了解决缓存一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，这类协议主要有MSI、MESI等等。</p>
<h4 id="1-MESI"><a href="#1-MESI" class="headerlink" title="1 MESI"></a>1 MESI</h4><p>当CPU写数据时，如果发现操作的变量是共享变量，即在其它CPU中也存在该变量的副本，会发出信号通知其它CPU将该内存变量的缓存行设置为无效，因此当其它CPU读取这个变量的时，发现自己缓存该变量的缓存行是无效的，那么它就会从内存中重新读取。</p>
<h4 id="2-总线嗅探"><a href="#2-总线嗅探" class="headerlink" title="2 总线嗅探"></a>2 总线嗅探</h4><p>那么是如何发现数据是否失效呢？</p>
<p>这里是用到了总线嗅探技术，就是每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中。</p>
<h4 id="3-总线风暴"><a href="#3-总线风暴" class="headerlink" title="3 总线风暴"></a>3 总线风暴</h4><p>总线嗅探技术有哪些缺点？</p>
<p>由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和CAS循环，无效的交互会导致总线带宽达到峰值。因此不要大量使用volatile关键字，至于什么时候使用volatile、什么时候用锁以及Syschonized都是需要根据实际场景的。</p>
<h3 id="1-4-JMM的特性"><a href="#1-4-JMM的特性" class="headerlink" title="1.4 JMM的特性"></a>1.4 JMM的特性</h3><p>JMM的三大特性，volatile只保证了两个，即可见性和有序性，不满足原子性</p>
<ul>
<li>可见性</li>
<li>原子性</li>
<li>有序性</li>
</ul>
<h3 id="1-5-可见性代码验证"><a href="#1-5-可见性代码验证" class="headerlink" title="1.5 可见性代码验证"></a>1.5 可见性代码验证</h3><p>但我们对于成员变量没有添加任何修饰时，是无法感知其它线程修改后的值</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.moxi.interview.study.thread;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Volatile Java虚拟机提供的轻量级同步机制</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 可见性（及时通知）</span>
<span class="hljs-comment"> * 不保证原子性</span>
<span class="hljs-comment"> * 禁止指令重排</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 假设是主物理内存</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;

    <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 验证volatile的可见性</span>
<span class="hljs-comment"> * 1. 假设int number = 0， number变量之前没有添加volatile关键字修饰</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args [])</span> </span>&#123;

        <span class="hljs-comment">// 资源类</span>
        MyData myData = <span class="hljs-keyword">new</span> MyData();

        <span class="hljs-comment">// AAA线程 实现了Runnable接口的，lambda表达式</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in&quot;</span>);

            <span class="hljs-comment">// 线程睡眠3秒，假设在进行运算</span>
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-comment">// 修改number的值</span>
            myData.addTo60();

            <span class="hljs-comment">// 输出修改后的值</span>
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t update number value:&quot;</span> + myData.number);

        &#125;, <span class="hljs-string">&quot;AAA&quot;</span>).start();

        <span class="hljs-keyword">while</span>(myData.number == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// main线程就一直在这里等待循环，直到number的值不等于零</span>
        &#125;

        <span class="hljs-comment">// 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环</span>
        <span class="hljs-comment">// 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了</span>
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t mission is over&quot;</span>);

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 最后输出结果：</span>
<span class="hljs-comment">         * AAA	 come in</span>
<span class="hljs-comment">         * AAA	 update number value:60</span>
<span class="hljs-comment">         * 最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</span>
<span class="hljs-comment">         */</span>

    &#125;
&#125;</code></pre></div>

<p>输出结果为</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/1_Volatile%E5%92%8CJMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/images/image-20200309162154191.png" alt="image-20200309162154191">    </p>
<p>最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</p>
<p>当我们修改MyData类中的成员变量时，并且添加volatile关键字修饰</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 假设是主物理内存</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;
    &#125;
&#125;</code></pre></div>

<p>最后输出的结果为：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/1_Volatile%E5%92%8CJMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/images/image-20200309162154191.png" alt="image-20200309162154191"></p>
<p>主线程也执行完毕了，说明volatile修饰的变量，是具备JVM轻量级同步机制的，能够感知其它线程的修改后的值。</p>
<h2 id="2-Volatile不保证原子性"><a href="#2-Volatile不保证原子性" class="headerlink" title="2 Volatile不保证原子性"></a>2 Volatile不保证原子性</h2><h3 id="2-1-前言"><a href="#2-1-前言" class="headerlink" title="2.1 前言"></a>2.1 前言</h3><p>通过前面对JMM的介绍，我们知道，各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后在写回到主内存中的。</p>
<p>这就可能存在一个线程AAA修改了共享变量X的值，但是还未写入主内存时，另外一个线程BBB又对主内存中同一共享变量X进行操作，但此时A线程工作内存中共享变量X对线程B来说是不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题。</p>
<h3 id="2-2-原子性"><a href="#2-2-原子性" class="headerlink" title="2.2 原子性"></a>2.2 原子性</h3><p>不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要具体完成，要么同时成功，要么同时失败。</p>
<p>数据库也经常提到事务具备原子性</p>
<h3 id="2-3-代码测试"><a href="#2-3-代码测试" class="headerlink" title="2.3 代码测试"></a>2.3 代码测试</h3><p>为了测试volatile是否保证原子性，我们创建了20个线程，然后每个线程分别循环1000次，来调用number++的方法</p>
<div class="code-wrapper"><pre><code class="hljs java">MyData myData = <span class="hljs-keyword">new</span> MyData();

<span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-comment">// 里面</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;
            myData.addPlusPlus();
        &#125;
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>最后通过 Thread.activeCount()，来感知20个线程是否执行完毕，这里判断线程数是否大于2，为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span>
<span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123;
    <span class="hljs-comment">// yield表示不执行</span>
    Thread.yield();
&#125;</code></pre></div>

<p>然后在线程执行完毕后，我们在查看number的值，假设volatile保证原子性的话，那么最后输出的值应该是</p>
<p>20 * 1000 = 20000,</p>
<p>完整代码如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs java">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Volatile Java虚拟机提供的轻量级同步机制</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 可见性（及时通知）</span>
<span class="hljs-comment"> * 不保证原子性</span>
<span class="hljs-comment"> * 禁止指令重排</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 假设是主物理内存</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 注意，此时number 前面是加了volatile修饰</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;
        number ++;
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 验证volatile的可见性</span>
<span class="hljs-comment"> * 1、 假设int number = 0， number变量之前没有添加volatile关键字修饰</span>
<span class="hljs-comment"> * 2、添加了volatile，可以解决可见性问题</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 验证volatile不保证原子性</span>
<span class="hljs-comment"> * 1、原子性指的是什么意思？</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args [])</span> </span>&#123;

        MyData myData = <span class="hljs-keyword">new</span> MyData();

        <span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                <span class="hljs-comment">// 里面</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;
                    myData.addPlusPlus();
                &#125;
            &#125;, String.valueOf(i)).start();
        &#125;

        <span class="hljs-comment">// 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span>
        <span class="hljs-comment">// 这里判断线程数是否大于2，为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</span>
        <span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123;
            <span class="hljs-comment">// yield表示不执行</span>
            Thread.yield();
        &#125;

        <span class="hljs-comment">// 查看最终的值</span>
        <span class="hljs-comment">// 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000</span>
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally number value: &quot;</span> + myData.number);

    &#125;
&#125;</code></pre></div>

<p>最终结果我们会发现，number输出的值并没有20000，而且是每次运行的结果都不一致的，这说明了volatile修饰的变量不保证原子性</p>
<p>第一次：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/2_Volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/images/image-20200309172900462.png" alt="image-20200309172900462"></p>
<p>第二次：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/2_Volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/images/image-20200309172919295.png" alt="image-20200309172919295"></p>
<p>第三次：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/2_Volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/images/image-20200309172929820.png" alt="image-20200309172929820"></p>
<h3 id="2-4-为什么出现数值丢失"><a href="#2-4-为什么出现数值丢失" class="headerlink" title="2.4 为什么出现数值丢失"></a>2.4 为什么出现数值丢失</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/2_Volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/images/image-20200309174220675.png" alt="image-20200309174220675"></p>
<p>各自线程在写入主内存的时候，出现了数据的丢失，而引起的数值缺失的问题</p>
<p>下面我们将一个简单的number++操作，转换为字节码文件一探究竟</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span> </span>&#123;
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;
        n++;
    &#125;
&#125;</code></pre></div>

<p>转换后的字节码文件</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">moxi</span>.<span class="hljs-title">interview</span>.<span class="hljs-title">study</span>.<span class="hljs-title">thread</span>.<span class="hljs-title">T1</span> </span>&#123;
  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> n;

  <span class="hljs-keyword">public</span> com.moxi.interview.study.thread.T1();
    Code:
       <span class="hljs-number">0</span>: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
       <span class="hljs-number">4</span>: aload_0
       <span class="hljs-number">5</span>: iconst_0
       6: putfield      #2                  // Field n:I
       <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span>

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;
    Code:
       <span class="hljs-number">0</span>: aload_0
       <span class="hljs-number">1</span>: dup
       2: getfield      #2                  // Field n:I
       <span class="hljs-number">5</span>: iconst_1
       <span class="hljs-number">6</span>: iadd
       7: putfield      #2                  // Field n:I
      <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span>
&#125;</code></pre></div>

<p>这里查看字节码的操作，是用到了IDEA的javap命令</p>
<p>我们首先，使用IDEA提供的External Tools，来扩展javap命令</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/2_Volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/images/image-20200309183026329.png" alt="image-20200309183026329"></p>
<p>完成上述操作后，我们在需要查看字节码的文件下，右键选择 External Tools即可</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/2_Volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/images/image-20200309183115613.png" alt="image-20200309183115613"></p>
<p>如果出现了找不到指定类，那是因为我们创建的是spring boot的maven项目，我们之前需要执行mvn package命令，进行打包操作，将其编译成class文件</p>
<p>移动到底部，有一份字节码指令对照表，方便我们进行阅读</p>
<p>下面我们就针对 add() 这个方法的字节码文件进行分析</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;
  Code:
     <span class="hljs-number">0</span>: aload_0
     <span class="hljs-number">1</span>: dup
     2: getfield      #2    // Field n:I
     <span class="hljs-number">5</span>: iconst_1
     <span class="hljs-number">6</span>: iadd
     7: putfield      #2    // Field n:I
    <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span></code></pre></div>

<p>我们能够发现 n++这条命令，被拆分成了3个指令</p>
<ul>
<li>执行<code>getfield</code> 从主内存拿到原始n</li>
<li>执行<code>iadd</code> 进行加1操作</li>
<li>执行<code>putfileld</code> 把累加后的值写回主内存 </li>
</ul>
<p>假设我们没有加 <code>synchronized</code>那么第一步就可能存在着，三个线程同时通过getfield命令，拿到主存中的 n值，然后三个线程，各自在自己的工作内存中进行加1操作，但他们并发进行  <code>iadd</code> 命令的时候，因为只能一个进行写，所以其它操作会被挂起，假设1线程，先进行了写操作，在写完后，volatile的可见性，应该需要告诉其它两个线程，主内存的值已经被修改了，但是因为太快了，其它两个线程，陆续执行 <code>iadd</code>命令，进行写入操作，这就造成了其他线程没有接受到主内存n的改变，从而覆盖了原来的值，出现写丢失，这样也就让最终的结果少于20000</p>
<h3 id="2-5-如何解决"><a href="#2-5-如何解决" class="headerlink" title="2.5 如何解决"></a>2.5 如何解决</h3><p>因此这也说明，在多线程环境下 number ++ 在多线程环境下是非线程安全的，解决的方法有哪些呢？</p>
<ul>
<li>在方法上加入 synchronized</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;
	number ++;
&#125;</code></pre></div>

<p>运行结果：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/2_Volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/images/image-20200309173315294.png" alt="image-20200309173315294"></p>
<p>我们能够发现引入synchronized关键字后，保证了该方法每次只能够一个线程进行访问和操作，最终输出的结果也就为20000</p>
<h3 id="2-6-其它解决方法"><a href="#2-6-其它解决方法" class="headerlink" title="2.6  其它解决方法"></a>2.6  其它解决方法</h3><p>上面的方法引入synchronized，虽然能够保证原子性，但是为了解决number++，而引入重量级的同步机制，有种 杀鸡焉用牛刀</p>
<p>除了引用synchronized关键字外，还可以使用JUC下面的原子包装类，即刚刚的int类型的number，可以使用AtomicInteger来代替</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">     *  创建一个原子Integer包装类，默认为0</span>
<span class="hljs-comment">      */</span>
AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtomic</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 相当于 atomicInter ++</span>
    atomicInteger.getAndIncrement();
&#125;</code></pre></div>

<p>然后同理，继续刚刚的操作</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-comment">// 里面</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;
            myData.addPlusPlus();
            myData.addAtomic();
        &#125;
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>最后输出</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000</span>
System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally number value: &quot;</span> + myData.number);
System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally atomicNumber value: &quot;</span> + myData.atomicInteger);</code></pre></div>

<p>下面的结果，一个是引入synchronized，一个是使用了原子包装类AtomicInteger</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/2_Volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/images/image-20200309205242622.png" alt="image-20200309205242622"></p>
<h2 id="3-Volatile禁止指令重排"><a href="#3-Volatile禁止指令重排" class="headerlink" title="3 Volatile禁止指令重排"></a>3 Volatile禁止指令重排</h2><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令重排，一般分为以下三种：</p>
<div class="code-wrapper"><pre><code class="hljs clean">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</code></pre></div>

<p>单线程环境里面确保最终执行结果和代码顺序的结果一致</p>
<p>处理器在进行重排序时，必须要考虑指令之间的<code>数据依赖性</code></p>
<p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p>
<h3 id="3-1-指令重排-example-1"><a href="#3-1-指令重排-example-1" class="headerlink" title="3.1 指令重排 - example 1"></a>3.1 指令重排 - example 1</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mySort</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">11</span>;
	<span class="hljs-keyword">int</span> y = <span class="hljs-number">12</span>;
	x = x + <span class="hljs-number">5</span>;
	y = x * x;
&#125;</code></pre></div>

<p>按照正常单线程环境，执行顺序是 1 2 3 4</p>
<p>但是在多线程环境下，可能出现以下的顺序：</p>
<ul>
<li>2 1 3 4</li>
<li>1 3 2 4 </li>
</ul>
<p>上述的过程就可以当做是指令的重排，即内部执行顺序，和我们的代码顺序不一样</p>
<p>但是指令重排也是有限制的，即不会出现下面的顺序</p>
<ul>
<li>4 3 2 1</li>
</ul>
<p>因为处理器在进行重排时候，必须考虑到指令之间的数据依赖性</p>
<p>因为步骤 4：需要依赖于 y的申明，以及x的申明，故因为存在数据依赖，无法首先执行</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>int a,b,x,y = 0</p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>x = a;</td>
<td>y = b;</td>
</tr>
<tr>
<td>b = 1;</td>
<td>a = 2;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>x = 0;  y = 0</td>
<td></td>
</tr>
</tbody></table>
<p>因为上面的代码，不存在数据的依赖性，因此编译器可能对数据进行重排</p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>b = 1;</td>
<td>a = 2;</td>
</tr>
<tr>
<td>x = a;</td>
<td>y = b;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>x = 2;  y = 1</td>
<td></td>
</tr>
</tbody></table>
<p>这样造成的结果，和最开始的就不一致了，这就是导致重排后，结果和最开始的不一样，因此为了防止这种结果出现，volatile就规定禁止指令重排，为了保证数据的一致性</p>
<h3 id="3-2-指令重排-example-2"><a href="#3-2-指令重排-example-2" class="headerlink" title="3.2 指令重排 - example 2"></a>3.2 指令重排 - example 2</h3><p>比如下面这段代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * ResortSeqDemo</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResortSeqDemo</span> </span>&#123;
    <span class="hljs-keyword">int</span> a= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;
        a = <span class="hljs-number">1</span>;
        flag = <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method02</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(flag) &#123;
            a = a + <span class="hljs-number">5</span>;
            System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>我们按照正常的顺序，分别调用method01()  和 method02() 那么，最终输出就是 a = 6</p>
<p>但是如果在多线程环境下，因为方法1 和 方法2，他们之间不能存在数据依赖的问题，因此原先的顺序可能是</p>
<div class="code-wrapper"><pre><code class="hljs java">a = <span class="hljs-number">1</span>;
flag = <span class="hljs-keyword">true</span>;

a = a + <span class="hljs-number">5</span>;
System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);</code></pre></div>

<p>但是在经过编译器，指令，或者内存的重排后，可能会出现这样的情况</p>
<div class="code-wrapper"><pre><code class="hljs java">flag = <span class="hljs-keyword">true</span>;

a = a + <span class="hljs-number">5</span>;
System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);

a = <span class="hljs-number">1</span>;</code></pre></div>

<p>也就是先执行 flag = true后，另外一个线程马上调用方法2，满足 flag的判断，最终让a + 5，结果为5，这样同样出现了数据不一致的问题</p>
<p>为什么会出现这个结果：多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p>
<p>这样就需要通过volatile来修饰，来保证线程安全性</p>
<h3 id="3-3-Volatile针对指令重排做了啥"><a href="#3-3-Volatile针对指令重排做了啥" class="headerlink" title="3.3 Volatile针对指令重排做了啥"></a>3.3 Volatile针对指令重排做了啥</h3><p>Volatile实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象</p>
<p>首先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：</p>
<ul>
<li>保证特定操作的顺序</li>
<li>保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</li>
</ul>
<p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说 <code>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</code>。 内存屏障另外一个作用是刷新出各种CPU的缓存数，因此任何CPU上的线程都能读取到这些数据的最新版本。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/3_Volatile%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/images/image-20200310162654437.png" alt="image-20200310162654437"></p>
<p>也就是过在Volatile的写 和 读的时候，加入屏障，防止出现指令重排的</p>
<h3 id="3-4-线程安全获得保证"><a href="#3-4-线程安全获得保证" class="headerlink" title="3.4 线程安全获得保证"></a>3.4 线程安全获得保证</h3><p>工作内存与主内存同步延迟现象导致的可见性问题</p>
<ul>
<li>可通过synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见</li>
</ul>
<p>对于指令重排导致的可见性问题和有序性问题</p>
<ul>
<li>可以使用volatile关键字解决，因为volatile关键字的另一个作用就是禁止重排序优化</li>
</ul>
<h3 id="3-5-总线嗅探"><a href="#3-5-总线嗅探" class="headerlink" title="3.5 总线嗅探"></a>3.5 总线嗅探</h3><h2 id="4-Volatile的应用"><a href="#4-Volatile的应用" class="headerlink" title="4 Volatile的应用"></a>4 Volatile的应用</h2><h3 id="单例模式DCL代码"><a href="#单例模式DCL代码" class="headerlink" title="单例模式DCL代码"></a>单例模式DCL代码</h3><p>首先回顾一下，单线程下的单例模式代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * SingletonDemo（单例模式）</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            instance = <span class="hljs-keyword">new</span> SingletonDemo();
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 这里的 == 是比较内存地址</span>
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
    &#125;
&#125;</code></pre></div>

<p>最后输出的结果</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/4_Volatile%E7%9A%84%E5%BA%94%E7%94%A8/images/image-20200310164513408.png" alt="image-20200310164513408"></p>
<p>但是在多线程的环境下，我们的单例模式是否还是同一个对象了</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * SingletonDemo（单例模式）</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            instance = <span class="hljs-keyword">new</span> SingletonDemo();
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                SingletonDemo.getInstance();
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>从下面的结果我们可以看出，我们通过SingletonDemo.getInstance() 获取到的对象，并不是同一个，而是被下面几个线程都进行了创建，那么在多线程环境下，单例模式如何保证呢？</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/4_Volatile%E7%9A%84%E5%BA%94%E7%94%A8/images/image-20200310164720940.png" alt="image-20200310164720940"></p>
<h4 id="1-解决方法1"><a href="#1-解决方法1" class="headerlink" title="1 解决方法1"></a>1 解决方法1</h4><p>引入synchronized关键字</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
        instance = <span class="hljs-keyword">new</span> SingletonDemo();
    &#125;
    <span class="hljs-keyword">return</span> instance;
&#125;</code></pre></div>

<p>输出结果</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/4_Volatile%E7%9A%84%E5%BA%94%E7%94%A8/images/image-20200310164946940.png" alt="image-20200310164946940"></p>
<p>我们能够发现，通过引入Synchronized关键字，能够解决高并发环境下的单例模式问题</p>
<p>但是synchronized属于重量级的同步机制，它只允许一个线程同时访问获取实例的方法，但是为了保证数据一致性，而减低了并发性，因此采用的比较少</p>
<h4 id="2-解决方法2"><a href="#2-解决方法2" class="headerlink" title="2 解决方法2"></a>2 解决方法2</h4><p>通过引入DCL   Double Check Lock   双端检锁机制</p>
<p>就是在进来和出去的时候，进行检测</p>
<div class="code-wrapper"><pre><code class="hljs smali">public<span class="hljs-keyword"> static</span> SingletonDemo getInstance() &#123;
    if(instance == null) &#123;
        // 同步代码段的时候，进行检测
        synchronized (SingletonDemo.class) &#123;
            if(instance == null) &#123;
               <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>SingletonDemo();
            &#125;
        &#125;
    &#125;
   <span class="hljs-built_in"> return </span>instance;
&#125;</code></pre></div>

<p>最后输出的结果为：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/1_%E8%B0%88%E8%B0%88Volatile/4_Volatile%E7%9A%84%E5%BA%94%E7%94%A8/images/image-20200310165703190.png" alt="image-20200310165703190"></p>
<p>从输出结果来看，确实能够保证单例模式的正确性，但是上面的方法还是存在问题的</p>
<p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入volatile可以禁止指令重排</p>
<p>原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象可能没有完成实例化。因为 instance = new SingletonDemo()；可以分为以下三步进行完成：</p>
<ul>
<li>memory = allocate();   // 1、分配对象内存空间</li>
<li>instance(memory);   // 2、初始化对象</li>
<li>instance = memory;  // 3、设置instance指向刚刚分配的内存地址，此时instance != null</li>
</ul>
<p>但是我们通过上面的三个步骤，能够发现，步骤2 和 步骤3之间不存在 数据依赖关系，而且无论重排前 还是重排后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。</p>
<ul>
<li>memory = allocate();   // 1、分配对象内存空间</li>
<li>instance = memory;  // 3、设置instance指向刚刚分配的内存地址，此时instance != null，但是对象还没有初始化完成</li>
<li>instance(memory);   // 2、初始化对象</li>
</ul>
<p>这样就会造成什么问题呢？</p>
<p>也就是当我们执行到重排后的步骤2，试图获取instance的时候，会得到null，因为对象的初始化还没有完成，而是在重排后的步骤3才完成，因此执行单例模式的代码时候，就会重新在创建一个instance实例</p>
<p><code>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</code></p>
<p>所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，这就造成了线程安全的问题</p>
<p>所以需要引入volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;</code></pre></div>

<h4 id="3-最终代码"><a href="#3-最终代码" class="headerlink" title="3 最终代码"></a>3 最终代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * SingletonDemo（单例模式）</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// a 双重检查加锁多线程情况下会出现某个线程虽然这里已经为空，但是另外一个线程已经执行到d处</span>
            <span class="hljs-keyword">synchronized</span> (SingletonDemo.class) <span class="hljs-comment">//b</span>
            &#123; 
           <span class="hljs-comment">//c不加volitale关键字的话有可能会出现尚未完全初始化就获取到的情况。原因是内存模型允许无序写入</span>
                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123; 
                	<span class="hljs-comment">// d 此时才开始初始化</span>
                    instance = <span class="hljs-keyword">new</span> SingletonDemo();
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
<span class="hljs-comment">//        // 这里的 == 是比较内存地址</span>
<span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span>
<span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span>
<span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span>
<span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                SingletonDemo.getInstance();
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<h1 id="第2章-CAS底层原理"><a href="#第2章-CAS底层原理" class="headerlink" title="第2章 CAS底层原理"></a>第2章 CAS底层原理</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>CAS的全称是Compare-And-Swap，它是CPU并发原语</p>
<p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的</p>
<p>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的。</p>
<h2 id="2-代码使用"><a href="#2-代码使用" class="headerlink" title="2 代码使用"></a>2 代码使用</h2><p>首先调用AtomicInteger创建了一个实例， 并初始化为5</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个原子类</span>
AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);</code></pre></div>

<p>然后调用CAS方法，企图更新成2019，这里有两个参数，一个是5，表示期望值，第二个就是我们要更新的值</p>
<div class="code-wrapper"><pre><code class="hljs java">atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>)</code></pre></div>

<p>然后再次使用了一个方法，同样将值改成1024</p>
<div class="code-wrapper"><pre><code class="hljs java">atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">1024</span>)</code></pre></div>

<p>完整代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * CASDemo</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 比较并交换：compareAndSet</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 创建一个原子类</span>
        AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span>
<span class="hljs-comment">         * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span>
<span class="hljs-comment">         */</span>
        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());

        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());
    &#125;
&#125;</code></pre></div>

<p>上面代码的执行结果为</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/2_%E8%B0%88%E8%B0%88CAS/5_CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/images/image-20200310201327734.png" alt="image-20200310201327734"></p>
<p>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，但是第二次后，主内存的值已经修改成了2019，不满足期望值，因此返回了false，本次写入失败</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/2_%E8%B0%88%E8%B0%88CAS/5_CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/images/image-20200310201311367.png" alt="image-20200310201311367"></p>
<p>这个就类似于SVN或者Git的版本号，如果没有人更改过，就能够正常提交，否者需要先将代码pull下来，合并代码后，然后提交</p>
<h2 id="3-CAS底层原理"><a href="#3-CAS底层原理" class="headerlink" title="3 CAS底层原理"></a>3 CAS底层原理</h2><p>首先我们先看看 atomicInteger.getAndIncrement()方法的源码</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/2_%E8%B0%88%E8%B0%88CAS/5_CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/images/image-20200310203030720.png" alt="image-20200310203030720"></p>
<p>从这里能够看到，底层又调用了一个unsafe类的getAndAddInt方法</p>
<h3 id="3-1-unsafe类"><a href="#3-1-unsafe类" class="headerlink" title="3.1 unsafe类"></a>3.1 unsafe类</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/2_%E8%B0%88%E8%B0%88CAS/5_CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/images/image-20200310203350122.png" alt="image-20200310203350122"></p>
<p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe类存在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中的CAS操作的执行依赖于Unsafe类的方法。</p>
<p><code>注意Unsafe类的所有方法都是native修饰的，也就是说unsafe类中的方法都直接调用操作系统底层资源执行相应的任务</code></p>
<p>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</p>
<h3 id="3-2-变量valueOffset"><a href="#3-2-变量valueOffset" class="headerlink" title="3.2 变量valueOffset"></a>3.2 变量valueOffset</h3><p>表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/2_%E8%B0%88%E8%B0%88CAS/5_CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/images/image-20200310203030720.png" alt="image-20200310203030720"></p>
<p>从这里我们能够看到，通过valueOffset，直接通过内存地址，获取到值，然后进行加1的操作</p>
<h3 id="3-3-变量value用volatile修饰"><a href="#3-3-变量value用volatile修饰" class="headerlink" title="3.3 变量value用volatile修饰"></a>3.3 变量value用volatile修饰</h3><p>保证了多线程之间的内存可见性</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/2_%E8%B0%88%E8%B0%88CAS/5_CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/images/image-20200310210701761.png" alt="image-20200310210701761"></p>
<p>var5：就是我们从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值到自己的本地内存，然后执行compareAndSwapInt()在再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p>
<p>那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较</p>
<p>假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p>
<ul>
<li>val1：AtomicInteger对象本身</li>
<li>var2：该对象值得引用地址</li>
<li>var4：需要变动的数量</li>
<li>var5：用var1和var2找到的内存中的真实值<ul>
<li>用该对象当前的值与var5比较</li>
<li>如果相同，更新var5 + var4 并返回true</li>
<li>如果不同，继续取值然后再比较，直到更新完成</li>
</ul>
</li>
</ul>
<p>这里没有用synchronized，而用CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。</p>
<p>假设线程A和线程B同时执行getAndInt操作（分别跑在不同的CPU上）</p>
<ol>
<li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</li>
<li>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是线程A被挂起（该线程失去CPU执行权）</li>
<li>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B没有被挂起，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</li>
<li>这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4不一致，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行do while</li>
<li>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</li>
</ol>
<p>Unsafe类 + CAS思想： 也就是自旋，自我旋转</p>
<h2 id="4-底层汇编"><a href="#4-底层汇编" class="headerlink" title="4 底层汇编"></a>4 底层汇编</h2><p>Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于unsafe.cpp中</p>
<ul>
<li>先想办法拿到变量value在内存中的地址</li>
<li>通过Atomic::cmpxchg实现比较替换，其中参数X是即将更新的值，参数e是原内存的值</li>
</ul>
<h2 id="5-CAS缺点"><a href="#5-CAS缺点" class="headerlink" title="5 CAS缺点"></a>5 CAS缺点</h2><p>CAS不加锁，保证一次性，但是需要多次比较</p>
<ul>
<li>循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会无限循环）</li>
<li>只能保证一个共享变量的原子操作<ul>
<li>当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作</li>
<li>但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性</li>
</ul>
</li>
<li>引出来ABA问题？</li>
</ul>
<h2 id="6-ABA问题"><a href="#6-ABA问题" class="headerlink" title="6 ABA问题"></a>6 ABA问题</h2><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><h3 id="7-1-CAS"><a href="#7-1-CAS" class="headerlink" title="7.1 CAS"></a>7.1 CAS</h3><p>CAS是compareAndSwap，比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止</p>
<h3 id="7-2-CAS应用"><a href="#7-2-CAS应用" class="headerlink" title="7.2 CAS应用"></a>7.2 CAS应用</h3><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否者什么都不做</p>
<h1 id="第3章-原子类AtomicInteger的ABA问题"><a href="#第3章-原子类AtomicInteger的ABA问题" class="headerlink" title="第3章 原子类AtomicInteger的ABA问题"></a>第3章 原子类AtomicInteger的ABA问题</h1><h2 id="1-连环套路"><a href="#1-连环套路" class="headerlink" title="1 连环套路"></a>1 连环套路</h2><p>从AtomicInteger引出下面的问题</p>
<p>CAS -&gt; Unsafe -&gt; CAS底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避ABA问题</p>
<h2 id="2-ABA问题是什么"><a href="#2-ABA问题是什么" class="headerlink" title="2 ABA问题是什么"></a>2 ABA问题是什么</h2><p>狸猫换太子</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/3_%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/6_%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98/images/image-20200311212442057.png" alt="image-20200311212442057"></p>
<p>假设现在有两个线程，分别是T1 和 T2，然后T1执行某个操作的时间为10秒，T2执行某个时间的操作是2秒，最开始AB两个线程，分别从主内存中获取A值，但是因为B的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了狸猫换太子。</p>
<p>所以ABA问题就是，在进行获取主内存值的时候，该内存值在我们写入主内存的时候，已经被修改了N次，但是最终又改成原来的值了</p>
<h2 id="3-CAS导致ABA问题"><a href="#3-CAS导致ABA问题" class="headerlink" title="3 CAS导致ABA问题"></a>3 CAS导致ABA问题</h2><p>CAS算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p>
<p>比如说一个线程one从内存位置V中取出A，这时候另外一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功</p>
<p><code>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的</code></p>
<h2 id="4-ABA问题"><a href="#4-ABA问题" class="headerlink" title="4 ABA问题"></a>4 ABA问题</h2><p>CAS只管开头和结尾，也就是头和尾是一样，那就修改成功，中间的这个过程，可能会被人修改过</p>
<h2 id="5-原子引用"><a href="#5-原子引用" class="headerlink" title="5 原子引用"></a>5 原子引用</h2><p>原子引用其实和原子包装类是差不多的概念，就是将一个java类，用原子引用类进行包装起来，那么这个类就具备了原子性</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 原子引用</span>
<span class="hljs-comment"> */</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    String userName;
    <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String userName, <span class="hljs-keyword">int</span> age)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.userName = userName;
        <span class="hljs-keyword">this</span>.age = age;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> userName;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserName</span><span class="hljs-params">(String userName)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.userName = userName;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> age;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.age = age;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +
                <span class="hljs-string">&quot;userName=&#x27;&quot;</span> + userName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, age=&quot;</span> + age +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        User z3 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;z3&quot;</span>, <span class="hljs-number">22</span>);

        User l4 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;l4&quot;</span>, <span class="hljs-number">25</span>);

        <span class="hljs-comment">// 创建原子引用包装类</span>
        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();

        <span class="hljs-comment">// 现在主物理内存的共享变量，为z3</span>
        atomicReference.set(z3);

        <span class="hljs-comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span>
        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());

        <span class="hljs-comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span>
        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());
    &#125;
&#125;</code></pre></div>

<h3 id="5-1-基于原子引用的ABA问题"><a href="#5-1-基于原子引用的ABA问题" class="headerlink" title="5.1 基于原子引用的ABA问题"></a>5.1 基于原子引用的ABA问题</h3><p>我们首先创建了两个线程，然后T1线程，执行一次ABA的操作，T2线程在一秒后修改主内存的值</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * ABA问题的解决，AtomicStampedReference</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABADemo</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 普通的原子引用包装类</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);
            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());

        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p>我们发现，它能够成功的修改，这就是ABA问题</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/3_%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/6_%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98/images/image-20200312154752973.png" alt="image-20200312154752973"></p>
<h2 id="6-解决ABA问题"><a href="#6-解决ABA问题" class="headerlink" title="6 解决ABA问题"></a>6 解决ABA问题</h2><p>新增一种机制，也就是修改版本号，类似于时间戳的概念</p>
<p>T1：  100 1                      2019 2</p>
<p>T2：  100 1     101 2       100  3</p>
<p>如果T1修改的时候，版本号为2，落后于现在的版本号3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路</p>
<h2 id="7-AtomicStampedReference"><a href="#7-AtomicStampedReference" class="headerlink" title="7 AtomicStampedReference"></a>7 AtomicStampedReference</h2><p>时间戳原子引用，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及期望版本号和当前版本号</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * ABA问题的解决，AtomicStampedReference</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABADemo</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 普通的原子引用包装类</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);

    <span class="hljs-comment">// 传递两个值，一个是初始值，一个是初始版本号</span>
    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的产生==========&quot;</span>);

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);
            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());

        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();

        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的解决==========&quot;</span>);

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            <span class="hljs-comment">// 获取版本号</span>
            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);

            <span class="hljs-comment">// 暂停t3一秒钟</span>
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            <span class="hljs-comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span>
            atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());

            atomicStampedReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());

        &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            <span class="hljs-comment">// 获取版本号</span>
            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);

            <span class="hljs-comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span>
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            <span class="hljs-keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>, stamp, stamp+<span class="hljs-number">1</span>);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 修改成功否：&quot;</span> + result + <span class="hljs-string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());


        &#125;, <span class="hljs-string">&quot;t4&quot;</span>).start();

    &#125;
&#125;</code></pre></div>

<p>运行结果为：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/3_%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/6_%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98/images/image-20200312200434776.png" alt="image-20200312200434776"></p>
<p>我们能够发现，线程t3，在进行ABA操作后，版本号变更成了3，而线程t4在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样</p>
<h2 id="8-LongAdder（CAS机制优化）"><a href="#8-LongAdder（CAS机制优化）" class="headerlink" title="8 LongAdder（CAS机制优化）"></a>8 LongAdder（CAS机制优化）</h2><p>LongAdder是java8为我们提供的新的类，跟AtomicLong有相同的效果。是对CAS机制的优化</p>
<div class="code-wrapper"><pre><code class="hljs axapta">LongAdder：
<span class="hljs-comment">//变量声明</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LongAdder <span class="hljs-keyword">count</span> = <span class="hljs-keyword">new</span> LongAdder();
<span class="hljs-comment">//变量操作</span>
<span class="hljs-keyword">count</span>.increment();
<span class="hljs-comment">//变量取值</span>
<span class="hljs-keyword">count</span></code></pre></div>

<h3 id="为什么有了AtomicLong还要新增一个LongAdder呢"><a href="#为什么有了AtomicLong还要新增一个LongAdder呢" class="headerlink" title="为什么有了AtomicLong还要新增一个LongAdder呢"></a>为什么有了AtomicLong还要新增一个LongAdder呢</h3><p>原因是：CAS底层实现是在一个死循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功率很高，否则失败率很高。在失败的时候，这些重复的原子性操作会耗费性能。（不停的<strong>自旋</strong>，进入一个无限重复的循环中）</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/3_%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/6_%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98/images/image-20200429085540554.png" alt="image-20200429085540554"></p>
<p><strong>核心思想：将热点数据分离。</strong></p>
<p>比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。这相当于将AtomicLong的单点的更新压力分担到各个节点上。在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。而在高并发的时候通过分散提高了性能。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;
    add(<span class="hljs-number">1L</span>);
&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;
    Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;
    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;
        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||
            (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||
            !(uncontended = a.cas(v = a.value, v + x)))
            longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);
    &#125;
&#125;</code></pre></div>

<p>但是这个CAS有没有问题呢？肯定是有的。比如说大量的线程同时并发修改一个AtomicInteger，可能有<strong>很多线程会不停的自旋</strong>，进入一个无限重复的循环中。</p>
<p>这些线程不停地获取值，然后发起CAS操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起CAS操作又失败了，再次进入下一个循环。</p>
<p>在大量线程高并发更新AtomicInteger的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。</p>
<p>于是，当当当当，Java 8推出了一个新的类，<strong>LongAdder</strong>，他就是尝试使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能！</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/3_%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/6_%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98/images/image-20200429085141487.png" alt="image-20200429085141487"></p>
<p>在LongAdder的底层实现中，首先有一个base值，刚开始多线程来不停的累加数值，都是对base进行累加的，比如刚开始累加成了base = 5。</p>
<p>接着如果发现并发更新的线程数量过多，在发生竞争的情况下，会有一个Cell数组用于将不同线程的操作离散到不同的节点上去 ==(会根据需要扩容，最大为CPU核）==就会开始施行<strong>分段CAS的机制</strong>，也就是内部会搞一个Cell数组，每个数组是一个数值分段。</p>
<p>这时，让大量的线程分别去对不同Cell内部的value值进行CAS累加操作，这样就把CAS计算压力分散到了不同的Cell分段数值中了！</p>
<p>这样就可以大幅度的降低多线程并发更新同一个数值时出现的无限循环的问题，大幅度提升了多线程并发更新数值的性能和效率！</p>
<p>而且他内部实现了<strong>自动分段迁移的机制</strong>，也就是如果某个Cell的value执行CAS失败了，那么就会自动去找另外一个Cell分段内的value值进行CAS操作。</p>
<p>这样也解决了线程空旋转、自旋不停等待执行CAS操作的问题，让一个线程过来执行CAS时可以尽快的完成这个操作。</p>
<p>最后，如果你要从LongAdder中获取当前累加的总值，就会把base值和所有Cell分段数值加起来返回给你。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/3_%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/6_%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98/images/image-20200429085957778.png" alt="image-20200429085957778"></p>
<p>如上图所示，LongAdder则是内部维护多个Cell变量，每个Cell里面有一个初始值为0的long型变量，在同等并发量的情况下，争夺单个变量的线程会减少，这是变相的减少了争夺共享资源的并发量，另外多个线程在争夺同一个原子变量时候，</p>
<p>如果失败并不是自旋CAS重试，而是尝试获取其他原子变量的锁，最后当获取当前值时候是把所有变量的值累加后再加上base的值返回的。</p>
<p>LongAdder维护了要给延迟初始化的原子性更新数组和一个基值变量base数组的大小保持是2的N次方大小，数组表的下标使用每个线程的hashcode值的掩码表示，数组里面的变量实体是Cell类型。</p>
<p>Cell 类型是Atomic的一个改进，用来减少缓存的争用，对于大多数原子操作字节填充是浪费的，因为原子操作都是无规律的分散在内存中进行的，多个原子性操作彼此之间是没有接触的，但是原子性数组元素彼此相邻存放将能经常共享缓存行，也就是<strong>伪共享</strong>。所以这在性能上是一个提升。（补充：可以看到Cell类用Contended注解修饰，这里主要是解决false sharing(伪共享的问题)，不过个人认为伪共享翻译的不是很好，或者应该是错误的共享，比如两个volatile变量被分配到了同一个缓存行，但是这两个的更新在高并发下会竞争，比如线程A去更新变量a，线程B去更新变量b，但是这两个变量被分配到了同一个缓存行，因此会造成每个线程都去争抢缓存行的所有权，例如A获取了所有权然后执行更新这时由于volatile的语义会造成其刷新到主存，但是由于变量b也被缓存到同一个缓存行，因此就会造成cache miss，这样就会造成极大的性能损失）<br><strong>LongAdder的add操作图</strong></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/3_%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/6_%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98/images/image-20200429090249633.png" alt="image-20200429090249633"></p>
<p>可以看到，只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。<br>如果Cell[]数组未初始化，会调用父类的longAccumelate去初始化Cell[]，如果Cell[]已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对Cell[]扩容了。<br><strong>另外由于Cells占用内存是相对比较大的，所以一开始并不创建，而是在需要时候再创建，也就是惰性加载，当一开始没有空间时候，所有的更新都是操作base变量。</strong></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/3_%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/6_%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98/images/image-20200429090556928.png" alt="image-20200429090556928"></p>
<p>如上图代码：<br>例如32、64位操作系统的缓存行大小不一样，因此JAVA8中就增加了一个注<code>@sun.misc.Contended</code>解用于解决这个问题,由JVM去插入这些变量，<a href="http://xn--openjdk-hc5k25at0ntqhnpa7548b.java.net/jeps/142">具体可以参考openjdk.java.net/jeps/142</a> ，但是通常来说对象是不规则的分配到内存中的，但是数组由于是连续的内存，因此可能会共享缓存行，因此这里加一个Contended注解以防cells数组发生伪共享的情况。</p>
<p>为了降低高并发下多线程对一个变量CAS争夺失败后大量线程会自旋而造成降低并发性能问题，LongAdder内部通过根据并发请求量来维护多个Cell元素(一个动态的Cell数组)来分担对单个变量进行争夺资源。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/3_%E8%B0%88%E8%B0%88%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84ABA%E9%97%AE%E9%A2%98/6_%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98/images/image-20200429090713078.png" alt="image-20200429090713078"></p>
<p>可以看到LongAdder继承自Striped64类，Striped64内部维护着三个变量，LongAdder的真实值其实就是base的值与Cell数组里面所有Cell元素值的累加，base是个基础值，默认是0，cellBusy用来实现自旋锁，当创建Cell元素或者扩容Cell数组时候用来进行线程间的同步。</p>
<p>在无竞争下直接更新base，类似AtomicLong高并发下，会将每个线程的操作hash到不同的cells数组中，从而将AtomicLong中更新一个value的行为优化之后，分散到多个value中<br>从而降低更新热点，而需要得到当前值的时候，直接 将所有cell中的value与base相加即可，但是跟AtomicLong(compare and change -&gt; xadd)的CAS不同，incrementAndGet操作及其变种可以返回更新后的值，而LongAdder返回的是void。</p>
<p>由于Cell相对来说比较占内存，因此这里采用懒加载的方式，在无竞争的情况下直接更新base域，在第一次发生竞争的时候(CAS失败)就会创建一个大小为2的cells数组，每次扩容都是加倍，只到达到CPU核数。同时我们知道扩容数组等行为需要只能有一个线程同时执行，因此需要一个锁，这里通过CAS更新cellsBusy来实现一个简单的spin lock。</p>
<p>数组访问索引是通过Thread里的threadLocalRandomProbe域取模实现的，这个域是ThreadLocalRandom更新的，cells的数组大小被限制为CPU的核数，因为即使有超过核数个线程去更新，但是每个线程也只会和一个CPU绑定，更新的时候顶多会有cpu核数个线程，因此我们只需要通过hash将不同线程的更新行为离散到不同的slot即可。<br>我们知道线程、线程池会被关闭或销毁，这个时候可能这个线程之前占用的slot就会变成没人用的，但我们也不能清除掉，因为一般web应用都是长时间运行的，线程通常也会动态创建、销毁，很可能一段时间后又会被其他线程占用，而对于短时间运行的，例如单元测试，清除掉有啥意义呢？</p>
<h1 id="第4章-Collection线程不安全的举例"><a href="#第4章-Collection线程不安全的举例" class="headerlink" title="第4章 Collection线程不安全的举例"></a>第4章 Collection线程不安全的举例</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>1、当我们执行下面语句的时候，底层进行了什么操作</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</code></pre></div>

<p>底层创建了一个空的数组，伴随着初始值为10</p>
<p>当执行add方法后，如果超过了10，那么会进行扩容，扩容的大小为原值的一半，也就是5个，使用下列方法扩容</p>
<div class="code-wrapper"><pre><code class="hljs java">Arrays.copyOf(elementData, netCapacity)</code></pre></div>

<h2 id="2-单线程环境下"><a href="#2-单线程环境下" class="headerlink" title="2 单线程环境下"></a>2 单线程环境下</h2><p>单线程环境的ArrayList是不会有问题的</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        list.add(<span class="hljs-string">&quot;a&quot;</span>);
        list.add(<span class="hljs-string">&quot;b&quot;</span>);
        list.add(<span class="hljs-string">&quot;c&quot;</span>);

        <span class="hljs-keyword">for</span>(String element : list) &#123;
            System.out.println(element);
        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="3-多线程环境"><a href="#3-多线程环境" class="headerlink" title="3 多线程环境"></a>3 多线程环境</h2><p>为什么ArrayList是线程不安全的？因为在进行写操作的时候，方法上为了保证并发性，是没有添加synchronized修饰，所以并发写的时候，就会出现问题</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/4_ArrayList%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B/images/image-20200312202720715.png" alt="image-20200312202720715"></p>
<p>当我们同时启动30个线程去操作List的时候</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 集合类线程不安全举例</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));
                System.out.println(list);
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>这个时候出现了错误，也就是java.util.ConcurrentModificationException</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/4_ArrayList%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B/images/image-20200312205142763.png" alt="image-20200312205142763"></p>
<p>这个异常是 并发修改的异常</p>
<h2 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5 解决方案"></a>5 解决方案</h2><h3 id="5-1-方案一：Vector"><a href="#5-1-方案一：Vector" class="headerlink" title="5.1 方案一：Vector"></a>5.1 方案一：Vector</h3><p>第一种方法，就是不用ArrayList这种不安全的List实现类，而采用Vector，线程安全的</p>
<p>关于Vector如何实现线程安全的，而是在方法上加了锁，即synchronized</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/4_ArrayList%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B/images/image-20200312210401865.png" alt="image-20200312210401865"></p>
<p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，导致并发性基于下降</p>
<h3 id="5-2-方案二：Collections-synchronized"><a href="#5-2-方案二：Collections-synchronized" class="headerlink" title="5.2 方案二：Collections.synchronized()"></a>5.2 方案二：Collections.synchronized()</h3><div class="code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());</code></pre></div>

<p>采用Collections集合工具类，在ArrayList外面包装一层 同步 机制</p>
<h3 id="5-3-方案三：采用JUC里面的方法"><a href="#5-3-方案三：采用JUC里面的方法" class="headerlink" title="5.3 方案三：采用JUC里面的方法"></a>5.3 方案三：采用JUC里面的方法</h3><p>CopyOnWriteArrayList：写时复制，主要是一种读写分离的思想</p>
<p>写时复制，CopyOnWrite容器即写时复制的容器，往一个容器中添加元素的时候，不直接往当前容器Object[]添加，而是先将Object[]进行copy，复制出一个新的容器object[] newElements，然后新的容器Object[] newElements里添加原始，添加元素完后，在将原容器的引用指向新的容器 setArray(newElements)；这样做的好处是可以对copyOnWrite容器进行并发的读 ，而不需要加锁，因为当前容器不需要添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p>
<p>就是写的时候，把ArrayList扩容一个出来，然后把值填写上去，在通知其他的线程，ArrayList的引用指向扩容后的</p>
<p>查看底层add方法源码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        Object[] elements = getArray();
        <span class="hljs-keyword">int</span> len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);
        newElements[len] = e;
        setArray(newElements);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;</code></pre></div>

<p>首先需要加锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
lock.lock();</code></pre></div>

<p>然后在末尾扩容一个单位</p>
<div class="code-wrapper"><pre><code class="hljs java">Object[] elements = getArray();
<span class="hljs-keyword">int</span> len = elements.length;
Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);</code></pre></div>

<p>然后在把扩容后的空间，填写上需要add的内容</p>
<div class="code-wrapper"><pre><code class="hljs java">newElements[len] = e;</code></pre></div>

<p>最后把内容set到Array中</p>
<h2 id="6-HashSet线程不安全"><a href="#6-HashSet线程不安全" class="headerlink" title="6 HashSet线程不安全"></a>6 HashSet线程不安全</h2><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>底层还是使用CopyOnWriteArrayList进行实例化</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/4_ArrayList%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B/images/image-20200312221602095.png" alt="image-20200312221602095"></p>
<h3 id="HashSet底层结构"><a href="#HashSet底层结构" class="headerlink" title="HashSet底层结构"></a>HashSet底层结构</h3><p>同理HashSet的底层结构就是HashMap</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/4_ArrayList%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BE%E4%BE%8B/images/image-20200312221735178.png" alt="image-20200312221735178"></p>
<p>但是为什么我调用 HashSet.add()的方法，只需要传递一个元素，而HashMap是需要传递key-value键值对？</p>
<p>首先我们查看hashSet的add方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;
	<span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;
&#125;</code></pre></div>

<p>我们能发现但我们调用add的时候，存储一个值进入map中，只是作为key进行存储，而value存储的是一个Object类型的常量，也就是说HashSet只关心key，而不关心value</p>
<h2 id="7-HashMap线程不安全"><a href="#7-HashMap线程不安全" class="headerlink" title="7 HashMap线程不安全"></a>7 HashMap线程不安全</h2><p>同理HashMap在多线程环境下，也是不安全的</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));
            System.out.println(map);
        &#125;, String.valueOf(i)).start();
    &#125;
&#125;</code></pre></div>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>1、使用Collections.synchronizedMap(new HashMap&lt;&gt;());</p>
<p>2、使用 ConcurrentHashMap</p>
<div class="code-wrapper"><pre><code class="hljs java">Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();</code></pre></div>

<h1 id="第5章-值传递和引用传递"><a href="#第5章-值传递和引用传递" class="headerlink" title="第5章 值传递和引用传递"></a>第5章 值传递和引用传递</h1><h2 id="1-举例"><a href="#1-举例" class="headerlink" title="1 举例"></a>1 举例</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 值传递和引用传递</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String personName;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String personName)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.personName = personName;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferValueDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;
        age = <span class="hljs-number">30</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue2</span><span class="hljs-params">(Person person)</span> </span>&#123;
        person.setPersonName(<span class="hljs-string">&quot;XXXX&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue3</span><span class="hljs-params">(String str)</span> </span>&#123;
        str = <span class="hljs-string">&quot;XXX&quot;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        TransferValueDemo test = <span class="hljs-keyword">new</span> TransferValueDemo();

        <span class="hljs-comment">// 定义基本数据类型</span>
        <span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;
        test.changeValue1(age);
        System.out.println(<span class="hljs-string">&quot;age ----&quot;</span> + age);

        <span class="hljs-comment">// 实例化person类</span>
        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;abc&quot;</span>);
        test.changeValue2(person);
        System.out.println(<span class="hljs-string">&quot;personName-----&quot;</span> + person.getPersonName());

        <span class="hljs-comment">// String</span>
        String str = <span class="hljs-string">&quot;abc&quot;</span>;
        test.changeValue3(str);
        System.out.println(<span class="hljs-string">&quot;string-----&quot;</span> + str);

    &#125;
&#125;</code></pre></div>

<p>最后输出结果</p>
<div class="code-wrapper"><pre><code class="hljs shell">age ----20
personName-----XXXX
string-----abc</code></pre></div>

<h2 id="2-changeValue1的执行过程"><a href="#2-changeValue1的执行过程" class="headerlink" title="2 changeValue1的执行过程"></a>2 changeValue1的执行过程</h2><p>八种基本数据类型，在栈里面分配内存，属于值传递</p>
<p><code>栈管运行，堆管存储</code></p>
<p>当们执行 changeValue1的时候，因为int是基本数据类型，所以传递的是int = 20这个值，相当于传递的是一个副本，main方法里面的age并没有改变，因此输出的结果 age还是20，属于值传递</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/5_TransferValue%E6%98%AF%E4%BB%80%E4%B9%88/images/image-20200314185317851.png" alt="image-20200314185317851"></p>
<h2 id="3-changeValue2的执行过程"><a href="#3-changeValue2的执行过程" class="headerlink" title="3 changeValue2的执行过程"></a>3 changeValue2的执行过程</h2><p>因为Person是属于对象，传递的是内存地址，当执行changeValue2的时候，会改变内存中的Person的值，属于引用传递，两个指针都是指向同一个地址</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/5_TransferValue%E6%98%AF%E4%BB%80%E4%B9%88/images/image-20200314185528034.png" alt="image-20200314185528034"></p>
<h2 id="4-changeValue3的执行过程"><a href="#4-changeValue3的执行过程" class="headerlink" title="4 changeValue3的执行过程"></a>4 changeValue3的执行过程</h2><p>String不属于基本数据类型，但是为什么执行完成后，还是abc呢？</p>
<p>这是因为String的特殊性，当我们执行String str = “abc”的时候，它会把 <code>abc</code> 放入常量池中</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/5_TransferValue%E6%98%AF%E4%BB%80%E4%B9%88/images/image-20200314190021466.png" alt="image-20200314190021466"></p>
<p>当我们执行changeValue3的时候，会重新新建一个xxx，并没有销毁abc，然后指向xxx，然后最后我们输出的是main中的引用，还是指向的abc，因此最后输出结果还是abc</p>
<h1 id="第6章-Lock"><a href="#第6章-Lock" class="headerlink" title="第6章 Lock"></a>第6章 Lock</h1><h2 id="1-Java锁之公平锁和非公平锁"><a href="#1-Java锁之公平锁和非公平锁" class="headerlink" title="1 Java锁之公平锁和非公平锁"></a>1 Java锁之公平锁和非公平锁</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列</p>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）</p>
<h3 id="1-2-如何创建"><a href="#1-2-如何创建" class="headerlink" title="1.2 如何创建"></a>1.2 如何创建</h3><p>并发包中ReentrantLock的创建可以指定析构函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span>
<span class="hljs-comment">*/</span>
Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);</code></pre></div>

<h3 id="1-3-两者区别"><a href="#1-3-两者区别" class="headerlink" title="1.3 两者区别"></a>1.3 两者区别</h3><p><strong>公平锁</strong>：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后安装FIFO的规则从队列中取到自己</p>
<p><strong>非公平锁：</strong> 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p>
<h3 id="1-4-题外话"><a href="#1-4-题外话" class="headerlink" title="1.4 题外话"></a>1.4 题外话</h3><p>Java ReenttrantLock通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于吞吐量比公平锁大，<code>对于synchronized而言，也是一种非公平锁</code></p>
<h2 id="2-可重入锁和递归锁ReentrantLock"><a href="#2-可重入锁和递归锁ReentrantLock" class="headerlink" title="2 可重入锁和递归锁ReentrantLock"></a>2 可重入锁和递归锁ReentrantLock</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>可重入锁就是递归锁</p>
<p>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</p>
<p>也就是说：<code>线程可以进入任何一个它已经拥有的锁所同步的代码块</code></p>
<p>ReentrantLock / Synchronized 就是一个典型的可重入锁</p>
<h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><p>可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是同一把锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;
	method2();
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;

&#125;</code></pre></div>

<p>也就是说我们只需要进入method1后，那么它也能直接进入method2方法，因为他们所拥有的锁，是同一把。</p>
<h3 id="2-3-作用"><a href="#2-3-作用" class="headerlink" title="2.3 作用"></a>2.3 作用</h3><p>可重入锁的最大作用就是避免死锁</p>
<h3 id="2-4-可重入锁验证"><a href="#2-4-可重入锁验证" class="headerlink" title="2.4 可重入锁验证"></a>2.4 可重入锁验证</h3><h4 id="证明Synchronized"><a href="#证明Synchronized" class="headerlink" title="证明Synchronized"></a>证明Synchronized</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 可重入锁（也叫递归锁）</span>
<span class="hljs-comment"> * 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 也就是说：`线程可以进入任何一个它已经拥有的锁所同步的代码块`</span>
<span class="hljs-comment"> */</span>

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 发送短信</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSMS</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t invoked sendSMS()&quot;</span>);

        <span class="hljs-comment">// 在同步方法中，调用另外一个同步方法</span>
        sendEmail();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 发邮件</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendEmail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        System.out.println(Thread.currentThread().getId() + <span class="hljs-string">&quot;\t invoked sendEmail()&quot;</span>);
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Phone phone = <span class="hljs-keyword">new</span> Phone();

        <span class="hljs-comment">// 两个线程操作资源列</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                phone.sendSMS();
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                phone.sendSMS();
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p>在这里，我们编写了一个资源类phone，拥有两个加了synchronized的同步方法，分别是sendSMS 和 sendEmail，我们在sendSMS方法中，调用sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：</p>
<div class="code-wrapper"><pre><code class="hljs shell">t1	 invoked sendSMS()
t1	 invoked sendEmail()
t2	 invoked sendSMS()
t2	 invoked sendEmail()</code></pre></div>

<p>这就说明当 t1 线程进入sendSMS的时候，拥有了一把锁，同时t2线程无法进入，直到t1线程拿着锁，执行了sendEmail 方法后，才释放锁，这样t2才能够进入</p>
<div class="code-wrapper"><pre><code class="hljs shell">t1	 invoked sendSMS()      t1线程在外层方法获取锁的时候
t1	 invoked sendEmail()    t1在进入内层方法会自动获取锁

t2	 invoked sendSMS()      t2线程在外层方法获取锁的时候
t2	 invoked sendEmail()    t2在进入内层方法会自动获取锁</code></pre></div>

<h4 id="证明ReentrantLock"><a href="#证明ReentrantLock" class="headerlink" title="证明ReentrantLock"></a>证明ReentrantLock</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;

    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * set进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);
            setLock();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLock</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t set Lock&quot;</span>);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        getLock();
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Phone phone = <span class="hljs-keyword">new</span> Phone();

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 因为Phone实现了Runnable接口</span>
<span class="hljs-comment">         */</span>
        Thread t3 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t3&quot;</span>);
        Thread t4 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t4&quot;</span>);
        t3.start();
        t4.start();
    &#125;
&#125;
</code></pre></div>

<p>现在我们使用ReentrantLock进行验证，首先资源类实现了Runnable接口，重写Run方法，里面调用get方法，get方法在进入的时候，就加了锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);
        setLock();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;</code></pre></div>

<p>然后在方法里面，又调用另外一个加了锁的setLock方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLock</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t set Lock&quot;</span>);
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;</code></pre></div>

<p>最后输出结果我们能发现，结果和加synchronized方法是一致的，都是在外层的方法获取锁之后，线程能够直接进入里层</p>
<div class="code-wrapper"><pre><code class="hljs shell">t3	 get Lock
t3	 set Lock
t4	 get Lock
t4	 set Lock</code></pre></div>

<p><strong>当我们在getLock方法加两把锁会是什么情况呢？</strong>  (阿里面试)</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);
        setLock();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
        lock.unlock();
    &#125;
&#125;</code></pre></div>

<p>最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是同一把锁，也就是说用同一个钥匙都能够打开</p>
<p><strong>当我们在getLock方法加两把锁，但是只解一把锁会出现什么情况呢？</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);
        setLock();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
        lock.unlock();
    &#125;
&#125;</code></pre></div>
<p>得到结果</p>
<div class="code-wrapper"><pre><code class="hljs pgsql">t3	 <span class="hljs-keyword">get</span> <span class="hljs-keyword">Lock</span>
t3	 <span class="hljs-keyword">set</span> <span class="hljs-keyword">Lock</span></code></pre></div>

<p>也就是说程序直接卡死，线程不能出来，也就说明我们申请几把锁，最后需要解除几把锁</p>
<p><strong>当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢？</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);
        setLock();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
        lock.unlock();
    &#125;
&#125;</code></pre></div>

<p>这个时候，运行程序会直接报错</p>
<div class="code-wrapper"><pre><code class="hljs shell">t3	 get Lock
t3	 set Lock
t4	 get Lock
t4	 set Lock
Exception in thread &quot;t3&quot; Exception in thread &quot;t4&quot; java.lang.IllegalMonitorStateException
	at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)
	at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)
	at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)
	at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)
	at java.lang.Thread.run(Thread.java:745)
java.lang.IllegalMonitorStateException
	at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)
	at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)
	at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)
	at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)
	at java.lang.Thread.run(Thread.java:745)</code></pre></div>

<h2 id="3-Java锁之自旋锁"><a href="#3-Java锁之自旋锁" class="headerlink" title="3 Java锁之自旋锁"></a>3 Java锁之自旋锁</h2><p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>
<p>原来提到的比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/6_Java%E7%9A%84%E9%94%81/Java%E9%94%81%E4%B9%8B%E8%87%AA%E6%97%8B%E9%94%81/images/image-20200315154143781.png" alt="image-20200315154143781"></p>
<h3 id="3-1-优缺点"><a href="#3-1-优缺点" class="headerlink" title="3.1 优缺点"></a>3.1 优缺点</h3><p>优点：循环比较获取直到成功为止，没有类似于wait的阻塞</p>
<p>缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源</p>
<h3 id="3-2-手写自旋锁"><a href="#3-2-手写自旋锁" class="headerlink" title="3.2 手写自旋锁"></a>3.2 手写自旋锁</h3><p>通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到</p>
<div class="code-wrapper"><pre><code class="hljs java">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 手写一个自旋锁</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 循环比较获取直到成功为止，没有类似于wait的阻塞</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLockDemo</span> </span>&#123;

    <span class="hljs-comment">// 现在的泛型装的是Thread，原子引用线程</span>
    AtomicReference&lt;Thread&gt;  atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myLock</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 获取当前进来的线程</span>
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in &quot;</span>);

        <span class="hljs-comment">// 开始自旋，期望值是null，更新值是当前线程，如果是null，则更新为当前线程，否者自旋</span>
        <span class="hljs-keyword">while</span>(!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>, thread)) &#123;

        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 解锁</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myUnLock</span><span class="hljs-params">()</span> </span>&#123;

        <span class="hljs-comment">// 获取当前进来的线程</span>
        Thread thread = Thread.currentThread();

        <span class="hljs-comment">// 自己用完了后，把atomicReference变成null</span>
        atomicReference.compareAndSet(thread, <span class="hljs-keyword">null</span>);

        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t invoked myUnlock()&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        SpinLockDemo spinLockDemo = <span class="hljs-keyword">new</span> SpinLockDemo();

        <span class="hljs-comment">// 启动t1线程，开始操作</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            <span class="hljs-comment">// 开始占有锁</span>
            spinLockDemo.myLock();


            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            <span class="hljs-comment">// 开始释放锁</span>
            spinLockDemo.myUnLock();

        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();


        <span class="hljs-comment">// 让main线程暂停1秒，使得t1线程，先执行</span>
        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        <span class="hljs-comment">// 1秒后，启动t2线程，开始占用这个锁</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            <span class="hljs-comment">// 开始占有锁</span>
            spinLockDemo.myLock();
            <span class="hljs-comment">// 开始释放锁</span>
            spinLockDemo.myUnLock();

        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();

    &#125;
&#125;</code></pre></div>

<p>最后输出结果</p>
<div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">t1</span> <span class="hljs-variable">come</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span>
.....一秒后.....
<span class="hljs-variable">t2</span> <span class="hljs-variable">come</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span>
.....五秒后.....
<span class="hljs-variable">t1</span> <span class="hljs-variable">invoked</span> <span class="hljs-function"><span class="hljs-title">myUnlock</span>()</span>
<span class="hljs-variable">t2</span> <span class="hljs-variable">invoked</span> <span class="hljs-function"><span class="hljs-title">myUnlock</span>()</span></code></pre></div>

<p>首先输出的是 t1     come in </p>
<p>然后1秒后，t2线程启动，发现锁被t1占有，所有不断的执行 compareAndSet方法，来进行比较，直到t1释放锁后，也就是5秒后，t2成功获取到锁，然后释放</p>
<h2 id="4-独占锁（写锁）-共享锁（读锁）-互斥锁"><a href="#4-独占锁（写锁）-共享锁（读锁）-互斥锁" class="headerlink" title="4 独占锁（写锁） / 共享锁（读锁） / 互斥锁"></a>4 独占锁（写锁） / 共享锁（读锁） / 互斥锁</h2><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁</p>
<p>共享锁：指该锁可以被多个线程锁持有</p>
<p>对ReentrantReadWriteLock其读锁是共享，其写锁是独占</p>
<p>写的时候只能一个人写，但是读的时候，可以多个人同时读</p>
<h3 id="4-2-为什么会有写锁和读锁"><a href="#4-2-为什么会有写锁和读锁" class="headerlink" title="4.2 为什么会有写锁和读锁"></a>4.2 为什么会有写锁和读锁</h3><p>原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读</p>
<div class="code-wrapper"><pre><code class="hljs plain">多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</code></pre></div>

<p>读-读：能共存</p>
<p>读-写：不能共存</p>
<p>写-写：不能共存</p>
<h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><p>实现一个读写缓存的操作，假设开始没有加锁的时候，会出现什么情况</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 读写锁</span>
<span class="hljs-comment"> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span>
<span class="hljs-comment"> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-comment">// private Lock lock = null;</span>

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 定义写操作</span>
<span class="hljs-comment">     * 满足：原子 + 独占</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        Object value = map.get(key);
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);
    &#125;


&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();
        <span class="hljs-comment">// 线程操作资源类，5个线程写</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            <span class="hljs-comment">// lambda表达式内部必须是final</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);
            &#125;, String.valueOf(i)).start();
        &#125;
        <span class="hljs-comment">// 线程操作资源类， 5个线程读</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            <span class="hljs-comment">// lambda表达式内部必须是final</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>我们分别创建5个线程写入缓存</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 线程操作资源类，5个线程写</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
    <span class="hljs-comment">// lambda表达式内部必须是final</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>5个线程读取缓存，</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 线程操作资源类， 5个线程读</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
    <span class="hljs-comment">// lambda表达式内部必须是final</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>最后运行结果：</p>
<div class="code-wrapper"><pre><code class="hljs 1c"><span class="hljs-number">0</span>	 正在写入：<span class="hljs-number">0</span>
<span class="hljs-number">4</span>	 正在写入：<span class="hljs-number">4</span>
<span class="hljs-number">3</span>	 正在写入：<span class="hljs-number">3</span>
<span class="hljs-number">1</span>	 正在写入：<span class="hljs-number">1</span>
<span class="hljs-number">2</span>	 正在写入：<span class="hljs-number">2</span>
<span class="hljs-number">0</span>	 正在读取:
<span class="hljs-number">1</span>	 正在读取:
<span class="hljs-number">2</span>	 正在读取:
<span class="hljs-number">3</span>	 正在读取:
<span class="hljs-number">4</span>	 正在读取:
<span class="hljs-number">2</span>	 写入完成
<span class="hljs-number">4</span>	 写入完成
<span class="hljs-number">4</span>	 读取完成：<span class="hljs-literal">null</span>
<span class="hljs-number">0</span>	 写入完成
<span class="hljs-number">3</span>	 读取完成：<span class="hljs-literal">null</span>
<span class="hljs-number">0</span>	 读取完成：<span class="hljs-literal">null</span>
<span class="hljs-number">1</span>	 写入完成
<span class="hljs-number">3</span>	 写入完成
<span class="hljs-number">1</span>	 读取完成：<span class="hljs-literal">null</span>
<span class="hljs-number">2</span>	 读取完成：<span class="hljs-literal">null</span></code></pre></div>

<p>我们可以看到，在写入的时候，写操作都没其它线程打断了，这就造成了，还没写完，其它线程又开始写，这样就造成数据不一致</p>
<h3 id="4-4-解决方法"><a href="#4-4-解决方法" class="headerlink" title="4.4 解决方法"></a>4.4 解决方法</h3><p>上面的代码是没有加锁的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到读写锁来解决了</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 创建一个读写锁</span>
<span class="hljs-comment">* 它是一个读写融为一体的锁，在使用的时候，需要转换</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">private</span> ReentrantReadWriteLock rwLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();</code></pre></div>

<p>当我们在进行写操作的时候，就需要转换成写锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个写锁</span>
rwLock.writeLock().lock();

<span class="hljs-comment">// 写锁 释放</span>
rwLock.writeLock().unlock();</code></pre></div>

<p>当们在进行读操作的时候，在转换成读锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个读锁</span>
rwLock.readLock().lock();

<span class="hljs-comment">// 读锁 释放</span>
rwLock.readLock().unlock();</code></pre></div>

<p>这里的读锁和写锁的区别在于，写锁一次只能一个线程进入，执行写操作，而读锁是多个线程能够同时进入，进行读取的操作</p>
<p>完整代码：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 读写锁</span>
<span class="hljs-comment"> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span>
<span class="hljs-comment"> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 缓存中的东西，必须保持可见性，因此使用volatile修饰</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 创建一个读写锁</span>
<span class="hljs-comment">     * 它是一个读写融为一体的锁，在使用的时候，需要转换</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> ReentrantReadWriteLock rwLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 定义写操作</span>
<span class="hljs-comment">     * 满足：原子 + 独占</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;

        <span class="hljs-comment">// 创建一个写锁</span>
        rwLock.writeLock().lock();

        <span class="hljs-keyword">try</span> &#123;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);

            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            map.put(key, value);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// 写锁 释放</span>
            rwLock.writeLock().unlock();
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 获取</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;

        <span class="hljs-comment">// 读锁</span>
        rwLock.readLock().lock();
        <span class="hljs-keyword">try</span> &#123;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);

            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            Object value = map.get(key);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// 读锁释放</span>
            rwLock.readLock().unlock();
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 清空缓存</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;
        map.clear();
    &#125;


&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();

        <span class="hljs-comment">// 线程操作资源类，5个线程写</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;
            <span class="hljs-comment">// lambda表达式内部必须是final</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);
            &#125;, String.valueOf(i)).start();
        &#125;

        <span class="hljs-comment">// 线程操作资源类， 5个线程读</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;
            <span class="hljs-comment">// lambda表达式内部必须是final</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>运行结果：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>	 正在写入：<span class="hljs-number">1</span>
<span class="hljs-attribute">1</span>	 写入完成
<span class="hljs-attribute">2</span>	 正在写入：<span class="hljs-number">2</span>
<span class="hljs-attribute">2</span>	 写入完成
<span class="hljs-attribute">3</span>	 正在写入：<span class="hljs-number">3</span>
<span class="hljs-attribute">3</span>	 写入完成
<span class="hljs-attribute">4</span>	 正在写入：<span class="hljs-number">4</span>
<span class="hljs-attribute">4</span>	 写入完成
<span class="hljs-attribute">5</span>	 正在写入：<span class="hljs-number">5</span>
<span class="hljs-attribute">5</span>	 写入完成
<span class="hljs-attribute">2</span>	 正在读取:
<span class="hljs-attribute">3</span>	 正在读取:
<span class="hljs-attribute">1</span>	 正在读取:
<span class="hljs-attribute">4</span>	 正在读取:
<span class="hljs-attribute">5</span>	 正在读取:
<span class="hljs-attribute">2</span>	 读取完成：<span class="hljs-number">2</span>
<span class="hljs-attribute">1</span>	 读取完成：<span class="hljs-number">1</span>
<span class="hljs-attribute">4</span>	 读取完成：<span class="hljs-number">4</span>
<span class="hljs-attribute">3</span>	 读取完成：<span class="hljs-number">3</span>
<span class="hljs-attribute">5</span>	 读取完成：<span class="hljs-number">5</span></code></pre></div>

<p>从运行结果我们可以看出，写入操作是一个一个线程进行执行的，并且中间不会被打断，而读操作的时候，是同时5个线程进入，然后并发读取操作</p>
<h2 id="5-为什么Synchronized无法禁止指令重排，却能保证有序性"><a href="#5-为什么Synchronized无法禁止指令重排，却能保证有序性" class="headerlink" title="5 为什么Synchronized无法禁止指令重排，却能保证有序性"></a>5 为什么Synchronized无法禁止指令重排，却能保证有序性</h2><h3 id="5-1-前言"><a href="#5-1-前言" class="headerlink" title="5.1 前言"></a>5.1 前言</h3><p>首先我们要分析下这道题，这简单的一个问题，其实里面还是包含了很多信息的，要想回答好这个问题，面试者至少要知道一下概念：</p>
<ul>
<li>Java内存模型</li>
<li>并发编程有序性问题</li>
<li>指令重排</li>
<li>synchronized锁</li>
<li>可重入锁</li>
<li>排它锁</li>
<li>as-if-serial语义</li>
<li>单线程&amp;多线程</li>
</ul>
<h3 id="5-2-标准解答"><a href="#5-2-标准解答" class="headerlink" title="5.2 标准解答"></a>5.2 标准解答</h3><p>为了进一步提升计算机各方面能力，在硬件层面做了很多优化，如处理器优化和指令重排等，但是这些技术的引入就会导致有序性问题。</p>
<blockquote>
<p>先解释什么是有序性问题，也知道是什么原因导致的有序性问题</p>
</blockquote>
<p>我们也知道，最好的解决有序性问题的办法，就是禁止处理器优化和指令重排，就像volatile中使用内存屏障一样。</p>
<blockquote>
<p>表明你知道啥是指令重排，也知道他的实现原理</p>
</blockquote>
<p>但是，虽然很多硬件都会为了优化做一些重排，但是在Java中，不管怎么排序，都不能影响单线程程序的执行结果。这就是as-if-serial语义，所有硬件优化的前提都是必须遵守as-if-serial语义。</p>
<p>as-if-serial语义把<strong>单线程</strong>程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会 干扰他们，也无需担心内存可见性问题。</p>
<blockquote>
<p>重点！解释下什么是as-if-serial语义，因为这是这道题的第一个关键词，答上来就对了一半了</p>
</blockquote>
<p>再说下synchronized，他是Java提供的锁，可以通过他对Java中的对象加锁，并且他是一种排他的、可重入的锁。</p>
<p>所以，当某个线程执行到一段被synchronized修饰的代码之前，会先进行加锁，执行完之后再进行解锁。在加锁之后，解锁之前，其他线程是无法再次获得锁的，只有这条加锁线程可以重复获得该锁。</p>
<blockquote>
<p>介绍synchronized的原理，这是本题的第二个关键点，到这里基本就可以拿满分了。</p>
</blockquote>
<p>synchronized通过排他锁的方式就保证了同一时间内，被synchronized修饰的代码是单线程执行的。所以呢，这就满足了as-if-serial语义的一个关键前提，那就是<strong>单线程</strong>，因为有as-if-serial语义保证，单线程的有序性就天然存在了。</p>
<h1 id="第7章-计时器和信号量"><a href="#第7章-计时器和信号量" class="headerlink" title="第7章 计时器和信号量"></a>第7章 计时器和信号量</h1><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1 CountDownLatch"></a>1 CountDownLatch</h2><h3 id="1-1-概念-1"><a href="#1-1-概念-1" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p>
<p>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程就会被阻塞。其它线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会被阻塞），当计数器的值变成零时，因调用await方法被阻塞的线程会被唤醒，继续执行</p>
<h3 id="1-2-场景"><a href="#1-2-场景" class="headerlink" title="1.2 场景"></a>1.2 场景</h3><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p>
<h3 id="1-3-解决方案"><a href="#1-3-解决方案" class="headerlink" title="1.3 解决方案"></a>1.3 解决方案</h3><p>这个时候就用到了CountDownLatch，计数器了。我们一共创建6个线程，然后计数器的值也设置成6</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 计数器</span>
CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);</code></pre></div>

<p>然后每次学生线程执行完，就让计数器的值减1</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 上完自习，离开教室&quot;</span>);
        countDownLatch.countDown();
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是一道墙，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p>
<div class="code-wrapper"><pre><code class="hljs java">countDownLatch.await();

System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 班长最后关门&quot;</span>);</code></pre></div>

<p>不加CountDownLatch的执行结果，我们发现main线程提前已经执行完成了</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>	 上完自习，离开教室
<span class="hljs-number">0</span>	 上完自习，离开教室
<span class="hljs-selector-tag">main</span>	 班长最后关门
<span class="hljs-number">2</span>	 上完自习，离开教室
<span class="hljs-number">3</span>	 上完自习，离开教室
<span class="hljs-number">4</span>	 上完自习，离开教室
<span class="hljs-number">5</span>	 上完自习，离开教室
<span class="hljs-number">6</span>	 上完自习，离开教室</code></pre></div>

<p>引入CountDownLatch后的执行结果，我们能够控制住main方法的执行，这样能够保证前提任务的执行</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">0</span>	 上完自习，离开教室
<span class="hljs-number">2</span>	 上完自习，离开教室
<span class="hljs-number">4</span>	 上完自习，离开教室
<span class="hljs-number">1</span>	 上完自习，离开教室
<span class="hljs-number">5</span>	 上完自习，离开教室
<span class="hljs-number">6</span>	 上完自习，离开教室
<span class="hljs-number">3</span>	 上完自习，离开教室
<span class="hljs-selector-tag">main</span>	 班长最后关门</code></pre></div>

<h3 id="1-4-完整代码"><a href="#1-4-完整代码" class="headerlink" title="1.4 完整代码"></a>1.4 完整代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.moxi.interview.study.thread;

<span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;

        <span class="hljs-comment">// 计数器</span>
        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 上完自习，离开教室&quot;</span>);
                countDownLatch.countDown();
            &#125;, String.valueOf(i)).start();
        &#125;

        countDownLatch.await();

        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 班长最后关门&quot;</span>);
    &#125;
&#125;</code></pre></div>

<h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2 CyclicBarrier"></a>2 CyclicBarrier</h2><h3 id="2-1-概念-1"><a href="#2-1-概念-1" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>和CountDownLatch相反，需要集齐七颗龙珠，召唤神龙。也就是做加法，开始是0，加到某个值的时候就执行</p>
<p>CyclicBarrier的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法</p>
<h3 id="2-2-案例"><a href="#2-2-案例" class="headerlink" title="2.2 案例"></a>2.2 案例</h3><p>集齐7个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span>
<span class="hljs-comment">*/</span>
CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">7</span>, () -&gt; &#123;
	System.out.println(<span class="hljs-string">&quot;召唤神龙&quot;</span>);
&#125;);</code></pre></div>

<p>然后同时编写七个线程，进行龙珠收集，但一个线程收集到了的时候，我们需要让他执行await方法，等待到7个线程全部执行完毕后，我们就执行原来定义好的方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;
    <span class="hljs-keyword">final</span> Integer tempInt = i;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="hljs-string">&quot;颗龙珠&quot;</span>);

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span>
            cyclicBarrier.await();
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>完整代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * CyclicBarrier循环屏障</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierDemo</span> </span>&#123;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span>
<span class="hljs-comment">         */</span>
        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">7</span>, () -&gt; &#123;
            System.out.println(<span class="hljs-string">&quot;召唤神龙&quot;</span>);
        &#125;);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;
            <span class="hljs-keyword">final</span> Integer tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="hljs-string">&quot;颗龙珠&quot;</span>);

                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span>
                    cyclicBarrier.await();
                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="3-Semaphore：信号量"><a href="#3-Semaphore：信号量" class="headerlink" title="3 Semaphore：信号量"></a>3 Semaphore：信号量</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p>信号量主要用于两个目的</p>
<ul>
<li>一个是用于共享资源的互斥使用</li>
<li>另一个用于并发线程数的控制</li>
</ul>
<h3 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2 代码"></a>3.2 代码</h3><p>我们模拟一个抢车位的场景，假设一共有6个车，3个停车位</p>
<p>那么我们首先需要定义信号量为3，也就是3个停车位</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span>
<span class="hljs-comment">*/</span>
Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>, <span class="hljs-keyword">false</span>);</code></pre></div>

<p>然后我们模拟6辆车同时并发抢占停车位，但第一个车辆抢占到停车位后，信号量需要减1</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 代表一辆车，已经占用了该车位</span>
semaphore.acquire(); <span class="hljs-comment">// 抢占</span></code></pre></div>

<p>同时车辆假设需要等待3秒后，释放信号量</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 每个车停3秒</span>
<span class="hljs-keyword">try</span> &#123;
	TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
	e.printStackTrace();
&#125;</code></pre></div>

<p>最后车辆离开，释放信号量</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 释放停车位</span>
semaphore.release();</code></pre></div>

<h3 id="3-3-完整代码"><a href="#3-3-完整代码" class="headerlink" title="3.3 完整代码"></a>3.3 完整代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 信号量Demo</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-03-16-15:01</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span>
<span class="hljs-comment">         */</span>
        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>, <span class="hljs-keyword">false</span>);

        <span class="hljs-comment">// 模拟6部车</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-comment">// 代表一辆车，已经占用了该车位</span>
                    semaphore.acquire(); <span class="hljs-comment">// 抢占</span>

                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 抢到车位&quot;</span>);

                    <span class="hljs-comment">// 每个车停3秒</span>
                    <span class="hljs-keyword">try</span> &#123;
                        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;

                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 离开车位&quot;</span>);

                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-comment">// 释放停车位</span>
                    semaphore.release();
                &#125;
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>运行结果</p>
<div class="code-wrapper"><pre><code class="hljs plain">0	 抢到车位
2	 抢到车位
1	 抢到车位
2	 离开车位
1	 离开车位
3	 抢到车位
0	 离开车位
4	 抢到车位
5	 抢到车位
4	 离开车位
3	 离开车位
5	 离开车位</code></pre></div>

<p>看运行结果能够发现，0 2 1 车辆首先抢占到了停车位，然后等待3秒后，离开，然后后面 3 4 5 又抢到了车位</p>
<h1 id="第8章阻塞队列"><a href="#第8章阻塞队列" class="headerlink" title="第8章阻塞队列"></a>第8章阻塞队列</h1><h2 id="8-1-概念"><a href="#8-1-概念" class="headerlink" title="8.1 概念"></a>8.1 概念</h2><h3 id="1-队列"><a href="#1-队列" class="headerlink" title="1 队列"></a>1 队列</h3><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭</p>
<h3 id="2-阻塞队列"><a href="#2-阻塞队列" class="headerlink" title="2 阻塞队列"></a>2 阻塞队列</h3><p>BlockingQueue   阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/8_%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/images/image-20200316152120272.png" alt="image-20200316152120272"></p>
<p>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素</p>
<ul>
<li><p><code>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</code></p>
<ul>
<li>当蛋糕店的柜子空的时候，无法从柜子里面获取蛋糕</li>
</ul>
</li>
<li><p><code>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</code></p>
<ul>
<li>当蛋糕店的柜子满的时候，无法继续向柜子里面添加蛋糕了</li>
</ul>
</li>
</ul>
<p>也就是说 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素</p>
<p>同理，试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增</p>
<h2 id="8-2-为什么要用？"><a href="#8-2-为什么要用？" class="headerlink" title="8.2 为什么要用？"></a>8.2 为什么要用？</h2><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞</p>
<p>在多线程领域：所谓的阻塞，在某些清空下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒</p>
<h3 id="为什么需要BlockingQueue"><a href="#为什么需要BlockingQueue" class="headerlink" title="为什么需要BlockingQueue"></a>为什么需要BlockingQueue</h3><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都帮你一手包办了</p>
<p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<h2 id="8-3-架构"><a href="#8-3-架构" class="headerlink" title="8.3 架构"></a>8.3 架构</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 你用过List集合类</span>

<span class="hljs-comment">// ArrayList集合类熟悉么？</span>

<span class="hljs-comment">// 还用过 CopyOnWriteList  和 BlockingQueue</span></code></pre></div>

<p>BlockingQueue阻塞队列是属于一个接口，底下有七个实现类</p>
<ul>
<li>ArrayBlockQueue：由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列<ul>
<li>有界，但是界限非常大，相当于无界，可以当成无界</li>
</ul>
</li>
<li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li>
<li>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列<ul>
<li>生产一个，消费一个，不存储元素，不消费不生产</li>
</ul>
</li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li>
</ul>
<p>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p>
<h2 id="8-4-BlockingQueue核心方法"><a href="#8-4-BlockingQueue核心方法" class="headerlink" title="8.4 BlockingQueue核心方法"></a>8.4 BlockingQueue核心方法</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/8_%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/images/image-20200316154442756.png" alt="image-20200316154442756"></p>
<table>
<thead>
<tr>
<th>抛出异常</th>
<th>当阻塞队列满时：在往队列中add插入元素会抛出 IIIegalStateException：Queue full                      当阻塞队列空时：再往队列中remove移除元素，会抛出NoSuchException</th>
</tr>
</thead>
<tbody><tr>
<td>特殊性</td>
<td>插入方法，成功true，失败false       移除方法：成功返回出队列元素，队列没有就返回空</td>
</tr>
<tr>
<td>一直阻塞</td>
<td>当阻塞队列满时，生产者继续往队列里put元素，队列会一直阻塞生产线程直到put数据or响应中断退出， 当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用。</td>
</tr>
<tr>
<td>超时退出</td>
<td>当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td>
</tr>
</tbody></table>
<h3 id="1-抛出异常组"><a href="#1-抛出异常组" class="headerlink" title="1 抛出异常组"></a>1 抛出异常组</h3><p>但执行add方法，向已经满的ArrayBlockingQueue中添加元素时候，会抛出异常</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞队列，需要填入默认值</span>
BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);

System.out.println(blockingQueue.add(<span class="hljs-string">&quot;a&quot;</span>));
System.out.println(blockingQueue.add(<span class="hljs-string">&quot;b&quot;</span>));
System.out.println(blockingQueue.add(<span class="hljs-string">&quot;c&quot;</span>));

System.out.println(blockingQueue.add(<span class="hljs-string">&quot;XXX&quot;</span>));</code></pre></div>

<p>运行后：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">true</span>
<span class="hljs-keyword">true</span>
<span class="hljs-keyword">true</span>
Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalStateException: Queue full
	at java.util.AbstractQueue.add(AbstractQueue.java:<span class="hljs-number">98</span>)
	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:<span class="hljs-number">312</span>)
	at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:<span class="hljs-number">25</span>)</code></pre></div>

<p>同时如果我们多取出元素的时候，也会抛出异常，我们假设只存储了3个值，但是取的时候，取了四次</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞队列，需要填入默认值</span>
BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);
System.out.println(blockingQueue.add(<span class="hljs-string">&quot;a&quot;</span>));
System.out.println(blockingQueue.add(<span class="hljs-string">&quot;b&quot;</span>));
System.out.println(blockingQueue.add(<span class="hljs-string">&quot;c&quot;</span>));

System.out.println(blockingQueue.remove());
System.out.println(blockingQueue.remove());
System.out.println(blockingQueue.remove());
System.out.println(blockingQueue.remove());</code></pre></div>

<p>那么出现异常</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">true</span>
<span class="hljs-keyword">true</span>
<span class="hljs-keyword">true</span>
a
b
c
Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.NoSuchElementException
	at java.util.AbstractQueue.remove(AbstractQueue.java:<span class="hljs-number">117</span>)
	at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:<span class="hljs-number">30</span>)</code></pre></div>

<h3 id="2-布尔类型组"><a href="#2-布尔类型组" class="headerlink" title="2 布尔类型组"></a>2 布尔类型组</h3><p>我们使用 offer的方法，添加元素时候，如果阻塞队列满了后，会返回false，否者返回true</p>
<p>同时在取的时候，如果队列已空，那么会返回null</p>
<div class="code-wrapper"><pre><code class="hljs java">BlockingQueue blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue(<span class="hljs-number">3</span>);

System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;a&quot;</span>));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;b&quot;</span>));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;c&quot;</span>));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;d&quot;</span>));

System.out.println(blockingQueue.poll());
System.out.println(blockingQueue.poll());
System.out.println(blockingQueue.poll());
System.out.println(blockingQueue.poll());</code></pre></div>

<p>运行结果</p>
<div class="code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">false</span>
<span class="hljs-keyword">a</span>
b
c
<span class="hljs-literal">null</span></code></pre></div>

<h3 id="3-阻塞队列组"><a href="#3-阻塞队列组" class="headerlink" title="3 阻塞队列组"></a>3 阻塞队列组</h3><p>我们使用 put的方法，添加元素时候，如果阻塞队列满了后，添加消息的线程，会一直阻塞，直到队列元素减少，会被清空，才会唤醒</p>
<p>一般在消息中间件，比如RabbitMQ中会使用到，因为需要保证消息百分百不丢失，因此只有让它阻塞</p>
<div class="code-wrapper"><pre><code class="hljs abnf">BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>)<span class="hljs-comment">;</span>
blockingQueue.put(<span class="hljs-string">&quot;a&quot;</span>)<span class="hljs-comment">;</span>
blockingQueue.put(<span class="hljs-string">&quot;b&quot;</span>)<span class="hljs-comment">;</span>
blockingQueue.put(<span class="hljs-string">&quot;c&quot;</span>)<span class="hljs-comment">;</span>
System.out.println(<span class="hljs-string">&quot;================&quot;</span>)<span class="hljs-comment">;</span>

blockingQueue.take()<span class="hljs-comment">;</span>
blockingQueue.take()<span class="hljs-comment">;</span>
blockingQueue.take()<span class="hljs-comment">;</span>
blockingQueue.take()<span class="hljs-comment">;</span></code></pre></div>

<p>同时使用take取消息的时候，如果内容不存在的时候，也会被阻塞</p>
<h3 id="4-不见不散组"><a href="#4-不见不散组" class="headerlink" title="4 不见不散组"></a>4 不见不散组</h3><p>offer( )  ， poll 加时间</p>
<p>使用offer插入的时候，需要指定时间，如果2秒还没有插入，那么就放弃插入</p>
<div class="code-wrapper"><pre><code class="hljs java">BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));</code></pre></div>

<p>同时取的时候也进行判断</p>
<div class="code-wrapper"><pre><code class="hljs java">System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));</code></pre></div>

<p>如果2秒内取不出来，那么就返回null</p>
<h2 id="8-5-SynchronousQueue"><a href="#8-5-SynchronousQueue" class="headerlink" title="8.5 SynchronousQueue"></a>8.5 SynchronousQueue</h2><p>SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储的BlockingQueue，每一个put操作必须等待一个take操作，否者不能继续添加元素</p>
<p>下面我们测试SynchronousQueue添加元素的过程</p>
<p>首先我们创建了两个线程，一个线程用于生产，一个线程用于消费</p>
<p>生产的线程分别put了 A、B、C这三个字段</p>
<div class="code-wrapper"><pre><code class="hljs java">BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;();

<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
    <span class="hljs-keyword">try</span> &#123;       
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put A &quot;</span>);
        blockingQueue.put(<span class="hljs-string">&quot;A&quot;</span>);
       
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put B &quot;</span>);
        blockingQueue.put(<span class="hljs-string">&quot;B&quot;</span>);        
        
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put C &quot;</span>);
        blockingQueue.put(<span class="hljs-string">&quot;C&quot;</span>);        
        
    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();</code></pre></div>

<p>消费线程使用take，消费阻塞队列中的内容，并且每次消费前，都等待5秒</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
    <span class="hljs-keyword">try</span> &#123;

        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        blockingQueue.take();
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take A &quot;</span>);

        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        blockingQueue.take();
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take B &quot;</span>);

        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        blockingQueue.take();
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take C &quot;</span>);

    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();</code></pre></div>

<p>最后结果输出为：</p>
<div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-built_in">t1</span>	 put A 
<span class="hljs-built_in">t2</span>	 take A 

<span class="hljs-number">5</span>秒后...

<span class="hljs-built_in">t1</span>	 put <span class="hljs-keyword">B </span>
<span class="hljs-built_in">t2</span>	 take <span class="hljs-keyword">B </span>

<span class="hljs-number">5</span>秒后...

<span class="hljs-built_in">t1</span>	 put C 
<span class="hljs-built_in">t2</span>	 take C</code></pre></div>

<p>我们从最后的运行结果可以看出，每次t1线程向队列中添加阻塞队列添加元素后，t1输入线程就会等待 t2消费线程，t2消费后，t2处于挂起状态，等待t1在存入，从而周而复始，形成 一存一取的状态</p>
<h2 id="8-6-阻塞队列的用处"><a href="#8-6-阻塞队列的用处" class="headerlink" title="8.6 阻塞队列的用处"></a>8.6 阻塞队列的用处</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p>一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮</p>
<p>关于多线程的操作，我们需要记住下面几句</p>
<ul>
<li>线程 操作 资源类</li>
<li>判断 干活 通知</li>
<li>防止虚假唤醒机制</li>
</ul>
<p>我们下面实现一个简单的生产者消费者模式，首先有资源类ShareData</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareData</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        <span class="hljs-comment">// 同步代码块，加锁</span>
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// 等待不能生产</span>
                condition.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            number++;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);

            <span class="hljs-comment">// 通知 唤醒</span>
            condition.signalAll();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        <span class="hljs-comment">// 同步代码块，加锁</span>
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// 等待不能消费</span>
                condition.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            number--;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);

            <span class="hljs-comment">// 通知 唤醒</span>
            condition.signalAll();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

&#125;</code></pre></div>

<p>里面有一个number变量，同时提供了increment 和 decrement的方法，分别让number 加1和减1</p>
<p>但是我们在进行判断的时候，为了防止出现虚假唤醒机制，不能使用if来进行判断，而应该使用while</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 判断</span>
<span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">// 等待不能生产</span>
    condition.await();
&#125;</code></pre></div>

<p>不能使用 if判断</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 判断</span>
<span class="hljs-keyword">if</span>(number != <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">// 等待不能生产</span>
    condition.await();
&#125;</code></pre></div>

<p>完整代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 生产者消费者 传统版</span>
<span class="hljs-comment"> * 题目：一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮</span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 线程 操作 资源类</span>
<span class="hljs-comment"> * 判断 干活 通知</span>
<span class="hljs-comment"> * 防止虚假唤醒机制</span>
<span class="hljs-comment"> */</span>

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareData</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        <span class="hljs-comment">// 同步代码块，加锁</span>
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// 等待不能生产</span>
                condition.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            number++;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);

            <span class="hljs-comment">// 通知 唤醒</span>
            condition.signalAll();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        <span class="hljs-comment">// 同步代码块，加锁</span>
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// 等待不能消费</span>
                condition.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            number--;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);

            <span class="hljs-comment">// 通知 唤醒</span>
            condition.signalAll();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProdConsumerTraditionDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 高内聚，低耦合    内聚指的是，一个空调，自身带有调节温度高低的方法</span>

        ShareData shareData = <span class="hljs-keyword">new</span> ShareData();

        <span class="hljs-comment">// t1线程，生产</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    shareData.increment();
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-comment">// t2线程，消费</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    shareData.decrement();
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p>最后运行成功后，我们一个进行生产，一个进行消费</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">t1</span>	 <span class="hljs-number">1</span>
<span class="hljs-attribute">t2</span>	 <span class="hljs-number">0</span>
<span class="hljs-attribute">t1</span>	 <span class="hljs-number">1</span>
<span class="hljs-attribute">t2</span>	 <span class="hljs-number">0</span>
<span class="hljs-attribute">t1</span>	 <span class="hljs-number">1</span>
<span class="hljs-attribute">t2</span>	 <span class="hljs-number">0</span>
<span class="hljs-attribute">t1</span>	 <span class="hljs-number">1</span>
<span class="hljs-attribute">t2</span>	 <span class="hljs-number">0</span>
<span class="hljs-attribute">t1</span>	 <span class="hljs-number">1</span>
<span class="hljs-attribute">t2</span>	 <span class="hljs-number">0</span></code></pre></div>

<h2 id="8-7-生成者和消费者3-0"><a href="#8-7-生成者和消费者3-0" class="headerlink" title="8.7 生成者和消费者3.0"></a>8.7 生成者和消费者3.0</h2><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，则这会给我们的程序带来不小的时间复杂度</p>
<p>现在我们使用新版的阻塞队列版生产者和消费者，使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 生产者消费者  阻塞队列版</span>
<span class="hljs-comment"> * 使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</span>
<span class="hljs-comment"> */</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> </span>&#123;
    <span class="hljs-comment">// 默认开启，进行生产消费</span>
    <span class="hljs-comment">// 这里用到了volatile是为了保持数据的可见性，也就是当TLAG修改时，要马上通知其它线程进行修改</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> FLAG = <span class="hljs-keyword">true</span>;

    <span class="hljs-comment">// 使用原子包装类，而不用number++</span>
    <span class="hljs-keyword">private</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();

    <span class="hljs-comment">// 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue</span>
    BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">// 而应该采用依赖注入里面的，构造注入方法传入</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyResource</span><span class="hljs-params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.blockingQueue = blockingQueue;
        <span class="hljs-comment">// 查询出传入的class是什么</span>
        System.out.println(blockingQueue.getClass().getName());
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 生产</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myProd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        String data = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">boolean</span> retValue;
        <span class="hljs-comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span>
        <span class="hljs-comment">// 当FLAG为true的时候，开始生产</span>
        <span class="hljs-keyword">while</span>(FLAG) &#123;
            data = atomicInteger.incrementAndGet() + <span class="hljs-string">&quot;&quot;</span>;

            <span class="hljs-comment">// 2秒存入1个data</span>
            retValue = blockingQueue.offer(data, <span class="hljs-number">2L</span>, TimeUnit.SECONDS);
            <span class="hljs-keyword">if</span>(retValue) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 插入队列:&quot;</span> + data  + <span class="hljs-string">&quot;成功&quot;</span> );
            &#125; <span class="hljs-keyword">else</span> &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 插入队列:&quot;</span> + data  + <span class="hljs-string">&quot;失败&quot;</span> );
            &#125;

            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 停止生产，表示FLAG=false，生产介绍&quot;</span>);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 消费</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myConsumer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        String retValue;
        <span class="hljs-comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span>
        <span class="hljs-comment">// 当FLAG为true的时候，开始生产</span>
        <span class="hljs-keyword">while</span>(FLAG) &#123;
            <span class="hljs-comment">// 2秒存入1个data</span>
            retValue = blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS);
            <span class="hljs-keyword">if</span>(retValue != <span class="hljs-keyword">null</span> &amp;&amp; retValue != <span class="hljs-string">&quot;&quot;</span>) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费队列:&quot;</span> + retValue  + <span class="hljs-string">&quot;成功&quot;</span> );
            &#125; <span class="hljs-keyword">else</span> &#123;
                FLAG = <span class="hljs-keyword">false</span>;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费失败，队列中已为空，退出&quot;</span> );

                <span class="hljs-comment">// 退出消费队列</span>
                <span class="hljs-keyword">return</span>;
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 停止生产的判断</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.FLAG = <span class="hljs-keyword">false</span>;
    &#125;

&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProdConsumerBlockingQueueDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 传入具体的实现类， ArrayBlockingQueue</span>
        MyResource myResource = <span class="hljs-keyword">new</span> MyResource(<span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="hljs-number">10</span>));

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 生产线程启动&quot;</span>);
            System.out.println(<span class="hljs-string">&quot;&quot;</span>);
            System.out.println(<span class="hljs-string">&quot;&quot;</span>);
            <span class="hljs-keyword">try</span> &#123;
                myResource.myProd();
                System.out.println(<span class="hljs-string">&quot;&quot;</span>);
                System.out.println(<span class="hljs-string">&quot;&quot;</span>);
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;prod&quot;</span>).start();


        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费线程启动&quot;</span>);

            <span class="hljs-keyword">try</span> &#123;
                myResource.myConsumer();
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;consumer&quot;</span>).start();

        <span class="hljs-comment">// 5秒后，停止生产和消费</span>
        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        System.out.println(<span class="hljs-string">&quot;&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;5秒中后，生产和消费线程停止，线程结束&quot;</span>);
        myResource.stop();
    &#125;
&#125;</code></pre></div>

<p>最后运行结果</p>
<div class="code-wrapper"><pre><code class="hljs java">java.util.concurrent.ArrayBlockingQueue
prod	 生产线程启动


consumer	 消费线程启动
prod	 插入队列:<span class="hljs-number">1</span>成功
consumer	 消费队列:<span class="hljs-number">1</span>成功
prod	 插入队列:<span class="hljs-number">2</span>成功
consumer	 消费队列:<span class="hljs-number">2</span>成功
prod	 插入队列:<span class="hljs-number">3</span>成功
consumer	 消费队列:<span class="hljs-number">3</span>成功
prod	 插入队列:<span class="hljs-number">4</span>成功
consumer	 消费队列:<span class="hljs-number">4</span>成功
prod	 插入队列:<span class="hljs-number">5</span>成功
consumer	 消费队列:<span class="hljs-number">5</span>成功


<span class="hljs-number">5</span>秒中后，生产和消费线程停止，线程结束
prod	 停止生产，表示FLAG=<span class="hljs-keyword">false</span>，生产介绍</code></pre></div>

<h1 id="第9章-Synchronized和Lock的区别"><a href="#第9章-Synchronized和Lock的区别" class="headerlink" title="第9章 Synchronized和Lock的区别"></a>第9章 Synchronized和Lock的区别</h1><h2 id="9-1-前言"><a href="#9-1-前言" class="headerlink" title="9.1 前言"></a>9.1 前言</h2><p>早期的时候我们对线程的主要操作为：</p>
<ul>
<li>synchronized wait  notify</li>
</ul>
<p>然后后面出现了替代方案</p>
<ul>
<li>lock await  signal</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/9_Synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%A5%BD%E5%A4%84/images/image-20200317101210376.png" alt="image-20200317101210376"></p>
<h2 id="9-2-问题"><a href="#9-2-问题" class="headerlink" title="9.2 问题"></a>9.2 问题</h2><h3 id="synchronized-和-lock-有什么区别？用新的lock有什么好处？举例说明"><a href="#synchronized-和-lock-有什么区别？用新的lock有什么好处？举例说明" class="headerlink" title="synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明"></a>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</h3><ul>
<li>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</li>
</ul>
<p>1）synchronized属于JVM层面，属于java的关键字</p>
<ul>
<li>monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象 只能在同步块或者方法中才能调用 wait/ notify等方法）</li>
<li>Lock是具体类（java.util.concurrent.locks.Lock）是api层面的锁</li>
</ul>
<p>2）使用方法：</p>
<ul>
<li><p>synchronized：不需要用户去手动释放锁，当synchronized代码执行后，系统会自动让线程释放对锁的占用</p>
</li>
<li><p>ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要lock() 和 unlock() 配置try catch语句来完成</p>
</li>
</ul>
<p>3）等待是否中断</p>
<ul>
<li>synchronized：不可中断，除非抛出异常或者正常运行完成</li>
<li>ReentrantLock：可中断，可以设置超时方法<ul>
<li>设置超时方法，trylock(long timeout, TimeUnit unit)</li>
<li>lockInterrupible() 放代码块中，调用interrupt() 方法可以中断</li>
</ul>
</li>
</ul>
<p>4）加锁是否公平</p>
<ul>
<li>synchronized：非公平锁</li>
<li>ReentrantLock：默认非公平锁，构造函数可以传递boolean值，true为公平锁，false为非公平锁</li>
</ul>
<p>5）锁绑定多个条件Condition</p>
<ul>
<li>synchronized：没有，要么随机，要么全部唤醒</li>
<li>ReentrantLock：用来实现分组唤醒需要唤醒的线程，可以精确唤醒，而不是像synchronized那样，要么随机，要么全部唤醒</li>
</ul>
<h2 id="9-3-举例"><a href="#9-3-举例" class="headerlink" title="9.3 举例"></a>9.3 举例</h2><p>针对刚刚提到的区别的第5条，我们有下面这样的一个场景</p>
<div class="code-wrapper"><pre><code class="hljs java">题目：多线程之间按顺序调用，实现 A-&gt; B -&gt; C 三个线程启动，要求如下：
AA打印<span class="hljs-number">5</span>次，BB打印<span class="hljs-number">10</span>次，CC打印<span class="hljs-number">15</span>次
紧接着
AA打印<span class="hljs-number">5</span>次，BB打印<span class="hljs-number">10</span>次，CC打印<span class="hljs-number">15</span>次
..
来<span class="hljs-number">10</span>轮</code></pre></div>

<p>我们会发现，这样的场景在使用synchronized来完成的话，会非常的困难，但是使用lock就非常方便了</p>
<p>也就是我们需要实现一个链式唤醒的操作</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/9_Synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%A5%BD%E5%A4%84/images/image-20200317105121435.png" alt="image-20200317105121435"></p>
<p>当A线程执行完后，B线程才能执行，然后B线程执行完成后，C线程才执行</p>
<p>首先我们需要创建一个重入锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个重入锁</span>
<span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();</code></pre></div>

<p>然后定义三个条件，也可以称为锁的钥匙，通过它就可以获取到锁，进入到方法里面</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这三个相当于备用钥匙</span>
<span class="hljs-keyword">private</span> Condition condition1 = lock.newCondition();
<span class="hljs-keyword">private</span> Condition condition2 = lock.newCondition();
<span class="hljs-keyword">private</span> Condition condition3 = lock.newCondition();</code></pre></div>

<p>然后开始记住锁的三部曲： 判断   干活  唤醒</p>
<p>这里的判断，为了避免虚假唤醒，一定要采用  while</p>
<p>干活就是把需要的内容，打印出来</p>
<p>唤醒的话，就是修改资源类的值，然后精准唤醒线程进行干活：这里A 唤醒B， B唤醒C，C又唤醒A</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print5</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 判断</span>
        <span class="hljs-keyword">while</span>(number != <span class="hljs-number">1</span>) &#123;
            <span class="hljs-comment">// 不等于1，需要等待</span>
            condition1.await();
        &#125;

        <span class="hljs-comment">// 干活</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);
        &#125;

        <span class="hljs-comment">// 唤醒 （干完活后，需要通知B线程执行）</span>
        number = <span class="hljs-number">2</span>;
        <span class="hljs-comment">// 通知2号去干活了</span>
        condition2.signal();

    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        e.printStackTrace();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Synchronized 和 Lock的区别</span>
<span class="hljs-comment"> */</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareResource</span> </span>&#123;
    <span class="hljs-comment">// A 1   B 2   c 3</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;
    <span class="hljs-comment">// 创建一个重入锁</span>
    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-comment">// 这三个相当于备用钥匙</span>
    <span class="hljs-keyword">private</span> Condition condition1 = lock.newCondition();
    <span class="hljs-keyword">private</span> Condition condition2 = lock.newCondition();
    <span class="hljs-keyword">private</span> Condition condition3 = lock.newCondition();


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print5</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">1</span>) &#123;
                <span class="hljs-comment">// 不等于1，需要等待</span>
                condition1.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);
            &#125;

            <span class="hljs-comment">// 唤醒 （干完活后，需要通知B线程执行）</span>
            number = <span class="hljs-number">2</span>;
            <span class="hljs-comment">// 通知2号去干活了</span>
            condition2.signal();

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print10</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">2</span>) &#123;
                <span class="hljs-comment">// 不等于2，需要等待</span>
                condition2.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);
            &#125;

            <span class="hljs-comment">// 唤醒 （干完活后，需要通知C线程执行）</span>
            number = <span class="hljs-number">3</span>;
            <span class="hljs-comment">// 通知2号去干活了</span>
            condition3.signal();

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print15</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">3</span>) &#123;
                <span class="hljs-comment">// 不等于3，需要等待</span>
                condition3.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);
            &#125;

            <span class="hljs-comment">// 唤醒 （干完活后，需要通知C线程执行）</span>
            number = <span class="hljs-number">1</span>;
            <span class="hljs-comment">// 通知1号去干活了</span>
            condition1.signal();

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncAndReentrantLockDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        ShareResource shareResource = <span class="hljs-keyword">new</span> ShareResource();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                    shareResource.print5();
            &#125;
        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                shareResource.print10();
            &#125;
        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                shareResource.print15();
            &#125;
        &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<h1 id="第10章线程池"><a href="#第10章线程池" class="headerlink" title="第10章线程池"></a>第10章线程池</h1><h2 id="10-1-前言"><a href="#10-1-前言" class="headerlink" title="10.1 前言"></a>10.1 前言</h2><p>获取多线程的方法，我们都知道有三种，还有一种是实现Callable接口</p>
<ul>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>实例化Thread类</li>
<li>使用线程池获取</li>
</ul>
<h2 id="10-2-Callable接口"><a href="#10-2-Callable接口" class="headerlink" title="10.2 Callable接口"></a>10.2 Callable接口</h2><p>Callable接口，是一种让线程执行完成后，能够返回结果的</p>
<p>在说到Callable接口的时候，我们不得不提到Runnable接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 实现Runnable接口</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;

    &#125;
&#125;</code></pre></div>

<p>我们知道，实现Runnable接口的时候，需要重写run方法，也就是线程在启动的时候，会自动调用的方法</p>
<p>同理，我们实现Callable接口，也需要实现call方法，但是这个时候我们还需要有返回值，这个Callable接口的应用场景一般就在于批处理业务，比如转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Callable有返回值</span>
<span class="hljs-comment"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;come in Callable&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;
    &#125;
&#125;</code></pre></div>

<p>最后我们需要做的就是通过Thread线程， 将MyThread2实现Callable接口的类包装起来</p>
<p>这里需要用到的是FutureTask类，他实现了Runnable接口，并且还需要传递一个实现Callable接口的类作为构造函数</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// FutureTask：实现了Runnable接口，构造函数又需要传入 Callable接口</span>
<span class="hljs-comment">// 这里通过了FutureTask接触了Callable接口</span>
FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());</code></pre></div>

<p>然后在用Thread进行实例化，传入实现Runnabnle接口的FutureTask的类</p>
<div class="code-wrapper"><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;aaa&quot;</span>);
t1.start();</code></pre></div>

<p>最后通过 futureTask.get() 获取到返回值</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 输出FutureTask的返回值</span>
System.out.println(<span class="hljs-string">&quot;result FutureTask &quot;</span> + futureTask.get());</code></pre></div>

<p>这就相当于原来我们的方式是main方法一条龙之心，后面在引入Callable后，对于执行比较久的线程，可以单独新开一个线程进行执行，最后在进行汇总输出</p>
<p>最后需要注意的是 要求获得Callable线程的计算结果，如果没有计算完成就要去强求，会导致阻塞，直到计算完成</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/10_%E7%BA%BF%E7%A8%8B%E6%B1%A0/images/image-20200317152541284.png" alt="image-20200317152541284"></p>
<p>也就是说 futureTask.get() 需要放在最后执行，这样不会导致主线程阻塞</p>
<p>也可以使用下面算法，使用类似于自旋锁的方式来进行判断是否运行完毕</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 判断futureTask是否计算完成</span>
<span class="hljs-keyword">while</span>(!futureTask.isDone()) &#123;

&#125;</code></pre></div>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>多个线程执行 一个FutureTask的时候，只会计算一次</p>
<div class="code-wrapper"><pre><code class="hljs java">FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());

<span class="hljs-comment">// 开启两个线程计算futureTask</span>
<span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;AAA&quot;</span>).start();
<span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;BBB&quot;</span>).start();</code></pre></div>

<p>如果我们要两个线程同时计算任务的话，那么需要这样写，需要定义两个futureTask</p>
<div class="code-wrapper"><pre><code class="hljs java">FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());
FutureTask&lt;Integer&gt; futureTask2 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());

<span class="hljs-comment">// 开启两个线程计算futureTask</span>
<span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;AAA&quot;</span>).start();

<span class="hljs-keyword">new</span> Thread(futureTask2, <span class="hljs-string">&quot;BBB&quot;</span>).start();</code></pre></div>

<h2 id="10-3-ThreadPoolExecutor"><a href="#10-3-ThreadPoolExecutor" class="headerlink" title="10.3 ThreadPoolExecutor"></a>10.3 ThreadPoolExecutor</h2><h3 id="1-为什么用线程池"><a href="#1-为什么用线程池" class="headerlink" title="1 为什么用线程池"></a>1 为什么用线程池</h3><p>线程池做的主要工作就是控制运行的线程的数量，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p>
<p>它的主要特点为：线程复用、控制最大并发数、管理线程</p>
<p>线程池中的任务是放入到阻塞队列中的</p>
<h3 id="2-线程池的好处"><a href="#2-线程池的好处" class="headerlink" title="2 线程池的好处"></a>2 线程池的好处</h3><p>多核处理的好处是：省略的上下文的切换开销</p>
<p>原来我们实例化对象的时候，是使用 new关键字进行创建，到了Spring后，我们学了IOC依赖注入，发现Spring帮我们将对象已经加载到了Spring容器中，只需要通过@Autowrite注解，就能够自动注入，从而使用</p>
<p>因此使用多线程有下列的好处</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就立即执行</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<h3 id="3-架构说明"><a href="#3-架构说明" class="headerlink" title="3 架构说明"></a>3 架构说明</h3><p>Java中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors（代表工具类），ExecutorService，ThreadPoolExecutor这几个类。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/10_%E7%BA%BF%E7%A8%8B%E6%B1%A0/images/image-20200317175202647.png" alt="image-20200317175202647"></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/10_%E7%BA%BF%E7%A8%8B%E6%B1%A0/images/image-20200317175241007.png" alt="image-20200317175241007"></p>
<h3 id="4-创建线程池"><a href="#4-创建线程池" class="headerlink" title="4 创建线程池"></a>4 创建线程池</h3><ul>
<li>Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池<ul>
<li>执行长期的任务，性能好很多</li>
<li>创建一个定长线程池，可控制线程数最大并发数，超出的线程会在队列中等待</li>
</ul>
</li>
<li>Executors.newSingleThreadExecutor：创建一个只有1个线程的 单线程池<ul>
<li>一个任务一个任务执行的场景</li>
<li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li>
</ul>
</li>
<li>Executors.newCacheThreadPool();  创建一个可扩容的线程池<ul>
<li>执行很多短期异步的小程序或者负载教轻的服务器</li>
<li>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程</li>
</ul>
</li>
<li>Executors.newScheduledThreadPool(int corePoolSize)：线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li>
</ul>
<p>具体使用，首先我们需要使用Executors工具类，进行创建线程池，这里创建了一个拥有5个线程的线程池</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span>
ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);

<span class="hljs-comment">// 创建一个只有一个线程的线程池</span>
ExecutorService threadPool = Executors.newSingleThreadExecutor();

<span class="hljs-comment">// 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span>
ExecutorService threadPool = Executors.newCacheThreadPool();</code></pre></div>

<p>然后我们执行下面的的应用场景</p>
<div class="code-wrapper"><pre><code class="hljs plain">模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</code></pre></div>

<p>我们需要使用 threadPool.execute执行业务，execute需要传入一个实现了Runnable接口的线程</p>
<div class="code-wrapper"><pre><code class="hljs java">threadPool.execute(() -&gt; &#123;
	System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户办理业务&quot;</span>);
&#125;);</code></pre></div>

<p>然后我们使用完毕后关闭线程池</p>
<div class="code-wrapper"><pre><code class="hljs java">threadPool.shutdown();</code></pre></div>

<p>完整代码为：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 第四种获取 / 使用 Java多线程的方式，通过线程池</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadPoolDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// Array  Arrays(辅助工具类)</span>
        <span class="hljs-comment">// Collection Collections(辅助工具类)</span>
        <span class="hljs-comment">// Executor Executors(辅助工具类)</span>


        <span class="hljs-comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span>
        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);

        <span class="hljs-comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span>
        <span class="hljs-keyword">try</span> &#123;

            <span class="hljs-comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
                threadPool.execute(() -&gt; &#123;
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="hljs-string">&quot; 办理业务&quot;</span>);
                &#125;);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            threadPool.shutdown();
        &#125;

    &#125;
&#125;</code></pre></div>

<p>最后结果：</p>
<div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">0</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">4</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">5</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">3</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">1</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">2</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">9</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">8</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">7</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">6</span> 办理业务</code></pre></div>

<p>我们能够看到，一共有5个线程，在给10个用户办理业务</p>
<h3 id="5-创建周期性执行任务的线程池"><a href="#5-创建周期性执行任务的线程池" class="headerlink" title="5  创建周期性执行任务的线程池"></a>5  创建周期性执行任务的线程池</h3><p>Executors.newScheduledThreadPool(int corePoolSize)：</p>
<p><strong>线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</strong></p>
<p>底层使用 ScheduledThreadPoolExecutor 来实现 ScheduledThreadPoolExecutor 为ThreadPoolExecutor子类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,
              <span class="hljs-keyword">new</span> DelayedWorkQueue());
&#125;</code></pre></div>

<h4 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h4><div class="code-wrapper"><pre><code class="hljs java">  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">   * command：执行的任务 Callable或Runnable接口实现类</span>
<span class="hljs-comment">* delay：延时执行任务的时间</span>
<span class="hljs-comment">* unit：延迟时间单位</span>
<span class="hljs-comment">   */</span>
  <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,
                                     <span class="hljs-keyword">long</span> delay,
                                     TimeUnit unit)</code></pre></div>



<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException   &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * command：执行的任务 Callable或Runnable接口实现类</span>
<span class="hljs-comment">	 * initialDelay 第一次执行任务延迟时间</span>
<span class="hljs-comment">	 * period 连续执行任务之间的周期，从上一个任务开始执行时计算延迟多少开始执行下一个任务，但是还会等上一个任务结束之后。</span>
<span class="hljs-comment">	 * unit：延迟时间单位</span>
<span class="hljs-comment">     */</span>
<span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">long</span> period, TimeUnit unit)</code></pre></div>



<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException   &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * command：执行的任务 Callable或Runnable接口实现类</span>
<span class="hljs-comment">	 * initialDelay 第一次执行任务延迟时间</span>
<span class="hljs-comment">	 * delay：连续执行任务之间的周期，从上一个任务全部执行完成时计算延迟多少开始执行下一个任务</span>
<span class="hljs-comment">	 * unit：延迟时间单位</span>
<span class="hljs-comment">     */</span>
<span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">long</span> delay, TimeUnit unit)</code></pre></div>

<h2 id="10-4-底层实现"><a href="#10-4-底层实现" class="headerlink" title="10. 4 底层实现"></a>10. 4 底层实现</h2><p>我们通过查看源码，点击了Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool能够发现底层都是使用了ThreadPoolExecutor</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/10_%E7%BA%BF%E7%A8%8B%E6%B1%A0/images/image-20200317182004293.png" alt="image-20200317182004293"></p>
<p>我们可以看到线程池的内部，还使用到了LinkedBlockingQueue 链表阻塞队列</p>
<p>同时在查看Executors.newCacheThreadPool 看到底层用的是 SynchronousBlockingQueue阻塞队列</p>
<p>最后查看一下，完整的三个创建线程的方法</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/10_%E7%BA%BF%E7%A8%8B%E6%B1%A0/images/image-20200317183202992.png" alt="image-20200317183202992"></p>
<h2 id="10-5-线程池的重要参数"><a href="#10-5-线程池的重要参数" class="headerlink" title="10. 5 线程池的重要参数"></a>10. 5 线程池的重要参数</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/10_%E7%BA%BF%E7%A8%8B%E6%B1%A0/images/image-20200317183600957.png" alt="image-20200317183600957"></p>
<p>线程池在创建的时候，一共有7大参数</p>
<ul>
<li>corePoolSize：核心线程数，线程池中的常驻核心线程数<ul>
<li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li>
<li>当线程池中的线程数目达到corePoolSize后，就会把到达的队列放到缓存队列中</li>
</ul>
</li>
<li>maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1、<ul>
<li>相当有扩容后的线程数，这个线程池能容纳的最多线程数</li>
</ul>
</li>
<li>keepAliveTime：多余的空闲线程存活时间<ul>
<li>当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的空闲线程会被销毁，直到只剩下corePoolSize个线程为止</li>
<li>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</li>
</ul>
</li>
<li>unit：keepAliveTime的单位</li>
<li>workQueue：任务队列，被提交的但未被执行的任务（类似于银行里面的候客区）<ul>
<li>LinkedBlockingQueue：链表阻塞队列</li>
<li>SynchronousBlockingQueue：同步阻塞队列</li>
</ul>
</li>
<li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程池 一般用默认即可</li>
<li>handler：拒绝策略，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的Runnable的策略</li>
</ul>
<p>当营业窗口和阻塞队列中都满了时候，就需要设置拒绝策略</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/10_%E7%BA%BF%E7%A8%8B%E6%B1%A0/images/image-20200317201150197.png" alt="image-20200317201150197"></p>
<h2 id="10-6-拒绝策略"><a href="#10-6-拒绝策略" class="headerlink" title="10.6 拒绝策略"></a>10.6 拒绝策略</h2><p>以下所有拒绝策略都实现了RejectedExecutionHandler接口</p>
<ul>
<li>AbortPolicy：默认，直接抛出RejectedExcutionException异常，阻止系统正常运行</li>
<li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li>
<li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者</li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li>
</ul>
<h2 id="10-7-线程池底层工作原理"><a href="#10-7-线程池底层工作原理" class="headerlink" title="10.7 线程池底层工作原理"></a>10.7 线程池底层工作原理</h2><h3 id="线程池运行架构图"><a href="#线程池运行架构图" class="headerlink" title="线程池运行架构图"></a>线程池运行架构图</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/10_%E7%BA%BF%E7%A8%8B%E6%B1%A0/images/image-20200318154414717.png" alt="image-20200318154414717"></p>
<p>文字说明</p>
<ol>
<li><p>在创建了线程池后，等待提交过来的任务请求</p>
</li>
<li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断</p>
<ol>
<li>如果正在运行的线程池数量小于corePoolSize，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列</li>
<li>如果这时候队列满了，并且正在运行的线程数量还小于maximumPoolSize，那么还是创建非核心线程like运行这个任务；</li>
<li>如果队列满了并且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</li>
</ol>
</li>
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p>
</li>
<li><p>当一个线程无事可做操作一定的时间(keepAliveTime)时，线程池会判断：</p>
<ol>
<li>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉</li>
<li>所以线程池的所有任务完成后，它会最终收缩到corePoolSize的大小</li>
</ol>
</li>
</ol>
<p>以顾客去银行办理业务为例，谈谈线程池的底层工作原理</p>
<ol>
<li>最开始假设来了两个顾客，因为corePoolSize为2，因此这两个顾客直接能够去窗口办理</li>
<li>后面又来了三个顾客，因为corePool已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待</li>
<li>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li>
<li>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略</li>
<li>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</li>
</ol>
<h2 id="10-8-为什么不用默认创建的线程池？"><a href="#10-8-为什么不用默认创建的线程池？" class="headerlink" title="10.8 为什么不用默认创建的线程池？"></a>10.8 为什么不用默认创建的线程池？</h2><p>线程池创建的方法有：固定数的，单一的，可变的，那么在实际开发中，应该使用哪个？</p>
<p>我们一个都不用，在生产环境中是使用自己自定义的</p>
<p>为什么不用 Executors 中JDK提供的？</p>
<p>根据阿里巴巴手册：并发控制这章</p>
<ul>
<li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程<ul>
<li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</li>
</ul>
</li>
<li>线程池不允许使用Executors去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险<ul>
<li>Executors返回的线程池对象弊端如下：<ul>
<li>FixedThreadPool和SingleThreadPool：<ul>
<li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li>
</ul>
</li>
<li>CacheThreadPool和ScheduledThreadPool<ul>
<li>运行的请求队列长度为：Integer.MAX_VALUE，线程数上限太大导致oom</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="10-9-手写线程池"><a href="#10-9-手写线程池" class="headerlink" title="10.9 手写线程池"></a>10.9 手写线程池</h2><h3 id="1-采用默认拒绝策略"><a href="#1-采用默认拒绝策略" class="headerlink" title="1 采用默认拒绝策略"></a>1 采用默认拒绝策略</h3><p>从上面我们知道，因为默认的Executors创建的线程池，底层都是使用LinkBlockingQueue作为阻塞队列的，而LinkBlockingQueue虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有20多亿，可以相当是无界的了，因此我们要使用ThreadPoolExecutor自己手动创建线程池，然后指定阻塞队列的大小</p>
<p>下面我们创建了一个 核心线程数为2，最大线程数为5，并且阻塞队列数为3的线程池</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 手写线程池</span>
<span class="hljs-keyword">final</span> Integer corePoolSize = <span class="hljs-number">2</span>;
<span class="hljs-keyword">final</span> Integer maximumPoolSize = <span class="hljs-number">5</span>;
<span class="hljs-keyword">final</span> Long keepAliveTime = <span class="hljs-number">1L</span>;

<span class="hljs-comment">// 自定义线程池，只改变了LinkBlockingQueue的队列大小</span>
ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(
    corePoolSize,
    maximumPoolSize,
    keepAliveTime,
    TimeUnit.SECONDS,
    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>),
    Executors.defaultThreadFactory(),
    <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());</code></pre></div>

<p>然后使用for循环，模拟10个用户来进行请求</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span>
<span class="hljs-keyword">try</span> &#123;

    <span class="hljs-comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
        executorService.execute(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="hljs-string">&quot; 办理业务&quot;</span>);
        &#125;);
    &#125;
&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
    e.printStackTrace();
&#125; <span class="hljs-keyword">finally</span> &#123;
    executorService.shutdown();
&#125;</code></pre></div>

<p>但是在用户执行到第九个的时候，触发了异常，程序中断</p>
<div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">0</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">6</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">5</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">1</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">4</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">7</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">2</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">3</span> 办理业务
java.util.concurrent.RejectedExecutionException: Task com.moxi.interview.study.thread.MyThreadPoolDemo$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">1747585824</span>@4dd8dc3 rejected from java.util.concurrent.ThreadPoolExecutor@6d03e736[Running, pool size = <span class="hljs-number">5</span>, active threads = <span class="hljs-number">3</span>, queued tasks = <span class="hljs-number">0</span>, completed tasks = <span class="hljs-number">5</span>]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="hljs-number">2047</span>)
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="hljs-number">823</span>)
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="hljs-number">1369</span>)
	at com.moxi.interview.study.thread.MyThreadPoolDemo.main(MyThreadPoolDemo.java:<span class="hljs-number">34</span>)</code></pre></div>

<p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的AbortPolicy，也就是抛异常的</p>
<p>触发条件是，请求的线程大于 阻塞队列大小 + 最大线程数 = 8 的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p>
<h3 id="2-采用CallerRunsPolicy拒绝策略"><a href="#2-采用CallerRunsPolicy拒绝策略" class="headerlink" title="2 采用CallerRunsPolicy拒绝策略"></a>2 采用CallerRunsPolicy拒绝策略</h3><p>当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为回退策略，就是把任务丢回原来的请求开启线程着，我们看运行结果</p>
<div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">0</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">7</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">6</span> 办理业务
main	 给用户:<span class="hljs-number">8</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">5</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">1</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">9</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">4</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">3</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">2</span> 办理业务</code></pre></div>

<p>我们发现，输出的结果里面出现了main线程，因为线程池出发了拒绝策略，把任务回退到main线程，然后main线程对任务进行处理</p>
<h3 id="3-采用-DiscardPolicy-拒绝策略"><a href="#3-采用-DiscardPolicy-拒绝策略" class="headerlink" title="3 采用 DiscardPolicy 拒绝策略"></a>3 采用 DiscardPolicy 拒绝策略</h3><div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">0</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">5</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">2</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">1</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">4</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">7</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">6</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">3</span> 办理业务</code></pre></div>

<p>采用DiscardPolicy拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</p>
<h3 id="4-采用DiscardOldestPolicy拒绝策略"><a href="#4-采用DiscardOldestPolicy拒绝策略" class="headerlink" title="4 采用DiscardOldestPolicy拒绝策略"></a>4 采用DiscardOldestPolicy拒绝策略</h3><div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">0</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">6</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">4</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">5</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">1</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">9</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">8</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">7</span> 办理业务</code></pre></div>

<p>这个策略和刚刚差不多，会把最久的队列中的任务替换掉</p>
<h2 id="10-10-线程池的合理参数"><a href="#10-10-线程池的合理参数" class="headerlink" title="10.10 线程池的合理参数"></a>10.10 线程池的合理参数</h2><p>生产环境中如何配置 corePoolSize 和 maximumPoolSize</p>
<p>这个是根据具体业务来配置的，分为CPU密集型和IO密集型</p>
<ul>
<li>CPU密集型</li>
</ul>
<p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p>
<p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p>
<p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</p>
<p>CPU密集型任务配置尽可能少的线程数量：</p>
<p>一般公式：CPU核数 + 1个线程数</p>
<ul>
<li>IO密集型</li>
</ul>
<p>由于IO密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p>
<p>IO密集型，即该任务需要大量的IO操作，即大量的阻塞</p>
<p>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力花费在等待上</p>
<p>所以IO密集型任务中使用多线程可以大大的加速程序的运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p>
<p>IO密集时，大部分线程都被阻塞，故需要多配置线程数：</p>
<p>参考公式：CPU核数 / (1 - 阻塞系数)      阻塞系数在0.8 ~ 0.9左右</p>
<p>例如：8核CPU：8/ (1 - 0.9) = 80个线程数</p>
<h1 id="第11章-死锁编码及定位分析"><a href="#第11章-死锁编码及定位分析" class="headerlink" title="第11章 死锁编码及定位分析"></a>第11章 死锁编码及定位分析</h1><h2 id="11-1-概念"><a href="#11-1-概念" class="headerlink" title="11.1 概念"></a>11.1 概念</h2><p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/11_%E6%AD%BB%E9%94%81%E7%BC%96%E7%A0%81%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/images/image-20200318175441578.png" alt="image-20200318175441578"></p>
<h2 id="11-2-产生死锁的原因"><a href="#11-2-产生死锁的原因" class="headerlink" title="11.2 产生死锁的原因"></a>11.2 产生死锁的原因</h2><ul>
<li>系统资源不足</li>
<li>进程运行推进的顺序不对</li>
<li>资源分配不当</li>
</ul>
<h2 id="11-3-死锁产生的四个必要条件"><a href="#11-3-死锁产生的四个必要条件" class="headerlink" title="11.3 死锁产生的四个必要条件"></a>11.3 死锁产生的四个必要条件</h2><ul>
<li>互斥<ul>
<li>解决方法：把互斥的共享资源封装成可同时访问</li>
</ul>
</li>
<li>占有且等待<ul>
<li>解决方法：进程请求资源时，要求它不占有任何其它资源，也就是它必须一次性申请到所有的资源，这种方式会导致资源效率低。</li>
</ul>
</li>
<li>非抢占式<ul>
<li>解决方法：如果进程不能立即分配资源，要求它不占有任何其他资源，也就是只能够同时获得所有需要资源时，才执行分配操作</li>
</ul>
</li>
<li>循环等待<ul>
<li>解决方法：对资源进行排序，要求进程按顺序请求资源。</li>
</ul>
</li>
</ul>
<h2 id="11-4-死锁代码"><a href="#11-4-死锁代码" class="headerlink" title="11.4 死锁代码"></a>11.4 死锁代码</h2><p>我们创建了一个资源类，然后让两个线程分别持有自己的锁，同时在尝试获取别人的，就会出现死锁现象</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 死锁小Demo</span>
<span class="hljs-comment"> * 死锁是指两个或多个以上的进程在执行过程中，</span>
<span class="hljs-comment"> * 因争夺资源而造成一种互相等待的现象，</span>
<span class="hljs-comment"> * 若无外力干涉那他们都将无法推进下去</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HoldLockThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;

    <span class="hljs-keyword">private</span> String lockA;
    <span class="hljs-keyword">private</span> String lockB;

    <span class="hljs-comment">// 持有自己的锁，还想得到别人的锁</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HoldLockThread</span><span class="hljs-params">(String lockA, String lockB)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.lockA = lockA;
        <span class="hljs-keyword">this</span>.lockB = lockB;
    &#125;


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">synchronized</span> (lockA) &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 自己持有&quot;</span> + lockA + <span class="hljs-string">&quot;\t 尝试获取：&quot;</span> + lockB);

            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            <span class="hljs-keyword">synchronized</span> (lockB) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 自己持有&quot;</span> + lockB + <span class="hljs-string">&quot;\t 尝试获取：&quot;</span> + lockA);
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        String lockA = <span class="hljs-string">&quot;lockA&quot;</span>;
        String lockB = <span class="hljs-string">&quot;lockB&quot;</span>;

        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> HoldLockThread(lockA, lockB), <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> HoldLockThread(lockB, lockA), <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p>运行结果，main线程无法结束</p>
<div class="code-wrapper"><pre><code class="hljs java">t1	 自己持有lockA	 尝试获取：lockB
t2	 自己持有lockB	 尝试获取：lockA</code></pre></div>

<h2 id="11-5-如何排查死锁"><a href="#11-5-如何排查死锁" class="headerlink" title="11.5 如何排查死锁"></a>11.5 如何排查死锁</h2><p>当我们出现死锁的时候，首先需要使用jps命令查看运行的程序</p>
<div class="code-wrapper"><pre><code class="hljs java">jps -l</code></pre></div>

<p>我们能看到DeadLockDemo这个类，一直在运行</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/97b22942b4818475ad6ba9b32058aaa823789290/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/JUC/11_%E6%AD%BB%E9%94%81%E7%BC%96%E7%A0%81%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/images/image-20200318181504703.png" alt="image-20200318181504703"></p>
<p>在使用jstack查看堆栈信息</p>
<div class="code-wrapper"><pre><code class="hljs java">jstack  7560   # 后面参数是 jps输出的该类的pid</code></pre></div>

<p>得到的结果</p>
<div class="code-wrapper"><pre><code class="hljs java">Found one Java-level deadlock:
=============================
<span class="hljs-string">&quot;t2&quot;</span>:
  waiting to lock monitor <span class="hljs-number">0x000000001cfc0de8</span> (object <span class="hljs-number">0x000000076b696e80</span>, a java.lang.String),
  which is held by <span class="hljs-string">&quot;t1&quot;</span>
<span class="hljs-string">&quot;t1&quot;</span>:
  waiting to lock monitor <span class="hljs-number">0x000000001cfc3728</span> (object <span class="hljs-number">0x000000076b696eb8</span>, a java.lang.String),
  which is held by <span class="hljs-string">&quot;t2&quot;</span>

Java stack information <span class="hljs-keyword">for</span> the threads listed above:
===================================================
<span class="hljs-string">&quot;t2&quot;</span>:
        at com.moxi.interview.study.Lock.HoldLockThread.run(DeadLockDemo.java:<span class="hljs-number">42</span>)
        - waiting to lock &lt;<span class="hljs-number">0x000000076b696e80</span>&gt; (a java.lang.String)
        - locked &lt;<span class="hljs-number">0x000000076b696eb8</span>&gt; (a java.lang.String)
        at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)
<span class="hljs-string">&quot;t1&quot;</span>:
        at com.moxi.interview.study.Lock.HoldLockThread.run(DeadLockDemo.java:<span class="hljs-number">42</span>)
        - waiting to lock &lt;<span class="hljs-number">0x000000076b696eb8</span>&gt; (a java.lang.String)
        - locked &lt;<span class="hljs-number">0x000000076b696e80</span>&gt; (a java.lang.String)
        at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)

Found <span class="hljs-number">1</span> deadlock.</code></pre></div>

<p>通过查看最后一行，我们看到  Found 1 deadlock，即存在一个死锁</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty 学习</title>
    <url>/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Netty-学习"><a href="#Netty-学习" class="headerlink" title="Netty 学习"></a>Netty 学习</h1><h2 id="1-Netty-介绍和应用场景"><a href="#1-Netty-介绍和应用场景" class="headerlink" title="1 Netty 介绍和应用场景"></a>1 Netty 介绍和应用场景</h2><h3 id="1-1-本课程的学习要求"><a href="#1-1-本课程的学习要求" class="headerlink" title="1.1 本课程的学习要求"></a>1.1 本课程的学习要求</h3><ol>
<li>本课程不适用于 <code>0</code> 基础的学员。</li>
<li>要求已经掌握了 <code>Java</code> 编程，主要技术构成：<code>Java OOP</code> 编程、<code>Java</code> 多线程编程、<code>Java IO</code> 编程、<code>Java</code> 网络编程、常用的 <code>Java</code> 设计模式（比如观察者模式，命令模式，职责链模式）、常用的数据结构（比如链表）。</li>
<li>本课程的《<code>Netty</code> 核心源码剖析章节》要求学员最好有项目开发和阅读源码的经历。</li>
</ol>
<h3 id="1-2-Netty-的介绍"><a href="#1-2-Netty-的介绍" class="headerlink" title="1.2 Netty 的介绍"></a>1.2 Netty 的介绍</h3><ol>
<li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li>
<li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li>
<li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li>
<li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li>
<li>要透彻理解 <code>Netty</code>，需要先学习 <code>NIO</code>，这样我们才能阅读 <code>Netty</code> 的源码。</li>
</ol>
<h3 id="1-3-Netty-的应用场景"><a href="#1-3-Netty-的应用场景" class="headerlink" title="1.3 Netty 的应用场景"></a>1.3 Netty 的应用场景</h3><h4 id="1-3-1-互联网行业"><a href="#1-3-1-互联网行业" class="headerlink" title="1.3.1 互联网行业"></a>1.3.1 互联网行业</h4><ol>
<li><p>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <code>RPC</code> 框架必不可少，<code>Netty</code> 作为异步高性能的通信框架，往往作为基础通信组件被这些 <code>RPC</code> 框架使用。</p>
</li>
<li><p>典型的应用有：阿里分布式服务框架 <code>Dubbo</code> 的 <code>RPC</code> 框 架使用 <code>Dubbo</code> 协议进行节点间通信，<code>Dubbo</code> 协议默认使用 <code>Netty</code> 作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_01.png" alt></p>
</li>
</ol>
<h4 id="1-3-2-游戏行业"><a href="#1-3-2-游戏行业" class="headerlink" title="1.3.2 游戏行业"></a>1.3.2 游戏行业</h4><ol>
<li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用。</li>
<li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器。</li>
<li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信。</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_02.png" alt></p>
<p>​                    <img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_03.png" alt></p>
<h4 id="1-3-3-大数据领域"><a href="#1-3-3-大数据领域" class="headerlink" title="1.3.3 大数据领域"></a>1.3.3 大数据领域</h4><ol>
<li>经典的 <code>Hadoop</code> 的高性能通信和序列化组件 <code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信。</li>
<li>它的 <code>NettyService</code> 基于 <code>Netty</code> 框架二次封装实现。</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_04.png" alt></p>
<h4 id="1-3-4-其他开源项目使用到-Netty"><a href="#1-3-4-其他开源项目使用到-Netty" class="headerlink" title="1.3.4 其他开源项目使用到 Netty"></a>1.3.4 其他开源项目使用到 Netty</h4><p>网址：<a href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a></p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_05.png" alt></p>
<h3 id="1-4-Netty-的学习资料的参考"><a href="#1-4-Netty-的学习资料的参考" class="headerlink" title="1.4 Netty 的学习资料的参考"></a>1.4 Netty 的学习资料的参考</h3><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/59141c1dN7a93c127.jpg" alt></p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/555080b2Ne6cbf9e3.jpg" alt></p>
<h2 id="2-Java-BIO-编程"><a href="#2-Java-BIO-编程" class="headerlink" title="2 Java BIO 编程"></a>2 Java BIO 编程</h2><h3 id="2-1-I-O-模型"><a href="#2-1-I-O-模型" class="headerlink" title="2.1 I/O 模型"></a>2.1 I/O 模型</h3><h4 id="2-1-1-模型基本说明"><a href="#2-1-1-模型基本说明" class="headerlink" title="2.1.1 模型基本说明"></a>2.1.1 模型基本说明</h4><ol>
<li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li>
<li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li>
<li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_01.png" alt></p>
<ol start="4">
<li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_02.png" alt></p>
<ol start="5">
<li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li>
</ol>
<h3 id="2-2-BIO、NIO、AIO-使用场景分析"><a href="#2-2-BIO、NIO、AIO-使用场景分析" class="headerlink" title="2.2  BIO、NIO、AIO 使用场景分析"></a>2.2  BIO、NIO、AIO 使用场景分析</h3><ol>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li>
<li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li>
<li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li>
</ol>
<h3 id="2-3-Java-BIO-的基本介绍"><a href="#2-3-Java-BIO-的基本介绍" class="headerlink" title="2.3 Java BIO 的基本介绍"></a>2.3 Java BIO 的基本介绍</h3><ol>
<li><code>Java BIO</code>就是传统的<code>Java I/O</code>编程，其相关的类和接口在<code>java.io</code>。</li>
<li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户端连接服务器）。</li>
<li><code>BIO</code>方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code>以前的唯一选择，程序简易理解。</li>
</ol>
<h3 id="2-4-Java-BIO-的工作机制"><a href="#2-4-Java-BIO-的工作机制" class="headerlink" title="2.4 Java BIO 的工作机制"></a>2.4 Java BIO 的工作机制</h3><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_03.png" alt></p>
<p>对<code>BIO</code>编程流程的梳理</p>
<ol>
<li>服务器端启动一个<code>ServerSocket</code>。</li>
<li>客户端启动<code>Socket</code>对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通信。</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li>
<li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li>
</ol>
<h3 id="2-5-Java-BIO-应用实例"><a href="#2-5-Java-BIO-应用实例" class="headerlink" title="2.5 Java BIO 应用实例"></a>2.5 Java BIO 应用实例</h3><p>实例说明：</p>
<ol>
<li><p>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</p>
</li>
<li><p>要求使用线程池机制改善，可以连接多个客户端。</p>
</li>
<li><p>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</p>
</li>
<li><p>代码演示</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.bio;

<span class="hljs-keyword">import</span> java.io.InputStream;
<span class="hljs-keyword">import</span> java.net.ServerSocket;
<span class="hljs-keyword">import</span> java.net.Socket;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIOServer</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 线程池机制</span>
        <span class="hljs-comment">// 思路</span>
        <span class="hljs-comment">// 1. 创建一个线程池</span>
        <span class="hljs-comment">// 2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span>
        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();
        <span class="hljs-comment">// 创建 ServerSocket</span>
        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);
        System.out.println(<span class="hljs-string">&quot;服务器启动了&quot;</span>);
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());
            <span class="hljs-comment">// 监听，等待客户端连接</span>
            System.out.println(<span class="hljs-string">&quot;等待连接....&quot;</span>);
            <span class="hljs-keyword">final</span> Socket socket = serverSocket.accept();
            System.out.println(<span class="hljs-string">&quot;连接到一个客户端&quot;</span>);
            <span class="hljs-comment">// 就创建一个线程，与之通讯(单独写一个方法)</span>
            newCachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 我们重写</span>
                    <span class="hljs-comment">// 可以和客户端通讯</span>
                    handler(socket);
                &#125;
            &#125;);
        &#125;
    &#125;

    <span class="hljs-comment">// 编写一个handler方法，和客户端通讯</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Socket socket)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());
            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];
            <span class="hljs-comment">// 通过socket获取输入流</span>
            InputStream inputStream = socket.getInputStream();
            <span class="hljs-comment">// 循环的读取客户端发送的数据</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());
                System.out.println(<span class="hljs-string">&quot;read....&quot;</span>);
                <span class="hljs-keyword">int</span> read = inputStream.read(bytes);
                <span class="hljs-keyword">if</span> (read != -<span class="hljs-number">1</span>) &#123;
                    System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));<span class="hljs-comment">// 输出客户端发送的数据</span>
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            System.out.println(<span class="hljs-string">&quot;关闭和client的连接&quot;</span>);
            <span class="hljs-keyword">try</span> &#123;
                socket.close();
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

</li>
</ol>
<h3 id="2-6-Java-BIO-问题分析"><a href="#2-6-Java-BIO-问题分析" class="headerlink" title="2.6 Java BIO 问题分析"></a>2.6 Java BIO 问题分析</h3><ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li>
</ol>
<h2 id="3-Java-NIO-编程"><a href="#3-Java-NIO-编程" class="headerlink" title="3 Java NIO 编程"></a>3 Java NIO 编程</h2><h3 id="3-1-Java-NIO-基本介绍"><a href="#3-1-Java-NIO-基本介绍" class="headerlink" title="3.1 Java NIO 基本介绍"></a>3.1 Java NIO 基本介绍</h3><ol>
<li><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong>，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li>
<li><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li>
<li><code>NIO</code> 有三大核心部分：<strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</li>
<li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li>
<li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li>
<li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li>
<li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li>
<li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.nio.IntBuffer;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicBuffer</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">//举例说明 Buffer 的使用(简单说明)</span>
        <span class="hljs-comment">//创建一个 Buffer，大小为 5，即可以存放 5 个 int</span>
        IntBuffer intBuffer = IntBuffer.allocate(<span class="hljs-number">5</span>);

        <span class="hljs-comment">//向buffer存放数据</span>
        <span class="hljs-comment">//intBuffer.put(10);</span>
        <span class="hljs-comment">//intBuffer.put(11);</span>
        <span class="hljs-comment">//intBuffer.put(12);</span>
        <span class="hljs-comment">//intBuffer.put(13);</span>
        <span class="hljs-comment">//intBuffer.put(14);</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;
            intBuffer.put(i * <span class="hljs-number">2</span>);
        &#125;
        <span class="hljs-comment">//如何从 buffer 读取数据</span>
        <span class="hljs-comment">//将 buffer 转换，读写切换(!!!)</span>
        intBuffer.flip();
        <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;
            System.out.println(intBuffer.get());
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="3-2-NIO-和-BIO-的比较"><a href="#3-2-NIO-和-BIO-的比较" class="headerlink" title="3.2 NIO 和 BIO 的比较"></a>3.2 NIO 和 BIO 的比较</h3><ol>
<li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li>
<li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li>
<li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li>
</ol>
<h3 id="3-3-NIO-三大核心原理示意图"><a href="#3-3-NIO-三大核心原理示意图" class="headerlink" title="3.3 NIO 三大核心原理示意图"></a>3.3 NIO 三大核心原理示意图</h3><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p>
<h4 id="3-3-1-Selector、Channel-和-Buffer-关系图（简单版）"><a href="#3-3-1-Selector、Channel-和-Buffer-关系图（简单版）" class="headerlink" title="3.3.1 Selector、Channel 和 Buffer 关系图（简单版）"></a>3.3.1 Selector、Channel 和 Buffer 关系图（简单版）</h4><p>关系图的说明:</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_01.png" alt="img"></p>
<ol>
<li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li>
<li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li>
<li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li>
<li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li>
<li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li>
<li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li>
<li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li>
</ol>
<h3 id="3-4-缓冲区（Buffer）"><a href="#3-4-缓冲区（Buffer）" class="headerlink" title="3.4 缓冲区（Buffer）"></a>3.4 缓冲区（Buffer）</h3><h4 id="3-4-1-基本介绍"><a href="#3-4-1-基本介绍" class="headerlink" title="3.4.1 基本介绍"></a>3.4.1 基本介绍</h4><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_02.png" alt="img"></p>
<h4 id="3-4-2-Buffer-类及其子类"><a href="#3-4-2-Buffer-类及其子类" class="headerlink" title="3.4.2 Buffer 类及其子类"></a>3.4.2 Buffer 类及其子类</h4><ol>
<li>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_03.png" alt="img"></p>
<ol>
<li><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_05.png" alt="img"></p>
<ol>
<li><code>Buffer</code> 类相关方法一览</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_06.png" alt="img"></p>
<h4 id="3-4-3-ByteBuffer"><a href="#3-4-3-ByteBuffer" class="headerlink" title="3.4.3 ByteBuffer"></a>3.4.3 ByteBuffer</h4><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_07.png" alt="img"></p>
<h3 id="3-5-通道（Channel）"><a href="#3-5-通道（Channel）" class="headerlink" title="3.5 通道（Channel）"></a>3.5 通道（Channel）</h3><h4 id="3-5-0-基本介绍"><a href="#3-5-0-基本介绍" class="headerlink" title="3.5.0 基本介绍"></a>3.5.0 基本介绍</h4><ol>
<li><p><code>NIO</code> 的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
</li>
<li><p><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</p>
</li>
<li><p><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></p>
</li>
<li><p>常用的 <code>Channel</code> 类有：<strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong>。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</p>
</li>
<li><p><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</p>
</li>
<li><p>图示</p>
</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_08.png" alt="img"></p>
<h4 id="3-5-1-FileChannel-类"><a href="#3-5-1-FileChannel-类" class="headerlink" title="3.5.1 FileChannel 类"></a>3.5.1 FileChannel 类</h4><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p>
<ul>
<li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li>
<li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li>
<li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li>
<li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li>
</ul>
<h4 id="3-5-2-应用实例1-本地文件写数据"><a href="#3-5-2-应用实例1-本地文件写数据" class="headerlink" title="3.5.2 应用实例1 - 本地文件写数据"></a>3.5.2 应用实例1 - 本地文件写数据</h4><p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li>
<li>文件不存在就创建</li>
<li>代码演示</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.io.FileOutputStream;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel01</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        String str = <span class="hljs-string">&quot;hello,尚硅谷&quot;</span>;
        <span class="hljs-comment">//创建一个输出流 -&gt; channel</span>
        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d:\\file01.txt&quot;</span>);

        <span class="hljs-comment">//通过 fileOutputStream 获取对应的 FileChannel</span>
        <span class="hljs-comment">//这个 fileChannel 真实类型是 FileChannelImpl</span>
        FileChannel fileChannel = fileOutputStream.getChannel();

        <span class="hljs-comment">//创建一个缓冲区 ByteBuffer</span>
        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);

        <span class="hljs-comment">//将 str 放入 byteBuffer</span>
        byteBuffer.put(str.getBytes());

        <span class="hljs-comment">//对 byteBuffer 进行 flip</span>
        byteBuffer.flip();

        <span class="hljs-comment">//将 byteBuffer 数据写入到 fileChannel</span>
        fileChannel.write(byteBuffer);
        fileOutputStream.close();
    &#125;
&#125;</code></pre></div>

<h4 id="3-5-3-应用实例2-本地文件读数据"><a href="#3-5-3-应用实例2-本地文件读数据" class="headerlink" title="3.5.3 应用实例2 - 本地文件读数据"></a>3.5.3 应用实例2 - 本地文件读数据</h4><p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li>
<li>假定文件已经存在</li>
<li>代码演示</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel02</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//创建文件的输入流</span>
        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\file01.txt&quot;</span>);
        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);
        
        <span class="hljs-comment">//通过 fileInputStream 获取对应的 FileChannel -&gt; 实际类型 FileChannelImpl</span>
        FileChannel fileChannel = fileInputStream.getChannel();
        
        <span class="hljs-comment">//创建缓冲区</span>
        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="hljs-keyword">int</span>)file.length());
        
        <span class="hljs-comment">//将通道的数据读入到 Buffer</span>
        fileChannel.read(byteBuffer);
        
        <span class="hljs-comment">//将 byteBuffer 的字节数据转成 String</span>
        System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array()));
        fileInputStream.close();
    &#125;
&#125;</code></pre></div>

<h4 id="3-5-4-应用实例3-使用一个-Buffer-完成文件读取、写入"><a href="#3-5-4-应用实例3-使用一个-Buffer-完成文件读取、写入" class="headerlink" title="3.5.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入"></a>3.5.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入</h4><p>实例要求：</p>
<ol>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li>
<li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li>
<li>代码演示</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_09.png" alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.FileOutputStream;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel03</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;1.txt&quot;</span>);
        FileChannel fileChannel01 = fileInputStream.getChannel();
        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;2.txt&quot;</span>);
        FileChannel fileChannel02 = fileOutputStream.getChannel();

        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);
        
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123; <span class="hljs-comment">//循环读取</span>

            <span class="hljs-comment">//这里有一个重要的操作，一定不要忘了</span>
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">            public final Buffer clear() &#123;</span>
<span class="hljs-comment">                position = 0;</span>
<span class="hljs-comment">                limit = capacity;</span>
<span class="hljs-comment">                mark = -1;</span>
<span class="hljs-comment">                return this;</span>
<span class="hljs-comment">            &#125;</span>
<span class="hljs-comment">            */</span>
            byteBuffer.clear(); <span class="hljs-comment">//清空 buffer</span>
            <span class="hljs-keyword">int</span> read = fileChannel01.read(byteBuffer);
            System.out.println(<span class="hljs-string">&quot;read = &quot;</span> + read);
            <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//表示读完</span>
                <span class="hljs-keyword">break</span>;
            &#125;

            <span class="hljs-comment">//将 buffer 中的数据写入到 fileChannel02--2.txt</span>
            byteBuffer.flip();
            fileChannel02.write(byteBuffer);
        &#125;

        <span class="hljs-comment">//关闭相关的流</span>
        fileInputStream.close();
        fileOutputStream.close();
    &#125;
&#125;</code></pre></div>

<h4 id="3-5-5-应用实例4-拷贝文件-transferFrom-方法"><a href="#3-5-5-应用实例4-拷贝文件-transferFrom-方法" class="headerlink" title="3.5.5 应用实例4 - 拷贝文件 transferFrom 方法"></a>3.5.5 应用实例4 - 拷贝文件 transferFrom 方法</h4><ol>
<li>实例要求：</li>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li>
<li>拷贝一张图片</li>
<li>代码演示</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.FileOutputStream;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel04</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//创建相关流</span>
        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\a.jpg&quot;</span>);
        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d:\\a2.jpg&quot;</span>);
        
        <span class="hljs-comment">//获取各个流对应的 FileChannel</span>
        FileChannel sourceCh = fileInputStream.getChannel();
        FileChannel destCh = fileOutputStream.getChannel();

        <span class="hljs-comment">//使用 transferForm 完成拷贝</span>
        destCh.transferFrom(sourceCh, <span class="hljs-number">0</span>, sourceCh.size());

        <span class="hljs-comment">//关闭相关通道和流</span>
        sourceCh.close();
        destCh.close();
        fileInputStream.close();
        fileOutputStream.close();
    &#125;
&#125;</code></pre></div>

<h4 id="3-5-6-关于-Buffer-和-Channel-的注意事项和细节"><a href="#3-5-6-关于-Buffer-和-Channel-的注意事项和细节" class="headerlink" title="3.5.6 关于 Buffer 和 Channel 的注意事项和细节"></a>3.5.6 关于 Buffer 和 Channel 的注意事项和细节</h4><ol>
<li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.nio.ByteBuffer;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOByteBufferPutGet</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        
        <span class="hljs-comment">//创建一个 Buffer</span>
        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);

        <span class="hljs-comment">//类型化方式放入数据</span>
        buffer.putInt(<span class="hljs-number">100</span>);
        buffer.putLong(<span class="hljs-number">9</span>);
        buffer.putChar(<span class="hljs-string">&#x27;尚&#x27;</span>);
        buffer.putShort((<span class="hljs-keyword">short</span>) <span class="hljs-number">4</span>);

        <span class="hljs-comment">//取出</span>
        buffer.flip();
        
        System.out.println();
        
        System.out.println(buffer.getInt());
        System.out.println(buffer.getLong());
        System.out.println(buffer.getChar());
        System.out.println(buffer.getShort());
    &#125;
&#125;</code></pre></div>

<ol start="2">
<li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.nio.ByteBuffer;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadOnlyBuffer</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">//创建一个 buffer</span>
        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;
            buffer.put((<span class="hljs-keyword">byte</span>) i);
        &#125;

        <span class="hljs-comment">//读取</span>
        buffer.flip();

        <span class="hljs-comment">//得到一个只读的 Buffer</span>
        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();
        System.out.println(readOnlyBuffer.getClass());

        <span class="hljs-comment">//读取</span>
        <span class="hljs-keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123;
            System.out.println(readOnlyBuffer.get());
        &#125;

        readOnlyBuffer.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">100</span>); <span class="hljs-comment">//ReadOnlyBufferException</span>
    &#125;
&#125;</code></pre></div>

<ol start="3">
<li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.io.RandomAccessFile;
<span class="hljs-keyword">import</span> java.nio.MappedByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MappedByteBufferTest</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        RandomAccessFile randomAccessFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);
        <span class="hljs-comment">//获取对应的通道</span>
        FileChannel channel = randomAccessFile.getChannel();

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式</span>
<span class="hljs-comment">         * 参数 2：0：可以直接修改的起始位置</span>
<span class="hljs-comment">         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span>
<span class="hljs-comment">         * 可以直接修改的范围就是 0-5</span>
<span class="hljs-comment">         * 实际类型 DirectByteBuffer</span>
<span class="hljs-comment">         */</span>
        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);

        mappedByteBuffer.put(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;H&#x27;</span>);
        mappedByteBuffer.put(<span class="hljs-number">3</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;9&#x27;</span>);
        mappedByteBuffer.put(<span class="hljs-number">5</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;Y&#x27;</span>);<span class="hljs-comment">//IndexOutOfBoundsException</span>

        randomAccessFile.close();
        System.out.println(<span class="hljs-string">&quot;修改成功~~&quot;</span>);
    &#125;
&#125;</code></pre></div>

<ol start="4">
<li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;
<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;
<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]</span>
<span class="hljs-comment"> * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScatteringAndGatheringTest</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        
        <span class="hljs-comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span>
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7000</span>);

        <span class="hljs-comment">//绑定端口到 socket，并启动</span>
        serverSocketChannel.socket().bind(inetSocketAddress);

        <span class="hljs-comment">//创建 buffer 数组</span>
        ByteBuffer[] byteBuffers = <span class="hljs-keyword">new</span> ByteBuffer[<span class="hljs-number">2</span>];
        byteBuffers[<span class="hljs-number">0</span>] = ByteBuffer.allocate(<span class="hljs-number">5</span>);
        byteBuffers[<span class="hljs-number">1</span>] = ByteBuffer.allocate(<span class="hljs-number">3</span>);

        <span class="hljs-comment">//等客户端连接 (telnet)</span>
        SocketChannel socketChannel = serverSocketChannel.accept();

        <span class="hljs-keyword">int</span> messageLength = <span class="hljs-number">8</span>; <span class="hljs-comment">//假定从客户端接收 8 个字节</span>

        <span class="hljs-comment">//循环的读取</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            <span class="hljs-keyword">int</span> byteRead = <span class="hljs-number">0</span>;

            <span class="hljs-keyword">while</span> (byteRead &lt; messageLength) &#123;
                <span class="hljs-keyword">long</span> l = socketChannel.read(byteBuffers);
                byteRead += l; <span class="hljs-comment">//累计读取的字节数</span>
                System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead);
                <span class="hljs-comment">//使用流打印,看看当前的这个 buffer 的 position 和 limit</span>
                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="hljs-string">&quot;position = &quot;</span> + buffer.position() + <span class="hljs-string">&quot;, limit = &quot;</span> + buffer.limit()).forEach(System.out::println);
            &#125;

            <span class="hljs-comment">//将所有的 buffer 进行 flip</span>
            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());
            <span class="hljs-comment">//将数据读出显示到客户端</span>
            <span class="hljs-keyword">long</span> byteWirte = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (byteWirte &lt; messageLength) &#123;
                <span class="hljs-keyword">long</span> l = socketChannel.write(byteBuffers);<span class="hljs-comment">//</span>
                byteWirte += l;
            &#125;
            
            <span class="hljs-comment">//将所有的buffer进行clear</span>
            Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123;
                buffer.clear();
            &#125;);
            
            System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead + <span class="hljs-string">&quot;, byteWrite = &quot;</span> + byteWirte + <span class="hljs-string">&quot;, messagelength = &quot;</span> + messageLength);
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="3-6-Selector（选择器）"><a href="#3-6-Selector（选择器）" class="headerlink" title="3.6 Selector（选择器）"></a>3.6 Selector（选择器）</h3><h4 id="3-6-1-基本介绍"><a href="#3-6-1-基本介绍" class="headerlink" title="3.6.1 基本介绍"></a>3.6.1 基本介绍</h4><ol>
<li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li>
<li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</li>
<li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li>
<li>避免了多线程之间的上下文切换导致的开销。</li>
</ol>
<h4 id="3-6-2-Selector-示意图和特点说明"><a href="#3-6-2-Selector-示意图和特点说明" class="headerlink" title="3.6.2 Selector 示意图和特点说明"></a>3.6.2 Selector 示意图和特点说明</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_10.png" alt="img"></p>
<p>说明如下：</p>
<ol>
<li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li>
<li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li>
<li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li>
<li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li>
<li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li>
</ol>
<h4 id="3-6-3-Selector-类相关方法"><a href="#3-6-3-Selector-类相关方法" class="headerlink" title="3.6.3 Selector 类相关方法"></a>3.6.3 Selector 类相关方法</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_11.png" alt="img"></p>
<h4 id="3-6-4-注意事项"><a href="#3-6-4-注意事项" class="headerlink" title="3.6.4 注意事项"></a>3.6.4 注意事项</h4><ol>
<li><p><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</p>
</li>
<li><p><code>Selector</code> 相关方法说明</p>
<ul>
<li><code>selector.select();</code> //阻塞</li>
<li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li>
<li><code>selector.wakeup();</code> //唤醒 selector</li>
<li><code>selector.selectNow();</code> //不阻塞，立马返还</li>
</ul>
</li>
</ol>
<h3 id="3-7-NIO-非阻塞网络编程原理分析图"><a href="#3-7-NIO-非阻塞网络编程原理分析图" class="headerlink" title="3.7 NIO 非阻塞网络编程原理分析图"></a>3.7 NIO 非阻塞网络编程原理分析图</h3><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_22.png" alt="img"></p>
<p>对上图的说明：</p>
<ol>
<li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li>
<li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li>
<li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li>
<li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li>
<li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li>
<li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li>
<li>可以通过得到的 <code>channel</code>，完成业务处理。</li>
<li>代码撑腰。。。</li>
</ol>
<h3 id="3-8-NIO-非阻塞网络编程快速入门"><a href="#3-8-NIO-非阻塞网络编程快速入门" class="headerlink" title="3.8 NIO 非阻塞网络编程快速入门"></a>3.8 NIO 非阻塞网络编程快速入门</h3><p>案例要求：</p>
<ol>
<li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li>
<li>看老师代码演示</li>
</ol>
<h3 id="3-9-SelectionKey"><a href="#3-9-SelectionKey" class="headerlink" title="3.9 SelectionKey"></a>3.9 SelectionKey</h3><ol>
<li><code>SelectionKey</code>，表示 <code>Selector</code> 和网络通道的注册关系，共四种：<ul>
<li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li>
<li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li>
<li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li>
<li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li>
</ul>
</li>
</ol>
<p>源码中：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_READ = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_WRITE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_CONNECT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_ACCEPT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;</code></pre></div>

<ol start="2">
<li><code>SelectionKey</code> 相关方法</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_12.png" alt="img"></p>
<h3 id="3-10-ServerSocketChannel"><a href="#3-10-ServerSocketChannel" class="headerlink" title="3.10 ServerSocketChannel"></a>3.10 ServerSocketChannel</h3><ol>
<li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接</li>
<li>相关方法如下</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_13.png" alt="img"></p>
<h3 id="3-11-SocketChannel"><a href="#3-11-SocketChannel" class="headerlink" title="3.11 SocketChannel"></a>3.11 SocketChannel</h3><ol>
<li><code>SocketChannel</code>，网络 <code>IO</code> 通道，具体负责进行读写操作。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li>
<li>相关方法如下</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_14.png" alt="img"></p>
<h3 id="3-12-NIO-网络编程应用实例-群聊系统"><a href="#3-12-NIO-网络编程应用实例-群聊系统" class="headerlink" title="3.12 NIO 网络编程应用实例 - 群聊系统"></a>3.12 NIO 网络编程应用实例 - 群聊系统</h3><p>实例要求：</p>
<ol>
<li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
<li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li>
<li>示意图分析和代码</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_15.png" alt="img"></p>
<p>代码：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 服务端：</span>

<span class="hljs-keyword">package</span> com.atguigu.nio.groupchat;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.Channel;
<span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;
<span class="hljs-keyword">import</span> java.nio.channels.Selector;
<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;
<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>&#123;

    <span class="hljs-comment">//定义属性</span>
    <span class="hljs-keyword">private</span> Selector selector;
    <span class="hljs-keyword">private</span> ServerSocketChannel listenChannel;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;

    <span class="hljs-comment">//构造器</span>
    <span class="hljs-comment">//初始化工作</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//得到选择器</span>
            selector = Selector.open();
            <span class="hljs-comment">//ServerSocketChannel</span>
            listenChannel = ServerSocketChannel.open();
            <span class="hljs-comment">//绑定端口</span>
            listenChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(PORT));
            <span class="hljs-comment">//设置非阻塞模式</span>
            listenChannel.configureBlocking(<span class="hljs-keyword">false</span>);
            <span class="hljs-comment">//将该 listenChannel 注册到 selector</span>
            listenChannel.register(selector, SelectionKey.OP_ACCEPT);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//循环处理</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                <span class="hljs-keyword">int</span> count = selector.select();
                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//有事件处理</span>
                    <span class="hljs-comment">// 遍历得到 selectionKey 集合</span>
                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();
                    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
                        <span class="hljs-comment">//取出 selectionkey</span>
                        SelectionKey key = iterator.next();
                        <span class="hljs-comment">//监听到 accept</span>
                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;
                            SocketChannel sc = listenChannel.accept();
                            sc.configureBlocking(<span class="hljs-keyword">false</span>);
                            <span class="hljs-comment">//将该 sc 注册到 seletor</span>
                            sc.register(selector, SelectionKey.OP_READ);
                            <span class="hljs-comment">//提示</span>
                            System.out.println(sc.getRemoteAddress() + <span class="hljs-string">&quot; 上线 &quot;</span>);
                        &#125;
                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<span class="hljs-comment">//通道发送read事件，即通道是可读的状态</span>
                            <span class="hljs-comment">// 处理读(专门写方法..)</span>
                            readData(key);
                        &#125;
                        <span class="hljs-comment">//当前的 key 删除，防止重复处理</span>
                        iterator.remove();
                    &#125;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    System.out.println(<span class="hljs-string">&quot;等待....&quot;</span>);
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">//发生异常处理....</span>
        &#125;
    &#125;

    <span class="hljs-comment">//读取客户端消息</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readData</span><span class="hljs-params">(SelectionKey key)</span> </span>&#123;
        SocketChannel channel = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//得到 channel</span>
            channel = (SocketChannel) key.channel();
            <span class="hljs-comment">//创建 buffer</span>
            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);
            <span class="hljs-keyword">int</span> count = channel.read(buffer);
            <span class="hljs-comment">//根据 count 的值做处理</span>
            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">//把缓存区的数据转成字符串</span>
                String msg = <span class="hljs-keyword">new</span> String(buffer.array());
                <span class="hljs-comment">//输出该消息</span>
                System.out.println(<span class="hljs-string">&quot;form客户端:&quot;</span> + msg);
                <span class="hljs-comment">//向其它的客户端转发消息(去掉自己),专门写一个方法来处理</span>
                sendInfoToOtherClients(msg, channel);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            <span class="hljs-keyword">try</span> &#123;
                System.out.println(channel.getRemoteAddress() + <span class="hljs-string">&quot;离线了..&quot;</span>);
                <span class="hljs-comment">//取消注册</span>
                key.cancel();
                <span class="hljs-comment">//关闭通道</span>
                channel.close();
            &#125; <span class="hljs-keyword">catch</span> (IOException e2) &#123;
                e2.printStackTrace();
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">//转发消息给其它客户(通道)</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfoToOtherClients</span><span class="hljs-params">(String msg, SocketChannel self)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;

        System.out.println(<span class="hljs-string">&quot;服务器转发消息中...&quot;</span>);
        <span class="hljs-comment">//遍历所有注册到 selector 上的 SocketChannel,并排除 self</span>
        <span class="hljs-keyword">for</span> (SelectionKey key : selector.keys()) &#123;
            <span class="hljs-comment">//通过 key 取出对应的 SocketChannel</span>
            Channel targetChannel = key.channel();
            <span class="hljs-comment">//排除自己</span>
            <span class="hljs-keyword">if</span> (targetChannel <span class="hljs-keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;
                <span class="hljs-comment">//转型</span>
                SocketChannel dest = (SocketChannel) targetChannel;
                <span class="hljs-comment">//将 msg 存储到 buffer</span>
                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());
                <span class="hljs-comment">//将 buffer 的数据写入通道</span>
                dest.write(buffer);
            &#125;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//创建服务器对象</span>
        GroupChatServer groupChatServer = <span class="hljs-keyword">new</span> GroupChatServer();
        groupChatServer.listen();
    &#125;
&#125;

<span class="hljs-comment">// 客户端：</span>

<span class="hljs-keyword">package</span> com.atguigu.nio.groupchat;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;
<span class="hljs-keyword">import</span> java.nio.channels.Selector;
<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>&#123;

    <span class="hljs-comment">//定义相关的属性</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<span class="hljs-comment">//服务器的ip</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;<span class="hljs-comment">//服务器端口</span>
    <span class="hljs-keyword">private</span> Selector selector;
    <span class="hljs-keyword">private</span> SocketChannel socketChannel;
    <span class="hljs-keyword">private</span> String username;

    <span class="hljs-comment">//构造器,完成初始化工作</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        
        selector = Selector.open();
        <span class="hljs-comment">//连接服务器</span>
        socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(HOST, PORT));
        <span class="hljs-comment">//设置非阻塞</span>
        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);
        <span class="hljs-comment">//将 channel 注册到selector</span>
        socketChannel.register(selector, SelectionKey.OP_READ);
        <span class="hljs-comment">//得到 username</span>
        username = socketChannel.getLocalAddress().toString().substring(<span class="hljs-number">1</span>);
        System.out.println(username + <span class="hljs-string">&quot; is ok...&quot;</span>);
    &#125;

    <span class="hljs-comment">//向服务器发送消息</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfo</span><span class="hljs-params">(String info)</span> </span>&#123;
        info = username + <span class="hljs-string">&quot; 说：&quot;</span> + info;
        <span class="hljs-keyword">try</span> &#123;
            socketChannel.write(ByteBuffer.wrap(info.getBytes()));
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    <span class="hljs-comment">//读取从服务器端回复的消息</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readInfo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">int</span> readChannels = selector.select();
            <span class="hljs-keyword">if</span> (readChannels &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有可以用的通道</span>
                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();
                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
                    SelectionKey key = iterator.next();
                    <span class="hljs-keyword">if</span> (key.isReadable()) &#123;
                        <span class="hljs-comment">//得到相关的通道</span>
                        SocketChannel sc = (SocketChannel) key.channel();
                        <span class="hljs-comment">//得到一个 Buffer</span>
                        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);
                        <span class="hljs-comment">//读取</span>
                        sc.read(buffer);
                        <span class="hljs-comment">//把读到的缓冲区的数据转成字符串</span>
                        String msg = <span class="hljs-keyword">new</span> String(buffer.array());
                        System.out.println(msg.trim());
                    &#125;
                &#125;
                iterator.remove(); <span class="hljs-comment">//删除当前的 selectionKey,防止重复操作</span>
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span>
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//启动我们客户端</span>
        GroupChatClient chatClient = <span class="hljs-keyword">new</span> GroupChatClient();
        <span class="hljs-comment">//启动一个线程,每个 3 秒，读取从服务器发送数据</span>
        <span class="hljs-keyword">new</span> Thread() &#123;
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                    chatClient.readInfo();
                    <span class="hljs-keyword">try</span> &#123;
                        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);
                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;.start();

        <span class="hljs-comment">//发送数据给服务器端</span>
        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);
        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;
            String s = scanner.nextLine();
            chatClient.sendInfo(s);
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="3-13-NIO-与零拷贝"><a href="#3-13-NIO-与零拷贝" class="headerlink" title="3.13 NIO 与零拷贝"></a>3.13 NIO 与零拷贝</h3><h4 id="3-13-1-零拷贝基本介绍"><a href="#3-13-1-零拷贝基本介绍" class="headerlink" title="3.13.1 零拷贝基本介绍"></a>3.13.1 零拷贝基本介绍</h4><ol>
<li>零拷贝是网络编程的关键，很多性能优化都离不开。</li>
<li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li>
<li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li>
</ol>
<h4 id="3-13-2-传统-IO-数据读写"><a href="#3-13-2-传统-IO-数据读写" class="headerlink" title="3.13.2 传统 IO 数据读写"></a>3.13.2 传统 IO 数据读写</h4><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p>
<div class="code-wrapper"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);
RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(file, <span class="hljs-string">&quot;rw&quot;</span>);

<span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) file.length()];
raf.read(arr);

Socket socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>).accept();
socket.getOutputStream().write(arr);</code></pre></div>

<h4 id="3-13-3-传统-IO-模型"><a href="#3-13-3-传统-IO-模型" class="headerlink" title="3.13.3 传统 IO 模型"></a>3.13.3 传统 IO 模型</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_17.png" alt="img"></p>
<p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p>
<h4 id="3-13-4-mmap-优化"><a href="#3-13-4-mmap-优化" class="headerlink" title="3.13.4 mmap 优化"></a>3.13.4 mmap 优化</h4><ol>
<li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li>
<li><code>mmap</code> 示意图</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_18.png" alt="img"></p>
<h4 id="3-13-5-sendFile-优化"><a href="#3-13-5-sendFile-优化" class="headerlink" title="3.13.5 sendFile 优化"></a>3.13.5 sendFile 优化</h4><ol>
<li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li>
<li>示意图和小结</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_19.png" alt="img"></p>
<ol start="3">
<li><p>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</p>
</li>
<li><p><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</p>
</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_20.png" alt="img"></p>
<ol start="5">
<li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li>
</ol>
<h4 id="3-13-6-零拷贝的再次理解"><a href="#3-13-6-零拷贝的再次理解" class="headerlink" title="3.13.6 零拷贝的再次理解"></a>3.13.6 零拷贝的再次理解</h4><ol>
<li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li>
<li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li>
</ol>
<h4 id="3-13-7-mmap-和-sendFile-的区别"><a href="#3-13-7-mmap-和-sendFile-的区别" class="headerlink" title="3.13.7 mmap 和 sendFile 的区别"></a>3.13.7 mmap 和 sendFile 的区别</h4><ol>
<li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li>
<li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li>
<li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li>
</ol>
<h4 id="3-13-8-NIO-零拷贝案例"><a href="#3-13-8-NIO-零拷贝案例" class="headerlink" title="3.13.8 NIO 零拷贝案例"></a>3.13.8 NIO 零拷贝案例</h4><p>案例要求：</p>
<ol>
<li>使用传统的 <code>IO</code> 方法传递一个大文件</li>
<li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li>
<li>看看两种传递方式耗时时间分别是多少</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio.zerocopy;

<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.net.ServerSocket;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;
<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;

<span class="hljs-comment">//服务器</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOServer</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7001</span>);
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        ServerSocket serverSocket = serverSocketChannel.socket();
        serverSocket.bind(address);

        <span class="hljs-comment">//创建buffer</span>
        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">4096</span>);

        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            SocketChannel socketChannel = serverSocketChannel.accept();
            <span class="hljs-keyword">int</span> readcount = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (-<span class="hljs-number">1</span> != readcount) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    readcount = socketChannel.read(byteBuffer);
                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;
                    <span class="hljs-comment">// ex.printStackTrace();</span>
                    <span class="hljs-keyword">break</span>;
                &#125;
                <span class="hljs-comment">//</span>
                byteBuffer.rewind(); <span class="hljs-comment">//倒带 position = 0 mark 作废</span>
            &#125;
        &#125;
    &#125;
&#125;



<span class="hljs-keyword">package</span> com.atguigu.nio.zerocopy;

<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;
<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOClient</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        SocketChannel socketChannel = SocketChannel.open();
        socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">7001</span>));
        String filename = <span class="hljs-string">&quot;protoc-3.6.1-win32.zip&quot;</span>;
        <span class="hljs-comment">//得到一个文件channel</span>
        FileChannel fileChannel = <span class="hljs-keyword">new</span> FileInputStream(filename).getChannel();
        <span class="hljs-comment">//准备发送</span>
        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();
        <span class="hljs-comment">//在 linux 下一个 transferTo 方法就可以完成传输</span>
        <span class="hljs-comment">//在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要</span>
        <span class="hljs-comment">//传输时的位置=》课后思考...</span>
        <span class="hljs-comment">//transferTo 底层使用到零拷贝</span>
        <span class="hljs-keyword">long</span> transferCount = fileChannel.transferTo(<span class="hljs-number">0</span>, fileChannel.size(), socketChannel);
        System.out.println(<span class="hljs-string">&quot;发送的总的字节数 = &quot;</span> + transferCount + <span class="hljs-string">&quot; 耗时: &quot;</span> + (System.currentTimeMillis() - startTime));

        <span class="hljs-comment">//关闭</span>
        fileChannel.close();
    &#125;
&#125;</code></pre></div>

<h3 id="3-14-Java-AIO-基本介绍"><a href="#3-14-Java-AIO-基本介绍" class="headerlink" title="3.14 Java AIO 基本介绍"></a>3.14 Java AIO 基本介绍</h3><ol>
<li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li>
<li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
<li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li>
</ol>
<h3 id="3-15-BIO、NIO、AIO-对比表"><a href="#3-15-BIO、NIO、AIO-对比表" class="headerlink" title="3.15 BIO、NIO、AIO 对比表"></a>3.15 BIO、NIO、AIO 对比表</h3><table>
<thead>
<tr>
<th></th>
<th>BIO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody><tr>
<td>IO模型</td>
<td>同步阻塞</td>
<td>同步非阻塞（多路复用）</td>
<td>异步非阻塞</td>
</tr>
<tr>
<td>编程难度</td>
<td>简单</td>
<td>复杂</td>
<td>复杂</td>
</tr>
<tr>
<td>可靠性</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<p><strong>举例说明</strong></p>
<ol>
<li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li>
<li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li>
<li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li>
</ol>
<h2 id="4-Netty-概述"><a href="#4-Netty-概述" class="headerlink" title="4 Netty 概述"></a>4 Netty 概述</h2><h3 id="4-1-原生-NIO-存在的问题"><a href="#4-1-原生-NIO-存在的问题" class="headerlink" title="4.1 原生 NIO 存在的问题"></a>4.1 原生 NIO 存在的问题</h3><ol>
<li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li>
<li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li>
<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。4. <code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决。</li>
</ol>
<h3 id="4-2-Netty-官网说明"><a href="#4-2-Netty-官网说明" class="headerlink" title="4.2 Netty 官网说明"></a>4.2 Netty 官网说明</h3><p>官网：<a href="https://netty.io/">https://netty.io/</a></p>
<p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter04_01.png" alt="img"></p>
<h3 id="4-3-Netty-的优点"><a href="#4-3-Netty-的优点" class="headerlink" title="4.3 Netty 的优点"></a>4.3 Netty 的优点</h3><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p>
<ol>
<li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li>
<li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li>
<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
<li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li>
<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li>
</ol>
<h3 id="4-4-Netty-版本说明"><a href="#4-4-Netty-版本说明" class="headerlink" title="4.4 Netty 版本说明"></a>4.4 Netty 版本说明</h3><ol>
<li><p><code>Netty</code> 版本分为 <code>Netty 3.x</code> 和 <code>Netty 4.x</code>、<code>Netty 5.x</code></p>
</li>
<li><p>因为 <code>Netty 5</code> 出现重大 <code>bug</code>，已经被官网废弃了，目前推荐使用的是 <code>Netty 4.x</code>的稳定版本</p>
</li>
<li><p>目前在官网可下载的版本 <code>Netty 3.x</code>、<code>Netty 4.0.x</code> 和 <code>Netty 4.1.x</code></p>
</li>
<li><p>在本套课程中，我们讲解 <code>Netty4.1.x</code> 版本</p>
</li>
<li><p><code>Netty</code> 下载地址：<a href="https://bintray.com/netty/downloads/netty/">https://bintray.com/netty/downloads/netty/</a></p>
</li>
<li><p>maven</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.netty/netty-all --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.42.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

</li>
</ol>
<h2 id="5-Netty-高性能架构设计"><a href="#5-Netty-高性能架构设计" class="headerlink" title="5  Netty 高性能架构设计"></a>5  Netty 高性能架构设计</h2><h3 id="5-1-线程模型基本介绍"><a href="#5-1-线程模型基本介绍" class="headerlink" title="5.1 线程模型基本介绍"></a>5.1 线程模型基本介绍</h3><ol>
<li>不同的线程模式，对程序的性能有很大影响，为了搞清 <code>Netty</code> 线程模式，我们来系统的讲解下各个线程模式，最后看看 <code>Netty</code> 线程模型有什么优越性。</li>
<li>目前存在的线程模型有：传统阻塞 <code>I/O</code> 服务模型 <code>Reactor</code> 模式</li>
<li>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现单 <code>Reactor</code> 单线程；单 <code>Reactor</code>多线程；主从 <code>Reactor</code>多线程</li>
<li><code>Netty</code> 线程模式（<code>Netty</code> 主要基于主从 <code>Reactor</code> 多线程模型做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>）</li>
</ol>
<h3 id="5-2-传统阻塞-I-O-服务模型"><a href="#5-2-传统阻塞-I-O-服务模型" class="headerlink" title="5.2 传统阻塞 I/O 服务模型"></a>5.2 传统阻塞 I/O 服务模型</h3><h4 id="5-2-1-工作原理图"><a href="#5-2-1-工作原理图" class="headerlink" title="5.2.1 工作原理图"></a>5.2.1 工作原理图</h4><ol>
<li>黄色的框表示对象，蓝色的框表示线程</li>
<li>白色的框表示方法（<code>API</code>）</li>
</ol>
<h4 id="5-2-2-模型特点"><a href="#5-2-2-模型特点" class="headerlink" title="5.2.2 模型特点"></a>5.2.2 模型特点</h4><ol>
<li>采用阻塞 <code>IO</code> 模式获取输入的数据</li>
<li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li>
</ol>
<h4 id="5-2-3-问题分析"><a href="#5-2-3-问题分析" class="headerlink" title="5.2.3 问题分析"></a>5.2.3 问题分析</h4><ol>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 <code>read</code> 操作，造成线程资源浪费</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_01.png" alt="img"></p>
<h3 id="5-3-Reactor-模式"><a href="#5-3-Reactor-模式" class="headerlink" title="5.3 Reactor 模式"></a>5.3 Reactor 模式</h3><h4 id="5-3-1-针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案："><a href="#5-3-1-针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案：" class="headerlink" title="5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案："></a>5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</h4><ol>
<li>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理 <code>Reactor</code> 对应的叫法：<ol>
<li>反应器模式</li>
<li>分发者模式（Dispatcher）</li>
<li>通知者模式（notifier）</li>
</ol>
</li>
<li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_02.png" alt="img"></p>
<h4 id="5-3-2-I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图"><a href="#5-3-2-I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图" class="headerlink" title="5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图"></a>5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_03.png" alt="img"></p>
<p>对上图说明：</p>
<ol>
<li><code>Reactor</code> 模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li>
<li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 <code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式</li>
<li><code>Reactor</code> 模式使用 <code>IO</code> 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li>
</ol>
<h4 id="5-3-3-Reactor-模式中核心组成"><a href="#5-3-3-Reactor-模式中核心组成" class="headerlink" title="5.3.3 Reactor 模式中核心组成"></a>5.3.3 Reactor 模式中核心组成</h4><ol>
<li><code>Reactor</code>：<code>Reactor</code> 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 <code>IO</code> 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li>
<li><code>Handlers</code>：处理程序执行 <code>I/O</code> 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code> 通过调度适当的处理程序来响应 <code>I/O</code> 事件，处理程序执行非阻塞操作。</li>
</ol>
<h4 id="5-3-4-Reactor-模式分类"><a href="#5-3-4-Reactor-模式分类" class="headerlink" title="5.3.4 Reactor 模式分类"></a>5.3.4 Reactor 模式分类</h4><p>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现</p>
<ol>
<li>单 <code>Reactor</code> 单线程</li>
<li>单 <code>Reactor</code> 多线程</li>
<li>主从 <code>Reactor</code> 多线程</li>
</ol>
<h3 id="5-4-单-Reactor-单线程"><a href="#5-4-单-Reactor-单线程" class="headerlink" title="5.4 单 Reactor 单线程"></a>5.4 单 Reactor 单线程</h3><p>原理图，并使用 <code>NIO</code> 群聊系统验证</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_04.png" alt="img"></p>
<h4 id="5-4-1-方案说明"><a href="#5-4-1-方案说明" class="headerlink" title="5.4.1 方案说明"></a>5.4.1 方案说明</h4><ol>
<li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 <code>API</code>，可以实现应用程序通过一个阻塞对象监听多路连接请求</li>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li>
<li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li>
<li><code>Handler</code> 会完成 <code>Read</code> → 业务处理 → <code>Send</code> 的完整业务流程</li>
</ol>
<p>结合实例：服务器端用一个线程通过多路复用搞定所有的 <code>IO</code> 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 <code>NIO</code> 案例就属于这种模型。</p>
<h4 id="5-4-2-方案优缺点分析"><a href="#5-4-2-方案优缺点分析" class="headerlink" title="5.4.2 方案优缺点分析"></a>5.4.2 方案优缺点分析</h4><ol>
<li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
<li>缺点：性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
<li>使用场景：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code> 在业务处理的时间复杂度 <code>O(1)</code> 的情况</li>
</ol>
<h3 id="5-5-单-Reactor-多线程"><a href="#5-5-单-Reactor-多线程" class="headerlink" title="5.5 单 Reactor 多线程"></a>5.5 单 Reactor 多线程</h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_05.png" alt="img"></p>
<h4 id="5-5-1-原理图"><a href="#5-5-1-原理图" class="headerlink" title="5.5.1 原理图"></a>5.5.1 原理图</h4><h4 id="5-5-2-对上图的小结"><a href="#5-5-2-对上图的小结" class="headerlink" title="5.5.2 对上图的小结"></a>5.5.2 对上图的小结</h4><ol>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后，通过 <code>Dispatch</code> 进行分发</li>
<li>如果建立连接请求，则右 <code>Acceptor</code> 通过 <code>accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理</li>
<li><code>handler</code> 只负责响应事件，不做具体的业务处理，通过 <code>read</code> 读取数据后，会分发给后面的 <code>worker</code> 线程池的某个线程处理业务</li>
<li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给 <code>handler</code></li>
<li><code>handler</code> 收到响应后，通过 <code>send</code> 将结果返回给 <code>client</code></li>
</ol>
<h4 id="5-5-3-方案优缺点分析"><a href="#5-5-3-方案优缺点分析" class="headerlink" title="5.5.3 方案优缺点分析"></a>5.5.3 方案优缺点分析</h4><ol>
<li>优点：可以充分的利用多核 <code>cpu</code> 的处理能力</li>
<li>缺点：多线程数据共享和访问比较复杂，<code>Reactor</code> 处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</li>
</ol>
<h3 id="5-6-主从-Reactor-多线程"><a href="#5-6-主从-Reactor-多线程" class="headerlink" title="5.6 主从 Reactor 多线程"></a>5.6 主从 Reactor 多线程</h3><h4 id="5-6-1-工作原理图"><a href="#5-6-1-工作原理图" class="headerlink" title="5.6.1 工作原理图"></a>5.6.1 工作原理图</h4><p>针对单 <code>Reactor</code> 多线程模型中，<code>Reactor</code> 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 <code>Reactor</code> 在多线程中运行</p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_06.png" alt="img"></p>
<h4 id="5-6-2-上图的方案说明"><a href="#5-6-2-上图的方案说明" class="headerlink" title="5.6.2 上图的方案说明"></a>5.6.2 上图的方案说明</h4><ol>
<li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件</li>
<li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code></li>
<li><code>subreactor</code> 将连接加入到连接队列进行监听，并创建 <code>handler</code> 进行各种事件处理</li>
<li>当有新事件发生时，<code>subreactor</code> 就会调用对应的 <code>handler</code> 处理</li>
<li><code>handler</code> 通过 <code>read</code> 读取数据，分发给后面的 <code>worker</code> 线程处理</li>
<li><code>worker</code> 线程池分配独立的 <code>worker</code> 线程进行业务处理，并返回结果</li>
<li><code>handler</code> 收到响应的结果后，再通过 <code>send</code> 将结果返回给 <code>client</code></li>
<li><code>Reactor</code> 主线程可以对应多个 <code>Reactor</code> 子线程，即 <code>MainRecator</code> 可以关联多个 <code>SubReactor</code></li>
</ol>
<h4 id="5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解："><a href="#5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解：" class="headerlink" title="5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解："></a>5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解：</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_07.png" alt="img"></p>
<h4 id="5-6-4-方案优缺点说明"><a href="#5-6-4-方案优缺点说明" class="headerlink" title="5.6.4 方案优缺点说明"></a>5.6.4 方案优缺点说明</h4><ol>
<li>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li>
<li>优点：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据。</li>
<li>缺点：编程复杂度较高</li>
<li>结合实例：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li>
</ol>
<h3 id="5-7-Reactor-模式小结"><a href="#5-7-Reactor-模式小结" class="headerlink" title="5.7 Reactor 模式小结"></a>5.7 Reactor 模式小结</h3><h4 id="5-7-1-3-种模式用生活案例来理解"><a href="#5-7-1-3-种模式用生活案例来理解" class="headerlink" title="5.7.1 3 种模式用生活案例来理解"></a>5.7.1 3 种模式用生活案例来理解</h4><ol>
<li>单 <code>Reactor</code> 单线程，前台接待员和服务员是同一个人，全程为顾客服务</li>
<li>单 <code>Reactor</code> 多线程，<code>1</code> 个前台接待员，多个服务员，接待员只负责接待</li>
<li>主从 <code>Reactor</code> 多线程，多个前台接待员，多个服务生</li>
</ol>
<h4 id="5-7-2-Reactor-模式具有如下的优点"><a href="#5-7-2-Reactor-模式具有如下的优点" class="headerlink" title="5.7.2 Reactor 模式具有如下的优点"></a>5.7.2 Reactor 模式具有如下的优点</h4><ol>
<li>响应快，不必为单个同步时间所阻塞，虽然 <code>Reactor</code> 本身依然是同步的</li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li>
<li>扩展性好，可以方便的通过增加 <code>Reactor</code> 实例个数来充分利用 <code>CPU</code> 资源</li>
<li>复用性好，<code>Reactor</code> 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ol>
<h3 id="5-8-Netty-模型"><a href="#5-8-Netty-模型" class="headerlink" title="5.8 Netty 模型"></a>5.8 Netty 模型</h3><h4 id="5-8-1-工作原理示意图-简单版"><a href="#5-8-1-工作原理示意图-简单版" class="headerlink" title="5.8.1 工作原理示意图 - 简单版"></a>5.8.1 工作原理示意图 - 简单版</h4><p>Netty主要基于<code>主从 Reactors</code> 多线程模型（如图）做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 `Reactor</p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_08.png" alt="img"></p>
<h4 id="5-8-2-对上图说明"><a href="#5-8-2-对上图说明" class="headerlink" title="5.8.2 对上图说明"></a>5.8.2 对上图说明</h4><ol>
<li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code></li>
<li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护</li>
<li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 <code>handler</code>），注意 <code>handler</code> 已经加入到通道</li>
</ol>
<h4 id="5-8-3-工作原理示意图-进阶版"><a href="#5-8-3-工作原理示意图-进阶版" class="headerlink" title="5.8.3 工作原理示意图 - 进阶版"></a>5.8.3 工作原理示意图 - 进阶版</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_09.png" alt="img"></p>
<h4 id="5-8-4-工作原理示意图-详细版"><a href="#5-8-4-工作原理示意图-详细版" class="headerlink" title="5.8.4 工作原理示意图 - 详细版"></a>5.8.4 工作原理示意图 - 详细版</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_10.png" alt="img"></p>
<h4 id="5-8-5-对上图的说明小结"><a href="#5-8-5-对上图的说明小结" class="headerlink" title="5.8.5 对上图的说明小结"></a>5.8.5 对上图的说明小结</h4><ol>
<li><p><code>Netty</code> 抽象出两组线程池 <code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</p>
</li>
<li><p><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code></p>
</li>
<li><p><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code></p>
</li>
<li><p><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</p>
</li>
<li><p><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code></p>
</li>
<li><p>每个 循环执行的步骤有 <code>BossNioEventLoop``3</code></p>
<ul>
<li>轮询 <code>accept</code> 事件</li>
<li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>worker</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li>
<li>处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li><p>每个 循环执行的步骤<code>Worker``NIOEventLoo</code></p>
<ul>
<li>轮询 <code>read</code>，<code>write</code> 事件</li>
<li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li>
<li>处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li><p>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器</p>
</li>
</ol>
<h4 id="5-8-6-Netty-快速入门实例-TCP-服务"><a href="#5-8-6-Netty-快速入门实例-TCP-服务" class="headerlink" title="5.8.6 Netty 快速入门实例 - TCP 服务"></a>5.8.6 Netty 快速入门实例 - TCP 服务</h4><p>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</p>
<ol>
<li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，客户端能发送消息给服务器”hello,服务器~”</li>
<li>服务器可以回复消息给客户端”hello,客户端~”</li>
<li>目的：对 <code>Netty</code> 线程模型有一个初步认识，便于理解 <code>Netty</code> 模型理论</li>
<li>看老师代码演示 5.1 编写服务端 5.2 编写客户端 5.3 对 <code>netty</code> 程序进行分析，看看 <code>netty</code> 模型特点 说明：创建 <code>Maven</code> 项目，并引入 <code>Netty</code> 包</li>
<li>代码如下</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java">NettyServer.java

<span class="hljs-keyword">package</span> com.atguigu.netty.simple;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFutureListener;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        
        <span class="hljs-comment">//创建BossGroup 和 WorkerGroup</span>
        <span class="hljs-comment">//说明</span>
        <span class="hljs-comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span>
        <span class="hljs-comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span>
        <span class="hljs-comment">//3. 两个都是无限循环</span>
        <span class="hljs-comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span>
        <span class="hljs-comment">//   默认实际 cpu核数 * 2</span>
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8</span>
        
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//创建服务器端的启动对象，配置参数</span>
            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();
            <span class="hljs-comment">//使用链式编程来进行设置</span>
            bootstrap.group(bossGroup, workerGroup) <span class="hljs-comment">//设置两个线程组</span>
                    .channel(NioServerSocketChannel.class) <span class="hljs-comment">//使用NioSocketChannel 作为服务器的通道实现</span>
                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>) <span class="hljs-comment">// 设置线程队列得到连接个数</span>
                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>) <span class="hljs-comment">//设置保持活动连接状态</span>
            <span class="hljs-comment">//          .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span>
                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="hljs-comment">//创建一个通道初始化对象(匿名对象)</span>
                        <span class="hljs-comment">//给pipeline 设置处理器</span>
                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                            System.out.println(<span class="hljs-string">&quot;客户socketchannel hashcode=&quot;</span> + ch.hashCode()); <span class="hljs-comment">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span>
                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());
                        &#125;
                    &#125;); <span class="hljs-comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span>

            System.out.println(<span class="hljs-string">&quot;.....服务器 is ready...&quot;</span>);

            <span class="hljs-comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span>
            <span class="hljs-comment">//启动服务器(并绑定端口)</span>
            ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();

            <span class="hljs-comment">//给cf 注册监听器，监控我们关心的事件</span>

            cf.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                    <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;
                        System.out.println(<span class="hljs-string">&quot;监听端口 6668 成功&quot;</span>);
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        System.out.println(<span class="hljs-string">&quot;监听端口 6668 失败&quot;</span>);
                    &#125;
                &#125;
            &#125;);

            <span class="hljs-comment">//对关闭通道进行监听</span>
            cf.channel().closeFuture().sync();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;

NettyServerHandler.java

<span class="hljs-keyword">package</span> com.atguigu.netty.simple;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.Channel;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 说明</span>
<span class="hljs-comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span>
<span class="hljs-comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span>
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span>
<span class="hljs-comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        
        System.out.println(<span class="hljs-string">&quot;服务器读取线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; channle =&quot;</span> + ctx.channel());
        System.out.println(<span class="hljs-string">&quot;server ctx =&quot;</span> + ctx);
        System.out.println(<span class="hljs-string">&quot;看看channel 和 pipeline的关系&quot;</span>);
        Channel channel = ctx.channel();
        ChannelPipeline pipeline = ctx.pipeline(); <span class="hljs-comment">//本质是一个双向链接, 出站入站</span>
        
        <span class="hljs-comment">//将 msg 转成一个 ByteBuf</span>
        <span class="hljs-comment">//ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span>
        ByteBuf buf = (ByteBuf) msg;
        System.out.println(<span class="hljs-string">&quot;客户端发送消息是:&quot;</span> + buf.toString(CharsetUtil.UTF_8));
        System.out.println(<span class="hljs-string">&quot;客户端地址:&quot;</span> + channel.remoteAddress());
    &#125;

    <span class="hljs-comment">//数据读取完毕</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//writeAndFlush 是 write + flush</span>
        <span class="hljs-comment">//将数据写入到缓存，并刷新</span>
        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span>
        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));
    &#125;
    
    <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ctx.close();
    &#125;
&#125;

NettyClient.java

<span class="hljs-keyword">package</span> com.atguigu.netty.simple;

<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//客户端需要一个事件循环组</span>
        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();
        <span class="hljs-keyword">try</span> &#123;
            
            <span class="hljs-comment">//创建客户端启动对象</span>
            <span class="hljs-comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span>
            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();
            <span class="hljs-comment">//设置相关参数</span>
            bootstrap.group(group) <span class="hljs-comment">//设置线程组</span>
                    .channel(NioSocketChannel.class) <span class="hljs-comment">// 设置客户端通道的实现类(反射)</span>
                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler()); <span class="hljs-comment">//加入自己的处理器</span>
                        &#125;
                    &#125;);
            
            System.out.println(<span class="hljs-string">&quot;客户端 ok..&quot;</span>);
            <span class="hljs-comment">//启动客户端去连接服务器端</span>
            <span class="hljs-comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span>
            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6668</span>).sync();
            <span class="hljs-comment">//给关闭通道进行监听</span>
            channelFuture.channel().closeFuture().sync();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            group.shutdownGracefully();
        &#125;
    &#125;
&#125;

NettyClientHandler.java

<span class="hljs-keyword">package</span> com.atguigu.netty.simple;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;
<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;
    
    <span class="hljs-comment">//当通道就绪就会触发该方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;client &quot;</span> + ctx);
        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, server: (&gt;^ω^&lt;)喵&quot;</span>, CharsetUtil.UTF_8));
    &#125;

    <span class="hljs-comment">//当通道有读取事件时，会触发</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ByteBuf buf = (ByteBuf) msg;
        System.out.println(<span class="hljs-string">&quot;服务器回复的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));
        System.out.println(<span class="hljs-string">&quot;服务器的地址： &quot;</span> + ctx.channel().remoteAddress());
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        cause.printStackTrace();
        ctx.close();
    &#125;
&#125;</code></pre></div>

<h4 id="5-8-7-任务队列中的-Task-有-3-种典型使用场景"><a href="#5-8-7-任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="5.8.7 任务队列中的 Task 有 3 种典型使用场景"></a>5.8.7 任务队列中的 Task 有 3 种典型使用场景</h4><ol>
<li>用户程序自定义的普通任务【举例说明】</li>
<li>用户自定义定时任务</li>
<li>非当前 <code>Reactor</code> 线程调用 <code>Channel</code> 的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的 <code>Channel</code> 引用，然后调用 <code>Write</code> 类方法向该用户推送消息，就会进入到这种场景。最终的 <code>Write</code> 会提交到任务队列中后被异步消费</li>
<li>代码演示</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.simple;

<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;
<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 说明</span>
<span class="hljs-comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span>
<span class="hljs-comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span>

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span>
<span class="hljs-comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">// 比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的</span>
        <span class="hljs-comment">// NIOEventLoop 的 taskQueue中,</span>

        <span class="hljs-comment">// 解决方案1 用户程序自定义的普通任务</span>

        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;

                <span class="hljs-keyword">try</span> &#123;
                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);
                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;</span>, CharsetUtil.UTF_8));
                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());
                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;
                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());
                &#125;
            &#125;
        &#125;);

        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;

                <span class="hljs-keyword">try</span> &#123;
                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);
                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵3&quot;</span>, CharsetUtil.UTF_8));
                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());
                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;
                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());
                &#125;
            &#125;
        &#125;);

        <span class="hljs-comment">//解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中</span>

        ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;

                <span class="hljs-keyword">try</span> &#123;
                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);
                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵4&quot;</span>, CharsetUtil.UTF_8));
                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());
                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;
                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());
                &#125;
            &#125;
        &#125;, <span class="hljs-number">5</span>, TimeUnit.SECONDS);

        System.out.println(<span class="hljs-string">&quot;go on ...&quot;</span>);

<span class="hljs-comment">//        System.out.println(&quot;服务器读取线程 &quot; + Thread.currentThread().getName() + &quot; channle =&quot; + ctx.channel());</span>
<span class="hljs-comment">//        System.out.println(&quot;server ctx =&quot; + ctx);</span>
<span class="hljs-comment">//        System.out.println(&quot;看看channel 和 pipeline的关系&quot;);</span>
<span class="hljs-comment">//        Channel channel = ctx.channel();</span>
<span class="hljs-comment">//        ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站</span>
<span class="hljs-comment">//        </span>
<span class="hljs-comment">//        //将 msg 转成一个 ByteBuf</span>
<span class="hljs-comment">//        //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span>
<span class="hljs-comment">//        ByteBuf buf = (ByteBuf) msg;</span>
<span class="hljs-comment">//        System.out.println(&quot;客户端发送消息是:&quot; + buf.toString(CharsetUtil.UTF_8));</span>
<span class="hljs-comment">//        System.out.println(&quot;客户端地址:&quot; + channel.remoteAddress());</span>
    &#125;

    <span class="hljs-comment">//数据读取完毕</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//writeAndFlush 是 write + flush</span>
        <span class="hljs-comment">//将数据写入到缓存，并刷新</span>
        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span>
        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));
    &#125;

    <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ctx.close();
    &#125;
&#125;</code></pre></div>

<h4 id="5-8-8-方案再说明"><a href="#5-8-8-方案再说明" class="headerlink" title="5.8.8 方案再说明"></a>5.8.8 方案再说明</h4><ol>
<li><code>Netty</code> 抽象出两组线程池，<code>BossGroup</code> 专门负责接收客户端连接，<code>WorkerGroup</code> 专门负责网络读写操作。</li>
<li><code>NioEventLoop</code> 表示一个不断循环执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code>网络通道。</li>
<li><code>NioEventLoop</code> 内部采用串行化设计，从消息的 <strong>读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</strong>，始终由 <code>IO</code> 线程 <code>NioEventLoop</code> 负责<code>NioEventLoopGroup</code>下包含多个 <code>NioEventLoop</code></li>
</ol>
<ul>
<li>每个 <code>NioEventLoop</code> 中包含有一个 <code>Selector</code>，一个 <code>taskQueue</code></li>
<li>每个 <code>NioEventLoop</code> 的 <code>Selector</code> 上可以注册监听多个 <code>NioChannel</code></li>
<li>每个 <code>NioChannel</code> 只会绑定在唯一的 <code>NioEventLoop</code> 上</li>
<li>每个 <code>NioChannel</code> 都绑定有一个自己的 <code>ChannelPipeline</code></li>
</ul>
<h3 id="5-9-异步模型"><a href="#5-9-异步模型" class="headerlink" title="5.9 异步模型"></a>5.9 异步模型</h3><h4 id="5-9-1-基本介绍"><a href="#5-9-1-基本介绍" class="headerlink" title="5.9.1 基本介绍"></a>5.9.1 基本介绍</h4><ol>
<li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li>
<li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind、Write、Connect</code> 等操作会简单的返回一个 <code>ChannelFuture</code>。</li>
<li>调用者并不能立刻获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机制获得 <code>IO</code> 操作结果。</li>
<li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code> 返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code> 去监控方法 <code>fun</code> 的处理过程（即：<code>Future-Listener</code> 机制）</li>
</ol>
<h4 id="5-9-2-Future-说明"><a href="#5-9-2-Future-说明" class="headerlink" title="5.9.2 Future 说明"></a>5.9.2 Future 说明</h4><ol>
<li>表示异步的执行结果,可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</li>
<li><code>ChannelFuture</code> 是一个接口：<code>public interface ChannelFuture extends Future&lt;Void&gt;</code> 我们可以添加监听器，当监听的事件发生时，就会通知到监听器。案例说明</li>
</ol>
<h4 id="5-9-3-工作原理示意图"><a href="#5-9-3-工作原理示意图" class="headerlink" title="5.9.3 工作原理示意图"></a>5.9.3 工作原理示意图</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_11.png" alt="img"></p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_12.png" alt="img"></p>
<p>说明：</p>
<ol>
<li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用 <code>future</code> 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。</li>
<li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。</li>
</ol>
<h4 id="5-9-4-Future-Listener-机制"><a href="#5-9-4-Future-Listener-机制" class="headerlink" title="5.9.4 Future-Listener 机制"></a>5.9.4 Future-Listener 机制</h4><ol>
<li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li>
<li>常见有如下操作<ul>
<li>通过 <code>isDone</code> 方法来判断当前操作是否完成；</li>
<li>通过 <code>isSuccess</code> 方法来判断已完成的当前操作是否成功；</li>
<li>通过 <code>getCause</code> 方法来获取已完成的当前操作失败的原因；</li>
<li>通过 <code>isCancelled</code> 方法来判断已完成的当前操作是否被取消；</li>
<li>通过 <code>addListener</code> 方法来注册监听器，当操作已完成（<code>isDone</code>方法返回完成），将会通知指定的监听器；如果 <code>Future</code> 对象已完成，则通知指定的监听器</li>
</ul>
</li>
</ol>
<p>举例说明 演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//绑定一个端口并且同步,生成了一个ChannelFuture对象</span>
<span class="hljs-comment">//启动服务器(并绑定端口)</span>
ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();
<span class="hljs-comment">//给cf 注册监听器，监控我们关心的事件</span>
cf.addListener((ChannelFutureListener) future -&gt; &#123;
    <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;
        System.out.println(<span class="hljs-string">&quot;监听端口 6668 成功&quot;</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        System.out.println(<span class="hljs-string">&quot;监听端口 6668 失败&quot;</span>);
    &#125;
&#125;);</code></pre></div>

<h3 id="5-10-快速入门实例-HTTP服务"><a href="#5-10-快速入门实例-HTTP服务" class="headerlink" title="5.10 快速入门实例 - HTTP服务"></a>5.10 快速入门实例 - HTTP服务</h3><ol>
<li>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</li>
<li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，浏览器发出请求 <code>http://localhost:6668/</code></li>
<li>服务器可以回复消息给客户端”Hello!我是服务器5”,并对特定请求资源进行过滤。</li>
<li>目的：<code>Netty</code> 可以做 <code>Http</code> 服务开发，并且理解 <code>Handler</code> 实例和客户端及其请求的关系。</li>
<li>看老师代码演示</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java">TestServer.java

<span class="hljs-keyword">package</span> com.atguigu.netty.http;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServer</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();

        <span class="hljs-keyword">try</span> &#123;
            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();

            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="hljs-keyword">new</span> TestServerInitializer());

            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">6668</span>).sync();

            channelFuture.channel().closeFuture().sync();

        &#125; <span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;

TestServerInitializer.java

<span class="hljs-keyword">package</span> com.atguigu.netty.http;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//向管道加入处理器</span>

        <span class="hljs-comment">//得到管道</span>
        ChannelPipeline pipeline = ch.pipeline();

        <span class="hljs-comment">//加入一个netty 提供的httpServerCodec codec =&gt;[coder - decoder]</span>
        <span class="hljs-comment">//HttpServerCodec 说明</span>
        <span class="hljs-comment">//1. HttpServerCodec 是netty 提供的处理http的 编-解码器</span>
        pipeline.addLast(<span class="hljs-string">&quot;MyHttpServerCodec&quot;</span>, <span class="hljs-keyword">new</span> HttpServerCodec());
        <span class="hljs-comment">//2. 增加一个自定义的handler</span>
        pipeline.addLast(<span class="hljs-string">&quot;MyTestHttpServerHandler&quot;</span>, <span class="hljs-keyword">new</span> TestHttpServerHandler());

        System.out.println(<span class="hljs-string">&quot;ok~~~~&quot;</span>);
    &#125;
&#125;

TestHttpServerHandler.java

<span class="hljs-keyword">package</span> com.atguigu.netty.http;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.*;
<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;

<span class="hljs-keyword">import</span> java.net.URI;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 说明</span>
<span class="hljs-comment"> * 1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter</span>
<span class="hljs-comment"> * 2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHttpServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">HttpObject</span>&gt; </span>&#123;

    <span class="hljs-comment">//channelRead0 读取客户端数据</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        System.out.println(<span class="hljs-string">&quot;对应的channel=&quot;</span> + ctx.channel() + <span class="hljs-string">&quot; pipeline=&quot;</span> + ctx
                .pipeline() + <span class="hljs-string">&quot; 通过pipeline获取channel&quot;</span> + ctx.pipeline().channel());

        System.out.println(<span class="hljs-string">&quot;当前ctx的handler=&quot;</span> + ctx.handler());

        <span class="hljs-comment">//判断 msg 是不是 httprequest请求</span>
        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> HttpRequest) &#123;

            System.out.println(<span class="hljs-string">&quot;ctx 类型=&quot;</span> + ctx.getClass());

            System.out.println(<span class="hljs-string">&quot;pipeline hashcode&quot;</span> + ctx.pipeline().hashCode() + <span class="hljs-string">&quot; TestHttpServerHandler hash=&quot;</span> + <span class="hljs-keyword">this</span>.hashCode());

            System.out.println(<span class="hljs-string">&quot;msg 类型=&quot;</span> + msg.getClass());
            System.out.println(<span class="hljs-string">&quot;客户端地址&quot;</span> + ctx.channel().remoteAddress());

            <span class="hljs-comment">//获取到</span>
            HttpRequest httpRequest = (HttpRequest) msg;
            <span class="hljs-comment">//获取uri, 过滤指定的资源</span>
            URI uri = <span class="hljs-keyword">new</span> URI(httpRequest.uri());
            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;
                System.out.println(<span class="hljs-string">&quot;请求了 favicon.ico, 不做响应&quot;</span>);
                <span class="hljs-keyword">return</span>;
            &#125;
            <span class="hljs-comment">//回复信息给浏览器 [http协议]</span>

            ByteBuf content = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 我是服务器&quot;</span>, CharsetUtil.UTF_8);

            <span class="hljs-comment">//构造一个http的相应，即 httpresponse</span>
            FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);

            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="hljs-string">&quot;text/plain&quot;</span>);
            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());

            <span class="hljs-comment">//将构建好 response返回</span>
            ctx.writeAndFlush(response);

        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="6-Netty-核心模块组件"><a href="#6-Netty-核心模块组件" class="headerlink" title="6 Netty 核心模块组件"></a>6 Netty 核心模块组件</h2><h3 id="6-1-Bootstrap、ServerBootstrap"><a href="#6-1-Bootstrap、ServerBootstrap" class="headerlink" title="6.1 Bootstrap、ServerBootstrap"></a>6.1 Bootstrap、ServerBootstrap</h3><ol>
<li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li>
<li>常见的方法有<ul>
<li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li>
<li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li>
<li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li>
<li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li>
<li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li>
<li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li>
<li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li>
<li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li>
</ul>
</li>
</ol>
<h3 id="6-2-Future、ChannelFuture"><a href="#6-2-Future、ChannelFuture" class="headerlink" title="6.2 Future、ChannelFuture"></a>6.2 Future、ChannelFuture</h3><p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p>
<p>常见的方法有</p>
<ul>
<li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li>
<li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li>
</ul>
<h3 id="6-3-Channel"><a href="#6-3-Channel" class="headerlink" title="6.3 Channel"></a>6.3 Channel</h3><ol>
<li><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</p>
</li>
<li><p>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</p>
</li>
<li><p>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</p>
</li>
<li><p><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</p>
</li>
<li><p>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</p>
</li>
<li><p>支持关联 <code>I/O</code> 操作与对应的处理程序</p>
</li>
<li><p>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code>类型与之对应，常用的<code>Channel</code>类型：</p>
<ul>
<li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li>
<li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li>
<li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li>
</ul>
</li>
</ol>
<h3 id="6-4-Selector"><a href="#6-4-Selector" class="headerlink" title="6.4 Selector"></a>6.4 Selector</h3><ol>
<li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li>
<li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li>
</ol>
<h3 id="6-5-ChannelHandler-及其实现类"><a href="#6-5-ChannelHandler-及其实现类" class="headerlink" title="6.5 ChannelHandler 及其实现类"></a>6.5 ChannelHandler 及其实现类</h3><ol>
<li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li>
<li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li>
<li><code>ChannelHandler</code> 及其实现类一览图（后）</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_01.png" alt="img"></p>
<ol>
<li>我们经常需要自定义一个 <code>Handler</code> 类去继承 <code>ChannelInboundHandlerAdapter</code>，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_02.png" alt="img"></p>
<h3 id="6-6-Pipeline-和-ChannelPipelin"><a href="#6-6-Pipeline-和-ChannelPipelin" class="headerlink" title="6.6 Pipeline 和 ChannelPipelin"></a>6.6 Pipeline 和 ChannelPipelin</h3><p><code>ChannelPipeline</code> 是一个重点：</p>
<ol>
<li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li>
<li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li>
<li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_03.png" alt="img"></p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_04.png" alt="img"></p>
<ol>
<li>常用方法 <code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li>
</ol>
<h3 id="6-7-ChannelHandlerContext"><a href="#6-7-ChannelHandlerContext" class="headerlink" title="6.7 ChannelHandlerContext"></a>6.7 ChannelHandlerContext</h3><ol>
<li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li>
<li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</li>
<li>常用方法<ul>
<li><code>ChannelFuture close()</code>，关闭通道</li>
<li><code>ChannelOutboundInvoker flush()</code>，刷新</li>
<li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到</li>
<li><code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</li>
</ul>
</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_05.png" alt="img"></p>
<h3 id="6-8-ChannelOption"><a href="#6-8-ChannelOption" class="headerlink" title="6.8 ChannelOption"></a>6.8 ChannelOption</h3><ol>
<li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li>
<li><code>ChannelOption</code> 参数如下：</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_06.png" alt="img"></p>
<h3 id="6-9-EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#6-9-EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="6.9 EventLoopGroup 和其实现类 NioEventLoopGroup"></a>6.9 EventLoopGroup 和其实现类 NioEventLoopGroup</h3><ol>
<li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，<code>Netty</code> 为了更好的利用多核 <code>CPU</code> 资源，一般会有多个 <code>EventLoop</code> 同时工作，每个 <code>EventLoop</code> 维护着一个 <code>Selector</code> 实例。</li>
<li><code>EventLoopGroup</code> 提供 <code>next</code> 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code> 来处理任务。在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</li>
<li>通常一个服务端口即一个 <code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和一个 <code>EventLoop</code> 线程。<code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_07.png" alt="img"></p>
<ol>
<li>常用方法 <code>public NioEventLoopGroup()</code>，构造方法 <code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li>
</ol>
<h3 id="6-10-Unpooled-类"><a href="#6-10-Unpooled-类" class="headerlink" title="6.10 Unpooled 类"></a>6.10 Unpooled 类</h3><ol>
<li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li>
<li>常用方法如下所示</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_08.png" alt="img"></p>
<ol>
<li>举例说明 <code>Unpooled</code> 获取 <code>Netty</code> 的数据容器 <code>ByteBuf</code> 的基本使用【案例演示】</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_09.png" alt="img"></p>
<p>案例 1</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.buf;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyByteBuf01</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        
        <span class="hljs-comment">//创建一个ByteBuf</span>
        <span class="hljs-comment">//说明</span>
        <span class="hljs-comment">//1. 创建 对象，该对象包含一个数组arr , 是一个byte[10]</span>
        <span class="hljs-comment">//2. 在netty 的buffer中，不需要使用flip 进行反转</span>
        <span class="hljs-comment">//   底层维护了 readerindex 和 writerIndex</span>
        <span class="hljs-comment">//3. 通过 readerindex 和  writerIndex 和  capacity， 将buffer分成三个区域</span>
        <span class="hljs-comment">// 0---readerindex 已经读取的区域</span>
        <span class="hljs-comment">// readerindex---writerIndex ， 可读的区域</span>
        <span class="hljs-comment">// writerIndex -- capacity, 可写的区域</span>
        ByteBuf buffer = Unpooled.buffer(<span class="hljs-number">10</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            buffer.writeByte(i);
        &#125;

        System.out.println(<span class="hljs-string">&quot;capacity=&quot;</span> + buffer.capacity());<span class="hljs-comment">//10</span>
        <span class="hljs-comment">//输出</span>
<span class="hljs-comment">//        for(int i = 0; i&lt;buffer.capacity(); i++) &#123;</span>
<span class="hljs-comment">//            System.out.println(buffer.getByte(i));</span>
<span class="hljs-comment">//        &#125;</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.capacity(); i++) &#123;
            System.out.println(buffer.readByte());
        &#125;
        System.out.println(<span class="hljs-string">&quot;执行完毕&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>案例 2</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.buf;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;

<span class="hljs-keyword">import</span> java.nio.charset.Charset;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyByteBuf02</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">//创建ByteBuf</span>
        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello,world!&quot;</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));

        <span class="hljs-comment">//使用相关的方法</span>
        <span class="hljs-keyword">if</span> (byteBuf.hasArray()) &#123; <span class="hljs-comment">// true</span>

            <span class="hljs-keyword">byte</span>[] content = byteBuf.array();

            <span class="hljs-comment">//将 content 转成字符串</span>
            System.out.println(<span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));

            System.out.println(<span class="hljs-string">&quot;byteBuf=&quot;</span> + byteBuf);

            System.out.println(byteBuf.arrayOffset()); <span class="hljs-comment">// 0</span>
            System.out.println(byteBuf.readerIndex()); <span class="hljs-comment">// 0</span>
            System.out.println(byteBuf.writerIndex()); <span class="hljs-comment">// 12</span>
            System.out.println(byteBuf.capacity()); <span class="hljs-comment">// 36</span>

            <span class="hljs-comment">//System.out.println(byteBuf.readByte()); //</span>
            System.out.println(byteBuf.getByte(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 104</span>

            <span class="hljs-keyword">int</span> len = byteBuf.readableBytes(); <span class="hljs-comment">//可读的字节数  12</span>
            System.out.println(<span class="hljs-string">&quot;len=&quot;</span> + len);

            <span class="hljs-comment">//使用for取出各个字节</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;
                System.out.println((<span class="hljs-keyword">char</span>) byteBuf.getByte(i));
            &#125;

            <span class="hljs-comment">//按照某个范围读取</span>
            System.out.println(byteBuf.getCharSequence(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));
            System.out.println(byteBuf.getCharSequence(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="6-11-Netty-应用实例-群聊系统"><a href="#6-11-Netty-应用实例-群聊系统" class="headerlink" title="6.11 Netty 应用实例-群聊系统"></a>6.11 Netty 应用实例-群聊系统</h3><p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
<li>目的：进一步理解 <code>Netty</code> 非阻塞网络编程机制</li>
<li>看老师代码演示</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_10.png" alt="img"></p>
<p>代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.*;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port; <span class="hljs-comment">//监听端口</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.port = port;
    &#125;

    <span class="hljs-comment">//编写run方法，处理客户端的请求</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//创建两个线程组</span>
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>

        <span class="hljs-keyword">try</span> &#123;
            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();

            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)
                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)
                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;

                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

                            <span class="hljs-comment">//获取到pipeline</span>
                            ChannelPipeline pipeline = ch.pipeline();
                            <span class="hljs-comment">//向pipeline加入解码器</span>
                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> StringDecoder());
                            <span class="hljs-comment">//向pipeline加入编码器</span>
                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> StringEncoder());
                            <span class="hljs-comment">//加入自己的业务处理handler</span>
                            pipeline.addLast(<span class="hljs-keyword">new</span> GroupChatServerHandler());

                        &#125;
                    &#125;);

            System.out.println(<span class="hljs-string">&quot;netty 服务器启动&quot;</span>);
            ChannelFuture channelFuture = b.bind(port).sync();

            <span class="hljs-comment">//监听关闭</span>
            channelFuture.channel().closeFuture().sync();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-keyword">new</span> GroupChatServer(<span class="hljs-number">7000</span>).run();
    &#125;
&#125;


<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;

<span class="hljs-keyword">import</span> io.netty.channel.Channel;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;
<span class="hljs-keyword">import</span> io.netty.channel.group.ChannelGroup;
<span class="hljs-keyword">import</span> io.netty.channel.group.DefaultChannelGroup;
<span class="hljs-keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;

<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;

    <span class="hljs-comment">//public static List&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;();</span>

    <span class="hljs-comment">//使用一个hashmap 管理</span>
    <span class="hljs-comment">//public static Map&lt;String, Channel&gt; channels = new HashMap&lt;String,Channel&gt;();</span>

    <span class="hljs-comment">//定义一个channle 组，管理所有的channel</span>
    <span class="hljs-comment">//GlobalEventExecutor.INSTANCE) 是全局的事件执行器，是一个单例</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ChannelGroup channelGroup = <span class="hljs-keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);


    <span class="hljs-comment">//handlerAdded 表示连接建立，一旦连接，第一个被执行</span>
    <span class="hljs-comment">//将当前channel 加入到  channelGroup</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        Channel channel = ctx.channel();
        <span class="hljs-comment">//将该客户加入聊天的信息推送给其它在线的客户端</span>
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">        该方法会将 channelGroup 中所有的channel 遍历，并发送 消息，</span>
<span class="hljs-comment">        我们不需要自己遍历</span>
<span class="hljs-comment">         */</span>
        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 加入聊天&quot;</span> + sdf.format(<span class="hljs-keyword">new</span> java.util.Date()) + <span class="hljs-string">&quot; \n&quot;</span>);
        channelGroup.add(channel);


    &#125;

    <span class="hljs-comment">//断开连接, 将xx客户离开信息推送给当前在线的客户</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        Channel channel = ctx.channel();
        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 离开了\n&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;channelGroup size&quot;</span> + channelGroup.size());

    &#125;

    <span class="hljs-comment">//表示channel 处于活动状态, 提示 xx上线</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 上线了~&quot;</span>);
    &#125;

    <span class="hljs-comment">//表示channel 处于不活动状态, 提示 xx离线了</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 离线了~&quot;</span>);
    &#125;

    <span class="hljs-comment">//读取数据</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//获取到当前channel</span>
        Channel channel = ctx.channel();
        <span class="hljs-comment">//这时我们遍历channelGroup, 根据不同的情况，回送不同的消息</span>

        channelGroup.forEach(ch -&gt; &#123;
            <span class="hljs-keyword">if</span> (channel != ch) &#123; <span class="hljs-comment">//不是当前的channel,转发消息</span>
                ch.writeAndFlush(<span class="hljs-string">&quot;[客户]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 发送了消息&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//回显自己发送的消息给自己</span>
                ch.writeAndFlush(<span class="hljs-string">&quot;[自己]发送了消息&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);
            &#125;
        &#125;);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//关闭通道</span>
        ctx.close();
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;

<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.*;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;

<span class="hljs-keyword">import</span> java.util.Scanner;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>&#123;
    
    <span class="hljs-comment">//属性</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.host = host;
        <span class="hljs-keyword">this</span>.port = port;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();

        <span class="hljs-keyword">try</span> &#123;
            
            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap()
                    .group(group)
                    .channel(NioSocketChannel.class)
                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;

                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

                            <span class="hljs-comment">//得到pipeline</span>
                            ChannelPipeline pipeline = ch.pipeline();
                            <span class="hljs-comment">//加入相关handler</span>
                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> StringDecoder());
                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> StringEncoder());
                            <span class="hljs-comment">//加入自定义的handler</span>
                            pipeline.addLast(<span class="hljs-keyword">new</span> GroupChatClientHandler());
                        &#125;
                    &#125;);

            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();
            <span class="hljs-comment">//得到channel</span>
            Channel channel = channelFuture.channel();
            System.out.println(<span class="hljs-string">&quot;-------&quot;</span> + channel.localAddress() + <span class="hljs-string">&quot;--------&quot;</span>);
            <span class="hljs-comment">//客户端需要输入信息，创建一个扫描器</span>
            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);
            <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;
                String msg = scanner.nextLine();
                <span class="hljs-comment">//通过channel 发送到服务器端</span>
                channel.writeAndFlush(msg + <span class="hljs-string">&quot;\r\n&quot;</span>);
            &#125;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            group.shutdownGracefully();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">new</span> GroupChatClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>).run();
    &#125;
&#125;


<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(msg.trim());
    &#125;
&#125;</code></pre></div>

<h3 id="6-12-Netty-心跳检测机制案例"><a href="#6-12-Netty-心跳检测机制案例" class="headerlink" title="6.12 Netty 心跳检测机制案例"></a>6.12 Netty 心跳检测机制案例</h3><p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 心跳检测机制案例,当服务器超过 <code>3</code> 秒没有读时，就提示读空闲</li>
<li>当服务器超过 <code>5</code> 秒没有写操作时，就提示写空闲</li>
<li>实现当服务器超过 <code>7</code> 秒没有读或者写操作时，就提示读写空闲</li>
<li>代码如下：</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.heartbeat;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;
<span class="hljs-keyword">import</span> io.netty.handler.timeout.IdleStateHandler;

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        
        <span class="hljs-comment">//创建两个线程组</span>
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>
        <span class="hljs-keyword">try</span> &#123;

            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();

            serverBootstrap.group(bossGroup, workerGroup);
            serverBootstrap.channel(NioServerSocketChannel.class);
            serverBootstrap.handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO));
            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;

                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                    ChannelPipeline pipeline = ch.pipeline();
                    <span class="hljs-comment">//加入一个netty 提供 IdleStateHandler</span>
                    <span class="hljs-comment">/*</span>
<span class="hljs-comment">                    说明</span>
<span class="hljs-comment">                    1. IdleStateHandler 是netty 提供的处理空闲状态的处理器</span>
<span class="hljs-comment">                    2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span>
<span class="hljs-comment">                    3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span>
<span class="hljs-comment">                    4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">                    5. 文档说明</span>
<span class="hljs-comment">                    triggers an &#123;@link IdleStateEvent&#125; when a &#123;@link Channel&#125; has not performed</span>
<span class="hljs-comment"> * read, write, or both operation for a while.</span>
<span class="hljs-comment"> *                  6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个handler去处理</span>
<span class="hljs-comment"> *                  通过调用(触发)下一个handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)</span>
<span class="hljs-comment">                     */</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">7000</span>, <span class="hljs-number">7000</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS));
                    <span class="hljs-comment">//加入一个对空闲检测进一步处理的handler(自定义)</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> MyServerHandler());
                &#125;
            &#125;);

            <span class="hljs-comment">//启动服务器</span>
            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();
            channelFuture.channel().closeFuture().sync();

        &#125; <span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;


<span class="hljs-keyword">package</span> com.atguigu.netty.heartbeat;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;
<span class="hljs-keyword">import</span> io.netty.handler.timeout.IdleStateEvent;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evt 事件</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;

            <span class="hljs-comment">//将  evt 向下转型 IdleStateEvent</span>
            IdleStateEvent event = (IdleStateEvent) evt;
            String eventType = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">switch</span> (event.state()) &#123;
                <span class="hljs-keyword">case</span> READER_IDLE:
                    eventType = <span class="hljs-string">&quot;读空闲&quot;</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> WRITER_IDLE:
                    eventType = <span class="hljs-string">&quot;写空闲&quot;</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> ALL_IDLE:
                    eventType = <span class="hljs-string">&quot;读写空闲&quot;</span>;
                    <span class="hljs-keyword">break</span>;
            &#125;
            System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot;--超时时间--&quot;</span> + eventType);
            System.out.println(<span class="hljs-string">&quot;服务器做相应处理..&quot;</span>);

            <span class="hljs-comment">//如果发生空闲，我们关闭通道</span>
            <span class="hljs-comment">// ctx.channel().close();</span>
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接"><a href="#6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接" class="headerlink" title="6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接"></a>6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接</h3><p>实例要求：</p>
<ol>
<li><code>Http</code> 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。</li>
<li>要求：实现基于 <code>WebSocket</code> 的长连接的全双工的交互</li>
<li>改变 <code>Http</code> 协议多次请求的约束，实现长连接了，服务器可以发送消息给浏览器</li>
<li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li>
<li>运行界面</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_11.png" alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.websocket;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;
<span class="hljs-keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//创建两个线程组</span>
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>
        <span class="hljs-keyword">try</span> &#123;

            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();

            serverBootstrap.group(bossGroup, workerGroup);
            serverBootstrap.channel(NioServerSocketChannel.class);
            serverBootstrap.handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO));
            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;

                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                    ChannelPipeline pipeline = ch.pipeline();

                    <span class="hljs-comment">//因为基于http协议，使用http的编码和解码器</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> HttpServerCodec());
                    <span class="hljs-comment">//是以块方式写，添加ChunkedWriteHandler处理器</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler());

                    <span class="hljs-comment">/*</span>
<span class="hljs-comment">                    说明</span>
<span class="hljs-comment">                    1. http数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span>
<span class="hljs-comment">                    2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span>
<span class="hljs-comment">                     */</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">8192</span>));
                    <span class="hljs-comment">/*</span>
<span class="hljs-comment">                    说明</span>
<span class="hljs-comment">                    1. 对应websocket ，它的数据是以 帧(frame) 形式传递</span>
<span class="hljs-comment">                    2. 可以看到WebSocketFrame 下面有六个子类</span>
<span class="hljs-comment">                    3. 浏览器请求时 ws://localhost:7000/hello 表示请求的uri</span>
<span class="hljs-comment">                    4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws协议 , 保持长连接</span>
<span class="hljs-comment">                    5. 是通过一个 状态码 101</span>
<span class="hljs-comment">                     */</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">&quot;/hello2&quot;</span>));

                    <span class="hljs-comment">//自定义的handler ，处理业务逻辑</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> MyTextWebSocketFrameHandler());
                &#125;
            &#125;);

            <span class="hljs-comment">//启动服务器</span>
            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();
            channelFuture.channel().closeFuture().sync();

        &#125; <span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.websocket;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;

<span class="hljs-keyword">import</span> java.time.LocalDateTime;

<span class="hljs-comment">//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTextWebSocketFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        System.out.println(<span class="hljs-string">&quot;服务器收到消息 &quot;</span> + msg.text());

        <span class="hljs-comment">//回复消息</span>
        ctx.channel().writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">&quot;服务器时间&quot;</span> + LocalDateTime.now() + <span class="hljs-string">&quot; &quot;</span> + msg.text()));
    &#125;

    <span class="hljs-comment">//当web客户端连接后， 触发方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span>
        System.out.println(<span class="hljs-string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());
        System.out.println(<span class="hljs-string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asShortText());
    &#125;


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        System.out.println(<span class="hljs-string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;异常发生 &quot;</span> + cause.getMessage());
        ctx.close(); <span class="hljs-comment">//关闭连接</span>
    &#125;
&#125;</code></pre></div>

<p>hello.html</p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> socket;</span>
<span class="javascript">    <span class="hljs-comment">//判断当前浏览器是否支持websocket</span></span>
<span class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.WebSocket) &#123;</span>
<span class="javascript">        <span class="hljs-comment">//go on</span></span>
<span class="javascript">        socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://localhost:7000/hello2&quot;</span>);</span>
<span class="javascript">        <span class="hljs-comment">//相当于channelRead, ev 收到服务器端回送的消息</span></span>
<span class="javascript">        socket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span>
<span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span>
<span class="javascript">            rt.value = rt.value + <span class="hljs-string">&quot;\n&quot;</span> + ev.data;</span>
        &#125;

<span class="javascript">        <span class="hljs-comment">//相当于连接开启(感知到连接开启)</span></span>
<span class="javascript">        socket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span>
<span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span>
<span class="javascript">            rt.value = <span class="hljs-string">&quot;连接开启了..&quot;</span></span>
        &#125;

<span class="javascript">        <span class="hljs-comment">//相当于连接关闭(感知到连接关闭)</span></span>
<span class="javascript">        socket.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span>

<span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span>
<span class="javascript">            rt.value = rt.value + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;连接关闭了..&quot;</span></span>
        &#125;
<span class="javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span>
<span class="javascript">        alert(<span class="hljs-string">&quot;当前浏览器不支持websocket&quot;</span>)</span>
    &#125;

<span class="javascript">    <span class="hljs-comment">//发送消息到服务器</span></span>
<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params">message</span>) </span>&#123;</span>
<span class="javascript">        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.socket) &#123; <span class="hljs-comment">//先判断socket是否创建好</span></span>
<span class="javascript">            <span class="hljs-keyword">return</span>;</span>
        &#125;
        if (socket.readyState === WebSocket.OPEN) &#123;
<span class="javascript">            <span class="hljs-comment">//通过socket 发送消息</span></span>
            socket.send(message)
<span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span>
<span class="javascript">            alert(<span class="hljs-string">&quot;连接没有开启&quot;</span>);</span>
        &#125;
    &#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return false&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;发生消息&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send(this.form.message.value)&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;responseText&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;responseText&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;清空内容&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<h2 id="7-Google-Protobuf"><a href="#7-Google-Protobuf" class="headerlink" title="7 Google Protobuf"></a>7 Google Protobuf</h2><h3 id="7-1-编码和解码的基本介绍"><a href="#7-1-编码和解码的基本介绍" class="headerlink" title="7.1 编码和解码的基本介绍"></a>7.1 编码和解码的基本介绍</h3><ol>
<li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码[示意图]</li>
<li><code>codec</code>（编解码器）的组成部分有两个：<code>decoder</code>（解码器）和 <code>encoder</code>（编码器）。<code>encoder</code> 负责把业务数据转换成字节码数据，<code>decoder</code> 负责把字节码数据转换成业务数据</li>
</ol>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_01.png" alt="img"></p>
<h3 id="7-2-Netty-本身的编码解码的机制和问题分析"><a href="#7-2-Netty-本身的编码解码的机制和问题分析" class="headerlink" title="7.2 Netty 本身的编码解码的机制和问题分析"></a>7.2 Netty 本身的编码解码的机制和问题分析</h3><ol>
<li><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)</li>
<li><code>Netty</code> 提供的编码器 <code>StringEncoder</code>，对字符串数据进行编码 <code>ObjectEncoder</code>，对Java对象进行编码…</li>
<li><code>Netty</code> 提供的解码器 <code>StringDecoder</code>,对字符串数据进行解码 <code>ObjectDecoder</code>，对 <code>Java</code> 对象进行解码…</li>
<li><code>Netty</code> 本身自带的 <code>ObjectDecoder</code> 和 <code>ObjectEncoder</code> 可以用来实现 <code>POJO</code> 对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，存在如下问题<ul>
<li>无法跨语言</li>
<li>序列化后的体积太大，是二进制编码的5倍多。</li>
<li>序列化性能太低</li>
</ul>
</li>
<li>=&gt;引出新的解决方案[<code>Google</code> 的 <code>Protobuf</code>]</li>
</ol>
<h3 id="7-3-Protobuf"><a href="#7-3-Protobuf" class="headerlink" title="7.3 Protobuf"></a>7.3 Protobuf</h3><ol>
<li><code>Protobuf</code> 基本介绍和使用示意图</li>
<li><code>Protobuf</code> 是 <code>Google</code> 发布的开源项目，全称 <code>Google Protocol Buffers</code>，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 <code>RPC</code> [远程过程调用 <code>remote procedure call</code> ]数据交换格式。目前很多公司 <code>http + json tcp + protobuf</code></li>
<li>参考文档：<a href="https://developers.google.com/protocol-buffers/docs/proto">https://developers.google.com/protocol-buffers/docs/proto</a> 语言指南</li>
<li><code>Protobuf</code> 是以 <code>message</code> 的方式来管理数据的.</li>
<li>支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的]（支持目前绝大多数语言，例如 <code>C++</code>、<code>C#</code>、<code>Java</code>、<code>python</code> 等）</li>
<li>高性能，高可靠性</li>
<li>使用 <code>protobuf</code> 编译器能自动生成代码，<code>Protobuf</code> 是将类的定义使用 <code>.proto</code> 文件进行描述。说明，在 <code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.ptoto</code> 编写插件.可以让语法高亮。</li>
<li>然后通过 <code>protoc.exe</code> 编译器根据 <code>.proto</code> 自动生成 <code>.java</code> 文件</li>
<li><code>protobuf</code> 使用示意图</li>
</ol>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_02.png" alt="img"></p>
<h3 id="7-4-Protobuf-快速入门实例"><a href="#7-4-Protobuf-快速入门实例" class="headerlink" title="7.4 Protobuf 快速入门实例"></a>7.4 Protobuf 快速入门实例</h3><p>编写程序，使用 <code>Protobuf</code> 完成如下功能</p>
<ol>
<li>客户端可以发送一个 <code>StudentPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li>
<li>服务端能接收 <code>StudentPoJo</code> 对象，并显示信息(通过 <code>Protobuf</code> 解码)</li>
<li>具体看老师演示步骤</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java">Student.proto

syntax = <span class="hljs-string">&quot;proto3&quot;</span>; <span class="hljs-comment">//版本</span>
option java_outer_classname = <span class="hljs-string">&quot;StudentPOJO&quot;</span>;<span class="hljs-comment">//生成的外部类名，同时也是文件名</span>
<span class="hljs-comment">//protobuf 使用message 管理数据</span>
message Student &#123; <span class="hljs-comment">//会在 StudentPOJO 外部类生成一个内部类 Student， 他是真正发送的POJO对象</span>
    int32 id = <span class="hljs-number">1</span>; <span class="hljs-comment">// Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span>
    string name = <span class="hljs-number">2</span>;
&#125;

编译
protoc.exe--java_out=.Student.proto
将生成的 StudentPOJO 放入到项目使用</code></pre></div>

<h3 id="7-5-Protobuf-快速入门实例-2"><a href="#7-5-Protobuf-快速入门实例-2" class="headerlink" title="7.5 Protobuf 快速入门实例 2"></a>7.5 Protobuf 快速入门实例 2</h3><ol>
<li>编写程序，使用 <code>Protobuf</code> 完成如下功能</li>
<li>客户端可以随机发送 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li>
<li>服务端能接收 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象(需要判断是哪种类型)，并显示信息(通过 <code>Protobuf</code> 解码)</li>
<li>具体看老师演示步骤</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java">Student.proto

syntax = <span class="hljs-string">&quot;proto3&quot;</span>;
option optimize_for = SPEED; <span class="hljs-comment">// 加快解析</span>
option java_package=<span class="hljs-string">&quot;com.atguigu.netty.codec2&quot;</span>;   <span class="hljs-comment">//指定生成到哪个包下</span>
option java_outer_classname=<span class="hljs-string">&quot;MyDataInfo&quot;</span>; <span class="hljs-comment">// 外部类名, 文件名</span>

<span class="hljs-comment">//protobuf 可以使用message 管理其他的message</span>
message MyMessage &#123;

    <span class="hljs-comment">//定义一个枚举类型</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DataType</span> </span>&#123;
        StudentType = <span class="hljs-number">0</span>; <span class="hljs-comment">//在proto3 要求enum的编号从0开始</span>
        WorkerType = <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-comment">//用data_type 来标识传的是哪一个枚举类型</span>
    DataType data_type = <span class="hljs-number">1</span>;

    <span class="hljs-comment">//表示每次枚举类型最多只能出现其中的一个, 节省空间</span>
    oneof dataBody &#123;
        Student student = <span class="hljs-number">2</span>;
        Worker worker = <span class="hljs-number">3</span>;
    &#125;

&#125;


message Student &#123;
    int32 id = <span class="hljs-number">1</span>;<span class="hljs-comment">//Student类的属性</span>
    string name = <span class="hljs-number">2</span>; <span class="hljs-comment">//</span>
&#125;
message Worker &#123;
    string name=<span class="hljs-number">1</span>;
    int32 age=<span class="hljs-number">2</span>;
&#125;</code></pre></div>

<h2 id="8-Netty-编解码器和-Handler-调用机制"><a href="#8-Netty-编解码器和-Handler-调用机制" class="headerlink" title="8 Netty 编解码器和 Handler 调用机制"></a>8 Netty 编解码器和 Handler 调用机制</h2><h3 id="8-1-基本说明"><a href="#8-1-基本说明" class="headerlink" title="8.1 基本说明"></a>8.1 基本说明</h3><ol>
<li><code>Netty</code> 的组件设计：<code>Netty</code> 的主要组件有 <code>Channel</code>、<code>EventLoop</code>、<code>ChannelFuture</code>、<code>ChannelHandler</code>、<code>ChannelPipe</code> 等</li>
<li><code>ChannelHandler</code> 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 <code>ChannelInboundHandler</code> 接口（或 <code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从 <code>ChannelInboundHandler</code> 冲刷数据。业务逻辑通常写在一个或者多个 <code>ChannelInboundHandler</code> 中。<code>ChannelOutboundHandler</code> 原理一样，只不过它是用来处理出站数据的</li>
<li><code>ChannelPipeline</code> 提供了 <code>ChannelHandler</code> 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 <code>pipeline</code> 中的一系列 <code>ChannelOutboundHandler</code>，并被这些 <code>Handler</code> 处理，反之则称为入站的</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_01.png" alt="img"></p>
<h3 id="8-2编码解码器"><a href="#8-2编码解码器" class="headerlink" title="8.2编码解码器"></a>8.2编码解码器</h3><ol>
<li>当 <code>Netty</code> 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 <code>java</code> 对象）；如果是出站消息，它会被编码成字节。</li>
<li><code>Netty</code> 提供一系列实用的编解码器，他们都实现了 <code>ChannelInboundHadnler</code> 或者 <code>ChannelOutboundHandler</code> 接口。在这些类中，<code>channelRead</code> 方法已经被重写了。以入站为例，对于每个从入站 <code>Channel</code> 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 <code>decode()</code> 方法进行解码，并将已经解码的字节转发给 <code>ChannelPipeline</code> 中的下一个 <code>ChannelInboundHandler</code>。</li>
</ol>
<h3 id="8-3-解码器-ByteToMessageDecoder"><a href="#8-3-解码器-ByteToMessageDecoder" class="headerlink" title="8.3 解码器 - ByteToMessageDecoder"></a>8.3 解码器 - ByteToMessageDecoder</h3><ol>
<li>关系继承图</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_02.png" alt="img"></p>
<ol>
<li>由于不可能知道远程节点是否会一次性发送一个完整的信息，<code>tcp</code> 有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理.</li>
<li>一个关于 <code>ByteToMessageDecoder</code> 实例分析</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_03.png" alt="img"></p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_04.png" alt="img"></p>
<h3 id="8-4-Netty-的-handler-链的调用机制"><a href="#8-4-Netty-的-handler-链的调用机制" class="headerlink" title="8.4 Netty 的 handler 链的调用机制"></a>8.4 Netty 的 handler 链的调用机制</h3><p>实例要求:</p>
<ol>
<li>使用自定义的编码器和解码器来说明 <code>Netty</code> 的 <code>handler</code> 调用机制 客户端发送 <code>long</code> -&gt; 服务器 服务端发送 <code>long</code> -&gt; 客户端</li>
<li>案例演示</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_05.png" alt="img"></p>
<ol>
<li>结论<ul>
<li>不论解码器 <code>handler</code> 还是编码器 <code>handler</code> 即接收的消息类型必须与待处理的消息类型一致，否则该 <code>handler</code> 不会被执行</li>
<li>在解码器进行数据解码时，需要判断缓存区（<code>ByteBuf</code>）的数据是否足够，否则接收到的结果会期望结果可能不一致</li>
</ul>
</li>
</ol>
<h3 id="8-5-解码器-ReplayingDecoder"><a href="#8-5-解码器-ReplayingDecoder" class="headerlink" title="8.5 解码器 - ReplayingDecoder"></a>8.5 解码器 - ReplayingDecoder</h3><ol>
<li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></li>
<li><code>ReplayingDecoder</code> 扩展了 <code>ByteToMessageDecoder</code> 类，使用这个类，我们不必调用 <code>readableBytes()</code> 方法。参数 <code>S</code> 指定了用户状态管理的类型，其中 <code>Void</code> 代表不需要状态管理</li>
<li>应用实例：使用 <code>ReplayingDecoder</code> 编写解码器，对前面的案例进行简化[案例演示]</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyByteToLongDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyByteToLongDecoder2 被调用&quot;</span>);
        <span class="hljs-comment">//在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断</span>
        out.add(in.readLong());
    &#125;
&#125;</code></pre></div>

<ol start="4">
<li><code>ReplayingDecoder</code>使用方便，但它也有一些局限性：<ul>
<li>并不是所有的 <code>ByteBuf</code> 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>。</li>
<li><code>ReplayingDecoder</code> 在某些情况下可能稍慢于 <code>ByteToMessageDecoder</code>，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li>
</ul>
</li>
</ol>
<h3 id="8-6-其它编解码器"><a href="#8-6-其它编解码器" class="headerlink" title="8.6 其它编解码器"></a>8.6 其它编解码器</h3><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_06.png" alt="img"></p>
<h4 id="8-6-1-其它解码器"><a href="#8-6-1-其它解码器" class="headerlink" title="8.6.1 其它解码器"></a>8.6.1 其它解码器</h4><ol>
<li><code>LineBasedFrameDecoder</code>：这个类在 <code>Netty</code> 内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</li>
<li><code>DelimiterBasedFrameDecoder</code>：使用自定义的特殊字符作为消息的分隔符。</li>
<li><code>HttpObjectDecoder</code>：一个 <code>HTTP</code> 数据的解码器</li>
<li><code>LengthFieldBasedFrameDecoder</code>：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li>
</ol>
<h4 id="8-6-2-其它编码器"><a href="#8-6-2-其它编码器" class="headerlink" title="8.6.2 其它编码器"></a>8.6.2 其它编码器</h4><h3 id="8-7-Log4j-整合到-Netty"><a href="#8-7-Log4j-整合到-Netty" class="headerlink" title="8.7 Log4j 整合到 Netty"></a>8.7 Log4j 整合到 Netty</h3><ol>
<li>在 <code>Maven</code> 中添加对 <code>Log4j</code> 的依赖在 <code>pom.xml</code></li>
</ol>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<ol>
<li>配置 <code>Log4j</code>，在 <code>resources/log4j.properties</code></li>
</ol>
<div class="code-wrapper"><pre><code class="hljs xml">log4j.rootLogger=DEBUG,stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=[%p]%C&#123;1&#125;-%m%n</code></pre></div>

<ol>
<li>演示整合</li>
</ol>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_07.png" alt="img"></p>
<h2 id="9-TCP-粘包和拆包及解决方案"><a href="#9-TCP-粘包和拆包及解决方案" class="headerlink" title="9 TCP 粘包和拆包及解决方案"></a>9 TCP 粘包和拆包及解决方案</h2><h3 id="9-1-TCP-粘包和拆包基本介绍"><a href="#9-1-TCP-粘包和拆包基本介绍" class="headerlink" title="9.1 TCP 粘包和拆包基本介绍"></a>9.1 TCP 粘包和拆包基本介绍</h3><ol>
<li><code>TCP</code> 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 <code>socket</code>，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（<code>Nagle</code> 算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的</li>
<li>由于 <code>TCP</code> 无消息保护边界,需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题,看一张图</li>
<li>示意图 <code>TCP</code> 粘包、拆包图解</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter09_01.png" alt="img"></p>
<p>对图的说明: 假设客户端分别发送了两个数据包 <code>D1</code> 和 <code>D2</code> 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p>
<ol>
<li>服务端分两次读取到了两个独立的数据包，分别是 <code>D1</code> 和 <code>D2</code>，没有粘包和拆包</li>
<li>服务端一次接受到了两个数据包，<code>D1</code> 和 <code>D2</code> 粘合在一起，称之为 <code>TCP</code> 粘包</li>
<li>服务端分两次读取到了数据包，第一次读取到了完整的 <code>D1</code> 包和 <code>D2</code> 包的部分内容，第二次读取到了 <code>D2</code> 包的剩余内容，这称之为 <code>TCP</code> 拆包</li>
<li>服务端分两次读取到了数据包，第一次读取到了 <code>D1</code> 包的部分内容 <code>D1_1</code>，第二次读取到了 <code>D1</code> 包的剩余部分内容 <code>D1_2</code> 和完整的 <code>D2</code> 包。</li>
</ol>
<h3 id="9-2-TCP-粘包和拆包现象实例"><a href="#9-2-TCP-粘包和拆包现象实例" class="headerlink" title="9.2 TCP 粘包和拆包现象实例"></a>9.2 TCP 粘包和拆包现象实例</h3><p>在编写 <code>Netty</code> 程序时，如果没有做处理，就会发生粘包和拆包的问题</p>
<p>看一个具体的实例：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 核心代码</span>

MyClientHandler.java

<span class="hljs-keyword">package</span> com.atguigu.netty.tcp;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;

<span class="hljs-keyword">import</span> java.nio.charset.Charset;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//使用客户端发送10条数据 hello,server 编号</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;
            ByteBuf buffer = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello,server &quot;</span> + i, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));
            ctx.writeAndFlush(buffer);
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[msg.readableBytes()];
        msg.readBytes(buffer);

        String message = <span class="hljs-keyword">new</span> String(buffer, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));
        System.out.println(<span class="hljs-string">&quot;客户端接收到消息=&quot;</span> + message);
        System.out.println(<span class="hljs-string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));

    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        cause.printStackTrace();
        ctx.close();
    &#125;
&#125;

MyServerHandler.java

<span class="hljs-keyword">package</span> com.atguigu.netty.tcp;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;

<span class="hljs-keyword">import</span> java.nio.charset.Charset;
<span class="hljs-keyword">import</span> java.util.UUID;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//cause.printStackTrace();</span>
        ctx.close();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[msg.readableBytes()];
        msg.readBytes(buffer);

        <span class="hljs-comment">//将buffer转成字符串</span>
        String message = <span class="hljs-keyword">new</span> String(buffer, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));

        System.out.println(<span class="hljs-string">&quot;服务器接收到数据 &quot;</span> + message);
        System.out.println(<span class="hljs-string">&quot;服务器接收到消息量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));

        <span class="hljs-comment">//服务器回送数据给客户端, 回送一个随机id ,</span>
        ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="hljs-string">&quot; &quot;</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));
        ctx.writeAndFlush(responseByteBuf);

    &#125;
&#125;</code></pre></div>

<h3 id="9-3-TCP-粘包和拆包解决方案"><a href="#9-3-TCP-粘包和拆包解决方案" class="headerlink" title="9.3 TCP 粘包和拆包解决方案"></a>9.3 TCP 粘包和拆包解决方案</h3><ol>
<li>使用自定义协议+编解码器来解决</li>
<li>关键就是要解决服务器端每次读取数据长度的问题，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 <code>TCP</code> 粘包、拆包。</li>
</ol>
<h3 id="9-4-看一个具体的实例"><a href="#9-4-看一个具体的实例" class="headerlink" title="9.4 看一个具体的实例"></a>9.4 看一个具体的实例</h3><ol>
<li>要求客户端发送 <code>5</code> 个 <code>Message</code> 对象，客户端每次发送一个 <code>Message</code> 对象</li>
<li>服务器端每次接收一个 <code>Message</code>，分 <code>5</code> 次进行解码，每读取到一个 <code>Message</code>，会回复一个 <code>Message</code> 对象给客户端。</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter09_02.png" alt="img"></p>
<ol>
<li>代码演示，全部代码核心</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 核心</span>

<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;

<span class="hljs-comment">//协议包</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProtocol</span> </span>&#123;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> len; <span class="hljs-comment">//关键</span>
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] content;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> len;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.len = len;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getContent() &#123;
        <span class="hljs-keyword">return</span> content;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] content)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.content = content;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;

<span class="hljs-keyword">import</span> java.nio.charset.Charset;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//使用客户端发送10条数据 &quot;今天天气冷，吃火锅&quot; 编号</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            String mes = <span class="hljs-string">&quot;今天天气冷，吃火锅&quot;</span>;
            <span class="hljs-keyword">byte</span>[] content = mes.getBytes(Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));
            <span class="hljs-keyword">int</span> length = mes.getBytes(Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)).length;

            <span class="hljs-comment">//创建协议包对象</span>
            MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();
            messageProtocol.setLen(length);
            messageProtocol.setContent(content);
            ctx.writeAndFlush(messageProtocol);
        &#125;
    &#125;

    <span class="hljs-comment">//    @Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-keyword">int</span> len = msg.getLen();
        <span class="hljs-keyword">byte</span>[] content = msg.getContent();

        System.out.println(<span class="hljs-string">&quot;客户端接收到消息如下&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + len);
        System.out.println(<span class="hljs-string">&quot;内容=&quot;</span> + <span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));

        System.out.println(<span class="hljs-string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;异常消息=&quot;</span> + cause.getMessage());
        ctx.close();
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyMessageEncoder encode 方法被调用&quot;</span>);
        out.writeInt(msg.getLen());
        out.writeBytes(msg.getContent());
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyMessageDecoder decode 被调用&quot;</span>);
        <span class="hljs-comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span>
        <span class="hljs-keyword">int</span> length = in.readInt();

        <span class="hljs-keyword">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];
        in.readBytes(content);

        <span class="hljs-comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span>
        MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();
        messageProtocol.setLen(length);
        messageProtocol.setContent(content);
        out.add(messageProtocol);
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;

<span class="hljs-keyword">import</span> java.nio.charset.Charset;
<span class="hljs-keyword">import</span> java.util.UUID;


<span class="hljs-comment">//处理业务的handler</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//cause.printStackTrace();</span>
        ctx.close();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//接收到数据，并处理</span>
        <span class="hljs-keyword">int</span> len = msg.getLen();
        <span class="hljs-keyword">byte</span>[] content = msg.getContent();

        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println(<span class="hljs-string">&quot;服务器接收到信息如下&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + len);
        System.out.println(<span class="hljs-string">&quot;内容=&quot;</span> + <span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));

        System.out.println(<span class="hljs-string">&quot;服务器接收到消息包数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));

        <span class="hljs-comment">//回复消息</span>
        String responseContent = UUID.randomUUID().toString();
        <span class="hljs-keyword">int</span> responseLen = responseContent.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>).length;
        <span class="hljs-keyword">byte</span>[] responseContent2 = responseContent.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);
        <span class="hljs-comment">//构建一个协议包</span>
        MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();
        messageProtocol.setLen(responseLen);
        messageProtocol.setContent(responseContent2);

        ctx.writeAndFlush(messageProtocol);
    &#125;
&#125;</code></pre></div>

<h2 id="10-Netty-核心源码剖析"><a href="#10-Netty-核心源码剖析" class="headerlink" title="10 Netty 核心源码剖析"></a>10 Netty 核心源码剖析</h2><h3 id="10-1-基本说明"><a href="#10-1-基本说明" class="headerlink" title="10.1 基本说明"></a>10.1 基本说明</h3><ol>
<li>只有看过 <code>Netty</code> 源码，才能说是真的掌握了 <code>Netty</code> 框架。</li>
<li>在 <code>io.netty.example</code> 包下，有很多 <code>Netty</code> 源码案例，可以用来分析。</li>
<li>源码分析章节是针对有 <code>Java</code> 项目经验，并且玩过框架源码的人员讲的，否则你听起来会有相当的难度。</li>
</ol>
<h3 id="10-2-Netty-启动过程源码剖析"><a href="#10-2-Netty-启动过程源码剖析" class="headerlink" title="10.2 Netty 启动过程源码剖析"></a>10.2 Netty 启动过程源码剖析</h3><h4 id="10-2-1-源码剖析目的"><a href="#10-2-1-源码剖析目的" class="headerlink" title="10.2.1 源码剖析目的"></a>10.2.1 源码剖析目的</h4><p>用源码分析的方式走一下 <code>Netty</code>（服务器）的启动过程，更好的理解 <code>Netty</code> 的整体设计和运行机制。</p>
<h4 id="10-2-2-源码剖析"><a href="#10-2-2-源码剖析" class="headerlink" title="10.2.2 源码剖析"></a>10.2.2 源码剖析</h4><p>说明：</p>
<ol>
<li>源码需要剖析到 <code>Netty</code> 调用 <code>doBind</code> 方法，追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>。</li>
<li>并且要 <code>Debug</code> 程序到 <code>NioEventLoop</code> 类的 <code>run</code> 代码，无限循环，在服务器端运行。</li>
</ol>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_01.png" alt="img"></p>
<h4 id="10-2-3-源码剖析过程"><a href="#10-2-3-源码剖析过程" class="headerlink" title="10.2.3 源码剖析过程"></a>10.2.3 源码剖析过程</h4><p><strong>1. <code>demo</code> 源码的基本理解</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 服务器启动类源码</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * Copyright 2012 The Netty Project</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * The Netty Project licenses this file to you under the Apache License,</span>
<span class="hljs-comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span>
<span class="hljs-comment"> * with the License. You may obtain a copy of the License at:</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="hljs-comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="hljs-comment"> * License for the specific language governing permissions and limitations</span>
<span class="hljs-comment"> * under the License.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">package</span> atguigu.netty.example.echo2;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;
<span class="hljs-keyword">import</span> io.netty.handler.ssl.SslContext;
<span class="hljs-keyword">import</span> io.netty.handler.ssl.SslContextBuilder;
<span class="hljs-keyword">import</span> io.netty.handler.ssl.util.SelfSignedCertificate;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Echoes back any received data from a client.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> SSL = System.getProperty(<span class="hljs-string">&quot;ssl&quot;</span>) != <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>));

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// Configure SSL.</span>
        <span class="hljs-keyword">final</span> SslContext sslCtx;
        <span class="hljs-keyword">if</span> (SSL) &#123;
            SelfSignedCertificate ssc = <span class="hljs-keyword">new</span> SelfSignedCertificate();
            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
        &#125; <span class="hljs-keyword">else</span> &#123;
            sslCtx = <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-comment">// Configure the server.</span>
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();
        <span class="hljs-keyword">try</span> &#123;
            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)
                    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))
                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                            ChannelPipeline p = ch.pipeline();
                            <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;
                                p.addLast(sslCtx.newHandler(ch.alloc()));
                            &#125;
                            <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>
                            p.addLast(<span class="hljs-keyword">new</span> EchoServerHandler());
                        &#125;
                    &#125;);

            <span class="hljs-comment">// Start the server.</span>
            ChannelFuture f = b.bind(PORT).sync();

            <span class="hljs-comment">// Wait until the server socket is closed.</span>
            f.channel().closeFuture().sync();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// Shut down all event loops to terminate all threads.</span>
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>说明：</p>
<ol>
<li>先看启动类：<code>main</code> 方法中，首先创建了关于 SSL 的配置类。</li>
<li>重点分析下创建了两个 <code>EventLoopGroup</code> 对象：</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java">EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();</code></pre></div>

<p>(1) 这两个对象是整个 <code>Netty</code> 的核心对象，可以说，整个 <code>Netty</code> 的运作都依赖于他们。<code>bossGroup</code> 用于接受 <code>TCP</code> 请求，他会将请求交给 <code>workerGroup</code>，<code>workerGroup</code> 会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作。</p>
<p>(2) <code>EventLoopGroup</code> 是事件循环组（线程组）含有多个 <code>EventLoop</code>，可以注册 <code>channel</code>，用于在事件循环中去进行选择（和选择器相关）。【debug看】</p>
<p>(3) <code>new NioEventLoopGroup(1);</code> 这个 <code>1</code> 表示 <code>bossGroup</code> 事件组有 <code>1</code> 个线程你可以指定，如果 <code>new NioEventLoopGroup()</code> 会含有默认个线程 <code>cpu核数 * 2</code>，即可以充分的利用多核的优势，【可以dubug一把】</p>
<div class="code-wrapper"><pre><code class="hljs java">DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));</code></pre></div>

<p>会创建 <code>EventExecutor</code> 数组 <code>children = new EventExecutor[nThreads];</code> // <code>debug</code> 一下每个元素的类型就是 <code>NIOEventLoop</code>，<code>NIOEventLoop</code> 实现了 <code>EventLoop</code> 接口和 <code>Executor</code> 接口 <code>try</code> 块中创建了一个 <code>ServerBootstrap</code> 对象，他是一个引导类，用于启动服务器和引导整个程序的初始化（看下源码 <code>allowseasybootstrapof&#123;@linkServerChannel&#125;</code>）。它和 <code>ServerChannel</code> 关联，而 <code>ServerChannel</code> 继承了 <code>Channel</code>，有一些方法 <code>remoteAddress</code> 等[可以Debug下]随后，变量 <code>b</code> 调用了 <code>group</code> 方法将两个 <code>group</code> 放入了自己的字段中，用于后期引导使用【<code>debug</code> 下 <code>group</code> 方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> *Set the &#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125; for the parent (acceptor) and the child (client) . These</span>
<span class="hljs-comment"> *&#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125;&#x27;s are used to handle all the events and IO for &#123;<span class="hljs-doctag">@link</span> ServerChannel&#125; and </span>
<span class="hljs-comment"> *&#123;<span class="hljs-doctag">@link</span> Channel&#125;&#x27;s.</span>
<span class="hljs-comment"> */</span></code></pre></div>

<p>】。</p>
<p>(4) 然后添加了一个 <code>channel</code>，其中参数一个 <code>Class</code> 对象，引导类将通过这个 <code>Class</code> 对象反射创建 <code>ChannelFactory</code>。然后添加了一些 <code>TCP</code> 的参数。【说明：<code>Channel</code> 的创建在 <code>bind</code> 方法，可以 <code>Debug</code> 下 <code>bind</code>，会找到 <code>channel = channelFactory.newChannel();</code> 】</p>
<p>(5) 再添加了一个服务器专属的日志处理器 <code>handler</code> 。</p>
<p>(6) 再添加一个 <code>SocketChannel</code>（不是 <code>ServerSocketChannel</code>）的 <code>handler</code>。</p>
<p>(7) 然后绑定端口并阻塞至连接成功。</p>
<p>(8) 最后 <code>main</code> 线程阻塞等待关闭。</p>
<p>(9) <code>finally</code> 块中的代码将在服务器关闭时优雅关闭所有资源。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> * Copyright 2012 The Netty Project</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * The Netty Project licenses this file to you under the Apache License,</span>
<span class="hljs-comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span>
<span class="hljs-comment"> * with the License. You may obtain a copy of the License at:</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="hljs-comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="hljs-comment"> * License for the specific language governing permissions and limitations</span>
<span class="hljs-comment"> * under the License.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">package</span> atguigu.netty.example.echo2;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandler.Sharable;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Handler implementation for the echo server.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Sharable</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;
        ctx.write(msg);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
        ctx.flush();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;
        <span class="hljs-comment">// Close the connection when an exception is raised.</span>
        cause.printStackTrace();
        ctx.close();
    &#125;
&#125;</code></pre></div>

<p>说明:</p>
<ol>
<li>这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端。</li>
<li>大致讲解了我们的 <code>demo</code> 源码的作用。后面的 <code>debug</code> 的时候会详细。</li>
</ol>
<p><strong>2. 分析 EventLoopGroup 的过程</strong></p>
<p>2.1 构造器方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123; 
    <span class="hljs-keyword">this</span>(nThreads, (Executor) <span class="hljs-keyword">null</span>);
&#125;</code></pre></div>

<p>2.2 上面的 <code>this(nThreads, (Executor) null);</code> 调用构造器（通过 <code>alt + d</code> 看即可）</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor)</span> </span>&#123;
    <span class="hljs-keyword">this</span>(nThreads, executor, SelectorProvider.provider());
&#125;</code></pre></div>

<p>2.3 上面的 <code>this(nThreads, executor, SelectorProvider.provider());</code> 调用下面构造器</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider)</span> </span>&#123;
    <span class="hljs-keyword">this</span>(nThreads, executor, selectorProvider,DefaultSelectStrategyFactory.INSTANCE);
&#125;</code></pre></div>

<p>2.4 上面的 <code>this()...</code> 调用构造器（<code>alt + d</code>）</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider,<span class="hljs-keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;
    <span class="hljs-keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());
&#125;</code></pre></div>

<p>2.5 上面的 <code>super()..</code> 的方法是父类：<code>MultithreadEventLoopGroup</code></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, Object...args)</span> </span>&#123;
    <span class="hljs-keyword">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
&#125;</code></pre></div>

<p>2.6 追踪到源码抽象类 <code>MultithreadEventExecutorGroup</code> 的构造器方法 <code>MultithreadEventExecutorGroup</code> 才是 <code>NioEventLoopGroup</code> 真正的构造方法，这里可以看成是一个模板方法，使用了设计模式的模板模式（可看我录制视频），所以，我们就需要好好分析 <code>MultithreadEventExecutorGroup</code> 方法了</p>
<p>2.7 分析 <code>MultithreadEventExecutorGroup</code></p>
<p>参数说明：</p>
<ul>
<li><code>@param nThreads</code> 使用的线程数，默认为 <code>core * 2</code>【可以追踪源码】</li>
<li><code>@param executor</code> 执行器:如果传入 <code>null</code>, 则采用 <code>Netty</code> 默认的线程工厂和默认的执行器 <code>ThreadPerTaskExecutor</code></li>
<li><code>@param chooserFactory</code> 单例 <code>new DefaultEventExecutorChooserFactory()</code></li>
<li><code>@param args args</code> 在创建执行器的时候传入固定参数</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor,</span></span>
<span class="hljs-function"><span class="hljs-params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (nThreads &lt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));
    &#125;

    <span class="hljs-keyword">if</span> (executor == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果传入的执行器是空的则采用默认的线程工厂和默认的执行器</span>
        executor = <span class="hljs-keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());
    &#125;

    <span class="hljs-comment">// 创建指定线程数的执行器数组</span>
    children = <span class="hljs-keyword">new</span> EventExecutor[nThreads];

    <span class="hljs-comment">// 初始化线程数组</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;
        <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 创建 new NioEventLoop</span>
            children[i] = newChild(executor, args);
            success = <span class="hljs-keyword">true</span>;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// 如果创建失败，优雅关闭</span>
            <span class="hljs-keyword">if</span> (!success) &#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;
                    children[j].shutdownGracefully();
                &#125;

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;
                    EventExecutor e = children[j];
                    <span class="hljs-keyword">try</span> &#123;
                        <span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;
                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                        &#125;
                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;
                        <span class="hljs-comment">// Let the caller handle the interruption.</span>
                        Thread.currentThread().interrupt();
                        <span class="hljs-keyword">break</span>;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;

    chooser = chooserFactory.newChooser(children);

    <span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> FutureListener&lt;Object&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
            <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;
                terminationFuture.setSuccess(<span class="hljs-keyword">null</span>);
            &#125;
        &#125;
    &#125;;
    
    <span class="hljs-comment">// 为每一个单例线程池添加一个关闭监听器</span>
    <span class="hljs-keyword">for</span> (EventExecutor e: children) &#123;
        e.terminationFuture().addListener(terminationListener);
    &#125;

    Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);
    <span class="hljs-comment">//将所有的单例线程池添加到一个 HashSet 中。</span>
    Collections.addAll(childrenSet, children);
    readonlyChildren = Collections.unmodifiableSet(childrenSet);
&#125;</code></pre></div>

<p>说明：</p>
<ol>
<li>如果 <code>executor</code> 是 <code>null</code>，创建一个默认的 <code>ThreadPerTaskExecutor</code>，使用 <code>Netty</code> 默认的线程工厂。</li>
<li>根据传入的线程数（<code>CPU * 2</code>）创建一个线程池（单例线程池）数组。</li>
<li>循环填充数组中的元素。如果异常，则关闭所有的单例线程池。</li>
<li>根据线程选择工厂创建一个线程选择器。</li>
<li>为每一个单例线程池添加一个关闭监听器。</li>
<li>将所有的单例线程池添加到一个 <code>HashSet</code> 中。</li>
</ol>
<p><strong>3. ServerBootstrap 创建和构造过程</strong></p>
<p>3.1 <code>ServerBootstrap</code> 是个空构造，但是有默认的成员变量</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="hljs-keyword">new</span> LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();

<span class="hljs-comment">// config 对象，会在后面起很大作用</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerBootstrapConfig config = <span class="hljs-keyword">new</span> ServerBootstrapConfig(<span class="hljs-keyword">this</span>);
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> EventLoopGroup childGroup;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ChannelHandler childHandler;</code></pre></div>

<p>3.2 分析一下 <code>ServerBootstrap</code> 基本使用情况</p>
<div class="code-wrapper"><pre><code class="hljs java">ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();
b.group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)
        .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))
        .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                ChannelPipeline p = ch.pipeline();
                <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;
                    p.addLast(sslCtx.newHandler(ch.alloc()));
                &#125;
                <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>
                p.addLast(<span class="hljs-keyword">new</span> EchoServerHandler());
            &#125;
        &#125;);</code></pre></div>

<p>说明:</p>
<ol>
<li>链式调用：<code>group</code> 方法，将 <code>boss</code> 和 <code>worker</code> 传入，<code>boss</code> 赋值给 <code>parentGroup</code> 属性, <code>worker</code> 赋值给 <code>childGroup</code> 属性。</li>
<li><code>channel</code> 方法传入 <code>NioServerSocketChannelclass</code> 对象。会根据这个 <code>class</code> 创建 <code>channel</code> 对象。</li>
<li><code>option</code> 方法传入 <code>TCP</code> 参数，放在一个 <code>LinkedHashMap</code> 中。</li>
<li><code>handler</code> 方法传入一个 <code>handler</code> 中，这个 <code>hanlder</code> 只专属于 <code>ServerSocketChannel</code> 而不是 <code>SocketChannel</code>。</li>
<li><code>childHandler</code> 传入一个 <code>hanlder</code>，这个 <code>handler</code> 将会在每个客户端连接的时候调用。供 <code>SocketChannel</code> 使用。</li>
</ol>
<p><strong>4. 绑定端口的分析</strong></p>
<p>4.1 服务器就是在这个 <code>bind</code> 方法里启动完成的 4.2 <code>bind</code> 方法代码,追踪到创建了一个端口对象，并做了一些空判断，核心代码 <code>doBind</code>，我们看看</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;
    validate();
    <span class="hljs-keyword">if</span> (localAddress == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;localAddress&quot;</span>);
    &#125;
    <span class="hljs-keyword">return</span> doBind(localAddress);
&#125;</code></pre></div>

<p>4.3 <code>doBind</code> 源码剖析，核心是两个方法 <code>initAndRegister</code> 和 <code>doBind0</code></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> </span>&#123;
    <span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();
    <span class="hljs-keyword">final</span> Channel channel = regFuture.channel();
    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">return</span> regFuture;
    &#125;

    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;
        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span>
        ChannelPromise promise = channel.newPromise();
        <span class="hljs-comment">//============================================</span>
        <span class="hljs-comment">//说明:执行doBind0方法，完成对端口的绑定</span>
        <span class="hljs-comment">//============================================</span>
        doBind0(regFuture, channel, localAddress, promise);
        <span class="hljs-keyword">return</span> promise;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span>
        <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);
        regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                Throwable cause = future.cause();
                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span>
                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span>
                    promise.setFailure(cause);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span>
                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span>
                    promise.registered();

                    doBind0(regFuture, channel, localAddress, promise);
                &#125;
            &#125;
        &#125;);
        <span class="hljs-keyword">return</span> promise;
    &#125;
&#125;</code></pre></div>

<p>4.4 分析说明 <code>initAndRegister</code></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">initAndRegister</span><span class="hljs-params">()</span> </span>&#123;
    Channel channel = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> &#123;
        channel = channelFactory.newChannel();

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 说明：channelFactory.newChannel() 方法的作用通过 ServerBootstrap 的通道工厂反射创建一个 NioServerSocketChannel,具体追踪源码可以得到下面结论</span>
<span class="hljs-comment">         * (1)通过 NIO 的 SelectorProvider 的 openServerSocketChannel 方法得到 JDK 的 channel。目的是让 Netty 包装 JDK 的 channel。</span>
<span class="hljs-comment">         * (2)创建了一个唯一的 ChannelId，创建了一个 NioMessageUnsafe，用于操作消息，创建了一个 DefaultChannelPipeline 管道，是个双向链表结构，用于过滤所有的进出的消息。</span>
<span class="hljs-comment">         * (3)创建了一个 NioServerSocketChannelConfig 对象，用于对外展示一些配置。 </span>
<span class="hljs-comment">         </span>
<span class="hljs-comment">         * channel = channelFactory.newChannel();//NioServerSocketChannel</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">         * 说明：init 初始化这个 NioServerSocketChannel，具体追踪源码可以得到如下结论</span>
<span class="hljs-comment">         * (1) init 方法，这是个抽象方法 (AbstractBootstrap类的），由ServerBootstrap实现（可以追一下源码//setChannelOptions(channel,options,logger);）。</span>
<span class="hljs-comment">         * (2)设置 NioServerSocketChannel 的 TCP 属性。</span>
<span class="hljs-comment">         * (3)由于 LinkedHashMap 是非线程安全的，使用同步进行处理。</span>
<span class="hljs-comment">         * (4)对 NioServerSocketChannel 的 ChannelPipeline 添加 ChannelInitializer 处理器。</span>
<span class="hljs-comment">         * (5)可以看出，init 的方法的核心作用在和 ChannelPipeline 相关。</span>
<span class="hljs-comment">         * (6)从 NioServerSocketChannel 的初始化过程中，我们知道，pipeline 是一个双向链表，并且，他本身就初始化了 head 和 tail，这里调用了他的 addLast 方法，也就是将整个 handler 插入到 tail 的前面，因为 tail 永远会在后面，需要做一些系统的固定工作。</span>
<span class="hljs-comment">         */</span>
        init(channel);
    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;
            channel.unsafe().closeForcibly();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    &#125;

    ChannelFuture regFuture = config().group().register(channel);
    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;
            channel.close();
        &#125; <span class="hljs-keyword">else</span> &#123;
            channel.unsafe().closeForcibly();
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> regFuture;
&#125;</code></pre></div>

<p>说明：</p>
<ol>
<li>基本说明：<code>initAndRegister()</code> 初始化 <code>NioServerSocketChannel</code> 通道并注册各个 <code>handler</code>，返回一个 <code>future</code>。</li>
<li>通过 <code>ServerBootstrap</code> 的通道工厂反射创建一个 <code>NioServerSocketChannel</code>。</li>
<li><code>init</code> 初始化这个 <code>NioServerSocketChannel</code>。</li>
<li><code>config().group().register(channel)</code> 通过 <code>ServerBootstrap</code> 的 <code>bossGroup</code> 注册 <code>NioServerSocketChannel</code>。</li>
<li>最后，返回这个异步执行的占位符即 <code>regFuture</code>。</li>
</ol>
<p>4.5 <code>init</code> 方法会调用 <code>addLast</code>，现在进入到 <code>addLast</code> 方法内查看</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;
    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
        checkMultiplicity(handler);
        newCtx = newContext(group, filterName(name, handler), handler);
        addLast0(newCtx);
        <span class="hljs-keyword">if</span> (!registered) &#123;
            newCtx.setAddPending();
            callHandlerCallbackLater(newCtx, <span class="hljs-keyword">true</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        &#125;
        EventExecutor executor = newCtx.executor();
        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;
            callHandlerAddedInEventLoop(newCtx, executor);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        &#125;
    &#125;
    callHandlerAdded0(newCtx);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre></div>

<p>说明：</p>
<ol>
<li><code>addLast</code> 方法，在 <code>DefaultChannelPipeline</code> 类中</li>
<li><code>addLast</code> 方法这就是 <code>pipeline</code> 方法的核心</li>
<li>检查该 <code>handler</code> 是否符合标准。</li>
<li>创建一个 <code>AbstractChannelHandlerContext</code> 对象，这里说一下，<code>ChannelHandlerContext</code> 对象是 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的关联，每当有 <code>ChannelHandler</code> 添加到 <code>Pipeline</code> 中时，都会创建 <code>Context</code>。<code>Context</code> 的主要功能是管理他所关联的 <code>Handler</code> 和同一个 <code>Pipeline</code> 中的其他 <code>Handler</code> 之间的交互。</li>
<li>将 <code>Context</code> 添加到链表中。也就是追加到 <code>tail</code> 节点的前面。</li>
<li>最后，同步或者异步或者晚点异步的调用 <code>callHandlerAdded0</code> 方法</li>
</ol>
<p>4.6 前面说了 <code>dobind</code> 方法有 <code>2</code> 个重要的步骤，<code>initAndRegister</code> 说完，接下来看 <code>doBind0</code> 方法，代码如下</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind0</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> ChannelFuture regFuture, <span class="hljs-keyword">final</span> Channel channel,</span></span>
<span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;

    <span class="hljs-comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span>
    <span class="hljs-comment">// the pipeline in its channelRegistered() implementation.</span>
    channel.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">if</span> (regFuture.isSuccess()) &#123;
                <span class="hljs-comment">//bind方法这里下断点，这里下断点，来玩!!</span>
                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            &#125; <span class="hljs-keyword">else</span> &#123;
                promise.setFailure(regFuture.cause());
            &#125;
        &#125;
    &#125;);
&#125;</code></pre></div>

<p>说明：</p>
<ol>
<li>该方法的参数为 <code>initAndRegister</code> 的 <code>future</code>，<code>NioServerSocketChannel</code>，端口地址，<code>NioServerSocketChannel</code> 的 <code>promise</code></li>
<li>这里就可以根据前面下的断点，一直 <code>debug</code>：</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 将调用 LoggingHandler 的 invokeBind 方法,最后会追到</span>
<span class="hljs-comment">// DefaultChannelPipeline 类的 bind</span>
<span class="hljs-comment">// 然后进入到 unsafe.bind 方法 debug，注意要追踪到</span>
<span class="hljs-comment">// unsafe.bind，要 debug 第二圈的时候，才能看到。</span>

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span> <span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    unsafe.bind(localAddress,promise);
&#125;

<span class="hljs-comment">// 继续追踪 AbstractChannel 的 </span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span> <span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;
    <span class="hljs-comment">//....</span>
    <span class="hljs-keyword">try</span>&#123;
        <span class="hljs-comment">//!!!! 小红旗可以看到，这里最终的方法就是 doBind 方法，执行成功后，执行通道的 fireChannelActive 方法，告诉所有的 handler，已经成功绑定。</span>
        doBind(localAddress);<span class="hljs-comment">//</span>
    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
        safeSetFailure(promise, t);
        closeIfClosed();
        <span class="hljs-keyword">return</span>;
    &#125;
&#125;</code></pre></div>

<ol>
<li>最终 <code>doBind</code> 就会追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>，说明 <code>Netty</code> 底层使用的是 <code>NIO</code></li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span> <span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;
        javaChannel().bind(localAddress, config.getBacklog());
    &#125; <span class="hljs-keyword">else</span> &#123;
        javaChannel().socket().bind(localAddress, config.getBacklog());
    &#125;
&#125;</code></pre></div>

<ol>
<li>回到 <code>bind</code> 方法（<code>alt + v</code>），最后一步：<code>safeSetSuccess(promise)</code>，告诉 <code>promise</code> 任务成功了。其可以执行监听器的方法了。到此整个启动过程已经结束了，ok 了</li>
<li>继续 <code>atl + v</code> 服务器就回进入到（<code>NioEventLoop</code> 类）一个循环代码，进行监听</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">for</span>(;;) &#123;
        <span class="hljs-keyword">try</span>&#123;

        &#125;
    &#125;
&#125;</code></pre></div>

<h4 id="10-2-4-Netty-启动过程梳理"><a href="#10-2-4-Netty-启动过程梳理" class="headerlink" title="10.2.4 Netty 启动过程梳理"></a>10.2.4 Netty 启动过程梳理</h4><ol>
<li>创建 <code>2</code> 个 <code>EventLoopGroup</code> 线程池数组。数组默认大小 <code>CPU * 2</code>，方便 <code>chooser</code> 选择线程池时提高性能</li>
<li><code>BootStrap</code> 将 <code>boss</code> 设置为 <code>group</code> 属性，将 <code>worker</code> 设置为 <code>childer</code> 属性</li>
<li>通过 <code>bind</code> 方法启动，内部重要方法为 <code>initAndRegister</code> 和 <code>dobind</code> 方法</li>
<li><code>initAndRegister</code> 方法会反射创建 <code>NioServerSocketChannel</code> 及其相关的 <code>NIO</code> 的对象，<code>pipeline</code>，<code>unsafe</code>，同时也为 <code>pipeline</code> 初始了 <code>head</code> 节点和 <code>tail</code> 节点。</li>
<li>在 <code>register0</code> 方法成功以后调用在 <code>dobind</code> 方法中调用 <code>doBind0</code> 方法，该方法会调用 <code>NioServerSocketChannel</code> 的 <code>doBind</code> 方法对 <code>JDK</code> 的 <code>channel</code> 和端口进行绑定，完成 <code>Netty</code> 服务器的所有启动，并开始监听连接事件。</li>
</ol>
<h3 id="10-3-Netty-接受请求过程源码剖析"><a href="#10-3-Netty-接受请求过程源码剖析" class="headerlink" title="10.3 Netty 接受请求过程源码剖析"></a>10.3 Netty 接受请求过程源码剖析</h3><h4 id="10-3-1-源码剖析目的"><a href="#10-3-1-源码剖析目的" class="headerlink" title="10.3.1 源码剖析目的"></a>10.3.1 源码剖析目的</h4><ol>
<li>服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，下面源码分析 <code>Netty</code> 在启动之后是如何接受客户端请求的</li>
<li>在 <code>io.netty.example</code> 包下</li>
</ol>
<h4 id="10-3-2-源码剖析"><a href="#10-3-2-源码剖析" class="headerlink" title="10.3.2 源码剖析"></a>10.3.2 源码剖析</h4><p>说明：</p>
<ol>
<li>从之前服务器启动的源码中，我们得知，服务器最终注册了一个 <code>Accept</code> 事件等待客户端的连接。我们也知道，<code>NioServerSocketChannel</code> 将自己注册到了 <code>boss</code> 单例线程池（<code>reactor</code> 线程）上，也就是 <code>EventLoop</code>。</li>
<li>先简单说下 <code>EventLoop</code> 的逻辑(后面我们详细讲解 <code>EventLoop</code>)</li>
</ol>
<p><code>EventLoop</code> 的作用是一个死循环，而这个循环中做 3 件事情：</p>
<ol>
<li><p>有条件的等待 <code>NIO</code> 事件。</p>
</li>
<li><p>处理 <code>NIO</code> 事件。</p>
</li>
<li><p>处理消息队列中的任务。</p>
</li>
<li><p>仍用前面的项目来分析：进入到 <code>NioEventLoop</code> 源码中后，在 <code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法开始调试最终我们要分析到 <code>AbstractNioChannel</code> 的 <code>doBeginRead</code> 方法，当到这个方法时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</p>
<p>源码分析过程</p>
</li>
<li><p>断点位置 <code>NioEventLoop</code> 的如下方法 <code>processSelectedKey</code></p>
</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;
    unsafe.read();<span class="hljs-comment">//断点位置</span>
&#125;</code></pre></div>

<ol>
<li>执行浏览器 <code>http://localhost:8007/</code> ，客户端发出请求</li>
<li>从的断点我们可以看到，<code>readyOps</code> 是 <code>16</code>，也就是 <code>Accept</code> 事件。说明浏览器的请求已经进来了。</li>
<li>这个 <code>unsafe</code> 是 <code>boss</code> 线程中 <code>NioServerSocketChannel</code> 的 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 对象。我们进入到 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 的 <code>read</code> 方法中</li>
<li><code>read</code> 方法代码并分析:</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
    asserteventLoop().inEventLoop();
    <span class="hljs-keyword">final</span> ChannelConfig config = config();
    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();
    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();
    allocHandle.reset(config);
    booleanclosed = <span class="hljs-keyword">false</span>;
    Throwable exception = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">do</span> &#123;
                <span class="hljs-keyword">int</span> localRead = doReadMessages(readBuf);
                <span class="hljs-keyword">if</span> (localRead == <span class="hljs-number">0</span>) &#123;
                    <span class="hljs-keyword">break</span>;
                &#125;
                <span class="hljs-keyword">if</span> (localRead &lt; <span class="hljs-number">0</span>) &#123;
                    closed = <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">break</span>;
                &#125;
                
                allocHandle.incMessagesRead(localRead);
            &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());
        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
            exception = t;
        &#125;
        
        <span class="hljs-keyword">int</span> size = readBuf.size();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;
            readPending = <span class="hljs-keyword">false</span>;
            pipeline.fireChannelRead(readBuf.get(i));
        &#125;
        readBuf.clear();
        allocHandle.readComplete();
        pipeline.fireChannelReadComplete();
        
        <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;
            closed = closeOnReadError(exception);

            pipeline.fireExceptionCaught(exception);
        &#125;
        
        <span class="hljs-keyword">if</span> (closed) &#123;
            inputShutdown = <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">if</span>(isOpen()) &#123;
                close(voidPromise());
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">//Check if there is a readPending which was not processed yet.</span>
        <span class="hljs-comment">//This could be for two reasons:</span>
        <span class="hljs-comment">//* The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span>
        <span class="hljs-comment">//* The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span>
        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;
            removeReadOp();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>说明： 1)检查该 <code>eventloop</code> 线程是否是当前线程。<code>asserteventLoop().inEventLoop()</code></p>
<p>2)执行 <code>doReadMessages</code> 方法，并传入一个 <code>readBuf</code> 变量，这个变量是一个 <code>List</code>，也就是容器。</p>
<p>3)循环容器，执行 <code>pipeline.fireChannelRead(readBuf.get(i));</code></p>
<p>4)<code>doReadMessages</code> 是读取 <code>boss</code> 线程中的 <code>NioServerSocketChannel</code> 接受到的请求。并把这些请求放进容器，一会我们 <code>debug</code> 下 <code>doReadMessages</code> 方法。</p>
<p>5)循环遍历容器中的所有请求，调用 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法，用于处理这些接受的请求或者其他事件，在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p>
<ol>
<li>追踪一下 <code>doReadMessages</code> 方法，就可以看得更清晰</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span> <span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    SocketChannel ch = SocketUtils.accept(javaChannel());
    buf.add(newNioSocketChannel(<span class="hljs-keyword">this</span>, ch));
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
&#125;</code></pre></div>

<p>说明： 1)通过工具类，调用 <code>NioServerSocketChannel</code> 内部封装的 <code>serverSocketChannel</code> 的 <code>accept</code> 方法，这是 <code>NIO</code> 做法。</p>
<p>2)获取到一个 <code>JDK</code> 的 <code>SocketChannel</code>，然后，使用 <code>NioSocketChannel</code> 进行封装。最后添加到容器中</p>
<p>3)这样容器 <code>buf</code> 中就有了 <code>NioSocketChannel</code> 【如果有兴趣可以追一下 <code>NioSocketChannel</code> 是如何创建的，我就不追了】</p>
<ol>
<li>回到 <code>read</code> 方法，继续分析循环执行 <code>pipeline.fireChannelRead</code> 方法</li>
</ol>
<p>1)前面分析 <code>doReadMessages</code> 方法的作用是通过 <code>ServerSocket</code> 的 <code>accept</code> 方法获取到 <code>TCP</code> 连接，然后封装成 <code>Netty</code> 的 <code>NioSocketChannel</code> 对象。最后添加到容器中</p>
<p>2)在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p>
<p>3)经过 <code>dubug</code>（多次），可以看到会反复执行多个 <code>handler</code> 的 <code>ChannelRead</code>，我们知道，<code>pipeline</code> 里面又 <code>4</code> 个 <code>handler</code>，分别是 <code>Head</code>，<code>LoggingHandler</code>，<code>ServerBootstrapAcceptor</code>，<code>Tail</code>。</p>
<p>4)我们重点看看 <code>ServerBootstrapAcceptor</code>。<code>debug</code> 之后，断点会进入到 <code>ServerBootstrapAcceptor</code> 中来。我们来看看 <code>ServerBootstrapAcceptor</code> 的 <code>channelRead</code> 方法（要多次 <code>debug</code> 才可以）</p>
<p>5)<code>channelRead</code> 方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span> <span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;
    <span class="hljs-keyword">final</span> Channelchild = (Channel)msg;
    child.pipeline().addLast(childHandler);
    setChannelOptions(child, childOptions, logger);
    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e : childAttrs) &#123;
        child.attr((AttributeKey&lt;Object&gt;)e.getKey()).set(e.getValue());
    &#125;
    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//将客户端连接注册到 worker 线程池</span>
        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuturefuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;
                    forceClose(child, future.cause());
                &#125;
            &#125;
        &#125;);
    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
        forceClose(child, t);
    &#125;
&#125;</code></pre></div>

<p>说明： 1)<code>msg</code> 强转成 <code>Channel</code>，实际上就是 <code>NioSocketChannel</code>。</p>
<p>2)添加 <code>NioSocketChannel</code> 的 <code>pipeline</code> 的 <code>handler</code>，就是我们 <code>main</code> 方法里面设置的 <code>childHandler</code> 方法里的。</p>
<p>3)设置 <code>NioSocketChannel</code> 的各种属性。</p>
<p>4)将该 <code>NioSocketChannel</code> 注册到 <code>childGroup</code> 中的一个 <code>EventLoop</code> 上，并添加一个监听器。</p>
<p>5)这个 <code>childGroup</code> 就是我们 <code>main</code> 方法创建的数组 <code>workerGroup</code>。</p>
<ol>
<li>进入 <code>register</code> 方法查看(步步追踪会到)</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span> <span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;
    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;
    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;
        register0(promise);
    &#125; <span class="hljs-keyword">else</span> &#123;
        eventLoop.execute(<span class="hljs-keyword">new</span> Runnable()&#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                register0(promise);<span class="hljs-comment">//进入到这里</span>
            &#125;
        &#125;);
    &#125;
&#125;
<span class="hljs-comment">// 继续进入到下面方法，执行管道中可能存在的任务,这里我们就不追了</span></code></pre></div>

<ol>
<li>最终会调用 <code>doBeginRead</code> 方法，也就是 <code>AbstractNioChannel</code> 类的方法</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-comment">//Channel.read() or ChannelHandlerContext.read() was called</span>
    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<span class="hljs-comment">//断点</span>
    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    readPending = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();
    <span class="hljs-keyword">if</span> ((interestOps&amp;readInterestOp) == <span class="hljs-number">0</span>) &#123;
        selectionKey.interestOps(interestOps | readInterestOp);
    &#125;
&#125;</code></pre></div>

<ol>
<li>这个地方调试时，请把前面的断点都去掉，然后启动服务器就会停止在 <code>doBeginRead</code>（需要先放过该断点，然后浏览器请求，才能看到效果）</li>
<li>执行到这里时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</li>
</ol>
<h4 id="10-3-3-Netty-接受请求过程梳理"><a href="#10-3-3-Netty-接受请求过程梳理" class="headerlink" title="10.3.3 Netty 接受请求过程梳理"></a>10.3.3 Netty 接受请求过程梳理</h4><p>总体流程：接受连接 –&gt; 创建一个新的 <code>NioSocketChannel</code> –&gt; 注册到一个 <code>workerEventLoop</code> 上 –&gt; 注册 <code>selecotRead</code> 事件。</p>
<ol>
<li>服务器轮询 <code>Accept</code> 事件，获取事件后调用 <code>unsafe</code> 的 <code>read</code> 方法，这个 <code>unsafe</code> 是 <code>ServerSocket</code> 的内部类，该方法内部由 <code>2</code> 部分组成</li>
<li><code>doReadMessages</code> 用于创建 <code>NioSocketChannel</code> 对象，该对象包装 <code>JDK</code> 的 <code>NioChannel</code> 客户端。该方法会像创建 <code>ServerSocketChanel</code> 类似创建相关的 <code>pipeline</code>，<code>unsafe</code>，<code>config</code></li>
<li>随后执行执行 <code>pipeline.fireChannelRead</code> 方法，并将自己绑定到一个 <code>chooser</code> 选择器选择的 <code>workerGroup</code> 中的一个 <code>EventLoop</code>。并且注册一个 <code>0</code>，表示注册成功，但并没有注册读（1）事件</li>
</ol>
<h3 id="10-4-Pipeline-Handler-HandlerContext-创建源码剖析"><a href="#10-4-Pipeline-Handler-HandlerContext-创建源码剖析" class="headerlink" title="10.4 Pipeline Handler HandlerContext 创建源码剖析"></a>10.4 Pipeline Handler HandlerContext 创建源码剖析</h3><h4 id="10-4-1-源码剖析目的"><a href="#10-4-1-源码剖析目的" class="headerlink" title="10.4.1 源码剖析目的"></a>10.4.1 源码剖析目的</h4><p><code>Netty</code> 中的 <code>ChannelPipeline</code>、<code>ChannelHandler</code> 和 <code>ChannelHandlerContext</code> 是非常核心的组件，我们从源码来分析 <code>Netty</code> 是如何设计这三个核心组件的，并分析是如何创建和协调工作的.</p>
<h4 id="10-4-2-源码剖析说明"><a href="#10-4-2-源码剖析说明" class="headerlink" title="10.4.2 源码剖析说明"></a>10.4.2 源码剖析说明</h4><p>说明 分析过程中，有很多的图形，所以我们准备了一个文档，在文档的基础上来做源码剖析</p>
<h4 id="10-4-3-源码剖析"><a href="#10-4-3-源码剖析" class="headerlink" title="10.4.3 源码剖析"></a>10.4.3 源码剖析</h4><ol>
<li>ChannelPipeline | ChannelHandler | ChannelHandlerContext介绍</li>
<li>1 三者关系</li>
</ol>
<p>1)每当 <code>ServerSocket</code> 创建一个新的连接，就会创建一个 <code>Socket</code>，对应的就是目标客户端。</p>
<p>2)每一个新创建的 <code>Socket</code> 都将会分配一个全新的 <code>ChannelPipeline</code>（以下简称 <code>pipeline</code>）</p>
<p>3)每一个 <code>ChannelPipeline</code> 内部都含有多个 <code>ChannelHandlerContext</code>（以下简称 <code>Context</code>）</p>
<p>4)他们一起组成了双向链表，这些 <code>Context</code> 用于包装我们调用 <code>addLast</code> 方法时添加的 <code>ChannelHandler</code>（以下简称 <code>handler</code>）</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_02.png" alt="img"></p>
<p>1)上图中：<code>ChannelSocket</code> 和 <code>ChannelPipeline</code> 是一对一的关联关系，而 <code>pipeline</code> 内部的多个 <code>Context</code> 形成了链表，<code>Context</code> 只是对 <code>Handler</code> 的封装。 2)当一个请求进来的时候，会进入 <code>Socket</code> 对应的 <code>pipeline</code>，并经过 <code>pipeline</code> 所有的 <code>handler</code>，对，就是设计模式中的过滤器模式。</p>
<p>1.2 ChannelPipeline 作用及设计</p>
<p>1)<code>pipeline</code> 的接口设计</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_03.png" alt="img"></p>
<p>部分源码</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_04.png" alt="img"></p>
<p>可以看到该接口继承了 <code>inBound</code>，<code>outBound</code>，<code>Iterable</code> 接口，表示他可以调用数据出站的方法和入站的方法，同时也能遍历内部的链表，看看他的几个代表性的方法，基本上都是针对 <code>handler</code> 链表的插入，追加，删除，替换操作，类似是一个 <code>LinkedList</code>。同时，也能返回 <code>channel</code>（也就是 <code>socket</code>）</p>
<p>1)在 <code>pipeline</code> 的接口文档上，提供了一幅图</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_05.png" alt="img"></p>
<p>对上图的解释说明： *这是一个 <code>handler</code> 的 <code>list</code>，<code>handler</code> 用于处理或拦截入站事件和出站事件，<code>pipeline</code> 实现了过滤器的高级形式，以便用户控制事件如何处理以及 <code>handler</code> 在 <code>pipeline</code> 中如何交互。</p>
<p>*上图描述了一个典型的 <code>handler</code> 在 <code>pipeline</code> 中处理 <code>I/O</code> 事件的方式，<code>IO</code> 事件由 <code>inboundHandler</code> 或者 <code>outBoundHandler</code> 处理，并通过调用 <code>ChannelHandlerContext.fireChannelRead</code> 方法转发给其最近的处理程序。</p>
<p>*入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的 <code>I/O</code> 线程生成入站数据。入站数据通常从如 <code>SocketChannel.read(ByteBuffer)</code> 获取。</p>
<p>*通常一个 <code>pipeline</code> 有多个 <code>handler</code>，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序协议解码器-将二进制数据转换为 <code>Java</code> 对象。协议编码器-将 <code>Java</code> 对象转换为二进制数据。业务逻辑处理程序-执行实际业务逻辑（例如数据库访问）</p>
<p>*你的业务程序不能将线程阻塞，会影响 <code>IO</code> 的速度，进而影响整个 <code>Netty</code> 程序的性能。如果你的业务程序很快，就可以放在 <code>IO</code> 线程中，反之，你需要异步执行。或者在添加 <code>handler</code> 的时候添加一个线程池，例如：</p>
<p>// 下面这个任务执行的时候，将不会阻塞 <code>IO</code> 线程，执行的线程来自 <code>group</code> 线程池</p>
<div class="code-wrapper"><pre><code class="hljs reasonml">pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">group</span>, <span class="hljs-string">&quot;handler&quot;</span>, <span class="hljs-params">new</span> MyBusinessLogicHandler()</span>);</code></pre></div>

<p>1.3 <code>ChannelHandler</code> 作用及设计</p>
<p>1)源码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelHandler</span> </span>&#123;
    <span class="hljs-comment">//当把 ChannelHandler 添加到 pipeline 时被调用</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;
    <span class="hljs-comment">//当从 pipeline 中移除时调用</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;
    <span class="hljs-comment">//当处理过程中在 pipeline 发生异常时调用</span>
    <span class="hljs-meta">@Deprecated</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception</span>;
&#125;</code></pre></div>

<p>2)<code>ChannelHandler</code> 的作用就是处理 <code>IO</code> 事件或拦截 <code>IO</code> 事件，并将其转发给下一个处理程序 <code>ChannelHandler</code>。<code>Handler</code> 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，<code>Netty</code> 定义了两个子接口继承 <code>ChannelHandler</code></p>
<p>2)<code>ChannelInboundHandler</code> 入站事件接口</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_06.png" alt="img"></p>
<p>*<code>channelActive</code> 用于当 <code>Channel</code> 处于活动状态时被调用；</p>
<p>*<code>channelRead</code> 当从 <code>Channel</code> 读取数据时被调用等等方法。</p>
<p>*程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，<code>Netty</code> 会回调对应的方法。</p>
<p>3)`ChannelOutboundHandler 出站事件接口</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_07.png" alt="img"></p>
<p>*<code>bind</code> 方法，当请求将 <code>Channel</code> 绑定到本地地址时调用</p>
<p>*<code>close</code> 方法，当请求关闭 <code>Channel</code> 时调用等等</p>
<p>*出站操作都是一些连接和写出数据类似的方法。</p>
<p>4)<code>ChannelDuplexHandler</code> 处理出站和入站事件</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_08.png" alt="img"></p>
<p>*<code>ChannelDuplexHandler</code> 间接实现了入站接口并直接实现了出站接口。</p>
<p>*是一个通用的能够同时处理入站事件和出站事件的类。</p>
<p>1.4 <code>ChannelHandlerContext</code> 作用及设计</p>
<p>1)<code>ChannelHandlerContext</code> <code>UML</code> 图</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_09.png" alt="img"></p>
<p><code>ChannelHandlerContext</code> 继承了出站方法调用接口和入站方法调用接口</p>
<p>1)<code>ChannelOutboundInvoker</code> 和 <code>ChannelInboundInvoker</code> 部分源码</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_10.png" alt="img"></p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_11.png" alt="img"></p>
<p>*这两个 <code>invoker</code> 就是针对入站或出站方法来的，就是在入站或出站 <code>handler</code> 的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的</p>
<p>2)<code>ChannelHandlerContext</code> 部分源码</p>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_12.png" alt="img"></p>
<p>*<code>ChannelHandlerContext</code> 不仅仅时继承了他们两个的方法，同时也定义了一些自己的方法</p>
<p>*这些方法能够获取 <code>Context</code> 上下文环境中对应的比如 <code>channel</code>，<code>executor</code>，<code>handler</code>，<code>pipeline</code>，内存分配器，关联的 <code>handler</code> 是否被删除。</p>
<p>*<code>Context</code> 就是包装了 <code>handler</code> 相关的一切，以方便 <code>Context</code> 可以在 <code>pipeline</code> 方便的操作 <code>handler</code></p>
<p>2.ChannelPipeline | ChannelHandler | ChannelHandlerContext</p>
<p>创建过程分为 <code>3</code> 个步骤来看创建的过程：</p>
<p>*任何一个 <code>ChannelSocket</code> 创建的同时都会创建一个 <code>pipeline</code>。</p>
<p>*当用户或系统内部调用 <code>pipeline</code> 的 <code>add</code></p>
<p>*** 方法添加 <code>handler</code> 时，都会创建一个包装这 <code>handler</code> 的 <code>Context</code>。</p>
<p>*这些 <code>Context</code> 在 <code>pipeline</code> 中组成了双向链表。</p>
<p>2.1 <code>Socket</code> 创建的时候创建 <code>pipeline</code> 在 <code>SocketChannel</code> 的抽象父类 <code>AbstractChannel</code> 的构造方法中</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractChannel</span><span class="hljs-params">(Channel parent)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.parent=parent;<span class="hljs-comment">//断点测试</span>
    id = newId();
    unsafe = <span class="hljs-keyword">new</span> Unsafe();
    pipeline = <span class="hljs-keyword">new</span> ChannelPipeline();
&#125;</code></pre></div>

<p><code>Debug</code> 一下，可以看到代码会执行到这里，然后继续追踪到</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">DefaultChannelPipeline</span><span class="hljs-params">(Channel channel)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="hljs-string">&quot;channel&quot;</span>);
    succeededFuture = <span class="hljs-keyword">new</span> SucceededChannelFuture(channel, <span class="hljs-keyword">null</span>);
    voidPromise = <span class="hljs-keyword">new</span> VoidChannelPromise(channel, <span class="hljs-keyword">true</span>);
    tail = <span class="hljs-keyword">new</span> TailContext(<span class="hljs-keyword">this</span>);
    head = <span class="hljs-keyword">new</span> HeadContext(<span class="hljs-keyword">this</span>);
    head.next = tail;
    tail.prev = head;
&#125;</code></pre></div>

<p>说明：</p>
<p>1）将 <code>channel</code> 赋值给 <code>channel</code> 字段，用于 <code>pipeline</code> 操作 <code>channel</code>。</p>
<p>2）创建一个 <code>future</code> 和 <code>promise</code>，用于异步回调使用。</p>
<p>3）创建一个 <code>inbound</code> 的 <code>tailContext</code>，创建一个既是 <code>inbound</code> 类型又是 <code>outbound</code> 类型的 <code>headContext</code>。</p>
<p>4）最后，将两个 <code>Context</code> 互相连接，形成双向链表。</p>
<p>5）<code>tailContext</code> 和 <code>HeadContext</code> 非常的重要，所有 <code>pipeline</code> 中的事件都会流经他们，</p>
<p>2.2 在 add<strong>添加处理器的时候创建Context</strong>看下 <code>DefaultChannelPipeline</code> 的 <code>addLast</code> 方法如何创建的 <code>Context</code>，代码如下</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (handlers == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//断点</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;handlers&quot;</span>);
    &#125;
    <span class="hljs-keyword">for</span> (ChannelHandler h : handlers) &#123;
        <span class="hljs-keyword">if</span> (h == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        addLast(executor, <span class="hljs-keyword">null</span>, h);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre></div>

<p>继续 Debug</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;
    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;
    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;
        checkMultiplicity(handler);

        newCtx = newContext(group, filterName(name, handler), handler);
        addLast0(newCtx);
        <span class="hljs-comment">//If the registered is false it means that the channel was not registered on an eventloop yet.</span>
        <span class="hljs-comment">//In this case we add the context to the pipeline and add a task that will call</span>
        <span class="hljs-comment">//ChannelHandler.handlerAdded(...) once the channel is registered.</span>
        <span class="hljs-keyword">if</span> (!registered) &#123;
            newCtx.setAddPending();
            callHandlerCallbackLater(newCtx, <span class="hljs-keyword">true</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        &#125;

        EventExecutor executor = newCtx.executor();
        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;
            newCtx.setAddPending();
            executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>&#123;
                    callHandlerAdded0(newCtx);
                &#125;
            &#125;);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        &#125;
    &#125;
    callHandlerAdded0(newCtx);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre></div>

<p>说明 1)<code>pipeline</code> 添加 <code>handler</code>，参数是线程池，<code>name</code> 是 <code>null</code>，<code>handler</code> 是我们或者系统传入的 <code>handler</code>。<code>Netty</code> 为了防止多个线程导致安全问题，同步了这段代码，步骤如下：</p>
<p>2)检查这个 <code>handler</code> 实例是否是共享的，如果不是，并且已经被别的 <code>pipeline</code> 使用了，则抛出异常。</p>
<p>3)调用 <code>new Context(group, filterName(name, handler), handler)</code> 方法，创建一个 <code>Context</code>。从这里可以看出来了，每次添加一个 <code>handler</code> 都会创建一个关联 <code>Context</code>。</p>
<p>4)调用 <code>addLast</code> 方法，将 <code>Context</code> 追加到链表中。</p>
<p>5)如果这个通道还没有注册到 <code>selecor</code> 上，就将这个 <code>Context</code> 添加到这个 <code>pipeline</code> 的待办任务中。当注册好了以后，就会调用 <code>callHandlerAdded0</code> 方法（默认是什么都不做，用户可以实现这个方法）。</p>
<p>6)到这里，针对三对象创建过程，了解的差不多了，和最初说的一样，每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。<code>tail</code> 是入站 <code>inbound</code> 类型的 <code>handler</code>，<code>head</code> 既是 <code>inbound</code> 也是 <code>outbound</code> 类型的 <code>handler</code>。在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。到此就 <code>OK</code> 了。</p>
<h4 id="10-4-4-Pipeline-Handler-HandlerContext-创建过程梳理"><a href="#10-4-4-Pipeline-Handler-HandlerContext-创建过程梳理" class="headerlink" title="10.4.4 Pipeline Handler HandlerContext 创建过程梳理"></a>10.4.4 Pipeline Handler HandlerContext 创建过程梳理</h4><ol>
<li>每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。</li>
<li>在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。</li>
<li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表</li>
<li>入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始</li>
</ol>
<h3 id="10-5-ChannelPipeline-调度-handler-的源码剖析"><a href="#10-5-ChannelPipeline-调度-handler-的源码剖析" class="headerlink" title="10.5 ChannelPipeline 调度 handler 的源码剖析"></a>10.5 ChannelPipeline 调度 handler 的源码剖析</h3><h4 id="10-5-1-源码剖析目的"><a href="#10-5-1-源码剖析目的" class="headerlink" title="10.5.1 源码剖析目的"></a>10.5.1 源码剖析目的</h4><ol>
<li>当一个请求进来的时候，<code>ChannelPipeline</code> 是如何调用内部的这些 <code>handler</code> 的呢？我们一起来分析下。</li>
<li>首先，当一个请求进来的时候，会第一个调用 <code>pipeline</code> 的相关方法，如果是入站事件，这些方法由 <code>fire</code> 开头，表示开始管道的流动。让后面的 <code>handler</code> 继续处理</li>
</ol>
<h4 id="10-5-2-源码剖析"><a href="#10-5-2-源码剖析" class="headerlink" title="10.5.2 源码剖析"></a>10.5.2 源码剖析</h4><p>当浏览器输入 <code>http://localhost:8007</code> 。可以看到会执行 <code>handler</code> 在 <code>Debug</code> 时，可以将断点下在 <code>DefaultChannelPipeline</code> 类的</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelActive</span><span class="hljs-params">()</span> </span>&#123;
    AbstractChannelHandlerContext.invokeChannelActive(head);<span class="hljs-comment">//断点</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre></div>

<p>源码分析</p>
<ol>
<li><code>DefaultChannelPipeline</code> 是如何实现这些 <code>fire</code> 方法的 3.1 <code>DefaultChannelPipeline</code> 源码</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultChannelPipeline</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelPipeline</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelActive</span><span class="hljs-params">()</span> </span>&#123;
        AbstractChannelHandlerContext.invokeChannelActive(head);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-title">ChannelPipelinefireChannelInactive</span><span class="hljs-params">()</span> </span>&#123;
        AbstractChannelHandlerContext.invokeChannelInactive(head);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireExceptionCaught</span><span class="hljs-params">(Throwable cause)</span> </span>&#123;
        AbstractChannelHandlerContext.invokeExceptionCaught(head, cause);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireUserEventTriggered</span><span class="hljs-params">(Object event)</span> </span>&#123;
        AbstractChannelHandlerContext.invokeUserEventTriggered(head, event);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelRead</span><span class="hljs-params">(Objectmsg)</span> </span>&#123;
        AbstractChannelHandlerContext.invokeChannelRead(head, msg);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelReadComplete</span><span class="hljs-params">()</span> </span>&#123;
        AbstractChannelHandlerContext.invokeChannelReadComplete(head);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelWritabilityChanged</span><span class="hljs-params">()</span> </span>&#123;
        AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
&#125;</code></pre></div>

<p>说明： 可以看出来，这些方法都是 <code>inbound</code> 的方法，也就是入站事件，调用静态方法传入的也是 <code>inbound</code> 的类型 <code>head</code> <code>handler</code>。这些静态方法则会调用 <code>head</code> 的 <code>ChannelInboundInvoker</code> 接口的方法，再然后调用 <code>handler</code> 的真正方法</p>
<p>3.2再看下 <code>piepline</code> 的 <code>outbound</code> 的 <code>fire</code> 方法实现源码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultChannelPipeline</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelPipeline</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.bind(localAddress);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.connect(remoteAddress);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, localAddress);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> tail.disconnect();
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.close();
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">deregister</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.deregister();
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;
        tail.flush();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.bind(localAddress, promise);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, promise);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, localAddress, promise);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.disconnect(promise);
    &#125;
&#125;</code></pre></div>

<p>说明：</p>
<p>1)这些都是出站的实现，但是调用的是 <code>outbound</code> 类型的 <code>tailhandler</code> 来进行处理，因为这些都是 <code>outbound</code> 事件。</p>
<p>2)出站是 <code>tail</code> 开始，入站从 <code>head</code> 开始。因为出站是从内部向外面写，从 <code>tail</code> 开始，能够让前面的 <code>handler</code> 进行处理，防止 <code>handler</code> 被遗漏，比如编码。反之，入站当然是从 <code>head</code> 往内部输入，让后面的 <code>handler</code> 能够处理这些输入的数据。比如解码。因此虽然 <code>head</code> 也实现了 <code>outbound</code> 接口，但不是从 head 开始执行出站任务</p>
<p>4.关于如何调度，用一张图来表示:</p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_13.png" alt="img"></p>
<p>说明： 1)<code>pipeline</code> 首先会调用 <code>Context</code> 的静态方法 <code>fireXXX</code>，并传入 <code>Context</code></p>
<p>2)然后，静态方法调用 <code>Context</code> 的 <code>invoker</code> 方法，而 <code>invoker</code> 方法内部会调用该 <code>Context</code> 所包含的 <code>Handler</code> 的真正的 <code>XXX</code> 方法，调用结束后，如果还需要继续向后传递，就调用 <code>Context</code> 的 <code>fireXXX2</code> 方法，循环往复。</p>
<h4 id="10-5-3-ChannelPipeline-调度-handler-梳理"><a href="#10-5-3-ChannelPipeline-调度-handler-梳理" class="headerlink" title="10.5.3 ChannelPipeline 调度 handler 梳理"></a>10.5.3 ChannelPipeline 调度 handler 梳理</h4><ol>
<li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表，入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始。</li>
<li>而节点中间的传递通过 <code>Abstract ChannelHandlerContext</code> 类内部的 <code>fire</code> 系列方法，找到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对 <code>handler</code> 的调度</li>
</ol>
<h3 id="10-6-Netty-心跳-heartbeat-服务源码剖析"><a href="#10-6-Netty-心跳-heartbeat-服务源码剖析" class="headerlink" title="10.6 Netty 心跳(heartbeat)服务源码剖析"></a>10.6 Netty 心跳(heartbeat)服务源码剖析</h3><h4 id="10-6-1-源码剖析目的"><a href="#10-6-1-源码剖析目的" class="headerlink" title="10.6.1 源码剖析目的"></a>10.6.1 源码剖析目的</h4><p><code>Netty</code> 作为一个网络框架，提供了诸多功能，比如编码解码等，<code>Netty</code> 还提供了非常重要的一个服务 – 心跳机制 <code>heartbeat</code>。通过心跳检查对方是否有效，这是 <code>RPC</code> 框架中是必不可少的功能。下面我们分析一下 <code>Netty</code> 内部心跳服务源码实现。</p>
<h4 id="10-6-2-源码剖析"><a href="#10-6-2-源码剖析" class="headerlink" title="10.6.2 源码剖析"></a>10.6.2 源码剖析</h4><p><code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性，重点分析 <code>IdleStateHandler</code>。</p>
<p>如图</p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_14.png" alt="img"></p>
<p>源码剖析：</p>
<p>5.<code>Netty</code> 提供的心跳介绍</p>
<p>1)<code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性。</p>
<p>2)如图</p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_15.png" alt="img"></p>
<p>3)<code>ReadTimeout</code> 事件和 <code>WriteTimeout</code> 事件都会自动关闭连接，而且，属于异常处理，所以，这里只是介绍以下，我们重点看 <code>IdleStateHandler</code>。</p>
<p>6.<code>IdleStateHandler</code> 分析</p>
<p>6.1 <code>4</code> 个属性</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> observeOutput; <span class="hljs-comment">//是否考虑出站时较慢的情况。默认值是 false</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> readerIdleTimeNanos; <span class="hljs-comment">//读事件空闲时间，0 则禁用事件</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> writerIdleTimeNanos;<span class="hljs-comment">//写事件空闲时间，0 则禁用事件</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> allIdleTimeNanos;<span class="hljs-comment">//读或写空闲时间，0 则禁用事件</span></code></pre></div>

<p>6.2<code>handlerAdded</code> 方法</p>
<p>当该 <code>handler</code> 被添加到 <code>pipeline</code> 中时，则调用 <code>initialize</code> 方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
    <span class="hljs-comment">//Avoid the case where destroy() is called before scheduling timeouts.</span>
    <span class="hljs-comment">//See:https://github.com/netty/netty/issues/143</span>
    <span class="hljs-keyword">switch</span>(state) &#123;
        case1:
        case2:
            <span class="hljs-keyword">return</span>;
    &#125;
    
    state=<span class="hljs-number">1</span>;
    initOutputChanged(ctx);
    
    lastReadTime = lastWriteTime = ticksInNanos();
    
    <span class="hljs-keyword">if</span>(readerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">//这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列中</span>
        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> ReaderIdleTimeoutTask(ctx), readerIdleTimeNanos, TimeUnit.NANOSECONDS);
    &#125;
    
    <span class="hljs-keyword">if</span>(writerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;
        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> WriterIdleTimeoutTask(ctx), writerIdleTimeNanos, TimeUnit.NANOSECONDS);
    &#125;
    
    <span class="hljs-keyword">if</span>(allIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;
        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> AllIdleTimeoutTask(ctx), allIdleTimeNanos, TimeUnit.NANOSECONDS);
    &#125;
&#125;</code></pre></div>

<p>只要给定的参数大于 <code>0</code>，就创建一个定时任务，每个事件都创建。同时，将 <code>state</code> 状态设置为 <code>1</code>，防止重复初始化。调用 <code>initOutputChanged</code> 方法，初始化“监控出站数据属性”。</p>
<p>6.3该类内部的 <code>3</code> 个定时任务类</p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_16.png" alt="img"></p>
<p>1)这 <code>3</code> 个定时任务分别对应读，写，读或者写事件。共有一个父类（<code>AbstractIdleTask</code>）。这个父类提供了一个模板方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractIdleTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelHandlerContext ctx;
    
    AbstractIdleTask(ChannelHandlerContext ctx) &#123;
        <span class="hljs-keyword">this</span>.ctx = ctx;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!ctx.channel().isOpen()) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        run(ctx);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>;
&#125;</code></pre></div>

<p>说明：当通道关闭了，就不执行任务了。反之，执行子类的 <code>run</code> 方法</p>
<p>7.读事件的 <code>run</code> 方法（即 <code>ReaderIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>
<p>1)代码及其说明</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
    <span class="hljs-keyword">long</span> nextDelay = readerIdleTimeNanos;
    <span class="hljs-keyword">if</span>(!reading) &#123;
        nextDelay -= ticksInNanos() - lastReadTime;
    &#125;
    
    <span class="hljs-keyword">if</span>(nextDelay &lt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">//Reader is idle-set a new timeout and notify the callback.</span>
        <span class="hljs-comment">//用于取消任务 promise</span>
        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);
        <span class="hljs-keyword">boolean</span> first = firstReaderIdleEvent;
        firstReaderIdleEvent = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//再次提交任务</span>
            IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.READER_IDLE, first);
            <span class="hljs-comment">//触发用户 handler use</span>
            channelIdle(ctx, event);
        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
            ctx.fireExceptionCaught(t);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">//Read occurred before the timeout - set a new timeout with shorter delay.</span>
        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);
    &#125;
&#125;</code></pre></div>

<p>说明：</p>
<p>1)得到用户设置的超时时间。</p>
<p>2)如果读取操作结束了（执行了 <code>channelReadComplete</code> 方法设置），就用当前时间减去给定时间和最后一次读（执操作的时间行了 <code>channelReadComplete</code> 方法设置），如果小于 <code>0</code>，就触发事件。反之，继续放入队列。间隔时间是新的计算时间。</p>
<p>3)触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个 <code>promise</code> 对象，用于做取消操作。然后，设置 <code>first</code> 属性为<code>false</code>，表示，下一次读取不再是第一次了，这个属性在 <code>channelRead</code> 方法会被改成 <code>true</code>。</p>
<p>4)创建一个 <code>IdleStateEvent</code> 类型的写事件对象，将此对象传递给用户的 <code>UserEventTriggered</code> 方法。完成触发事件的操作。</p>
<p>5)总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发 <code>UserEventTriggered</code> 方法。//前面介绍 <code>IdleStateHandler</code> 说过,可以看一下</p>
<p>8.写事件的 <code>run</code> 方法（即 <code>WriterIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>
<p>1)<code>run</code> 代码和分析</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
    <span class="hljs-keyword">long</span> lastWriteTime = IdleStateHandler.<span class="hljs-keyword">this</span>.lastWriteTime;
    <span class="hljs-keyword">long</span> nextDelay = writerIdleTimeNanos - (ticksInNanos()-lastWriteTime);
    <span class="hljs-keyword">if</span> (nextDelay &lt;=<span class="hljs-number">0</span> ) &#123;
        <span class="hljs-comment">//Writer is idle - set a new timeout and notify the callback.</span>
        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, writerIdleTimeNanos, TimeUnit.NANOSECONDS);
        <span class="hljs-keyword">boolean</span> first = firstWriterIdleEvent;
        firstWriterIdleEvent = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span>(hasOutputChanged(ctx, first)) &#123;
                <span class="hljs-keyword">return</span>;
            &#125;
            
            IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.WRITER_IDLE, first);
            channelIdle(ctx, event);
        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
            ctx.fireExceptionCaught(t);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">//Write occurred before the timeout - set a new timeout with shorter delay.</span>
        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);
    &#125;
&#125;</code></pre></div>

<p>说明：写任务的 <code>run</code> 代码逻辑基本和读任务的逻辑一样，唯一不同的就是有一个针对出站较慢数据的判断 <code>hasOutputChanged</code></p>
<p>9.所有事件的 <code>run</code> 方法（即 <code>AllIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>
<p>代码分析</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
    <span class="hljs-keyword">long</span> nextDelay = allIdleTimeNanos;
    <span class="hljs-keyword">if</span>(!reading) &#123;
        nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);
    &#125;
    
    <span class="hljs-keyword">if</span>(nextDelay &lt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">//Both reader and writer are idle - set a new timeout and</span>
        <span class="hljs-comment">//notify the callback.</span>
        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, allIdleTimeNanos, TimeUnit.NANOSECONDS);
        <span class="hljs-keyword">boolean</span> first = firstAllIdleEvent;
        firstAllIdleEvent = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span>(hasOutputChanged(ctx, first)) &#123;
                <span class="hljs-keyword">return</span>;
            &#125;
            
            IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.ALL_IDLE, first);
            channelIdle(ctx, event);
        &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;
            ctx.fireExceptionCaught(t);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">//Either read or write occurred before the timeout - set a new</span>
        <span class="hljs-comment">//timeout with shorter delay.</span>
        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);
    &#125;
&#125;</code></pre></div>

<p>说明：</p>
<p>1)表示这个监控着所有的事件。当读写事件发生时，都会记录。代码逻辑和写事件的的基本一致：</p>
<p>2)需要大家注意的地方是</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">long</span> nextDelay = allIdleTimeNanos;
<span class="hljs-keyword">if</span>(!reading) &#123;
    <span class="hljs-comment">//当前时间减去最后一次写或读的时间，若大于 0，说明超时了</span>
    nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);
&#125;</code></pre></div>

<p>3)这里的时间计算是取读写事件中的最大值来的。然后像写事件一样，判断是否发生了写的慢的情况。</p>
<p>10.小结 <code>Netty</code> 的心跳机制</p>
<p>1)<code>IdleStateHandler</code> 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 <code>handler</code> 的 <code>userEventTriggered</code> 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接。</p>
<p>2)<code>IdleStateHandler</code> 的实现基于 <code>EventLoop</code> 的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。</p>
<p>3)内部有 <code>3</code> 个定时任务，分别对应读事件，写事件，读写事件。通常用户监听读写事件就足够了。</p>
<p>4)同时，<code>IdleStateHandler</code> 内部也考虑了一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间。<code>Netty</code> 通过构造方法中的 <code>observeOutput</code> 属性来决定是否对出站缓冲区的情况进行判断。</p>
<p>5)如果出站缓慢，<code>Netty</code> 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，可能造成 <code>OOM</code>，<code>OOM</code> 比空闲的问题更大。</p>
<p>6)所以，当你的应用出现了内存溢出，<code>OOM</code> 之类，并且写空闲极少发生（使用了 <code>observeOutput</code> 为 <code>true</code>），那么就需要注意是不是数据出站速度过慢。</p>
<p>7)还有一个注意的地方：就是 <code>ReadTimeoutHandler</code>，它继承自 <code>IdleStateHandler</code>，当触发读空闲事件的时候，就触发 <code>ctx</code>. <code>fireExceptionCaught</code> 方法，并传入一个 <code>ReadTimeoutException</code>，然后关闭 <code>Socket</code>。</p>
<p>8)而 <code>WriteTimeoutHandler</code> 的实现不是基于 <code>IdleStateHandler</code> 的，他的原理是，当调用 <code>write</code> 方法的时候，会创建一个定时任务，任务内容是根据传入的 <code>promise</code> 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 <code>promise</code> 的 <code>isDone</code> 方法返回 <code>false</code>，表明还没有写完，说明超时了，则抛出异常。当 <code>write</code> 方法完成后，会打断定时任务。</p>
<h3 id="10-7-Netty-核心组件-EventLoop-源码剖析"><a href="#10-7-Netty-核心组件-EventLoop-源码剖析" class="headerlink" title="10.7 Netty 核心组件 EventLoop 源码剖析]"></a>10.7 Netty 核心组件 EventLoop 源码剖析]</h3><h4 id="10-7-1-源码剖析目的"><a href="#10-7-1-源码剖析目的" class="headerlink" title="10.7.1 源码剖析目的"></a>10.7.1 源码剖析目的</h4><p><code>Echo</code> 第一行代码就是：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1)</code>; 下面分析其最核心的组件 <code>EventLoop</code>。</p>
<h4 id="10-7-2-源码剖析"><a href="#10-7-2-源码剖析" class="headerlink" title="10.7.2 源码剖析"></a>10.7.2 源码剖析</h4><p>源码剖析</p>
<p>1.<code>EventLoop</code>介绍 1.1首先看看 <code>NioEventLoop</code> 的继承图</p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_17.png" alt="img"></p>
<p>说明重点： 1)<code>ScheduledExecutorService</code> 接口表示是一个定时任务接口，<code>EventLoop</code> 可以接受定时任务。</p>
<p>2)<code>EventLoop</code> 接口：<code>Netty</code> 接口文档说明该接口作用：一旦 <code>Channel</code> 注册了，就处理该 <code>Channel</code> 对应的所有 <code>I/O</code> 操作。</p>
<p>3)<code>SingleThreadEventExecutor</code> 表示这是一个单个线程的线程池</p>
<p>4)<code>EventLoop</code> 是一个单例的线程池，里面含有一个死循环的线程不断的做着 <code>3</code> 件事情：监听端口，处理端口事件，处理队列事件。每个 <code>EventLoop</code> 都可以绑定多个 <code>Channel</code>，而每个 <code>Channel</code> 始终只能由一个 <code>EventLoop</code> 来处理</p>
<ol>
<li><code>NioEventLoop</code> 的使用 - <code>execute</code> 方法</li>
</ol>
<p>2.1 <code>execute</code> 源码剖析</p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_18.png" alt="img"></p>
<p>在 <code>EventLoop</code> 的使用，一般就是 <code>eventloop.execute(task);</code> 看下 <code>execute</code> 方法的实现(在 <code>SingleThreadEventExecutor</code> 类中)</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(task == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);
    &#125;
    <span class="hljs-keyword">boolean</span> inEventLoop = inEventLoop();
    <span class="hljs-keyword">if</span>(inEventLoop) &#123;
        addTask(task);
    &#125; <span class="hljs-keyword">else</span> &#123;
        startThread();
        addTask(task);
        <span class="hljs-keyword">if</span>(isShutdown() &amp;&amp; removeTask(task)) &#123;
            reject();
        &#125;
    &#125;
    
    <span class="hljs-keyword">if</span>(!addTaskWakesUp&amp;&amp;wakesUpForTask(task)) &#123;
        wakeup(inEventLoop);
    &#125;
&#125;</code></pre></div>

<p>说明: 1)首先判断该 <code>EventLoop</code> 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。</p>
<p>2)如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。</p>
<p>3)如果 <code>addTaskWakesUp</code> 是 <code>false</code>，并且任务不是 <code>NonWakeupRunnable</code> 类型的，就尝试唤醒 <code>selector</code>。这个时候，阻塞在 <code>selecor</code>的线程就会立即返回</p>
<p>4)可以下断点来追踪</p>
<p>2.2我们 <code>debugaddTask</code> 和 <code>offerTask</code> 方法源码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(Runnable task)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(task == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);
    &#125;
    
    <span class="hljs-keyword">if</span>(!offerTask(task)) &#123;
        reject(task);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerTask</span><span class="hljs-params">(Runnable task)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(isShutdown()) &#123;
        reject();
    &#125;
    <span class="hljs-keyword">return</span> taskQueue.offer(task);
&#125;</code></pre></div>

<p>3.<code>NioEventLoop</code> 的父类 <code>SingleThreadEventExecutor</code> 的 <code>startThread</code> 方法 3.1当执行 <code>execute</code> 方法的时候，如果当前线程不是 <code>EventLoop</code> 所属线程，则尝试启动线程，也就是 <code>startThread</code> 方法，dubug 代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startThread</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span>(state == ST_NOT_STARTED) &#123;
        <span class="hljs-keyword">if</span>(STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;
            <span class="hljs-keyword">try</span>&#123;
                doStartThread();
            &#125; <span class="hljs-keyword">catch</span>(Throwable cause) &#123;
                STATE_UPDATER.set(<span class="hljs-keyword">this</span>, ST_NOT_STARTED);
                PlatformDependent.throwException(cause);
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>说明:该方法首先判断是否启动过了，保证 <code>EventLoop</code> 只有一个线程，如果没有启动过，则尝试使用 <code>Cas</code> 将 <code>state</code> 状态改为 <code>ST_STARTED</code>，也就是已启动。然后调用 <code>doStartThread</code> 方法。如果失败，则进行回滚</p>
<p>看下 <code>doStartThread</code> 方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStartThread</span><span class="hljs-params">()</span> </span>&#123;
    executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;
            updateLastExecutionTime();
            <span class="hljs-keyword">try</span>&#123;
                SingleThreadEventExecutor.<span class="hljs-keyword">this</span>.run();
                success=<span class="hljs-keyword">true</span>;
            &#125; <span class="hljs-keyword">finally</span> &#123;
                <span class="hljs-keyword">for</span>( ; ; ) &#123;
                    intoldState = state;
                    <span class="hljs-keyword">if</span>(oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.<span class="hljs-keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;
                        <span class="hljs-keyword">break</span>;
                    &#125;
                &#125;
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-keyword">for</span>( ; ; ) &#123;
                        <span class="hljs-keyword">if</span>(confirmShutdown()) &#123;
                            <span class="hljs-keyword">break</span>;
                        &#125;
                    &#125;
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-keyword">try</span> &#123;
                        cleanup();
                    &#125; <span class="hljs-keyword">finally</span> &#123;
                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class="hljs-keyword">this</span>,ST_TERMINATED);
                        threadLock.release();
                        terminationFuture.setSuccess(<span class="hljs-keyword">null</span>);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;);
&#125;</code></pre></div>

<p>说明： 1)首先调用 <code>executor</code> 的 <code>execute</code> 方法，这个 <code>executor</code> 就是在创建 <code>EventLoopGroup</code> 的时候创建的 <code>ThreadPerTaskExecutor</code> 类。该 <code>execute</code> 方法会将 <code>Runnable</code> 包装成 <code>Netty</code> 的 <code>FastThreadLocalThread</code>。</p>
<p>2)任务中，首先判断线程中断状态，然后设置最后一次的执行时间。</p>
<p>3)执行当前 <code>NioEventLoop</code> 的 <code>run</code> 方法，注意：这个方法是个死循环，是整个 <code>EventLoop</code> 的核心</p>
<p>4)在 <code>finally</code> 块中，使用 <code>CAS</code> 不断修改 <code>state</code> 状态，改成 <code>ST_SHUTTING_DOWN</code>。也就是当线程 <code>Loop</code> 结束的时候。关闭线程。最后还要死循环确认是否关闭，否则不会 <code>break</code>。然后，执行 <code>cleanup</code> 操作，更新状态为</p>
<p>5)<code>ST_TERMINATED</code>，并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。并回调 <code>terminationFuture</code> 方法。</p>
<p>6)其实最核心的就是 <code>EventLoop</code> 自身的 <code>run</code> 方法。再继续深入 <code>run</code> 方法</p>
<p>4.<code>EventLoop</code> 中的 <code>Loop</code> 是靠 <code>run</code> 实现的，我们分析下 <code>run</code> 方法(该方法在 <code>NioEventLoop</code>)</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">for</span>( ; ; ) &#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">switch</span>(selectStrategy.calculateStrategy(selectNowSupplier,hasTasks())) &#123;
                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:
                    <span class="hljs-keyword">continue</span>;
                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:
                    select(wakenUp.getAndSet(<span class="hljs-keyword">false</span>));
                    <span class="hljs-keyword">if</span>(wakenUp.get()) &#123;
                        selector.wakeup();
                    &#125;    
                <span class="hljs-keyword">default</span>:
            &#125;
            
            cancelledKeys = <span class="hljs-number">0</span>;
            needsToSelectAgain = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;
            <span class="hljs-keyword">if</span>(ioRatio == <span class="hljs-number">100</span>) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    processSelectedKeys();
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-comment">//Ensure we always run tasks.</span>
                    runAllTasks();
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();
                <span class="hljs-keyword">try</span> &#123;
                    processSelectedKeys();
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-comment">//Ensure we always runtasks.</span>
                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;
                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;
            handleLoopException(t);
        &#125;
        <span class="hljs-comment">//Always handle shutdown even if the loop processing threw an exception.</span>
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span>(isShuttingDown()) &#123;
                closeAll();
                <span class="hljs-keyword">if</span>(confirmShutdown()) &#123;
                    <span class="hljs-keyword">return</span>;
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
            handleLoopException(t);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>说明: 1)从上面的步骤可以看出，整个 <code>run</code> 方法做了 <code>3</code> 件事情： <code>select</code> 获取感兴趣的事件。 <code>processSelectedKeys</code> 处理事件。 <code>runAllTasks</code> 执行队列中的任务。</p>
<p>2)上面的三个方法，我们就追一下 <code>select</code> 方法(体现非阻塞)核心 <code>select</code> 方法解析</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> oldWakenUp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    Selector selector = <span class="hljs-keyword">this</span>.selector;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">long</span> currentTimeNanos = System.nanoTime();
        <span class="hljs-keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);
        <span class="hljs-keyword">for</span>( ; ; ) &#123;
            <span class="hljs-keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="hljs-number">500000L</span>)/<span class="hljs-number">1000000L</span>;
            <span class="hljs-keyword">if</span>(timeoutMillis &lt;= <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">if</span>(selectCnt == <span class="hljs-number">0</span>) &#123;
                    selector.selectNow();
                    selectCnt=<span class="hljs-number">1</span>;
                &#125;
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-comment">//If a task was submitted when wakenUp value was true, the task didn&#x27;t get a chance to call</span>
            <span class="hljs-comment">//Selector#wakeup. So we need to check task queue again before executing select operation.</span>
            <span class="hljs-comment">//If wedon&#x27;t, the task might be pended until select operation was timedout.</span>
            <span class="hljs-comment">//It might be pended until idle timeout if IdleStateHandler existed inpipeline.</span>
            <span class="hljs-keyword">if</span>(hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;
                selector.selectNow();
                selectCnt = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
            
            <span class="hljs-keyword">int</span> selectedKeys = selector.select(timeoutMillis);<span class="hljs-comment">//否则阻塞给定时间，默认一秒</span>
            selectCnt++;
            <span class="hljs-comment">//如果 1 秒后返回，有返回值||select被用户唤醒||任务队列有任务||有定时任务即将被执行；则跳出循环</span>
            <span class="hljs-keyword">if</span>(selectedKeys != <span class="hljs-number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;
                <span class="hljs-comment">//-Selected something,</span>
                <span class="hljs-comment">//-waken up by user,or</span>
                <span class="hljs-comment">//-the task queue has apending task.</span>
                <span class="hljs-comment">//-a scheduled task is ready for processing</span>
                <span class="hljs-keyword">break</span>;
            &#125;
            
            <span class="hljs-keyword">if</span>(Thread.interrupted()) &#123;
                <span class="hljs-comment">//Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span>
                <span class="hljs-comment">//As this is most likely a bug in the handler of the user or it&#x27;s client library we will</span>
                <span class="hljs-comment">//also log it.</span>
                <span class="hljs-comment">//</span>
                <span class="hljs-comment">//See https://github.com/netty/netty/issues/2426</span>
                <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;
                    logger.debug(<span class="hljs-string">&quot;Selector.select() returned prematurely because &quot;</span> + <span class="hljs-string">&quot; Thread.currentThread().interrupt() was called. Use &quot;</span> + <span class="hljs-string">&quot; NioEventLoop.shutdownGracefully() to shutdowntheNioEventLoop.&quot;</span>);
                &#125;
                selectCnt = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-keyword">long</span> time = System.nanoTime();
            <span class="hljs-keyword">if</span>(time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;
                <span class="hljs-comment">//timeoutMillis elapsed without any thing selected.</span>
                selectCnt =<span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;
                <span class="hljs-comment">//The selector returned prematurely many times in a row.</span>
                <span class="hljs-comment">//Rebuild the selector to work around the problem.</span>
                logger.warn(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>, selectCnt, selector);
                rebuildSelector();
                selector = <span class="hljs-keyword">this</span>.selector;
                <span class="hljs-comment">//Select again to populate selectedKeys.</span>
                selector.selectNow();
                selectCnt = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
            
            currentTimeNanos = time;
        &#125;
        
        <span class="hljs-keyword">if</span>(selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;
            <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;
                logger.debug(<span class="hljs-string">&quot;Selector.select()returned prematurely &#123;&#125; times in a row for Selector&#123;&#125;.&quot;</span>, selectCnt - <span class="hljs-number">1</span>, selector);
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;
        <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;
            logger.debug(CancelledKeyException.class.getSimpleName() + <span class="hljs-string">&quot;raisedbyaSelector &#123;&#125; - JDKbug?&quot;</span>, selector, e);
        &#125;
        <span class="hljs-comment">//Harmless exception - log anyway</span>
    &#125;
&#125;</code></pre></div>

<p>说明：调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selector</code>，防止 <code>selector</code> 阻塞时间过长</p>
<p>5.<code>EventLoop</code> 作为 <code>Netty</code> 的核心的运行机制小结</p>
<p>1)每次执行 <code>execute</code> 方法都是向队列中添加任务。当第一次添加时就启动线程，执行 <code>run</code> 方法，而 <code>run</code> 方法是整个 <code>EventLoop</code> 的核心，就像 <code>EventLoop</code> 的名字一样，<code>LoopLoop</code>，不停的 <code>Loop</code>，<code>Loop</code> 做什么呢？做 <code>3</code> 件事情。</p>
<p>调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selecor</code>，防止 <code>selector</code> 阻塞时间过长。</p>
<p>当 <code>selector</code> 返回的时候，回调用 <code>processSelectedKeys</code> 方法对 <code>selectKey</code> 进行处理。</p>
<p>当 <code>processSelectedKeys</code> 方法执行结束后，则按照 <code>ioRatio</code> 的比例执行 <code>runAllTasks</code> 方法，默认是 <code>IO</code> 任务时间和非 <code>IO</code> 任务时间是相同的，你也可以根据你的应用特点进行调优。比如非 <code>IO</code> 任务比较多，那么你就将</p>
<p><code>ioRatio</code> 调小一点，这样非 <code>IO</code> 任务就能执行的长一点。防止队列积攒过多的任务。</p>
<h3 id="10-8-handler-中加入线程池和-Context-中添加线程池的源码剖析"><a href="#10-8-handler-中加入线程池和-Context-中添加线程池的源码剖析" class="headerlink" title="10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析"></a>10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析</h3><h4 id="10-8-1-源码剖析目的"><a href="#10-8-1-源码剖析目的" class="headerlink" title="10.8.1 源码剖析目的"></a>10.8.1 源码剖析目的</h4><ol>
<li>在 <code>Netty</code> 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 <code>Netty</code> 对 <code>Socket</code> 的处理速度。</li>
<li>而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有 <code>2</code> 种方式，而且这 <code>2</code> 种方式实现的区别也蛮大的。</li>
<li>处理耗时业务的第一种方式 – <code>handler</code> 中加入线程池</li>
<li>处理耗时业务的第二种方式 – <code>Context</code> 中添加线程池</li>
<li>我们就来分析下两种方式</li>
</ol>
<h4 id="10-8-2-源码剖析"><a href="#10-8-2-源码剖析" class="headerlink" title="10.8.2 源码剖析"></a>10.8.2 源码剖析</h4><p>说明 演示两种方式的实现，以及从源码来追踪两种方式执行流程</p>
<ol>
<li>处理耗时业务的第一种方式 – handler种加入线程池</li>
<li>1对前面的 <code>Netty</code> <code>demo</code>源码进行修改，在 <code>EchoServerHandler</code> 的 <code>channelRead</code> 方法进行异步</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventExecutorGroup group = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<span class="hljs-number">16</span>);

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException, InterruptedException </span>&#123;
        <span class="hljs-keyword">final</span> Object msgCop = msg;
        <span class="hljs-keyword">final</span> ChannelHandlerContext cxtCop = ctx;
        group.submit(<span class="hljs-keyword">new</span> Callable&lt;Object&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                ByteBuf buf = (ByteBuf)msgCop;
                <span class="hljs-keyword">byte</span>[] req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buf.readableBytes()];
                buf.readBytes(req);
                String body = <span class="hljs-keyword">new</span> String(req, <span class="hljs-string">&quot;UTF-8&quot;</span>);
                Thread.sleep(<span class="hljs-number">10</span> * <span class="hljs-number">1000</span>);
                System.err.println(body + <span class="hljs-string">&quot; &quot;</span> + Thread.currentThread().getName());
                String reqString = <span class="hljs-string">&quot;Helloiamserver~~~&quot;</span>;
                ByteBuf resp = Unpooled.copiedBuffer(reqString.getBytes());
                cxtCop.writeAndFlush(resp);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
            &#125;
        &#125;);
        System.out.println(<span class="hljs-string">&quot;goon..&quot;</span>);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
        ctx.flush();
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;
        <span class="hljs-comment">// Close the connection when an exception is raised.</span>
        cause.printStackTrace();
        ctx.close();
    &#125;
&#125;</code></pre></div>

<p>说明： 1)在 <code>channelRead</code> 方法，模拟了一个耗时 <code>10</code> 秒的操作，这里，我们将这个任务提交到了一个自定义的业务线程池中，这样，就不会阻塞 <code>Netty</code> 的 <code>IO</code> 线程。</p>
<p>11.2这样处理之后，整个程序的逻辑如图</p>
<p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_19.png" alt="img"></p>
<p>说明：</p>
<p>1)解释一下上图，当 <code>IO</code> 线程轮询到一个 <code>socket</code> 事件，然后，<code>IO</code> 线程开始处理，当走到耗时 <code>handler</code> 的时候，将耗时任务交给业务线程池。</p>
<p>2)当耗时任务执行完毕再执行 <code>pipeline write</code> 方法的时候，(代码中使用的是 <code>context</code> 的 <code>write</code> 方法，上图画的是执行 <code>pipeline</code> 方法，是一个意思)会将任务这个任务交给 <code>IO</code> 线程</p>
<p>11.3 <code>write</code> 方法的源码(在 <code>AbstractChannelHandlerContext</code> 类)</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Object msg, <span class="hljs-keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;
    AbstractChannelHandlerContext next = findContextOutbound();
    <span class="hljs-keyword">final</span> Object m = pipeline.touch(msg, next);
    EventExecutor executor = next.executor();
    <span class="hljs-keyword">if</span>(executor.inEventLoop()) &#123;
        <span class="hljs-keyword">if</span>(flush) &#123;
            next.invokeWriteAndFlush(m, promise);
        &#125; <span class="hljs-keyword">else</span> &#123;
            next.invokeWrite(m, promise);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        AbstractWriteTask task;
        <span class="hljs-keyword">if</span>(flush) &#123;
            task = WriteAndFlushTask.newInstance(next, m, promise);
        &#125; <span class="hljs-keyword">else</span> &#123;
            task = WriteTask.newInstance(next, m, promise);
        &#125;
        safeExecute(executor, task, promise, m);
    &#125;
&#125;</code></pre></div>

<p>说明:</p>
<p>1)当判定下个 <code>outbound</code> 的 <code>executor</code> 线程不是当前线程的时候，会将当前的工作封装成 <code>task</code>，然后放入 <code>mpsc</code> 队列中，等待 <code>IO</code> 任务执行完毕后执行队列中的任务。</p>
<p>2)这里可以 Debug 来验证(提醒：Debug 时，服务器端 Debug, 客户端 <code>Run</code> 的方式)，当我们使用了 <code>group.submit(new Callable&lt;Object&gt; ()&#123;&#125;</code> 在 <code>handler</code> 中加入线程池，就会进入到 <code>safeExecute(executor, task, promise, m);</code> 如果去掉这段代码，而使用普通方式来执行耗时的业务，那么就不会进入到 <code>safeExecute(executor, task, promise, m);</code>（说明：普通方式执行耗时代码，看我准备好的案例即可）</p>
<p>12.处理耗时业务的第二种方式 -<code>Context</code> 中添加线程池 1.1在添加 <code>pipeline</code> 中的 <code>handler</code> 时候，添加一个线程池</p>
<p>//属性</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventExecutorGroup group = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<span class="hljs-number">16</span>);
ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();
                b.group(bossGroup, workerGroup)
                 .channel(NioServerSocketChannel.class)
                 .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)
                 .handler(newLoggingHandler(LogLevel.INFO))
                 .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
                     <span class="hljs-meta">@Override</span>
                     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                         ChannelPipeline p = ch.pipeline();
                         <span class="hljs-keyword">if</span>(sslCtx != <span class="hljs-keyword">null</span>) &#123;
                             p.addLast(sslCtx.newHandler(ch.alloc()));
                         &#125;
                         <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>
                         <span class="hljs-comment">//p.addLast(new EchoServerHandler());</span>
                         p.addLast(group, <span class="hljs-keyword">new</span> EchoServerHandler());
                    &#125;
                &#125;);</code></pre></div>

<p>说明：</p>
<p>1)<code>handler</code> 中的代码就使用普通的方式来处理耗时业务。</p>
<p>2)当我们在调用 <code>addLast</code> 方法添加线程池后，<code>handler</code> 将优先使用这个线程池，如果不添加，将使用 <code>IO</code> 线程</p>
<p>3)当走到 <code>AbstractChannelHandlerContext</code> 的 <code>invokeChannelRead</code> 方法的时候，<code>executor.inEventLoop()</code> 是不会通过的，因为当前线程是 <code>IO</code> 线程 <code>Context</code>（也就是 <code>Handler</code>）的 <code>executor</code> 是业务线程，所以会异步执行，debug 下源码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;
    <span class="hljs-keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);
    EventExecutor executor = next.executor();
    <span class="hljs-keyword">if</span>(executor.inEventLoop()) &#123;
        next.invokeChannelRead(m);
    &#125; <span class="hljs-keyword">else</span> &#123;
        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-comment">//执行run</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                next.invokeChannelRead(m);
            &#125;
        &#125;);
    &#125;
&#125;</code></pre></div>

<p>4)验证时，我们如果去掉 <code>p.addLast(group,newEchoServerHandler());</code> 改成 <code>p.addLastnewEchoServerHandler());</code> 你会发现代码不会进行异步执行。</p>
<p>5)后面的整个流程就变成和第一个方式一样了</p>
<p>13.两种方式的比较</p>
<p>1)第一种方式在 <code>handler</code> 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 <code>mpscTask</code> 中。如果 <code>IO</code> 时间很短，<code>task</code> 很多，可能一个循环下来，都没时间执行整个 <code>task</code>，导致响应时间达不到指标。</p>
<p>2)第二种方式是 <code>Netty</code> 标准方式(即加入到队列)，但是，这么做会将整个 <code>handler</code> 都交给业务线程池。不论耗时不耗时，都加入到队列里，不够灵活。</p>
<p>3)各有优劣，从灵活性考虑，第一种较好。</p>
<h2 id="11-用-Netty-自己实现-Dubbo-RPC"><a href="#11-用-Netty-自己实现-Dubbo-RPC" class="headerlink" title="11 用 Netty 自己实现 Dubbo RPC"></a>11 用 Netty 自己实现 Dubbo RPC</h2><h3 id="11-1-RPC-基本介绍"><a href="#11-1-RPC-基本介绍" class="headerlink" title="11.1 RPC 基本介绍"></a>11.1 RPC 基本介绍</h3><ol>
<li><code>RPC（Remote Procedure Call）</code>—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li>
<li>两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图)</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_01.png" alt="img"></p>
<ol>
<li>常见的 <code>RPC</code> 框架有：比较知名的如阿里的 <code>Dubbo</code>、<code>Google</code> 的 <code>gRPC</code>、<code>Go</code> 语言的 <code>rpcx</code>、<code>Apache</code> 的 <code>thrift</code>，<code>Spring</code> 旗下的 <code>SpringCloud</code>。</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_02.png" alt="img"></p>
<h3 id="11-2-RPC-调用流程图"><a href="#11-2-RPC-调用流程图" class="headerlink" title="11.2 RPC 调用流程图"></a>11.2 RPC 调用流程图<img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_03.png" alt="img"></h3><h3 id="11-3-PRC-调用流程说明"><a href="#11-3-PRC-调用流程说明" class="headerlink" title="11.3 PRC 调用流程说明"></a>11.3 PRC 调用流程说明</h3><ol>
<li>服务消费方（<code>client</code>）以本地调用方式调用服务</li>
<li><code>client stub</code> 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体</li>
<li><code>client stub</code> 将消息进行编码并发送到服务端</li>
<li><code>server stub</code> 收到消息后进行解码</li>
<li><code>server stub</code> 根据解码结果调用本地的服务</li>
<li>本地服务执行并将结果返回给 <code>server stub</code></li>
<li><code>server stub</code> 将返回导入结果进行编码并发送至消费方</li>
<li><code>client stub</code> 接收到消息并进行解码</li>
<li>服务消费方（<code>client</code>）得到结果</li>
</ol>
<p>小结：<code>RPC</code> 的目标就是将 <code>2 - 8</code> 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用</p>
<h3 id="11-4-自己实现-Dubbo-RPC（基于-Netty）"><a href="#11-4-自己实现-Dubbo-RPC（基于-Netty）" class="headerlink" title="11.4 自己实现 Dubbo RPC（基于 Netty）"></a>11.4 自己实现 Dubbo RPC（基于 Netty）</h3><h4 id="11-4-1-需求说明"><a href="#11-4-1-需求说明" class="headerlink" title="11.4.1 需求说明"></a>11.4.1 需求说明</h4><ol>
<li><code>Dubbo</code> 底层使用了 <code>Netty</code> 作为网络通讯框架，要求用 <code>Netty</code> 实现一个简单的 <code>RPC</code> 框架</li>
<li>模仿 <code>Dubbo</code>，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 <code>Netty 4.1.20</code></li>
</ol>
<h4 id="11-4-2-设计说明"><a href="#11-4-2-设计说明" class="headerlink" title="11.4.2 设计说明"></a>11.4.2 设计说明</h4><ol>
<li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。</li>
<li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。</li>
<li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 <code>Netty</code> 请求提供者返回数据</li>
<li>开发的分析图</li>
</ol>
<p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_04.png" alt="img"></p>
<h4 id="11-4-3-代码实现"><a href="#11-4-3-代码实现" class="headerlink" title="11.4.3 代码实现"></a>11.4.3 代码实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.publicinterface;

<span class="hljs-comment">//这个是接口，是服务提供方和 服务消费方都需要</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;

    <span class="hljs-function">String <span class="hljs-title">hello</span><span class="hljs-params">(String mes)</span></span>;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.provider;

<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-comment">//当有消费方调用该方法时， 就返回一个结果</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String mes)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;收到客户端消息=&quot;</span> + mes);
        <span class="hljs-comment">//根据mes 返回不同的结果</span>
        <span class="hljs-keyword">if</span> (mes != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好客户端, 我已经收到你的消息 [&quot;</span> + mes + <span class="hljs-string">&quot;] 第&quot;</span> + (++count) + <span class="hljs-string">&quot; 次&quot;</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好客户端, 我已经收到你的消息 &quot;</span>;
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.provider;

<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyServer;

<span class="hljs-comment">//ServerBootstrap 会启动一个服务提供者，就是 NettyServer</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerBootstrap</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">//代码代填..</span>
        NettyServer.startServer(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>);
    &#125;
&#125;


<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;


<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer</span><span class="hljs-params">(String hostName, <span class="hljs-keyword">int</span> port)</span> </span>&#123;
        startServer0(hostName, port);
    &#125;

    <span class="hljs-comment">//编写一个方法，完成对NettyServer的初始化和启动</span>

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer0</span><span class="hljs-params">(String hostname, <span class="hljs-keyword">int</span> port)</span> </span>&#123;

        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();

        <span class="hljs-keyword">try</span> &#123;

            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();

            serverBootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
                                      <span class="hljs-meta">@Override</span>
                                      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                                          ChannelPipeline pipeline = ch.pipeline();
                                          pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());
                                          pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());
                                          pipeline.addLast(<span class="hljs-keyword">new</span> NettyServerHandler()); <span class="hljs-comment">//业务处理器</span>

                                      &#125;
                                  &#125;

                    );

            ChannelFuture channelFuture = serverBootstrap.bind(hostname, port).sync();
            System.out.println(<span class="hljs-string">&quot;服务提供方开始提供服务~~&quot;</span>);
            channelFuture.channel().closeFuture().sync();

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;

<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.customer.ClientBootstrap;
<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.provider.HelloServiceImpl;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;

<span class="hljs-comment">//服务器这边handler比较简单</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//获取客户端发送的消息，并调用服务</span>
        System.out.println(<span class="hljs-string">&quot;msg=&quot;</span> + msg);
        <span class="hljs-comment">//客户端在调用服务器的api 时，我们需要定义一个协议</span>
        <span class="hljs-comment">//比如我们要求 每次发消息是都必须以某个字符串开头 &quot;HelloService#hello#你好&quot;</span>
        <span class="hljs-keyword">if</span> (msg.toString().startsWith(ClientBootstrap.providerName)) &#123;

            String result = <span class="hljs-keyword">new</span> HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(<span class="hljs-string">&quot;#&quot;</span>) + <span class="hljs-number">1</span>));
            ctx.writeAndFlush(result);
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ctx.close();
    &#125;
&#125;


<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;

<span class="hljs-keyword">import</span> java.util.concurrent.Callable;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;

    <span class="hljs-keyword">private</span> ChannelHandlerContext context;<span class="hljs-comment">//上下文</span>
    <span class="hljs-keyword">private</span> String result; <span class="hljs-comment">//返回的结果</span>
    <span class="hljs-keyword">private</span> String para; <span class="hljs-comment">//客户端调用方法时，传入的参数</span>
    
    <span class="hljs-comment">//与服务器的连接创建后，就会被调用, 这个方法是第一个被调用(1)</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot; channelActive 被调用  &quot;</span>);
        context = ctx; <span class="hljs-comment">//因为我们在其它方法会使用到 ctx</span>
    &#125;

    <span class="hljs-comment">//收到服务器的数据后，调用方法 (4)</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot; channelRead 被调用  &quot;</span>);
        result = msg.toString();
        notify(); <span class="hljs-comment">//唤醒等待的线程</span>
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ctx.close();
    &#125;

    <span class="hljs-comment">//被代理对象调用, 发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果 (3)-》5</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot; call1 被调用  &quot;</span>);
        context.writeAndFlush(para);
        <span class="hljs-comment">//进行wait</span>
        wait(); <span class="hljs-comment">//等待channelRead 方法获取到服务器的结果后，唤醒</span>
        System.out.println(<span class="hljs-string">&quot; call2 被调用  &quot;</span>);
        <span class="hljs-keyword">return</span> result; <span class="hljs-comment">//服务方返回的结果</span>

    &#125;

    <span class="hljs-comment">//(2)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPara</span><span class="hljs-params">(String para)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot; setPara  &quot;</span>);
        <span class="hljs-keyword">this</span>.para = para;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;


<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;

<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;
<span class="hljs-keyword">import</span> java.util.concurrent.Executor;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;

    <span class="hljs-comment">//创建线程池</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> NettyClientHandler client;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-comment">//编写方法使用代理模式，获取一个代理对象</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; serivceClass, <span class="hljs-keyword">final</span> String providerName)</span> </span>&#123;

        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
                <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;serivceClass&#125;, (proxy, method, args) -&gt; &#123;

                    System.out.println(<span class="hljs-string">&quot;(proxy, method, args) 进入....&quot;</span> + (++count) + <span class="hljs-string">&quot; 次&quot;</span>);
                    <span class="hljs-comment">//&#123;&#125;  部分的代码，客户端每调用一次 hello, 就会进入到该代码</span>
                    <span class="hljs-keyword">if</span> (client == <span class="hljs-keyword">null</span>) &#123;
                        initClient();
                    &#125;

                    <span class="hljs-comment">//设置要发给服务器端的信息</span>
                    <span class="hljs-comment">//providerName 协议头 args[0] 就是客户端调用api hello(???), 参数</span>
                    client.setPara(providerName + args[<span class="hljs-number">0</span>]);

                    <span class="hljs-comment">//</span>
                    <span class="hljs-keyword">return</span> executor.submit(client).get();

                &#125;);
    &#125;

    <span class="hljs-comment">//初始化客户端</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initClient</span><span class="hljs-params">()</span> </span>&#123;
        client = <span class="hljs-keyword">new</span> NettyClientHandler();
        <span class="hljs-comment">//创建EventLoopGroup</span>
        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();
        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();
        bootstrap.group(group)
                .channel(NioSocketChannel.class)
                .option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)
                .handler(
                        <span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
                            <span class="hljs-meta">@Override</span>
                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                                ChannelPipeline pipeline = ch.pipeline();
                                pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());
                                pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());
                                pipeline.addLast(client);
                            &#125;
                        &#125;
                );

        <span class="hljs-keyword">try</span> &#123;
            bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>).sync();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.customer;

<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyClient;
<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientBootstrap</span> </span>&#123;
    
    <span class="hljs-comment">//这里定义协议头</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String providerName = <span class="hljs-string">&quot;HelloService#hello#&quot;</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//创建一个消费者</span>
        NettyClient customer = <span class="hljs-keyword">new</span> NettyClient();

        <span class="hljs-comment">//创建代理对象</span>
        HelloService service = (HelloService) customer.getBean(HelloService.class, providerName);

        <span class="hljs-keyword">for</span> (; ; ) &#123;
            Thread.sleep(<span class="hljs-number">2</span> * <span class="hljs-number">1000</span>);
            <span class="hljs-comment">//通过代理对象调用服务提供者的方法(服务)</span>
            String res = service.hello(<span class="hljs-string">&quot;你好 dubbo~&quot;</span>);
            System.out.println(<span class="hljs-string">&quot;调用的结果 res= &quot;</span> + res);
        &#125;
    &#125;
&#125;</code></pre></div>

]]></content>
      <categories>
        <category>Java</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud 学习</title>
    <url>/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="SpringCloud-学习"><a href="#SpringCloud-学习" class="headerlink" title="SpringCloud 学习"></a>SpringCloud 学习</h1><h2 id="1-什么是-Spring-Cloud"><a href="#1-什么是-Spring-Cloud" class="headerlink" title="1  什么是 Spring Cloud"></a>1  什么是 Spring Cloud</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>Spring Cloud 为开发人员提供了工具，可以快速构建分布式系统中的一些常见模式（例如配置管理、服务发现、断路器、智能路由、微型代理、控制总线、一次性令牌、全球锁定、领导力选择、分布式会话、集群状态）。分布式系统的协调会导致锅炉板模式，使用Spring Cloud开发人员可以快速支持实现这些模式的服务和应用程序。它们将在任何分布式环境中运作良好，包括开发人员自己的笔记本电脑、裸机数据中心以及云铸造厂等管理平台。</p>
<h3 id="1-2-特征"><a href="#1-2-特征" class="headerlink" title="1.2 特征"></a>1.2 特征</h3><p>Spring Cloud 专注于为典型使用案例提供良好的开箱即用体验，并提供覆盖他人的扩展机制。</p>
<ul>
<li>分布式/版本配置</li>
<li>服务注册和发现</li>
<li>路由</li>
<li>服务到服务电话</li>
<li>负载平衡</li>
<li>断路 器</li>
<li>全球锁</li>
<li>领导人选举和集群状态</li>
<li>分布式消息</li>
</ul>
<h3 id="1-3-Spring-Cloud-和-Spring-Boot-版本对应"><a href="#1-3-Spring-Cloud-和-Spring-Boot-版本对应" class="headerlink" title="1.3  Spring Cloud 和 Spring Boot 版本对应"></a>1.3  Spring Cloud 和 Spring Boot 版本对应</h3><table>
<thead>
<tr>
<th>spring-cloud依赖</th>
<th>spring-boot依赖</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Finchley.M2</strong></td>
<td><strong>&gt;=2.0.0.M3 and &lt;2.0.0.M5</strong></td>
</tr>
<tr>
<td><strong>Finchley.M3</strong></td>
<td><strong>&gt;=2.0.0.M5 and &lt;=2.0.0.M5</strong></td>
</tr>
<tr>
<td><strong>Finchley.M4</strong></td>
<td><strong>&gt;=2.0.0.M6 and &lt;=2.0.0.M6</strong></td>
</tr>
<tr>
<td><strong>Finchley.M5</strong></td>
<td><strong>&gt;=2.0.0.M7 and &lt;=2.0.0.M7</strong></td>
</tr>
<tr>
<td><strong>Finchley.M6</strong></td>
<td><strong>&gt;=2.0.0.RC1 and &lt;=2.0.0.RC1</strong></td>
</tr>
<tr>
<td><strong>Finchley.M7</strong></td>
<td><strong>&gt;=2.0.0.RC2 and &lt;=2.0.0.RC2</strong></td>
</tr>
<tr>
<td><strong>Finchley.M9</strong></td>
<td><strong>&gt;=2.0.0.RELEASE and &lt;=2.0.0.RELEASE</strong></td>
</tr>
<tr>
<td><strong>Finchley.RC1</strong></td>
<td><strong>&gt;=2.0.1.RELEASE and &lt;2.0.2.RELEASE</strong></td>
</tr>
<tr>
<td><strong>Finchley.RC2</strong></td>
<td><strong>&gt;=2.0.2.RELEASE and &lt;2.0.3.RELEASE</strong></td>
</tr>
<tr>
<td><strong>Finchley.BUILD-SNAPSHOT</strong></td>
<td><strong>&gt;=2.0.999.BUILD-SNAPSHOT and &lt;2.1.0.M3</strong></td>
</tr>
<tr>
<td><strong>Greenwich.M1</strong></td>
<td><strong>&gt;=2.1.0.M3 and &lt;2.1.0.RELEASE</strong></td>
</tr>
<tr>
<td><strong>Greenwich.SR6</strong></td>
<td><strong>&gt;=2.1.0.RELEASE and &lt;2.1.999.BUILD-SNAPSHOT</strong></td>
</tr>
<tr>
<td><strong>Greenwich.BUILD-SNAPSHOT</strong></td>
<td><strong>&gt;=2.1.999.BUILD-SNAPSHOT and &lt;2.2.0.M4</strong></td>
</tr>
<tr>
<td><strong>Hoxton.SR9</strong></td>
<td><strong>&gt;=2.2.0.M4 and &lt;2.3.7.BUILD-SNAPSHOT</strong></td>
</tr>
<tr>
<td><strong>Hoxton.BUILD-SNAPSHOT</strong></td>
<td><strong>&gt;=2.3.7.BUILD-SNAPSHOT and &lt;2.4.0.M1</strong></td>
</tr>
<tr>
<td><strong>2020.0.0-M3</strong></td>
<td><strong>&gt;=2.4.0.M1 and &lt;=2.4.0.M1</strong></td>
</tr>
<tr>
<td><strong>2020.0.0-M4</strong></td>
<td><strong>&gt;=2.4.0.M2 and &lt;=2.4.0-M3</strong></td>
</tr>
<tr>
<td><strong>2020.0.0-M5</strong></td>
<td><strong>&gt;=2.4.0.M4 and &lt;2.4.1-SNAPSHOT</strong></td>
</tr>
<tr>
<td><strong>2020.0.0-SNAPSHOT</strong></td>
<td><strong>&gt;=2.4.1-SNAPSHOT</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>spring-cloud-alibaba</strong>依赖</th>
<th>spring-boot依赖</th>
</tr>
</thead>
<tbody><tr>
<td><strong>2.2.1.RELEASE</strong></td>
<td><strong>&gt;=2.2.0.RELEASE and &lt;2.3.0.M1</strong></td>
</tr>
</tbody></table>
<p>官网推荐的搭配    (<a href="https://spring.io/projects/spring-cloud/#learn">Spring Cloud</a>)</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210414213635785.png" alt="image-20210414213635785"></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210414213625457.png" alt="image-20210414213625457"></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210414213609319.png" alt="image-20210414213609319"></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210414213553429.png" alt="image-20210414213553429"></p>
<h3 id="1-4-pom文件"><a href="#1-4-pom文件" class="headerlink" title="1.4 pom文件"></a>1.4 pom文件</h3><ul>
<li>父模块的依赖 pom.xml</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>SpringCloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>cloud_provider_payment_8081<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span>
	
	<span class="hljs-comment">&lt;!--版本管理--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.13.1<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">lombok.version</span>&gt;</span>1.18.18<span class="hljs-tag">&lt;/<span class="hljs-name">lombok.version</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>8.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">druid.version</span>&gt;</span>1.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">druid.version</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">mybatis.spring.boot.version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.spring.boot.version</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
	
	<span class="hljs-comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module不用谢groupId和version--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-comment">&lt;!--spring boot 2.3.8.RELEASE--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-comment">&lt;!--spring cloud Hoxton.SR10--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Hoxton.SR10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
			
			<span class="hljs-comment">&lt;!--mybatis--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatis.spring.boot.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-comment">&lt;!--junit--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-comment">&lt;!--log4j--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
			
			<span class="hljs-comment">&lt;!--spring cloud 阿里巴巴--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-comment">&lt;!--mysql--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-comment">&lt;!-- druid--&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
					<span class="hljs-tag">&lt;<span class="hljs-name">fork</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">fork</span>&gt;</span>
					<span class="hljs-tag">&lt;<span class="hljs-name">addResources</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addResources</span>&gt;</span>
				<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<ul>
<li>子模块的依赖</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>SpringCloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud_provider_payment_8081<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--包含了sleuth+zipkin--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-comment">&lt;!--eureka-client--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		 引入自己定义的api通用包，可以使用Payment支付Entity 
		
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-api-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
					<span class="hljs-tag">&lt;<span class="hljs-name">fork</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">fork</span>&gt;</span>
					<span class="hljs-tag">&lt;<span class="hljs-name">addResources</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addResources</span>&gt;</span>
				<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<h3 id="1-5-端口占用"><a href="#1-5-端口占用" class="headerlink" title="1.5  端口占用"></a>1.5  端口占用</h3><blockquote>
<p>  Web server failed to start. Port 8001 was already in use.</p>
</blockquote>
<ul>
<li><p>netstat -ano</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210426223701074.png" alt="image-20210426223701074"></p>
</li>
<li><p>taskkill /F /pid 21600</p>
</li>
</ul>
<h3 id="1-6-依赖"><a href="#1-6-依赖" class="headerlink" title="1.6 依赖"></a>1.6 依赖</h3><p>子模块的pom.xml 一定要根据自己的需求， 删减多余的依赖， 避免 yml 配置不过， 无法启动项目</p>
<h2 id="2-Eureka-服务治理"><a href="#2-Eureka-服务治理" class="headerlink" title="2 Eureka 服务治理"></a>2 Eureka 服务治理</h2><h3 id="2-1-什么是服务治理"><a href="#2-1-什么是服务治理" class="headerlink" title="2.1 什么是服务治理"></a>2.1 什么是服务治理</h3><ul>
<li><p>Spring Cloud 封装了 Netflix 公司开发的Eureka模块来实现服务治理</p>
</li>
<li><p>在传统的RPC远程调用框架中，管理每个服务与服务之间的依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务与服务之间的依赖关系，可以实现服务调用，负载均衡，容错等，实现服务发现与注册。</p>
</li>
</ul>
<h3 id="2-2-pom"><a href="#2-2-pom" class="headerlink" title="2.2 pom"></a>2.2 pom</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>SpringCloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
   
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud_eureka_server_7001<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
   
   <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
   
   <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
      <span class="hljs-comment">&lt;!--eureka server--&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
      
      <span class="hljs-comment">&lt;!--引入自己定义的api通用包，可以使用payment支付Entity--&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud_api_commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
      
      <span class="hljs-comment">&lt;!--boot web actuator--&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
      
      <span class="hljs-comment">&lt;!--一般通用配置--&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
      
   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<h3 id="2-3-application-yml"><a href="#2-3-application-yml" class="headerlink" title="2.3 application.yml"></a>2.3 application.yml</h3><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">inetutils:</span>
      <span class="hljs-attr">timeout-seconds:</span> <span class="hljs-number">10</span>

<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">instance:</span>
    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment">#eureka服务端的实例名称</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-comment"># false表示不向注册中心注册自己</span>
    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>
    <span class="hljs-comment"># false表示自己端就是注册中心, 我的职责就是维护服务实例，并不需要检索服务</span>
    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-comment"># 设置与Eureka server 交互的地址查询服务和注册服务都需要依赖这个地址</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></code></pre></div>

<h3 id="2-4-主启动类"><a href="#2-4-主启动类" class="headerlink" title="2.4 主启动类"></a>2.4 主启动类</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.springcloud;

<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/27 9:19</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableEurekaServer</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaMain7001</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      SpringApplication.run(EurekaMain7001.class, args);
   &#125;
&#125;</code></pre></div>

<h3 id="2-5-问题"><a href="#2-5-问题" class="headerlink" title="2.5 问题"></a>2.5 问题</h3><ul>
<li><p>Eureka注册失败 <strong>Cannot determine local hostname</strong></p>
</li>
<li><p>增加配置</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">inetutils:</span>
      <span class="hljs-attr">timeout-seconds:</span> <span class="hljs-number">10</span></code></pre></div>

</li>
</ul>
<h3 id="2-6-测试"><a href="#2-6-测试" class="headerlink" title="2.6 测试"></a>2.6 测试</h3><p>浏览器地址栏输入：<a href="http://localhost:7001/">http://localhost:7001/</a></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210427170930511.png" alt="image-20210427170930511"></p>
<h3 id="2-7-服务注册"><a href="#2-7-服务注册" class="headerlink" title="2.7 服务注册"></a>2.7 服务注册</h3><h4 id="1-支付微服务8001入驻进EurekaServer"><a href="#1-支付微服务8001入驻进EurekaServer" class="headerlink" title="1 支付微服务8001入驻进EurekaServer"></a>1 支付微服务8001入驻进EurekaServer</h4><ul>
<li><p>改pom，增加依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--eureka server--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>改yml，增加配置</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-comment"># 表示是否将自己注册进EurekaServer默认为true。</span>
    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>
    <span class="hljs-comment"># 是否从EurekaServer抓取已有的注册信息，默认为true。</span>
    <span class="hljs-comment"># 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span>
    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span></code></pre></div>
</li>
<li><p>主启动类，加注解</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableEurekaClient</span> <span class="hljs-comment">// 增加的注解</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentMain8001</span> </span>&#123;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
      SpringApplication.run(PaymentMain8001.class, args);
   &#125;
&#125;</code></pre></div>
</li>
<li><p>测试</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210427172855280.png" alt="image-20210427172855280"></p>
</li>
</ul>
<h4 id="2-订单微服务80入驻进EurekaServer"><a href="#2-订单微服务80入驻进EurekaServer" class="headerlink" title="2 订单微服务80入驻进EurekaServer"></a>2 订单微服务80入驻进EurekaServer</h4><ul>
<li><p>改pom，增加依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--eureka server--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>改yml，增加配置</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-comment"># 表示是否将自己注册进EurekaServer默认为true。</span>
    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>
    <span class="hljs-comment"># 是否从EurekaServer抓取已有的注册信息，默认为true。</span>
    <span class="hljs-comment"># 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span>
    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span></code></pre></div>
</li>
<li><p>主启动类，加注解</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span>
<span class="hljs-meta">@EnableEurekaServer</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderMain80</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		SpringApplication.run(OrderMain80.class, args);
	&#125;
&#125;</code></pre></div>
</li>
<li><p>测试</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210427173202248.png" alt="image-20210427173202248"></p>
</li>
</ul>
<h3 id="2-8-服务发现"><a href="#2-8-服务发现" class="headerlink" title="2.8 服务发现"></a>2.8 服务发现</h3><ul>
<li><p>修改controller </p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获取一些信息,得到具体的微服务</span>
<span class="hljs-meta">@Resource</span>
<span class="hljs-keyword">private</span> DiscoveryClient client;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 注册进来的微服务, 获取一些信息</span>
<span class="hljs-meta">@GetMapping(value = &quot;/payment/discovery&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">discovery</span><span class="hljs-params">()</span> </span>&#123;
   List&lt;String&gt; services = client.getServices();
   System.out.println(<span class="hljs-string">&quot;discovery ==&gt; services: &quot;</span> + services);

   <span class="hljs-comment">// 得到一个具体的微服务信息, 通过具体的微服务ID</span>
   List&lt;ServiceInstance&gt; instances = client.getInstances(<span class="hljs-string">&quot;CLOUD-ORDER-SERVICE&quot;</span>);
   <span class="hljs-keyword">for</span> (ServiceInstance instance : instances) &#123;
      System.out.println(
            instance.getHost() + <span class="hljs-string">&quot;\t&quot;</span> +
                  instance.getHost() + <span class="hljs-string">&quot;\t&quot;</span> +
                  instance.getPort() + <span class="hljs-string">&quot;\t&quot;</span> +
                  instance.getUri() + <span class="hljs-string">&quot;\t&quot;</span> +
                  instance.getServiceId() + <span class="hljs-string">&quot;\n&quot;</span>
      );
   &#125;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.client;
&#125;</code></pre></div>

</li>
</ul>
<h3 id="2-9-自我保护"><a href="#2-9-自我保护" class="headerlink" title="2.9 自我保护"></a>2.9 自我保护</h3><ul>
<li><p>在eurekaServer端7001处设置关闭自我保护机制</p>
<p>出厂默认，自我保护机制是开启的</p>
<p>使用<code>eureka.server.enable-self-preservation = false</code>可以禁用自我保护模式</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span>
  <span class="hljs-string">...</span>
  <span class="hljs-attr">server:</span>
    <span class="hljs-comment">#关闭自我保护机制，保证不可用服务被及时踢除</span>
    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span>
    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">2000</span></code></pre></div>
</li>
<li><p>生产者客户端eureakeClient端8001</p>
<p>默认：</p>
<p>eureka.instance.lease-renewal-interval-in-seconds=30<br>eureka.instance.lease-expiration-duration-in-seconds=90</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span>
  <span class="hljs-string">...</span>
  <span class="hljs-attr">instance:</span>
    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">payment8001</span>
    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>
    <span class="hljs-comment">#心跳检测与续约时间</span>
    <span class="hljs-comment">#开发时没置小些，保证服务关闭后注册中心能即使剔除服务</span>
    <span class="hljs-comment">#Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)</span>
    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">1</span>
    <span class="hljs-comment">#Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务</span>
    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">2</span></code></pre></div>

<h3 id="2-10-停更说明"><a href="#2-10-停更说明" class="headerlink" title="2.10 停更说明"></a>2.10 停更说明</h3><p><a href="https://github.com/Netflix/eureka/wiki">https://github.com/Netflix/eureka/wiki</a></p>
<blockquote>
<p>  Eureka 2.0 (Discontinued)</p>
<p>  The existing open source work on eureka 2.0 is discontinued. The code base and artifacts that were released as part of the existing repository of work on the 2.x branch is considered use at your own risk.</p>
<p>  Eureka 1.x is a core part of Netflix’s service discovery system and is still an active project.</p>
</blockquote>
</li>
</ul>
<h2 id="3-Hystrix-服务降级"><a href="#3-Hystrix-服务降级" class="headerlink" title="3 Hystrix 服务降级"></a>3 Hystrix 服务降级</h2><h3 id="3-1-Hystrix是什么"><a href="#3-1-Hystrix是什么" class="headerlink" title="3.1 Hystrix是什么"></a>3.1 Hystrix是什么</h3><ul>
<li><p><strong>概述</strong></p>
</li>
<li><p><strong>分布式系统面临的问题</strong></p>
<p>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。</p>
</li>
<li><p><strong>服务雪崩</strong></p>
<p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.<br>对于高流量的应用来说，单一的后避依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p>
<p>所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。</p>
</li>
<li><p><strong>Hystrix是什么</strong></p>
<p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</p>
<p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝)，向调用方返回一个符合预期的、可处理的备选响应（FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<blockquote>
<p>  hystrix<br>  n. 豪猪属;猬草属;豪猪;豪猪亚属</p>
</blockquote>
</li>
</ul>
<h3 id="3-2-Hystrix停更进维"><a href="#3-2-Hystrix停更进维" class="headerlink" title="3.2 Hystrix停更进维"></a>3.2 Hystrix停更进维</h3><ul>
<li><p><strong>能干嘛</strong></p>
<ul>
<li>服务降级</li>
<li>服务熔断</li>
<li>接近实对的监控</li>
<li>…</li>
</ul>
</li>
<li><p><strong>官网资料</strong></p>
<p><a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">link</a></p>
</li>
<li><p><strong>Hystrix官宣，停更进维</strong></p>
<p><a href="https://github.com/Netflix/Hystrix">link</a></p>
<ul>
<li>被动修bugs</li>
<li>不再接受合并请求</li>
<li>不再发布新版本</li>
</ul>
</li>
</ul>
<h3 id="3-3-Hystrix的服务降级熔断限流概念初讲"><a href="#3-3-Hystrix的服务降级熔断限流概念初讲" class="headerlink" title="3.3 Hystrix的服务降级熔断限流概念初讲"></a>3.3 Hystrix的服务降级熔断限流概念初讲</h3><ul>
<li><p><strong>服务降级</strong></p>
<p>服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback</p>
</li>
<li><p><strong>哪些情况会出发降级</strong></p>
<ul>
<li>程序运行导常</li>
<li>超时</li>
<li>服务熔断触发服务降级</li>
<li>线程池/信号量打满也会导致服务降级</li>
</ul>
</li>
<li><p><strong>服务熔断</strong></p>
<p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。</p>
<p>服务的降级 -&gt; 进而熔断 -&gt; 恢复调用链路</p>
</li>
<li><p><strong>服务限流</strong></p>
<p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。</p>
</li>
</ul>
<h3 id="3-4-Hystrix支付微服务构建"><a href="#3-4-Hystrix支付微服务构建" class="headerlink" title="3.4 Hystrix支付微服务构建"></a>3.4 Hystrix支付微服务构建</h3><p>将cloud-eureka-server7001改配置成单机版</p>
<ol>
<li><p>新建cloud-provider-hygtrix-payment8001</p>
</li>
<li><p><strong>POM</strong></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>SpringCloudS<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud_provider_hygtrix_payment_8001<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--hystrix--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--eureka server--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud_api_commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--boot web actuator--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>
</li>
<li><p><strong>yml</strong></p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-provider-hystrix-payment</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">inetutils:</span>
      <span class="hljs-attr">timeout-seconds:</span> <span class="hljs-number">10</span>

<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span> <span class="hljs-comment"># 单机版</span></code></pre></div>
</li>
<li><p><strong>主启动</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.springcloud;

<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/5/11 22:04</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableEurekaClient</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentHystrixMain8001</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		SpringApplication.run(PaymentHystrixMain8001.class, args);
	&#125;
&#125;</code></pre></div>
</li>
<li><p><strong>业务类</strong></p>
<p><strong>service</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentService</span> </span>&#123;

	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_OK</span><span class="hljs-params">(Integer id)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程池: &quot;</span> + Thread.currentThread().getName()
				+ <span class="hljs-string">&quot; paymentInfo_OK&quot;</span> + id + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;O(∩_∩)O哈哈~&quot;</span>;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_TimeOut</span><span class="hljs-params">(Integer id)</span> </span>&#123;
		<span class="hljs-keyword">try</span> &#123;
			TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">3000</span>);
		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
			e.printStackTrace();
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程池: &quot;</span> + Thread.currentThread().getName()
				+ <span class="hljs-string">&quot; paymentInfo_TimeOut&quot;</span> + id
				+ <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;O(∩_∩)O哈哈~&quot;</span> + <span class="hljs-string">&quot;  耗时(秒): 3&quot;</span>;
	&#125;
&#125;
</code></pre></div>

<p><strong>controller</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;

	<span class="hljs-meta">@Resource</span>
	<span class="hljs-keyword">private</span> PaymentService paymentService;

	<span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
	<span class="hljs-keyword">private</span> String serverPort;  <span class="hljs-comment">// 添加serverPort</span>

	<span class="hljs-meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_OK</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
		String result = paymentService.paymentInfo_OK(id);
		log.info(<span class="hljs-string">&quot;*****result: &quot;</span> + result);
		<span class="hljs-keyword">return</span> result;
	&#125;

	<span class="hljs-meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_TimeOut</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
		String result = paymentService.paymentInfo_TimeOut(id);
		log.info(<span class="hljs-string">&quot;*****result: &quot;</span> + result);
		<span class="hljs-keyword">return</span> result;
	&#125;
&#125;</code></pre></div>
</li>
<li><p><strong>测试</strong></p>
<ul>
<li>启动eureka7001</li>
</ul>
</li>
</ol>
<div class="code-wrapper"><pre><code>-   启动cloud-provider-hystrix-payment8001


-   访问


-   success的方法 - http://localhost:8001/payment/hystrix/ok/1
-   每次调用耗费5秒钟 - http://localhost:8001/payment/hystrix/timeout/1

-   上述module均OK


-   以上述为根基平台，从正确 -&gt; 错误 -&gt; 降级熔断 -&gt; 恢复。</code></pre></div><h3 id="3-5-JMeter高并发压测后卡顿"><a href="#3-5-JMeter高并发压测后卡顿" class="headerlink" title="3.5 JMeter高并发压测后卡顿"></a>3.5 JMeter高并发压测后卡顿</h3><p><strong>上述在非高并发情形下，还能勉强满足</strong></p>
<p><strong>Jmeter压测测试</strong></p>
<p><a href="https://jmeter.apache.org/index.html">JMeter官网</a></p>
<blockquote>
<p>  The Apache JMeter™ application is open source software, a 100% pure Java application designed to load test functional behavior and measure performance. It was originally designed for testing Web Applications but has since expanded to other test functions.</p>
</blockquote>
<p>开启Jmeter，来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务</p>
<ol>
<li><p>测试计划中右键添加-》线程-》线程组（线程组202102，线程数：200，线程数：100，其他参数默认）</p>
</li>
<li><p>刚刚新建线程组202102，右键它-》添加-》取样器-》Http请求-》基本 输入<a href="http://localhost:8001/payment/hystrix/ok/1">http://localhost:8001/payment/hystrix/ok/1</a></p>
</li>
<li><p>点击绿色三角形图标启动。</p>
</li>
</ol>
<p>看演示结果：拖慢，原因：tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。</p>
<p>Jmeter压测结论</p>
<p>上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖慢。</p>
<h3 id="3-6订单微服务调用支付服务出现卡顿"><a href="#3-6订单微服务调用支付服务出现卡顿" class="headerlink" title="3.6订单微服务调用支付服务出现卡顿"></a>3.6订单微服务调用支付服务出现卡顿</h3><p><strong>看热闹不嫌弃事大，80新建加入</strong></p>
<ol>
<li><p>新建 - cloud-consumer-feign-hystrix-order80</p>
</li>
<li><p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-comment">&lt;!--hystrix--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!--openfeign--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!--eureka server--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!--boot web actuator--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!--引入自己定义的api通用包，可以使用Payment支付Entity--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud_api_commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div>
</li>
<li><p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>

<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/</span></code></pre></div>
</li>
<li><p>主启动</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.netflix.hystrix.EnableHystrix;
<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableFeignClients</span>
<span class="hljs-comment">//@EnableHystrix</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderHystrixMain80</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;
        SpringApplication.run(OrderHystrixMain80.class,args);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>业务类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.springcloud.service;

<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/5/14 20:16</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PaymentHystrixService</span> </span>&#123;
	<span class="hljs-meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_OK</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;

	<span class="hljs-meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_TimeOut</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;

&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.springcloud.controller;

<span class="hljs-keyword">import</span> com.pnca.springcloud.service.PaymentHystrixService;
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-keyword">import</span> javax.annotation.Resource;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/5/14 20:22</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderHystrixController</span> </span>&#123;
	<span class="hljs-meta">@Resource</span>
	<span class="hljs-keyword">private</span> PaymentHystrixService paymentHystrixService;

	<span class="hljs-meta">@GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_OK</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
		String result = paymentHystrixService.paymentInfo_OK(id);
		<span class="hljs-keyword">return</span> result;
	&#125;

	<span class="hljs-meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_TimeOut</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
		String result = paymentHystrixService.paymentInfo_TimeOut(id);
		<span class="hljs-keyword">return</span> result;
	&#125;
&#125;</code></pre></div>
</li>
<li><p>正常测试</p>
<ul>
<li><a href="http://localhost/consumer/payment/hystrix/ok/1">http://localhost/consumer/payment/hystrix/ok/1</a></li>
</ul>
</li>
<li><p>高并发测试</p>
<ul>
<li>2W个线程压8001</li>
<li>消费端80微服务再去访问正常的Ok微服务8001地址</li>
<li><a href="http://localhost/consumer/payment/hystrix/ok/32">http://localhost/consumer/payment/hystrix/ok/32</a></li>
<li>消费者80被拖慢</li>
<li>原因：8001同一层次的其它接口服务被困死，因为tomcat线程池里面的工作线程已经被挤占完毕。</li>
<li>正因为有上述故障或不佳表现才有我们的降级/容错/限流等技术诞生。</li>
</ul>
</li>
</ol>
<h3 id="3-7-降级容错解决的维度要求"><a href="#3-7-降级容错解决的维度要求" class="headerlink" title="3.7 降级容错解决的维度要求"></a>3.7 降级容错解决的维度要求</h3><p>超时导致服务器变慢(转圈) - 超时不再等待</p>
<p>出错(宕机或程序运行出错) - 出错要有兜底</p>
<p>解决：</p>
<ul>
<li>对方服务(8001)超时了，调用者(80)不能一直卡死等待，必须有服务降级。</li>
<li>对方服务(8001)down机了，调用者(80)不能一直卡死等待，必须有服务降级。</li>
<li>对方服务(8001)OK，调用者(80)自己出故障或有自我要求(自己的等待时间小于服务提供者)，自己处理降级。</li>
</ul>
<h3 id="3-8-Hystrix之服务降级支付侧fallback"><a href="#3-8-Hystrix之服务降级支付侧fallback" class="headerlink" title="3.8 Hystrix之服务降级支付侧fallback"></a>3.8 Hystrix之服务降级支付侧fallback</h3><p>降级配置 - @HystrixCommand</p>
<p>8001先从自身找问题</p>
<p><strong>设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处埋，作服务降级fallback。</strong></p>
<p><strong>8001fallback</strong></p>
<p>业务类启用 - @HystrixCommand报异常后如何处理</p>
<p>—旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentService</span> </span>&#123;

	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_OK</span><span class="hljs-params">(Integer id)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程池: &quot;</span> + Thread.currentThread().getName()
				+ <span class="hljs-string">&quot; paymentInfo_OK&quot;</span> + id + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;O(∩_∩)O哈哈~&quot;</span>;
	&#125;

	<span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;/*指定善后方法名*/,</span>
<span class="hljs-meta">			commandProperties = &#123;@HystrixProperty(</span>
<span class="hljs-meta">					name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;3000&quot;)</span>
<span class="hljs-meta">			&#125;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_TimeOut</span><span class="hljs-params">(Integer id)</span> </span>&#123;
<span class="hljs-comment">//		int age = 10 / 0;</span>
		<span class="hljs-keyword">try</span> &#123;
			TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">5000</span>);
		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
			e.printStackTrace();
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程池: &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;id: &quot;</span>
				+ id + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;O(∩_∩)O哈哈~&quot;</span> + <span class="hljs-string">&quot;  耗时(秒):&quot;</span>;
	&#125;

	<span class="hljs-comment">//用来善后的方法</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_TimeOutHandler</span><span class="hljs-params">(Integer id)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程池:  &quot;</span> + Thread.currentThread().getName()
				+ <span class="hljs-string">&quot;  8001系统繁忙或者运行报错，请稍后再试,id:  &quot;</span>
				+ id + <span class="hljs-string">&quot;\t&quot;</span> + <span class="hljs-string">&quot;o(╥﹏╥)o&quot;</span>;
	&#125;
&#125;</code></pre></div>

<p>上面故意制造两种异常:</p>
<ol>
<li>int age = 10/0，计算异常</li>
<li>我们能接受3秒钟，它运行5秒钟，超时异常。</li>
</ol>
<p>当前服务不可用了，做服务降级，兜底的方案都是paymentInfo_TimeOutHandler</p>
<p><strong>主启动类激活</strong></p>
<p>添加新注解@EnableCircuitBreaker</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
<span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableEurekaClient</span>
<span class="hljs-meta">@EnableCircuitBreaker</span><span class="hljs-comment">//添加到此处</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentHystrixMain8001</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
            SpringApplication.run(PaymentHystrixMain8001.class, args);
    &#125;
&#125;</code></pre></div>

<h3 id="3-9-Hystrix之服务降级订单侧fallback"><a href="#3-9-Hystrix之服务降级订单侧fallback" class="headerlink" title="3.9 Hystrix之服务降级订单侧fallback"></a>3.9 Hystrix之服务降级订单侧fallback</h3><p>80订单微服务，也可以更好的保护自己，自己也依样画葫芦进行客户端降级保护</p>
<p>题外话，切记 - 我们自己配置过的热部署方式对java代码的改动明显</p>
<p>但对@HystrixCommand内属性的修改建议重启微服务</p>
<ul>
<li><p>YML</p>
<div class="code-wrapper"><pre><code class="hljs java">server:
  port: <span class="hljs-number">80</span>

eureka:
  client:
    register-with-eureka: <span class="hljs-keyword">false</span>
    service-url:
      defaultZone: http:<span class="hljs-comment">//eureka7001.com:7001/eureka/</span>

#开启
feign:
  hystrix:
    enabled: <span class="hljs-keyword">true</span></code></pre></div>
</li>
<li><p>主启动</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.netflix.hystrix.EnableHystrix;
<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableFeignClients</span>
<span class="hljs-meta">@EnableHystrix</span><span class="hljs-comment">//添加到此处</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderHystrixMain80</span></span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
        SpringApplication.run(OrderHystrixMain80.class,args);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>业务类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.lun.springcloud.service.PaymentHystrixService;
<span class="hljs-keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
<span class="hljs-keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-keyword">import</span> javax.annotation.Resource;

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderHystirxController</span> </span>&#123;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> PaymentHystrixService paymentHystrixService;


    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span>
    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;</span>
<span class="hljs-meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;1500&quot;)</span>
<span class="hljs-meta">    &#125;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_TimeOut</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
        <span class="hljs-comment">//int age = 10/0;</span>
        String result = paymentHystrixService.paymentInfo_TimeOut(id);
        <span class="hljs-keyword">return</span> result;
    &#125;
    
    <span class="hljs-comment">//善后方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentTimeOutFallbackMethod</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;</span>;
    &#125;

&#125;</code></pre></div>

</li>
</ul>
<h3 id="3-10-Hystrix之全局服务降级DefaultProperties"><a href="#3-10-Hystrix之全局服务降级DefaultProperties" class="headerlink" title="3.10 Hystrix之全局服务降级DefaultProperties"></a>3.10 Hystrix之全局服务降级DefaultProperties</h3><p><strong>目前问题1</strong> 每个业务方法对应一个兜底的方法，代码膨胀</p>
<p><strong>解决方法</strong></p>
<p>1:1每个方法配置一个服务降级方法，技术上可以，但是不聪明</p>
<p>1:N除了个别重要核心业务有专属，其它普通的可以通过@DefaultProperties(defaultFallback = “”)统一跳转到统一处理结果页面</p>
<p>通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.springcloud.controller;

<span class="hljs-keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;
<span class="hljs-keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
<span class="hljs-keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;
<span class="hljs-keyword">import</span> com.pnca.springcloud.service.PaymentHystrixService;
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-keyword">import</span> javax.annotation.Resource;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/5/14 20:22</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-meta">@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderHystrixController</span> </span>&#123;
	<span class="hljs-meta">@Resource</span>
	<span class="hljs-keyword">private</span> PaymentHystrixService paymentHystrixService;

	<span class="hljs-meta">@GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_OK</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
		String result = paymentHystrixService.paymentInfo_OK(id);
		<span class="hljs-keyword">return</span> result;
	&#125;

	<span class="hljs-comment">//	@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;, commandProperties = &#123;</span>
<span class="hljs-comment">//			@HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1500&quot;)</span>
<span class="hljs-comment">//	&#125;)</span>
	<span class="hljs-meta">@HystrixCommand</span><span class="hljs-comment">//用全局的fallback方法</span>
	<span class="hljs-meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_TimeOut</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
		<span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;
		String result = paymentHystrixService.paymentInfo_TimeOut(id);
		<span class="hljs-keyword">return</span> result;
	&#125;

	<span class="hljs-comment">//善后方法</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentTimeOutFallbackMethod</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o&quot;</span>;
	&#125;

	<span class="hljs-comment">// 下面是全局fallback方法</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">payment_Global_FallbackMethod</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~&quot;</span>;
	&#125;

&#125;</code></pre></div>

<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210518203239366.png" alt="image-20210518203239366"></p>
<h3 id="3-11-Hystrix之通配服务降级FeignFallback"><a href="#3-11-Hystrix之通配服务降级FeignFallback" class="headerlink" title="3.11 Hystrix之通配服务降级FeignFallback"></a>3.11 Hystrix之通配服务降级FeignFallback</h3><p><strong>目前问题2</strong> 统一和自定义的分开，代码混乱</p>
<p><strong>服务降级，客户端去调用服务端，碰上服务端宕机或关闭</strong></p>
<p>本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦</p>
<p><strong>未来我们要面对的异常</strong></p>
<ul>
<li>运行</li>
<li>超时</li>
<li>宕机</li>
</ul>
<p><strong>修改cloud-consumer-feign-hystrix-order80</strong></p>
<p>根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，<br>重新新建一个类(AaymentFallbackService)实现该接口，统一为接口里面的方法进行异常处理</p>
<ul>
<li><p>PaymentFallbackService类实现PaymentHystrixService接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentFallbackService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PaymentHystrixService</span> </span>&#123;
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_OK</span><span class="hljs-params">(Integer id)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;----- PaymentFallbackService fall back - paymentInfo_OK, o(╥﹏╥)o&quot;</span>;
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_TimeOut</span><span class="hljs-params">(Integer id)</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;----- PaymentFallbackService fall back - paymentInfo_TimeOut, o(╥﹏╥)o&quot;</span>;
	&#125;
&#125;</code></pre></div>
</li>
<li><p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>

<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/</span>

<span class="hljs-comment">#开启</span>
<span class="hljs-attr">feign:</span>
  <span class="hljs-attr">hystrix:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span></code></pre></div>
</li>
<li><p>PaymentHystrixService接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;, fallback = PaymentFallbackService.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PaymentHystrixService</span> </span>&#123;
	<span class="hljs-meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_OK</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;

	<span class="hljs-meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo_TimeOut</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;

&#125;</code></pre></div>
</li>
<li><p>测试</p>
<ul>
<li><p>单个eureka先启动7001</p>
</li>
<li><p>PaymentHystrixMain8001启动</p>
</li>
<li><p>正常访问测试 - <a href="http://localhost/consumer/payment/hystrix/ok/1">http://localhost/consumer/payment/hystrix/ok/1</a></p>
</li>
<li><p>故意关闭微服务8001</p>
</li>
<li><p>客户端自己调用提示 - 此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210518204905169.png" alt="image-20210518204905169"></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-12-Hystrix之服务熔断理论"><a href="#3-12-Hystrix之服务熔断理论" class="headerlink" title="3.12 Hystrix之服务熔断理论"></a>3.12 Hystrix之服务熔断理论</h3><p>断路器，相当于保险丝。</p>
<p><strong>熔断机制概述</strong></p>
<p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该<strong>节点微服务调用响应正常后，恢复调用链路。</strong></p>
<p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand。</p>
<p><a href="https://martinfowler.com/bliki/CircuitBreaker.html">Martin Fowler的相关论文</a>)</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/state.png" alt="img"></p>
<h3 id="3-13-Hystrix之服务熔断案例-上"><a href="#3-13-Hystrix之服务熔断案例-上" class="headerlink" title="3.13 Hystrix之服务熔断案例(上)"></a>3.13 Hystrix之服务熔断案例(上)</h3><p><a href="https://hutool.cn/">Hutool国产工具类</a></p>
<ul>
<li><p>修改cloud-provider-hystrix-payment8001</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.hutool.core.util.IdUtil;
<span class="hljs-keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
<span class="hljs-keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentService</span></span>&#123;    

    ...
    
    <span class="hljs-comment">//=====服务熔断</span>
    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;</span>
<span class="hljs-meta">            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),// 是否开启断路器</span>
<span class="hljs-meta">            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),// 请求次数</span>
<span class="hljs-meta">            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), // 时间窗口期</span>
<span class="hljs-meta">            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),// 失败率达到多少后跳闸</span>
<span class="hljs-meta">    &#125;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentCircuitBreaker</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(id &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;******id 不能负数&quot;</span>);
        &#125;
        String serialNumber = IdUtil.simpleUUID();

        <span class="hljs-keyword">return</span> Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;调用成功，流水号: &quot;</span> + serialNumber;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentCircuitBreaker_fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;id 不能负数，请稍后再试，/(ㄒoㄒ)/~~   id: &quot;</span> +id;
    &#125;

&#125;</code></pre></div>

<blockquote>
<p>  The precise way that the circuit opening and closing occurs is as follows:</p>
<p>  Assuming the volume across a circuit meets a certain threshold : HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()<br>  And assuming that the error percentage, as defined above exceeds the error percentage defined in : HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()<br>  Then the circuit-breaker transitions from CLOSED to OPEN.<br>  While it is open, it short-circuits all requests made against that circuit-breaker.<br>  After some amount of time (HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()), the next request is let through. If it fails, the command stays OPEN for the sleep window. If it succeeds, it transitions to CLOSED and the logic in 1) takes over again.<br>  <a href="https://github.com/Netflix/Hystrix/issues/674">link</a></p>
</blockquote>
</li>
<li><p>HystrixCommandProperties配置类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.netflix.hystrix;

...

<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixCommandProperties</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(HystrixCommandProperties.class);

    <span class="hljs-comment">/* defaults */</span>
    <span class="hljs-comment">/* package */</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer default_metricsRollingStatisticalWindow = <span class="hljs-number">10000</span>;<span class="hljs-comment">// default =&gt; statisticalWindow: 10000 = 10 seconds (and default of 10 buckets so each bucket is 1 second)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer default_metricsRollingStatisticalWindowBuckets = <span class="hljs-number">10</span>;<span class="hljs-comment">// default =&gt; statisticalWindowBuckets: 10 = 10 buckets in a 10 second window so each bucket is 1 second</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer default_circuitBreakerRequestVolumeThreshold = <span class="hljs-number">20</span>;<span class="hljs-comment">// default =&gt; statisticalWindowVolumeThreshold: 20 requests in 10 seconds must occur before statistics matter</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer default_circuitBreakerSleepWindowInMilliseconds = <span class="hljs-number">5000</span>;<span class="hljs-comment">// default =&gt; sleepWindow: 5000 = 5 seconds that we will sleep before trying again after tripping the circuit</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer default_circuitBreakerErrorThresholdPercentage = <span class="hljs-number">50</span>;<span class="hljs-comment">// default =&gt; errorThresholdPercentage = 50 = if 50%+ of requests in 10 seconds are failures or latent then we will trip the circuit</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Boolean default_circuitBreakerForceOpen = <span class="hljs-keyword">false</span>;<span class="hljs-comment">// default =&gt; forceCircuitOpen = false (we want to allow traffic)</span>
    <span class="hljs-comment">/* package */</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Boolean default_circuitBreakerForceClosed = <span class="hljs-keyword">false</span>;<span class="hljs-comment">// default =&gt; ignoreErrors = false </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer default_executionTimeoutInMilliseconds = <span class="hljs-number">1000</span>; <span class="hljs-comment">// default =&gt; executionTimeoutInMilliseconds: 1000 = 1 second</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Boolean default_executionTimeoutEnabled = <span class="hljs-keyword">true</span>;

    ...
&#125;</code></pre></div>

</li>
</ul>
<h3 id="3-14-Hystrix之服务熔断案例-下"><a href="#3-14-Hystrix之服务熔断案例-下" class="headerlink" title="3.14 Hystrix之服务熔断案例(下)"></a>3.14 Hystrix之服务熔断案例(下)</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> PaymentService paymentService;

    ...
    
    <span class="hljs-comment">//====服务熔断</span>
    <span class="hljs-meta">@GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentCircuitBreaker</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>
<span class="hljs-function">    </span>&#123;
        String result = paymentService.paymentCircuitBreaker(id);
        log.info(<span class="hljs-string">&quot;****result: &quot;</span>+result);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;</code></pre></div>

<p><strong>测试</strong></p>
<p>自测cloud-provider-hystrix-payment8001</p>
<p>正确 - <a href="http://localhost:8001/payment/circuit/1">http://localhost:8001/payment/circuit/1</a></p>
<p>错误 - <a href="http://localhost:8001/payment/circuit/-1">http://localhost:8001/payment/circuit/-1</a></p>
<p>多次错误，再来次正确，但错误得显示</p>
<p>重点测试 - 多次错误，然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行</p>
<h3 id="3-15-Hystrix之服务熔断总结"><a href="#3-15-Hystrix之服务熔断总结" class="headerlink" title="3.15 Hystrix之服务熔断总结"></a>3.15 Hystrix之服务熔断总结</h3><p><strong>大神结论</strong></p>
<p><a href="https://martinfowler.com/bliki/CircuitBreaker.html">Martin Fowler的相关论文</a></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/84d60234d01c4b7e9cae515066eb711b.png" alt="img"></p>
<ul>
<li><p><strong>熔断类型</strong></p>
<ul>
<li>熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态。</li>
<li>熔断关闭：熔断关闭不会对服务进行熔断。</li>
<li>熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断。</li>
</ul>
</li>
<li><p><strong>官网断路器流程图</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/825d02fd7925521b1d76be0a21c15db0.png" alt="img"></p>
</li>
<li><p><strong>官网步骤</strong></p>
<blockquote>
<p>  The precise way that the circuit opening and closing occurs is as follows:</p>
<p>  Assuming the volume across a circuit meets a certain threshold : HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()<br>  And assuming that the error percentage, as defined above exceeds the error percentage defined in : HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()<br>  Then the circuit-breaker transitions from CLOSED to OPEN.<br>  While it is open, it short-circuits all requests made against that circuit-breaker.<br>  After some amount of time (HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()), the next request is let through. If it fails, the command stays OPEN for the sleep window. If it succeeds, it transitions to CLOSED and the logic in 1) takes over again.<br>  [link](<a href="https://github.com/Netflix/Hystrix/issues/674">Circuit Breaker will never be closed again if HystrixBadRequestException thrown! · Issue #674 · Netflix/Hystrix (github.com)</a>)</p>
</blockquote>
</li>
<li><p><strong>断路器在什么情况下开始起作用</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//=====服务熔断</span>
<span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;</span>
<span class="hljs-meta">    @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),// 是否开启断路器</span>
<span class="hljs-meta">    @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),// 请求次数</span>
<span class="hljs-meta">    @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), // 时间窗口期</span>
<span class="hljs-meta">    @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),// 失败率达到多少后跳闸</span>
<span class="hljs-meta">&#125;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentCircuitBreaker</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
    ...
&#125;</code></pre></div>
</li>
<li><p>涉及到<strong>断路器</strong>的<strong>三个重要参数</strong>：</p>
<ul>
<li>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</li>
<li>请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次7,即使所有的请求都超时或其他原因失败，断路器都不会打开。</li>
<li>错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</li>
</ul>
</li>
<li><p><strong>断路器开启或者关闭的条件</strong></p>
<ul>
<li>到达以下阀值，断路器将会开启：<ul>
<li>当满足一定的阀值的时候（默认10秒内超过20个请求次数)</li>
<li>当失败率达到一定的时候（默认10秒内超过50%的请求失败)<br>当开启的时候，所有请求都不会进行转发</li>
</ul>
</li>
<li>一段时间之后（默认是5秒)，这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。</li>
</ul>
</li>
<li><p><strong>断路器打开之后</strong></p>
<ul>
<li>再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</li>
<li>原来的主逻辑要如何恢复呢？<ul>
<li>对于这一问题，hystrix也为我们实现了自动恢复功能。</li>
<li>当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>All 配置</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;fallbackMethod&quot;, </span>
<span class="hljs-meta">                groupKey = &quot;strGroupCommand&quot;, </span>
<span class="hljs-meta">                commandKey = &quot;strCommand&quot;, </span>
<span class="hljs-meta">                threadPoolKey = &quot;strThreadPool&quot;,</span>
<span class="hljs-meta">                </span>
<span class="hljs-meta">                commandProperties = &#123;</span>
<span class="hljs-meta">                    // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;execution.isolation.strategy&quot;, value = &quot;THREAD&quot;),</span>
<span class="hljs-meta">                    // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;execution.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;),</span>
<span class="hljs-meta">                    // 配置命令执行的超时时间</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;execution.isolation.thread.timeoutinMilliseconds&quot;, value = &quot;10&quot;),</span>
<span class="hljs-meta">                    // 是否启用超时时间</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;execution.timeout.enabled&quot;, value = &quot;true&quot;),</span>
<span class="hljs-meta">                    // 执行超时的时候是否中断</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnTimeout&quot;, value = &quot;true&quot;),</span>
<span class="hljs-meta">                    </span>
<span class="hljs-meta">                    // 执行被取消的时候是否中断</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;execution.isolation.thread.interruptOnCancel&quot;, value = &quot;true&quot;),</span>
<span class="hljs-meta">                    // 允许回调方法执行的最大并发数</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;fallback.isolation.semaphore.maxConcurrentRequests&quot;, value = &quot;10&quot;),</span>
<span class="hljs-meta">                    // 服务降级是否启用，是否执行回调函数</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;fallback.enabled&quot;, value = &quot;true&quot;),</span>
<span class="hljs-meta">                    // 是否启用断路器</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;),</span>
<span class="hljs-meta">                    // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;20&quot;),</span>
<span class="hljs-meta">                    </span>
<span class="hljs-meta">                    // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过 circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50, 就把断路器设置为 &quot;打开&quot; 状态，否则就设置为 &quot;关闭&quot; 状态。</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;50&quot;),</span>
<span class="hljs-meta">                    // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，会将断路器置为 &quot;半开&quot; 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 &quot;打开&quot; 状态，如果成功就设置为 &quot;关闭&quot; 状态。</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;circuitBreaker.sleepWindowinMilliseconds&quot;, value = &quot;5000&quot;),</span>
<span class="hljs-meta">                    // 断路器强制打开</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;circuitBreaker.forceOpen&quot;, value = &quot;false&quot;),</span>
<span class="hljs-meta">                    // 断路器强制关闭</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;circuitBreaker.forceClosed&quot;, value = &quot;false&quot;),</span>
<span class="hljs-meta">                    // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;metrics.rollingStats.timeinMilliseconds&quot;, value = &quot;10000&quot;),</span>
<span class="hljs-meta">                    </span>
<span class="hljs-meta">                    // 该属性用来设置滚动时间窗统计指标信息时划分&quot;桶&quot;的数量，断路器在收集指标信息的时候会根据设置的时间窗长度拆分成多个 &quot;桶&quot; 来累计各度量值，每个&quot;桶&quot;记录了一段时间内的采集指标。</span>
<span class="hljs-meta">                    // 比如 10 秒内拆分成 10 个&quot;桶&quot;收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;metrics.rollingStats.numBuckets&quot;, value = &quot;10&quot;),</span>
<span class="hljs-meta">                    // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.enabled&quot;, value = &quot;false&quot;),</span>
<span class="hljs-meta">                    // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.timeInMilliseconds&quot;, value = &quot;60000&quot;),</span>
<span class="hljs-meta">                    // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.numBuckets&quot;, value = &quot;60000&quot;),</span>
<span class="hljs-meta">                    // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，</span>
<span class="hljs-meta">                    // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，</span>
<span class="hljs-meta">                    // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;metrics.rollingPercentile.bucketSize&quot;, value = &quot;100&quot;),</span>
<span class="hljs-meta">                    </span>
<span class="hljs-meta">                    // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;metrics.healthSnapshot.intervalinMilliseconds&quot;, value = &quot;500&quot;),</span>
<span class="hljs-meta">                    // 是否开启请求缓存</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;requestCache.enabled&quot;, value = &quot;true&quot;),</span>
<span class="hljs-meta">                    // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;requestLog.enabled&quot;, value = &quot;true&quot;),</span>
<span class="hljs-meta"></span>
<span class="hljs-meta">                &#125;,</span>
<span class="hljs-meta">                threadPoolProperties = &#123;</span>
<span class="hljs-meta">                    // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;10&quot;),</span>
<span class="hljs-meta">                    // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列，否则将使用 LinkedBlockingQueue 实现的队列。</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;-1&quot;),</span>
<span class="hljs-meta">                    // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。</span>
<span class="hljs-meta">                    // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。</span>
<span class="hljs-meta">                    @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;5&quot;),</span>
<span class="hljs-meta">                &#125;</span>
<span class="hljs-meta">               )</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;
	...
&#125;</code></pre></div>



</li>
</ul>
<h3 id="3-16-Hystrix工作流程最后总结"><a href="#3-16-Hystrix工作流程最后总结" class="headerlink" title="3.16 Hystrix工作流程最后总结"></a>3.16 Hystrix工作流程最后总结</h3><p><strong>服务限流</strong> - 后面高级篇讲解alibaba的Sentinel说明</p>
<p><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">官方解释</a></p>
<p><strong>官网图例</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/hystrix-command-flow-chart.png" alt="img"></p>
<p><strong>步骤说明</strong></p>
<ol>
<li><p>创建HystrixCommand （用在依赖的服务返回单个操作结果的时候）或HystrixObserableCommand（用在依赖的服务返回多个操作结果的时候）对象。</p>
</li>
<li><p>命令执行。</p>
</li>
<li><p>其中 HystrixCommand实现了下面前两种执行方式</p>
<ol>
<li>execute()：同步执行，从依赖的服务返回一个单一的结果对象或是在发生错误的时候抛出异常。</li>
<li>queue()：异步执行，直接返回一个Future对象，其中包含了服务执行结束时要返回的单一结果对象。</li>
</ol>
</li>
<li><p>而 HystrixObservableCommand实现了后两种执行方式：</p>
<ol>
<li>obseve()：返回Observable对象，它代表了操作的多个统</li>
</ol>
<p>果，它是一个Hot Observable （不论“事件源”是否有“订阅者”，都会在创建后对事件进行发布，所以对于Hot Observable的每一个“订阅者”都有可能是从“事件源”的中途开始的，并可能只是看到了整个操作的局部过程）。</p>
<ol start="2">
<li>toObservable()：同样会返回Observable对象，也代表了操作的多个结果，但它返回的是一个Cold Observable（没有“订间者”的时候并不会发布事件，而是进行等待，直到有“订阅者”之后才发布事件，所以对于Cold Observable 的订阅者，它可以保证从一开始看到整个操作的全部过程）。</li>
</ol>
<p>若当前命令的请求缓存功能是被启用的，并且该命令缓存命中，那么缓存的结果会立即以</p>
</li>
<li><p>若当前命令的请求缓存功能是被启用的，并且该命令缓存命中，那么缓存的结果会立即以Observable对象的形式返回。</p>
</li>
<li><p>检查断路器是否为打开状态。如果断路器是打开的，那么Hystrix不会执行命令，而是转接到fallback处理逻辑(第8步)；如果断路器是关闭的，检查是否有可用资源来执行命令(第5步)。</p>
</li>
<li><p>线程池/请求队列信号量是否占满。如果命令依赖服务的专有线程地和请求队列，或者信号量（不使用线程的时候）已经被占满，那么Hystrix也不会执行命令，而是转接到fallback处理理辑(第8步) 。</p>
</li>
<li><p>Hystrix会根据我们编写的方法来决定采取什么样的方式去请求依赖服务。</p>
<ol>
<li>HystrixCommand.run()：返回一个单一的结果，或者抛出异常。</li>
<li>HystrixObservableCommand.construct()：返回一个Observable对象来发射多个结果，或通过onError发送错误通知。</li>
</ol>
</li>
<li><p>Hystix会将“成功”、“失败”、“拒绝”、“超时” 等信息报告给断路器，而断路器会维护一组计数器来统计这些数据。断路器会使用这些统计数据来决定是否要将断路器打开，来对某个依赖服务的请求进行”熔断/短路”。</p>
</li>
<li><p>当命令执行失败的时候，Hystix会进入fallback尝试回退处理，我们通常也称波操作为“服务降级”。而能够引起服务降级处理的情况有下面几种：</p>
<ol>
<li>第4步∶当前命令处于“熔断/短路”状态，断洛器是打开的时候。</li>
<li>第5步∶当前命令的钱程池、请求队列或者信号量被占满的时候。</li>
<li>第6步∶HystrixObsevableCommand.construct()或HytrixCommand.run()抛出异常的时候。</li>
</ol>
</li>
<li><p>当Hystrix命令执行成功之后，它会将处理结果直接返回或是以Observable的形式返回。</p>
</li>
</ol>
<p><strong>tips</strong>：如果我们没有为命令实现降级逻辑或者在降级处理逻辑中抛出了异常，Hystrix依然会运回一个Obsevable对象，但是它不会发射任结果数惯，而是通过onError方法通知命令立即中断请求，并通过onError方法将引起命令失败的异常发送给调用者。</p>
<h3 id="3-17-Hystrix图形化Dashboard搭建"><a href="#3-17-Hystrix图形化Dashboard搭建" class="headerlink" title="3.17 Hystrix图形化Dashboard搭建"></a>3.17 Hystrix图形化Dashboard搭建</h3><ul>
<li><p>概述</p>
<p>除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控(Hystrix Dashboard)，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。</p>
<p>Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。</p>
<p>仪表盘9001</p>
</li>
<li><p>新建cloud-consumer-hystrix-dashboard9001</p>
</li>
<li><p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>SpringCloudS<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-consumer-hystrix-dashboard9001<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>
</li>
<li><p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9001</span></code></pre></div>
</li>
<li><p>HystrixDashboardMain9001+新注解@EnableHystrixDashboard</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableHystrixDashboard</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixDashboardMain9001</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(HystrixDashboardMain9001.class,args);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>所有Provider微服务提供类(8001/8002/8003)都需要监控依赖配置</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>启动cloud-consumer-hystrix-dashboard9001该微服务后续将监控微服务8001</p>
<p>浏览器输入<a href="http://localhost:9001/hystrix">http://localhost:9001/hystrix</a></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210521103737389.png" alt="image-20210521103737389"></p>
</li>
<li><div class="code-wrapper"><pre><code class="java"><span class="keyword">import</span> org.springframework.boot.SpringApplication;
<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="keyword">import</span> org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;

<span class="meta">@SpringBootApplication</span>
<span class="meta">@EnableHystrixDashboard</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardMain9001</span></span>
<span class="class"></span>&#123;
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;
        SpringApplication.run(HystrixDashboardMain9001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;
    &#125;
&#125;

&lt;!--code￼<span class="number">44</span>--&gt;</code></pre></div>
</li>
<li><p>如果一直 Londing, 在dashboard项目中添加依赖</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">hystrix:</span>
  <span class="hljs-attr">dashboard:</span>
    <span class="hljs-attr">proxy-stream-allow-list:</span> <span class="hljs-string">&quot;localhost&quot;</span></code></pre></div>
</li>
<li><p><strong>监控测试</strong></p>
<ul>
<li>启动1个eureka</li>
<li>启动8001，9001</li>
</ul>
</li>
<li><p><strong>观察监控窗口</strong></p>
<p>9001监控8001 - 填写监控地址 -  <a href="http://localhost:8001/actuator/hystrix.stream">http://localhost:8001/actuator/hystrix.stream</a> 到 <a href="http://localhost:9001/hystrix页面的输入框。">http://localhost:9001/hystrix页面的输入框。</a></p>
</li>
<li><p>测试地址</p>
<ul>
<li><p><a href="http://localhost:8001/payment/circuit/1">http://localhost:8001/payment/circuit/1</a></p>
</li>
<li><p><a href="http://localhost:8001/payment/circuit/-1">http://localhost:8001/payment/circuit/-1</a></p>
</li>
<li><p>测试通过</p>
</li>
<li><p>先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210521105756646.png" alt="image-20210521105756646"></p>
</li>
</ul>
</li>
<li><p><strong>如何看?</strong></p>
<ul>
<li><p>7色</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/6740b2a462751db0ce8f2813f740c5b5.png" alt="img"></p>
</li>
<li><p>1圈</p>
<p>实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减。</p>
<p>该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，<strong>流量越大该实心圆就越大</strong>。所以通过该实心圆的展示，就可以在大量的实例中快速的发现故障实例和高压力实例。</p>
</li>
<li><p>1线</p>
<p>曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势。</p>
</li>
<li><p>整图说明</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/8a8c682ab027e313e4d9af9e4bd96206.png" alt="img"></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/7fe0003d738028e6e20a3bf8f802cd2d.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-GateWay"><a href="#4-GateWay" class="headerlink" title="4 GateWay"></a>4 GateWay</h2><ul>
<li><p>Zuul开发人员窝里斗，实属明日黄花</p>
</li>
<li><p>重点关注Gate Way</p>
</li>
</ul>
<h3 id="4-1-GateWay是什么"><a href="#4-1-GateWay是什么" class="headerlink" title="4.1 GateWay是什么"></a>4.1 GateWay是什么</h3><p><a href="https://github.com/Netflix/zuul/wiki">上一代zuul 1.x官网</a></p>
<p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/">Gateway官网</a></p>
<h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ul>
<li><p>Cloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关;</p>
</li>
<li><p>但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul，那就是SpringCloud Gateway—句话：gateway是原zuul1.x版的替代。<img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/54b61d819aa1630bc61732de340b55b4.png" alt></p>
</li>
<li><p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。</p>
</li>
</ul>
<ul>
<li>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如:熔断、限流、重试等。</li>
</ul>
<ul>
<li>SpringCloud Gateway是Spring Cloud的一个全新项目，基于Spring 5.0+Spring Boot 2.0和Project Reactor等技术开发的网关，它旨在为微服务架构提供—种简单有效的统一的API路由管理方式。</li>
</ul>
<ul>
<li><p>SpringCloud Gateway作为Spring Cloud 生态系统中的网关，目标是替代Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</p>
</li>
<li><p>Spring Cloud Gateway的目标提供统一的路由方式且基于 Filter链的方式提供了网关基本的功能，例如:安全，监控/指标，和限流。</p>
</li>
</ul>
<h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h4><ul>
<li>方向代理</li>
<li>鉴权</li>
<li>流量控制</li>
<li>熔断</li>
<li>日志监控</li>
<li>…</li>
</ul>
<h4 id="3-微服务架构中网关的位置"><a href="#3-微服务架构中网关的位置" class="headerlink" title="3 微服务架构中网关的位置"></a>3 微服务架构中网关的位置</h4><p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/5877d4b9035ead9cd2d037609dceb442.png" alt="img"></p>
<h3 id="4-2-GateWay-非阻塞异步模型"><a href="#4-2-GateWay-非阻塞异步模型" class="headerlink" title="4.2 GateWay 非阻塞异步模型"></a>4.2 GateWay 非阻塞异步模型</h3><p>有Zuull了怎么又出来Gateway？<strong>我们为什么选择Gateway?</strong></p>
<ol>
<li>netflix不太靠谱，zuul2.0一直跳票，迟迟不发布。<ol>
<li>一方面因为Zuul1.0已经进入了维护阶段，而且Gateway是SpringCloud团队研发的，是亲儿子产品，值得信赖。而且很多功能Zuul都没有用起来也非常的简单便捷。</li>
<li>Gateway是基于异步非阻塞模型上进行开发的，性能方面不需要担心。虽然Netflix早就发布了最新的Zuul 2.x，但Spring Cloud貌似没有整合计划。而且Netflix相关组件都宣布进入维护期；不知前景如何?</li>
<li>多方面综合考虑Gateway是很理想的网关选择。</li>
</ol>
</li>
<li>SpringCloud Gateway具有如下特性<ol>
<li>基于Spring Framework 5，Project Reactor和Spring Boot 2.0进行构建；</li>
<li>动态路由：能够匹配任何请求属性；</li>
<li>可以对路由指定Predicate (断言)和Filter(过滤器)；</li>
<li>集成Hystrix的断路器功能；</li>
<li>集成Spring Cloud 服务发现功能；</li>
<li>易于编写的Predicate (断言)和Filter (过滤器)；</li>
<li>请求限流功能；</li>
<li>支持路径重写。</li>
</ol>
</li>
<li>SpringCloud Gateway与Zuul的区别<ol>
<li>在SpringCloud Finchley正式版之前，Spring Cloud推荐的网关是Netflix提供的Zuul。</li>
<li>Zuul 1.x，是一个基于阻塞I/O的API Gateway。</li>
<li>Zuul 1.x基于Servlet 2.5使用阻塞架构它不支持任何长连接(如WebSocket)Zuul的设计模式和Nginx较像，每次I/О操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用Java实现，而JVM本身会有第-次加载较慢的情况，使得Zuul的性能相对较差。</li>
<li>Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。Zuul .x的性能较Zuul 1.x有较大提升。在性能方面，根据官方提供的基准测试,Spring Cloud Gateway的RPS(每秒请求数)是Zuul的1.6倍。</li>
<li>Spring Cloud Gateway建立在Spring Framework 5、Project Reactor和Spring Boot2之上，使用非阻塞API。</li>
<li>Spring Cloud Gateway还支持WebSocket，并且与Spring紧密集成拥有更好的开发体验</li>
</ol>
</li>
</ol>
<h4 id="Zuul1-x模型"><a href="#Zuul1-x模型" class="headerlink" title="Zuul1.x模型"></a>Zuul1.x模型</h4><p>Springcloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传统的Serviet IO处理模型。</p>
<p>Servlet的生命周期？servlet 由 servlet container 进行生命周期管理。</p>
<ul>
<li>container 启动时构造 servlet 对象并调用 servlet init() 进行初始化；</li>
<li>container 运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用 service )；</li>
<li>container 关闭时调用 servlet destory() 销毁 servlet。</li>
</ul>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/b71ecbfb29c939615c988123a0704306.png" alt="img"></p>
<p>上述模式的<strong>缺点</strong>：</p>
<p>Servlet是一个简单的网络IO模型，当请求进入Servlet container时，Servlet container就会为其绑定一个线程，在<strong>并发不高的场景下</strong>这种模型是适用的。但是一旦高并发(如抽风用Jmeter压)，线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间。在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势。</p>
<p>所以Zuul 1.X是基于servlet之上的一个阻塞式处理模型，即Spring实现了处理所有request请求的一个servlet (DispatcherServlet)并由该servlet阻塞式处理处理。所以SpringCloud Zuul无法摆脱servlet模型的弊端。</p>
<h4 id="Gateway模型"><a href="#Gateway模型" class="headerlink" title="Gateway模型"></a>Gateway模型</h4><p>WebFlux是什么？[官方文档](<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux">官方文档 (spring.io)</a>)</p>
<p>传统的Web框架，比如说: Struts2，SpringMVC等都是基于Servlet APl与Servlet容器基础之上运行的。</p>
<p>但是在Servlet3.1之后有了异步非阻塞的支持。而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程(Spring 5必须让你使用Java 8)。</p>
<p>Spring WebFlux是Spring 5.0 引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet APl，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范。</p>
<blockquote>
<p>  Spring Cloud Gateway requires the Netty runtime provided by Spring Boot and Spring Webflux. It does not work in a traditional Servlet Container or when built as a WAR.<a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.7.RELEASE/reference/html/">link</a></p>
</blockquote>
<h3 id="4-3-Gateway工作流程"><a href="#4-3-Gateway工作流程" class="headerlink" title="4.3 Gateway工作流程"></a>4.3 Gateway工作流程</h3><h4 id="三大核心概念"><a href="#三大核心概念" class="headerlink" title="三大核心概念"></a>三大核心概念</h4><ol>
<li>Route(路由) - 路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由；</li>
<li>Predicate(断言) - 参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由；</li>
<li>Filter(过滤) - 指的是Spring框架中GatewayFilter的实例,使用过滤器,可以在请求被路由前或者之后对请求进行修改。</li>
</ol>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/70da1eecc951a338588356ee2db3fa1f.png" alt="img"></p>
<p>web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。</p>
<p>predicate就是我们的匹配条件；而fliter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了。</p>
<h4 id="Gateway工作流程"><a href="#Gateway工作流程" class="headerlink" title="Gateway工作流程"></a>Gateway工作流程</h4><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-how-it-works">官网总结</a></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/62be54501c6e2b95620b79cc918a2e9a.png" alt="img"></p>
<blockquote>
<p>  Clients make requests to Spring Cloud Gateway. If the Gateway Handler Mapping determines that a request matches a route, it is sent to the Gateway Web Handler. This handler runs the request through a filter chain that is specific to the request. The reason the filters are divided by the dotted line is that filters can run logic both before and after the proxy request is sent. All “pre” filter logic is executed. Then the proxy request is made. After the proxy request is made, the “post” filter logic is run. [link](<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-how-it-works">Spring Cloud Gateway</a>)</p>
</blockquote>
<ul>
<li>客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到GatewayWeb Handler。</li>
</ul>
<ul>
<li>Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</li>
</ul>
<ul>
<li>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”)或之后(“post”）执行业务逻辑。</li>
</ul>
<ul>
<li>Filter在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。</li>
</ul>
<p><strong>核心逻辑</strong>：路由转发 + 执行过滤器链。</p>
<h3 id="4-4-Gateway9527搭建"><a href="#4-4-Gateway9527搭建" class="headerlink" title="4.4 Gateway9527搭建"></a>4.4 Gateway9527搭建</h3><ol>
<li><p>新建 Module - cloud-gateway-gateway9527</p>
</li>
<li><p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>SpringCloudS<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud_gateway_gateway9527<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
	
	<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
		
		<span class="hljs-comment">&lt;!--gateway--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		
		<span class="hljs-comment">&lt;!--eureka-client--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>
</li>
<li><p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9527</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-gateway</span>

<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">instance:</span>
    <span class="hljs-attr">hostname:</span> <span class="hljs-string">cloud-gateway-service</span>
  <span class="hljs-attr">client:</span> <span class="hljs-comment">#服务提供者provider注册进eureka服务列表内</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka</span></code></pre></div>
</li>
<li><p>业务类</p>
<p>无</p>
</li>
<li><p>主启动类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;


<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableEurekaClient</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GateWayMain9527</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(GateWayMain9527.class, args);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>9527网关如何做路由映射?</p>
<p>cloud-provider-payment8001看看controller的访问地址</p>
<ul>
<li>get</li>
<li>lb</li>
</ul>
<p>我们目前不想暴露8001端口，希望在8001外面套一层9527</p>
</li>
<li><p>YML新增网关配置</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9527</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-gateway</span>
<span class="hljs-comment">#############################新增网关配置###########################</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment_routh</span> <span class="hljs-comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8001</span>          <span class="hljs-comment">#匹配后提供服务的路由地址</span>
          <span class="hljs-comment">#uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/payment/get/**</span>         <span class="hljs-comment"># 断言，路径相匹配的进行路由</span>

        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment_routh2</span> <span class="hljs-comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8001</span>          <span class="hljs-comment">#匹配后提供服务的路由地址</span>
          <span class="hljs-comment">#uri: lb://cloud-payment-service #匹配后提供服务的路由地址</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/payment/lb/**</span>         <span class="hljs-comment"># 断言，路径相匹配的进行路由</span>
<span class="hljs-comment">####################################################################</span>

<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">instance:</span>
    <span class="hljs-attr">hostname:</span> <span class="hljs-string">cloud-gateway-service</span>
  <span class="hljs-attr">client:</span> <span class="hljs-comment">#服务提供者provider注册进eureka服务列表内</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka</span></code></pre></div>
</li>
<li><p>测试</p>
<ul>
<li><p>启动7001</p>
</li>
<li><p>启动8001-cloud-provider-payment8001</p>
</li>
<li><p>启动9527网关</p>
</li>
<li><p>访问说明</p>
</li>
<li><p>添加网关前 - <a href="http://localhost:8001/payment/get/1">http://localhost:8001/payment/get/1</a></p>
</li>
<li><p>添加网关后 - <a href="http://localhost:9527/payment/get/1">http://localhost:9527/payment/get/1</a></p>
</li>
<li><p>两者访问成功，返回相同结果</p>
</li>
</ul>
</li>
</ol>
<h3 id="4-5-Gateway配置路由的两种方式"><a href="#4-5-Gateway配置路由的两种方式" class="headerlink" title="4.5 Gateway配置路由的两种方式"></a>4.5 Gateway配置路由的两种方式</h3><ul>
<li><p><strong>在配置文件yml中配置，见上一章节</strong></p>
</li>
<li><p><strong>代码中注入RouteLocator的Bean</strong></p>
</li>
<li><p>官方案例 - <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#modifying-the-way-remote-addresses-are-resolved">link</a></p>
<div class="code-wrapper"><pre><code class="hljs java">RemoteAddressResolver resolver = XForwardedRemoteAddressResolver
    .maxTrustedIndex(<span class="hljs-number">1</span>);

...

.route(<span class="hljs-string">&quot;direct-route&quot;</span>,
    r -&gt; r.remoteAddr(<span class="hljs-string">&quot;10.1.1.1&quot;</span>, <span class="hljs-string">&quot;10.10.1.1/24&quot;</span>)
        .uri(<span class="hljs-string">&quot;https://downstream1&quot;</span>)
.route(<span class="hljs-string">&quot;proxied-route&quot;</span>,
    r -&gt; r.remoteAddr(resolver, <span class="hljs-string">&quot;10.10.1.1&quot;</span>, <span class="hljs-string">&quot;10.10.1.1/24&quot;</span>)
        .uri(<span class="hljs-string">&quot;https://downstream2&quot;</span>)
)</code></pre></div>
</li>
<li><p>百度国内新闻网址，需要外网 - <a href="http://news.baidu.com/guonei">http://news.baidu.com/guonei</a></p>
</li>
<li><p><strong>自己写一个</strong></p>
<ul>
<li>业务需求 - 通过9527网关访问到外网的百度新闻网址</li>
</ul>
</li>
<li><p><strong>编码</strong><br>cloud-gateway-gateway9527业务实现</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.route.RouteLocator;
<span class="hljs-keyword">import</span> org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;


<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GateWayConfig</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title">customRouteLocator</span><span class="hljs-params">(RouteLocatorBuilder routeLocatorBuilder)</span></span>
<span class="hljs-function">    </span>&#123;
        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();

        routes.route(<span class="hljs-string">&quot;path_route_atguigu&quot;</span>,
                r -&gt; r.path(<span class="hljs-string">&quot;/guonei&quot;</span>)
                        .uri(<span class="hljs-string">&quot;http://news.baidu.com/guonei&quot;</span>)).build();

        <span class="hljs-keyword">return</span> routes.build();
    &#125;
&#125;</code></pre></div>



</li>
</ul>
<ul>
<li><p><strong>测试</strong></p>
<p>浏览器输入<a href="http://localhost:9527/guonei，返回http://news.baidu.com/guonei相同的页面。">http://localhost:9527/guonei，返回http://news.baidu.com/guonei相同的页面。</a></p>
</li>
</ul>
<h3 id="4-6-GateWay配置动态路由"><a href="#4-6-GateWay配置动态路由" class="headerlink" title="4.6 GateWay配置动态路由"></a>4.6 GateWay配置动态路由</h3><p>默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建<strong>动态路由进行转发，从而实现动态路由的功能</strong>（不写死一个地址）。</p>
<ul>
<li><p><strong>启动</strong></p>
<ul>
<li>eureka7001</li>
<li>payment8001/8002</li>
</ul>
</li>
<li><p><strong>POM</strong></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--eureka-client--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p><strong>YML</strong></p>
<p>需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。</p>
<p>lb://serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9527</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-gateway</span>
<span class="hljs-comment">#############################新增网关配置###########################</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">locator:</span>
          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#开启从注册中心动态创建路由的功能，利用微服务名进行路由</span>
      <span class="hljs-attr">routes:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment_routh</span> <span class="hljs-comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span>
          <span class="hljs-comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://cloud-payment-service</span> <span class="hljs-comment">#匹配后提供服务的路由地址</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/payment/get/**</span>         <span class="hljs-comment"># 断言，路径相匹配的进行路由</span>

        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">payment_routh2</span> <span class="hljs-comment">#payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名</span>
          <span class="hljs-comment">#uri: http://localhost:8001          #匹配后提供服务的路由地址</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://cloud-payment-service</span> <span class="hljs-comment">#匹配后提供服务的路由地址</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/payment/lb/**</span>         <span class="hljs-comment"># 断言，路径相匹配的进行路由</span>
<span class="hljs-comment">####################################################################</span>

<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">instance:</span>
    <span class="hljs-attr">hostname:</span> <span class="hljs-string">cloud-gateway-service</span>
  <span class="hljs-attr">client:</span> <span class="hljs-comment">#服务提供者provider注册进eureka服务列表内</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka</span></code></pre></div>
</li>
<li><p><strong>测试</strong></p>
<p>浏览器输入 - <a href="http://localhost:9527/payment/lb">http://localhost:9527/payment/lb</a></p>
</li>
<li><p>结果</p>
<p>不停刷新页面，8001/8002两个端口切换。</p>
</li>
</ul>
<h3 id="4-7-GateWay常用的Predicate"><a href="#4-7-GateWay常用的Predicate" class="headerlink" title="4.7 GateWay常用的Predicate"></a>4.7 GateWay常用的Predicate</h3><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">官方文档</a></p>
<ul>
<li><p><strong>Route Predicate Factories这个是什么</strong></p>
<blockquote>
<p>  Spring Cloud Gateway matches routes as part of the Spring WebFlux HandlerMapping infrastructure. Spring Cloud Gateway includes many built-in route predicate factories. All of these predicates match on different attributes of the HTTP request. You can combine multiple route predicate factories with logical and statements. [link](<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gateway-request-predicates-factories">Spring Cloud Gateway</a>)</p>
</blockquote>
</li>
<li><p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。</p>
</li>
<li><p>Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些Predicate都与HTTP请求的不同属性匹配。多个RoutePredicate工厂可以进行组合。</p>
</li>
<li><p>Spring Cloud Gateway创建Route 对象时，使用RoutePredicateFactory 创建 Predicate对象，Predicate 对象可以赋值给Route。Spring Cloud Gateway包含许多内置的Route Predicate Factories。</p>
</li>
<li><p>所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and。</p>
<blockquote>
<p>  <strong>predicate</strong></p>
<p>  美: [‘predɪkeɪt] 英: [‘predɪkət]</p>
<p>  <strong>v.</strong> 断言；使基于；使以…为依据；表明</p>
<p>  <strong>adj.</strong> 述语的；谓项的</p>
<p>  <strong>n.</strong> 谓语（句子成分，对主语加以陈述，如 John went home 中的 went home）</p>
</blockquote>
</li>
<li><p><strong>常用的Route Predicate Factory</strong></p>
<ul>
<li>The After Route Predicate Factory</li>
<li>The Before Route Predicate Factory</li>
<li>The Between Route Predicate Factory</li>
<li>The Cookie Route Predicate Factory</li>
<li>The Header Route Predicate Factory</li>
<li>The Host Route Predicate Factory</li>
<li>The Method Route Predicate Factory</li>
<li>The Path Route Predicate Factory</li>
<li>The Query Route Predicate Factory</li>
<li>The RemoteAddr Route Predicate Factory</li>
<li>The weight Route Predicate Factory</li>
</ul>
</li>
<li><p><strong>讨论几个Route Predicate Factory</strong></p>
<ul>
<li><p><strong>The After Route Predicate Factory</strong></p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">after_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-comment"># 这个时间后才能起效</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span></code></pre></div>
</li>
<li><p>可以通过下述方法获得上述格式的时间戳字符串</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.ZonedDateTime;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T2</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;
        ZonedDateTime zbj = ZonedDateTime.now(); <span class="hljs-comment">// 默认时区</span>
        System.out.println(zbj);

       <span class="hljs-comment">//2021-02-22T15:51:37.485+08:00[Asia/Shanghai]</span>
    &#125;
&#125;</code></pre></div>
</li>
<li><p><strong>The Between Route Predicate Factory</strong></p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">between_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-comment"># 两个时间点之间</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="hljs-number">2017-01-21T17:42:47.789-07:00</span>[<span class="hljs-string">America/Denver</span>]</code></pre></div>
</li>
<li><p><strong>The Cookie Route Predicate Factory</strong></p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">cookie_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=chocolate,</span> <span class="hljs-string">ch.p</span></code></pre></div>

<ul>
<li>The cookie route predicate factory takes two parameters, the cookie name and a regular expression.</li>
<li>This predicate matches cookies that have the given name and whose values match the regular expression.</li>
</ul>
</li>
<li><p>测试</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 该命令相当于发get请求，且没带cookie</span>
curl http://localhost:9527/payment/lb

<span class="hljs-meta">#</span><span class="bash"> 带cookie的</span>
curl http://localhost:9527/payment/lb --cookie &quot;chocolate=chip&quot;</code></pre></div>
</li>
<li><p><strong>The Header Route Predicate Factory</strong></p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">header_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span>
        <span class="hljs-attr">predicates:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">Header=X-Request-Id,</span> <span class="hljs-string">\d+</span></code></pre></div>

<ul>
<li>The header route predicate factory takes two parameters, the header name and a regular expression.</li>
<li>This predicate matches with a header that has the given name whose value matches the regular expression.</li>
</ul>
</li>
<li><p>测试</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 带指定请求头的参数的CURL命令</span>
curl http://localhost:9527/payment/lb -H &quot;X-Request-Id:123&quot;</code></pre></div>
</li>
<li><p>其它的，举一反三。</p>
</li>
</ul>
</li>
<li><p><strong>小结</strong></p>
<p>说白了，Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。</p>
</li>
</ul>
<h3 id="4-8-GateWay的Filter"><a href="#4-8-GateWay的Filter" class="headerlink" title="4.8 GateWay的Filter"></a>4.8 GateWay的Filter</h3><ul>
<li><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/#gatewayfilter-factories">官方文档</a></p>
<blockquote>
<p>  Route filters allow the modification of the incoming HTTP request or outgoing HTTP response in some manner. Route filters are scoped to a particular route. Spring Cloud Gateway includes many built-in GatewayFilter Factories.</p>
</blockquote>
<p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。</p>
</li>
<li><p>Spring Cloud Gateway的Filter:</p>
<ul>
<li>生命周期：<ul>
<li>pre</li>
<li>post</li>
</ul>
</li>
<li>种类（具体看官方文档）：<ul>
<li>GatewayFilter - 有31种</li>
<li>GlobalFilter - 有10种</li>
</ul>
</li>
</ul>
</li>
<li><p>常用的GatewayFilter：AddRequestParameter GatewayFilter</p>
</li>
<li><p>自定义全局GlobalFilter：</p>
<ul>
<li>两个主要接口介绍：<ul>
<li>GlobalFilter</li>
<li>Ordered</li>
</ul>
</li>
<li>能干什么：<ul>
<li>全局日志记录</li>
<li>统一网关鉴权</li>
</ul>
</li>
</ul>
</li>
<li><p>代码案例</p>
<p>GateWay9527项目添加MyLogGateWayFilter类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;
<span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;
<span class="hljs-keyword">import</span> org.springframework.core.Ordered;
<span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;
<span class="hljs-keyword">import</span> reactor.core.publisher.Mono;

<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLogGateWayFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalFilter</span>,<span class="hljs-title">Ordered</span></span>
<span class="hljs-class"></span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span>
<span class="hljs-function">    </span>&#123;
        log.info(<span class="hljs-string">&quot;***********come in MyLogGateWayFilter:  &quot;</span>+<span class="hljs-keyword">new</span> Date());

        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="hljs-string">&quot;uname&quot;</span>);

        <span class="hljs-keyword">if</span>(uname == <span class="hljs-keyword">null</span>)
        &#123;
            log.info(<span class="hljs-string">&quot;*******用户名为null，非法用户，o(╥﹏╥)o&quot;</span>);
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
            <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();
        &#125;

        <span class="hljs-keyword">return</span> chain.filter(exchange);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
&#125;</code></pre></div>
</li>
<li><p>测试</p>
</li>
<li><p>启动</p>
<ul>
<li>EurekaMain7001</li>
<li>PaymentMain8001</li>
<li>GateWayMain9527</li>
<li>PaymentMain8002</li>
</ul>
</li>
<li><p>浏览器输入</p>
<ul>
<li><a href="http://localhost:9527/payment/lb">http://localhost:9527/payment/lb</a> - 反问异常</li>
<li><a href="http://localhost:9527/payment/lb?uname=abc">http://localhost:9527/payment/lb?uname=abc</a> - 正常反问</li>
</ul>
</li>
</ul>
<h2 id="4-Config-分布式配置中心"><a href="#4-Config-分布式配置中心" class="headerlink" title="4 Config 分布式配置中心"></a>4 Config 分布式配置中心</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><h4 id="分布式系统面临的配置问题"><a href="#分布式系统面临的配置问题" class="headerlink" title="分布式系统面临的配置问题"></a>分布式系统面临的配置问题</h4><ul>
<li>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。</li>
<li>SpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理.……</li>
</ul>
<h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/d5462e3b8c3a063561f5f8fc7fde327e.png" alt></p>
<p>SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。</p>
<h4 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h4><ul>
<li>SpringCloud Config分为服务端和客户端两部分。</li>
</ul>
<ul>
<li>服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口。</li>
</ul>
<ul>
<li>客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。</li>
</ul>
<h4 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h4><ul>
<li><p>集中管理配置文件</p>
</li>
<li><p>不同环境不同配置，动态化的配置更新，分环境部署比如</p>
<p>dev/test/prod/beta/release</p>
</li>
<li><p>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</p>
</li>
<li><p>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置</p>
</li>
<li><p>将配置信息以REST接口的形式暴露 - post/crul访问刷新即可…</p>
</li>
</ul>
<h4 id="与GitHub整合配置"><a href="#与GitHub整合配置" class="headerlink" title="与GitHub整合配置"></a><strong>与GitHub整合配置</strong></h4><p>由于SpringCloud Config默认使用Git来存储配置文件(也有其它方式,比如支持SVN和本地文件)，但最推荐的还是Git，而且使用的是http/https访问的形式。</p>
<h4 id="官网"><a href="#官网" class="headerlink" title="官网"></a><strong>官网</strong></h4><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/</a></p>
<h3 id="4-2-Config配置总控中心搭建"><a href="#4-2-Config配置总控中心搭建" class="headerlink" title="4.2 Config配置总控中心搭建"></a>4.2 Config配置总控中心搭建</h3><h4 id="1-初始化-Github-仓库"><a href="#1-初始化-Github-仓库" class="headerlink" title="1 初始化 Github 仓库"></a>1 初始化 Github 仓库</h4><p>用你自己的账号在GitHub上新建一个名为springcloud-config的新Repository。</p>
<p>由上一步获得刚新建的git地址 - <code>git@github.com:abc/springcloud-config.git</code>。</p>
<p>本地硬盘目录上新建git仓库并clone。</p>
<ul>
<li>工作目录为D:\SpringCloud2021</li>
<li><code>git clone git@github.com:abc/springcloud-config.git</code></li>
</ul>
<p>此时在工作目录会创建名为springcloud-config的文件夹。</p>
<p>在springcloud-config的文件夹种创建三个配置文件（为本次教学使用的）,随后git add .，git commit -m “sth”等一系列上传操作上传到springcloud-config的新Repository。</p>
<ul>
<li><p>config-dev.yml</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">config:</span>
  <span class="hljs-attr">info:</span> <span class="hljs-string">&quot;master branch,springcloud-config/config-dev.yml version=7&quot;</span></code></pre></div>
</li>
<li><p>config-prod.yml</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">config:</span>
  <span class="hljs-attr">info:</span> <span class="hljs-string">&quot;master branch,springcloud-config/config-prod.yml version=1&quot;</span></code></pre></div>
</li>
<li><p>config-test.yml</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">config:</span>
  <span class="hljs-attr">info:</span> <span class="hljs-string">&quot;master branch,springcloud-config/config-test.yml version=1&quot;</span></code></pre></div>

</li>
</ul>
<h4 id="2-建立配置中心模块"><a href="#2-建立配置中心模块" class="headerlink" title="2 建立配置中心模块"></a>2 建立配置中心模块</h4><p>新建Module模块cloud-config-center-3344，它即为Cloud的配置中心模块CloudConfig Center</p>
<ul>
<li><p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>LearnCloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lun.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-config-center-3344<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--添加消息总线RabbitMQ支持--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>
</li>
<li><p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">3344</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span>  <span class="hljs-string">cloud-config-center</span> <span class="hljs-comment">#注册进Eureka服务器的微服务名</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">config:</span>
      <span class="hljs-attr">server:</span>
        <span class="hljs-attr">git:</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">git@github.com:pncalbl/springcloud-config.git</span> <span class="hljs-comment">#GitHub上面的git仓库名字</span>
          <span class="hljs-comment">####搜索目录</span>
          <span class="hljs-attr">search-paths:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">springcloud-config</span>
      <span class="hljs-comment">####读取分支</span>
      <span class="hljs-attr">label:</span> <span class="hljs-string">master</span>

<span class="hljs-comment">#服务注册到eureka地址</span>
<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span></code></pre></div>
</li>
<li><p>主启动类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableConfigServer</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigCenterMain3344</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
            SpringApplication.run(ConfigCenterMain3344.class, args);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>windows下修改hosts文件，增加映射</p>
<div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1 config-3344.com</code></pre></div>
</li>
<li><p>测试通过Config微服务是否可以从GitHub上获取配置内容</p>
<ul>
<li><p>启动ConfigCenterMain3344</p>
</li>
<li><p>浏览器防问 - <a href="http://config-3344.com:3344/master/config-dev.yml">http://config-3344.com:3344/master/config-dev.yml</a></p>
</li>
<li><p>页面返回结果：</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">config:</span>
  <span class="hljs-attr">info:</span> <span class="hljs-string">&quot;master branch,springcloud-config/config-dev.yml version=7&quot;</span></code></pre></div>
</li>
</ul>
</li>
<li><p>配置读取规则</p>
<ul>
<li>官方文档</li>
<li>/{label}/{application}-{profile}.yml（推荐）<ul>
<li>master分支<ul>
<li><a href="http://config-3344.com:3344/master/config-dev.yml">http://config-3344.com:3344/master/config-dev.yml</a></li>
<li><a href="http://config-3344.com:3344/master/config-test.yml">http://config-3344.com:3344/master/config-test.yml</a></li>
<li><a href="http://config-3344.com:3344/master/config-prod.yml">http://config-3344.com:3344/master/config-prod.yml</a></li>
</ul>
</li>
<li>dev分支<ul>
<li><a href="http://config-3344.com:3344/dev/config-dev.yml">http://config-3344.com:3344/dev/config-dev.yml</a></li>
<li><a href="http://config-3344.com:3344/dev/config-test.yml">http://config-3344.com:3344/dev/config-test.yml</a></li>
<li><a href="http://config-3344.com:3344/dev/config-prod.yml">http://config-3344.com:3344/dev/config-prod.yml</a></li>
</ul>
</li>
</ul>
</li>
<li>/{application}-{profile}.yml<ul>
<li><a href="http://config-3344.com:3344/config-dev.yml">http://config-3344.com:3344/config-dev.yml</a></li>
<li><a href="http://config-3344.com:3344/config-test.yml">http://config-3344.com:3344/config-test.yml</a></li>
<li><a href="http://config-3344.com:3344/config-prod.yml">http://config-3344.com:3344/config-prod.yml</a></li>
<li><a href="http://config-3344.com:3344/config-xxxx.yml(不存在的配置)">http://config-3344.com:3344/config-xxxx.yml(不存在的配置)</a></li>
</ul>
</li>
<li>/{application}/{profile}[/{label}]<ul>
<li><a href="http://config-3344.com:3344/config/dev/master">http://config-3344.com:3344/config/dev/master</a></li>
<li><a href="http://config-3344.com:3344/config/test/master">http://config-3344.com:3344/config/test/master</a></li>
<li><a href="http://config-3344.com:3344/config/test/dev">http://config-3344.com:3344/config/test/dev</a></li>
</ul>
</li>
<li>重要配置细节总结<ul>
<li>/{name}-{profiles}.yml</li>
<li>/{label}-{name}-{profiles}.yml</li>
<li>label：分支(branch)</li>
<li>name：服务名</li>
<li>profiles：环境(dev/test/prod)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>成功实现了用SpringCloud Config通过GitHub获取配置信息</p>
<h3 id="4-3-Config客户端配置与测试"><a href="#4-3-Config客户端配置与测试" class="headerlink" title="4.3 Config客户端配置与测试"></a>4.3 Config客户端配置与测试</h3><p><strong>新建cloud-config-client-3355</strong></p>
<ul>
<li><p><strong>POM</strong></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>LearnCloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lun.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-config-client-3355<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--添加消息总线RabbitMQ支持--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>


<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>
</li>
<li><p><strong>bootstrap.yml</strong></p>
<ul>
<li><p>applicaiton.yml是用户级的资源配置项</p>
</li>
<li><p>boostrap.yml是系统级的，优先级更加高</p>
</li>
</ul>
</li>
</ul>
<div class="code-wrapper"><pre><code>-   Spring Cloud会创建一个Bootstrap Context，作为Spring应用的Application Context的父上下文。


-   初始化的时候，BootstrapContext负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。


-   Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离。


-   要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml。

<pre><code class="hljs yml">    <span class="hljs-attr">server:</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">3355</span>
    
    <span class="hljs-attr">spring:</span>
      <span class="hljs-attr">application:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span>
      <span class="hljs-attr">cloud:</span>
        <span class="hljs-comment">#Config客户端配置</span>
        <span class="hljs-attr">config:</span>
          <span class="hljs-attr">label:</span> <span class="hljs-string">master</span> <span class="hljs-comment">#分支名称</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">config</span> <span class="hljs-comment">#配置文件名称</span>
          <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:3344</span> <span class="hljs-comment">#配置中心地址k</span>


<span class="hljs-string">​</span>    
<span class="hljs-string">​</span>    <span class="hljs-comment">#服务注册到eureka地址</span>
<span class="hljs-string">​</span>    <span class="hljs-attr">eureka:</span>
<span class="hljs-string">​</span>      <span class="hljs-attr">client:</span>
<span class="hljs-string">​</span>        <span class="hljs-attr">service-url:</span>
<span class="hljs-string">​</span>          <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span>
<span class="hljs-string">​</span>    <span class="hljs-string">```</span>

<span class="hljs-bullet">-</span>   <span class="hljs-string">**修改config-dev.yml配置并提交到GitHub中，比如加个变量age或者版本号version**</span>

<span class="hljs-bullet">-</span>   <span class="hljs-string">**主启动**</span>

    <span class="hljs-string">```java</span>
    <span class="hljs-string">import</span> <span class="hljs-string">org.springframework.boot.SpringApplication;</span>
    <span class="hljs-string">import</span> <span class="hljs-string">org.springframework.boot.autoconfigure.SpringBootApplication;</span>
    <span class="hljs-string">import</span> <span class="hljs-string">org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span>
    
    
    <span class="hljs-string">@EnableEurekaClient</span>
    <span class="hljs-string">@SpringBootApplication</span>
    <span class="hljs-string">public</span> <span class="hljs-string">class</span> <span class="hljs-string">ConfigClientMain3355</span>
    &#123;
        <span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">void</span> <span class="hljs-string">main(String</span>[] <span class="hljs-string">args)</span> &#123;
                <span class="hljs-string">SpringApplication.run(ConfigClientMain3355.class</span>, <span class="hljs-string">args);</span>
        &#125;
    &#125;</code></pre></div></code></pre><ul>
<li><p><strong>业务类</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;
<span class="hljs-keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;


<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RefreshScope</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigClientController</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String configInfo;

    <span class="hljs-meta">@GetMapping(&quot;/configInfo&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getConfigInfo</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> configInfo;
    &#125;
&#125;</code></pre></div>
</li>
<li><p><strong>测试</strong></p>
<ul>
<li><p>启动Config配置中心3344微服务并自测</p>
<ul>
<li><p><a href="http://config-3344.com:3344/master/config-prod.yml">http://config-3344.com:3344/master/config-prod.yml</a></p>
</li>
<li><p><a href="http://config-3344.com:3344/master/config-dev.yml">http://config-3344.com:3344/master/config-dev.yml</a></p>
</li>
</ul>
</li>
<li><p>启动3355作为Client准备访问</p>
<ul>
<li><a href="http://localhost:3355/configlnfo">http://localhost:3355/configlnfo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>成功实现了客户端3355访问SpringCloud Config3344通过GitHub获取配置信息可问题随时而来</strong></p>
<p>分布式配置的动态刷新问题</p>
<ul>
<li>Linux运维修改GitHub上的配置文件内容做调整</li>
<li>刷新3344，发现ConfigServer配置中心立刻响应</li>
<li>刷新3355，发现ConfigClient客户端没有任何响应</li>
<li>3355没有变化除非自己重启或者重新加载</li>
<li>难到每次运维修改配置文件，客户端都需要重启??噩梦</li>
</ul>
<h3 id="4-3-Config动态刷新之手动版"><a href="#4-3-Config动态刷新之手动版" class="headerlink" title="4.3 Config动态刷新之手动版"></a>4.3 Config动态刷新之手动版</h3><p>避免每次更新配置都要重启客户端微服务3355</p>
<p><strong>动态刷新步骤</strong>：</p>
<p>修改3355模块</p>
<ul>
<li><p>POM引入actuator监控</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>
</li>
<li><p>修改YML，添加暴露监控端口配置：</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># 暴露监控端点</span>
<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span></code></pre></div>
</li>
<li><p>@RefreshScope业务类Controller修改</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;
...

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RefreshScope</span><span class="hljs-comment">//&lt;-----</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigClientController</span></span>
<span class="hljs-class"></span>&#123;
...
&#125;</code></pre></div>
</li>
<li><p>测试</p>
<p>此时修改github配置文件内容 -&gt; 访问3344 -&gt; 访问3355</p>
<p><a href="http://localhost:3355/configInfo">http://localhost:3355/configInfo</a></p>
<p>3355改变没有??? <strong>没有</strong>，还需一步</p>
<p>How</p>
<p>需要运维人员发送Post请求刷新3355</p>
<div class="code-wrapper"><pre><code class="hljs shell">curl -X POST &quot;http://localhost:3355/actuator/refresh&quot;</code></pre></div>
</li>
<li><p>再次测试</p>
<p><a href="http://localhost:3355/configInfo">http://localhost:3355/configInfo</a></p>
<p>3355改变没有??? <strong>改了</strong>。</p>
<p>成功实现了客户端3355刷新到最新配置内容，避免了服务重启</p>
<p>想想还有什么问题?</p>
<ul>
<li>假如有多个微服务客户端3355/3366/3377</li>
<li>每个微服务都要执行—次post请求，手动刷新?</li>
<li>可否广播，一次通知，处处生效?</li>
<li>我们想大范围的自动刷新，求方法</li>
</ul>
</li>
</ul>
<h2 id="5-Bus消息总线"><a href="#5-Bus消息总线" class="headerlink" title="5 Bus消息总线"></a>5 Bus消息总线</h2><h3 id="5-1-Bus消息总线是什么"><a href="#5-1-Bus消息总线是什么" class="headerlink" title="5.1 Bus消息总线是什么"></a>5.1 Bus消息总线是什么</h3><h4 id="上—讲解的加深和扩充"><a href="#上—讲解的加深和扩充" class="headerlink" title="上—讲解的加深和扩充"></a><strong>上—讲解的加深和扩充</strong></h4><p>一言以蔽之，分布式自动刷新配置功能。</p>
<p>Spring Cloud Bus配合Spring Cloud Config使用可以实现配置的动态刷新。</p>
<h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>Spring Cloud Bus 配合Spring Cloud Config 使用可以实现配置的动态刷新。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/458fd679c01274ca84f785e1f75c1336.png" alt></p>
<p>Spring Cloud Bus 是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息中间件的功能。Spring Clud Bus目前支持RabbitMQ和Kafka。</p>
<h4 id="能干嘛-1"><a href="#能干嘛-1" class="headerlink" title="能干嘛"></a><strong>能干嘛</strong></h4><p>Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/26c6ced30935219d4717814a446eb67a.png" alt></p>
<h4 id="为何被称为总线"><a href="#为何被称为总线" class="headerlink" title="为何被称为总线"></a><strong>为何被称为总线</strong></h4><ul>
<li><p>什么是总线</p>
<p>在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。</p>
</li>
<li><p>基本原理</p>
<p>ConfigClient 实例都监听MQ中同一个topic(默认是Spring Cloud Bus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。</p>
</li>
</ul>
<h3 id="5-2-Bus之RabbitMQ环境配置"><a href="#5-2-Bus之RabbitMQ环境配置" class="headerlink" title="5.2 Bus之RabbitMQ环境配置"></a>5.2 Bus之RabbitMQ环境配置</h3><ul>
<li>安装Erlang，下载地址：<a href="http://erlang.org/download/otp_win64_21.3.exe">http://erlang.org/download/otp_win64_21.3.exe</a></li>
</ul>
<ul>
<li>安装RabbitMQ，下载地址：<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-3.8.3.exe">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-3.8.3.exe</a></li>
</ul>
<ul>
<li>打开cmd进入RabbitMQ安装目录下的sbin目录，如：D:\devSoft\RabbitMQ Scrverk\rabbitmq_server-3.7.14\sbin</li>
</ul>
<ul>
<li>输入以下命令启动管理功能</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs shell">rabbitmq-plugins enable rabbitmq_management</code></pre></div>

<p>这样就可以添加可视化插件。</p>
<ul>
<li>访问地址查看是否安装成功：<a href="http://localhost:15672/">http://localhost:15672/</a></li>
<li>输入账号密码并登录：guest guest</li>
</ul>
<h3 id="5-3-Bus动态刷新全局广播的设计思想和选型"><a href="#5-3-Bus动态刷新全局广播的设计思想和选型" class="headerlink" title="5.3 Bus动态刷新全局广播的设计思想和选型"></a>5.3 Bus动态刷新全局广播的设计思想和选型</h3><p>必须先具备良好的RabbitMQ环境先</p>
<p>演示广播效果，增加复杂度，再以3355为模板再制作一个3366</p>
<h4 id="1-新建cloud-config-client-3366"><a href="#1-新建cloud-config-client-3366" class="headerlink" title="1 新建cloud-config-client-3366"></a>1 新建cloud-config-client-3366</h4><h4 id="2-POM"><a href="#2-POM" class="headerlink" title="2 POM"></a>2 POM</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>LearnCloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lun.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-config-client-3366<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--添加消息总线RabbitMQ支持--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<h4 id="3-YML"><a href="#3-YML" class="headerlink" title="3 YML"></a>3 YML</h4><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">3366</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-comment">#Config客户端配置</span>
    <span class="hljs-attr">config:</span>
      <span class="hljs-attr">label:</span> <span class="hljs-string">master</span> <span class="hljs-comment">#分支名称</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">config</span> <span class="hljs-comment">#配置文件名称</span>
      <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml</span>
      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:3344</span> <span class="hljs-comment">#配置中心地址</span>

<span class="hljs-comment">#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>

<span class="hljs-comment">#服务注册到eureka地址</span>
<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span>

<span class="hljs-comment"># 暴露监控端点</span>
<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span></code></pre></div>

<h4 id="4-主启动"><a href="#4-主启动" class="headerlink" title="4 主启动"></a>4 主启动</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;

<span class="hljs-meta">@EnableEurekaClient</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigCenterMain3344</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;
        SpringApplication.run(ConfigCenterMain3344.class,args);
    &#125;
&#125;</code></pre></div>

<h4 id="5-controller"><a href="#5-controller" class="headerlink" title="5 controller"></a>5 controller</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;
<span class="hljs-keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RefreshScope</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigClientController</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String serverPort;

    <span class="hljs-meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String configInfo;

    <span class="hljs-meta">@GetMapping(&quot;/configInfo&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">configInfo</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;serverPort: &quot;</span>+serverPort+<span class="hljs-string">&quot;\t\n\n configInfo: &quot;</span>+configInfo;
    &#125;

&#125;</code></pre></div>

<h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><ol>
<li><p>利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/3a0975f4bac7393fe406821531e9daef.png" alt></p>
</li>
<li><p>利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e2809f728b8eb3e776883e4f905b8712.png" alt></p>
</li>
<li><p>图二的架构显然更加适合，图—不适合的原因如下：</p>
<ul>
<li>打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。</li>
<li>破坏了微服务各节点的对等性。</li>
<li>有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。</li>
</ul>
</li>
</ol>
<h3 id="5-4-Bus动态刷新全局广播配置实现"><a href="#5-4-Bus动态刷新全局广播配置实现" class="headerlink" title="5.4 Bus动态刷新全局广播配置实现"></a>5.4 Bus动态刷新全局广播配置实现</h3><h4 id="1-服务端配置"><a href="#1-服务端配置" class="headerlink" title="1 服务端配置"></a>1 服务端配置</h4><p><strong>给cloud-config-center-3344配置中心服务端添加消息总线支持</strong></p>
<h5 id="1-1-POM"><a href="#1-1-POM" class="headerlink" title="1.1 POM"></a>1.1 POM</h5><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加消息总线RabbitNQ支持--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h5 id="1-2-YML"><a href="#1-2-YML" class="headerlink" title="1.2 YML"></a>1.2 YML</h5><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">3344</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span>  <span class="hljs-string">cloud-config-center</span> <span class="hljs-comment">#注册进Eureka服务器的微服务名</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">config:</span>
      <span class="hljs-attr">server:</span>
        <span class="hljs-attr">git:</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">git@github.com:zzyybs/springcloud-config.git</span> <span class="hljs-comment">#GitHub上面的git仓库名字</span>
        <span class="hljs-comment">####搜索目录</span>
          <span class="hljs-attr">search-paths:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">springcloud-config</span>
      <span class="hljs-comment">####读取分支</span>
      <span class="hljs-attr">label:</span> <span class="hljs-string">master</span>
<span class="hljs-comment">#rabbitmq相关配置&lt;--------------------------</span>
<span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>

<span class="hljs-comment">#服务注册到eureka地址</span>
<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span>

<span class="hljs-comment">##rabbitmq相关配置,暴露bus刷新配置的端点&lt;--------------------------</span>
<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span> <span class="hljs-comment">#暴露bus刷新配置的端点</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">eposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;bus-refresh&#x27;</span></code></pre></div>

<h4 id="2-客户端配置1"><a href="#2-客户端配置1" class="headerlink" title="2 客户端配置1"></a>2 客户端配置1</h4><p><strong>给cloud-config-client-3355客户端添加消息总线支持</strong></p>
<h5 id="2-1-POM"><a href="#2-1-POM" class="headerlink" title="2.1 POM"></a>2.1 POM</h5><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加消息总线RabbitNQ支持--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org-springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h5 id="2-2-YML"><a href="#2-2-YML" class="headerlink" title="2.2 YML"></a>2.2 YML</h5><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">3355</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-comment">#Config客户端配置</span>
    <span class="hljs-attr">config:</span>
      <span class="hljs-attr">label:</span> <span class="hljs-string">master</span> <span class="hljs-comment">#分支名称</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">config</span> <span class="hljs-comment">#配置文件名称</span>
      <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml</span>
      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:3344</span> <span class="hljs-comment">#配置中心地址k</span>

<span class="hljs-comment">#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口&lt;----------------------</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>

<span class="hljs-comment">#服务注册到eureka地址</span>
<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span>

<span class="hljs-comment"># 暴露监控端点</span>
<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span></code></pre></div>

<h4 id="3-客户端配置2"><a href="#3-客户端配置2" class="headerlink" title="3 客户端配置2"></a>3 客户端配置2</h4><p><strong>给cloud-config-client-3366客户端添加消息总线支持</strong></p>
<h5 id="3-1-POM"><a href="#3-1-POM" class="headerlink" title="3.1 POM"></a>3.1 POM</h5><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加消息总线RabbitNQ支持--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org-springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<h5 id="3-2-YML"><a href="#3-2-YML" class="headerlink" title="3.2 YML"></a>3.2 YML</h5><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">3366</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-comment">#Config客户端配置</span>
    <span class="hljs-attr">config:</span>
      <span class="hljs-attr">label:</span> <span class="hljs-string">master</span> <span class="hljs-comment">#分支名称</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">config</span> <span class="hljs-comment">#配置文件名称</span>
      <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml</span>
      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:3344</span> <span class="hljs-comment">#配置中心地址</span>

<span class="hljs-comment">#rabbitmq相关配置 15672是Web管理界面的端口；5672是MQ访问的端口&lt;-----------------------</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>

<span class="hljs-comment">#服务注册到eureka地址</span>
<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span>

<span class="hljs-comment"># 暴露监控端点</span>
<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span></code></pre></div>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul>
<li>启动<ul>
<li>EurekaMain7001</li>
<li>ConfigcenterMain3344</li>
<li>ConfigclientMain3355</li>
<li>ConfigclicntMain3366</li>
</ul>
</li>
<li>运维工程师<ul>
<li>修改Github上配置文件内容，增加版本号</li>
<li>发送POST请求<ul>
<li>curl -X POST “<a href="http://localhost:3344/actuator/bus-refresh&quot;">http://localhost:3344/actuator/bus-refresh&quot;</a></li>
<li>—次发送，处处生效</li>
</ul>
</li>
</ul>
</li>
<li>配置中心<ul>
<li><a href="http://config-3344.com:3344/config-dev.yml">http://config-3344.com:3344/config-dev.yml</a><br>客户端</li>
<li><a href="http://localhost:3355/configlnfo">http://localhost:3355/configlnfo</a></li>
<li><a href="http://localhost:3366/configInfo">http://localhost:3366/configInfo</a></li>
<li>获取配置信息，发现都已经刷新了</li>
</ul>
</li>
</ul>
<p><strong>—次修改，广播通知，处处生效</strong></p>
<h3 id="5-5-Bus动态刷新定点通知"><a href="#5-5-Bus动态刷新定点通知" class="headerlink" title="5.5 Bus动态刷新定点通知"></a>5.5 Bus动态刷新定点通知</h3><p>不想全部通知，只想定点通知</p>
<ul>
<li>只通知3355</li>
<li>不通知3366</li>
</ul>
<p>简单一句话 - <strong>指定具体某一个实例生效而不是全部</strong></p>
<ul>
<li>公式：<a href="http://localhost:3344/actuator/bus-refresh/{destination}">http://localhost:3344/actuator/bus-refresh/{destination}</a></li>
<li>/bus/refresh请求不再发送到具体的服务实例上，而是发给config server通过destination参数类指定需要更新配置的服务或实例</li>
</ul>
<p>案例</p>
<ul>
<li>我们这里以刷新运行在3355端口上的config-client（配置文件中设定的应用名称）为例，只通知3355，不通知3366</li>
<li>curl -X POST “<a href="http://localhost:3344/actuator/bus-refresh/config-client:3355">http://localhost:3344/actuator/bus-refresh/config-client:3355</a></li>
</ul>
<p>通知总结</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/ccd5fcc8293edec24d7e889e189d0bfe.png" alt></p>
<h2 id="6-Stream"><a href="#6-Stream" class="headerlink" title="6 Stream"></a>6 Stream</h2><h3 id="6-1-Stream为什么被引入"><a href="#6-1-Stream为什么被引入" class="headerlink" title="6.1 Stream为什么被引入"></a>6.1 Stream为什么被引入</h3><p>常见MQ(消息中间件)：</p>
<ul>
<li>ActiveMQ</li>
<li>RabbitMQ</li>
<li>RocketMQ</li>
<li>Kafka</li>
</ul>
<p>有没有一种新的技术诞生，让我们不再关注具体MQ的细节，我们只需要用一种适配绑定的方式，自动的给我们在各种MQ内切换。（类似于Hibernate）</p>
<p>Cloud Stream是什么？屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型。</p>
<h3 id="6-2-Stream是什么及Binder介绍"><a href="#6-2-Stream是什么及Binder介绍" class="headerlink" title="6.2 Stream是什么及Binder介绍"></a>6.2 Stream是什么及Binder介绍</h3><p><a href="https://spring.io/projects/spring-cloud-stream#overview">官方文档1</a></p>
<p><a href="https://cloud.spring.io/spring-tloud-static/spring-cloud-stream/3.0.1.RELEASE/reference/html/Spring">官方文档2</a></p>
<p><a href="https://m.wang1314.com/doc/webapp/topic/20971999.html">Cloud Stream中文指导手册</a></p>
<p><strong>什么是Spring Cloud Stream？</strong></p>
<p>官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。</p>
<p>应用程序通过inputs或者 outputs 来与Spring Cloud Stream中binder对象交互。</p>
<p>通过我们配置来binding(绑定)，而Spring Cloud Stream 的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。</p>
<p>通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。<br>Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。</p>
<p>目前仅支持RabbitMQ、 Kafka。</p>
<h3 id="6-3-Stream的设计思想"><a href="#6-3-Stream的设计思想" class="headerlink" title="6.3 Stream的设计思想"></a>6.3 Stream的设计思想</h3><h4 id="1-标准MQ"><a href="#1-标准MQ" class="headerlink" title="1 标准MQ"></a>1 <strong>标准MQ</strong></h4><p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/dd57e502418ecdae99f29991abe8bb02.png" alt></p>
<ul>
<li>生产者/消费者之间靠消息媒介传递信息内容</li>
<li>消息必须走特定的通道 - 消息通道 Message Channel</li>
<li>消息通道里的消息如何被消费呢，谁负责收发处理 - 消息通道MessageChannel的子接口SubscribableChannel，由MessageHandler消息处理器所订阅。</li>
</ul>
<h4 id="2-为什么用Cloud-Stream？"><a href="#2-为什么用Cloud-Stream？" class="headerlink" title="2 为什么用Cloud Stream？"></a>2 <strong>为什么用Cloud Stream？</strong></h4><p>比方说我们用到了RabbitMQ和Kafka，由于这两个消息中间件的架构上的不同，像RabbitMQ有exchange，kafka有Topic和Partitions分区。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/5587b05def1c26b8c9d9874c78f80b28.png" alt></p>
<p>这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，后面的业务需求，我想往另外一种消息队列进行迁移，这时候无疑就是一个灾难性的，一大堆东西都要重新推倒重新做，因为它跟我们的系统耦合了，这时候Spring Cloud Stream给我们提供了—种解耦合的方式。</p>
<h4 id="3-Stream凭什么可以统一底层差异？"><a href="#3-Stream凭什么可以统一底层差异？" class="headerlink" title="3 Stream凭什么可以统一底层差异？"></a>3 <strong>Stream凭什么可以统一底层差异？</strong></h4><p>在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。</p>
<h4 id="4-通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。"><a href="#4-通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。" class="headerlink" title="4 通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。"></a>4 <strong>通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离</strong>。</h4><p><strong>Binder</strong>：</p>
<ul>
<li>INPUT对应于消费者</li>
<li>OUTPUT对应于生产者</li>
</ul>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/96256569e677453570b55209c26e0b8c.png" alt></p>
<h4 id="5-Stream中的消息通信方式遵循了发布-订阅模式"><a href="#5-Stream中的消息通信方式遵循了发布-订阅模式" class="headerlink" title="5 Stream中的消息通信方式遵循了发布-订阅模式"></a>5 <strong>Stream中的消息通信方式遵循了发布-订阅模式</strong></h4><p>Topic主题进行广播</p>
<ul>
<li>在RabbitMQ就是Exchange</li>
<li>在Kakfa中就是Topic</li>
</ul>
<h3 id="6-4-Stream编码常用注解简介"><a href="#6-4-Stream编码常用注解简介" class="headerlink" title="6.4 Stream编码常用注解简介"></a>6.4 Stream编码常用注解简介</h3><h4 id="1-Spring-Cloud-Stream标准流程套路"><a href="#1-Spring-Cloud-Stream标准流程套路" class="headerlink" title="1 Spring Cloud Stream标准流程套路"></a>1 <strong>Spring Cloud Stream标准流程套路</strong></h4><p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/077a3b34aec6eed91a7019a9d5ca4e3c.png" alt></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/1ca02dd31581d92a7a610bcd137f6848.png" alt></p>
<ul>
<li>Binder - 很方便的连接中间件，屏蔽差异。</li>
<li>Channel - 通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置。</li>
<li>Source和Sink - 简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入。</li>
</ul>
<h4 id="2-编码API和常用注解"><a href="#2-编码API和常用注解" class="headerlink" title="2 编码API和常用注解"></a>2 <strong>编码API和常用注解</strong></h4><table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Middleware</td>
<td>中间件，目前只支持RabbitMQ和Kafka</td>
</tr>
<tr>
<td>Binder</td>
<td>Binder是应用与消息中间件之间的封装，目前实行了Kafka和RabbitMQ的Binder，通过Binder可以很方便的连接中间件，可以动态的改变消息类型(对应于Kafka的topic,RabbitMQ的exchange)，这些都可以通过配置文件来实现</td>
</tr>
<tr>
<td>@Input</td>
<td>注解标识输入通道，通过该输乎通道接收到的消息进入应用程序</td>
</tr>
<tr>
<td>@Output</td>
<td>注解标识输出通道，发布的消息将通过该通道离开应用程序</td>
</tr>
<tr>
<td>@StreamListener</td>
<td>监听队列，用于消费者的队列的消息接收</td>
</tr>
<tr>
<td>@EnableBinding</td>
<td>指信道channel和exchange绑定在一起</td>
</tr>
</tbody></table>
<h4 id="3-案例说明"><a href="#3-案例说明" class="headerlink" title="3 案例说明"></a>3 案例说明</h4><p>准备RabbitMQ环境</p>
<p>工程中新建三个子模块</p>
<ul>
<li>cloud-stream-rabbitmq-provider8801，作为生产者进行发消息模块</li>
<li>cloud-stream-rabbitmq-consumer8802，作为消息接收模块</li>
<li>cloud-stream-rabbitmq-consumer8803，作为消息接收模块</li>
</ul>
<h3 id="6-5-Stream消息驱动之生产者"><a href="#6-5-Stream消息驱动之生产者" class="headerlink" title="6.5 Stream消息驱动之生产者"></a>6.5 Stream消息驱动之生产者</h3><ul>
<li><p>新建Module：cloud-stream-rabbitmq-provider8801</p>
</li>
<li><p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>LearnCloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lun.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-stream-rabbitmq-provider8801<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--基础配置--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>
</li>
<li><p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8801</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-stream-provider</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">stream:</span>
      <span class="hljs-attr">binders:</span> <span class="hljs-comment"># 在此处配置要绑定的rabbitmq的服务信息；</span>
        <span class="hljs-attr">defaultRabbit:</span> <span class="hljs-comment"># 表示定义的名称，用于于binding整合</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">rabbit</span> <span class="hljs-comment"># 消息组件类型</span>
          <span class="hljs-attr">environment:</span> <span class="hljs-comment"># 设置rabbitmq的相关的环境配置</span>
            <span class="hljs-attr">spring:</span>
              <span class="hljs-attr">rabbitmq:</span>
                <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
                <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>
                <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>
                <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>
      <span class="hljs-attr">bindings:</span> <span class="hljs-comment"># 服务的整合处理</span>
        <span class="hljs-attr">output:</span> <span class="hljs-comment"># 这个名字是一个通道的名称</span>
          <span class="hljs-attr">destination:</span> <span class="hljs-string">studyExchange</span> <span class="hljs-comment"># 表示要使用的Exchange名称定义</span>
          <span class="hljs-attr">content-type:</span> <span class="hljs-string">application/json</span> <span class="hljs-comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span>
          <span class="hljs-attr">binder:</span> <span class="hljs-string">defaultRabbit</span> <span class="hljs-comment"># 设置要绑定的消息服务的具体设置</span>

<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span> <span class="hljs-comment"># 客户端进行Eureka注册的配置</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span>
  <span class="hljs-attr">instance:</span>
    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 设置心跳的时间间隔（默认是30秒）</span>
    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 如果现在超过了5秒的间隔（默认是90秒）</span>
    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">send-8801.com</span>  <span class="hljs-comment"># 在信息列表时显示主机名称</span>
    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>     <span class="hljs-comment"># 访问的路径变为IP地址</span></code></pre></div>
</li>
<li><p>主启动类StreamMQMain8801</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMQMain8801</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(StreamMQMain8801.class,args);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>业务类</p>
<ol>
<li><p>发送消息接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMessageProvider</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>
</li>
<li><p>发送消息接口实现类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.lun.springcloud.service.IMessageProvider;
<span class="hljs-keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;
<span class="hljs-keyword">import</span> org.springframework.cloud.stream.messaging.Source;
<span class="hljs-keyword">import</span> org.springframework.integration.support.MessageBuilder;
<span class="hljs-keyword">import</span> org.springframework.messaging.MessageChannel;

<span class="hljs-keyword">import</span> javax.annotation.Resource;
<span class="hljs-keyword">import</span> java.util.UUID;


<span class="hljs-meta">@EnableBinding(Source.class)</span> <span class="hljs-comment">//定义消息的推送管道</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProviderImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IMessageProvider</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> MessageChannel output; <span class="hljs-comment">// 消息发送管道</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        String serial = UUID.randomUUID().toString();
        output.send(MessageBuilder.withPayload(serial).build());
        System.out.println(<span class="hljs-string">&quot;*****serial: &quot;</span>+serial);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;</code></pre></div>
</li>
<li><p>Controller</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.lun.springcloud.service.IMessageProvider;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-keyword">import</span> javax.annotation.Resource;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendMessageController</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> IMessageProvider messageProvider;

    <span class="hljs-meta">@GetMapping(value = &quot;/sendMessage&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> messageProvider.send();
    &#125;

&#125;</code></pre></div>
</li>
</ol>
</li>
<li><p>测试</p>
<ul>
<li><p>启动 7001eureka</p>
</li>
<li><p>启动 RabpitMq</p>
<ul>
<li>rabbitmq-plugins enable rabbitmq_management</li>
<li><a href="http://localhost:15672/">http://localhost:15672/</a></li>
</ul>
</li>
<li><p>启动 8801</p>
</li>
<li><p>访问 - <a href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a></p>
<ul>
<li>后台将打印字符串serial: UUID</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-6-Stream消息驱动之消费者"><a href="#6-6-Stream消息驱动之消费者" class="headerlink" title="6.6 Stream消息驱动之消费者"></a>6.6 Stream消息驱动之消费者</h3><ul>
<li><p>新建Module：cloud-stream-rabbitmq-consumer8802</p>
</li>
<li><p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>LearnCloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lun.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-stream-rabbitmq-consumer8802<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--基础配置--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>
</li>
<li><p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8802</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-stream-consumer</span>
  <span class="hljs-attr">cloud:</span>
      <span class="hljs-attr">stream:</span>
        <span class="hljs-attr">binders:</span> <span class="hljs-comment"># 在此处配置要绑定的rabbitmq的服务信息；</span>
          <span class="hljs-attr">defaultRabbit:</span> <span class="hljs-comment"># 表示定义的名称，用于于binding整合</span>
            <span class="hljs-attr">type:</span> <span class="hljs-string">rabbit</span> <span class="hljs-comment"># 消息组件类型</span>
            <span class="hljs-attr">environment:</span> <span class="hljs-comment"># 设置rabbitmq的相关的环境配置</span>
              <span class="hljs-attr">spring:</span>
                <span class="hljs-attr">rabbitmq:</span>
                  <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
                  <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>
                  <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>
                  <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>
        <span class="hljs-attr">bindings:</span> <span class="hljs-comment"># 服务的整合处理</span>
          <span class="hljs-attr">input:</span> <span class="hljs-comment"># 这个名字是一个通道的名称</span>
            <span class="hljs-attr">destination:</span> <span class="hljs-string">studyExchange</span> <span class="hljs-comment"># 表示要使用的Exchange名称定义</span>
            <span class="hljs-attr">content-type:</span> <span class="hljs-string">application/json</span> <span class="hljs-comment"># 设置消息类型，本次为对象json，如果是文本则设置“text/plain”</span>
            <span class="hljs-attr">binder:</span> <span class="hljs-string">defaultRabbit</span> <span class="hljs-comment"># 设置要绑定的消息服务的具体设置</span>

<span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span> <span class="hljs-comment"># 客户端进行Eureka注册的配置</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka</span>
  <span class="hljs-attr">instance:</span>
    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 设置心跳的时间间隔（默认是30秒）</span>
    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 如果现在超过了5秒的间隔（默认是90秒）</span>
    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">receive-8802.com</span>  <span class="hljs-comment"># 在信息列表时显示主机名称</span>
    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>     <span class="hljs-comment"># 访问的路径变为IP地址</span></code></pre></div>
</li>
<li><p>主启动类StreamMQMain8802</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamMQMain8802</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(StreamMQMain8802.class,args);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>业务类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;
<span class="hljs-keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;
<span class="hljs-keyword">import</span> org.springframework.cloud.stream.annotation.StreamListener;
<span class="hljs-keyword">import</span> org.springframework.cloud.stream.messaging.Sink;
<span class="hljs-keyword">import</span> org.springframework.messaging.Message;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;


<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@EnableBinding(Sink.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReceiveMessageListenerController</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String serverPort;


    <span class="hljs-meta">@StreamListener(Sink.INPUT)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">input</span><span class="hljs-params">(Message&lt;String&gt; message)</span></span>
<span class="hljs-function">    </span>&#123;
        System.out.println(<span class="hljs-string">&quot;消费者1号,-----&gt;接受到的消息: &quot;</span>+message.getPayload()+<span class="hljs-string">&quot;\t  port: &quot;</span>+serverPort);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>测试</p>
<ul>
<li>启动EurekaMain7001</li>
<li>启动StreamMQMain8801</li>
<li>启动StreamMQMain8802</li>
<li>8801发送8802接收消息</li>
</ul>
</li>
</ul>
<h3 id="6-7-Stream之消息重复消费"><a href="#6-7-Stream之消息重复消费" class="headerlink" title="6.7 Stream之消息重复消费"></a>6.7 Stream之消息重复消费</h3><ul>
<li><p>依照8802，克隆出来一份运行8803 - cloud-stream-rabbitmq-consumer8803。</p>
</li>
<li><p>启动</p>
<ul>
<li>RabbitMQ</li>
<li>服务注册 - 8801</li>
<li>消息生产 - 8801</li>
<li>消息消费 - 8802</li>
<li>消息消费 - 8802</li>
</ul>
</li>
<li><p><strong>运行后有两个问题</strong></p>
<ul>
<li>有重复消费问题</li>
<li>消息持久化问题</li>
</ul>
</li>
<li><p><strong>消费</strong></p>
<ul>
<li><a href="http://localhost:8801/sendMessage">http://localhost:8801/sendMessage</a></li>
<li>目前是8802/8803同时都收到了，存在重复消费问题</li>
<li>如何解决：分组和持久化属性group（重要）</li>
</ul>
</li>
<li><p><strong>生产实际案例</strong></p>
<ul>
<li><p>比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。这时我们就可以<strong>使用Stream中的消息分组来解决</strong>。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/f61e83441af907a42e8886368bde59ff.png" alt></p>
</li>
<li><p>注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。不同组是可以全面消费的(重复消费)。</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-8-Stream之group解决消息重复消费"><a href="#6-8-Stream之group解决消息重复消费" class="headerlink" title="6.8 Stream之group解决消息重复消费"></a>6.8 Stream之group解决消息重复消费</h3><ul>
<li><p><strong>原理</strong></p>
<ul>
<li>微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次。</li>
<li><strong>不同的组</strong>是可以重复消费的，<strong>同一个组</strong>内会发生竞争关系，只有其中一个可以消费。</li>
<li><strong>8802/8803都变成不同组，group两个不同</strong></li>
<li>group: A_Group、B_Group</li>
</ul>
</li>
<li><p><strong>8802修改YML</strong></p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-stream-provider</span>
  <span class="hljs-attr">cloud:</span>
      <span class="hljs-attr">stream:</span>
        <span class="hljs-attr">binders:</span> <span class="hljs-comment"># 在此处配置要绑定的rabbitmq的服务信息；</span>
          <span class="hljs-attr">defaultRabbit:</span> <span class="hljs-comment"># 表示定义的名称，用于于binding整合</span>
            <span class="hljs-attr">type:</span> <span class="hljs-string">rabbit</span> <span class="hljs-comment"># 消息组件类型</span>
            <span class="hljs-attr">environment:</span> <span class="hljs-comment"># 设置rabbitmq的相关的环境配置</span>
              <span class="hljs-attr">spring:</span>
                <span class="hljs-attr">rabbitmq:</span>
                  <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
                  <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>
                  <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>
                  <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span>
        <span class="hljs-attr">bindings:</span> <span class="hljs-comment"># 服务的整合处理</span>
          <span class="hljs-attr">output:</span> <span class="hljs-comment"># 这个名字是一个通道的名称</span>
            <span class="hljs-attr">destination:</span> <span class="hljs-string">studyExchange</span> <span class="hljs-comment"># 表示要使用的Exchange名称定义</span>
            <span class="hljs-attr">content-type:</span> <span class="hljs-string">application/json</span> <span class="hljs-comment"># 设置消息类型，本次为json，文本则设置“text/plain”</span>
            <span class="hljs-attr">binder:</span> <span class="hljs-string">defaultRabbit</span> <span class="hljs-comment"># 设置要绑定的消息服务的具体设置</span>
            <span class="hljs-attr">group:</span> <span class="hljs-string">A_Group</span> <span class="hljs-comment">#&lt;----------------------------------------关键</span></code></pre></div>
</li>
<li><p>8803修改YML（与8802的类似位置 ）<code>group: B_Group</code></p>
<p>结论：<strong>还是重复消费</strong></p>
</li>
<li><p>8802/8803实现了轮询分组，每次只有一个消费者，8801模块的发的消息只能被8802或8803其中一个接收到，这样避免了重复消费。</p>
<p><strong>8802/8803都变成相同组，group两个相同</strong></p>
<p>group: A_Group</p>
<p>8802修改YML<code>group: A_Group</code></p>
<p>8803修改YML<code>group: A_Group</code></p>
<p>结论：同一个组的多个微服务实例，每次只会有一个拿到</p>
</li>
</ul>
<h3 id="6-9-Stream之消息持久化"><a href="#6-9-Stream之消息持久化" class="headerlink" title="6.9 Stream之消息持久化"></a>6.9 Stream之消息持久化</h3><p>通过上述，解决了重复消费问题，再看看持久化。</p>
<p>停止8802/8803并去除掉8802的分组，8803的分组没有去掉。group: A_Groupgroup: A_Group</p>
<p>8801先发送4条消息到RabbitMq。</p>
<p>先启动8802，无分组属性配置，后台没有打出来消息。</p>
<p>再启动8803，有分组属性配置，后台打出来了MQ上的消息。(消息持久化体现)</p>
<h2 id="7-Sleuth"><a href="#7-Sleuth" class="headerlink" title="7 Sleuth"></a>7 Sleuth</h2><p>服务追踪</p>
<h3 id="7-1-Sleuth是什么"><a href="#7-1-Sleuth是什么" class="headerlink" title="7.1 Sleuth是什么"></a>7.1 Sleuth是什么</h3><p><strong>为什么会出现这个技术？要解决哪些问题？</strong></p>
<p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/b40478e2b2c83d7181b9c71cdcae05ea.png" alt></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/f97d15b5686264d45b46f6f188e99873.png" alt></p>
<p><strong>是什么</strong></p>
<ul>
<li><a href="https://github.com/spring-cloud/spring-cloud-sleuth">https://github.com/spring-cloud/spring-cloud-sleuth</a></li>
<li>Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案</li>
<li>在分布式系统中提供追踪解决方案并且兼容支持了zipkin</li>
</ul>
<p><strong>解决</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/ca541262b26f809a0c25014feaa069d7.png" alt></p>
<blockquote>
<p>  sleuth<br>  英 [sluːθ] 美 [sluːθ]<br>  n. 侦探</p>
</blockquote>
<h3 id="7-2-Sleuth之zipkin搭建安装"><a href="#7-2-Sleuth之zipkin搭建安装" class="headerlink" title="7.2 Sleuth之zipkin搭建安装"></a>7.2 Sleuth之zipkin搭建安装</h3><p><strong>下载</strong></p>
<ul>
<li>SpringCloud从F版起已不需要自己构建Zipkin Server了，只需调用jar包即可</li>
<li><a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/</a></li>
<li>zipkin-server-2.12.9-exec.jar</li>
</ul>
<p><strong>运行jar</strong></p>
<div class="code-wrapper"><pre><code class="hljs java">java -jar zipkin-server-<span class="hljs-number">2.12</span><span class="hljs-number">.9</span>-exec.jar</code></pre></div>

<p><strong>运行控制台</strong></p>
<p><a href="http://localhost:9411/zipkin/">http://localhost:9411/zipkin/</a></p>
<p><strong>术语</strong></p>
<p>完整的调用链路</p>
<p>表示一请求链路，一条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/ec45d9d026fee8c83eaaf7bf8cb6893d.png" alt></p>
<p>—条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id关联起来。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/f75fcfd2146df03428b9c8c53d13c1f1.png" alt></p>
<p>整个链路的依赖关系如下：</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/c1d19c5e9724578ee9c8668903685fa4.png" alt></p>
<p>名词解释</p>
<ul>
<li>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识</li>
<li>span：表示调用链路来源，通俗的理解span就是一次请求信息</li>
</ul>
<h3 id="7-3-Sleuth链路监控展现"><a href="#7-3-Sleuth链路监控展现" class="headerlink" title="7.3 Sleuth链路监控展现"></a>7.3 Sleuth链路监控展现</h3><p>服务提供者</p>
<p>cloud-provider-payment8001</p>
<p><strong>POM</strong></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--包含了sleuth+zipkin--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p><strong>YML</strong></p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-payment-service</span>

  <span class="hljs-attr">zipkin:</span> <span class="hljs-comment">#&lt;-------------------------------------关键 </span>
      <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://localhost:9411</span>
  <span class="hljs-attr">sleuth:</span>
    <span class="hljs-attr">sampler:</span>
      <span class="hljs-comment">#采样率值介于 0 到 1 之间，1 则表示全部采集</span>
      <span class="hljs-attr">probability:</span> <span class="hljs-number">1</span></code></pre></div>

<p>业务类 PaymentController</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;
    
    ...
    
 	<span class="hljs-meta">@GetMapping(&quot;/payment/zipkin&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentZipkin</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi ,i&#x27;am paymentzipkin server fall back，welcome to here, O(∩_∩)O哈哈~&quot;</span>;
    &#125;    
&#125;</code></pre></div>

<p>服务消费者(调用方)</p>
<p>cloud-consumer-order80</p>
<p><strong>POM</strong></p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
    <span class="hljs-attr">application:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-order-service</span>
    <span class="hljs-attr">zipkin:</span>
      <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://localhost:9411</span>
    <span class="hljs-attr">sleuth:</span>
      <span class="hljs-attr">sampler:</span>
        <span class="hljs-attr">probability:</span> <span class="hljs-number">1</span></code></pre></div>

<p>业条类OrderController</p>
<div class="code-wrapper"><pre><code class="hljs java">    <span class="hljs-comment">// ====================&gt; zipkin+sleuth</span>
    <span class="hljs-meta">@GetMapping(&quot;/consumer/payment/zipkin&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentZipkin</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        String result = restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8001&quot;</span>+<span class="hljs-string">&quot;/payment/zipkin/&quot;</span>, String.class);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;</code></pre></div>

<p>依次启动eureka7001/8001/80 - 80调用8001几次测试下</p>
<p>打开浏览器访问: <a href="http://localhost:9411">http://localhost:9411</a></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/733ad2e18037059045ec80cb59d8d2a3.png" alt></p>
<h2 id="8-Cloud-Alibaba简介"><a href="#8-Cloud-Alibaba简介" class="headerlink" title="8 Cloud Alibaba简介"></a>8 Cloud Alibaba简介</h2><h3 id="8-1-为什么会出现SpringCloud-alibaba"><a href="#8-1-为什么会出现SpringCloud-alibaba" class="headerlink" title="8.1 为什么会出现SpringCloud alibaba"></a>8.1 为什么会出现SpringCloud alibaba</h3><p>Spring Cloud Netflix项目进入维护模式</p>
<p><a href="https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now">https://spring.io/blog/2018/12/12/spring-cloud-greenwich-rc1-available-now</a></p>
<p>什么是维护模式？</p>
<p>将模块置于维护模式，意味着Spring Cloud团队将不会再向模块添加新功能。</p>
<p>他们将修复block级别的 bug 以及安全问题，他们也会考虑并审查社区的小型pull request。</p>
<h3 id="8-2-SpringCloud-alibaba带来了什么"><a href="#8-2-SpringCloud-alibaba带来了什么" class="headerlink" title="8.2 SpringCloud alibaba带来了什么"></a>8.2 SpringCloud alibaba带来了什么</h3><h4 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a><strong>是什么</strong></h4><p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">官网 (github.com)</a></p>
<p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p>
<p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p>
<p>诞生：2018.10.31，Spring Cloud Alibaba 正式入驻了Spring Cloud官方孵化器，并在Maven 中央库发布了第一个版本。</p>
<h4 id="能干嘛-2"><a href="#能干嘛-2" class="headerlink" title="能干嘛"></a><strong>能干嘛</strong></h4><ul>
<li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li>
<li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li>
<li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li>
<li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li>
<li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li>
<li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
</ul>
<h4 id="去哪下"><a href="#去哪下" class="headerlink" title="去哪下"></a><strong>去哪下</strong></h4><p>如果需要使用已发布的版本，在 <code>dependencyManagement</code> 中添加如下配置。</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre></div>

<p>然后在 <code>dependencies</code> 中添加自己所需使用的依赖即可使用。</p>
<h4 id="怎么玩-1"><a href="#怎么玩-1" class="headerlink" title="怎么玩"></a><strong>怎么玩</strong></h4><ul>
<li><p><strong><a href="https://github.com/alibaba/Sentinel">Sentinel</a></strong>：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
</li>
<li><p><strong><a href="https://github.com/alibaba/Nacos">Nacos</a></strong>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p>
</li>
<li><p><strong><a href="https://rocketmq.apache.org/">RocketMQ</a></strong>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p>
</li>
<li><p><strong><a href="https://github.com/apache/dubbo">Dubbo</a></strong>：Apache Dubbo™ 是一款高性能 Java RPC 框架。</p>
</li>
<li><p><strong><a href="https://github.com/seata/seata">Seata</a></strong>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</p>
</li>
<li><p><strong><a href="https://www.aliyun.com/product/oss">Alibaba Cloud OSS</a></strong>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p>
</li>
<li><p><strong><a href="https://help.aliyun.com/document_detail/43136.html">Alibaba Cloud SchedulerX</a></strong>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</p>
</li>
<li><p><strong><a href="https://www.aliyun.com/product/sms">Alibaba Cloud SMS</a></strong>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</p>
</li>
</ul>
<h3 id="8-3-Spring-Cloud-Alibaba学习资料获取"><a href="#8-3-Spring-Cloud-Alibaba学习资料获取" class="headerlink" title="8.3 Spring Cloud Alibaba学习资料获取"></a>8.3 Spring Cloud Alibaba学习资料获取</h3><ul>
<li><p>官网</p>
<ul>
<li><a href="https://spring.io/projects/spring-cloud-alibaba#overview">https://spring.io/projects/spring-cloud-alibaba#overview</a></li>
</ul>
</li>
<li><p>英文</p>
<ul>
<li><a href="https://github.com/alibaba/spring-cloud-alibaba">https://github.com/alibaba/spring-cloud-alibaba</a></li>
<li><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html</a></li>
</ul>
</li>
<li><p>中文</p>
<ul>
<li><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></li>
</ul>
</li>
</ul>
<h2 id="9-Nacos"><a href="#9-Nacos" class="headerlink" title="9 Nacos"></a>9 Nacos</h2><h3 id="9-1-Nacos简介和下载"><a href="#9-1-Nacos简介和下载" class="headerlink" title="9.1 Nacos简介和下载"></a>9.1 Nacos简介和下载</h3><p><strong>为什么叫Nacos</strong></p>
<ul>
<li>前四个字母分别为Naming和Configuration的前两个字母，最后的s为Service。</li>
</ul>
<p><strong>是什么</strong></p>
<ul>
<li>一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li>
<li>Nacos: Dynamic Naming and Configuration Service</li>
<li>Nacos就是注册中心＋配置中心的组合 -&gt; <strong>Nacos = Eureka+Config+Bus</strong></li>
</ul>
<p><strong>能干嘛</strong></p>
<ul>
<li>替代Eureka做服务注册中心</li>
<li>替代Config做服务配置中心</li>
</ul>
<p><strong>去哪下</strong></p>
<ul>
<li><a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></li>
<li>[官网文档](<a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring">https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring</a> cloud alibaba nacos_discovery)</li>
</ul>
<p><strong>各中注册中心比较</strong></p>
<table>
<thead>
<tr>
<th>服务注册与发现框架</th>
<th>CAP模型</th>
<th>控制台管理</th>
<th>社区活跃度</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>AP</td>
<td>支持</td>
<td>低(2.x版本闭源)</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>CP</td>
<td>不支持</td>
<td>中</td>
</tr>
<tr>
<td>consul</td>
<td>CP</td>
<td>支持</td>
<td>高</td>
</tr>
<tr>
<td>Nacos</td>
<td>AP</td>
<td>支持</td>
<td>高</td>
</tr>
</tbody></table>
<p>据说Nacos在阿里巴巴内部有超过10万的实例运行，已经过了类似双十一等各种大型流量的考验。</p>
<h3 id="9-2-Nacos安装"><a href="#9-2-Nacos安装" class="headerlink" title="9.2 Nacos安装"></a>9.2 Nacos安装</h3><ul>
<li><p>本地Java8+Maven环境已经OK先</p>
</li>
<li><p>从<a href="https://github.com/alibaba/nacos/releases">官网</a>下载Nacos</p>
</li>
<li><p>解压安装包，直接运行bin目录下的startup.cmd</p>
<div class="code-wrapper"><pre><code class="hljs shell">startup.cmd -m standalone</code></pre></div>
</li>
<li><p>命令运行成功后直接访问<a href="http://localhost:8848/nacos，默认账号密码都是nacos">http://localhost:8848/nacos，默认账号密码都是nacos</a></p>
</li>
<li><p>结果页面</p>
</li>
</ul>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210608215624077.png" alt></p>
<h3 id="9-3-Nacos之服务提供者注册"><a href="#9-3-Nacos之服务提供者注册" class="headerlink" title="9.3 Nacos之服务提供者注册"></a>9.3 Nacos之服务提供者注册</h3><p><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery">官方文档</a></p>
<p>新建Module - cloudalibaba-provider-payment9001</p>
<p>POM</p>
<p>父POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre></div>

<p>本模块</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud2020<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloudalibaba-provider-payment9001<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--日常通用jar包配置--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9001</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">nacos-payment-provider</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># 配置Nacos地址</span>

<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span></code></pre></div>

<p>主启动</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;

<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentMain9001</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
            SpringApplication.run(PaymentMain9001.class, args);
    &#125;
&#125;</code></pre></div>

<p>业务类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;
    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String serverPort;

    <span class="hljs-meta">@GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPayment</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;nacos registry, serverPort: &quot;</span>+ serverPort+<span class="hljs-string">&quot;\t id&quot;</span>+id;
    &#125;
&#125;</code></pre></div>

<p>测试</p>
<ul>
<li><a href="http://localhost:9001/payment/nacos/1">http://localhost:9001/payment/nacos/1</a></li>
<li>nacos控制台</li>
<li>nacos服务注册中心+服务提供者9001都OK了</li>
</ul>
<p>为了下一章节演示nacos的负载均衡，参照9001新建9002</p>
<ul>
<li>新建cloudalibaba-provider-payment9002</li>
<li>9002其它步骤你懂的</li>
<li>或者<strong>取巧</strong>不想新建重复体力劳动，可以利用IDEA功能，直接拷贝虚拟端口映射</li>
</ul>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/2bef79cd8f72b8f23b815b49f4ba07ce.png" alt></p>
<h3 id="9-4-Nacos之服务消费者注册和负载"><a href="#9-4-Nacos之服务消费者注册和负载" class="headerlink" title="9.4 Nacos之服务消费者注册和负载"></a>9.4 Nacos之服务消费者注册和负载</h3><p>新建Module - cloudalibaba-consumer-nacos-order83</p>
<p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>LearnCloud<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lun.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloudalibaba-consumer-nacos-order83<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lun.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-api-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--日常通用jar包配置--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<p>为什么nacos支持负载均衡？因为spring-cloud-starter-alibaba-nacos-discovery内含netflix-ribbon包。</p>
<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">83</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">nacos-order-consumer</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span>

<span class="hljs-comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span>
<span class="hljs-attr">service-url:</span>
  <span class="hljs-attr">nacos-user-service:</span> <span class="hljs-string">http://nacos-payment-provider</span></code></pre></div>

<p>主启动</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;


<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderNacosMain83</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;
        SpringApplication.run(OrderNacosMain83.class,args);
    &#125;
&#125;</code></pre></div>

<p>业务类</p>
<p>ApplicationContextConfig</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextConfig</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@LoadBalanced</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();
    &#125;
&#125;</code></pre></div>

<p>OrderNacosController</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;
<span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;

<span class="hljs-keyword">import</span> javax.annotation.Resource;

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderNacosController</span> </span>&#123;
    
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RestTemplate restTemplate;

    <span class="hljs-meta">@Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String serverURL;

    <span class="hljs-meta">@GetMapping(value = &quot;/consumer/payment/nacos/&#123;id&#125;&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">paymentInfo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> restTemplate.getForObject(serverURL+<span class="hljs-string">&quot;/payment/nacos/&quot;</span>+id,String.class);
    &#125;

&#125;</code></pre></div>

<p>测试</p>
<ul>
<li>启动nacos控制台</li>
<li><a href="http://localhost:83/consumer/payment/nacos/13">http://localhost:83/consumer/payment/nacos/13</a><ul>
<li>83访问9001/9002，轮询负载OK</li>
</ul>
</li>
</ul>
<h3 id="9-5-Nacos服务注册中心对比提升"><a href="#9-5-Nacos服务注册中心对比提升" class="headerlink" title="9.5 Nacos服务注册中心对比提升"></a>9.5 Nacos服务注册中心对比提升</h3><p><strong>Nacos全景图</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/a9c35ea022a95aa76bfec990d6b73d8a.png" alt></p>
<p><strong>Nacos和CAP</strong></p>
<p>Nacos与其他注册中心特性对比</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/62d5a8566a2dc588a5ed52346049a054.png" alt></p>
<p><strong>Nacos服务发现实例模型</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/6578e36df056a995a39034045c36fc40.png" alt></p>
<p><strong>Nacos支持AP和CP模式的切换</strong></p>
<p>C是所有节点在同一时间看到的数据是一致的；而A的定义是所有的请求都会收到响应。</p>
<p>何时选择使用何种模式?</p>
<p>—般来说，如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如Spring cloud和Dubbo服务，都适用于AP模式，AP模式为了服务的可能性而减弱了一致性，因此AP模式下只支持注册临时实例。</p>
<p>如果需要在服务级别编辑或者存储配置信息，那么CP是必须，K8S服务和DNS服务则适用于CP模式。CP模式下则支持注册持久化实例，此时则是以Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。</p>
<p>切换命令：</p>
<p>curl -X PUT ‘$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP</p>
<h3 id="9-6-Nacos之服务配置中心"><a href="#9-6-Nacos之服务配置中心" class="headerlink" title="9.6 Nacos之服务配置中心"></a>9.6 Nacos之服务配置中心</h3><p>基础配置</p>
<p>cloudalibaba-config-nacos-client3377</p>
<p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud2020<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloudalibaba-config-nacos-client3377<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--nacos-config--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--nacos-discovery--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--web + actuator--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--一般基础配置--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<p>YML</p>
<p>Nacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常启动。</p>
<p>springboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application</p>
<p>bootstrap</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># nacos配置</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">3377</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">nacos-config-client</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment">#Nacos服务注册中心地址</span>
      <span class="hljs-attr">config:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment">#Nacos作为配置中心地址</span>
        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment">#指定yaml格式的配置</span>
        <span class="hljs-attr">group:</span> <span class="hljs-string">DEV_GROUP</span>
        <span class="hljs-attr">namespace:</span> <span class="hljs-string">7d8f0f5a-6a53-4785-9686-dd460158e5d4</span>


<span class="hljs-comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span>
<span class="hljs-comment"># nacos-config-client-dev.yaml</span>

<span class="hljs-comment"># nacos-config-client-test.yaml   ----&gt; config.info</span></code></pre></div>

<p>application</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">profiles:</span>
    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># 表示开发环境</span>
    <span class="hljs-comment">#active: test # 表示测试环境</span>
    <span class="hljs-comment">#active: info</span></code></pre></div>

<p>主启动</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;


<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NacosConfigClientMain3377</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(NacosConfigClientMain3377.class, args);
    &#125;
&#125;</code></pre></div>

<p>业务类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;
<span class="hljs-keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RefreshScope</span> <span class="hljs-comment">//支持Nacos的动态刷新功能。</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigClientController</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String configInfo;

    <span class="hljs-meta">@GetMapping(&quot;/config/info&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getConfigInfo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> configInfo;
    &#125;
&#125;</code></pre></div>

<p><strong>在Nacos中添加配置信息</strong></p>
<p>Nacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则</p>
<p><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">官方文档</a></p>
<p>说明：之所以需要配置spring.application.name，是因为它是构成Nacos配置管理dataId 字段的一部分。</p>
<p>在 Nacos Spring Cloud中,dataId的完整格式如下：</p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">$&#123;prefix&#125;-$&#123;spring-profile.active&#125;.$&#123;file-extension&#125;</span></code></pre></div>

<ul>
<li>prefix默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。</li>
<li>spring.profile.active即为当前环境对应的 profile，详情可以参考 Spring Boot文档。注意：当spring.profile.active为空时，对应的连接符 - 也将不存在，datald 的拼接格式变成${prefix}.${file-extension}</li>
<li>file-exetension为配置内容的数据格式，可以通过配置项spring .cloud.nacos.config.file-extension来配置。目前只支持properties和yaml类型。</li>
<li>通过Spring Cloud 原生注解@RefreshScope实现配置自动更新。</li>
</ul>
<p>最后公式：</p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">$&#123;spring.application.name)&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></code></pre></div>

<p>配置新增</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/05d45948bf637614dbd70e2bc8ce992d.png" alt></p>
<p>Nacos界面配置对应 - 设置DataId</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210611020331428.png" alt></p>
<p>配置小结</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/b3bffc4a646b30f9bf64fc649bf26f7d.png" alt></p>
<p><strong>测试</strong></p>
<ul>
<li>启动前需要在nacos客户端-配置管理-配置管理栏目下有对应的yaml配置文件</li>
<li>运行cloud-config-nacos-client3377的主启动类</li>
<li>调用接口查看配置信息 - <a href="http://localhost:3377/config/info">http://localhost:3377/config/info</a></li>
</ul>
<p><strong>自带动态刷新</strong></p>
<p>修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新。</p>
<h3 id="9-7-Nacos之命名空间分组和DataID三者关系"><a href="#9-7-Nacos之命名空间分组和DataID三者关系" class="headerlink" title="9.7 Nacos之命名空间分组和DataID三者关系"></a>9.7 Nacos之命名空间分组和DataID三者关系</h3><p><strong>问题 - 多环境多项目管理</strong></p>
<p>问题1:</p>
<p>实际开发中，通常一个系统会准备</p>
<ol>
<li>dev开发环境</li>
<li>test测试环境</li>
<li>prod生产环境。</li>
</ol>
<p>如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢?</p>
<p>问题2:</p>
<p>一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境…那怎么对这些微服务配置进行管理呢?</p>
<p>Nacos的图形化管理界面</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/3a7d1ad9bea8356742997ed3ebbe9be3.png" alt></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/fe336f99f44c4b0aefddf0ae38d1c470.png" alt></p>
<p><strong>Namespace+Group+Data lD三者关系？为什么这么设计？</strong></p>
<ol>
<li><p>是什么</p>
<p>类似Java里面的package名和类名最外层的namespace是可以用于区分部署环境的，Group和DatalD逻辑上区分两个目标对象。</p>
</li>
<li><p>三者情况</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/60712abd615dd86ac6c119bf132a28d6.png" alt></p>
</li>
</ol>
<p>默认情况：Namespace=public，Group=DEFAULT_GROUP，默认Cluster是DEFAULT</p>
<ul>
<li>Nacos默认的Namespace是public，Namespace主要用来实现隔离。<ul>
<li>比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。</li>
</ul>
</li>
<li>Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去</li>
<li>Service就是微服务:一个Service可以包含多个Cluster (集群)，Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。<ul>
<li>比方说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，这时就可以给杭州机房的Service微服务起一个集群名称(HZ) ，给广州机房的Service微服务起一个集群名称(GZ)，还可以尽量让同一个机房的微服务互相调用，以提升性能。</li>
</ul>
</li>
<li>最后是Instance，就是微服务的实例。</li>
</ul>
<h3 id="9-8-Nacos之DataID配置"><a href="#9-8-Nacos之DataID配置" class="headerlink" title="9.8 Nacos之DataID配置"></a>9.8 Nacos之DataID配置</h3><p>指定spring.profile.active和配置文件的DatalD来使不同环境下读取不同的配置</p>
<p>默认空间+默认分组+新建dev和test两个DatalD</p>
<ul>
<li><p>新建dev配置DatalD</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/5ea4b3fd5ca8cb6e7de6f0d9ac98f051.png" alt></p>
</li>
<li><p>新建test配置DatalD</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/b41fe36b41fa2d5abc6e5e492ee3625d.png" alt></p>
</li>
</ul>
<p>通过spring.profile.active属性就能进行多环境下配置文件的读取</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/281a70d387cb48ce82e94421adf17747.png" alt></p>
<p><strong>测试</strong></p>
<ul>
<li><a href="http://localhost:3377/config/info">http://localhost:3377/config/info</a></li>
<li>配置是什么就加载什么 test/dev</li>
</ul>
<h3 id="9-9-Nacos之Group分组方案"><a href="#9-9-Nacos之Group分组方案" class="headerlink" title="9.9 Nacos之Group分组方案"></a>9.9 Nacos之Group分组方案</h3><p>通过Group实现环境区分 - 新建Group</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/bdf592aa566fe50f7f454118a70ca03c.png" alt></p>
<p>在nacos图形界面控制台上面新建配置文件DatalD</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/28aee2b45901bbb9a6776d5c4398a6bb.png" alt></p>
<p>bootstrap+application</p>
<p>在config下增加一条group的配置即可。可配置为DEV_GROUP或TEST GROUP</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/342a167a8bd948d8ba5cbfd760cf66a6.png" alt></p>
<h3 id="9-8-Nacos之Namespace空间方案"><a href="#9-8-Nacos之Namespace空间方案" class="headerlink" title="9.8 Nacos之Namespace空间方案"></a>9.8 Nacos之Namespace空间方案</h3><p>新建dev/test的Namespace</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/a10c71978c75c214aca5fa7057bb2834.png" alt></p>
<p>回到服务管理-服务列表查看</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/2a9f3fa415f5cead0219d404a47131a0.png" alt></p>
<p>按照域名配置填写</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/2177c126090c0db553a8ce77e838a7c9.png" alt></p>
<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># nacos配置</span>
<span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">3377</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">nacos-config-client</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment">#Nacos服务注册中心地址</span>
      <span class="hljs-attr">config:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment">#Nacos作为配置中心地址</span>
        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment">#指定yaml格式的配置</span>
        <span class="hljs-attr">group:</span> <span class="hljs-string">DEV_GROUP</span>
        <span class="hljs-attr">namespace:</span> <span class="hljs-string">7d8f0f5a-6a53-4785-9686-dd460158e5d4</span> <span class="hljs-comment">#&lt;------------指定namespace</span>


<span class="hljs-comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span>
<span class="hljs-comment"># nacos-config-client-dev.yaml</span>

<span class="hljs-comment"># nacos-config-client-test.yaml   ----&gt; config.info</span></code></pre></div>

<h3 id="9-9-Nacos集群-架构说明"><a href="#9-9-Nacos集群-架构说明" class="headerlink" title="9.9 Nacos集群_架构说明"></a>9.9 Nacos集群_架构说明</h3><blockquote>
<p>  <a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">官方文档</a></p>
<p>  <strong>官网架构图</strong></p>
<p>  集群部署架构图</p>
<p>  因此开源的时候推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面</p>
<p>  <a href="http://ip1:port/openAPI直连ip模式，机器挂则需要修改ip才可以使用。">http://ip1:port/openAPI直连ip模式，机器挂则需要修改ip才可以使用。</a></p>
<p>  <a href="http://VIP:port/openAPI挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。">http://VIP:port/openAPI挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。</a></p>
<p>  <a href="http://nacos.com:port/openAPI域名＋VIP模式，可读性好，而且换ip方便，推荐模式">http://nacos.com:port/openAPI域名＋VIP模式，可读性好，而且换ip方便，推荐模式</a></p>
<p>  <img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/59bfb9114980c13f42d14e64dd2dafab.png" alt></p>
</blockquote>
<p>上图官网翻译，真实情况</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/681c3dc16a69f197896cbff482f2298e.png" alt></p>
<p>按照上述，<strong>我们需要mysql数据库</strong>。</p>
<blockquote>
<p>  <a href="https://nacos.io/zh-cn/docs/deployment.html">官网说明</a></p>
<p>  默认Nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的。为了解决这个问题，<strong>Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL的存储</strong>。</p>
<p>  Nacos支持三种部署模式</p>
<ul>
<li>单机模式-用于测试和单机试用。</li>
<li>集群模式-用于生产环境，确保高可用。</li>
<li>多集群模式-用于多数据中心场景。</li>
</ul>
<p>  <strong>Windows</strong></p>
<p>  cmd startup.cmd或者双击startup.cmd文件</p>
<p>  <strong>单机模式支持mysql</strong></p>
<p>  在0.7版本之前，在单机模式时nacos使用嵌入式数据库实现数据的存储，不方便观察数据存储的基本情况。0.7版本增加了支持mysql数据源能力，具体的操作步骤:</p>
<ol>
<li><p>安装数据库，版本要求:5.6.5+</p>
</li>
<li><p>初始化mysq数据库，数据库初始化文件: nacos-mysql.sql</p>
</li>
<li><p>修改conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql)，添加mysql数据源的url、用户名和密码。</p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.platform</span>=<span class="hljs-string">mysql</span>

<span class="hljs-meta">db.num</span>=<span class="hljs-string">1</span>
<span class="hljs-meta">db.url.0</span>=<span class="hljs-string">jdbc:mysql://11.162.196.16:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span>
<span class="hljs-meta">db.user</span>=<span class="hljs-string">nacos_devtest</span>
<span class="hljs-meta">db.password</span>=<span class="hljs-string">youdontknow</span></code></pre></div>

<p>再以单机模式启动nacos，nacos所有写嵌入式数据库的数据都写到了mysql。</p>
</li>
</ol>
</blockquote>
<h3 id="9-10-Nacos持久化切换配置"><a href="#9-10-Nacos持久化切换配置" class="headerlink" title="9.10 Nacos持久化切换配置"></a>9.10 Nacos持久化切换配置</h3><p>Nacos默认自带的是嵌入式数据库derby，<a href="https://blog.csdn.net/u011863024/article/details/github.com/alibaba/nacos/blob/develop/config/pom.xml">nacos的pom.xml</a>中可以看出。</p>
<p>derby到mysql切换配置步骤：</p>
<ol>
<li>nacos-server-1.1.4\nacos\conf录下找到nacos-mysql.sql文件，执行脚本。</li>
<li>nacos-server-1.1.4\nacos\conf目录下找到application.properties，添加以下配置（按需修改对应值）。</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">## If use MySQL as datasource:</span>
<span class="hljs-meta">spring.datasource.platform</span>=<span class="hljs-string">mysql</span>

<span class="hljs-comment">## Count of DB:</span>
<span class="hljs-meta">db.num</span>=<span class="hljs-string">1</span>

<span class="hljs-comment">## Connect URL of DB:</span>
<span class="hljs-meta">db.url.0</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span>
<span class="hljs-meta">db.user.0</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">db.password.0</span>=<span class="hljs-string">root</span></code></pre></div>

<p>启动Nacos，可以看到是个全新的空记录界面，以前是记录进derby。</p>
<h3 id="9-11-Nacos之Linux版本安装"><a href="#9-11-Nacos之Linux版本安装" class="headerlink" title="9.11 Nacos之Linux版本安装"></a>9.11 Nacos之Linux版本安装</h3><p>预计需要，1个Nginx+3个nacos注册中心+1个mysql</p>
<blockquote>
<p>  请确保是在环境中安装使用:</p>
<ol>
<li><p>64 bit OS Linux/Unix/Mac，推荐使用Linux系统。</p>
</li>
<li><p>64 bit JDK 1.8+；<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">下载</a>.<a href="https://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/">配置</a>。</p>
</li>
<li><p>Maven 3.2.x+；<a href="https://maven.apache.org/download.cgi">下载</a>.<a href="https://maven.apache.org/settings.html">配置</a>。</p>
</li>
<li><p>3个或3个以上Nacos节点才能构成集群。</p>
<p><a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">link</a></p>
</li>
</ol>
</blockquote>
<p>Nacos下载Linux版</p>
<p><a href="https://github.com/alibaba/nacos/releases/tag/1.1.4">https://github.com/alibaba/nacos/releases/tag/1.1.4</a></p>
<p>nacos-server-1.1.4.tar.gz 解压后安装</p>
<h3 id="9-12-Nacos集群配置-上"><a href="#9-12-Nacos集群配置-上" class="headerlink" title="9.12 Nacos集群配置(上)"></a>9.12 Nacos集群配置(上)</h3><p>集群配置步骤(重点)</p>
<p><strong>1.Linux服务器上mysql数据库配置</strong></p>
<p>SQL脚本在哪里 - 目录nacos/conf/nacos-mysql.sql</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/e845f90f1003384a9db91bc34dfdd248.png" alt></p>
<p>自己Linux机器上的Mysql数据库上运行</p>
<p><strong>2.application.properties配置</strong></p>
<p>位置</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/1f5549ab8a788ff450f4cfb2bed03f58.png" alt></p>
<p>添加以下内容，设置数据源</p>
<div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.platform</span>=<span class="hljs-string">mysql</span>

<span class="hljs-meta">db.num</span>=<span class="hljs-string">1</span>
<span class="hljs-meta">db.url.0</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span>
<span class="hljs-meta">db.user</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">db.password</span>=<span class="hljs-string">1234</span></code></pre></div>

<p><strong>3.Linux服务器上nacos的集群配置cluster.conf</strong></p>
<p>梳理出3台nacos集器的不同服务端口号，设置3个端口：</p>
<ul>
<li>3333</li>
<li>4444</li>
<li>5555</li>
</ul>
<p>复制出cluster.conf</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/d742baa2bf4354db8dd9d588724e1f5c.png" alt></p>
<p>内容</p>
<div class="code-wrapper"><pre><code class="hljs cfg">192.168.111.144:3333
192.168.111.144:4444
192.168.111.144:5555</code></pre></div>

<p><strong>注意</strong>，这个IP不能写127.0.0.1，必须是Linux命令<code>hostname -i</code>能够识别的IP</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/431d5c0a090b88dffce35768e89e5a90.png" alt></p>
<p><strong>4.编辑Nacos的启动脚本startup.sh，使它能够接受不同的启动端口</strong></p>
<p>/mynacos/nacos/bin目录下有startup.sh</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/2cd7289348079d580cefed591a7568b9.png" alt></p>
<p>平时单机版的启动，都是./startup.sh即可</p>
<p>但是，集群启动，我们希望可以类似其它软件的shell命令，传递不同的端口号启动不同的nacos实例。<br>命令: ./startup.sh -p 3333表示启动端口号为3333的nacos服务器实例，和上一步的cluster.conf配置的一致。</p>
<p>修改内容</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/5b1fc1f634176ad17a19e4021d2b3b5e.png" alt></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/9a3b1d043e5d55236216a46f296e8606.png" alt></p>
<p>执行方式 - <code>startup.sh - p 端口号</code></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/c68aec0dbcc1ed3d61b7e482718f9270.png" alt></p>
<h3 id="9-13-Nacos集群配置-下"><a href="#9-13-Nacos集群配置-下" class="headerlink" title="9.13 Nacos集群配置(下)"></a>9.13 Nacos集群配置(下)</h3><p><strong>5.Nginx的配置，由它作为负载均衡器</strong></p>
<p>修改nginx的配置文件 - nginx.conf</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/700b800ca2e5a3dc01d0312cbeacda38.png" alt></p>
<p>修改内容</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/769472eda4b6a5e1b284db80c705d17f.png" alt></p>
<p>按照指定启动</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/f97a514ee914fb6050fd7428beb20639.png" alt></p>
<p><strong>6.截止到此处，1个Nginx+3个nacos注册中心+1个mysql</strong></p>
<p><strong>测试</strong></p>
<ul>
<li>启动3个nacos注册中心<ul>
<li><code>startup.sh - p 3333</code></li>
<li><code>startup.sh - p 4444</code></li>
<li><code>startup.sh - p 5555</code></li>
<li>查看nacos进程启动数<code>ps -ef | grep nacos | grep -v grep | wc -l</code></li>
</ul>
</li>
<li>启动nginx<ul>
<li><code>./nginx -c /usr/local/nginx/conf/nginx.conf</code></li>
<li>查看nginx进程<code>ps - ef| grep nginx</code></li>
</ul>
</li>
<li>测试通过nginx，访问nacos - <a href="http://192.168.111.144:1111/nacos/#/login">http://192.168.111.144:1111/nacos/#/login</a></li>
<li>新建一个配置测试</li>
</ul>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/a550718db79bd46ee21031e36cb3be00.png" alt></p>
<ul>
<li>新建后，可在linux服务器的mysql新插入一条记录</li>
</ul>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/acc1d20f83d539d0e7943a11859328f5.png" alt></p>
<ul>
<li>让微服务cloudalibaba-provider-payment9002启动注册进nacos集群 - 修改配置文件</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9002</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">nacos-payment-provider</span>
  <span class="hljs-attr">c1oud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-comment">#配置Nacos地址</span>
        <span class="hljs-comment">#server-addr: Localhost:8848</span>
        <span class="hljs-comment">#换成nginx的1111端口，做集群</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.111</span><span class="hljs-number">.144</span><span class="hljs-string">:1111</span>

<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">inc1ude:</span> <span class="hljs-string">&#x27;*&#x27;</span></code></pre></div>

<ul>
<li>启动微服务cloudalibaba-provider-payment9002</li>
<li>访问nacos，查看注册结果</li>
</ul>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/b463fc3b4e9796fa7d98fb72a3c421b6.png" alt></p>
<p><strong>高可用小总结</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/42ff7ef670012437b046f099192d7484.png" alt></p>
<h2 id="10-Sentinel"><a href="#10-Sentinel" class="headerlink" title="10 Sentinel"></a>10 Sentinel</h2><h3 id="10-1-Sentinel是什么"><a href="#10-1-Sentinel是什么" class="headerlink" title="10.1 Sentinel是什么"></a>10.1 Sentinel是什么</h3><p><a href="https://github.com/alibaba/Sentinel">官方Github</a></p>
<p><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">官方文档</a></p>
<h4 id="1-Sentinel是什么"><a href="#1-Sentinel是什么" class="headerlink" title="1 Sentinel是什么"></a>1 Sentinel是什么</h4><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<p>Sentinel 具有以下特征:</p>
<ul>
<li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li>
<li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li>
<li><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<h4 id="2-Sentinel-的主要特性"><a href="#2-Sentinel-的主要特性" class="headerlink" title="2 Sentinel 的主要特性"></a>2 Sentinel 的主要特性</h4><p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/50505538-2c484880-0aaf-11e9-9ffc-cbaaef20be2b.png" alt="Sentinel-features-overview"></p>
<h4 id="3-Sentinel-的开源生态"><a href="#3-Sentinel-的开源生态" class="headerlink" title="3 Sentinel 的开源生态"></a>3 Sentinel 的开源生态</h4><p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/84338449-a9497e00-abce-11ea-8c6a-473fe477b9a1.png" alt="Sentinel-opensource-eco"></p>
<p>Sentinel 分为两个部分:</p>
<ul>
<li>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li>
<li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li>
</ul>
<p>—句话解释，之前我们讲解过的Hystrix。</p>
<p>Hystrix与Sentinel比较：</p>
<ul>
<li>Hystrix<ol>
<li>需要我们程序员自己手工搭建监控平台</li>
<li>没有一套web界面可以给我们进行更加细粒度化得配置流控、速率控制、服务熔断、服务降级</li>
</ol>
</li>
<li>Sentinel<ol>
<li>单独一个组件，可以独立出来。</li>
<li>直接界面化的细粒度统一配置。</li>
</ol>
</li>
</ul>
<p>约定 &gt; 配置 &gt; 编码</p>
<p>都可以写在代码里面，但是我们本次还是大规模的学习使用配置和注解的方式，尽量少写代码</p>
<blockquote>
<p>  sentinel<br>  英 [ˈsentɪnl] 美 [ˈsentɪnl]<br>  n. 哨兵</p>
</blockquote>
<h3 id="10-2-Sentinel下载安装运行"><a href="#10-2-Sentinel下载安装运行" class="headerlink" title="10.2 Sentinel下载安装运行"></a>10.2 Sentinel下载安装运行</h3><p><a href="https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_sentinel">官方文档</a></p>
<p>服务使用中的各种问题：</p>
<ul>
<li>服务雪崩</li>
<li>服务降级</li>
<li>服务熔断</li>
<li>服务限流</li>
</ul>
<p>Sentinel 分为两个部分：</p>
<ul>
<li>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li>
<li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li>
</ul>
<p>安装步骤：</p>
<ul>
<li><p>下载</p>
<ul>
<li><a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></li>
<li>下载到本地sentinel-dashboard-1.7.0.jar</li>
</ul>
</li>
<li><p>运行命令</p>
<ul>
<li>前提<ul>
<li>Java 8 环境</li>
<li>8080端口不能被占用</li>
</ul>
</li>
<li>命令<ul>
<li><code>java -jar sentinel-dashboard-1.7.0.jar</code></li>
</ul>
</li>
</ul>
</li>
<li><p>访问Sentinel管理界面</p>
<ul>
<li>localhost:8080</li>
<li>登录账号密码均为sentinel</li>
</ul>
</li>
</ul>
<h3 id="10-3-Sentinel初始化监控"><a href="#10-3-Sentinel初始化监控" class="headerlink" title="10.3 Sentinel初始化监控"></a>10.3 Sentinel初始化监控</h3><p><strong>启动Nacos8848成功</strong></p>
<p><strong>新建工程 - cloudalibaba-sentinel-service8401</strong></p>
<p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud2020<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloudalibaba-sentinel-service8401<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-api-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--SpringCloud ailibaba sentinel --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--openfeign--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- SpringBoot整合Web组件+actuator --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--日常通用jar包配置--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.6.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8401</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">cloudalibaba-sentinel-service</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment">#Nacos服务注册中心地址</span>
    <span class="hljs-attr">sentinel:</span>
      <span class="hljs-attr">transport:</span>
        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span> <span class="hljs-comment">#配置Sentinel dashboard地址</span>
        <span class="hljs-attr">port:</span> <span class="hljs-number">8719</span>

<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span>

<span class="hljs-attr">feign:</span>
  <span class="hljs-attr">sentinel:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 激活Sentinel对Feign的支持</span></code></pre></div>

<p>主启动</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;

<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApp8401</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(MainApp8401.class, args);
    &#125;
&#125;</code></pre></div>

<p>业务类FlowLimitController</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.annotation.SentinelResource;
<span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowLimitController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/testA&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testA</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------testA&quot;</span>;
    &#125;

    <span class="hljs-meta">@GetMapping(&quot;/testB&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testB</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        log.info(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;...testB&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------testB&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p><strong>启动Sentinel8080 - <code>java -jar sentinel-dashboard-1.7.0.jar</code></strong></p>
<p><strong>启动微服务8401</strong></p>
<p><strong>启动8401微服务后查看sentienl控制台</strong></p>
<ul>
<li><p>刚启动，空空如也，啥都没有</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210617220923039.png" alt></p>
</li>
<li><p>Sentinel采用的懒加载说明</p>
<ul>
<li><p>执行一次访问即可</p>
<ul>
<li><a href="http://localhost:8401/testA">http://localhost:8401/testA</a></li>
<li><a href="http://localhost:8401/testB">http://localhost:8401/testB</a></li>
</ul>
</li>
<li><p>效果 - sentinel8080正在监控微服务8401</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210617221025659.png" alt></p>
</li>
</ul>
</li>
</ul>
<h3 id="10-4-Sentinel流控规则简介"><a href="#10-4-Sentinel流控规则简介" class="headerlink" title="10.4  Sentinel流控规则简介"></a>10.4  Sentinel流控规则简介</h3><p>基本介绍</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/image-20210617221256227.png" alt></p>
<p>进一步解释说明：</p>
<ul>
<li><p>资源名：唯一名称，默认请求路径。</p>
</li>
<li><p>针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）。</p>
</li>
<li><p>阈值类型/单机阈值：</p>
<ul>
<li>QPS(每秒钟的请求数量)︰当调用该API的QPS达到阈值的时候，进行限流。</li>
<li>线程数：当调用该API的线程数达到阈值的时候，进行限流。</li>
</ul>
</li>
<li><p>是否集群：不需要集群。</p>
</li>
<li><p>流控模式：</p>
<ul>
<li>直接：API达到限流条件时，直接限流。</li>
<li>关联：当关联的资源达到阈值时，就限流自己。</li>
<li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流)【API级别的针对来源】。</li>
</ul>
</li>
<li><p>流控效果：</p>
<ul>
<li>快速失败：直接失败，抛异常。</li>
<li>Warm up：根据Code Factor（冷加载因子，默认3）的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值。</li>
<li>排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效。</li>
</ul>
</li>
</ul>
<h3 id="10-5-Sentinel流控-QPS直接失败"><a href="#10-5-Sentinel流控-QPS直接失败" class="headerlink" title="10.5 Sentinel流控-QPS直接失败"></a>10.5 Sentinel流控-QPS直接失败</h3><p><strong>直接 -&gt; 快速失败（系统默认）</strong></p>
<p><strong>配置及说明</strong></p>
<p>表示1秒钟内查询1次就是OK，若超过次数1，就直接-&gt;快速失败，报默认错误</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/56642cc2b7dd5b0d1252235c84f69173.png" alt></p>
<p><strong>测试</strong></p>
<p>快速多次点击访问<a href="http://localhost:8401/testA">http://localhost:8401/testA</a></p>
<p><strong>结果</strong></p>
<p>返回页面 Blocked by Sentinel (flow limiting)</p>
<p><strong>源码</strong></p>
<p>com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController</p>
<p><strong>思考</strong></p>
<p>直接调用默认报错信息，技术方面OK，但是，是否应该有我们自己的后续处理？类似有个fallback的兜底方法?</p>
<h3 id="10-6-Sentinel流控-线程数直接失败"><a href="#10-6-Sentinel流控-线程数直接失败" class="headerlink" title="10.6 Sentinel流控-线程数直接失败"></a>10.6 Sentinel流控-线程数直接失败</h3><p>线程数：当调用该API的线程数达到阈值的时候，进行限流。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/65af4de19564cceebe7cd67589babd69.png" alt></p>
<h3 id="10-7-Sentinel流控-关联"><a href="#10-7-Sentinel流控-关联" class="headerlink" title="10.7 Sentinel流控-关联"></a>10.7 Sentinel流控-关联</h3><p><strong>是什么？</strong></p>
<ul>
<li>当自己关联的资源达到阈值时，就限流自己</li>
<li>当与A关联的资源B达到阀值后，就限流A自己（B惹事，A挂了）</li>
</ul>
<p><strong>设置testA</strong></p>
<p>当关联资源/testB的QPS阀值超过1时，就限流/testA的Rest访问地址，<strong>当关联资源到阈值后限制配置好的资源名</strong>。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/12cd41ae91ba50fe3b5525bab7bc3805.png" alt></p>
<p><strong>Postman模拟并发密集访问testB</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/531e3c582fd2be3aa543ecca5b88c26e.png" alt></p>
<p>访问testB成功</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/f0bdbe602b9c7185b10a2255772b3304.png" alt></p>
<p>postman里新建多线程集合组</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/e66c6aef5cb47beecd7c232f6eac6686.png" alt></p>
<p>将访问地址添加进新新线程组</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/d476cfa823eee6589955e4762a11dfcf.png" alt></p>
<p>Run - 大批量线程高并发访问B</p>
<p>Postman运行后，点击访问<a href="http://localhost:8401/testA，发现testA挂了">http://localhost:8401/testA，发现testA挂了</a></p>
<ul>
<li>结果Blocked by Sentinel(flow limiting)</li>
</ul>
<h3 id="10-8-Sentinel流控-预热"><a href="#10-8-Sentinel流控-预热" class="headerlink" title="10.8 Sentinel流控-预热"></a>10.8 Sentinel流控-预热</h3><blockquote>
<p>  Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档，具体的例子可以参见 WarmUpFlowDemo。</p>
<p>  通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：</p>
<p>  <img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/ede9b7e029c54840e3b40b69c4f371b5.png" alt></p>
<p>  <a href="https://github.com/alibaba/Sentinel/wiki/流量控制#warm-up">link</a></p>
</blockquote>
<blockquote>
<p>  默认coldFactor为3，即请求QPS 从 threshold / 3开始，经预热时长逐渐升至设定的QPS阈值。<a href="https://github.com/alibaba/Sentinel/wiki/流量控制#warm-up">link</a></p>
</blockquote>
<p><strong>源码</strong> - com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController</p>
<p><strong>WarmUp配置</strong></p>
<p>案例，阀值为10+预热时长设置5秒。</p>
<p>系统初始化的阀值为10/ 3约等于3,即阀值刚开始为3;然后过了5秒后阀值才慢慢升高恢复到10</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/c26846d68d79eae1e962f37942a2c99f.png" alt></p>
<p><strong>测试</strong></p>
<p>多次快速点击<a href="http://localhost:8401/testB">http://localhost:8401/testB</a> - 刚开始不行，后续慢慢OK</p>
<p><strong>应用场景</strong></p>
<p>如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来,慢慢的把阀值增长到设置的阀值。</p>
<h3 id="10-9-Sentinel流控-排队等待"><a href="#10-9-Sentinel流控-排队等待" class="headerlink" title="10.9 Sentinel流控-排队等待"></a>10.9 Sentinel流控-排队等待</h3><p>匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。</p>
<p>设置：/testA每秒1次请求，超过的话就排队等待，等待的超时时间为20000毫秒。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/0ddd217545dd0fe2b1f251dbea814ac2.png" alt></p>
<blockquote>
<p>  匀速排队</p>
<p>  匀速排队（RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。详细文档可以参考 流量控制 - 匀速器模式，具体的例子可以参见 PaceFlowDemo。</p>
<p>  该方式的作用如下图所示：</p>
<p>  <img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/79f93ab9f5dc11b05bbed9b793ef7c20.png" alt></p>
<p>  这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p>
<p>  注意：匀速排队模式暂时不支持 QPS &gt; 1000 的场景。</p>
<p>  <a href="https://github.com/alibaba/Sentinel/wiki/流量控制#匀速排队">link</a></p>
</blockquote>
<p>源码 - com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController</p>
<p><strong>测试</strong></p>
<ul>
<li>添加日志记录代码到FlowLimitController的testA方法</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowLimitController</span> </span>&#123;
    <span class="hljs-meta">@GetMapping(&quot;/testA&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testA</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        log.info(Thread.currentThread().getName()+<span class="hljs-string">&quot;\t&quot;</span>+<span class="hljs-string">&quot;...testA&quot;</span>);<span class="hljs-comment">//&lt;----</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------testA&quot;</span>;
    &#125;

    ...
&#125;</code></pre></div>

<ul>
<li>Postman模拟并发密集访问testA。具体操作参考<a href="https://blog.csdn.net/u011863024/article/details/114298288#">117_Sentinel流控-关联</a></li>
<li>后台结果</li>
</ul>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/c89a2124391676992c8fabffdaf1a07c.png" alt></p>
<h3 id="10-10-Sentinel降级简介"><a href="#10-10-Sentinel降级简介" class="headerlink" title="10.10 Sentinel降级简介"></a>10.10 Sentinel降级简介</h3><p><a href="https://github.com/alibaba/Sentinel/wiki/熔断降级">官方文档</a></p>
<blockquote>
<p>  <strong>熔断降级概述</strong></p>
<p>  除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。</p>
<p>  现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。</p>
<p>  <a href="https://github.com/alibaba/Sentinel/wiki/熔断降级#概述">link</a></p>
</blockquote>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/6a002ef360a4e5f20ee2748a092f0211.png" alt></p>
<ul>
<li><p>RT（平均响应时间，秒级）</p>
<ul>
<li>平均响应时间 超出阈值 且 在时间窗口内通过的请求&gt;=5，两个条件同时满足后触发降级。</li>
<li>窗口期过后关闭断路器。</li>
<li>RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt=XXXX才能生效）。</li>
</ul>
</li>
<li><p>异常比列（秒级）</p>
<ul>
<li>QPS &gt;= 5且异常比例（秒级统计）超过阈值时，触发降级;时间窗口结束后，关闭降级 。</li>
</ul>
</li>
<li><p>异常数(分钟级)</p>
<ul>
<li>异常数(分钟统计）超过阈值时，触发降级;时间窗口结束后，关闭降级</li>
</ul>
</li>
</ul>
<p>Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高)，对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。</p>
<p>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。</p>
<p>Sentinei的断路器是没有类似Hystrix半开状态的。(Sentinei 1.8.0 已有半开状态)</p>
<p>半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用。</p>
<h3 id="10-11-Sentinel降级-RT"><a href="#10-11-Sentinel降级-RT" class="headerlink" title="10.11 Sentinel降级-RT"></a>10.11 Sentinel降级-RT</h3><p>是什么？</p>
<blockquote>
<p>  平均响应时间(DEGRADE_GRADE_RT)：当1s内持续进入5个请求，对应时刻的平均响应时间（秒级）均超过阈值（ count，以ms为单位），那么在接下的时间窗口（DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用都会自动地熔断(抛出DegradeException )。注意Sentinel 默认统计的RT上限是4900 ms，超出此阈值的都会算作4900ms，若需要变更此上限可以通过启动配置项-Dcsp.sentinel.statistic.max.rt=xxx来配置。</p>
</blockquote>
<p><strong>注意</strong>：Sentinel 1.7.0才有<strong>平均响应时间</strong>（<code>DEGRADE_GRADE_RT</code>），Sentinel 1.8.0的没有这项，取而代之的是<strong>慢调用比例</strong> (<code>SLOW_REQUEST_RATIO</code>)。</p>
<blockquote>
<p>  慢调用比例 (SLOW_REQUEST_RATIO)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。<a href="https://github.com/alibaba/Sentinel/wiki/熔断降级#熔断策略">link</a></p>
</blockquote>
<p>接下来讲解Sentinel 1.7.0的。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/dcf85d4362c017e543173c76b7dcc2a8.png" alt></p>
<p><strong>测试</strong></p>
<p>代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowLimitController</span> </span>&#123;
	...

    <span class="hljs-meta">@GetMapping(&quot;/testD&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testD</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123; 
            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); 
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; 
            e.printStackTrace(); 
        &#125;
        log.info(<span class="hljs-string">&quot;testD 测试RT&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------testD&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>配置</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/3a608908cef3d557322967e6bc0e5696.png" alt></p>
<p>jmeter压测</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/6dcaee9f62bfd3c8334560df34f6aaa6.png" alt></p>
<p>结论</p>
<p>按照上述配置，永远一秒钟打进来10个线程（大于5个了）调用testD，我们希望200毫秒处理完本次任务，如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开（保险丝跳闸）微服务不可用，保险丝跳闸断电了后续我停止jmeter，没有这么大的访问量了，断路器关闭（保险丝恢复），微服务恢复OK。</p>
<h3 id="10-12-Sentinel降级-异常比例"><a href="#10-12-Sentinel降级-异常比例" class="headerlink" title="10.12 Sentinel降级-异常比例"></a>10.12 Sentinel降级-异常比例</h3><p><strong>是什么？</strong></p>
<blockquote>
<p>  异常比例(DEGRADE_GRADE_EXCEPTION_RATIO)：当资源的每秒请求量 &gt;= 5，并且每秒异常总数占通过量的比值超过阈值（ DegradeRule中的 count）之后，资源进入降级状态，即在接下的时间窗口( DegradeRule中的timeWindow，以s为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是[0.0, 1.0]，代表0% -100%。</p>
</blockquote>
<p><strong>注意</strong>，与Sentinel 1.8.0相比，有些不同（Sentinel 1.8.0才有的半开状态），Sentinel 1.8.0的如下：</p>
<blockquote>
<p>  异常比例 (ERROR_RATIO)：当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。<a href="https://github.com/alibaba/Sentinel/wiki/熔断降级#熔断策略">link</a></p>
</blockquote>
<p>接下来讲解Sentinel 1.7.0的。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/b8f35b00fffd79ef68e8f744403b92f3.png" alt></p>
<p><strong>测试</strong></p>
<p>代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowLimitController</span> </span>&#123;

    ...

    <span class="hljs-meta">@GetMapping(&quot;/testD&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testD</span><span class="hljs-params">()</span> </span>&#123;
        log.info(<span class="hljs-string">&quot;testD 异常比例&quot;</span>);
        <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>/<span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------testD&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>配置</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/ab66591ba085c32e9303d96be7b44f0d.png" alt></p>
<p>jmeter</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/6b4fd3cb04118ae77181fe8bf2019176.png" alt></p>
<p><em>结论</em></p>
<p>按照上述配置，单独访问一次，必然来一次报错一次(int age = 10/0)，调一次错一次。</p>
<p>开启jmeter后，直接高并发发送请求，多次调用达到我们的配置条件了。断路器开启(保险丝跳闸)，微服务不可用了，不再报错error而是服务降级了。</p>
<h3 id="10-13-Sentinel降级-异常数"><a href="#10-13-Sentinel降级-异常数" class="headerlink" title="10.13 Sentinel降级-异常数"></a>10.13 Sentinel降级-异常数</h3><p><strong>是什么？</strong></p>
<blockquote>
<p>  异常数( <code>DEGRADE_GRADF_EXCEPTION_COUNT</code> )：当资源近1分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若<code>timeWindow</code>小于60s，则结束熔断状态后码可能再进入熔断状态。</p>
</blockquote>
<p>注意，与Sentinel 1.8.0相比，有些不同（Sentinel 1.8.0才有的半开状态），Sentinel 1.8.0的如下：</p>
<blockquote>
<p>  异常数 (ERROR_COUNT)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</p>
</blockquote>
<p>接下来讲解Sentinel 1.7.0的。</p>
<p><strong>异常数是按照分钟统计的，时间窗口一定要大于等于60秒</strong>。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/d92c6a9ae5ed514b52ddf43fdf0d5f0e.png" alt></p>
<p><strong>测试</strong></p>
<p>代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowLimitController</span></span>&#123;
	...

    <span class="hljs-meta">@GetMapping(&quot;/testE&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testE</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        log.info(<span class="hljs-string">&quot;testE 测试异常数&quot;</span>);
        <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>/<span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------testE 测试异常数&quot;</span>;
    &#125;
&#125;</code></pre></div>

<p>配置</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/218fe52e19c07b30bbf4d994d05e6a8e.png" alt></p>
<p>访问<a href="http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，我们看到error窗口，但是达到5次报错后，进入熔断后降级。">http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，我们看到error窗口，但是达到5次报错后，进入熔断后降级。</a></p>
<h3 id="10-4-Sentinel热点key-上"><a href="#10-4-Sentinel热点key-上" class="headerlink" title="10.4 Sentinel热点key(上)"></a>10.4 Sentinel热点key(上)</h3><p><strong>基本介绍</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/9d2aa6d777767b3233aa643330eb9cf4.png" alt></p>
<p><strong>官网</strong></p>
<p><a href="https://github.com/alibaba/Sentinel/wiki/热点参数限流">官方文档</a></p>
<blockquote>
<p>  何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p>
<ul>
<li><p>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</p>
</li>
<li><p>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</p>
<p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/16d2ddeff96b7cb68a064b6ec05bde25.png" alt></p>
<p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。</p>
<p><a href="https://github.com/alibaba/Sentinel/wiki/热点参数限流#overview">link</a></p>
</li>
</ul>
</blockquote>
<p><strong>承上启下复习start</strong></p>
<p>兜底方法，分为系统默认和客户自定义，两种</p>
<p>之前的case，限流出问题后，都是用sentinel系统默认的提示: Blocked by Sentinel (flow limiting)</p>
<p>我们能不能自定？类似 Hystrix，某个方法出问题了，就找对应的兜底降级方法?</p>
<p>结论 - <strong>从HystrixCommand到@SentinelResource</strong></p>
<p><strong>代码</strong></p>
<p>com.alibaba.csp.sentinel.slots.block.BlockException</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowLimitController</span></span>
<span class="hljs-class"></span>&#123;

    ...

    <span class="hljs-meta">@GetMapping(&quot;/testHotKey&quot;)</span>
    <span class="hljs-meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler/*兜底方法*/ = &quot;deal_testHotKey&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testHotKey</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span>
<span class="hljs-function"><span class="hljs-params">                             <span class="hljs-meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span> </span>&#123;
        <span class="hljs-comment">//int age = 10/0;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------testHotKey&quot;</span>;
    &#125;
    
    <span class="hljs-comment">/*兜底方法*/</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deal_testHotKey</span> <span class="hljs-params">(String p1, String p2, BlockException exception)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------deal_testHotKey,o(╥﹏╥)o&quot;</span>;  <span class="hljs-comment">//sentinel系统默认的提示：Blocked by Sentinel (flow limiting)</span>
    &#125;

&#125;</code></pre></div>

<p><strong>配置</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/9620ee4e7e54d48ba7dda394fa1c8cd0.png" alt></p>
<p>第一种</p>
<ul>
<li><code>@SentinelResource(value = &quot;testHotKey&quot;)</code></li>
<li>异常打到了前台用户界面看到，不友好</li>
</ul>
<p>第二种</p>
<ul>
<li><p><code>@SentinelResource(value = &quot;testHotKey&quot;, blockHandler = &quot;dealHandler_testHotKey&quot;)</code></p>
</li>
<li><p>方法testHotKey里面第一个参数只要QPS超过每秒1次，马上降级处理</p>
</li>
<li><p>异常用了我们自己定义的兜底方法</p>
</li>
</ul>
<p><strong>测试</strong></p>
<ul>
<li><p>error</p>
<ul>
<li><a href="http://localhost:8401/testHotKey?p1=abc">http://localhost:8401/testHotKey?p1=abc</a></li>
<li><a href="http://localhost:8401/testHotKey?p1=abc&amp;p2=33">http://localhost:8401/testHotKey?p1=abc&amp;p2=33</a></li>
</ul>
</li>
<li><p>right</p>
<ul>
<li><a href="http://localhost:8401/testHotKey?p2=abc">http://localhost:8401/testHotKey?p2=abc</a></li>
</ul>
</li>
</ul>
<h3 id="10-5-Sentinel热点key-下"><a href="#10-5-Sentinel热点key-下" class="headerlink" title="10.5 Sentinel热点key(下)"></a>10.5 Sentinel热点key(下)</h3><p>上述案例演示了第一个参数p1，当QPS超过1秒1次点击后马上被限流。</p>
<p><strong>参数例外项</strong></p>
<ul>
<li><p>普通 - 超过1秒钟一个后，达到阈值1后马上被限流</p>
</li>
<li><p><strong>我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样</strong></p>
</li>
<li><p>特例 - 假如当p1的值等于5时，它的阈值可以达到200</p>
</li>
</ul>
<p><strong>配置</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/3aa08b15109cd346a6083f080a0468fa.png" alt></p>
<p><strong>测试</strong></p>
<ul>
<li>right - <a href="http://localhost:8401/testHotKey?p1=5">http://localhost:8401/testHotKey?p1=5</a></li>
<li>error - <a href="http://localhost:8401/testHotKey?p1=3">http://localhost:8401/testHotKey?p1=3</a></li>
<li>当p1等于5的时候，阈值变为200</li>
<li>当p1不等于5的时候，阈值就是平常的1</li>
</ul>
<p><strong>前提条件</strong> - 热点参数的注意点，参数必须是基本类型或者String</p>
<p><strong>其它</strong></p>
<p>在方法体抛异常</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowLimitController</span></span>
<span class="hljs-class"></span>&#123;

    ...

    <span class="hljs-meta">@GetMapping(&quot;/testHotKey&quot;)</span>
    <span class="hljs-meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler/*兜底方法*/ = &quot;deal_testHotKey&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testHotKey</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span>
<span class="hljs-function"><span class="hljs-params">                             <span class="hljs-meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span> </span>&#123;
        <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>/<span class="hljs-number">0</span>;<span class="hljs-comment">//&lt;----------------------------会抛异常的地方</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------testHotKey&quot;</span>;
    &#125;
    
    <span class="hljs-comment">/*兜底方法*/</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deal_testHotKey</span> <span class="hljs-params">(String p1, String p2, BlockException exception)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;------deal_testHotKey,o(╥﹏╥)o&quot;</span>;  <span class="hljs-comment">//sentinel系统默认的提示：Blocked by Sentinel (flow limiting)</span>
    &#125;

&#125;</code></pre></div>

<p>将会抛出Spring Boot 2的默认异常页面，而不是兜底方法。</p>
<ul>
<li>@SentinelResource - 处理的是sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理;</li>
</ul>
<ul>
<li>RuntimeException int age = 10/0，这个是java运行时报出的运行时异常RunTimeException，@SentinelResource不管</li>
</ul>
<p>总结 - @SentinelResource主管配置出错，运行出错该走异常走异常</p>
<h3 id="10-16-Sentinel系统规则"><a href="#10-16-Sentinel系统规则" class="headerlink" title="10.16 Sentinel系统规则"></a>10.16 Sentinel系统规则</h3><p><a href="https://github.com/alibaba/Sentinel/wiki/系统自适应限流">官方文档</a></p>
<blockquote>
<p>  Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。<a href="https://github.com/alibaba/Sentinel/wiki/系统自适应限流">link</a></p>
</blockquote>
<blockquote>
<p>  <strong>系统规则</strong></p>
<p>  系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p>  系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p>
<p>  系统规则支持以下的模式：</p>
<ul>
<li><p>Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。</p>
</li>
<li><p>CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</p>
</li>
<li><p>平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</p>
</li>
<li><p>并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</p>
</li>
<li><p>入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</p>
<p><a href="https://github.com/alibaba/Sentinel/wiki/系统自适应限流#系统规则">link</a></p>
</li>
</ul>
</blockquote>
<h3 id="10-17-SentinelResource配置-上"><a href="#10-17-SentinelResource配置-上" class="headerlink" title="10.17 SentinelResource配置(上)"></a>10.17 SentinelResource配置(上)</h3><p><em>按资源名称限流 + 后续处理</em></p>
<p><strong>启动Nacos成功</strong></p>
<p><strong>启动Sentinel成功</strong></p>
<p><strong>Module - cloudalibaba-sentinel-service8401**</strong>配置流控规则**</p>
<p>配置步骤</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.annotation.SentinelResource;
<span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.myhandler.CustomerBlockHandler;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.CommonResult;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.Payment;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RateLimitController</span> </span>&#123;
    
    <span class="hljs-meta">@GetMapping(&quot;/byResource&quot;)</span>
    <span class="hljs-meta">@SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">byResource</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;按资源名称限流测试OK&quot;</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">2020L</span>,<span class="hljs-string">&quot;serial001&quot;</span>));
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">handleException</span><span class="hljs-params">(BlockException exception)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">444</span>,exception.getClass().getCanonicalName()+<span class="hljs-string">&quot;\t 服务不可用&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p><strong>配置流控规则</strong></p>
<p>配置步骤</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/91aa0ac210011218db9557a2bfcfebd1.png" alt></p>
<p>图形配置和代码关系</p>
<p>表示1秒钟内查询次数大于1，就跑到我们自定义的处流，限流</p>
<p>1秒钟点击1下，OK</p>
<p>超过上述，疯狂点击，返回了自己定义的限流处理信息，限流发生</p>
<div class="code-wrapper"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;code&quot;</span>:<span class="hljs-number">444</span>, <span class="hljs-attr">&quot;message&quot;</span>:<span class="hljs-string">&quot;com.alibaba.csp.sentinel.slots.block.flow.FlowException\t 服务不可用&quot;</span>, <span class="hljs-attr">&quot;data&quot;</span>:<span class="hljs-literal">null</span>&#125;</code></pre></div>

<p><strong>额外问题</strong></p>
<p>此时关闭问服务8401 -&gt; Sentinel控制台，流控规则消失了</p>
<p><em>按照Url地址限流 + 后续处理</em></p>
<p><strong>通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息</strong></p>
<p><strong>业务类RateLimitController</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RateLimitController</span></span>
<span class="hljs-class"></span>&#123;
	...

    <span class="hljs-meta">@GetMapping(&quot;/rateLimit/byUrl&quot;)</span>
    <span class="hljs-meta">@SentinelResource(value = &quot;byUrl&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">byUrl</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;按url限流测试OK&quot;</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">2020L</span>,<span class="hljs-string">&quot;serial002&quot;</span>));
    &#125;
&#125;</code></pre></div>

<p><strong>Sentinel控制台配置</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/d6a79b7cc3f2f9c8b6dcbe3f77f78c6b.png" alt></p>
<p><strong>测试</strong></p>
<ul>
<li>快速点击<a href="http://localhost:8401/rateLimit/byUrl">http://localhost:8401/rateLimit/byUrl</a></li>
<li>结果 - 会返回Sentinel自带的限流处理结果 Blocked by Sentinel (flow limiting)</li>
</ul>
<p><strong>上面兜底方案面临的问题</strong></p>
<ol>
<li>系统默认的，没有体现我们自己的业务要求。</li>
<li>依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观。</li>
<li>每个业务方法都添加—个兜底的，那代码膨胀加剧。</li>
<li>全局统—的处理方法没有体现。</li>
</ol>
<h3 id="10-18-SentinelResource配置-中"><a href="#10-18-SentinelResource配置-中" class="headerlink" title="10.18 SentinelResource配置(中)"></a>10.18 SentinelResource配置(中)</h3><p>客户自定义限流处理逻辑</p>
<p>自定义限流处理类 - 创建CustomerBlockHandler类用于自定义限流处理逻辑</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.CommonResult;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.Payment;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerBlockHandler</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CommonResult <span class="hljs-title">handlerException</span><span class="hljs-params">(BlockException exception)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">4444</span>,<span class="hljs-string">&quot;按客戶自定义,global handlerException----1&quot;</span>);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CommonResult <span class="hljs-title">handlerException2</span><span class="hljs-params">(BlockException exception)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">4444</span>,<span class="hljs-string">&quot;按客戶自定义,global handlerException----2&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>RateLimitController</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RateLimitController</span> </span>&#123;
	...

    <span class="hljs-meta">@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)</span>
    <span class="hljs-meta">@SentinelResource(value = &quot;customerBlockHandler&quot;,</span>
<span class="hljs-meta">            blockHandlerClass = CustomerBlockHandler.class,//&lt;-------- 自定义限流处理类</span>
<span class="hljs-meta">            blockHandler = &quot;handlerException2&quot;)</span><span class="hljs-comment">//&lt;-----------</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">customerBlockHandler</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;按客戶自定义&quot;</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">2020L</span>,<span class="hljs-string">&quot;serial003&quot;</span>));
    &#125;
&#125;</code></pre></div>

<p>Sentinel控制台配置</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/44dccf4107a74fda56f0807d39fa53f1.png" alt></p>
<p>启动微服务后先调用一次 - <a href="http://localhost:8401/rateLimit/customerBlockHandler。然后，多次快速刷新http://localhost:8401/rateLimit/customerBlockHandler。刷新后，我们自定义兜底方法的字符串信息就返回到前端。">http://localhost:8401/rateLimit/customerBlockHandler。然后，多次快速刷新http://localhost:8401/rateLimit/customerBlockHandler。刷新后，我们自定义兜底方法的字符串信息就返回到前端。</a></p>
<h3 id="10-19-SentinelResource配置-下"><a href="#10-19-SentinelResource配置-下" class="headerlink" title="10.19 SentinelResource配置(下)"></a>10.19 SentinelResource配置(下)</h3><blockquote>
<p>  <strong>@SentinelResource 注解</strong></p>
<p>  注意：注解方式埋点不支持 private 方法。</p>
<p>  @SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。 @SentinelResource 注解包含以下属性：</p>
<ul>
<li>value：资源名称，必需项（不能为空）</li>
<li>entryType：entry 类型，可选项（默认为 EntryType.OUT）</li>
<li>blockHandler / blockHandlerClass: blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li>
<li>fallback /fallbackClass：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：<ul>
<li>返回值类型必须与原函数返回值类型一致；</li>
<li>方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。</li>
<li>fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li>
</ul>
</li>
<li>defaultFallback（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：<ul>
<li>返回值类型必须与原函数返回值类型一致；</li>
<li>方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。</li>
<li>defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li>
</ul>
</li>
<li>exceptionsToIgnore（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。<br><a href="https://github.com/alibaba/Sentinel/wiki/注解支持#sentinelresource-注解">link</a></li>
</ul>
</blockquote>
<p>Sentinel主要有三个核心Api：</p>
<ol>
<li>SphU定义资源</li>
<li>Tracer定义统计</li>
<li>ContextUtil定义了上下文</li>
</ol>
<h3 id="10-20-Sentinel服务熔断Ribbon环境预说"><a href="#10-20-Sentinel服务熔断Ribbon环境预说" class="headerlink" title="10.20 Sentinel服务熔断Ribbon环境预说"></a>10.20 Sentinel服务熔断Ribbon环境预说</h3><p>sentinel整合ribbon+openFeign+fallback</p>
<p>Ribbon系列</p>
<ul>
<li>启动nacos和sentinel</li>
<li>提供者9003/9004</li>
<li>消费者84</li>
</ul>
<p><strong>提供者9003/9004</strong></p>
<p>新建cloudalibaba-provider-payment9003/9004，两个一样的做法</p>
<p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud2020<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloudalibaba-provider-payment9003<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-api-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--日常通用jar包配置--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">9003</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">nacos-payment-provider</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment">#配置Nacos地址</span>

<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span></code></pre></div>

<p><strong>记得修改不同的端口号</strong></p>
<p>主启动</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentMain9003</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(PaymentMain9003.class, args);
    &#125;
&#125;</code></pre></div>

<p>业务类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.CommonResult;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.Payment;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-keyword">import</span> java.util.HashMap;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentController</span> </span>&#123;
    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String serverPort;

    <span class="hljs-comment">//模拟数据库</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap&lt;Long,Payment&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">static</span>
    &#123;
        hashMap.put(<span class="hljs-number">1L</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">1L</span>,<span class="hljs-string">&quot;28a8c1e3bc2742d8848569891fb42181&quot;</span>));
        hashMap.put(<span class="hljs-number">2L</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">2L</span>,<span class="hljs-string">&quot;bba8c1e3bc2742d8848569891ac32182&quot;</span>));
        hashMap.put(<span class="hljs-number">3L</span>,<span class="hljs-keyword">new</span> Payment(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;6ua8c1e3bc2742d8848569891xt92183&quot;</span>));
    &#125;

    <span class="hljs-meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">paymentSQL</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>
<span class="hljs-function">    </span>&#123;
        Payment payment = hashMap.get(id);
        CommonResult&lt;Payment&gt; result = <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;from mysql,serverPort:  &quot;</span>+serverPort,payment);
        <span class="hljs-keyword">return</span> result;
    &#125;

&#125;</code></pre></div>

<p>测试地址 - <a href="http://localhost:9003/paymentSQL/1">http://localhost:9003/paymentSQL/1</a></p>
<p><strong>消费者84</strong></p>
<p>新建cloudalibaba-consumer-nacos-order84</p>
<p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud2020<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloudalibaba-consumer-nacos-order84<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--SpringCloud openfeign --&gt;</span>
        <span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">        &lt;dependency&gt;</span>
<span class="hljs-comment">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span>
<span class="hljs-comment">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span>
<span class="hljs-comment">        &lt;/dependency&gt;</span>
<span class="hljs-comment">		--&gt;</span>
        <span class="hljs-comment">&lt;!--SpringCloud ailibaba nacos --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--SpringCloud ailibaba sentinel --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud-api-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- SpringBoot整合Web组件 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--日常通用jar包配置--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">84</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">nacos-order-consumer</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span>
    <span class="hljs-attr">sentinel:</span>
      <span class="hljs-attr">transport:</span>
        <span class="hljs-comment">#配置Sentinel dashboard地址</span>
        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span>
        <span class="hljs-comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span>
        <span class="hljs-attr">port:</span> <span class="hljs-number">8719</span>

<span class="hljs-comment">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span>
<span class="hljs-attr">service-url:</span>
  <span class="hljs-attr">nacos-user-service:</span> <span class="hljs-string">http://nacos-payment-provider</span>

<span class="hljs-comment"># 激活Sentinel对Feign的支持</span>
<span class="hljs-attr">feign:</span>
  <span class="hljs-attr">sentinel:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span></code></pre></div>

<p>主启动</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;
<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;

<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableFeignClients</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderNacosMain84</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(OrderNacosMain84.class, args);
    &#125;
&#125;</code></pre></div>

<p>业务类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-comment">//import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span>
<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;

<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-comment">//@EnableFeignClients</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderNacosMain84</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(OrderNacosMain84.class, args);
    &#125;
&#125;</code></pre></div>

<p>ApplicationContextConfig</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;


<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationContextConfig</span> </span>&#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@LoadBalanced</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();
    &#125;
&#125;</code></pre></div>

<p>CircleBreakerController</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.annotation.SentinelResource;
<span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.service.PaymentService;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.CommonResult;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.Payment;
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;
<span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;

<span class="hljs-keyword">import</span> javax.annotation.Resource;

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleBreakerController</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVICE_URL = <span class="hljs-string">&quot;http://nacos-payment-provider&quot;</span>;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RestTemplate restTemplate;
 
    <span class="hljs-meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span>
    <span class="hljs-meta">@SentinelResource(value = &quot;fallback&quot;)</span><span class="hljs-comment">//没有配置</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>
<span class="hljs-function">    </span>&#123;
        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);

        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException (<span class="hljs-string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException (<span class="hljs-string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);
        &#125;

        <span class="hljs-keyword">return</span> result;
    &#125;
    
&#125;</code></pre></div>

<p>修改后请重启微服务</p>
<ul>
<li>热部署对java代码级生效及时</li>
<li>对@SentinelResource注解内属性，有时效果不好</li>
</ul>
<p>目的</p>
<ul>
<li>fallback管运行异常</li>
<li>blockHandler管配置违规</li>
</ul>
<p>测试地址 - <a href="http://localhost:84/consumer/fallback/1">http://localhost:84/consumer/fallback/1</a></p>
<p>没有任何配置</p>
<p>只配置fallback</p>
<p>只配置blockHandler</p>
<p>fallback和blockHandler都配置</p>
<p>忽略属性</p>
<h3 id="10-21-Sentinel服务熔断无配置"><a href="#10-21-Sentinel服务熔断无配置" class="headerlink" title="10.21 Sentinel服务熔断无配置"></a>10.21 Sentinel服务熔断无配置</h3><p>没有任何配置 - <strong>给用户error页面，不友好</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleBreakerController</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVICE_URL = <span class="hljs-string">&quot;http://nacos-payment-provider&quot;</span>;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RestTemplate restTemplate;
 
    <span class="hljs-meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span>
    <span class="hljs-meta">@SentinelResource(value = &quot;fallback&quot;)</span><span class="hljs-comment">//没有配置</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>
<span class="hljs-function">    </span>&#123;
        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);

        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException (<span class="hljs-string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException (<span class="hljs-string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);
        &#125;

        <span class="hljs-keyword">return</span> result;
    &#125;
    
&#125;</code></pre></div>

<h3 id="10-22-Sentinel服务熔断只配置fallback"><a href="#10-22-Sentinel服务熔断只配置fallback" class="headerlink" title="10.22 Sentinel服务熔断只配置fallback"></a>10.22 Sentinel服务熔断只配置fallback</h3><p>fallback只负责业务异常</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleBreakerController</span> </span>&#123;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVICE_URL = <span class="hljs-string">&quot;http://nacos-payment-provider&quot;</span>;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RestTemplate restTemplate;
 
    <span class="hljs-meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span>
    <span class="hljs-comment">//@SentinelResource(value = &quot;fallback&quot;)//没有配置</span>
    <span class="hljs-meta">@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;handlerFallback&quot;)</span> <span class="hljs-comment">//fallback只负责业务异常</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> </span>&#123;
        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);

        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException (<span class="hljs-string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException (<span class="hljs-string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);
        &#125;

        <span class="hljs-keyword">return</span> result;
    &#125;
    
    <span class="hljs-comment">//本例是fallback</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">handlerFallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span>  Long id,Throwable e)</span> </span>&#123;
        Payment payment = <span class="hljs-keyword">new</span> Payment(id,<span class="hljs-string">&quot;null&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult&lt;&gt;(<span class="hljs-number">444</span>,<span class="hljs-string">&quot;兜底异常handlerFallback,exception内容  &quot;</span>+e.getMessage(),payment);
    &#125;
    
&#125;</code></pre></div>

<p>测试地址 - <a href="http://localhost:84/consumer/fallback/4">http://localhost:84/consumer/fallback/4</a></p>
<p>页面返回结果：</p>
<div class="code-wrapper"><pre><code class="hljs json">&#123;&quot;code&quot;:444,&quot;message&quot;:&quot;兜底异常nandlerFal1back, exception内容illegalkrgumentEBxceptiorn,非法参数异常……&quot;,&quot;data&quot;:&#123;&quot;id&quot;:4,&quot;seria:&quot;null&quot;&#125;&#125;
</code></pre></div>

<h3 id="10-23-Sentinel服务熔断只配置blockHandler"><a href="#10-23-Sentinel服务熔断只配置blockHandler" class="headerlink" title="10.23 Sentinel服务熔断只配置blockHandler"></a>10.23 Sentinel服务熔断只配置blockHandler</h3><p>blockHandler只负责<strong>sentinel控制台配置违规</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleBreakerController</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVICE_URL = <span class="hljs-string">&quot;http://nacos-payment-provider&quot;</span>;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RestTemplate restTemplate;

    <span class="hljs-meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span>
    <span class="hljs-comment">//@SentinelResource(value = &quot;fallback&quot;) //没有配置</span>
    <span class="hljs-comment">//@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback只负责业务异常</span>
    <span class="hljs-meta">@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;)</span> <span class="hljs-comment">//blockHandler只负责sentinel控制台配置违规</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>
<span class="hljs-function">    </span>&#123;
        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);

        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException (<span class="hljs-string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException (<span class="hljs-string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);
        &#125;

        <span class="hljs-keyword">return</span> result;
    &#125;
    <span class="hljs-comment">//本例是fallback</span>
<span class="hljs-comment">/*    public CommonResult handlerFallback(@PathVariable  Long id,Throwable e) &#123;</span>
<span class="hljs-comment">        Payment payment = new Payment(id,&quot;null&quot;);</span>
<span class="hljs-comment">        return new CommonResult&lt;&gt;(444,&quot;兜底异常handlerFallback,exception内容  &quot;+e.getMessage(),payment);</span>
<span class="hljs-comment">    &#125;*/</span>
    
    <span class="hljs-comment">//本例是blockHandler</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">blockHandler</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span>  Long id,BlockException blockException)</span> </span>&#123;
        Payment payment = <span class="hljs-keyword">new</span> Payment(id,<span class="hljs-string">&quot;null&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult&lt;&gt;(<span class="hljs-number">445</span>,<span class="hljs-string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span>+blockException.getMessage(),payment);
    &#125;
&#125;</code></pre></div>

<p>测试地址 - <a href="http://localhost:84/consumer/fallback/4">http://localhost:84/consumer/fallback/4</a></p>
<h3 id="10-24-Sentinel服务熔断fallback和blockHandler都配置"><a href="#10-24-Sentinel服务熔断fallback和blockHandler都配置" class="headerlink" title="10.24 Sentinel服务熔断fallback和blockHandler都配置"></a>10.24 Sentinel服务熔断fallback和blockHandler都配置</h3><p>若blockHandler和fallback 都进行了配置，则被限流降级而抛出BlockException时只会进入blockHandler处理逻辑。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleBreakerController</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVICE_URL = <span class="hljs-string">&quot;http://nacos-payment-provider&quot;</span>;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> RestTemplate restTemplate;

    <span class="hljs-meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span>
    <span class="hljs-comment">//@SentinelResource(value = &quot;fallback&quot;) //没有配置</span>
    <span class="hljs-comment">//@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback只负责业务异常</span>
    <span class="hljs-comment">//@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) //blockHandler只负责sentinel控制台配置违规</span>
    <span class="hljs-meta">@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>
<span class="hljs-function">    </span>&#123;
        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);

        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException (<span class="hljs-string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException (<span class="hljs-string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);
        &#125;

        <span class="hljs-keyword">return</span> result;
    &#125;
    <span class="hljs-comment">//本例是fallback</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">handlerFallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span>  Long id,Throwable e)</span> </span>&#123;
        Payment payment = <span class="hljs-keyword">new</span> Payment(id,<span class="hljs-string">&quot;null&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult&lt;&gt;(<span class="hljs-number">444</span>,<span class="hljs-string">&quot;兜底异常handlerFallback,exception内容  &quot;</span>+e.getMessage(),payment);
    &#125;
    <span class="hljs-comment">//本例是blockHandler</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">blockHandler</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span>  Long id,BlockException blockException)</span> </span>&#123;
        Payment payment = <span class="hljs-keyword">new</span> Payment(id,<span class="hljs-string">&quot;null&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult&lt;&gt;(<span class="hljs-number">445</span>,<span class="hljs-string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span>+blockException.getMessage(),payment);
    &#125;
&#125;</code></pre></div>

<h3 id="10-25-Sentinel服务熔断exceptionsToIgnore"><a href="#10-25-Sentinel服务熔断exceptionsToIgnore" class="headerlink" title="10.25 Sentinel服务熔断exceptionsToIgnore"></a>10.25 Sentinel服务熔断exceptionsToIgnore</h3><p>exceptionsToIgnore，忽略指定异常，即这些异常不用兜底方法处理。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleBreakerController</span>    </span>
<span class="hljs-class"></span>
<span class="hljs-class">    ...</span>
<span class="hljs-class">    </span>
    @RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)
    <span class="hljs-meta">@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;,</span>
<span class="hljs-meta">            exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;)</span><span class="hljs-comment">//&lt;-------------</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">fallback</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span></span>
<span class="hljs-function">    </span>&#123;
        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="hljs-string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);

        <span class="hljs-keyword">if</span> (id == <span class="hljs-number">4</span>) &#123;
            <span class="hljs-comment">//exceptionsToIgnore属性有IllegalArgumentException.class，</span>
            <span class="hljs-comment">//所以IllegalArgumentException不会跳入指定的兜底程序。</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException (<span class="hljs-string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.getData() == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException (<span class="hljs-string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);
        &#125;

        <span class="hljs-keyword">return</span> result;
    &#125;

	...
&#125;</code></pre></div>

<h3 id="10-26-Sentinel服务熔断OpenFeign"><a href="#10-26-Sentinel服务熔断OpenFeign" class="headerlink" title="10.26 Sentinel服务熔断OpenFeign"></a>10.26 Sentinel服务熔断OpenFeign</h3><p><strong>修改84模块</strong></p>
<ul>
<li>84消费者调用提供者9003</li>
<li>Feign组件一般是消费侧</li>
</ul>
<p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringCloud openfeign --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># 激活Sentinel对Feign的支持</span>
<span class="hljs-attr">feign:</span>
  <span class="hljs-attr">sentinel:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span></code></pre></div>

<p>业务类</p>
<p>带@Feignclient注解的业务接口，fallback = PaymentFallbackService.class</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.CommonResult;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.Payment;
<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;

<span class="hljs-meta">@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PaymentService</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">paymentSQL</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.CommonResult;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.entities.Payment;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentFallbackService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PaymentService</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">paymentSQL</span><span class="hljs-params">(Long id)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult&lt;&gt;(<span class="hljs-number">44444</span>,<span class="hljs-string">&quot;服务降级返回,---PaymentFallbackService&quot;</span>,<span class="hljs-keyword">new</span> Payment(id,<span class="hljs-string">&quot;errorSerial&quot;</span>));
    &#125;
&#125;</code></pre></div>

<p>Controller</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleBreakerController</span> </span>&#123;

    ...
    
	<span class="hljs-comment">//==================OpenFeign</span>
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> PaymentService paymentService;

    <span class="hljs-meta">@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; <span class="hljs-title">paymentSQL</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> paymentService.paymentSQL(id);
    &#125;
&#125;</code></pre></div>

<p>主启动</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;

<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableFeignClients</span><span class="hljs-comment">//&lt;------------------------</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderNacosMain84</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(OrderNacosMain84.class, args);
    &#125;
&#125;</code></pre></div>

<p>测试 - <a href="http://localhost:84/consumer/paymentSQL/1">http://localhost:84/consumer/paymentSQL/1</a></p>
<p>测试84调用9003，此时故意关闭9003微服务提供者，<strong>84消费侧自动降级</strong>，不会被耗死。</p>
<table>
<thead>
<tr>
<th>-</th>
<th align="center">Sentinel</th>
<th>Hystrix</th>
<th>resilience4j</th>
</tr>
</thead>
<tbody><tr>
<td>隔离策略</td>
<td align="center">信号量隔离（并发线程数限流）</td>
<td>线程池隔商/信号量隔离</td>
<td>信号量隔离</td>
</tr>
<tr>
<td>熔断降级策略</td>
<td align="center">基于响应时间、异常比率、异常数</td>
<td>基于异常比率</td>
<td>基于异常比率、响应时间</td>
</tr>
<tr>
<td>实时统计实现</td>
<td align="center">滑动窗口（LeapArray）</td>
<td>滑动窗口（基于RxJava）</td>
<td>Ring Bit Buffer</td>
</tr>
<tr>
<td>动态规则配置</td>
<td align="center">支持多种数据源</td>
<td>支持多种数据源</td>
<td>有限支持</td>
</tr>
<tr>
<td>扩展性</td>
<td align="center">多个扩展点</td>
<td>插件的形式</td>
<td>接口的形式</td>
</tr>
<tr>
<td>基于注解的支持</td>
<td align="center">支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>限流</td>
<td align="center">基于QPS，支持基于调用关系的限流</td>
<td>有限的支持</td>
<td>Rate Limiter</td>
</tr>
<tr>
<td>流量整形</td>
<td align="center">支持预热模式匀速器模式、预热排队模式</td>
<td>不支持</td>
<td>简单的Rate Limiter模式</td>
</tr>
<tr>
<td>系统自适应保护</td>
<td align="center">支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>控制台</td>
<td align="center">提供开箱即用的控制台，可配置规则、查看秒级监控，机器发观等</td>
<td>简单的监控查看</td>
<td>不提供控制台，可对接其它监控系统</td>
</tr>
</tbody></table>
<h3 id="10-27-Sentinel持久化规则"><a href="#10-27-Sentinel持久化规则" class="headerlink" title="10.27 Sentinel持久化规则"></a>10.27 Sentinel持久化规则</h3><p><strong>是什么</strong></p>
<p>一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化。</p>
<p><strong>怎么玩</strong></p>
<p>将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效。</p>
<p><strong>步骤</strong></p>
<p>修改cloudalibaba-sentinel-service8401</p>
<p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8401</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">cloudalibaba-sentinel-service</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment">#Nacos服务注册中心地址</span>
    <span class="hljs-attr">sentinel:</span>
      <span class="hljs-attr">transport:</span>
        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span> <span class="hljs-comment">#配置Sentinel dashboard地址</span>
        <span class="hljs-attr">port:</span> <span class="hljs-number">8719</span>
      <span class="hljs-attr">datasource:</span> <span class="hljs-comment">#&lt;---------------------------关注点，添加Nacos数据源配置</span>
        <span class="hljs-attr">ds1:</span>
          <span class="hljs-attr">nacos:</span>
            <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span>
            <span class="hljs-attr">dataId:</span> <span class="hljs-string">cloudalibaba-sentinel-service</span>
            <span class="hljs-attr">groupId:</span> <span class="hljs-string">DEFAULT_GROUP</span>
            <span class="hljs-attr">data-type:</span> <span class="hljs-string">json</span>
            <span class="hljs-attr">rule-type:</span> <span class="hljs-string">flow</span>

<span class="hljs-attr">management:</span>
  <span class="hljs-attr">endpoints:</span>
    <span class="hljs-attr">web:</span>
      <span class="hljs-attr">exposure:</span>
        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span>

<span class="hljs-attr">feign:</span>
  <span class="hljs-attr">sentinel:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 激活Sentinel对Feign的支持</span></code></pre></div>

<p>添加Nacos业务规则配置</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/2401a6b2df715ee64f647da2f31e1eeb.png" alt></p>
<p>配置内容解析</p>
<div class="code-wrapper"><pre><code class="hljs json">[&#123;
    <span class="hljs-attr">&quot;resource&quot;</span>: <span class="hljs-string">&quot;/rateLimit/byUrl&quot;</span>,
    <span class="hljs-attr">&quot;IimitApp&quot;</span>: <span class="hljs-string">&quot;default&quot;</span>,
    <span class="hljs-attr">&quot;grade&quot;</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">&quot;count&quot;</span>: <span class="hljs-number">1</span>, 
    <span class="hljs-attr">&quot;strategy&quot;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">&quot;controlBehavior&quot;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">&quot;clusterMode&quot;</span>: <span class="hljs-literal">false</span>
&#125;]</code></pre></div>

<ul>
<li>esource：资源名称；</li>
<li>limitApp：来源应用；</li>
<li>grade：阈值类型，0表示线程数, 1表示QPS；</li>
<li>count：单机阈值；</li>
<li>strategy：流控模式，0表示直接，1表示关联，2表示链路；</li>
<li>controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待；</li>
<li>clusterMode：是否集群。</li>
</ul>
<p>启动8401后刷新sentinel发现业务规则有了</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/c854e986254c09d0a7866811ec1e0cb4.png" alt></p>
<p>快速访问测试接口 - <a href="http://localhost:8401/rateLimit/byUrl">http://localhost:8401/rateLimit/byUrl</a> - 页面返回<code>Blocked by Sentinel (flow limiting)</code></p>
<p>停止8401再看sentinel - 停机后发现流控规则没有了</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/09ea175d22d31718e15c3b569d98d381.png" alt></p>
<p>重新启动8401再看sentinel</p>
<ul>
<li>乍一看还是没有，稍等一会儿</li>
<li>多次调用 - <a href="http://localhost:8401/rateLimit/byUrl">http://localhost:8401/rateLimit/byUrl</a></li>
<li>重新配置出现了，持久化验证通过</li>
</ul>
<h2 id="11-Seata"><a href="#11-Seata" class="headerlink" title="11 Seata"></a>11 Seata</h2><h3 id="11-1-分布式事务问题由来"><a href="#11-1-分布式事务问题由来" class="headerlink" title="11.1 分布式事务问题由来"></a>11.1 分布式事务问题由来</h3><p>分布式前</p>
<ul>
<li>单机单库没这个问题</li>
<li>从1:1 -&gt; 1:N -&gt; N:N</li>
</ul>
<p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用,分别使用三个独立的数据源，业务操作需要调用三三 个服务来完成。此时<strong>每个服务内部的数据一致性由本地事务来保证， 但是全局的数据一致性问题没法保证</strong>。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/9a619fb6a635ac96f2f17734bcda7967.png" alt></p>
<p>一句话：<strong>一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题</strong>。</p>
<h3 id="11-2-Seata术语"><a href="#11-2-Seata术语" class="headerlink" title="11.2 Seata术语"></a>11.2 Seata术语</h3><p><strong>是什么</strong></p>
<p>Seata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</p>
<p><a href="http://seata.io/zh-cn/">官方网址</a></p>
<p><strong>能干嘛</strong></p>
<p>一个典型的分布式事务过程</p>
<p>分布式事务处理过程的一ID+三组件模型：</p>
<ul>
<li>Transaction ID XID 全局唯一的事务ID</li>
<li>三组件概念<ul>
<li>TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，驱动全局事务提交或回滚。</li>
<li>TM (Transaction Manager) - 事务管理器：定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li>
<li>RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
</li>
</ul>
<p>处理过程：</p>
<ol>
<li>TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID；</li>
<li>XID在微服务调用链路的上下文中传播；</li>
<li>RM向TC注册分支事务，将其纳入XID对应全局事务的管辖；</li>
<li>TM向TC发起针对XID的全局提交或回滚决议；</li>
<li>TC调度XID下管辖的全部分支事务完成提交或回滚请求。</li>
</ol>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/2d2c6aa29c3158413f66d4ef8c1000dc.png" alt></p>
<h3 id="11-3-Seata-Server安装"><a href="#11-3-Seata-Server安装" class="headerlink" title="11.3 Seata-Server安装"></a>11.3 Seata-Server安装</h3><p><strong>去哪下</strong></p>
<p>发布说明: <a href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a></p>
<p><strong>怎么玩</strong></p>
<p>本地@Transactional</p>
<p>全局@GlobalTransactional</p>
<p><strong>SEATA 的分布式交易解决方案</strong></p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/302377d33ddcd708e20b996bd9f2c7b8.png" alt></p>
<p>我们只需要使用一个 <code>@GlobalTransactional</code> 注解在业务方法上:</p>
<p><strong>Seata-Server安装</strong></p>
<p>官网地址 - <a href="http://seata.io/zh-cn/">http://seata.io/zh-cn/</a></p>
<p>下载版本 - 0.9.0</p>
<p>seata-server-0.9.0.zip解压到指定目录并修改conf目录下的file.conf配置文件</p>
<p>先备份原始file.conf文件</p>
<p>主要修改:自定义事务组名称+事务日志存储模式为db +数据库连接信息</p>
<p>file.conf</p>
<p>service模块</p>
<div class="code-wrapper"><pre><code class="hljs nix">service &#123;
    <span class="hljs-comment">##fsp_tx_group是自定义的</span>
    vgroup_mapping.my.test.<span class="hljs-attr">tx_group=&quot;fsp_tx_group&quot;</span> 
    default.<span class="hljs-attr">grouplist</span> = <span class="hljs-string">&quot;127.0.0.1:8091&quot;</span>
    <span class="hljs-attr">enableDegrade</span> = <span class="hljs-literal">false</span>
    <span class="hljs-attr">disable</span> = <span class="hljs-literal">false</span>
    max.commitretry.<span class="hljs-attr">timeout=</span> <span class="hljs-string">&quot;-1&quot;</span>
    max.ollbackretry.<span class="hljs-attr">timeout=</span> <span class="hljs-string">&quot;-1&quot;</span>
&#125;
</code></pre></div>

<p>store模块</p>
<div class="code-wrapper"><pre><code class="hljs nix"><span class="hljs-comment">## transaction log store</span>
store &#123;
	<span class="hljs-comment">## store mode: file, db</span>
	<span class="hljs-comment">## 改成db</span>
	<span class="hljs-attr">mode</span> = <span class="hljs-string">&quot;db&quot;</span>
	
	<span class="hljs-comment">## file store</span>
	file &#123;
		<span class="hljs-attr">dir</span> = <span class="hljs-string">&quot;sessionStore&quot;</span>
		
		<span class="hljs-comment"># branch session size, if exceeded first try compress lockkey, still exceeded throws exceptions</span>
		<span class="hljs-attr">max-branch-session-size</span> = <span class="hljs-number">16384</span>
		<span class="hljs-comment"># globe session size, if exceeded throws exceptions</span>
		<span class="hljs-attr">max-global-session-size</span> = <span class="hljs-number">512</span>
		<span class="hljs-comment"># file buffer size, if exceeded allocate new buffer</span>
		<span class="hljs-attr">file-write-buffer-cache-size</span> = <span class="hljs-number">16384</span>
		<span class="hljs-comment"># when recover batch read size</span>
		session.reload.<span class="hljs-attr">read_size=</span> <span class="hljs-number">100</span>
		<span class="hljs-comment"># async, sync</span>
		<span class="hljs-attr">flush-disk-mode</span> = async
	&#125;

	<span class="hljs-comment"># database store</span>
	db &#123;
		<span class="hljs-comment">## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span>
		<span class="hljs-attr">datasource</span> = <span class="hljs-string">&quot;dbcp&quot;</span>
		<span class="hljs-comment">## mysql/oracle/h2/oceanbase etc.</span>
		<span class="hljs-comment">## 配置数据源</span>
		<span class="hljs-attr">db-type</span> = <span class="hljs-string">&quot;mysql&quot;</span>
		<span class="hljs-attr">driver-class-name</span> = <span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>
		<span class="hljs-attr">url</span> = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/seata?serverTimezone=GMT&quot;</span>
		<span class="hljs-attr">user</span> = <span class="hljs-string">&quot;root&quot;</span>
		<span class="hljs-attr">password</span> = <span class="hljs-string">&quot;你自己密码&quot;</span>
		<span class="hljs-attr">min-conn=</span> <span class="hljs-number">1</span>
		<span class="hljs-attr">max-conn</span> = <span class="hljs-number">3</span>
		global.<span class="hljs-attr">table</span> = <span class="hljs-string">&quot;global_table&quot;</span>
		branch.<span class="hljs-attr">table</span> = <span class="hljs-string">&quot;branch_table&quot;</span>
		<span class="hljs-attr">lock-table</span> = <span class="hljs-string">&quot;lock_table&quot;</span>
		<span class="hljs-attr">query-limit</span> = <span class="hljs-number">100</span>
	&#125;
&#125;</code></pre></div>

<p>mysql5.7数据库新建库seata，在seata库里建表</p>
<p>建表db_store.sql在\seata-server-0.9.0\seata\conf目录里面</p>
<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- the table to store GlobalSession data</span>
<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> `global_table`;
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> `global_table` (
  `xid` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>)  <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,
  `transaction_id` <span class="hljs-type">bigint</span>,
  `status` tinyint <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,
  `application_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>),
  `transaction_service_group` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>),
  `transaction_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>),
  `timeout` <span class="hljs-type">int</span>,
  `begin_time` <span class="hljs-type">bigint</span>,
  `application_data` <span class="hljs-type">varchar</span>(<span class="hljs-number">2000</span>),
  `gmt_create` datetime,
  `gmt_modified` datetime,
  <span class="hljs-keyword">primary</span> key (`xid`),
  key `idx_gmt_modified_status` (`gmt_modified`, `status`),
  key `idx_transaction_id` (`transaction_id`)
);

<span class="hljs-comment">-- the table to store BranchSession data</span>
<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> `branch_table`;
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> `branch_table` (
  `branch_id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,
  `xid` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,
  `transaction_id` <span class="hljs-type">bigint</span> ,
  `resource_group_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>),
  `resource_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) ,
  `lock_key` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) ,
  `branch_type` <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>) ,
  `status` tinyint,
  `client_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>),
  `application_data` <span class="hljs-type">varchar</span>(<span class="hljs-number">2000</span>),
  `gmt_create` datetime,
  `gmt_modified` datetime,
  <span class="hljs-keyword">primary</span> key (`branch_id`),
  key `idx_xid` (`xid`)
);

<span class="hljs-comment">-- the table to store lock data</span>
<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> `lock_table`;
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> `lock_table` (
  `row_key` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,
  `xid` <span class="hljs-type">varchar</span>(<span class="hljs-number">96</span>),
  `transaction_id` long ,
  `branch_id` long,
  `resource_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) ,
  `table_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) ,
  `pk` <span class="hljs-type">varchar</span>(<span class="hljs-number">36</span>) ,
  `gmt_create` datetime ,
  `gmt_modified` datetime,
  <span class="hljs-keyword">primary</span> key(`row_key`)
);</code></pre></div>

<p>修改seata-server-0.9.0\seata\conf目录下的registry.conf配置文件</p>
<div class="code-wrapper"><pre><code class="hljs nix">registry &#123;
  <span class="hljs-comment"># file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span>
  <span class="hljs-comment"># 改用为nacos</span>
  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;nacos&quot;</span>

  nacos &#123;
  	<span class="hljs-comment">## 加端口号</span>
    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost:8848&quot;</span>
    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span>
  &#125;
  ...
&#125;</code></pre></div>

<p>目的是：指明注册中心为nacos，及修改nacos连接信息</p>
<p>先启动Nacos端口号8848 nacos\bin\startup.cmd</p>
<p>再启动seata-server - seata-server-0.9.0\seata\bin\seata-server.bat</p>
<h3 id="11-4-Seata业务数据库准备"><a href="#11-4-Seata业务数据库准备" class="headerlink" title="11.4 Seata业务数据库准备"></a>11.4 Seata业务数据库准备</h3><p>以下演示都需要先启动Nacos后启动Seata,保证两个都OK。</p>
<p>分布式事务业务说明</p>
<p>这里我们会创建三个服务，一个订单服务，一个库存服务，一个账户服务。</p>
<p>当用户下单时,会在订单服务中创建一个订单, 然后通过远程调用库存服务来扣减下单商品的库存，再通过远程调用账户服务来扣减用户账户里面的余额，最后在订单服务中修改订单状态为已完成。</p>
<p>该操作跨越三个数据库，有两次远程调用，很明显会有分布式事务问题。</p>
<p><strong>一言蔽之</strong>，下订单—&gt;扣库存—&gt;减账户(余额)。</p>
<p>创建业务数据库</p>
<ul>
<li>seata_ order：存储订单的数据库;</li>
<li>seata_ storage：存储库存的数据库;</li>
<li>seata_ account：存储账户信息的数据库。</li>
</ul>
<p>建库SQL</p>
<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE seata_order;
<span class="hljs-keyword">CREATE</span> DATABASE seata_storage;
<span class="hljs-keyword">CREATE</span> DATABASE seata_account;</code></pre></div>

<p>按照上述3库分别建对应业务表</p>
<ul>
<li><p>seata_order库下建t_order表</p>
<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_order
(
    `id`         <span class="hljs-type">BIGINT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,
    `user_id`    <span class="hljs-type">BIGINT</span>(<span class="hljs-number">11</span>)     <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户id&#x27;</span>,
    `product_id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">11</span>)     <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;产品id&#x27;</span>,
    `count`      <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)        <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;数量&#x27;</span>,
    `money`      <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">11</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;金额&#x27;</span>,
    `status`     <span class="hljs-type">INT</span>(<span class="hljs-number">1</span>)         <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;订单状态: 0:创建中; 1:已完结&#x27;</span>
) ENGINE <span class="hljs-operator">=</span> INNODB
  AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">7</span>
  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;

<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
<span class="hljs-keyword">FROM</span> t_order;</code></pre></div>
</li>
<li><p>seata_storage库下建t_storage表</p>
<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_storage
(
    `id`         <span class="hljs-type">BIGINT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,
    `product_id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;产品id&#x27;</span>,
    `total`      <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)    <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;总库存&#x27;</span>,
    `used`       <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)    <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;已用库存&#x27;</span>,
    `residue`    <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)    <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;剩余库存&#x27;</span>
) ENGINE <span class="hljs-operator">=</span> INNODB
  AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> seata_storage.t_storage(`id`, `product_id`, `total`, `used`, `residue`)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;100&#x27;</span>);

<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
<span class="hljs-keyword">FROM</span> t_storage;</code></pre></div>
</li>
<li><p>seata_account库下建t_account表</p>
<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_account
(
    `id`      <span class="hljs-type">BIGINT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY COMMENT <span class="hljs-string">&#x27;id&#x27;</span>,
    `user_id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">11</span>)     <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户id&#x27;</span>,
    `total`   <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;总额度&#x27;</span>,
    `used`    <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;已用余额&#x27;</span>,
    `residue` <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;剩余可用额度&#x27;</span>
) ENGINE <span class="hljs-operator">=</span> INNODB
  AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;

<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> seata_account.t_account(`id`, `user_id`, `total`, `used`, `residue`)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1000&#x27;</span>);

<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
<span class="hljs-keyword">FROM</span> t_account;</code></pre></div>

</li>
</ul>
<p>按照上述3库分别建对应的回滚日志表</p>
<ul>
<li><p>订单-库存-账户3个库下<strong>都需要建各自的回滚日志表</strong></p>
</li>
<li><p>\seata-server-0.9.0\seata\conf目录下的db_ undo_ log.sql</p>
</li>
<li><p>建表SQL</p>
<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- the table to store seata xid data</span>
<span class="hljs-comment">-- 0.7.0+ add context</span>
<span class="hljs-comment">-- you must to init this sql for you business databese. the seata server not need it.</span>
<span class="hljs-comment">-- 此脚本必须初始化在你当前的业务数据库中，用于AT 模式XID记录。与server端无关（注：业务数据库）</span>
<span class="hljs-comment">-- 注意此处0.3.0+ 增加唯一索引 ux_undo_log</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `undo_log`
(
    `id`            <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,
    `branch_id`     <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    `xid`           <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    `context`       <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    `rollback_info` longblob     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    `log_status`    <span class="hljs-type">int</span>(<span class="hljs-number">11</span>)      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    `log_created`   datetime     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    `log_modified`  datetime     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    `ext`           <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
    <span class="hljs-keyword">PRIMARY</span> KEY (`id`),
    <span class="hljs-keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`, `branch_id`)
) ENGINE <span class="hljs-operator">=</span> InnoDB
  AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;</code></pre></div>

</li>
</ul>
<h3 id="11-5-Seata之Order-Module配置搭建"><a href="#11-5-Seata之Order-Module配置搭建" class="headerlink" title="11.5 Seata之Order-Module配置搭建"></a>11.5 Seata之Order-Module配置搭建</h3><p>下订单 -&gt; 减库存 -&gt; 扣余额 -&gt; 改（订单）状态</p>
<p>seata-order-service2001</p>
<p>POM</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud2020<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>seata-order-service2001<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--nacos--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--seata--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>seata-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.seata<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.seata<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>seata-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--feign--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--web-actuator--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--mysql-druid--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.37<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

<p>配置文件</p>
<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">2001</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">seata-order-service</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">alibaba:</span>
      <span class="hljs-attr">seata:</span>
        <span class="hljs-comment">#自定义事务组名称需要与seata-server中的对应</span>
        <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">fsp_tx_group</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/seata_order</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>

<span class="hljs-attr">feign:</span>
  <span class="hljs-attr">hystrix:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span>

<span class="hljs-attr">logging:</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">io:</span>
      <span class="hljs-attr">seata:</span> <span class="hljs-string">info</span>

<span class="hljs-attr">mybatis:</span>
  <span class="hljs-attr">mapperLocations:</span> <span class="hljs-string">classpath:mapper/*.xml</span></code></pre></div>

<p>file.conf</p>
<div class="code-wrapper"><pre><code class="hljs nix"><span class="hljs-comment">## transaction log store, only used in seata-server</span>
store &#123;
  <span class="hljs-comment">## store mode: file、db、redis</span>
  <span class="hljs-attr">mode</span> = <span class="hljs-string">&quot;db&quot;</span>
  <span class="hljs-comment">## rsa decryption public key</span>
  <span class="hljs-attr">publicKey</span> = <span class="hljs-string">&quot;&quot;</span>
  <span class="hljs-comment">## file store property</span>
  file &#123;
    <span class="hljs-comment">## store location dir</span>
    <span class="hljs-attr">dir</span> = <span class="hljs-string">&quot;sessionStore&quot;</span>
    <span class="hljs-comment"># branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span>
    <span class="hljs-attr">maxBranchSessionSize</span> = <span class="hljs-number">16384</span>
    <span class="hljs-comment"># globe session size , if exceeded throws exceptions</span>
    <span class="hljs-attr">maxGlobalSessionSize</span> = <span class="hljs-number">512</span>
    <span class="hljs-comment"># file buffer size , if exceeded allocate new buffer</span>
    <span class="hljs-attr">fileWriteBufferCacheSize</span> = <span class="hljs-number">16384</span>
    <span class="hljs-comment"># when recover batch read size</span>
    <span class="hljs-attr">sessionReloadReadSize</span> = <span class="hljs-number">100</span>
    <span class="hljs-comment"># async, sync</span>
    <span class="hljs-attr">flushDiskMode</span> = async
  &#125;

  <span class="hljs-comment">## database store property</span>
  db &#123;
    <span class="hljs-comment">## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp)/HikariDataSource(hikari) etc.</span>
    <span class="hljs-attr">datasource</span> = <span class="hljs-string">&quot;druid&quot;</span>
    <span class="hljs-comment">## mysql/oracle/postgresql/h2/oceanbase etc.</span>
    <span class="hljs-attr">dbType</span> = <span class="hljs-string">&quot;mysql&quot;</span>
    <span class="hljs-attr">driverClassName</span> = <span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>
    <span class="hljs-comment">## if using mysql to store the data, recommend add rewriteBatchedStatements=true in jdbc connection param</span>
    <span class="hljs-attr">url</span> = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/seata?serverTimezone=GMT&quot;</span>
    <span class="hljs-attr">user</span> = <span class="hljs-string">&quot;root&quot;</span>
    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;root&quot;</span>
    <span class="hljs-attr">minConn</span> = <span class="hljs-number">5</span>
    <span class="hljs-attr">maxConn</span> = <span class="hljs-number">100</span>
    <span class="hljs-attr">globalTable</span> = <span class="hljs-string">&quot;global_table&quot;</span>
    <span class="hljs-attr">branchTable</span> = <span class="hljs-string">&quot;branch_table&quot;</span>
    <span class="hljs-attr">lockTable</span> = <span class="hljs-string">&quot;lock_table&quot;</span>
    <span class="hljs-attr">queryLimit</span> = <span class="hljs-number">100</span>
    <span class="hljs-attr">maxWait</span> = <span class="hljs-number">5000</span>
  &#125;

  <span class="hljs-comment">## redis store property</span>
  redis &#123;
    <span class="hljs-comment">## redis mode: single、sentinel</span>
    <span class="hljs-attr">mode</span> = <span class="hljs-string">&quot;single&quot;</span>
    <span class="hljs-comment">## single mode property</span>
    single &#123;
      <span class="hljs-attr">host</span> = <span class="hljs-string">&quot;127.0.0.1&quot;</span>
      <span class="hljs-attr">port</span> = <span class="hljs-string">&quot;6379&quot;</span>
    &#125;
    <span class="hljs-comment">## sentinel mode property</span>
    sentinel &#123;
      <span class="hljs-attr">masterName</span> = <span class="hljs-string">&quot;&quot;</span>
      <span class="hljs-comment">## such as &quot;10.28.235.65:26379,10.28.235.65:26380,10.28.235.65:26381&quot;</span>
      <span class="hljs-attr">sentinelHosts</span> = <span class="hljs-string">&quot;&quot;</span>
    &#125;
    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">database</span> = <span class="hljs-string">&quot;0&quot;</span>
    <span class="hljs-attr">minConn</span> = <span class="hljs-number">1</span>
    <span class="hljs-attr">maxConn</span> = <span class="hljs-number">10</span>
    <span class="hljs-attr">maxTotal</span> = <span class="hljs-number">100</span>
    <span class="hljs-attr">queryLimit</span> = <span class="hljs-number">100</span>
  &#125;
&#125;</code></pre></div>

<p>registry.conf</p>
<div class="code-wrapper"><pre><code class="hljs nix">registry &#123;
  <span class="hljs-comment"># file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span>
  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;nacos&quot;</span>

  nacos &#123;
    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;seata-server&quot;</span>
    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8848&quot;</span>
    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span>
    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span>
    <span class="hljs-attr">username</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;&quot;</span>
  &#125;
  eureka &#123;
    <span class="hljs-attr">serviceUrl</span> = <span class="hljs-string">&quot;http://localhost:8761/eureka&quot;</span>
    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;default&quot;</span>
    <span class="hljs-attr">weight</span> = <span class="hljs-string">&quot;1&quot;</span>
  &#125;
  redis &#123;
    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost:6379&quot;</span>
    <span class="hljs-attr">db</span> = <span class="hljs-number">0</span>
    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span>
    <span class="hljs-attr">timeout</span> = <span class="hljs-number">0</span>
  &#125;
  zk &#123;
    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span>
    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>
    <span class="hljs-attr">sessionTimeout</span> = <span class="hljs-number">6000</span>
    <span class="hljs-attr">connectTimeout</span> = <span class="hljs-number">2000</span>
    <span class="hljs-attr">username</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;&quot;</span>
  &#125;
  consul &#123;
    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span>
    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span>
    <span class="hljs-attr">aclToken</span> = <span class="hljs-string">&quot;&quot;</span>
  &#125;
  etcd3 &#123;
    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span>
    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;http://localhost:2379&quot;</span>
  &#125;
  sofa &#123;
    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:9603&quot;</span>
    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;default&quot;</span>
    <span class="hljs-attr">region</span> = <span class="hljs-string">&quot;DEFAULT_ZONE&quot;</span>
    <span class="hljs-attr">datacenter</span> = <span class="hljs-string">&quot;DefaultDataCenter&quot;</span>
    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span>
    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span>
    <span class="hljs-attr">addressWaitTime</span> = <span class="hljs-string">&quot;3000&quot;</span>
  &#125;
  file &#123;
    <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;file.conf&quot;</span>
  &#125;
&#125;

config &#123;
  <span class="hljs-comment"># file、nacos 、apollo、zk、consul、etcd3</span>
  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;file&quot;</span>

  nacos &#123;
    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8848&quot;</span>
    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span>
    <span class="hljs-attr">username</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">dataId</span> = <span class="hljs-string">&quot;seataServer.properties&quot;</span>
  &#125;
  consul &#123;
    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span>
    <span class="hljs-attr">aclToken</span> = <span class="hljs-string">&quot;&quot;</span>
  &#125;
  apollo &#123;
    <span class="hljs-attr">appId</span> = <span class="hljs-string">&quot;seata-server&quot;</span>
    <span class="hljs-comment">## apolloConfigService will cover apolloMeta</span>
    <span class="hljs-attr">apolloMeta</span> = <span class="hljs-string">&quot;http://192.168.1.204:8801&quot;</span>
    <span class="hljs-attr">apolloConfigService</span> = <span class="hljs-string">&quot;http://192.168.1.204:8080&quot;</span>
    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;application&quot;</span>
    <span class="hljs-attr">apolloAccesskeySecret</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;seata&quot;</span>
  &#125;
  zk &#123;
    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>
    <span class="hljs-attr">sessionTimeout</span> = <span class="hljs-number">6000</span>
    <span class="hljs-attr">connectTimeout</span> = <span class="hljs-number">2000</span>
    <span class="hljs-attr">username</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-attr">nodePath</span> = <span class="hljs-string">&quot;/seata/seata.properties&quot;</span>
  &#125;
  etcd3 &#123;
    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;http://localhost:2379&quot;</span>
  &#125;
  file &#123;
    <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;file.conf&quot;</span>
  &#125;
&#125;</code></pre></div>

<p>domain</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;
<span class="hljs-keyword">import</span> lombok.Data;
<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;

<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonResult</span>&lt;<span class="hljs-title">T</span>&gt;</span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-keyword">private</span> Integer code;
    <span class="hljs-keyword">private</span> String  message;
    <span class="hljs-keyword">private</span> T       data;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CommonResult</span><span class="hljs-params">(Integer code, String message)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">this</span>(code,message,<span class="hljs-keyword">null</span>);
    &#125;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.springcloud.alibaba.domain;

<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;
<span class="hljs-keyword">import</span> lombok.Data;
<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;

<span class="hljs-keyword">import</span> java.math.BigDecimal;

<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-keyword">private</span> Long userId;

    <span class="hljs-keyword">private</span> Long productId;

    <span class="hljs-keyword">private</span> Integer count;

    <span class="hljs-keyword">private</span> BigDecimal money;

    <span class="hljs-keyword">private</span> Integer status; <span class="hljs-comment">//订单状态：0：创建中；1：已完结</span>
&#125;</code></pre></div>

<h3 id="11-6-Seata之Order-Module撸码-上"><a href="#11-6-Seata之Order-Module撸码-上" class="headerlink" title="11.6 Seata之Order-Module撸码(上)"></a>11.6 Seata之Order-Module撸码(上)</h3><p>Dao接口及实现</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.domain.Order;
<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;
<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;

<span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderDao</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-comment">//1 新建订单</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(Order order)</span></span>;

    <span class="hljs-comment">//2 修改订单状态，从零改为1</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userId&quot;)</span> Long userId,<span class="hljs-meta">@Param(&quot;status&quot;)</span> Integer status)</span></span>;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.atguigu.springcloud.alibaba.dao.OrderDao&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.atguigu.springcloud.alibaba.domain.Order&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;product_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;productId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;count&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;count&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;money&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;money&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;DECIMAL&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;status&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;status&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;create&quot;</span>&gt;</span>
        insert into t_order (id,user_id,product_id,count,money,status)
        values (null,#&#123;userId&#125;,#&#123;productId&#125;,#&#123;count&#125;,#&#123;money&#125;,0);
    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>


    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span>
        update t_order set status = 1
        where user_id=#&#123;userId&#125; and status = #&#123;status&#125;;
    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div>

<p>Service接口及实现</p>
<ul>
<li>OrderService<ul>
<li>OrderServiceImpl</li>
</ul>
</li>
<li>StorageService</li>
<li>AccountService</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.domain.Order;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(Order order)</span></span>;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.domain.CommonResult;
<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;

<span class="hljs-keyword">import</span> java.math.BigDecimal;

<span class="hljs-meta">@FeignClient(value = &quot;seata-storage-service&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StorageService</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@PostMapping(value = &quot;/storage/decrease&quot;)</span>
    <span class="hljs-function">CommonResult <span class="hljs-title">decrease</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;productId&quot;)</span> Long productId, <span class="hljs-meta">@RequestParam(&quot;count&quot;)</span> Integer count)</span></span>;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.domain.CommonResult;
<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;

<span class="hljs-keyword">import</span> java.math.BigDecimal;

<span class="hljs-meta">@FeignClient(value = &quot;seata-account-service&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountService</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@PostMapping(value = &quot;/account/decrease&quot;)</span>
    <span class="hljs-function">CommonResult <span class="hljs-title">decrease</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="hljs-meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span></span>;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.dao.OrderDao;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.domain.Order;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.service.AccountService;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.service.OrderService;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.service.StorageService;
<span class="hljs-keyword">import</span> io.seata.spring.annotation.GlobalTransactional;
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-keyword">import</span> javax.annotation.Resource;

<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> OrderDao orderDao;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> StorageService storageService;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> AccountService accountService;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span>
<span class="hljs-comment">     * 简单说：下订单-&gt;扣库存-&gt;减余额-&gt;改状态</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-comment">//@GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(Order order)</span></span>
<span class="hljs-function">    </span>&#123;
        log.info(<span class="hljs-string">&quot;-----&gt;开始新建订单&quot;</span>);
        <span class="hljs-comment">//1 新建订单</span>
        orderDao.create(order);

        <span class="hljs-comment">//2 扣减库存</span>
        log.info(<span class="hljs-string">&quot;-----&gt;订单微服务开始调用库存，做扣减Count&quot;</span>);
        storageService.decrease(order.getProductId(),order.getCount());
        log.info(<span class="hljs-string">&quot;-----&gt;订单微服务开始调用库存，做扣减end&quot;</span>);

        <span class="hljs-comment">//3 扣减账户</span>
        log.info(<span class="hljs-string">&quot;-----&gt;订单微服务开始调用账户，做扣减Money&quot;</span>);
        accountService.decrease(order.getUserId(),order.getMoney());
        log.info(<span class="hljs-string">&quot;-----&gt;订单微服务开始调用账户，做扣减end&quot;</span>);

        <span class="hljs-comment">//4 修改订单状态，从零到1,1代表已经完成</span>
        log.info(<span class="hljs-string">&quot;-----&gt;修改订单状态开始&quot;</span>);
        orderDao.update(order.getUserId(),<span class="hljs-number">0</span>);
        log.info(<span class="hljs-string">&quot;-----&gt;修改订单状态结束&quot;</span>);

        log.info(<span class="hljs-string">&quot;-----&gt;下订单结束了，O(∩_∩)O哈哈~&quot;</span>);

    &#125;
&#125;</code></pre></div>

<h3 id="11-7-Seata之Order-Module撸码-下"><a href="#11-7-Seata之Order-Module撸码-下" class="headerlink" title="11.7 Seata之Order-Module撸码(下)"></a>11.7 Seata之Order-Module撸码(下)</h3><p>controller</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.domain.CommonResult;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.domain.Order;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.service.OrderService;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-keyword">import</span> javax.annotation.Resource;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> OrderService orderService;


    <span class="hljs-meta">@GetMapping(&quot;/order/create&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">create</span><span class="hljs-params">(Order order)</span></span>
<span class="hljs-function">    </span>&#123;
        orderService.create(order);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;订单创建成功&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>Config配置</p>
<ul>
<li>MyBatisConfig</li>
<li>DataSourceProxyConfig</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@MapperScan(&#123;&quot;com.atguigu.springcloud.alibaba.dao&quot;&#125;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfig</span> </span>&#123;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java">主启动<span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;
<span class="hljs-keyword">import</span> io.seata.rm.datasource.DataSourceProxy;
<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;
<span class="hljs-keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;
<span class="hljs-keyword">import</span> org.mybatis.spring.transaction.SpringManagedTransactionFactory;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;
<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;
<span class="hljs-keyword">import</span> javax.sql.DataSource;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 使用Seata对数据源进行代理</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceProxyConfig</span> </span>&#123;

    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span>
    <span class="hljs-keyword">private</span> String mapperLocations;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceProxy <span class="hljs-title">dataSourceProxy</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProxy(dataSource);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactoryBean</span><span class="hljs-params">(DataSourceProxy dataSourceProxy)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSourceProxy);
        sqlSessionFactoryBean.setMapperLocations(<span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver().getResources(mapperLocations));
        sqlSessionFactoryBean.setTransactionFactory(<span class="hljs-keyword">new</span> SpringManagedTransactionFactory());
        <span class="hljs-keyword">return</span> sqlSessionFactoryBean.getObject();
    &#125;

&#125;</code></pre></div>

<p>主启动</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
<span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;
<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;

<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@EnableFeignClients</span>
<span class="hljs-comment">//取消数据源的自动创建，而是使用自己定义的</span>
<span class="hljs-meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeataOrderMainApp2001</span></span>
<span class="hljs-class"></span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>
<span class="hljs-function">    </span>&#123;
        SpringApplication.run(SeataOrderMainApp2001.class, args);
    &#125;
&#125;</code></pre></div>

<h3 id="11-8-Seata之Storage-Module说明"><a href="#11-8-Seata之Storage-Module说明" class="headerlink" title="11.8 Seata之Storage-Module说明"></a>11.8 Seata之Storage-Module说明</h3><p>与seata-order-service2001模块大致相同</p>
<p>seata-storage-service2002</p>
<p>POM（与seata-order-service2001模块大致相同）</p>
<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">2002</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">seata-storage-service</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">alibaba:</span>
      <span class="hljs-attr">seata:</span>
        <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">fsp_tx_group</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/seata_storage</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>

<span class="hljs-attr">logging:</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">io:</span>
      <span class="hljs-attr">seata:</span> <span class="hljs-string">info</span>

<span class="hljs-attr">mybatis:</span>
  <span class="hljs-attr">mapperLocations:</span> <span class="hljs-string">classpath:mapper/*.xml</span></code></pre></div>

<p>file.conf（与seata-order-service2001模块大致相同）</p>
<p>registry.conf（与seata-order-service2001模块大致相同）</p>
<p>domain</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Data;

<span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Storage</span> </span>&#123;

    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 产品id</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> Long productId;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 总库存</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> Integer total;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 已用库存</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> Integer used;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 剩余库存</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> Integer residue;
&#125;</code></pre></div>

<p>CommonResult（与seata-order-service2001模块大致相同）</p>
<p>Dao接口及实现</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;
<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;

<span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StorageDao</span> </span>&#123;

    <span class="hljs-comment">//扣减库存</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;productId&quot;)</span> Long productId, <span class="hljs-meta">@Param(&quot;count&quot;)</span> Integer count)</span></span>;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.atguigu.springcloud.alibaba.dao.StorageDao&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.atguigu.springcloud.alibaba.domain.Storage&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;product_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;productId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;total&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;total&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;used&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;used&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;residue&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;residue&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;decrease&quot;</span>&gt;</span>
        UPDATE
            t_storage
        SET
            used = used + #&#123;count&#125;,residue = residue - #&#123;count&#125;
        WHERE
            product_id = #&#123;productId&#125;
    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div>

<p>Service接口及实现</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StorageService</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 扣减库存</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(Long productId, Integer count)</span></span>;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.dao.StorageDao;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.service.StorageService ;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-keyword">import</span> javax.annotation.Resource;


<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StorageServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StorageService</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(StorageServiceImpl.class);

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> StorageDao storageDao;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 扣减库存</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(Long productId, Integer count)</span> </span>&#123;
        LOGGER.info(<span class="hljs-string">&quot;-------&gt;storage-service中扣减库存开始&quot;</span>);
        storageDao.decrease(productId,count);
        LOGGER.info(<span class="hljs-string">&quot;-------&gt;storage-service中扣减库存结束&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>Controller</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.domain.CommonResult ;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.service.StorageService ;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StorageController</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> StorageService storageService;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 扣减库存</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@RequestMapping(&quot;/storage/decrease&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">decrease</span><span class="hljs-params">(Long productId, Integer count)</span> </span>&#123;
        storageService.decrease(productId, count);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;扣减库存成功！&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>Config配置（与seata-order-service2001模块大致相同）</p>
<p>主启动（与seata-order-service2001模块大致相同）</p>
<h3 id="11-9-Seata之Account-Module说明"><a href="#11-9-Seata之Account-Module说明" class="headerlink" title="11.9 Seata之Account-Module说明"></a>11.9 Seata之Account-Module说明</h3><p>与seata-order-service2001模块大致相同</p>
<p>seata-account-service2003</p>
<p>POM（与seata-order-service2001模块大致相同）</p>
<p>YML</p>
<div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">2003</span>

<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">seata-account-service</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">alibaba:</span>
      <span class="hljs-attr">seata:</span>
        <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">fsp_tx_group</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">discovery:</span>
        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/seata_account</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>

<span class="hljs-attr">feign:</span>
  <span class="hljs-attr">hystrix:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span>

<span class="hljs-attr">logging:</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">io:</span>
      <span class="hljs-attr">seata:</span> <span class="hljs-string">info</span>

<span class="hljs-attr">mybatis:</span>
  <span class="hljs-attr">mapperLocations:</span> <span class="hljs-string">classpath:mapper/*.xml</span></code></pre></div>

<p>file.conf（与seata-order-service2001模块大致相同）</p>
<p>registry.conf（与seata-order-service2001模块大致相同）</p>
<p>domain</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;
<span class="hljs-keyword">import</span> lombok.Data;
<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;

<span class="hljs-keyword">import</span> java.math.BigDecimal;

<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;

    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 用户id</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> Long userId;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 总额度</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> BigDecimal total;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 已用额度</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> BigDecimal used;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 剩余额度</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> BigDecimal residue;
&#125;</code></pre></div>

<p>CommonResult（与seata-order-service2001模块大致相同）</p>
<p>Dao接口及实现</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;
<span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;

<span class="hljs-keyword">import</span> java.math.BigDecimal;

<span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountDao</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 扣减账户余额</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="hljs-meta">@Param(&quot;money&quot;)</span> BigDecimal money)</span></span>;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.atguigu.springcloud.alibaba.dao.AccountDao&quot;</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.atguigu.springcloud.alibaba.domain.Account&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;total&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;total&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;DECIMAL&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;used&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;used&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;DECIMAL&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;residue&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;residue&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;DECIMAL&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;decrease&quot;</span>&gt;</span>
        UPDATE t_account
        SET
          residue = residue - #&#123;money&#125;,used = used + #&#123;money&#125;
        WHERE
          user_id = #&#123;userId&#125;;
    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div>

<p>Service接口及实现</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;

<span class="hljs-keyword">import</span> java.math.BigDecimal;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccountService</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 扣减账户余额</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId 用户id</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> money 金额</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="hljs-meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span></span>;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.dao.AccountDao;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.service.AccountService ;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-keyword">import</span> javax.annotation.Resource;
<span class="hljs-keyword">import</span> java.math.BigDecimal;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccountService</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AccountServiceImpl.class);


    <span class="hljs-meta">@Resource</span>
    AccountDao accountDao;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 扣减账户余额</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(Long userId, BigDecimal money)</span> </span>&#123;
        LOGGER.info(<span class="hljs-string">&quot;-------&gt;account-service中扣减账户余额开始&quot;</span>);
        accountDao.decrease(userId,money);
        LOGGER.info(<span class="hljs-string">&quot;-------&gt;account-service中扣减账户余额结束&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>Controller</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.domain.CommonResult ;
<span class="hljs-keyword">import</span> com.atguigu.springcloud.alibaba.service.AccountService ;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-keyword">import</span> javax.annotation.Resource;
<span class="hljs-keyword">import</span> java.math.BigDecimal;

<span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountController</span> </span>&#123;

    <span class="hljs-meta">@Resource</span>
    AccountService accountService;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 扣减账户余额</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@RequestMapping(&quot;/account/decrease&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">decrease</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;userId&quot;)</span> Long userId, <span class="hljs-meta">@RequestParam(&quot;money&quot;)</span> BigDecimal money)</span></span>&#123;
        accountService.decrease(userId,money);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;扣减账户余额成功！&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>Config配置（与seata-order-service2001模块大致相同）</p>
<p>主启动（与seata-order-service2001模块大致相同）</p>
<h3 id="11-10-Seata之-GlobalTransactional验证"><a href="#11-10-Seata之-GlobalTransactional验证" class="headerlink" title="11.10 Seata之@GlobalTransactional验证"></a>11.10 Seata之@GlobalTransactional验证</h3><p>下订单 -&gt; 减库存 -&gt; 扣余额 -&gt; 改（订单）状态</p>
<p>数据库初始情况：</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/e639c859e870eebd847d579347ed8755.png" alt></p>
<p>正常下单 - <a href="http://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100">http://localhost:2001/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100</a></p>
<p>数据库正常下单后状况：</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/32401b689cf9a7d624fd0f2aea7ce414.png" alt></p>
<p><strong>超时异常，没加@GlobalTransactional</strong></p>
<p>模拟AccountServiceImpl添加超时</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccountService</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AccountServiceImpl.class);


    <span class="hljs-meta">@Resource</span>
    AccountDao accountDao;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 扣减账户余额</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">(Long userId, BigDecimal money)</span> </span>&#123;
        LOGGER.info(<span class="hljs-string">&quot;-------&gt;account-service中扣减账户余额开始&quot;</span>);
        <span class="hljs-comment">//模拟超时异常，全局事务回滚</span>
        <span class="hljs-comment">//暂停几秒钟线程</span>
        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">20</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;
        accountDao.decrease(userId,money);
        LOGGER.info(<span class="hljs-string">&quot;-------&gt;account-service中扣减账户余额结束&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>另外，OpenFeign的调用默认时间是1s以内，所以最后会抛异常。</p>
<p>数据库情况</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/af40cc3756cef7179e58c813ed404db3.png" alt></p>
<p><strong>故障情况</strong></p>
<ul>
<li>当库存和账户金额扣减后，订单状态并没有设置为已经完成，没有从零改为1</li>
<li>而且由于feign的重试机制，账户余额还有可能被多次扣减</li>
</ul>
<p><strong>超时异常，加了@GlobalTransactional</strong></p>
<p>用@GlobalTransactional标注OrderServiceImpl的create()方法。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;
    
    ...

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span>
<span class="hljs-comment">     * 简单说：下订单-&gt;扣库存-&gt;减余额-&gt;改状态</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-comment">//rollbackFor = Exception.class表示对任意异常都进行回滚</span>
    <span class="hljs-meta">@GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(Order order)</span></span>
<span class="hljs-function">    </span>&#123;
		...
    &#125;
&#125;</code></pre></div>

<p>还是模拟AccountServiceImpl添加超时，下单后数据库数据并没有任何改变，记录都添加不进来，<strong>达到出异常，数据库回滚的效果</strong>。</p>
<h3 id="11-11-Seata之原理简介"><a href="#11-11-Seata之原理简介" class="headerlink" title="11.11 Seata之原理简介"></a>11.11 Seata之原理简介</h3><p>2019年1月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。</p>
<p>Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架。</p>
<p>2020起始，用1.0以后的版本。Alina Gingertail</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/2d2c6aa29c3158413f66d4ef8c1000dc.png" alt></p>
<p><strong>分布式事务的执行流程</strong></p>
<ul>
<li>TM开启分布式事务(TM向TC注册全局事务记录) ;</li>
<li>按业务场景，编排数据库、服务等事务内资源(RM向TC汇报资源准备状态) ;</li>
<li>TM结束分布式事务，事务一阶段结束(TM通知TC提交/回滚分布式事务) ;</li>
<li>TC汇总事务信息，决定分布式事务是提交还是回滚；</li>
<li>TC通知所有RM提交/回滚资源，事务二阶段结束。</li>
</ul>
<p><strong>AT模式如何做到对业务的无侵入</strong></p>
<ul>
<li><p>是什么</p>
<blockquote>
<p>  <strong>前提</strong></p>
<ul>
<li>基于支持本地 ACID 事务的关系型数据库。</li>
<li>Java 应用，通过 JDBC 访问数据库。</li>
</ul>
<p>  <strong>整体机制</strong></p>
<p>  两阶段提交协议的演变：</p>
<ul>
<li><p>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</p>
</li>
<li><p>二阶段：</p>
<ul>
<li>提交异步化，非常快速地完成。</li>
<li></li>
<li><ul>
<li>回滚通过一阶段的回滚日志进行反向补偿。</li>
</ul>
</li>
</ul>
<p><a href="http://seata.io/zh-cn/docs/overview/what-is-seata.html">link</a></p>
</li>
</ul>
</blockquote>
</li>
<li><p>一阶段加载</p>
</li>
</ul>
<p>在一阶段，Seata会拦截“业务SQL”</p>
<ol>
<li>解析SQL语义，找到“业务SQL” 要更新的业务数据，在业务数据被更新前，将其保存成”before image”</li>
<li>执行“业务SQL” 更新业务数据，在业务数据更新之后,</li>
<li>其保存成”after image”，最后生成行锁。</li>
</ol>
<p>以上操作全部在一个数据库事务内完成, 这样保证了一阶段操作的原子性。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/80a7bd6cacef78392b278af04d446562.png" alt></p>
<ul>
<li>二阶段提交</li>
</ul>
<p>二阶段如果顺利提交的话，因为”业务SQL”在一阶段已经提交至数据库，所以Seata框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/a16483118166481bd7f9d06f91a28146.png" alt></p>
<ul>
<li>二阶段回滚</li>
</ul>
<p>二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的 “业务SQL”，还原业务数据。</p>
<p>回滚方式便是用”before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和”after image”。</p>
<p>如果两份数据完全一致就说明没有脏写， 可以还原业务数据，如果不一致就说明有脏写, 出现脏写就需要转人工处理。</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/828b79e4c7679ce5f09069e551c2a717.png" alt></p>
<p>补充</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/21da4fdc4260008c3324574abc33f0ae.png" alt></p>
<h2 id="12-面试补充"><a href="#12-面试补充" class="headerlink" title="12 面试补充"></a>12 面试补充</h2><h3 id="12-1-雪花算法-上"><a href="#12-1-雪花算法-上" class="headerlink" title="12.1 雪花算法(上)"></a>12.1 雪花算法(上)</h3><p><strong>为什么需要分布式全局唯一ID以及分布式ID的业务需求？集群高并发情况下如何保证分布式唯一全局Id生成？</strong></p>
<p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识，如在美团点评的金融、支付、餐饮、酒店，猫眼电影等产品的系统中数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息。特别一点的如订单、骑手、优惠券也都雷要有唯一ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。</p>
<p><strong>ID生成规则部分硬性要求</strong></p>
<ul>
<li><p><em>全局唯一</em>：不能出现重复的ID号，既然是唯一-标识，这是最基本的要求</p>
</li>
<li><p><em>趋势递增</em>：在MySQL的InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用Btree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</p>
</li>
<li><p><em>单调递增</em>：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求</p>
</li>
<li><p><em>信息安全</em>：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可。如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，需要ID无规则不规则，让竞争对手否好猜。</p>
</li>
<li><p><em>含时间戳</em>：这样就能够在开发中快速了解这个分布式id的生成时间。</p>
</li>
</ul>
<p><strong>ID号生成系统的可用性要求</strong></p>
<ul>
<li><em>高可用</em>：发一个获取分布式ID的请求，服务器就要保证99.999%的情况下给我创建一个唯一分布式ID。</li>
<li><em>低延迟</em>：发一个获取分布式ID的请求，服务器就要快，极速。</li>
<li><em>高QPS</em>：假如并发一口气10万个创建分布式ID请求同时杀过来，服务器要顶的住且一下子成功创建10万个分布式ID。</li>
</ul>
<p><strong>一般通用方案</strong></p>
<p><em>UUID</em></p>
<p>UUID(Universally Unique ldentifer)的标准型式包含32个16进制数字，以连了号分为五段，形式为8-4-4-4-12的36个字符， 示例：550e8400-e29b-41d4-a716-446655440000</p>
<p>性能非常高：本地生成，没有网络消耗</p>
<p>如果只是考虑唯一性，那就选用它吧</p>
<p>但是，入数据库性能差</p>
<p><strong>为什么无序的UUID会导致入库性能变差呢？</strong></p>
<ol>
<li>无序，无法预测他的生成顺序，不能生成递增有序的数字。首先分布式ID一般都会作为主键， 但是安装MySQL官方推荐主键要尽量越短越好，UUID每一个都很长，所以不是很推荐。</li>
<li>主键，ID作为主键时在特定的环境会存在一些问题。比如做DB主键的场景下，UUID就非常不适用MySQL官方有明确的建议主键要尽量越短越好36个字符长度的UUID不符合要求。</li>
<li>索引，既然分布式ID是主键，然后主键是包含索引的，然后MySQL的索引是通过B+树来实现的，每一次新的UUID数据的插入，为了查询的优化，都会对索引底层的B+树进行修改，因为UUID数据是无序的，所以每一次UUID数据的插入都会对主键的的B+树进行很大的修改，这一点很不好。 插入完全无序，不但会导致一-些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。</li>
</ol>
<blockquote>
<p>  All indexes other than the clustered index are known as <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_secondary_index">secondary indexes</a>. In InnoDB, each record in a secondary index contains the primary key columns for the row, as well as the columns specified for the secondary index. InnoDB uses this primary key value to search for the row in the clustered index.</p>
<p>  If the primary key is long, the secondary indexes use more space, so it is advantageous to have a short primary key.</p>
<p>  <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html">link</a></p>
</blockquote>
<p><strong>数据库自增主键</strong></p>
<p><em>单机</em></p>
<p>在单机里面，数据库的自增ID机制的主要原理是：数据库自增ID和MySQL数据库的replace into实现的。</p>
<p>REPLACE INTO的含义是插入一条记录，如果表中唯一索引的值遇到冲突，则替换老数据。</p>
<p>这里的replace into跟inset功能类似，不同点在于：replace into首先尝试插入数据列表中，如果发现表中已经有此行数据（根据主键或唯一索引判断）则先删除，再插入。否则直接插入新数据。</p>
<div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_test(
	id <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,
	stub <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,
	<span class="hljs-keyword">UNIQUE</span> KEY stub(stub)
)

<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> FROMt_ test;

REPLACE <span class="hljs-keyword">INTO</span> t_test (stub) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;b&#x27;</span>);

<span class="hljs-keyword">SELECT</span> LAST_INSERT_ID();</code></pre></div>

<p><em>集群分布式</em></p>
<p>那数据库自增ID机制适合作分布式ID吗？答案是不太适合</p>
<ol>
<li><p>系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1，2，3，4，5（步长是1），这<br>个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，貌似还好，现在想象一下如果我们线上有100台机器，这<br>个时候要扩容该怎么做？简直是噩梦，所以系统水平扩展方案复杂难以实现。</p>
</li>
<li><p>数据库压力还是很大，每次获取ID都得读写一次数据库， 非常影响性能，不符合分布式ID里面的延迟低和要高QPS的规则（在高并发下，如果都去数据库里面获取id，那是非常影响性能的）</p>
<p>基于Redis生成全局ID策略</p>
<p>因为Redis是单线的天生保证原子性，可以使用原子操作INCR和INCRBY来实现</p>
</li>
</ol>
<p>注意：在Redis集群情况下，同样和MySQL一样需要设置不同的增长步长，同时key一定要设置有效期可以使用Redis集群来获取更高的吞吐量。</p>
<p>假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。</p>
<p>各个Redis生成的ID为:</p>
<p>A：1, 6, 11, 16, 21<br>B：2, 7 , 12, 17, 22<br>C：3, 8, 13, 18, 23<br>D：4, 9, 14, 19, 24<br>E：5, 10, 15, 20, 25</p>
<h3 id="12-2-雪花算法-下"><a href="#12-2-雪花算法-下" class="headerlink" title="12.2 雪花算法(下)"></a>12.2 雪花算法(下)</h3><p>Twitter的分布式自增ID算法snowflake</p>
<p><strong>概述</strong></p>
<p>Twitter的snowflake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra（由Facebook开发一套开源分布式NoSQL数据库系统）。因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一生成服务。</p>
<p>Twitter的分布式雪花算法SnowFlake ，经测试snowflake 每秒能够产生26万个自增可排序的ID</p>
<ol>
<li>Twitter的SnowFlake生成ID能够按照时间有序生成。</li>
<li>SnowFlake算法生成ID的结果是一个64bit大小的整数， 为一个Long型（转换成字符串后长度最多19）。</li>
<li>分布式系统内不会产生ID碰撞（由datacenter和workerld作区分）并且效率较高。</li>
</ol>
<p>分布式系统中，有一些需要使用全局唯一ID的场景， 生成ID的基本要求：</p>
<ol>
<li>在分布式的环境下必须全局且唯一 。</li>
<li>一般都需要单调递增，因为一般唯一ID都会存到数据库，而Innodb的特性就是将内容存储在主键索引树上的叶子节点而且是从左往右，递增的，所以考<br>虑到数据库性能，一般生成的ID也最好是单调递增。 为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点， 首先他相对比较长， 另外UUID一般是无序的。</li>
<li>可能还会需要无规则，因为如果使用唯一ID作为订单号这种，为了不然别人知道一天的订单量是多少，就需要这个规则。</li>
</ol>
<p><strong>结构</strong></p>
<p>雪花算法的几个核心组成部分：</p>
<p><img src="/2021/04/04/SpringCloud%E5%AD%A6%E4%B9%A0/795b3d1fa01bbd15d8b7b85c2724bf42.png" alt></p>
<p>号段解析：</p>
<p>1bit：</p>
<p>不用，因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0。</p>
<p>41bit - 时间戳，用来记录时间戳，毫秒级：</p>
<ul>
<li>41位可以表示2^41 − 1个数字。</li>
<li>如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0到2^41-1, <strong>减1是因为可表示的数值范围是从0开始算的，而不是1。</strong></li>
<li>也就是说41位可以表示2^41 − 1 个毫秒的值，转化成单位年则是( 2^41 − 1 ) / ( 1000 ∗ 60 ∗ 60 ∗ 24 ∗ 365 ) = 69 年。</li>
</ul>
<p>10bit - 工作机器ID，用来记录工作机器ID：</p>
<ul>
<li><p>可以部署在2^10 = 1024 包括5位DataCenterId和5位Workerld。</p>
</li>
<li><p>5位(bit) 可以表示的最大正整数是2^5 − 1=31,即可以用0、1、2、3、…31这32个数字，来表示不同的DataCenterld或Workerld。</p>
</li>
</ul>
<p>12bit - 序列号，用来记录同毫秒内产生的不同id。</p>
<ul>
<li>12位(bit) 可以表示的最大正整数是2^12 − 1 = 4095 , 即可以用0、1、2、 3、…4094这4095个数字，来表示同一机器同一时间截(毫秒)内产生的4095个ID序号。</li>
</ul>
<p>SnowFlake可以保证：</p>
<ul>
<li>所有生成的ID按时间趋势递增。</li>
<li>整个分布式系统内不会产生重复id（因为有DataCenterId和Workerld来做区分)</li>
</ul>
<p><strong>源码</strong></p>
<p>以下代码仅供学习：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Twitter_Snowflake</span>
<span class="hljs-comment"> * SnowFlake的结构如下(每部分用-分开):</span>
<span class="hljs-comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000</span>
<span class="hljs-comment"> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0</span>
<span class="hljs-comment"> * 41位时间戳(毫秒级)，注意，41位时间戳不是存储当前时间的时间戳，而是存储时间戳的差值（当前时间戳 - 开始时间戳)</span>
<span class="hljs-comment"> * 得到的值），这里的的开始时间戳，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下面程序SnowflakeIdWorker类的startTime属性）。41位的时间戳，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69</span>
<span class="hljs-comment"> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId</span>
<span class="hljs-comment"> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间戳)产生4096个ID序号</span>
<span class="hljs-comment"> * 加起来刚好64位，为一个Long型。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SnowflakeIdWorker</span> </span>&#123;
    <span class="hljs-comment">/** 开始时间戳 (2015-01-01) */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> twepoch = <span class="hljs-number">1420041600000L</span>;

    <span class="hljs-comment">/** 机器id所占的位数 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> workerIdBits = <span class="hljs-number">5L</span>;

    <span class="hljs-comment">/** 数据标识id所占的位数 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> datacenterIdBits = <span class="hljs-number">5L</span>;

    <span class="hljs-comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> maxWorkerId = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; workerIdBits);

    <span class="hljs-comment">/** 支持的最大数据标识id，结果是31 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> maxDatacenterId = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; datacenterIdBits);

    <span class="hljs-comment">/** 序列在id中占的位数 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequenceBits = <span class="hljs-number">12L</span>;

    <span class="hljs-comment">/** 机器ID向左移12位 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> workerIdShift = sequenceBits;

    <span class="hljs-comment">/** 数据标识id向左移17位(12+5) */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;

    <span class="hljs-comment">/** 时间戳向左移22位(5+5+12) */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;

    <span class="hljs-comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequenceMask = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; sequenceBits);

    <span class="hljs-comment">/** 工作机器ID(0~31) */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> workerId;

    <span class="hljs-comment">/** 数据中心ID(0~31) */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> datacenterId;

    <span class="hljs-comment">/** 毫秒内序列(0~4095) */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sequence = <span class="hljs-number">0L</span>;

    <span class="hljs-comment">/** 上次生成ID的时间戳 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastTimestamp = -<span class="hljs-number">1L</span>;

    <span class="hljs-comment">//==============================Constructors=====================================</span>
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 构造函数</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> workerId 工作ID (0~31)</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> datacenterId 数据中心ID (0~31)</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SnowflakeIdWorker</span><span class="hljs-params">(<span class="hljs-keyword">long</span> workerId, <span class="hljs-keyword">long</span> datacenterId)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));
        &#125;
        <span class="hljs-keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));
        &#125;
        <span class="hljs-keyword">this</span>.workerId = workerId;
        <span class="hljs-keyword">this</span>.datacenterId = datacenterId;
    &#125;

    <span class="hljs-comment">// ==============================Methods==========================================</span>
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 获得下一个ID (该方法是线程安全的)</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SnowflakeId</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">long</span> timestamp = timeGen();

        <span class="hljs-comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span>
        <span class="hljs-keyword">if</span> (timestamp &lt; lastTimestamp) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(
                    String.format(<span class="hljs-string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));
        &#125;

        <span class="hljs-comment">//如果是同一时间生成的，则进行毫秒内序列</span>
        <span class="hljs-keyword">if</span> (lastTimestamp == timestamp) &#123;
            sequence = (sequence + <span class="hljs-number">1</span>) &amp; sequenceMask;
            <span class="hljs-comment">//毫秒内序列溢出</span>
            <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">//阻塞到下一个毫秒,获得新的时间戳</span>
                timestamp = tilNextMillis(lastTimestamp);
            &#125;
        &#125;
        <span class="hljs-comment">//时间戳改变，毫秒内序列重置</span>
        <span class="hljs-keyword">else</span> &#123;
            sequence = <span class="hljs-number">0L</span>;
        &#125;

        <span class="hljs-comment">//上次生成ID的时间戳</span>
        lastTimestamp = timestamp;

        <span class="hljs-comment">//移位并通过或运算拼到一起组成64位的ID</span>
        <span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="hljs-comment">//</span>
                | (datacenterId &lt;&lt; datacenterIdShift) <span class="hljs-comment">//</span>
                | (workerId &lt;&lt; workerIdShift) <span class="hljs-comment">//</span>
                | sequence;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lastTimestamp 上次生成ID的时间戳</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前时间戳</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> <span class="hljs-title">tilNextMillis</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lastTimestamp)</span> </span>&#123;
        <span class="hljs-keyword">long</span> timestamp = timeGen();
        <span class="hljs-keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;
            timestamp = timeGen();
        &#125;
        <span class="hljs-keyword">return</span> timestamp;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 返回以毫秒为单位的当前时间</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前时间(毫秒)</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> <span class="hljs-title">timeGen</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> System.currentTimeMillis();
    &#125;

    <span class="hljs-comment">/** 测试 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;开始：&quot;</span>+System.currentTimeMillis());
        SnowflakeIdWorker idWorker = <span class="hljs-keyword">new</span> SnowflakeIdWorker(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;
            <span class="hljs-keyword">long</span> id = idWorker.nextId();
            System.out.println(id);
<span class="hljs-comment">//            System.out.println(Long.toBinaryString(id));</span>
        &#125;
        System.out.println(<span class="hljs-string">&quot;结束：&quot;</span>+System.currentTimeMillis());
    &#125;
&#125;</code></pre></div>

<p><strong>工程落地经验</strong></p>
<p><a href="https://www.hutool.cn/docs/#/core/工具类/唯一ID工具-IdUtil?id=snowflake">Hutool的Snowflake文档</a></p>
<p>添加依赖</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-captcha<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.6.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>示例程序：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.hutool.core.lang.Snowflake;
<span class="hljs-keyword">import</span> cn.hutool.core.net.NetUtil;
<span class="hljs-keyword">import</span> cn.hutool.core.util.IdUtil; 
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;

<span class="hljs-keyword">import</span> javax.annotation.PostConstruct;

<span class="hljs-meta">@Slf4j</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdGeneratorSnowflake</span></span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> workerId = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> datacenterId = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">private</span> Snowflake snowflake = IdUtil.createSnowflake(workerId, datacenterId);

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">snowflakeId</span><span class="hljs-params">()</span></span>&#123;
		<span class="hljs-keyword">return</span> snowflake.nextId();
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">snowflakeId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> workerId, <span class="hljs-keyword">long</span> datacenterId)</span></span>&#123;
		Snowflake snowflake = IdUtil.createSnowflake(workerId, datacenterId);
		<span class="hljs-keyword">return</span> snowflake.nextId();
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
	    IdGeneratorSnowflake idGenerator = <span class="hljs-keyword">new</span> IdGeneratorSnowflake();
		System.out.println(idGenerator.snowflakeId());
        
        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++)&#123;
			threadPool.submit(() -&gt; &#123;
				System.out.print1n(idGenerator.snowflakeId());
			&#125;);
		&#125;
        
		threadPool.shutdown();

	&#125;
&#125;</code></pre></div>

<p><strong>优缺点</strong></p>
<p>优点：</p>
<p>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</p>
<p>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</p>
<p>可以根据自身业务特性分配bit位，非常灵活。</p>
<p>缺点：</p>
<p>依赖机器时钟，如果机器时钟回拨，会导致重复ID生成。</p>
<p>在单机上是递增的，但是由于设计到分布式环境，每台机器上的时钟不可能完全同步，有时候会出现不是全局递增的情况。</p>
<p>此缺点可以认为无所谓，一般分布式ID只要求趋势递增，并不会严格要求递增，90%的需求都只要求趋势递增）</p>
<p><strong>其他补充</strong></p>
<p>百度开源的分布式唯一ID生成器UidGenerator</p>
<p>美团点评分布式ID生成系统Leaf</p>
<h2 id="Spring-Cloud组件总结"><a href="#Spring-Cloud组件总结" class="headerlink" title="Spring Cloud组件总结"></a>Spring Cloud组件总结</h2><table>
<thead>
<tr>
<th>组件</th>
<th>简介</th>
<th>分类</th>
<th>官网</th>
<th>笔记</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>Eureka is the Netflix Service Discovery Server and Client.</td>
<td>服务注册中心</td>
<td><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.7.RELEASE/reference/html/#service-discovery-eureka-clients">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298270#15_Eureka_1148">link</a></td>
<td>eureka中文解释：int.(因找到某物，尤指问题的答案而高兴)我发现了，我找到了</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services.</td>
<td>服务注册中心</td>
<td><a href="https://zookeeper.apache.org/">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/107434932">link</a></td>
<td>zookeeper中文解释：n.动物园管理员</td>
</tr>
<tr>
<td>Consul</td>
<td>Consul is a service mesh solution providing a full featured control plane with service discovery, configuration, and segmentation functionality.</td>
<td>服务注册中心</td>
<td><a href="https://www.consul.io/">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298270#31_Consul_2333">link</a></td>
<td>consul中文解释：n.领事</td>
</tr>
<tr>
<td>Ribbon</td>
<td>Ribbon is a client-side load balancer that gives you a lot of control over the behavior of HTTP and TCP clients.</td>
<td>服务调用</td>
<td><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.7.RELEASE/reference/html/#spring-cloud-ribbon">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298270#36_Ribbon_2780">link</a></td>
<td>ribbon中文解释：n.(用于捆绑或装饰的)带子;丝带;带状物;</td>
</tr>
<tr>
<td>OpenFeign</td>
<td>Feign is a declarative web service client. It makes writing web service clients easier.</td>
<td>服务调用</td>
<td><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.7.RELEASE/reference/html/">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298270#43_OpenFeign_3304">link</a></td>
<td>feign中文意思：v.假装，装作，佯装(有某种感觉或生病、疲倦等)</td>
</tr>
<tr>
<td>Hystrix</td>
<td>Netflix has created a library called Hystrix that implements the circuit breaker pattern.</td>
<td>服务降级</td>
<td><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.7.RELEASE/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298270#47_Hystrix_3696">link</a></td>
<td>hystrix中文意思：n.豪猪属;猬草属;豪猪;豪猪亚属</td>
</tr>
<tr>
<td>GateWay</td>
<td>Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring/metrics, and resiliency.</td>
<td>服务网关</td>
<td><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.7.RELEASE/reference/html/">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298282#66_GateWay_771">link</a></td>
<td>gateway中文意思：n.网关;途径;门道;手段</td>
</tr>
<tr>
<td>Config</td>
<td>Spring Cloud Config provides server-side and client-side support for externalized configuration in a distributed system.</td>
<td>服务配置</td>
<td><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.7.RELEASE/reference/html/">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298282#74_Config_1524">link</a></td>
<td>-</td>
</tr>
<tr>
<td>Bus</td>
<td>Spring Cloud Bus links nodes of a distributed system with a lightweight message broker.</td>
<td>服务总线</td>
<td><a href="https://docs.spring.io/spring-cloud-bus/docs/2.2.3.RELEASE/reference/html/">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298282#78_Bus_2078">link</a></td>
<td>-</td>
</tr>
<tr>
<td>Stream</td>
<td>Spring Cloud Stream is a framework for building message-driven microservice applications.</td>
<td>消息队列</td>
<td><a href="https://docs.spring.io/spring-cloud-stream/docs/3.0.10.RELEASE/reference/html/spring-cloud-stream.html#spring-cloud-stream-overview-introducing">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298282#83_Stream_2576">link</a></td>
<td>-</td>
</tr>
<tr>
<td>Sleuth</td>
<td>Spring Cloud Sleuth implements a distributed tracing solution for Spring Cloud.</td>
<td>服务跟踪</td>
<td><a href="https://docs.spring.io/spring-cloud-sleuth/docs/2.2.7.RELEASE/reference/html/">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298282#92_Sleuth_3191">link</a></td>
<td>sleuth中文意思：n.侦探</td>
</tr>
<tr>
<td>Nacos</td>
<td>Nacos致力于帮助您发现、配置和管理微服务。</td>
<td>服务注册中心、服务配置、服务总线</td>
<td><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298282#96_Nacos_3488">link</a></td>
<td>NAme + COnfiguration + Service</td>
</tr>
<tr>
<td>Sentinel</td>
<td>Sentinel是面向分布式服务架构的流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助您保障微服务的稳定性。</td>
<td>服务降级</td>
<td><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298288#111_Sentinel_240">link</a></td>
<td>sentinel中文意思：n.哨兵</td>
</tr>
<tr>
<td>Seata</td>
<td>Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</td>
<td>分布式事务</td>
<td><a href="https://seata.io/zh-cn/">link</a></td>
<td><a href="https://blog.csdn.net/u011863024/article/details/114298288#139_Seata_2287">link</a></td>
<td>-</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 学习</title>
    <url>/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="第一部分-内存与垃圾回收"><a href="#第一部分-内存与垃圾回收" class="headerlink" title="第一部分 内存与垃圾回收"></a>第一部分 内存与垃圾回收</h1><h1 id="第1章-JVM与Java体系结构"><a href="#第1章-JVM与Java体系结构" class="headerlink" title="第1章 JVM与Java体系结构"></a>第1章 JVM与Java体系结构</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？</p>
<p>运行着的线上系统突然卡死，系统无法访问，甚至直接OOMM！</p>
<ul>
<li>想解决线上JVM GC问题，但却无从下手。</li>
<li>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了</li>
<li>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704111417472.png" alt="image-20200704111417472"></p>
<p>大部分Java开发人员，除会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</p>
<p>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</p>
<p>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704112119729.png" alt="image-20200704112119729"></p>
<h2 id="2-架构师每天都在思考什么？"><a href="#2-架构师每天都在思考什么？" class="headerlink" title="2 架构师每天都在思考什么？"></a>2 架构师每天都在思考什么？</h2><ul>
<li>应该如何让我的系统更快？</li>
<li>如何避免系统出现瓶颈？</li>
</ul>
<p>知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？</p>
<ul>
<li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li>
<li>根据业务场景和需求，决定技术方向，做技术选型</li>
<li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li>
<li>解决各类潜在系统风险，核心功能的架构与代码编写</li>
<li>分析系统瓶颈，解决各种疑难杂症，性能调优等</li>
</ul>
<h2 id="3-为什么要学习JVM"><a href="#3-为什么要学习JVM" class="headerlink" title="3 为什么要学习JVM"></a>3 为什么要学习JVM</h2><ul>
<li><p>面试的需要（BATJ、TMD，PKQ等面试都爱问）</p>
</li>
<li><p>中高级程序员必备技能</p>
<ul>
<li>项目管理、调优的需求</li>
</ul>
</li>
<li><p>追求极客的精神</p>
<ul>
<li>比如：垃圾回收算法、JIT（及时编译器）、底层原理</li>
</ul>
</li>
</ul>
<h2 id="4-Java-vs-C"><a href="#4-Java-vs-C" class="headerlink" title="4 Java vs C++"></a>4 Java vs C++</h2><p>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704112700211.png" alt="image-20200704112700211"></p>
<p>C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。</p>
<h2 id="5-推荐书籍"><a href="#5-推荐书籍" class="headerlink" title="5 推荐书籍"></a>5 推荐书籍</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704145340513.png" alt="image-20200704145340513"></p>
<h2 id="6-Java生态圈"><a href="#6-Java生态圈" class="headerlink" title="6 Java生态圈"></a>6 Java生态圈</h2><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p>
<ul>
<li><p>作为一个平台，Java虚拟机扮演着举足轻重的作用</p>
<ul>
<li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li>
</ul>
</li>
<li><p>作为灯种文化，Java几乎成为了“开源”的代名词。</p>
<ul>
<li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li>
<li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li>
</ul>
</li>
<li><p>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</p>
</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704151731216.png" alt="image-20200704151731216"></p>
<p>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704152052489.png" alt="image-20200704152052489"></p>
<p>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</p>
<p>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p>
<h2 id="7-字节码"><a href="#7-字节码" class="headerlink" title="7 字节码"></a>7 字节码</h2><p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</p>
<p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p>
<p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</p>
<h2 id="8-多语言混合编程"><a href="#8-多语言混合编程" class="headerlink" title="8 多语言混合编程"></a>8 多语言混合编程</h2><p>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p>
<p>试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</p>
<p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</p>
<h2 id="9-Java发展的重大事件"><a href="#9-Java发展的重大事件" class="headerlink" title="9 Java发展的重大事件"></a>9 Java发展的重大事件</h2><ul>
<li><p>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java</p>
</li>
<li><p>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</p>
</li>
<li><p>1996年1月23日sun Microsystems发布了JDK 1.0。</p>
</li>
<li><p>1998年，JDK1.2版本发布。同时，sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</p>
</li>
<li><p>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</p>
</li>
<li><p>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</p>
</li>
<li><p>2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</p>
</li>
<li><p>2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</p>
</li>
<li><p>2006年，JDK6发布。同年，Java开源并建立了openJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。</p>
</li>
<li><p>2007年，Java平台迎来了新伙伴Clojure。</p>
</li>
<li><p>2008年，oracle收购了BEA，得到了JRockit虚拟机。</p>
</li>
<li><p>2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。</p>
</li>
<li><p>2010年，oracle收购了sun，获得Java商标和最真价值的HotSpot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit</p>
</li>
<li><p>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</p>
</li>
<li><p>2017年，JDK9发布。将G1设置为默认Gc，替代CMS</p>
</li>
<li><p>同年，IBM的J9开源，形成了现在的open J9社区</p>
</li>
<li><p>2018年，Android的Java侵权案判决，Google赔偿oracle计88亿美元</p>
</li>
<li><p>同年，oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</p>
</li>
<li><p>同年，JDK11发布，LTS版本的JDK，发布革命性的zGc，调整JDK授权许可</p>
</li>
<li><p>2019年，JDK12发布，加入RedHat领导开发的shenandoah GC</p>
</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704182035810.png" alt="image-20200704182035810"></p>
<p>在JDK11之前，oracleJDK中还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，我们可以认为openJDK和oracleJDK代码实质上已经完全一致的程度。</p>
<h2 id="10-虚拟机与Java虚拟机"><a href="#10-虚拟机与Java虚拟机" class="headerlink" title="10 虚拟机与Java虚拟机"></a>10 虚拟机与Java虚拟机</h2><h3 id="10-1-虚拟机"><a href="#10-1-虚拟机" class="headerlink" title="10.1 虚拟机"></a>10.1 虚拟机</h3><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p>
<ul>
<li>大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</li>
<li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li>
</ul>
<p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<h3 id="10-2-Java虚拟机"><a href="#10-2-Java虚拟机" class="headerlink" title="10.2 Java虚拟机"></a>10.2 Java虚拟机</h3><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p>
<p>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p>
<p>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</p>
<p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<p>特点：</p>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<h2 id="11-JVM的位置"><a href="#11-JVM的位置" class="headerlink" title="11 JVM的位置"></a>11 JVM的位置</h2><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704183048061.png" alt="image-20200704183048061"></p>
<p>Java的体系结构</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704183236169.png" alt="image-20200704183236169"></p>
<h2 id="12-JVM整体结构"><a href="#12-JVM整体结构" class="headerlink" title="12 JVM整体结构"></a>12 JVM整体结构</h2><ul>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li>
<li>它采用解释器与即时编译器并存的架构。</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704183436495.png" alt="image-20200704183436495"></p>
<p>执行引擎包含三部分：解释器，及时编译器，垃圾回收器</p>
<h2 id="13-Java代码执行流程"><a href="#13-Java代码执行流程" class="headerlink" title="13 Java代码执行流程"></a>13 Java代码执行流程</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704210429535.png" alt="image-20200704210429535"></p>
<p>只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了</p>
<h2 id="14-JVM的架构模型"><a href="#14-JVM的架构模型" class="headerlink" title="14 JVM的架构模型"></a>14 JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p>
<p>基于栈式架构的特点</p>
<ul>
<li>设计和实现更简单，适用于资源受限的系统；</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配。</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
<p>基于寄存器架构的特点</p>
<ul>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作。</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p>
<p>基于栈的计算流程（以Java虚拟机为例）：</p>
<div class="code-wrapper"><pre><code class="hljs bash">iconst_2 //常量2入栈
istore_1
iconst_3 // 常量3入栈
istore_2
iload_1
iload_2
iadd //常量2/3出栈，执行相加
istore_0 // 结果5入栈</code></pre></div>

<p>而基于寄存器的计算流程</p>
<div class="code-wrapper"><pre><code class="hljs bash">mov eax,2 //将eax寄存器的值设为1
add eax,3 //使eax寄存器的值加3</code></pre></div>

<h3 id="字节码反编译"><a href="#字节码反编译" class="headerlink" title="字节码反编译"></a>字节码反编译</h3><p>我们编写一个简单的代码，然后查看一下字节码的反编译后的结果</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/7/20 21:31</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span>
<span class="hljs-comment"> **/</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackStruTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;
    &#125;
&#125;</code></pre></div>

<p>然后我们找到编译后的 class文件，使用下列命令进行反编译</p>
<div class="code-wrapper"><pre><code class="hljs bash">javap -v StackStruTest.class</code></pre></div>

<p>得到的文件为:</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> static void main(java.lang.String[]);
  <span class="hljs-attribute">descriptor</span>: ([Ljava/lang/String;)V
  <span class="hljs-attribute">flags</span>: ACC_PUBLIC, ACC_STATIC
  <span class="hljs-attribute">Code</span>:
    <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span>
       <span class="hljs-attribute">0</span>: iconst_<span class="hljs-number">2</span>
       <span class="hljs-attribute">1</span>: istore_<span class="hljs-number">1</span>
       <span class="hljs-attribute">2</span>: iconst_<span class="hljs-number">3</span>
       <span class="hljs-attribute">3</span>: istore_<span class="hljs-number">2</span>
       <span class="hljs-attribute">4</span>: iload_<span class="hljs-number">1</span>
       <span class="hljs-attribute">5</span>: iload_<span class="hljs-number">2</span>
       <span class="hljs-attribute">6</span>: iadd
       <span class="hljs-attribute">7</span>: istore_<span class="hljs-number">3</span>
       <span class="hljs-attribute">8</span>: return
    <span class="hljs-attribute">LineNumberTable</span>:
      <span class="hljs-attribute">line</span> <span class="hljs-number">9</span>: <span class="hljs-number">0</span>
      <span class="hljs-attribute">line</span> <span class="hljs-number">10</span>: <span class="hljs-number">2</span>
      <span class="hljs-attribute">line</span> <span class="hljs-number">11</span>: <span class="hljs-number">4</span>
      <span class="hljs-attribute">line</span> <span class="hljs-number">12</span>: <span class="hljs-number">8</span>
    <span class="hljs-attribute">LocalVariableTable</span>:
      <span class="hljs-attribute">Start</span>  Length  Slot  Name   Signature
          <span class="hljs-attribute">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args  <span class="hljs-meta"> [Ljava/lang/String;</span>
<span class="hljs-meta">          2       7     1     i   I</span>
<span class="hljs-meta">          4       5     2     j   I</span>
<span class="hljs-meta">          8       1     3     k   I</span></code></pre></div>

<h2 id="15-总结"><a href="#15-总结" class="headerlink" title="15 总结"></a>15 总结</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>跨平台性</li>
<li>指令集小</li>
<li>指令多</li>
<li>执行性能比寄存器差</li>
</ul>
<h2 id="16-JVM生命周期"><a href="#16-JVM生命周期" class="headerlink" title="16 JVM生命周期"></a>16 JVM生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
<h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li>
<li>程序开始执行时他才运行，程序结束时他就停止。</li>
<li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li>
</ul>
<h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下的几种情况：</p>
<ul>
<li><p>程序正常执行结束</p>
</li>
<li><p>程序在执行过程中遇到了异常或错误而异常终止</p>
</li>
<li><p>由于操作系统用现错误而导致Java虚拟机进程终止</p>
</li>
<li><p>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</p>
</li>
<li><p>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</p>
</li>
</ul>
<h2 id="17-JVM发展历程"><a href="#17-JVM发展历程" class="headerlink" title="17 JVM发展历程"></a>17 JVM发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul>
<li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。</li>
<li>这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</li>
<li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li>
<li>现在hotspot内置了此虚拟机。</li>
</ul>
<h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><p>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。<br>Exact Memory Management：准确式内存管理</p>
<ul>
<li>也可以叫Non-Conservative/Accurate Memory Management</li>
<li>虚拟机可以知道内存中某个位置的数据具体是什么类型。|</li>
</ul>
<p>具备现代高性能虚拟机的维形</p>
<ul>
<li>热点探测（寻找出热点代码进行缓存）</li>
<li>编译器与解释器混合工作模式</li>
</ul>
<p>只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p>
<h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><p>HotSpot历史</p>
<ul>
<li>最初由一家名为“Longview Technologies”的小公司设计</li>
<li>1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。</li>
<li>JDK1.3时，HotSpot VM成为默认虚拟机</li>
</ul>
<p>目前Hotspot占有绝对的市场地位，称霸武林。</p>
<ul>
<li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li>
<li>Sun/oracle JDK和openJDK的默认虚拟机</li>
<li>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念）</li>
</ul>
<p>从服务器、桌面到移动端、嵌入式都有应用。</p>
<p>名称中的HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li>
</ul>
<h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><p>专注于服务器端应用</p>
<ul>
<li>它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li>
</ul>
<p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</p>
<ul>
<li>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li>
</ul>
<p>优势：全面的Java运行时解决方案组合</p>
<ul>
<li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li>
<li>MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li>
</ul>
<p>2008年，JRockit被oracle收购。</p>
<p>oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p>
<p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p>
<h3 id="IBM的J9"><a href="#IBM的J9" class="headerlink" title="IBM的J9"></a>IBM的J9</h3><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p>
<p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p>
<p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</p>
<p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9</p>
<p>OpenJDK   -&gt; 是JDK开源了，包括了虚拟机</p>
<h3 id="KVM和CDC-CLDC-Hotspot"><a href="#KVM和CDC-CLDC-Hotspot" class="headerlink" title="KVM和CDC / CLDC  Hotspot"></a>KVM和CDC / CLDC  Hotspot</h3><p>oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。</p>
<p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p>
<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
<p>所有的虚拟机的原则：一次编译，到处运行。</p>
<h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><p>前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azu1VW和BEALiquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机I</p>
<ul>
<li>高性能Java虚拟机中的战斗机。</li>
</ul>
<p>Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。</p>
<p>每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</p>
<p>2010年，AzulSystems公司开始从硬件转向软件，发布了自己的zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</p>
<h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><p>高性能Java虚拟机中的战斗机。</p>
<p>BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition），</p>
<p>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</p>
<p>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</p>
<h3 id="Apache-Marmony"><a href="#Apache-Marmony" class="headerlink" title="Apache Marmony"></a>Apache Marmony</h3><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p>
<p>它是IElf和Inte1联合开发的开源JVM，受到同样开源的openJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p>
<p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p>
<h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p>
<p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p>
<p>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXPSP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</p>
<h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p>
<p>基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</p>
<p>基于openJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p>
<ul>
<li>创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且Gc不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。</li>
<li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li>
<li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li>
<li>PMU hardware的Java profiling tool和诊断协助功能</li>
<li>针对大数据场景的ZenGc </li>
</ul>
<p>taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</p>
<p>目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。</p>
<h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p>
<p>Dalvik y只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范</p>
<p>不能直接执行Java的Class文件</p>
<p>基于寄存器架构，不是jvm的栈架构。</p>
<p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p>
<ul>
<li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li>
</ul>
<p>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</p>
<h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><p>2018年4月，oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p>
<p>GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”<br>的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p>
<p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p>
<p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p>
<p>如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle HotSpot VM为默认虚拟机。</p>
<h1 id="第2章-类加载子系统"><a href="#第2章-类加载子系统" class="headerlink" title="第2章 类加载子系统"></a>第2章 类加载子系统</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705080719531.png" alt="image-20200705080719531"></p>
<p>完整图如下</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705080911284.png" alt="image-20200705080911284"></p>
<p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p>
<ul>
<li>类加载器</li>
<li>执行引擎</li>
</ul>
<h2 id="2-类加载器子系统作用"><a href="#2-类加载器子系统作用" class="headerlink" title="2 类加载器子系统作用"></a>2 类加载器子系统作用</h2><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p>
<p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p>
<p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705081813409.png" alt="image-20200705081813409"></p>
<ul>
<li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li>
<li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li>
<li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705081913538.png" alt="image-20200705081913538"></p>
<h2 id="3-类的加载过程"><a href="#3-类的加载过程" class="headerlink" title="3 类的加载过程"></a>3 类的加载过程</h2><p>例如下面的一段简单的代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloLoader</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;我已经被加载啦&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>它的加载过程是怎么样的呢?</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705082255746.png" alt="image-20200705082255746"></p>
<p>完整的流程图如下所示</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705082601441.png" alt="image-20200705082601441"></p>
<h2 id="4-加载阶段"><a href="#4-加载阶段" class="headerlink" title="4 加载阶段"></a>4 加载阶段</h2><p>通过一个类的全限定名获取定义此类的二进制字节流</p>
<p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<h3 id="4-1-加载class文件的方式"><a href="#4-1-加载class文件的方式" class="headerlink" title="4.1 加载class文件的方式"></a>4.1 加载class文件的方式</h3><ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，使用最多的是：动态代理技术</li>
<li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li>
<li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li>
</ul>
<h3 id="4-2-链接阶段"><a href="#4-2-链接阶段" class="headerlink" title="4.2 链接阶段"></a>4.2 链接阶段</h3><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p>
<p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<blockquote>
<p>工具：Binary Viewer查看</p>
</blockquote>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705084038680.png" alt="image-20200705084038680"></p>
<p>如果出现不合法的字节码文件，那么将会验证不通过</p>
<p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705090237078.png" alt="image-20200705090237078"></p>
<p>安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705090328171.png" alt="image-20200705090328171"></p>
<h3 id="4-3-准备-Prepare"><a href="#4-3-准备-Prepare" class="headerlink" title="4.3 准备 Prepare"></a>4.3 准备 Prepare</h3><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloApp</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(a);
    &#125;
&#125;</code></pre></div>

<p>上面的变量a在准备阶段会赋初始值，但不是1，而是0。</p>
<p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p>
<p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p>
<p>例如下面这段代码</p>
<h3 id="4-4-解析-Resolve"><a href="#4-4-解析-Resolve" class="headerlink" title="4.4 解析 Resolve"></a>4.4 解析 Resolve</h3><p>将常量池内的符号引用转换为直接引用的过程。</p>
<p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>
<p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p>
<h3 id="4-5-初始化阶段"><a href="#4-5-初始化阶段" class="headerlink" title="4.5 初始化阶段"></a>4.5 初始化阶段</h3><p>初始化阶段就是执行类构造器法<clinit>（）的过程。</clinit></p>
<p>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p>
<ul>
<li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li>
</ul>
<p>构造器方法中指令按语句在源文件中出现的顺序执行。</p>
<p><clinit>（）不同于类的构造器。（关联：构造器是虚拟机视角下的<init>（））若该类具有父类，JVM会保证子类的<clinit>（）执行前，父类的<clinit>（）已经执行完毕。</clinit></clinit></init></clinit></p>
<ul>
<li>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassInitTest</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">static</span> &#123;
        num = <span class="hljs-number">2</span>;
        number = <span class="hljs-number">20</span>;
        System.out.println(num);
        System.out.println(number);  <span class="hljs-comment">//报错，非法的前向引用</span>
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">10</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(ClassInitTest.num); <span class="hljs-comment">// 2</span>
        System.out.println(ClassInitTest.number); <span class="hljs-comment">// 10</span>
    &#125;
&#125;</code></pre></div>

<p>关于涉及到父类时候的变量赋值过程</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClinitTest1</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">static</span> &#123;
            A = <span class="hljs-number">2</span>;
        &#125;
    &#125;

    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = A;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(Son.b);
    &#125;
&#125;</code></pre></div>

<p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回</p>
<div class="code-wrapper"><pre><code class="hljs bash">iconst_1
putstatic <span class="hljs-comment">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span>
iconst_2
putstatic <span class="hljs-comment">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span>
<span class="hljs-built_in">return</span></code></pre></div>

<p>虚拟机必须保证一个类的<clinit>（）方法在多线程下被同步加锁。</clinit></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadThreadTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 线程t1开始&quot;</span>);
            <span class="hljs-keyword">new</span> DeadThread();
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 线程t2开始&quot;</span>);
            <span class="hljs-keyword">new</span> DeadThread();
        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadThread</span> </span>&#123;
    <span class="hljs-keyword">static</span> &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 初始化当前类&quot;</span>);
            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;

            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>上面的代码，输出结果为</p>
<div class="code-wrapper"><pre><code class="hljs mipsasm">线程<span class="hljs-built_in">t1</span>开始
线程<span class="hljs-built_in">t2</span>开始
线程<span class="hljs-built_in">t2</span> 初始化当前类</code></pre></div>

<p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p>
<h2 id="5-类加载器的分类"><a href="#5-类加载器的分类" class="headerlink" title="5 类加载器的分类"></a>5 类加载器的分类</h2><p>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p>
<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705094149223.png" alt="image-20200705094149223"></p>
<p>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。</p>
<p>我们通过一个类，获取它不同的加载器</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 获取系统类加载器</span>
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);

        <span class="hljs-comment">// 获取其上层的：扩展类加载器</span>
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println(extClassLoader);

        <span class="hljs-comment">// 试图获取 根加载器</span>
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();
        System.out.println(bootstrapClassLoader);

        <span class="hljs-comment">// 获取自定义加载器</span>
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        System.out.println(classLoader);
        
        <span class="hljs-comment">// 获取String类型的加载器</span>
        ClassLoader classLoader1 = String.class.getClassLoader();
        System.out.println(classLoader1);
    &#125;
&#125;</code></pre></div>

<p>得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">sun</span>.misc.Launcher$AppClassLoader@<span class="hljs-number">18</span>b<span class="hljs-number">4</span>aac<span class="hljs-number">2</span>
<span class="hljs-attribute">sun</span>.misc.Launcher$ExtClassLoader@<span class="hljs-number">1540</span>e<span class="hljs-number">19</span>d
<span class="hljs-attribute">null</span>
<span class="hljs-attribute">sun</span>.misc.Launcher$AppClassLoader@<span class="hljs-number">18</span>b<span class="hljs-number">4</span>aac<span class="hljs-number">2</span>
<span class="hljs-attribute">null</span></code></pre></div>

<h3 id="5-1-虚拟机自带的加载器"><a href="#5-1-虚拟机自带的加载器" class="headerlink" title="5.1 虚拟机自带的加载器"></a>5.1 虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul>
<li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li>
<li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承自ava.lang.ClassLoader，没有父加载器。</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li>
</ul>
<h3 id="5-2-扩展类加载器（Extension-ClassLoader）"><a href="#5-2-扩展类加载器（Extension-ClassLoader）" class="headerlink" title="5.2 扩展类加载器（Extension ClassLoader）"></a>5.2 扩展类加载器（Extension ClassLoader）</h3><ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<h3 id="5-3-应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#5-3-应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="5.3 应用程序类加载器（系统类加载器，AppClassLoader）"></a>5.3 应用程序类加载器（系统类加载器，AppClassLoader）</h3><ul>
<li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>
<li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li>
</ul>
<h3 id="5-4-用户自定义类加载器"><a href="#5-4-用户自定义类加载器" class="headerlink" title="5.4 用户自定义类加载器"></a>5.4 用户自定义类加载器</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。<br>为什么要自定义类加载器？</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄漏</li>
</ul>
<p>用户自定义类加载器实现步骤：</p>
<ul>
<li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ul>
<h3 id="5-5-查看根加载器所能加载的目录"><a href="#5-5-查看根加载器所能加载的目录" class="headerlink" title="5.5 查看根加载器所能加载的目录"></a>5.5 查看根加载器所能加载的目录</h3><p>刚刚我们通过概念了解到了，根加载器只能够加载 java /lib目录下的class，我们通过下面代码验证一下</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderTest1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;*********启动类加载器************&quot;</span>);
        <span class="hljs-comment">// 获取BootstrapClassLoader 能够加载的API的路径</span>
        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
        <span class="hljs-keyword">for</span> (URL url : urls) &#123;
            System.out.println(url.toExternalForm());
        &#125;

        <span class="hljs-comment">// 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器</span>
        ClassLoader classLoader = Provider.class.getClassLoader();
    &#125;
&#125;</code></pre></div>

<p>得到的结果</p>
<div class="code-wrapper"><pre><code class="hljs gradle">*********启动类加载器************
<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/resources.jar
<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/rt.jar
<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/sunrsasign.jar
<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jsse.jar
<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jce.jar
<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/charsets.jar
<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jfr.jar
<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>classes
<span class="hljs-keyword">null</span></code></pre></div>

<h3 id="5-6-关于ClassLoader"><a href="#5-6-关于ClassLoader" class="headerlink" title="5.6 关于ClassLoader"></a>5.6 关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705103516138.png" alt="image-20200705103516138"></p>
<p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705103636003.png" alt="image-20200705103636003"></p>
<p>获取ClassLoader的途径</p>
<ul>
<li>获取当前ClassLoader：clazz.getClassLoader()</li>
<li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li>
<li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li>
<li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li>
</ul>
<h2 id="6-双亲委派机制"><a href="#6-双亲委派机制" class="headerlink" title="6 双亲委派机制"></a>6 双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p>
<h3 id="6-1-工作原理"><a href="#6-1-工作原理" class="headerlink" title="6.1 工作原理"></a>6.1 工作原理</h3><ul>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705105151258.png" alt="image-20200705105151258"></p>
<h3 id="6-2-双亲委派机制举例"><a href="#6-2-双亲委派机制举例" class="headerlink" title="6.2 双亲委派机制举例"></a>6.2 双亲委派机制举例</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705105810107.png" alt="image-20200705105810107"></p>
<h3 id="6-3-沙箱安全机制"><a href="#6-3-沙箱安全机制" class="headerlink" title="6.3 沙箱安全机制"></a>6.3 沙箱安全机制</h3><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>
<h3 id="6-4-双亲委派机制的优势"><a href="#6-4-双亲委派机制的优势" class="headerlink" title="6.4 双亲委派机制的优势"></a>6.4 双亲委派机制的优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改<ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li>
</ul>
</li>
</ul>
<h2 id="7-其它"><a href="#7-其它" class="headerlink" title="7 其它"></a>7 其它</h2><h3 id="如何判断两个class对象是否相同"><a href="#如何判断两个class对象是否相同" class="headerlink" title="如何判断两个class对象是否相同"></a>如何判断两个class对象是否相同</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li>
</ul>
<p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p>
<p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：王动使用和被动使用。<br>主动使用，又分为七种情况：</p>
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法I</li>
<li>反射（比如：Class.forName（”com.atguigu.Test”））</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持：</li>
<li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li>
</ul>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>
<h1 id="第3章-运行时数据区概述及线程"><a href="#第3章-运行时数据区概述及线程" class="headerlink" title="第3章  运行时数据区概述及线程"></a>第3章  运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/images/image-20200705111640511.png" alt="image-20200705111640511"></p>
<p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/images/image-20200705111843003.png" alt="image-20200705111843003"></p>
<p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/images/image-20200705112036630.png" alt="image-20200705112036630"></p>
<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
<blockquote>
<p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p>
</blockquote>
<p>运行时数据区的完整图</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/images/image-20200705112416101.png" alt="image-20200705112416101"></p>
<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p>
<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈。</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
<p>!<img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/images/image-20200705112601211.png" alt="image-20200705112601211"></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p>
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li>
</ul>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p>
<h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|<br>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p>
<ul>
<li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>
<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>
<li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li>
<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>
</ul>
<h1 id="第4章-程序计数器"><a href="#第4章-程序计数器" class="headerlink" title="第4章 程序计数器"></a>第4章 程序计数器</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705155551919.png" alt="image-20200705155551919"></p>
<p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p>
<h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705155728557.png" alt="image-20200705155728557"></p>
<h2 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3 代码演示"></a>3 代码演示</h2><p>我们首先写一个简单的代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCRegisterTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">20</span>;
        <span class="hljs-keyword">int</span> k = i + j;
    &#125;
&#125;</code></pre></div>

<p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p>
<div class="code-wrapper"><pre><code class="hljs bash">0: bipush        10
2: istore_1
3: bipush        20
5: istore_2
6: iload_1
7: iload_2
8: iadd
9: istore_3
10: <span class="hljs-built_in">return</span></code></pre></div>

<p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了 </p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161007423.png" alt="image-20200705161007423"></p>
<h2 id="4-使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#4-使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="4 使用PC寄存器存储字节码指令地址有什么用呢？"></a>4 使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161409533.png" alt="image-20200705161409533"></p>
<h2 id="5-PC寄存器为什么被设定为私有的？"><a href="#5-PC寄存器为什么被设定为私有的？" class="headerlink" title="5 PC寄存器为什么被设定为私有的？"></a>5 PC寄存器为什么被设定为私有的？</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161812542.png" alt="image-20200705161812542"></p>
<h2 id="6-CPU时间片"><a href="#6-CPU时间片" class="headerlink" title="6 CPU时间片"></a>6 CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
<p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
<p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161849557.png" alt="image-20200705161849557"></p>
<h1 id="第5章-虚拟机栈"><a href="#第5章-虚拟机栈" class="headerlink" title="第5章 虚拟机栈"></a>第5章 虚拟机栈</h1><h2 id="1-虚拟机栈概述"><a href="#1-虚拟机栈概述" class="headerlink" title="1 虚拟机栈概述"></a>1 虚拟机栈概述</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。<br>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java战（stack）？为什么？</p>
<p>首先栈是运行时的单位，而堆是存储的单位</p>
<ul>
<li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li>
<li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705163928652.png" alt="image-20200705163928652"></p>
<h3 id="1-1-Java虚拟机栈是什么"><a href="#1-1-Java虚拟机栈是什么" class="headerlink" title="1.1 Java虚拟机栈是什么"></a>1.1 Java虚拟机栈是什么</h3><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p>
<blockquote>
<p>是线程私有的</p>
</blockquote>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705164722033.png" alt="image-20200705164722033"></p>
<h3 id="1-2-生命周期"><a href="#1-2-生命周期" class="headerlink" title="1.2 生命周期"></a>1.2 生命周期</h3><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p>
<h3 id="1-3-作用"><a href="#1-3-作用" class="headerlink" title="1.3 作用"></a>1.3 作用</h3><p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<blockquote>
<p>局部变量，它是相比于成员变量来说的（或属性）</p>
<p>基本数据类型变量 VS  引用类型变量（类、数组、接口）</p>
</blockquote>
<h3 id="1-4-栈的特点"><a href="#1-4-栈的特点" class="headerlink" title="1.4 栈的特点"></a>1.4 栈的特点</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM直接对Java栈的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
<p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705165025382.png" alt="image-20200705165025382"></p>
<h3 id="1-5-开发中遇到哪些异常？"><a href="#1-5-开发中遇到哪些异常？" class="headerlink" title="1.5 开发中遇到哪些异常？"></a>1.5 开发中遇到哪些异常？</h3><p>栈中可能出现的异常</p>
<p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p>
<p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</p>
<p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 outofMemoryError 异常。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackErrorTest</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        System.out.println(count++);
        main(args);
    &#125;
&#125;</code></pre></div>

<p>当栈深度达到9872的时候，就出现栈内存空间不足</p>
<h3 id="1-6-设置栈内存大小"><a href="#1-6-设置栈内存大小" class="headerlink" title="1.6 设置栈内存大小"></a>1.6 设置栈内存大小</h3><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p>
<div class="code-wrapper"><pre><code class="hljs shell">-Xss1m
-Xss1k</code></pre></div>

<h2 id="2-栈的存储单位"><a href="#2-栈的存储单位" class="headerlink" title="2 栈的存储单位"></a>2 栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p>
<p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<h3 id="2-1-栈中存储什么？"><a href="#2-1-栈中存储什么？" class="headerlink" title="2.1 栈中存储什么？"></a>2.1 栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。在这个线程上正在执行的每个方法都各自对应一个栈颜（Stack Frame）。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<blockquote>
<p>OOP的基本概念：类和对象</p>
<p>类中基本结构：field（属性、字段、域）、method</p>
</blockquote>
<p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705203142545.png" alt="image-20200705203142545"></p>
<p>下面写一个简单的代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackFrameTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        method01();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;方法1的开始&quot;</span>);
        <span class="hljs-keyword">int</span> i = method02();
        System.out.println(<span class="hljs-string">&quot;方法1的结束&quot;</span>);
        <span class="hljs-keyword">return</span> i;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method02</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;方法2的开始&quot;</span>);
        <span class="hljs-keyword">int</span> i = method03();;
        System.out.println(<span class="hljs-string">&quot;方法2的结束&quot;</span>);
        <span class="hljs-keyword">return</span> i;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method03</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;方法3的开始&quot;</span>);
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>;
        System.out.println(<span class="hljs-string">&quot;方法3的结束&quot;</span>);
        <span class="hljs-keyword">return</span> i;
    &#125;
&#125;</code></pre></div>

<p>输出结果为</p>
<div class="code-wrapper"><pre><code class="hljs bash">方法1的开始
方法2的开始
方法3的开始
方法3的结束
方法2的结束
方法1的结束</code></pre></div>

<p>满足栈先进后出的概念，通过Idea的 DEBUG，能够看到栈信息</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705203916023.png" alt="image-20200705203916023"></p>
<h3 id="2-2-栈运行原理"><a href="#2-2-栈运行原理" class="headerlink" title="2.2 栈运行原理"></a>2.2 栈运行原理</h3><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
<p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p>
<h3 id="2-3-栈帧的内部结构"><a href="#2-3-栈帧的内部结构" class="headerlink" title="2.3 栈帧的内部结构"></a>2.3 栈帧的内部结构</h3><p>每个栈帧中存储着：</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（operand Stack）（或表达式栈）</li>
<li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705204836977.png" alt="image-20200705204836977"></p>
<p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705205443993.png" alt="image-20200705205443993"></p>
<h2 id="3-局部变量表"><a href="#3-局部变量表" class="headerlink" title="3 局部变量表"></a>3 局部变量表</h2><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p>
<p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p>
<p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p>
<p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
<p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
<p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<h3 id="3-1-关于Slot的理解"><a href="#3-1-关于Slot的理解" class="headerlink" title="3.1 关于Slot的理解"></a>3.1 关于Slot的理解</h3><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p>
<p>局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
<p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。</p>
<blockquote>
<p>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。<br>1ong和double则占据两个slot。</p>
</blockquote>
<p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p>
<p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）</p>
<p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705212454445.png" alt="image-20200705212454445"></p>
<h3 id="3-2-Slot的重复利用"><a href="#3-2-Slot的重复利用" class="headerlink" title="3.2 Slot的重复利用"></a>3.2 Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705213106749.png" alt="image-20200705213106749"></p>
<h3 id="3-3-静态变量与局部变量的对比"><a href="#3-3-静态变量与局部变量的对比" class="headerlink" title="3.3 静态变量与局部变量的对比"></a>3.3 静态变量与局部变量的对比</h3><p>变量的分类：</p>
<ul>
<li>按数据类型分：基本数据类型、引用数据类型</li>
<li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量<ul>
<li>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块</li>
<li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li>
<li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li>
</ul>
</li>
</ul>
<p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p>
<p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p>
<p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
<p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<h2 id="4-操作数栈"><a href="#4-操作数栈" class="headerlink" title="4 操作数栈"></a>4 操作数栈</h2><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>操作数栈：Operand Stack</p>
<p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 <strong>操作数栈</strong>，也可以称之为 <strong>表达式栈</strong>（Expression Stack）</p>
<p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p>
<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706090618332.png" alt="image-20200706090618332"></p>
<p>代码举例</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706090833697.png" alt="image-20200706090833697"></p>
<p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p>
<p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。.</p>
<blockquote>
<p>这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的</p>
</blockquote>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</p>
<p>栈中的任何一个元素都是可以任意的Java数据类型</p>
<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
<p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p>
<p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p>
<h3 id="4-2-代码追踪"><a href="#4-2-代码追踪" class="headerlink" title="4.2 代码追踪"></a>4.2 代码追踪</h3><p>我们给定代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAddOperation</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">byte</span> i = <span class="hljs-number">15</span>;
    <span class="hljs-keyword">int</span> j = <span class="hljs-number">8</span>;
    <span class="hljs-keyword">int</span> k = i + j;
&#125;</code></pre></div>

<p>使用javap 命令反编译class文件： javap -v 类名.class</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706092610730.png" alt="image-20200706092610730"></p>
<blockquote>
<p>byte、short、char、boolean 内部都是使用int型来进行保存的</p>
<p>从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和  8进行入栈操作</p>
<p>同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作</p>
</blockquote>
<p>执行流程如下所示：</p>
<p>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入栈。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093131621.png" alt="image-20200706093131621"></p>
<p>执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093251302.png" alt="image-20200706093251302"></p>
<blockquote>
<p>为什么局部变量表不是从0开始的呢？</p>
<p>其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了~</p>
</blockquote>
<p>然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093646406.png" alt="image-20200706093646406"></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093751711.png" alt="image-20200706093751711"></p>
<p>然后从局部变量表中，依次将数据放在操作数栈中</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093859191.png" alt="image-20200706093859191"></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093921573.png" alt="image-20200706093921573"></p>
<p>然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706094046782.png" alt="image-20200706094046782"></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706094109629.png" alt="image-20200706094109629"></p>
<p>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</p>
<p>i++和++i的区别</p>
<h2 id="5-栈顶缓存技术"><a href="#5-栈顶缓存技术" class="headerlink" title="5 栈顶缓存技术"></a>5 栈顶缓存技术</h2><p>栈顶缓存技术：Top Of Stack Cashing</p>
<p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
<blockquote>
<p>寄存器：指令更少，执行速度快</p>
</blockquote>
<h2 id="6-动态链接"><a href="#6-动态链接" class="headerlink" title="6 动态链接"></a>6 动态链接</h2><p>动态链接：Dynamic Linking</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706100311886.png" alt="image-20200706100311886"></p>
<blockquote>
<p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p>
</blockquote>
<p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p>
<p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</p>
<p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706101251847.png" alt="image-20200706101251847"></p>
<blockquote>
<p>为什么需要运行时常量池？</p>
<p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p>
<p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p>
</blockquote>
<h2 id="7-方法调用：解析与分配"><a href="#7-方法调用：解析与分配" class="headerlink" title="7 方法调用：解析与分配"></a>7 方法调用：解析与分配</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<h3 id="7-1-链接"><a href="#7-1-链接" class="headerlink" title="7.1 链接"></a>7.1 链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期被确定，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p>
<h3 id="7-2-绑定机制"><a href="#7-2-绑定机制" class="headerlink" title="7.2 绑定机制"></a>7.2 绑定机制</h3><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<h4 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h4><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
<h4 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h4><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p>
<h3 id="早晚期绑定的发展历史"><a href="#早晚期绑定的发展历史" class="headerlink" title="早晚期绑定的发展历史"></a>早晚期绑定的发展历史</h3><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<h3 id="7-3-虚方法和非虚方法"><a href="#7-3-虚方法和非虚方法" class="headerlink" title="7.3 虚方法和非虚方法"></a>7.3 虚方法和非虚方法</h3><ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li>
<li>其他方法称为虚方法。</li>
</ul>
<blockquote>
<p>子类对象的多态的使用前提</p>
<ul>
<li>类的继承关系</li>
<li>方法的重写</li>
</ul>
</blockquote>
<p>虚拟机中提供了以下几条方法调用指令：</p>
<h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本</init></li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ul>
<h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</p>
<h3 id="7-4-invokedynamic指令"><a href="#7-4-invokedynamic指令" class="headerlink" title="7.4 invokedynamic指令"></a>7.4 invokedynamic指令</h3><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现动态类型语言】支持而做的一种改进。</p>
<p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
<h3 id="7-5-动态类型语言和静态类型语言"><a href="#7-5-动态类型语言和静态类型语言" class="headerlink" title="7.5 动态类型语言和静态类型语言"></a>7.5 动态类型语言和静态类型语言</h3><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
<blockquote>
<p>Java：String info = “mogu blog”;     (Java是静态类型语言的，会先编译就进行类型检查)</p>
<p>JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查）</p>
</blockquote>
<h3 id="7-6-方法重写的本质"><a href="#7-6-方法重写的本质" class="headerlink" title="7.6 方法重写的本质"></a>7.6 方法重写的本质</h3><h4 id="Java-语言中方法重写的本质："><a href="#Java-语言中方法重写的本质：" class="headerlink" title="Java 语言中方法重写的本质："></a>Java 语言中方法重写的本质：</h4><ul>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.1ang.I1legalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。</li>
</ul>
<h4 id="IllegalAccessError介绍"><a href="#IllegalAccessError介绍" class="headerlink" title="IllegalAccessError介绍"></a>IllegalAccessError介绍</h4><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<h3 id="7-7-方法的调用：虚方法表"><a href="#7-7-方法的调用：虚方法表" class="headerlink" title="7.7 方法的调用：虚方法表"></a>7.7 方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表<br>（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
<p>虚方法表是什么时候被创建的呢？</p>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706144954070.png" alt="image-20200706144954070"></p>
<p>如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。</p>
<h2 id="8-方法返回地址"><a href="#8-方法返回地址" class="headerlink" title="8 方法返回地址"></a>8 方法返回地址</h2><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p>
<ul>
<li><p>正常执行完成</p>
</li>
<li><p>出现未处理的异常，非正常退出</p>
</li>
</ul>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p>
<ul>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li>
</ul>
<p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p>
<p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706154554604.png" alt="image-20200706154554604"></p>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p>
<h2 id="9-一些附加信息"><a href="#9-一些附加信息" class="headerlink" title="9 一些附加信息"></a>9 一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<h2 id="10-栈的相关面试题"><a href="#10-栈的相关面试题" class="headerlink" title="10 栈的相关面试题"></a>10 栈的相关面试题</h2><ul>
<li>举例栈溢出的情况？（StackOverflowError）<ul>
<li>通过 -Xss设置栈的大小</li>
</ul>
</li>
<li>调整栈大小，就能保证不出现溢出么？<ul>
<li>不能保证不溢出</li>
</ul>
</li>
<li>分配的栈内存越大越好么？<ul>
<li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li>
</ul>
</li>
<li>垃圾回收是否涉及到虚拟机栈？<ul>
<li>不会</li>
</ul>
</li>
<li>方法中定义的局部变量是否线程安全？<ul>
<li>具体问题具体分析</li>
</ul>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 面试题</span>
<span class="hljs-comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span>
<span class="hljs-comment"> * 何为线程安全？</span>
<span class="hljs-comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span>
<span class="hljs-comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderTest</span> </span>&#123;

    <span class="hljs-comment">// s1的声明方式是线程安全的</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 线程内部创建的，属于局部变量</span>
        StringBuilder s1 = <span class="hljs-keyword">new</span> StringBuilder();
        s1.append(<span class="hljs-string">&quot;a&quot;</span>);
        s1.append(<span class="hljs-string">&quot;b&quot;</span>);
    &#125;

    <span class="hljs-comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title">method04</span><span class="hljs-params">()</span> </span>&#123;
        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();
        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);
        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);
        <span class="hljs-keyword">return</span> stringBuilder;
    &#125;

    <span class="hljs-comment">// stringBuilder 是线程不安全的，操作的是共享数据</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method02</span><span class="hljs-params">(StringBuilder stringBuilder)</span> </span>&#123;
        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);
        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);
    &#125;


    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 同时并发的执行，会出现线程不安全的问题</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method03</span><span class="hljs-params">()</span> </span>&#123;
        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);
            stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        method02(stringBuilder);
    &#125;

    <span class="hljs-comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">method05</span><span class="hljs-params">()</span> </span>&#123;
        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();
        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);
        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);
        <span class="hljs-keyword">return</span> stringBuilder.toString();
    &#125;
&#125;</code></pre></div>

<p>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p>
<p>运行时数据区，是否存在Error和GC？</p>
<table>
<thead>
<tr>
<th>运行时数据区</th>
<th>是否存在Error</th>
<th>是否存在GC</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>方法区</td>
<td>是（OOM）</td>
<td>是</td>
</tr>
<tr>
<td>堆</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h1 id="第6章-本地方法接口"><a href="#第6章-本地方法接口" class="headerlink" title="第6章 本地方法接口"></a>第6章 本地方法接口</h1><h2 id="1-什么是本地方法"><a href="#1-什么是本地方法" class="headerlink" title="1 什么是本地方法"></a>1 什么是本地方法</h2><p>简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p>
<p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/6_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/images/image-20200706164139252.png" alt="image-20200706164139252"></p>
<p>代码举例说明Native方法是如何编写的</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IhaveNatives</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Native1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Native2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Native3</span><span class="hljs-params">(Object o)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Natives</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ary)</span> <span class="hljs-keyword">throws</span> Exception</span>;
&#125;</code></pre></div>

<blockquote>
<p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p>
</blockquote>
<h2 id="2-为什么使用Native-Method？"><a href="#2-为什么使用Native-Method？" class="headerlink" title="2 为什么使用Native Method？"></a>2 为什么使用Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<h3 id="2-1-与Java环境的交互"><a href="#2-1-与Java环境的交互" class="headerlink" title="2.1 与Java环境的交互"></a>2.1 与Java环境的交互</h3><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p>
<h3 id="2-2-与操作系统的交互"><a href="#2-2-与操作系统的交互" class="headerlink" title="2.2 与操作系统的交互"></a>2.2 与操作系统的交互</h3><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p>
<h3 id="2-3-Sun’s-Java"><a href="#2-3-Sun’s-Java" class="headerlink" title="2.3 Sun’s Java"></a>2.3 Sun’s Java</h3><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p>
<h2 id="3-现状"><a href="#3-现状" class="headerlink" title="3 现状"></a>3 现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<h1 id="第7章-本地方法栈"><a href="#第7章-本地方法栈" class="headerlink" title="第7章 本地方法栈"></a>第7章 本地方法栈</h1><p>Java虚拟机栈于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p>
<p>本地方法栈，也是线程私有的。</p>
<p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li>
</ul>
<p>本地方法是使用C语言实现的。</p>
<p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/7_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/images/image-20200706174708418.png" alt="image-20200706174708418"></p>
<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p>
<ul>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
<p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p>
<p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>
<h1 id="第8章-堆"><a href="#第8章-堆" class="headerlink" title="第8章 堆"></a>第8章 堆</h1><h2 id="1-堆的核心概念"><a href="#1-堆的核心概念" class="headerlink" title="1 堆的核心概念"></a>1 堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706195127740.png" alt="image-20200706195127740"></p>
<p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>
<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p>
<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>
<p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p>
<blockquote>
<p>-Xms10m：最小堆内存</p>
<p>-Xmx10m：最大堆内存</p>
</blockquote>
<p>下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706200739392.png" alt="image-20200706200739392"></p>
<p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>
<p>我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p>
<ul>
<li>因为还有一些对象是在栈上分配的</li>
</ul>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
<ul>
<li>也就是触发了GC的时候，才会进行回收</li>
<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li>
</ul>
<p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706201904057.png" alt="image-20200706201904057"></p>
<h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p>
<ul>
<li>Young Generation Space 新生区  Young/New   又被划分为Eden区和Survivor区</li>
<li>Tenure generation space 养老区 Old/Tenure</li>
<li>Permanent Space永久区   Perm</li>
</ul>
<p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p>
<ul>
<li>Young Generation Space新生区  Young/New  又被划分为Eden区和Survivor区</li>
<li>Tenure generation space 养老区  Old/Tenure</li>
<li>Meta Space  元空间   Meta</li>
</ul>
<p>约定：新生区 -&gt; 新生代 -&gt; 年轻代   、  养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706203419496.png" alt="image-20200706203419496"></p>
<p>堆空间内部结构，JDK1.8之前从永久代  替换成 元空间</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706203835403.png" alt="image-20200706203835403"></p>
<h2 id="2-设置堆内存大小与OOM"><a href="#2-设置堆内存大小与OOM" class="headerlink" title="2 设置堆内存大小与OOM"></a>2 设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>
<ul>
<li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li>
<li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li>
</ul>
<p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p>
<p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p>
<p>默认情况下</p>
<ul>
<li><p>初始内存大小：物理电脑内存大小/64</p>
</li>
<li><p>最大内存大小：物理电脑内存大小/4</p>
</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span>
<span class="hljs-comment"> *  -X：是jvm运行参数</span>
<span class="hljs-comment"> *  ms：memory start</span>
<span class="hljs-comment"> * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSpaceInitial</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 返回Java虚拟机中的堆内存总量</span>
        <span class="hljs-keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;
        <span class="hljs-comment">// 返回Java虚拟机试图使用的最大堆内存</span>
        <span class="hljs-keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;
        System.out.println(<span class="hljs-string">&quot;-Xms:&quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>输出结果</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms:245M</span>
<span class="hljs-deletion">-Xmx:3614M</span></code></pre></div>

<p>如何查看堆内存的内存分配情况</p>
<div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps </span> -&gt;  <span class="hljs-keyword">jstat </span>-gc 进程id</code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706205756045.png" alt="image-20200706205756045"></p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+PrintGCDetails</span></code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706205821919.png" alt="image-20200706205821919"></p>
<h3 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706205947535.png" alt="image-20200706205947535"></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706210000461.png" alt="image-20200706210000461"></p>
<p>我们简单的写一个OOM例子</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;
            list.add(<span class="hljs-number">999999999</span>);
        &#125;
    &#125;
&#125;
</code></pre></div>

<p>然后设置启动参数</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx:10m</span></code></pre></div>

<p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706211652779.png" alt="image-20200706211652779"></p>
<h2 id="3-年轻代与老年代"><a href="#3-年轻代与老年代" class="headerlink" title="3 年轻代与老年代"></a>3 年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul>
<li>生命周期短的，及时回收即可</li>
</ul>
</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>
</ul>
<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>
<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707075847954.png" alt="image-20200707075847954"></p>
<p>下面这参数开发中一般不会调：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707080154039.png" alt="image-20200707080154039"></p>
<ul>
<li>Eden：From：to -&gt;  8:1:1</li>
<li>新生代：老年代  - &gt;  1 : 2</li>
</ul>
<p>配置新生代与老年代在堆结构的占比。</p>
<ul>
<li><p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p>
</li>
<li><p>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p>
</li>
</ul>
<blockquote>
<p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p>
</blockquote>
<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p>
<p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p>
<blockquote>
<p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>
<p>可以使用选项”-Xmn”设置新生代最大内存大小</p>
<p>这个参数一般使用默认值就可以了。</p>
</blockquote>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707084208115.png" alt="image-20200707084208115"></p>
<h2 id="4-图解对象分配过程"><a href="#4-图解对象分配过程" class="headerlink" title="4 图解对象分配过程"></a>4 图解对象分配过程</h2><h3 id="4-1-概念-1"><a href="#4-1-概念-1" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ul>
<li>new的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>啥时候能去养老区呢？可以设置次数。默认是15次。</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>
<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>
</ul>
<p>可以设置参数：-Xx:MaxTenuringThreshold= N进行设置</p>
<h3 id="4-2-图解过程"><a href="#4-2-图解过程" class="headerlink" title="4.2 图解过程"></a>4.2 图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707084714886.png" alt="image-20200707084714886"></p>
<p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p>
<p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707085232646.png" alt="image-20200707085232646"></p>
<p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象  晋升到 老年代中</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707085737207.png" alt="image-20200707085737207"></p>
<h3 id="4-3-思考：幸存区区满了后？"><a href="#4-3-思考：幸存区区满了后？" class="headerlink" title="4.3 思考：幸存区区满了后？"></a>4.3 思考：幸存区区满了后？</h3><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p>
<p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p>
<blockquote>
<p>举例：以当兵为例，正常人的晋升可能是 ：  新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p>
<p>但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -&gt; 排长</p>
</blockquote>
<h3 id="4-4-对象分配的特殊情况"><a href="#4-4-对象分配的特殊情况" class="headerlink" title="4.4 对象分配的特殊情况"></a>4.4 对象分配的特殊情况</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707091058346.png" alt="image-20200707091058346"></p>
<h3 id="4-5-代码演示对象分配过程"><a href="#4-5-代码演示对象分配过程" class="headerlink" title="4.5 代码演示对象分配过程"></a>4.5 代码演示对象分配过程</h3><p>我们不断的创建大对象</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapInstanceTest</span> </span>&#123;
    <span class="hljs-keyword">byte</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">200</span>)];
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        ArrayList&lt;HeapInstanceTest&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            list.add(<span class="hljs-keyword">new</span> HeapInstanceTest());
            Thread.sleep(<span class="hljs-number">10</span>);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>然后设置JVM参数</p>
<div class="code-wrapper"><pre><code class="hljs bash">-Xms600m -Xmx600m</code></pre></div>

<p>然后cmd输入下面命令，打开VisualVM图形化界面</p>
<div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">jvisualvm</span></code></pre></div>

<p>然后通过执行上面代码，通过VisualGC进行动态化查看</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.gif" alt="垃圾回收"></p>
<p>最终，在老年代和新生代都满了，就出现OOM</p>
<div class="code-wrapper"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space
	at com.atguigu.java.chapter08.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:<span class="hljs-number">13</span>)
	at com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:<span class="hljs-number">17</span>)</code></pre></div>

<h3 id="4-6-常用的调优工具"><a href="#4-6-常用的调优工具" class="headerlink" title="4.6 常用的调优工具"></a>4.6 常用的调优工具</h3><ul>
<li>JDK命令行</li>
<li>Eclipse：Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>Visual VM（实时监控  推荐~）</li>
<li>Jprofiler（推荐~）</li>
<li>Java Flight Recorder（实时监控）</li>
<li>GCViewer</li>
<li>GCEasy</li>
</ul>
<h3 id="4-7-总结"><a href="#4-7-总结" class="headerlink" title="4.7 总结"></a>4.7 总结</h3><ul>
<li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li>
<li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li>
<li>新生代采用复制算法的目的：是为了减少内碎片</li>
</ul>
<h2 id="5-Minor-GC，MajorGC、Full-GC"><a href="#5-Minor-GC，MajorGC、Full-GC" class="headerlink" title="5 Minor GC，MajorGC、Full GC"></a>5 Minor GC，MajorGC、Full GC</h2><ul>
<li>Minor GC：新生代的GC</li>
<li>Major GC：老年代的GC</li>
<li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li>
</ul>
<blockquote>
<p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p>
<p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p>
</blockquote>
<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>
<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li>
<li>老年代收集（MajorGC/OldGC）：只是老年代的圾收集。<ul>
<li>目前，只有CMSGC会有单独收集老年代的行为。</li>
<li>注意，很多时候Major GC会和FullGC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li>
</ul>
</li>
<li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul>
<li>目前，只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
<p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p>
<h3 id="5-1-Minor-GC"><a href="#5-1-Minor-GC" class="headerlink" title="5.1 Minor GC"></a>5.1 Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p>
<p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>
<p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p>
<blockquote>
<p>STW：stop the word</p>
</blockquote>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707095606813.png" alt="image-20200707095606813"></p>
<h3 id="5-2-Major-GC"><a href="#5-2-Major-GC" class="headerlink" title="5.2 Major GC"></a>5.2 Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p>
<p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p>
<ul>
<li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li>
</ul>
<p>Major GC的速度一般会比MinorGc慢10倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p>
<h3 id="5-3-Full-GC"><a href="#5-3-Full-GC" class="headerlink" title="5.3 Full GC"></a>5.3 Full GC</h3><p>触发FullGC执行的情况有如下五种：</p>
<ul>
<li>调用System.gc（）时，系统建议执行FullGC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ul>
<p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p>
<h3 id="5-4-GC-举例"><a href="#5-4-GC-举例" class="headerlink" title="5.4 GC 举例"></a>5.4 GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            String a = <span class="hljs-string">&quot;mogu blog&quot;</span>;
            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;
                list.add(a);
                a = a + a;
                i++;
            &#125;
        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.getStackTrace();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>设置JVM启动参数</p>
<div class="code-wrapper"><pre><code class="hljs bash">-Xms10m -Xmx10m -XX:+PrintGCDetails</code></pre></div>

<p>打印出的日志</p>
<div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2038</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">500</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">2038</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">797</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.3532002</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.36</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2108</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">480</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">2405</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">1565</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0014069</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2288</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">6845</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">9133</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058675</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0002857</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5263</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5263</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058564</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-variable">Heap</span>
 <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">60</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">2048</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd0f138</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span>
 <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">5263</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">73</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffb23cf0</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span>
 <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3514</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4498</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span>
  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">388</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">390</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span>
  
  <span class="hljs-variable">Exception</span> <span class="hljs-variable">in</span> <span class="hljs-variable">thread</span> <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">OutOfMemoryError</span><span class="hljs-operator">:</span> <span class="hljs-variable">Java</span> <span class="hljs-variable">heap</span> <span class="hljs-variable">space</span>
	<span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">util</span><span class="hljs-operator">.</span><span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">copyOfRange</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">3664</span><span class="hljs-punctuation">)</span>
	<span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-built_in">String</span><span class="hljs-operator">.&lt;</span><span class="hljs-variable">init</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">String</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">207</span><span class="hljs-punctuation">)</span>
	<span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">StringBuilder</span><span class="hljs-operator">.</span><span class="hljs-variable">toString</span><span class="hljs-punctuation">(</span><span class="hljs-variable">StringBuilder</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">407</span><span class="hljs-punctuation">)</span>
	<span class="hljs-variable">at</span> <span class="hljs-variable">com</span><span class="hljs-operator">.</span><span class="hljs-variable">atguigu</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">chapter08</span><span class="hljs-operator">.</span><span class="hljs-variable">GCTest</span><span class="hljs-operator">.</span><span class="hljs-variable">main</span><span class="hljs-punctuation">(</span><span class="hljs-variable">GCTest</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">20</span><span class="hljs-punctuation">)</span></code></pre></div>

<p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p>
<h2 id="6-堆空间分代思想"><a href="#6-堆空间分代思想" class="headerlink" title="6 堆空间分代思想"></a>6 堆空间分代思想</h2><p> 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<blockquote>
<p>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p>
</blockquote>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707101511025.png" alt="image-20200707101511025"></p>
<p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707101543871.png" alt="image-20200707101543871"></p>
<h2 id="7-内存分配策略"><a href="#7-内存分配策略" class="headerlink" title="7 内存分配策略"></a>7 内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p>
<p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden<ul>
<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li>
</ul>
</li>
<li>大对象直接分配到老年代<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象年龄判断<ul>
<li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li>
</ul>
</li>
</ul>
<p>空间分配担保： -Xx:HandlePromotionFailure</p>
<ul>
<li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li>
</ul>
<h2 id="8-为对象分配内存：TLAB"><a href="#8-为对象分配内存：TLAB" class="headerlink" title="8 为对象分配内存：TLAB"></a>8 为对象分配内存：TLAB</h2><h3 id="8-1-问题：堆空间都是共享的么？"><a href="#8-1-问题：堆空间都是共享的么？" class="headerlink" title="8.1 问题：堆空间都是共享的么？"></a>8.1 问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p>
<h3 id="8-2-为什么有TLAB？"><a href="#8-2-为什么有TLAB？" class="headerlink" title="8.2 为什么有TLAB？"></a>8.2 为什么有TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p>
<p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p>
<p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p>
<p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<h3 id="8-3-什么是TLAB"><a href="#8-3-什么是TLAB" class="headerlink" title="8.3 什么是TLAB"></a>8.3 什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p>
<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p>
<p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707103547712.png" alt="image-20200707103547712"></p>
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p>
<p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p>
<p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p>
<p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>
<h3 id="8-4-TLAB分配过程"><a href="#8-4-TLAB分配过程" class="headerlink" title="8.4 TLAB分配过程"></a>8.4 TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707104253530.png" alt="image-20200707104253530"></p>
<h2 id="9-小结：堆空间的参数设置"><a href="#9-小结：堆空间的参数设置" class="headerlink" title="9 小结：堆空间的参数设置"></a>9 小结：堆空间的参数设置</h2><ul>
<li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p>
</li>
<li><p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p>
</li>
<li><p>-Xms：初始堆空间内存（默认为物理内存的1/64）</p>
</li>
<li><p>-Xmx：最大堆空间内存（默认为物理内存的1/4）</p>
</li>
<li><p>-Xmn：设置新生代的大小。（初始值及最大值）</p>
</li>
<li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p>
</li>
<li><p>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</p>
</li>
<li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p>
</li>
<li><p>-XX：+PrintGCDetails：输出详细的GC处理日志</p>
<ul>
<li>打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc</li>
</ul>
</li>
<li><p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p>
</li>
</ul>
<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul>
<li>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li>
<li>如果小于，则改为进行一次FullGC。</li>
<li>如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。</li>
</ul>
</li>
</ul>
<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p>
<h2 id="10-堆是分配对象的唯一选择么？"><a href="#10-堆是分配对象的唯一选择么？" class="headerlink" title="10 堆是分配对象的唯一选择么？"></a>10 堆是分配对象的唯一选择么？</h2><h3 id="10-1-逃逸分析"><a href="#10-1-逃逸分析" class="headerlink" title="10.1 逃逸分析"></a>10.1 逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>
<p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
<p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
<h4 id="1-逃逸分析举例"><a href="#1-逃逸分析举例" class="headerlink" title="1 逃逸分析举例"></a>1 逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">my_method</span><span class="hljs-params">()</span> </span>&#123;
    V v = <span class="hljs-keyword">new</span> V();
    <span class="hljs-comment">// use v</span>
    <span class="hljs-comment">// ....</span>
    v = <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>

<p>针对下面的代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;
    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();
    sb.append(s1);
    sb.append(s2);
    <span class="hljs-keyword">return</span> sb;
&#125;</code></pre></div>

<p>如果想要StringBuffer sb不发生逃逸，可以这样写</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;
    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();
    sb.append(s1);
    sb.append(s2);
    <span class="hljs-keyword">return</span> sb.toString();
&#125;</code></pre></div>

<p>完整的逃逸分析代码举例</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 逃逸分析</span>
<span class="hljs-comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EscapeAnalysis</span> </span>&#123;

    <span class="hljs-keyword">public</span> EscapeAnalysis obj;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> EscapeAnalysis <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> obj == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> EscapeAnalysis():obj;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 为成员属性赋值，发生逃逸</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setObj</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.obj = <span class="hljs-keyword">new</span> EscapeAnalysis();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useEscapeAnalysis</span><span class="hljs-params">()</span> </span>&#123;
        EscapeAnalysis e = <span class="hljs-keyword">new</span> EscapeAnalysis();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 引用成员变量的值，发生逃逸</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useEscapeAnalysis2</span><span class="hljs-params">()</span> </span>&#123;
        EscapeAnalysis e = getInstance();
        <span class="hljs-comment">// getInstance().XXX  发生逃逸</span>
    &#125;
&#125;</code></pre></div>

<h4 id="2-参数设置"><a href="#2-参数设置" class="headerlink" title="2 参数设置"></a>2 参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p>
<p>如果使用的是较早的版本，开发人员则可以通过：</p>
<ul>
<li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li>
<li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>
</ul>
<h4 id="3-结论"><a href="#3-结论" class="headerlink" title="3 结论"></a>3 结论</h4><p>开发中能使用局部变量的，就不要使用在方法外定义。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ul>
<li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>
<li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ul>
<h3 id="10-2-栈上分配"><a href="#10-2-栈上分配" class="headerlink" title="10.2 栈上分配"></a>10.2 栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<p>常见的栈上分配的场景</p>
<blockquote>
<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p>
</blockquote>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 栈上分配</span>
<span class="hljs-comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> String age;
    <span class="hljs-keyword">private</span> String gender;
    <span class="hljs-keyword">private</span> String phone;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackAllocation</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;
            alloc();
        &#125;
        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);

        <span class="hljs-comment">// 为了方便查看堆内存中对象个数，线程sleep</span>
        Thread.sleep(<span class="hljs-number">10000000</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 未发生逃逸</span>
        User user = <span class="hljs-keyword">new</span> User(); 
    &#125;
&#125;</code></pre></div>

<p>设置JVM参数，表示未开启逃逸分析</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></code></pre></div>

<p>运行结果，同时还触发了GC操作</p>
<div class="code-wrapper"><pre><code class="hljs plain">花费的时间为：664 ms</code></pre></div>

<p>然后查看内存的情况，发现有大量的User存储在堆中</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707203038615.png" alt="image-20200707203038615"></p>
<p>我们在开启逃逸分析</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span></code></pre></div>

<p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p>
<div class="code-wrapper"><pre><code class="hljs plain">花费的时间为：5 ms</code></pre></div>

<p>在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707203441718.png" alt="image-20200707203441718"></p>
<h3 id="10-3-同步省略"><a href="#10-3-同步省略" class="headerlink" title="10.3 同步省略"></a>10.3 同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
<p>例如下面的代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;
    Object hellis = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-keyword">synchronized</span>(hellis) &#123;
        System.out.println(hellis);
    &#125;
&#125;</code></pre></div>

<p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;
    Object hellis = <span class="hljs-keyword">new</span> Object();
	System.out.println(hellis);
&#125;</code></pre></div>

<p>我们将其转换成字节码</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707205634266.png" alt="image-20200707205634266"></p>
<h3 id="10-4-分离对象和标量替换"><a href="#10-4-分离对象和标量替换" class="headerlink" title="10.4 分离对象和标量替换"></a>10.4 分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;
    alloc();
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;
&#125;
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;
    Point point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
    System.out.println(<span class="hljs-string">&quot;point.x&quot;</span> + point.x + <span class="hljs-string">&quot;;point.y&quot;</span> + point.y);
&#125;</code></pre></div>

<p>以上代码，经过标量替换后，就会变成</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>;
    System.out.println(<span class="hljs-string">&quot;point.x = &quot;</span> + x + <span class="hljs-string">&quot;; point.y=&quot;</span> + y);
&#125;</code></pre></div>

<p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p>
<h3 id="10-5-代码优化之标量替换"><a href="#10-5-代码优化之标量替换" class="headerlink" title="10.5 代码优化之标量替换"></a>10.5 代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>
<div class="code-wrapper"><pre><code class="hljs bash">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></pre></div>

<p>这里设置参数如下：</p>
<ul>
<li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li>
<li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li>
<li>参数-Xmx10m：指定了堆空间最大为10MB</li>
<li>参数-XX:+PrintGC：将打印Gc日志</li>
<li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>
</ul>
<h3 id="10-6-逃逸分析的不足"><a href="#10-6-逃逸分析的不足" class="headerlink" title="10.6 逃逸分析的不足"></a>10.6 逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p>
<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。<br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>
<p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p>
<h2 id="11-小结"><a href="#11-小结" class="headerlink" title="11 小结"></a>11 小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
<p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p>
<p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
<h1 id="第9章-方法区"><a href="#第9章-方法区" class="headerlink" title="第9章 方法区"></a>第9章 方法区</h1><h2 id="9-1-前言"><a href="#9-1-前言" class="headerlink" title="9.1 前言"></a>9.1 前言</h2><p>这次所讲述的是运行时数据区的最后一个部分</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708093918121.png" alt="image-20200708093918121"></p>
<p>从线程共享与否的角度来看</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708093918121.png" alt="image-20200708093918121"></p>
<p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p>
<h2 id="9-2-栈、堆、方法区的交互关系"><a href="#9-2-栈、堆、方法区的交互关系" class="headerlink" title="9.2 栈、堆、方法区的交互关系"></a>9.2 栈、堆、方法区的交互关系</h2><p>下面就涉及了对象的访问定位</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708094747667.png" alt="image-20200708094747667"></p>
<ul>
<li>Person：存放在元空间，也可以说方法区</li>
<li>person：存放在Java栈的局部变量表中</li>
<li>new Person()：存放在Java堆中</li>
</ul>
<h2 id="9-3-方法区的理解"><a href="#9-3-方法区的理解" class="headerlink" title="9.3 方法区的理解"></a>9.3 方法区的理解</h2><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p>
<p>所以，方法区看作是一块独立于Java堆的内存空间。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708095853544.png" alt="image-20200708095853544"></p>
<p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p>
<ul>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul>
<li>加载大量的第三方的jar包</li>
<li>Tomcat部署的工程过多（30~50个）</li>
<li>大量动态的生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ul>
<h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p>
<ul>
<li>JDK 1.8后，元空间存放在堆外内存中</li>
</ul>
<p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。            </p>
<blockquote>
<p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）</p>
</blockquote>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708102919149.png" alt="image-20200708102919149"></p>
<p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708103055914.png" alt="image-20200708103055914"></p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p>
<p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p>
<p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p>
<h2 id="9-4-设置方法区大小与OOM"><a href="#9-4-设置方法区大小与OOM" class="headerlink" title="9.4 设置方法区大小与OOM"></a>9.4 设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 </p>
<h3 id="1-jdk7及以前"><a href="#1-jdk7及以前" class="headerlink" title="1 jdk7及以前"></a>1 jdk7及以前</h3><ul>
<li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li>
<li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li>
<li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708111756800.png" alt="image-20200708111756800"></p>
<h3 id="2-JDK8以后"><a href="#2-JDK8以后" class="headerlink" title="2 JDK8以后"></a>2 JDK8以后</h3><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p>
<p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p>
<p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p>
<p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，FullGC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
<p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到FullGC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p>
<h3 id="3-如何解决这些OOM"><a href="#3-如何解决这些OOM" class="headerlink" title="3 如何解决这些OOM"></a>3 如何解决这些OOM</h3><ul>
<li><p>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</p>
<ul>
<li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li>
</ul>
</li>
<li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p>
</li>
<li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
</li>
</ul>
<h2 id="9-5-方法区的内部结构"><a href="#9-5-方法区的内部结构" class="headerlink" title="9.5  方法区的内部结构"></a>9.5  方法区的内部结构</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708161728320.png" alt="image-20200708161728320"></p>
<p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708161856504.png" alt="image-20200708161856504"></p>
<h3 id="1-类型信息"><a href="#1-类型信息" class="headerlink" title="1 类型信息"></a>1 类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<h3 id="2-域信息"><a href="#2-域信息" class="headerlink" title="2 域信息"></a>2 域信息</h3><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p>
<h3 id="3-方法（Method）信息"><a href="#3-方法（Method）信息" class="headerlink" title="3 方法（Method）信息"></a>3 方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外）</li>
</ul>
<blockquote>
<p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p>
</blockquote>
<h3 id="4-non-final的类变量"><a href="#4-non-final的类变量" class="headerlink" title="4 non-final的类变量"></a>4 non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p>
<p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * non-final的类变量</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Order order = <span class="hljs-keyword">new</span> Order();
        order.hello();
        System.out.println(order.count);
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">2</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p>
<h3 id="5-全局常量"><a href="#5-全局常量" class="headerlink" title="5 全局常量"></a>5 全局常量</h3><p>全局常量就是使用 static final 进行修饰</p>
<p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 </p>
<h3 id="6-运行时常量池-VS-常量池"><a href="#6-运行时常量池-VS-常量池" class="headerlink" title="6 运行时常量池 VS 常量池"></a>6 运行时常量池 VS 常量池</h3><p>运行时常量池，就是运行时常量池</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708171151384.png" alt="image-20200708171151384"></p>
<ul>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池</li>
<li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li>
</ul>
<h3 id="7-常量池"><a href="#7-常量池" class="headerlink" title="7 常量池"></a>7 常量池</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708172357052.png" alt="image-20200708172357052"></p>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p>
<h4 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。</p>
<p>比如：如下的代码：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleClass</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p>
<h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h4><ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<p>例如下面这段代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaTest2</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;
        Object obj = <span class="hljs-keyword">new</span> Object();
    &#125;
&#125;</code></pre></div>

<p>将会被翻译成如下字节码</p>
<div class="code-wrapper"><pre><code class="hljs bash">new <span class="hljs-comment">#2  </span>
dup
invokespecial</code></pre></div>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p>
<h3 id="8-运行时常量池"><a href="#8-运行时常量池" class="headerlink" title="8 运行时常量池"></a>8 运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p>
<p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p>
<p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p>
<p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</p>
<p>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</p>
<p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p>
<h2 id="9-6-方法区使用举例"><a href="#9-6-方法区使用举例" class="headerlink" title="9.6 方法区使用举例"></a>9.6 方法区使用举例</h2><p>如下代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;
        <span class="hljs-keyword">int</span> x = <span class="hljs-number">500</span>;
        <span class="hljs-keyword">int</span> y = <span class="hljs-number">100</span>;
        <span class="hljs-keyword">int</span> a = x / y;
        <span class="hljs-keyword">int</span> b = <span class="hljs-number">50</span>;
        System.out.println(a+b);
    &#125;
&#125;</code></pre></div>

<p>字节码执行过程展示</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708204750374.png" alt="image-20200708204750374"></p>
<p>首先现将操作数500放入到操作数栈中</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708204953552.png" alt="image-20200708204953552"></p>
<p>然后存储到局部变量表中</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205029376.png" alt="image-20200708205029376"></p>
<p>然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205221737.png" alt="image-20200708205221737"></p>
<p>将500 和 100 进行一个除法运算，在把结果入栈</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205413721.png" alt="image-20200708205413721"></p>
<p>在最后就是输出流，需要调用运行时常量池的常量</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205708057.png" alt="image-20200708205708057"></p>
<p>最后调用invokevirtual（虚方法调用），然后返回</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205909176.png" alt="image-20200708205909176"></p>
<p>返回时</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708210540696.png" alt="image-20200708210540696"></p>
<p>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p>
<h2 id="9-7-方法区的演进细节"><a href="#9-7-方法区的演进细节" class="headerlink" title="9.7 方法区的演进细节"></a>9.7 方法区的演进细节</h2><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p>
<p>Hotspot中方法区的变化：</p>
<table>
<thead>
<tr>
<th>JDK1.6及以前</th>
<th>有永久代，静态变量存储在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7</td>
<td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td>
</tr>
<tr>
<td>JDK1.8</td>
<td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td>
</tr>
</tbody></table>
<p>JDK6的时候</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708211541300.png" alt="image-20200708211541300"></p>
<p>JDK7的时候</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708211609911.png" alt="image-20200708211609911"></p>
<p>JDK8的时候，元空间大小只受物理内存影响</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708211637952.png" alt="image-20200708211637952"></p>
<h3 id="1-为什么永久代要被元空间替代？"><a href="#1-为什么永久代要被元空间替代？" class="headerlink" title="1 为什么永久代要被元空间替代？"></a>1 为什么永久代要被元空间替代？</h3><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p>
<p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p>
<ul>
<li>为永久代设置空间大小是很难确定的。</li>
</ul>
<p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工<br>程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>
<p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p>
<p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。<br>因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<ul>
<li>对永久代进行调优是很困难的。<ul>
<li>主要是为了降低Full GC</li>
</ul>
</li>
</ul>
<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。<br>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p>
<h3 id="2-StringTable为什么要调整位置"><a href="#2-StringTable为什么要调整位置" class="headerlink" title="2 StringTable为什么要调整位置"></a>2 StringTable为什么要调整位置</h3><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而ful1gc是老年代的空间不足、永久代不足时才会触发。</p>
<p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h3 id="3-静态变量存放在那里？"><a href="#3-静态变量存放在那里？" class="headerlink" title="3 静态变量存放在那里？"></a>3 静态变量存放在那里？</h3><p>静态引用对应的对象实体始终都存在堆空间</p>
<p>可以使用 jhsdb.ext，需要在jdk9的时候才引入的</p>
<p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708215025527.png" alt="image-20200708215025527"></p>
<p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。</p>
<p>接着，找到了一个引用该staticobj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708215218078.png" alt="image-20200708215218078"></p>
<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点</p>
<h2 id="9-8-方法区的垃圾回收"><a href="#9-8-方法区的垃圾回收" class="headerlink" title="9.8 方法区的垃圾回收"></a>9.8 方法区的垃圾回收</h2><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p>
<p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li>
</ul>
<h2 id="9-9-总结"><a href="#9-9-总结" class="headerlink" title="9.9 总结"></a>9.9 总结</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708220303243.png" alt="image-20200708220303243"></p>
<h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p>百度<br>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p>
<p>蚂蚁金服：<br>Java8的内存分代改进<br>JVM内存分哪几个区，每个区的作用是什么？<br>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？<br>二面：Eden和survior的比例分配</p>
<p>小米：<br>jvm内存分区，为什么要有新生代和老年代</p>
<p>字节跳动：<br>二面：Java的内存分区<br>二面：讲讲vm运行时数据库区<br>什么时候对象会进入老年代？</p>
<p>京东：<br>JVM的内存结构，Eden和Survivor比例。<br>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p>
<p>天猫：<br>一面：Jvm内存模型以及分区，需要详细到每个区放什么。<br>一面：JVM的内存模型，Java8做了什么改</p>
<p>拼多多：<br>JVM内存分哪几个区，每个区的作用是什么？</p>
<p>美团：<br>java内存分配<br>jvm的永久代中会发生垃圾回收吗？<br>一面：jvm内存分区，为什么要有新生代和老年代？</p>
<h1 id="第10章-对象实例化内存布局与访问定位"><a href="#第10章-对象实例化内存布局与访问定位" class="headerlink" title="第10章 对象实例化内存布局与访问定位"></a>第10章 对象实例化内存布局与访问定位</h1><h2 id="1-对象实例化"><a href="#1-对象实例化" class="headerlink" title="1 对象实例化"></a>1 对象实例化</h2><h3 id="1-1-面试题"><a href="#1-1-面试题" class="headerlink" title="1.1 面试题"></a>1.1 面试题</h3><ul>
<li>对象在JVM中是怎么存储的？</li>
<li>对象头信息里面有哪些东西？</li>
<li>Java对象头有什么？</li>
</ul>
<p>从对象创建的方式 和 步骤开始说</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709095356247.png" alt="image-20200709095356247"></p>
<h3 id="1-2-对象创建方式"><a href="#1-2-对象创建方式" class="headerlink" title="1.2 对象创建方式"></a>1.2 对象创建方式</h3><ul>
<li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li>
<li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</li>
<li>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</li>
<li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li>
<li>使用序列化：序列化一般用于Socket的网络传输</li>
<li>第三方库 Objenesis</li>
</ul>
<h3 id="1-3-创建对象的步骤"><a href="#1-3-创建对象的步骤" class="headerlink" title="1.3 创建对象的步骤"></a>1.3 创建对象的步骤</h3><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p>
<h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p>
<ul>
<li><p>如果内存规整：指针碰撞</p>
</li>
<li><p>如果内存不规整</p>
<ul>
<li>虚拟表需要维护一个列表</li>
<li>空闲列表分配</li>
</ul>
</li>
</ul>
<p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p>
<p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p>
<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p>
<p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><ul>
<li>采用CAS配上失败重试保证更新的原子性</li>
<li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul>
<li>在Eden区给每个线程分配一块区域</li>
</ul>
</li>
</ul>
<h3 id="1-4-初始化分配到的内存"><a href="#1-4-初始化分配到的内存" class="headerlink" title="1.4 初始化分配到的内存"></a>1.4 初始化分配到的内存</h3><p>给对象属性赋值的操作</p>
<ul>
<li><p>属性的默认初始化</p>
</li>
<li><p>显示初始化</p>
</li>
<li><p>代码块中的初始化</p>
</li>
<li><p>构造器初始化</p>
</li>
<li><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p>
</li>
</ul>
<h3 id="1-5-设置对象的对象头"><a href="#1-5-设置对象的对象头" class="headerlink" title="1.5 设置对象的对象头"></a>1.5 设置对象的对象头</h3><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<h3 id="1-6-执行init方法进行初始化"><a href="#1-6-执行init方法进行初始化" class="headerlink" title="1.6 执行init方法进行初始化"></a>1.6 执行init方法进行初始化</h3><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p>
<p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>
<h3 id="1-7-对象实例化的过程"><a href="#1-7-对象实例化的过程" class="headerlink" title="1.7 对象实例化的过程"></a>1.7 对象实例化的过程</h3><ul>
<li>加载类元信息</li>
<li>为对象分配内存</li>
<li>处理并发问题</li>
<li>属性的默认初始化（零值初始化）</li>
<li>设置对象头信息</li>
<li>属性的显示初始化、代码块中初始化、构造器中初始化</li>
</ul>
<h2 id="1-8-对象内存布局"><a href="#1-8-对象内存布局" class="headerlink" title="1.8 对象内存布局"></a>1.8 对象内存布局</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709151033237.png" alt="image-20200709151033237"></p>
<h3 id="1-9-对象头"><a href="#1-9-对象头" class="headerlink" title="1.9 对象头"></a>1.9 对象头</h3><p>对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针</p>
<blockquote>
<p>如果是数组，还需要记录数组的长度</p>
</blockquote>
<h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul>
<li>哈希值（HashCode）</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>翩向时间戳</li>
</ul>
<h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</p>
<h3 id="1-10-实例数据（Instance-Data）"><a href="#1-10-实例数据（Instance-Data）" class="headerlink" title="1.10 实例数据（Instance Data）"></a>1.10 实例数据（Instance Data）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p>
<h3 id="1-11-小结"><a href="#1-11-小结" class="headerlink" title="1.11 小结"></a>1.11 小结</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709152801713.png" alt="image-20200709152801713"></p>
<h2 id="2-对象的访问定位"><a href="#2-对象的访问定位" class="headerlink" title="2 对象的访问定位"></a>2 对象的访问定位</h2><h3 id="2-1-图示"><a href="#2-1-图示" class="headerlink" title="2.1 图示"></a>2.1 图示</h3><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709164149920.png" alt="image-20200709164149920"></p>
<h3 id="2-2-对象访问的两种方式"><a href="#2-2-对象访问的两种方式" class="headerlink" title="2.2 对象访问的两种方式"></a>2.2 对象访问的两种方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709164342002.png" alt="image-20200709164342002"></p>
<p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p>
<h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709164350466.png" alt="image-20200709164350466"></p>
<p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p>
<h1 id="第11章-直接内存-Direct-Memory"><a href="#第11章-直接内存-Direct-Memory" class="headerlink" title="第11章 直接内存 Direct Memory"></a>第11章 直接内存 Direct Memory</h1><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p>
<p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p>
<p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p>
<p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p>
<ul>
<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li>
</ul>
<p>使用下列代码，直接分配本地内存空间</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> BUFFER = <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; <span class="hljs-comment">// 1GB</span>
ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</code></pre></div>

<h2 id="非直接缓存区和缓存区"><a href="#非直接缓存区和缓存区" class="headerlink" title="非直接缓存区和缓存区"></a>非直接缓存区和缓存区</h2><p>原来采用BIO的架构，我们需要从用户态切换成内核态</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/images/image-20200709170907611.png" alt="image-20200709170907611"></p>
<p>NIO的方式使用了缓存区的概念</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>也可能导致outofMemoryError异常</p>
<p>由于直接内存在Java堆外，因此它的大小不会直接受限于-xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。<br>缺点</p>
<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
<p>直接内存大小可以通过MaxDirectMemorySize设置</p>
<p>如果不指定，默认与堆的最大值-xmx参数值一致</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/images/image-20200709230647277.png" alt="image-20200709230647277"></p>
<h1 id="第12章执行引擎"><a href="#第12章执行引擎" class="headerlink" title="第12章执行引擎"></a>第12章执行引擎</h1><h2 id="1-执行引擎概述"><a href="#1-执行引擎概述" class="headerlink" title="1 执行引擎概述"></a>1 执行引擎概述</h2><p>执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710080707873.png" alt="image-20200710080707873"></p>
<p>执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
<p>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710081118053.png" alt="image-20200710081118053"></p>
<p>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p>
<h3 id="执行引擎的工作流程"><a href="#执行引擎的工作流程" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h3><ul>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li>
<li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710081627217.png" alt="image-20200710081627217"></p>
<p>从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p>
<h2 id="2-Java代码编译和执行过程"><a href="#2-Java代码编译和执行过程" class="headerlink" title="2 Java代码编译和执行过程"></a>2 Java代码编译和执行过程</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p>
<ul>
<li>前面橙色部分是生成字节码文件的过程，和JVM无关</li>
<li>后面蓝色和绿色才是JVM需要考虑的过程</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710082141643.png" alt="image-20200710082141643"></p>
<p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710082433146.png" alt="image-20200710082433146"></p>
<p>Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710083036258.png" alt="image-20200710083036258"></p>
<p>我们用一个总的图，来说说 解释器和编译器</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710083656277.png" alt="image-20200710083656277"></p>
<h3 id="2-1-什么是解释器（Interpreter）"><a href="#2-1-什么是解释器（Interpreter）" class="headerlink" title="2.1 什么是解释器（Interpreter）"></a>2.1 什么是解释器（Interpreter）</h3><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<h3 id="2-2-什么是IT编译器"><a href="#2-2-什么是IT编译器" class="headerlink" title="2.2 什么是IT编译器"></a>2.2 什么是IT编译器</h3><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>
<h3 id="2-3-为什么Java是半编译半解释型语言"><a href="#2-3-为什么Java是半编译半解释型语言" class="headerlink" title="2.3 为什么Java是半编译半解释型语言"></a>2.3 为什么Java是半编译半解释型语言</h3><p>JDK1.x时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p>
<p>翻译成本地代码后，就可以做一个缓存操作，存储在方法区中</p>
<h2 id="3-机器码、指令、汇编语言"><a href="#3-机器码、指令、汇编语言" class="headerlink" title="3 机器码、指令、汇编语言"></a>3 机器码、指令、汇编语言</h2><h3 id="3-1-机器码"><a href="#3-1-机器码" class="headerlink" title="3.1 机器码"></a>3.1 机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p>
<p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p>
<p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p>
<p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p>
<h3 id="3-2-指令"><a href="#3-2-指令" class="headerlink" title="3.2 指令"></a>3.2 指令</h3><p>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p>
<p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p>
<p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p>
<h3 id="3-3-指令集"><a href="#3-3-指令集" class="headerlink" title="3.3 指令集"></a>3.3 指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。<br>如常见的</p>
<ul>
<li>x86指令集，对应的是x86架构的平台</li>
<li>ARM指令集，对应的是ARM架构的平台</li>
</ul>
<h3 id="3-4-汇编语言"><a href="#3-4-汇编语言" class="headerlink" title="3.4 汇编语言"></a>3.4 汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p>
<p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbo1）或标号（Labe1）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p>
<blockquote>
<p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</p>
</blockquote>
<h3 id="3-5-高级语言"><a href="#3-5-高级语言" class="headerlink" title="3.5 高级语言"></a>3.5 高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。</p>
<p>高级语言比机器语言、汇编语言更接近人的语言当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710085323733.png" alt="image-20200710085323733"></p>
<p>高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++</p>
<h3 id="3-6-C、C-源程序执行过程"><a href="#3-6-C、C-源程序执行过程" class="headerlink" title="3.6 C、C++源程序执行过程"></a>3.6 C、C++源程序执行过程</h3><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p>
<p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710085553258.png" alt="image-20200710085553258"></p>
<h3 id="3-7-字节码"><a href="#3-7-字节码" class="headerlink" title="3.7 字节码"></a>3.7 字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p>
<p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p>
<p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p>
<ul>
<li>字节码典型的应用为：Java bytecode</li>
</ul>
<h2 id="4-解释器"><a href="#4-解释器" class="headerlink" title="4 解释器"></a>4 解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710090203674.png" alt="image-20200710090203674"></p>
<p>为什么Java源文件不直接翻译成JMV，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的</p>
<p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
<h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p>
<p>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</p>
<p>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p>
<p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p>
<ul>
<li>Interpreter模块：实现了解释器的核心功能</li>
<li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li>
</ul>
<h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</p>
<p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p>
<p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p>
<h2 id="5-JIT编译器"><a href="#5-JIT编译器" class="headerlink" title="5 JIT编译器"></a>5 JIT编译器</h2><h3 id="5-1-Java代码的执行分类"><a href="#5-1-Java代码的执行分类" class="headerlink" title="5.1 Java代码的执行分类"></a>5.1 Java代码的执行分类</h3><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p>
<p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p>
<p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p>
<p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</p>
<h3 id="5-2-问题来了"><a href="#5-2-问题来了" class="headerlink" title="5.2 问题来了"></a>5.2 问题来了</h3><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<ul>
<li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li>
</ul>
<p>首先明确：<br>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。<br>编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>所以：<br>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</p>
<p>在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
<h3 id="5-3-HotSpot-JVM执行方式"><a href="#5-3-HotSpot-JVM执行方式" class="headerlink" title="5.3 HotSpot JVM执行方式"></a>5.3 HotSpot JVM执行方式</h3><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p>
<h3 id="5-4-案例"><a href="#5-4-案例" class="headerlink" title="5.4 案例"></a>5.4 案例</h3><p>注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710095417462.png" alt="image-20200710095417462"></p>
<h3 id="5-5-概念解释"><a href="#5-5-概念解释" class="headerlink" title="5.5 概念解释"></a>5.5 概念解释</h3><ul>
<li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）</li>
<li>把字节码转变成机器码的过程。</li>
<li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。</li>
</ul>
<p>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p>
<p>JIT编译器：HotSpot VM的C1、C2编译器。</p>
<p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p>
<h3 id="5-6-热点探测技术"><a href="#5-6-热点探测技术" class="headerlink" title="5.6 热点探测技术"></a>5.6 热点探测技术</h3><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。</p>
<p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p>
<p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</p>
<p>采用基于计数器的热点探测，HotSpot V将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p>
<ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
<h3 id="5-7-方法调用计数器"><a href="#5-7-方法调用计数器" class="headerlink" title="5.7 方法调用计数器"></a>5.7 方法调用计数器</h3><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p>
<p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p>
<p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710101829934.png" alt="image-20200710101829934"></p>
<h3 id="5-8-热点衰减"><a href="#5-8-热点衰减" class="headerlink" title="5.8 热点衰减"></a>5.8 热点衰减</h3><p> 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）</p>
<ul>
<li>半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄</li>
</ul>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<br>-XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p>
<p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p>
<h3 id="5-9-回边计数器"><a href="#5-9-回边计数器" class="headerlink" title="5.9 回边计数器"></a>5.9 回边计数器</h3><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710103103869.png" alt="image-20200710103103869"></p>
<h3 id="5-10-HotSpotVM-可以设置程序执行方法"><a href="#5-10-HotSpotVM-可以设置程序执行方法" class="headerlink" title="5.10 HotSpotVM 可以设置程序执行方法"></a>5.10 HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p>
<ul>
<li>-Xint：完全采用解释器模式执行程序；</li>
<li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710103340273.png" alt="image-20200710103340273"></p>
<h3 id="5-11-HotSpotVM中-JIT-分类"><a href="#5-11-HotSpotVM中-JIT-分类" class="headerlink" title="5.11 HotSpotVM中 JIT 分类"></a>5.11 HotSpotVM中 JIT 分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li><p>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；</p>
<ul>
<li>C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。</li>
</ul>
</li>
<li><p>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。</p>
<ul>
<li>C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用C++）</li>
</ul>
</li>
</ul>
<h3 id="5-12-C1-和-C2编译器不同的优化策略"><a href="#5-12-C1-和-C2编译器不同的优化策略" class="headerlink" title="5.12 C1 和 C2编译器不同的优化策略"></a>5.12 C1 和 C2编译器不同的优化策略</h3><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。</p>
<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li>去虚拟化：对唯一的实现樊进行内联</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
<p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p>
<ul>
<li>标量替换：用标量值代替聚合对象的属性值</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li>
<li>同步消除：清除同步操作，通常指synchronized</li>
</ul>
<h3 id="5-13-分层编译策略"><a href="#5-13-分层编译策略" class="headerlink" title="5.13 分层编译策略"></a>5.13 分层编译策略</h3><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p>
<p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p>
<h3 id="5-14-总结"><a href="#5-14-总结" class="headerlink" title="5.14 总结"></a>5.14 总结</h3><ul>
<li>一般来讲，JIT编译出来的机器码性能比解释器搞</li>
<li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li>
</ul>
<h3 id="5-15-AOT编译器"><a href="#5-15-AOT编译器" class="headerlink" title="5.15 AOT编译器"></a>5.15 AOT编译器</h3><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p>
<p>Java 9引入了实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p>
<p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p>
<div class="code-wrapper"><pre><code class="hljs livescript">.java -&gt; .<span class="hljs-keyword">class</span> -&gt; <span class="hljs-function"><span class="hljs-params">(使用jaotc)</span> -&gt;</span> .so</code></pre></div>

<p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</p>
<p>缺点：</p>
<ul>
<li>破坏了 java  “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li>
<li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li>
<li>还需要继续优化中，最初只支持Linux X64 java base</li>
</ul>
<h3 id="5-16-写到最后"><a href="#5-16-写到最后" class="headerlink" title="5.16 写到最后"></a>5.16 写到最后</h3><ul>
<li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器</li>
<li>编译效果短短几年时间就追评了G2编译器，未来可期</li>
<li>目前，带着实验状态标签，需要使用开关参数去激活才能使用</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</span></code></pre></div>

<h1 id="第13章-StringTable"><a href="#第13章-StringTable" class="headerlink" title="第13章 StringTable"></a>第13章 StringTable</h1><h2 id="1-String的基本特性"><a href="#1-String的基本特性" class="headerlink" title="1 String的基本特性"></a>1 String的基本特性</h2><ul>
<li>String：字符串，使用一对 ”” 引起来表示<ul>
<li>String s1 = “mogublog” ;   // 字面量的定义方式</li>
<li>String s2 =  new String(“moxi”); </li>
</ul>
</li>
<li>string声明为final的，不可被继承</li>
<li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小</li>
<li>string在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</li>
</ul>
<h3 id="1-1-为什么JDK9改变了结构"><a href="#1-1-为什么JDK9改变了结构" class="headerlink" title="1.1 为什么JDK9改变了结构"></a>1.1 为什么JDK9改变了结构</h3><p>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。</p>
<p>我们建议改变字符串的内部表示class从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。</p>
<p>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 之前</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];
<span class="hljs-comment">// 之后</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] value</code></pre></div>

<p>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</p>
<h3 id="1-2-String的不可变性"><a href="#1-2-String的不可变性" class="headerlink" title="1.2 String的不可变性"></a>1.2 String的不可变性</h3><p>String：代表不可变的字符序列。简称：不可变性。</p>
<blockquote>
<p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
</blockquote>
<p>代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * String的不可变性</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTest1</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span>
        String s1 = <span class="hljs-string">&quot;abc&quot;</span>;
        String s2 = <span class="hljs-string">&quot;abc&quot;</span>;
        System.out.println(s1 == s2);
        s1 = <span class="hljs-string">&quot;hello&quot;</span>;
        System.out.println(s1 == s2);
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(<span class="hljs-string">&quot;----------------&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;
        String s1 = <span class="hljs-string">&quot;abc&quot;</span>;
        String s2 = <span class="hljs-string">&quot;abc&quot;</span>;
        <span class="hljs-comment">// 只要进行了修改，就会重新创建一个对象，这就是不可变性</span>
        s2 += <span class="hljs-string">&quot;def&quot;</span>;
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(<span class="hljs-string">&quot;----------------&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;
        String s1 = <span class="hljs-string">&quot;abc&quot;</span>;
        String s2 = s1.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>);
        System.out.println(s1);
        System.out.println(s2);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        test1();
        test2();
        test3();
    &#125;
&#125;</code></pre></div>

<p>运行结果</p>
<div class="code-wrapper"><pre><code class="hljs asciidoc">true
false
hello
abc
----------------
abc
abcdef
----------------
abc
mbc</code></pre></div>

<h3 id="1-3-面试题"><a href="#1-3-面试题" class="headerlink" title="1.3 面试题"></a>1.3 面试题</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 面试题</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringExer</span> </span>&#123;
    String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;good&quot;</span>);
    <span class="hljs-keyword">char</span> [] ch = &#123;<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>&#125;;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(String str, <span class="hljs-keyword">char</span> ch [])</span> </span>&#123;
        str = <span class="hljs-string">&quot;test ok&quot;</span>;
        ch[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        StringExer ex = <span class="hljs-keyword">new</span> StringExer();
        ex.change(ex.str, ex.ch);
        System.out.println(ex.str);
        System.out.println(ex.ch);
    &#125;
&#125;</code></pre></div>

<p>输出结果</p>
<div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">good</span>
<span class="hljs-attribute">best</span></code></pre></div>

<h3 id="1-4-注意"><a href="#1-4-注意" class="headerlink" title="1.4 注意"></a>1.4 注意</h3><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p>
<p>String的string Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进string Pool的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。</p>
<p>使用-XX:StringTablesize可设置stringTab1e的长度</p>
<p>在jdk6中stringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。stringTablesize设置没有要求</p>
<p>在jdk7中，stringTable的长度默认值是60013，</p>
<p>在JDK8中，StringTable可以设置的最小值为1009</p>
<h2 id="2-String的内存分配"><a href="#2-String的内存分配" class="headerlink" title="2 String的内存分配"></a>2 String的内存分配</h2><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>
<p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p>
<p>直接使用双引号声明出来的String对象会直接存储在常量池中。</p>
<ul>
<li>比如：String info=”atguigu.com”；</li>
</ul>
<p>如果不是用双引号声明的String对象，可以使用String提供的intern（）方法。</p>
<p>Java 6及以前，字符串常量池存放在永久代</p>
<p>Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p>
<blockquote>
<p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p>
<p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用string.intern（）。</p>
</blockquote>
<p>Java8元空间，字符串常量在堆</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711093546398.png" alt="image-20200711093546398"></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711093558709.png" alt="image-20200711093558709"></p>
<h3 id="2-1-为什么StringTable从永久代调整到堆中"><a href="#2-1-为什么StringTable从永久代调整到堆中" class="headerlink" title="2.1 为什么StringTable从永久代调整到堆中"></a>2.1 为什么StringTable从永久代调整到堆中</h3><p>在JDK 7中，interned字符串不再在Java堆的永久生成中分配，而是在Java堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern()方法会看到更显著的差异。</p>
<ul>
<li>永久代的默认比较小</li>
<li>永久代垃圾回收频率低</li>
</ul>
<h2 id="3-String的基本操作"><a href="#3-String的基本操作" class="headerlink" title="3 String的基本操作"></a>3 String的基本操作</h2><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p>
<h2 id="4-字符串拼接操作"><a href="#4-字符串拼接操作" class="headerlink" title="4 字符串拼接操作"></a>4 字符串拼接操作</h2><ul>
<li>常量与常量的拼接结果在常量池，原理是编译期优化</li>
<li>常量池中不会存在相同内容的变量</li>
<li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li>
<li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;
       String s1 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>;  <span class="hljs-comment">// 得到 abc的常量池</span>
       String s2 = <span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">// abc存放在常量池，直接将常量池的地址返回</span>
       <span class="hljs-comment">/**</span>
<span class="hljs-comment">        * 最终java编译成.class，再执行.class</span>
<span class="hljs-comment">        */</span>
       System.out.println(s1 == s2); <span class="hljs-comment">// true，因为存放在字符串常量池</span>
       System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span>
   &#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;
       String s1 = <span class="hljs-string">&quot;javaEE&quot;</span>;
       String s2 = <span class="hljs-string">&quot;hadoop&quot;</span>;
       String s3 = <span class="hljs-string">&quot;javaEEhadoop&quot;</span>;
       String s4 = <span class="hljs-string">&quot;javaEE&quot;</span> + <span class="hljs-string">&quot;hadoop&quot;</span>;    
       String s5 = s1 + <span class="hljs-string">&quot;hadoop&quot;</span>;
       String s6 = <span class="hljs-string">&quot;javaEE&quot;</span> + s2;
       String s7 = s1 + s2;

       System.out.println(s3 == s4); <span class="hljs-comment">// true</span>
       System.out.println(s3 == s5); <span class="hljs-comment">// false</span>
       System.out.println(s3 == s6); <span class="hljs-comment">// false</span>
       System.out.println(s3 == s7); <span class="hljs-comment">// false</span>
       System.out.println(s5 == s6); <span class="hljs-comment">// false</span>
       System.out.println(s5 == s7); <span class="hljs-comment">// false</span>
       System.out.println(s6 == s7); <span class="hljs-comment">// false</span>

       String s8 = s6.intern();
       System.out.println(s3 == s8); <span class="hljs-comment">// true</span>
   &#125;</code></pre></div>

<p>从上述的结果我们可以知道：</p>
<p>如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果</p>
<p>而调用intern方法，则会判断字符串常量池中是否存在JavaEEhadoop值，如果存在则返回常量池中的值，否者就在常量池中创建</p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>拼接操作的底层其实使用了StringBuilder</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711102231129.png" alt="image-20200711102231129"></p>
<p>s1 + s2的执行细节</p>
<ul>
<li>StringBuilder s = new StringBuilder();</li>
<li>s.append(s1);</li>
<li>s.append(s2);</li>
<li>s.toString();  -&gt; 类似于new String(“ab”);</li>
</ul>
<p>在JDK5之后，使用的是StringBuilder，在JDK5之前使用的是StringBuffer</p>
<table>
<thead>
<tr>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td>
<td>StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td>
<td>可变类，速度更快</td>
</tr>
<tr>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td></td>
<td>线程安全</td>
<td>线程不安全</td>
</tr>
<tr>
<td></td>
<td>多线程操作字符串</td>
<td>单线程操作字符串</td>
</tr>
</tbody></table>
<p>注意，我们左右两边如果是变量的话，就是需要new StringBuilder进行拼接，但是如果使用的是final修饰，则是从常量池中获取。所以说拼接符号左右两边都是字符串常量或常量引用 则仍然使用编译器优化。也就是说被final修饰的变量，将会变成常量，类和方法将不能被继承、</p>
<ul>
<li>在开发中，能够使用final的时候，建议使用上</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">final</span> String s1 = <span class="hljs-string">&quot;a&quot;</span>;
    <span class="hljs-keyword">final</span> String s2 = <span class="hljs-string">&quot;b&quot;</span>;
    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;
    String s4 = s1 + s2;
    System.out.println(s3 == s4);
&#125;</code></pre></div>

<p>运行结果</p>
<div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span></code></pre></div>

<h3 id="拼接操作和append性能对比"><a href="#拼接操作和append性能对比" class="headerlink" title="拼接操作和append性能对比"></a>拼接操作和append性能对比</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> highLevel)</span> </span>&#123;
    String src = <span class="hljs-string">&quot;&quot;</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; highLevel; i++) &#123;
        src += <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 每次循环都会创建一个StringBuilder对象</span>
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> highLevel)</span> </span>&#123;
    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; highLevel; i++) &#123;
        sb.append(<span class="hljs-string">&quot;a&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>方法1耗费的时间：4005ms，方法2消耗时间：7ms</p>
<p>结论：</p>
<ul>
<li>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</li>
</ul>
<p>好处</p>
<ul>
<li>StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象</li>
<li>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</li>
<li>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间</li>
</ul>
<p>改进的空间</p>
<ul>
<li>我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li>
<li>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</li>
</ul>
<h2 id="5-intern-的使用"><a href="#5-intern-的使用" class="headerlink" title="5 intern()的使用"></a>5 intern()的使用</h2><p>intern是一个native方法，调用的是底层C的方法</p>
<p>字符串池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串对象相等的字符串，则返回池中的字符串。否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。</p>
<p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>
<p>比如：</p>
<div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> myInfo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;I love atguigu&quot;</span>).<span class="hljs-built_in">intern</span>();</code></pre></div>

<p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p>
<div class="code-wrapper"><pre><code class="hljs java">（<span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>+<span class="hljs-string">&quot;c&quot;</span>）.intern（）==<span class="hljs-string">&quot;abc&quot;</span></code></pre></div>

<p>通俗点讲，Interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p>
<h3 id="intern的空间效率测试"><a href="#intern的空间效率测试" class="headerlink" title="intern的空间效率测试"></a>intern的空间效率测试</h3><p>我们通过测试一下，使用了intern和不使用的时候，其实相差还挺多的</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 使用Intern() 测试执行效率</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringIntern2</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_COUNT = <span class="hljs-number">1000</span> * <span class="hljs-number">10000</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] arr = <span class="hljs-keyword">new</span> String[MAX_COUNT];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Integer [] data = <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;
        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_COUNT; i++) &#123;
            arr[i] = <span class="hljs-keyword">new</span> String(String.valueOf(data[i%data.length])).intern();
        &#125;
        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start));

        <span class="hljs-keyword">try</span> &#123;
            Thread.sleep(<span class="hljs-number">1000000</span>);
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.getStackTrace();
        &#125;
    &#125;
&#125;</code></pre></div>

<p><strong>结论</strong>：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省内存空间。</p>
<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</p>
<h2 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6 面试题"></a>6 面试题</h2><h3 id="6-1-new-String-“ab”-会创建几个对象"><a href="#6-1-new-String-“ab”-会创建几个对象" class="headerlink" title="6.1 new String(“ab”)会创建几个对象"></a>6.1 new String(“ab”)会创建几个对象</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * new String(&quot;ab&quot;) 会创建几个对象？ 看字节码就知道是2个对象</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringNewTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ab&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>我们转换成字节码来查看</p>
<div class="code-wrapper"><pre><code class="hljs tap"><span class="hljs-number"> 0 </span>new <span class="hljs-comment">#2 &lt;java/lang/String&gt;</span>
<span class="hljs-number"> 3 </span>dup
<span class="hljs-number"> 4 </span>ldc <span class="hljs-comment">#3 &lt;ab&gt;</span>
<span class="hljs-number"> 6 </span>invokespecial <span class="hljs-comment">#4 &lt;java/lang/String.&lt;init&gt;&gt;</span>
<span class="hljs-number"> 9 </span>astore_1
10 return</code></pre></div>

<p>这里面就是两个对象</p>
<ul>
<li>一个对象是：new关键字在堆空间中创建</li>
<li>另一个对象：字符串常量池中的对象</li>
</ul>
<h3 id="6-2-new-String-“a”-new-String-“b”-会创建几个对象"><a href="#6-2-new-String-“a”-new-String-“b”-会创建几个对象" class="headerlink" title="6.2 new String(“a”) + new String(“b”) 会创建几个对象"></a>6.2 new String(“a”) + new String(“b”) 会创建几个对象</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * new String(&quot;ab&quot;) 会创建几个对象？ 看字节码就知道是2个对象</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringNewTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>字节码文件为</p>
<div class="code-wrapper"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder&gt;
 <span class="hljs-number">3</span> dup
 <span class="hljs-number">4</span> invokespecial #<span class="hljs-number">3</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.&lt;init&gt;&gt;
 <span class="hljs-number">7</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/lang/</span>String&gt;
<span class="hljs-number">10</span> dup
<span class="hljs-number">11</span> ldc #<span class="hljs-number">5</span> &lt;a&gt;
<span class="hljs-number">13</span> invokespecial #<span class="hljs-number">6</span> &lt;java<span class="hljs-regexp">/lang/</span>String.&lt;init&gt;&gt;
<span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.<span class="hljs-keyword">append</span>&gt;
<span class="hljs-number">19</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/lang/</span>String&gt;
<span class="hljs-number">22</span> dup
<span class="hljs-number">23</span> ldc #<span class="hljs-number">8</span> &lt;b&gt;
<span class="hljs-number">25</span> invokespecial #<span class="hljs-number">6</span> &lt;java<span class="hljs-regexp">/lang/</span>String.&lt;init&gt;&gt;
<span class="hljs-number">28</span> invokevirtual #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.<span class="hljs-keyword">append</span>&gt;
<span class="hljs-number">31</span> invokevirtual #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.toString&gt;
<span class="hljs-number">34</span> astore_1
<span class="hljs-number">35</span> <span class="hljs-keyword">return</span></code></pre></div>

<p>我们创建了6个对象</p>
<ul>
<li>对象1：new StringBuilder()</li>
<li>对象2：new String(“a”)</li>
<li>对象3：常量池的 a</li>
<li>对象4：new String(“b”)</li>
<li>对象5：常量池的 b</li>
<li>对象6：toString中会创建一个 new String(“ab”)<ul>
<li>调用toString方法，不会在常量池中生成ab</li>
</ul>
</li>
</ul>
<h3 id="6-3-intern的使用：JDK6和JDK7"><a href="#6-3-intern的使用：JDK6和JDK7" class="headerlink" title="6.3 intern的使用：JDK6和JDK7"></a>6.3 intern的使用：JDK6和JDK7</h3><h4 id="JDK6中"><a href="#JDK6中" class="headerlink" title="JDK6中"></a>JDK6中</h4><div class="code-wrapper"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);  <span class="hljs-comment">// 在常量池中已经有了</span>
s.intern(); <span class="hljs-comment">// 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1</span>
String s2 = <span class="hljs-string">&quot;1&quot;</span>;
System.out.println(s == s2); <span class="hljs-comment">// false</span>

String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);
s3.intern();
String s4 = <span class="hljs-string">&quot;11&quot;</span>;
System.out.println(s3 == s4); <span class="hljs-comment">// true</span></code></pre></div>

<p>输出结果</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">false</span>
<span class="hljs-keyword">true</span></code></pre></div>

<p>为什么对象会不一样呢？</p>
<ul>
<li>一个是new创建的对象，一个是常量池中的对象，显然不是同一个</li>
</ul>
<p>如果是下面这样的，那么就是true</p>
<div class="code-wrapper"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);
s = s.intern();
String s2 = <span class="hljs-string">&quot;1&quot;</span>;
System.out.println(s == s2); <span class="hljs-comment">// true</span></code></pre></div>

<p>而对于下面的来说，因为 s3变量记录的地址是  new String(“11”)，然后这段代码执行完以后，常量池中不存在 “11”，这是JDK6的关系，然后执行 s3.intern()后，就会在常量池中生成 “11”，最后 s4用的就是s3的地址</p>
<blockquote>
<p>为什么最后输出的 s3 == s4  会为false呢？</p>
<p>这是因为在JDK6中创建了一个新的对象 “11”，也就是有了新的地址， s2 = 新地址</p>
<p>而在JDK7中，在JDK7中，并没有创新一个新对象，而是指向常量池中的新对象</p>
</blockquote>
<h4 id="JDK7中"><a href="#JDK7中" class="headerlink" title="JDK7中"></a>JDK7中</h4><div class="code-wrapper"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);
s.intern();
String s2 = <span class="hljs-string">&quot;1&quot;</span>;
System.out.println(s == s2); <span class="hljs-comment">// true</span>

String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);
s3.intern();
String s4 = <span class="hljs-string">&quot;11&quot;</span>;
System.out.println(s3 == s4); <span class="hljs-comment">// true</span></code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711145925091.png" alt="image-20200711145925091"></p>
<h3 id="6-4-扩展"><a href="#6-4-扩展" class="headerlink" title="6.4 扩展"></a>6.4 扩展</h3><div class="code-wrapper"><pre><code class="hljs java">String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);
String s4 = <span class="hljs-string">&quot;11&quot;</span>;  <span class="hljs-comment">// 在常量池中生成的字符串</span>
s3.intern();  <span class="hljs-comment">// 然后s3就会从常量池中找，发现有了，就什么事情都不做</span>
System.out.println(s3 == s4);</code></pre></div>

<p>我们将 s4的位置向上移动一行，发现变化就会很大，最后得到的是 false</p>
<h3 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h3><p>总结string的intern（）的使用：</p>
<p>JDK1.6中，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，会把此<strong>对象复制一份</strong>，放入串池，并返回串池中的对象地址</li>
</ul>
<p>JDK1.7起，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，则会把<strong>对象的引用地址</strong>复制一份，放入串池，并返回串池中的引用地址</li>
</ul>
<p>练习：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711150859709.png" alt="image-20200711150859709"></p>
<ul>
<li>在JDK6中，在字符串常量池中创建一个字符串 “ab”</li>
<li>在JDK8中，在字符串常量池中没有创建 “ab”，而是将堆中的地址复制到 串池中。</li>
</ul>
<p>所以上述结果，在JDK6中是：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">true</span>
<span class="hljs-keyword">false</span></code></pre></div>

<p>在JDK8中是</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">false</span>
<span class="hljs-keyword">true</span></code></pre></div>

<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711151326909.png" alt="image-20200711151326909"></p>
<p>针对下面这题，在JDK6和8中表现的是一样的</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13_StringTable/images/image-20200711151433277.png" alt="image-20200711151433277"></p>
<h2 id="7-StringTable的垃圾回收"><a href="#7-StringTable的垃圾回收" class="headerlink" title="7 StringTable的垃圾回收"></a>7 StringTable的垃圾回收</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * String的垃圾回收</span>
<span class="hljs-comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringGCTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;
            String.valueOf(i).intern();
        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="8-G1中的String去重操作"><a href="#8-G1中的String去重操作" class="headerlink" title="8 G1中的String去重操作"></a>8 G1中的String去重操作</h2><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p>
<h3 id="8-1-描述"><a href="#8-1-描述" class="headerlink" title="8.1 描述"></a>8.1 描述</h3><p>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：</p>
<ul>
<li><p>堆存活数据集合里面string对象占了25%</p>
</li>
<li><p>堆存活数据集合里面重复的string对象有13.5%</p>
</li>
<li><p>string对象的平均长度是45</p>
</li>
</ul>
<p>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说：<br>stringl.equals（string2）= true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。</p>
<h3 id="8-2-实现"><a href="#8-2-实现" class="headerlink" title="8.2 实现"></a>8.2 实现</h3><ul>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的string对象。</li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。</li>
<li>使用一个hashtab1e来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，string对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li>
</ul>
<h3 id="8-3-开启"><a href="#8-3-开启" class="headerlink" title="8.3 开启"></a>8.3 开启</h3><p>命令行选项</p>
<blockquote>
<p>UsestringDeduplication（bool）：开启string去重，默认是不开启的，需要手动开启。<br>Printstringbeduplicationstatistics（bool）：打印详细的去重统计信息<br>stringpeduplicationAgeThreshold（uintx）：达到这个年龄的string对象被认为是去重的候选对象</p>
</blockquote>
<h1 id="第14章-垃圾回收概述"><a href="#第14章-垃圾回收概述" class="headerlink" title="第14章 垃圾回收概述"></a>第14章 垃圾回收概述</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>这次我们主要关注的是黄色部分，内存的分配与回收</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/images/image-20200712084539884.png" alt="image-20200712084539884"></p>
<h2 id="2-什么是垃圾"><a href="#2-什么是垃圾" class="headerlink" title="2 什么是垃圾"></a>2 什么是垃圾</h2><p>在提到什么是垃圾之前，我们先看下面一张图</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/images/image-20200712085456113.png" alt="image-20200712085456113"></p>
<p>从上图我们可以很明确的知道，Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集。</p>
<p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。<br>关于垃圾收集有三个经典问题：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>
<h3 id="2-1-什么是垃圾？"><a href="#2-1-什么是垃圾？" class="headerlink" title="2.1 什么是垃圾？"></a>2.1 什么是垃圾？</h3><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p>
<p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p>
<h3 id="2-2-磁盘碎片整理"><a href="#2-2-磁盘碎片整理" class="headerlink" title="2.2 磁盘碎片整理"></a>2.2 磁盘碎片整理</h3><p>机械硬盘需要进行磁盘整理，同时还有坏道</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/images/image-20200712090848669.png" alt="image-20200712090848669"></p>
<h3 id="2-3-大厂面试题"><a href="#2-3-大厂面试题" class="headerlink" title="2.3 大厂面试题"></a>2.3 大厂面试题</h3><h4 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h4><ul>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1？</li>
<li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li>
<li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li>
<li>GC的两种判定方法？CMS收集器与G1收集器的特点</li>
</ul>
<h4 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h4><ul>
<li>说一下GC算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ul>
<h4 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h4><ul>
<li>JVM GC原理，JVM怎么回收内存</li>
<li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ul>
<h4 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h4><p>Java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的</p>
<h4 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h4><ul>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，</li>
<li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li>
</ul>
<h4 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h4><ul>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM有哪三种垃圾回收器？</li>
</ul>
<h4 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h4><ul>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc（）和Runtime.gc（）会做什么事情？</li>
<li>Java GC机制？GC Roots有哪些？</li>
<li>Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次?</li>
</ul>
<h2 id="3-为什么需要GC"><a href="#3-为什么需要GC" class="headerlink" title="3 为什么需要GC"></a>3 为什么需要GC</h2><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>
<p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。</p>
<p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>
<h2 id="4-早期垃圾回收"><a href="#4-早期垃圾回收" class="headerlink" title="4 早期垃圾回收"></a>4 早期垃圾回收</h2><p>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++">MibBridge *pBridge= <span class="hljs-keyword">new</span> cmBaseGroupBridge（）；
<span class="hljs-comment">//如果注册失败，使用Delete释放该对象所占内存区域</span>
<span class="hljs-keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）
	<span class="hljs-keyword">delete</span> pBridge；</code></pre></div>

<p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。 </p>
<p>有了垃圾回收机制后，上述代码极有可能变成这样</p>
<div class="code-wrapper"><pre><code class="hljs c++">MibBridge *pBridge=<span class="hljs-keyword">new</span> <span class="hljs-built_in">cmBaseGroupBridge</span>(); 
pBridge-&gt;<span class="hljs-built_in">Register</span>(kDestroy);</code></pre></div>

<p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。</p>
<h2 id="5-Java垃圾回收机制"><a href="#5-Java垃圾回收机制" class="headerlink" title="5 Java垃圾回收机制"></a>5 Java垃圾回收机制</h2><h3 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h3><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p>
<p>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</p>
<p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p>
<p>oracle官网关于垃圾回收的介绍<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p>
<h3 id="5-2-担忧"><a href="#5-2-担忧" class="headerlink" title="5.2 担忧"></a>5.2 担忧</h3><p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p>
<p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</p>
<p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p>
<h3 id="5-3-GC主要关注的区域"><a href="#5-3-GC主要关注的区域" class="headerlink" title="5.3 GC主要关注的区域"></a>5.3 GC主要关注的区域</h3><p>GC主要关注于 方法区 和堆中的垃圾收集</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/images/image-20200712092427246.png" alt="image-20200712092427246"></p>
<p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收</p>
<ul>
<li>其中，Java堆是垃圾收集器的工作重点</li>
</ul>
<p>从次数上讲：</p>
<ul>
<li>频繁收集Young区</li>
<li>较少收集Old区</li>
<li>基本不收集Perm区（元空间）</li>
</ul>
<h1 id="第15章-垃圾回收相关算法"><a href="#第15章-垃圾回收相关算法" class="headerlink" title="第15章 垃圾回收相关算法"></a>第15章 垃圾回收相关算法</h1><h2 id="1-标记阶段：引用计数算法"><a href="#1-标记阶段：引用计数算法" class="headerlink" title="1 标记阶段：引用计数算法"></a>1 标记阶段：引用计数算法</h2><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p>
<p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p>
<p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法。</strong></p>
<p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p>
<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>
<p>缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</p>
<blockquote>
<p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。<br>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</p>
</blockquote>
<h3 id="1-1-循环引用"><a href="#1-1-循环引用" class="headerlink" title="1.1 循环引用"></a>1.1 循环引用</h3><p>当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712102205795.png" alt="image-20200712102205795"></p>
<h3 id="1-2-举例"><a href="#1-2-举例" class="headerlink" title="1.2 举例"></a>1.2 举例</h3><p>我们使用一个案例来测试Java中是否采用的是引用计数算法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 引用计数算法测试</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefCountGC</span> </span>&#123;
    <span class="hljs-comment">// 这个成员属性的唯一作用就是占用一点内存</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] bigSize = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];
    <span class="hljs-comment">// 引用</span>
    Object reference = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        RefCountGC obj1 = <span class="hljs-keyword">new</span> RefCountGC();
        RefCountGC obj2 = <span class="hljs-keyword">new</span> RefCountGC();
        obj1.reference = obj2;
        obj2.reference = obj1;
        obj1 = <span class="hljs-keyword">null</span>;
        obj2 = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span>
        System.gc();
    &#125;
&#125;</code></pre></div>

<p>运行结果</p>
<div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">15490</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">15490</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0061980</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.36</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">8</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">672</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">672</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3479</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3479</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0045983</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-variable">Heap</span>
 <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">655</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000770a00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000007c0000000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">65536</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b5a3ee8</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">10752</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">10752</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000770a00000</span><span class="hljs-punctuation">)</span>
 <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">672</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1e00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000006cc900000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1e00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1ea8070</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006cc900000</span><span class="hljs-punctuation">)</span>
 <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3486</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4496</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span>
  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">385</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">388</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span></code></pre></div>

<p>我们能够看到，上述进行了GC收集的行为，将上述的新生代中的两个对象都进行回收了</p>
<div class="code-wrapper"><pre><code class="hljs shell">PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)</code></pre></div>

<p>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712103230349.png" alt="image-20200712103230349"></p>
<h3 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h3><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p>
<p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p>
<p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。Python如何解决循环引用？</p>
<blockquote>
<p>手动解除：很好理解，就是在合适的时机，解除引用关系。<br>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</p>
</blockquote>
<h2 id="2-标记阶段：可达性分析算法"><a href="#2-标记阶段：可达性分析算法" class="headerlink" title="2 标记阶段：可达性分析算法"></a>2 标记阶段：可达性分析算法</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>可达性分析算法：也可以称为 根搜索算法、追踪性垃圾收集</p>
<p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p>
<p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p>
<h3 id="2-2-思路"><a href="#2-2-思路" class="headerlink" title="2.2 思路"></a>2.2 思路</h3><p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p>
<p>基本思路：</p>
<ul>
<li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712104149246.png" alt="image-20200712104149246"></p>
<p>官场上的裙带关系，可达性分析在人类关系网中</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712104312406.png" alt="image-20200712104312406"></p>
<h3 id="2-3-GC-Roots可以是哪些？"><a href="#2-3-GC-Roots可以是哪些？" class="headerlink" title="2.3 GC Roots可以是哪些？"></a>2.3 GC Roots可以是哪些？</h3><ul>
<li>虚拟机栈中引用的对象<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象<ul>
<li>比如：Java类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中常量引用的对象<ul>
<li>比如：字符串常量池（string Table）里的引用</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用。<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。</li>
</ul>
</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712104622677.png" alt="image-20200712104622677"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p>
<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p>
<p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p>
<p>这点也是导致GC进行时必须“stop The World”的一个重要原因。</p>
<p>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
<h2 id="3-对象的finalization机制"><a href="#3-对象的finalization机制" class="headerlink" title="3 对象的finalization机制"></a>3 对象的finalization机制</h2><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>
<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p>
<p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
<h3 id="3-1-注意"><a href="#3-1-注意" class="headerlink" title="3.1 注意"></a>3.1 注意</h3><p>永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ul>
<li>在finalize（）时可能会导致对象复活。</li>
<li>finalize（）方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。<ul>
<li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li>
</ul>
</li>
<li>一个糟糕的finalize（）会严重影响Gc的性能。</li>
</ul>
<p>从功能上来说，finalize（）方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于C++中的析构函数。</p>
<p>由于finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
<h3 id="3-2-生存还是死亡？"><a href="#3-2-生存还是死亡？" class="headerlink" title="3.2 生存还是死亡？"></a>3.2 生存还是死亡？</h3><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li>可触及的：从根节点开始，可以到达这个对象。</li>
<li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</li>
<li>不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong>。</li>
</ul>
<p>以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
<h3 id="3-3-具体过程"><a href="#3-3-具体过程" class="headerlink" title="3.3 具体过程"></a>3.3 具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p>
<ul>
<li><p>如果对象objA到GC Roots没有引用链，则进行第一次标记。</p>
</li>
<li><p>进行筛选，判断此对象是否有必要执行finalize（）方法</p>
<ul>
<li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li>
<li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li>
<li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712110411885.png" alt="image-20200712110411885"></p>
<p>上图就是我们看到的Finalizer线程</p>
<h3 id="3-4-代码演示"><a href="#3-4-代码演示" class="headerlink" title="3.4 代码演示"></a>3.4 代码演示</h3><p>我们使用重写 finalize()方法，然后在方法的内部，重写将其存放到GC Roots中</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 测试Object类中finalize()方法</span>
<span class="hljs-comment"> * 对象复活场景</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CanReliveObj</span> </span>&#123;
    <span class="hljs-comment">// 类变量，属于GC Roots的一部分</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CanReliveObj canReliveObj;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        <span class="hljs-keyword">super</span>.finalize();
        System.out.println(<span class="hljs-string">&quot;调用当前类重写的finalize()方法&quot;</span>);
        canReliveObj = <span class="hljs-keyword">this</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        canReliveObj = <span class="hljs-keyword">new</span> CanReliveObj();
        canReliveObj = <span class="hljs-keyword">null</span>;
        System.gc();
        System.out.println(<span class="hljs-string">&quot;-----------------第一次gc操作------------&quot;</span>);
        <span class="hljs-comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span>
        Thread.sleep(<span class="hljs-number">2000</span>);
        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-keyword">null</span>) &#123;
            System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);
        &#125;

        System.out.println(<span class="hljs-string">&quot;-----------------第二次gc操作------------&quot;</span>);
        canReliveObj = <span class="hljs-keyword">null</span>;
        System.gc();
        <span class="hljs-comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span>
        Thread.sleep(<span class="hljs-number">2000</span>);
        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-keyword">null</span>) &#123;
            System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
            System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);
        &#125;

    &#125;
&#125;</code></pre></div>

<p>最后运行结果</p>
<div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-comment">-----------------第一次gc操作------------</span>
调用当前类重写的finalize()方法
obj <span class="hljs-keyword">is</span> still alive
<span class="hljs-comment">-----------------第二次gc操作------------</span>
obj <span class="hljs-keyword">is</span> dead</code></pre></div>

<p>在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</p>
<h2 id="4-MAT与JProfiler的GC-Roots溯源"><a href="#4-MAT与JProfiler的GC-Roots溯源" class="headerlink" title="4 MAT与JProfiler的GC Roots溯源"></a>4 MAT与JProfiler的GC Roots溯源</h2><h3 id="4-1-MAT是什么？"><a href="#4-1-MAT是什么？" class="headerlink" title="4.1 MAT是什么？"></a>4.1 MAT是什么？</h3><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p>
<p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p>
<p>大家可以在<a href="http://www.eclipse.org/mat/下载并使用MAT">http://www.eclipse.org/mat/下载并使用MAT</a></p>
<h3 id="4-2-命令行使用-jmap"><a href="#4-2-命令行使用-jmap" class="headerlink" title="4.2 命令行使用 jmap"></a>4.2 命令行使用 jmap</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712112026317.png" alt="image-20200712112026317"></p>
<h3 id="4-3-使用JVIsualVM"><a href="#4-3-使用JVIsualVM" class="headerlink" title="4.3 使用JVIsualVM"></a>4.3 使用JVIsualVM</h3><p>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</p>
<p>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）。</p>
<p>在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。</p>
<p>右击这个节点选择save as（另存为）即可将heap dump保存到本地。</p>
<h3 id="4-4-使用MAT打开Dump文件"><a href="#4-4-使用MAT打开Dump文件" class="headerlink" title="4.4 使用MAT打开Dump文件"></a>4.4 使用MAT打开Dump文件</h3><p>打开后，我们就可以看到有哪些可以作为GC Roots的对象</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712112512720.png" alt="image-20200712112512720"></p>
<p>里面我们能够看到有一些常用的Java类，然后Thread线程。</p>
<h3 id="4-5-JProfiler的GC-Roots溯源"><a href="#4-5-JProfiler的GC-Roots溯源" class="headerlink" title="4.5 JProfiler的GC Roots溯源"></a>4.5 JProfiler的GC Roots溯源</h3><p>我们在实际的开发中，一般不会查找全部的GC Roots，可能只是查找某个对象的整个链路，或者称为GC Roots溯源，这个时候，我们就可以使用JProfiler</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712113256075.png" alt="image-20200712113256075"></p>
<h3 id="4-6-如何判断什么原因造成OOM"><a href="#4-6-如何判断什么原因造成OOM" class="headerlink" title="4.6 如何判断什么原因造成OOM"></a>4.6 如何判断什么原因造成OOM</h3><p>当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 内存溢出排查</span>
<span class="hljs-comment"> * -Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapOOM</span> </span>&#123;
    <span class="hljs-comment">// 创建1M的文件</span>
    <span class="hljs-keyword">byte</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        ArrayList&lt;HeapOOM&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                list.add(<span class="hljs-keyword">new</span> HeapOOM());
                count++;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.getStackTrace();
            System.out.println(<span class="hljs-string">&quot;count:&quot;</span> + count);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError将出错时候的dump文件输出</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span></code></pre></div>

<p>我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712150229048.png" alt="image-20200712150229048"></p>
<p>然后我们通过线程，还能够定位到哪里出现OOM</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712150303710.png" alt="image-20200712150303710"></p>
<h2 id="5-清除阶段：标记-清除算法"><a href="#5-清除阶段：标记-清除算法" class="headerlink" title="5 清除阶段：标记-清除算法"></a>5 清除阶段：标记-清除算法</h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p>
<ul>
<li>标记一清除算法（Mark-Sweep）</li>
<li>复制算法（copying）</li>
<li>标记-压缩算法（Mark-Compact）</li>
</ul>
<p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>
<h3 id="5-1-执行过程"><a href="#5-1-执行过程" class="headerlink" title="5.1 执行过程"></a>5.1 执行过程</h3><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p>
<ul>
<li><strong>标记</strong>：Collector从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>。一般是在对象的Header中记录为可达对象。<ul>
<li><strong>标记的是引用的对象，不是垃圾！！</strong></li>
</ul>
</li>
<li><strong>清除</strong>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712150935078.png" alt="image-20200712150935078"></p>
<h3 id="5-2-什么是清除？"><a href="#5-2-什么是清除？" class="headerlink" title="5.2 什么是清除？"></a>5.2 什么是清除？</h3><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p>
<p>关于空闲列表是在为对象分配内存的时候 提过</p>
<ul>
<li>如果内存规整<ul>
<li>采用指针碰撞的方式进行内存分配</li>
</ul>
</li>
<li>如果内存不规整<ul>
<li>虚拟机需要维护一个列表</li>
<li>空闲列表分配</li>
</ul>
</li>
</ul>
<h3 id="5-3-缺点"><a href="#5-3-缺点" class="headerlink" title="5.3 缺点"></a>5.3 缺点</h3><ul>
<li>标记清除算法的效率不算高</li>
<li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li>
</ul>
<h2 id="6-清除阶段：复制算法"><a href="#6-清除阶段：复制算法" class="headerlink" title="6 清除阶段：复制算法"></a>6 清除阶段：复制算法</h2><h3 id="6-1-背景"><a href="#6-1-背景" class="headerlink" title="6.1 背景"></a>6.1 背景</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>
<h3 id="6-2-核心思想"><a href="#6-2-核心思想" class="headerlink" title="6.2 核心思想"></a>6.2 核心思想</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712151916991.png" alt="image-20200712151916991"></p>
<p>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712152029615.png" alt="image-20200712152029615"></p>
<h3 id="6-3-优点"><a href="#6-3-优点" class="headerlink" title="6.3 优点"></a>6.3 优点</h3><ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ul>
<h3 id="6-4-缺点"><a href="#6-4-缺点" class="headerlink" title="6.4 缺点"></a>6.4 缺点</h3><ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li>
</ul>
<h3 id="6-5-注意"><a href="#6-5-注意" class="headerlink" title="6.5 注意"></a>6.5 注意</h3><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</p>
<p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712152847218.png" alt="image-20200712152847218"></p>
<h2 id="7-清除阶段：标记-整理算法"><a href="#7-清除阶段：标记-整理算法" class="headerlink" title="7 清除阶段：标记-整理算法"></a>7 清除阶段：标记-整理算法</h2><h3 id="7-1-背景"><a href="#7-1-背景" class="headerlink" title="7.1 背景"></a>7.1 背景</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p>
<p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p>
<p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>
<h3 id="7-2-执行过程"><a href="#7-2-执行过程" class="headerlink" title="7.2 执行过程"></a>7.2 执行过程</h3><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p>
<p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712153236508.png" alt="image-20200712153236508"></p>
<h3 id="7-3-标清和标整的区别"><a href="#7-3-标清和标整的区别" class="headerlink" title="7.3 标清和标整的区别"></a>7.3 标清和标整的区别</h3><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p>
<p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<h3 id="7-4-标整的优缺点"><a href="#7-4-标整的优缺点" class="headerlink" title="7.4 标整的优缺点"></a>7.4 标整的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>
<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>
</ul>
<h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8 小结"></a>8 小结</h2><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
<table>
<thead>
<tr>
<th></th>
<th>标记清除</th>
<th>标记整理</th>
<th>复制</th>
</tr>
</thead>
<tbody><tr>
<td><strong>速率</strong></td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p>综合我们可以找到，没有最好的算法，只有最合适的算法</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</p>
<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>年轻代（Young Gen）</li>
</ul>
<p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<ul>
<li>老年代（Tenured Gen）</li>
</ul>
<p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<ul>
<li>Mark阶段的开销与存活对象的数量成正比。</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>
<li>compact阶段的开销与存活对象的数据成正比。</li>
</ul>
<p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p>
<h2 id="9-增量收集算法"><a href="#9-增量收集算法" class="headerlink" title="9 增量收集算法"></a>9 增量收集算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理</strong>，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h2 id="10-分区算法"><a href="#10-分区算法" class="headerlink" title="10 分区算法"></a>10 分区算法</h2><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。<br>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/images/image-20200712165318590.png" alt="image-20200712165318590"></p>
<h2 id="11-写到最后"><a href="#11-写到最后" class="headerlink" title="11 写到最后"></a>11 写到最后</h2><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>
<h1 id="第16章-垃圾回收相关概念"><a href="#第16章-垃圾回收相关概念" class="headerlink" title="第16章 垃圾回收相关概念"></a>第16章 垃圾回收相关概念</h1><h2 id="1-System-gc-的理解"><a href="#1-System-gc-的理解" class="headerlink" title="1 System.gc()的理解"></a>1 System.gc()的理解</h2><p>在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p>然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p>
<p>JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc() </p>
<p>代码演示是否出发GC操作</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * System.gc()</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemGCTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> SystemGCTest();
        <span class="hljs-comment">// 提醒JVM进行垃圾回收</span>
        System.gc();
        <span class="hljs-comment">//System.runFinalization();</span>
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        <span class="hljs-keyword">super</span>.finalize();
        System.out.println(<span class="hljs-string">&quot;SystemGCTest 执行了 finalize方法&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>运行结果，但是不一定会触发销毁的方法，调用System.runFinalization()会强制调用 失去引用对象的finalize()</p>
<div class="code-wrapper"><pre><code class="hljs mercury">SystemGCTest 执行了 <span class="hljs-keyword">finalize</span>方法</code></pre></div>

<h3 id="手动GC来理解不可达对象的回收"><a href="#手动GC来理解不可达对象的回收" class="headerlink" title="手动GC来理解不可达对象的回收"></a>手动GC来理解不可达对象的回收</h3><p>代码如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 局部变量回收</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalVarGC</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];
        System.gc();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 触发YoungGC的时候，已经被回收了</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC2</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];
        buffer = <span class="hljs-keyword">null</span>;
        System.gc();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 不会被回收，因为它还存放在局部变量表索引为1的槽中</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC3</span><span class="hljs-params">()</span> </span>&#123;
        &#123;
            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];
        &#125;
        System.gc();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC4</span><span class="hljs-params">()</span> </span>&#123;
        &#123;
            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];
        &#125;
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">10</span>;
        System.gc();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * localvarGC5中的数组已经被回收</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC5</span><span class="hljs-params">()</span> </span>&#123;
        localvarGC1();
        System.gc();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        LocalVarGC localVarGC = <span class="hljs-keyword">new</span> LocalVarGC();
        localVarGC.localvarGC3();
    &#125;
&#125;</code></pre></div>

<h2 id="2-内存溢出"><a href="#2-内存溢出" class="headerlink" title="2 内存溢出"></a>2 内存溢出</h2><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>
<p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现ooM的情况。</p>
<p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Fu11GC操作，这时候会回收大量的内存，供应用程序继续使用。</p>
<p>javadoc中对outofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p>
<p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p>
<ul>
<li>Java虚拟机的堆内存设置不够。</li>
</ul>
<p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</p>
<ul>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li>
</ul>
<p>对于老版本的oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</p>
<p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的ooM有所改观，出现ooM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</p>
<p>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<blockquote>
<p>例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。<br>在java.nio.BIts.reserveMemory（）方法中，我们能清楚的看到，System.gc（）会被调用，以清理空间。</p>
</blockquote>
<p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<p>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</p>
<h2 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3 内存泄漏"></a>3 内存泄漏</h2><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现outofMemory异常，导致程序崩溃。</p>
<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
<blockquote>
<p>买房子：80平的房子，但是有10平是公摊的面积，我们是无法使用这10平的空间，这就是所谓的内存泄漏</p>
</blockquote>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712195158470.png" alt="image-20200712195158470"></p>
<p>Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。</p>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><ul>
<li>单例模式</li>
</ul>
<p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
<ul>
<li>一些提供close的资源未关闭导致内存泄漏</li>
</ul>
<p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</p>
<h2 id="4-Stop-The-World"><a href="#4-Stop-The-World" class="headerlink" title="4 Stop The World"></a>4 Stop The World</h2><p> stop-the-world，简称STw，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>
<p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p>
<ul>
<li><p>分析工作必须在一个能确保一致性的快照中进行</p>
</li>
<li><p>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</p>
</li>
<li><p>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</p>
</li>
</ul>
<p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STw的发生。</p>
<p>STW事件和采用哪款GC无关所有的GC都有这个事件。</p>
<p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
<p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
<p>开发中不要用system.gc() 会导致stop-the-world的发生。</p>
<h2 id="5-垃圾回收的并行与并发"><a href="#5-垃圾回收的并行与并发" class="headerlink" title="5 垃圾回收的并行与并发"></a>5 垃圾回收的并行与并发</h2><h3 id="5-1-并发"><a href="#5-1-并发" class="headerlink" title="5.1 并发"></a>5.1 并发</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>
<p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712202522051.png" alt="image-20200712202522051"></p>
<h3 id="5-2-并行"><a href="#5-2-并行" class="headerlink" title="5.2 并行"></a>5.2 并行</h3><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Paralle1）。</p>
<p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p>
<p>适合科学计算，后台处理等弱交互场景</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712202822129.png" alt="image-20200712202822129"></p>
<h3 id="5-3-并发和并行对比"><a href="#5-3-并发和并行对比" class="headerlink" title="5.3 并发和并行对比"></a>5.3 并发和并行对比</h3><p><strong>并发</strong>，指的是多个事情，在同一时间段内同时发生了。</p>
<p><strong>并行</strong>，指的是多个事情，在同一时间点上同时发生了。</p>
<p>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</p>
<p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。</p>
<p>否则，看似同时发生的事情，其实都是并发执行的。</p>
<h3 id="5-4-垃圾回收的并行与并发"><a href="#5-4-垃圾回收的并行与并发" class="headerlink" title="5.4 垃圾回收的并行与并发"></a>5.4 垃圾回收的并行与并发</h3><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ul>
<li><p>并行（Paralle1）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel old；</p>
</li>
<li><p>串行（Serial）</p>
<ul>
<li>相较于并行的概念，单线程执行。</li>
<li>如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712203607845.png" alt="image-20200712203607845"></p>
<p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。&gt;用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</p>
<blockquote>
<p>如：CMS、G1</p>
</blockquote>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712203815517.png" alt="image-20200712203815517"></p>
<h2 id="6-安全点与安全区域"><a href="#6-安全点与安全区域" class="headerlink" title="6 安全点与安全区域"></a>6 安全点与安全区域</h2><h3 id="6-1-安全点"><a href="#6-1-安全点" class="headerlink" title="6.1 安全点"></a>6.1 安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p>
<p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>
<p>如何在cc发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<ul>
<li><strong>抢先式中断</strong>：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>
<li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li>
</ul>
<h3 id="6-2-安全区域"><a href="#6-2-安全区域" class="headerlink" title="6.2 安全区域"></a>6.2 安全区域</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于sleep-状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>
<p><strong>执行流程：</strong></p>
<ul>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li>
</ul>
<h2 id="7-再谈引用"><a href="#7-再谈引用" class="headerlink" title="7 再谈引用"></a>7 再谈引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
<p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？<br>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p>
<ul>
<li>强引用（Strong Reference）</li>
<li>软引用（Soft Reference）</li>
<li>弱引用（Weak Reference）</li>
<li>虚引用（Phantom Reference）</li>
</ul>
<p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.1ang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712205813321.png" alt="image-20200712205813321"></p>
<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p>
<ul>
<li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object（）”这种引用关系。无论任何情况下，==只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象==。</li>
<li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li>
<li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>
<li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。==为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知==。</li>
</ul>
<h2 id="8-再谈引用：强引用"><a href="#8-再谈引用：强引用" class="headerlink" title="8 再谈引用：强引用"></a>8 再谈引用：强引用</h2><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p>
<p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p>
<h3 id="8-1-举例"><a href="#8-1-举例" class="headerlink" title="8.1 举例"></a>8.1 举例</h3><p>强引用的案例说明</p>
<div class="code-wrapper"><pre><code class="hljs java">StringBuffer str = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello mogublog&quot;</span>);</code></pre></div>

<p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712211501377.png" alt="image-20200712211501377"></p>
<p>如果此时，在运行一个赋值语句</p>
<div class="code-wrapper"><pre><code class="hljs java">StringBuffer str = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello mogublog&quot;</span>);
StringBuffer str1 = str;</code></pre></div>

<p>对应的内存结构为:</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/16_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/images/image-20200712211732976.png" alt="image-20200712211732976"></p>
<p>那么我们将 str = null; 则 原来堆中的对象也不会被回收，因为还有其它对象指向该区域</p>
<h3 id="8-2-总结"><a href="#8-2-总结" class="headerlink" title="8.2 总结"></a>8.2 总结</h3><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ul>
<li>强引用可以直接访问目标对象。</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li>
<li>强引用可能导致内存泄漏。</li>
</ul>
<h2 id="9-再谈引用：-软引用"><a href="#9-再谈引用：-软引用" class="headerlink" title="9 再谈引用： 软引用"></a>9 再谈引用： 软引用</h2><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<blockquote>
<p>注意，这里的第一次回收是不可达的对象</p>
</blockquote>
<p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<blockquote>
<p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</p>
</blockquote>
<p>在JDK1.2版之后提供了SoftReference类来实现软引用</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span>
Object obj = <span class="hljs-keyword">new</span> Object();
<span class="hljs-comment">// 创建一个软引用</span>
SoftReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(obj);
obj = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//销毁强引用，这是必须的，不然会存在强引用和软引用</span></code></pre></div>

<h2 id="10-再谈引用：弱引用"><a href="#10-再谈引用：弱引用" class="headerlink" title="10 再谈引用：弱引用"></a>10 再谈引用：弱引用</h2><blockquote>
<p>发现即回收</p>
</blockquote>
<p>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
<p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span>
Object obj = <span class="hljs-keyword">new</span> Object();
<span class="hljs-comment">// 创建一个弱引用</span>
WeakReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(obj);
obj = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//销毁强引用，这是必须的，不然会存在强引用和弱引用</span></code></pre></div>

<p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p>
<p>面试题：你开发中使用过WeakHashMap吗？</p>
<p>WeakHashMap用来存储图片信息，可以在内存不足的时候，及时回收，避免了OOM</p>
<h2 id="11-再谈引用：虚引用"><a href="#11-再谈引用：虚引用" class="headerlink" title="11 再谈引用：虚引用"></a>11 再谈引用：虚引用</h2><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null</p>
<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
<p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>
<blockquote>
<p>虚引用无法获取到我们的数据</p>
</blockquote>
<p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span>
Object obj = <span class="hljs-keyword">new</span> Object();
<span class="hljs-comment">// 声明引用队列</span>
ReferenceQueue phantomQueue = <span class="hljs-keyword">new</span> ReferenceQueue();
<span class="hljs-comment">// 声明虚引用（还需要传入引用队列）</span>
PhantomReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);
obj = <span class="hljs-keyword">null</span>;</code></pre></div>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>我们使用一个案例，来结合虚引用，引用队列，finalize进行讲解</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-12-21:42</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhantomReferenceTest</span> </span>&#123;
    <span class="hljs-comment">// 当前类对象的声明</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PhantomReferenceTest obj;
    <span class="hljs-comment">// 引用队列</span>
    <span class="hljs-keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="hljs-keyword">null</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
        <span class="hljs-keyword">super</span>.finalize();
        System.out.println(<span class="hljs-string">&quot;调用当前类的finalize方法&quot;</span>);
        obj = <span class="hljs-keyword">this</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;
                <span class="hljs-keyword">if</span> (phantomQueue != <span class="hljs-keyword">null</span>) &#123;
                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="hljs-keyword">null</span>;
                    <span class="hljs-keyword">try</span> &#123;
                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();
                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                        e.getStackTrace();
                    &#125;
                    <span class="hljs-keyword">if</span> (objt != <span class="hljs-keyword">null</span>) &#123;
                        System.out.println(<span class="hljs-string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);
                    &#125;
                &#125;
            &#125;
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);
        thread.setDaemon(<span class="hljs-keyword">true</span>);
        thread.start();

        phantomQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();
        obj = <span class="hljs-keyword">new</span> PhantomReferenceTest();
        <span class="hljs-comment">// 构造了PhantomReferenceTest对象的虚引用，并指定了引用队列</span>
        PhantomReference&lt;PhantomReferenceTest&gt; phantomReference = <span class="hljs-keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(phantomReference.get());
            <span class="hljs-comment">// 去除强引用</span>
            obj = <span class="hljs-keyword">null</span>;
            <span class="hljs-comment">// 第一次进行GC，由于对象可复活，GC无法回收该对象</span>
            System.out.println(<span class="hljs-string">&quot;第一次GC操作&quot;</span>);
            System.gc();
            Thread.sleep(<span class="hljs-number">1000</span>);
            <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123;
                System.out.println(<span class="hljs-string">&quot;obj 是 null&quot;</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                System.out.println(<span class="hljs-string">&quot;obj 不是 null&quot;</span>);
            &#125;
            System.out.println(<span class="hljs-string">&quot;第二次GC操作&quot;</span>);
            obj = <span class="hljs-keyword">null</span>;
            System.gc();
            Thread.sleep(<span class="hljs-number">1000</span>);
            <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123;
                System.out.println(<span class="hljs-string">&quot;obj 是 null&quot;</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                System.out.println(<span class="hljs-string">&quot;obj 不是 null&quot;</span>);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;

        &#125;
    &#125;
&#125;</code></pre></div>

<p>最后运行结果</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">null</span>
第一次GC操作
调用当前类的finalize方法
obj 不是 <span class="hljs-keyword">null</span>
第二次GC操作
追踪垃圾回收过程：PhantomReferenceTest实例被GC了
obj 是 <span class="hljs-keyword">null</span></code></pre></div>

<p>从上述运行结果我们知道，第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次gc，因为会调用finalize方法，将对象复活了，所以对象没有被回收，但是调用第二次gc操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是 将回收的值存入到引用队列中。</p>
<h2 id="12-终结器引用"><a href="#12-终结器引用" class="headerlink" title="12 终结器引用"></a>12 终结器引用</h2><p>它用于实现对象的finalize() 方法，也可以称为终结器引用</p>
<p>无需手动编码，其内部配合引用队列使用</p>
<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p>
<h1 id="第17章-垃圾回收器"><a href="#第17章-垃圾回收器" class="headerlink" title="第17章 垃圾回收器"></a>第17章 垃圾回收器</h1><h2 id="1-GC分类与性能指标"><a href="#1-GC分类与性能指标" class="headerlink" title="1 GC分类与性能指标"></a>1 GC分类与性能指标</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p>
<p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p>
<p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p>
<blockquote>
<p>Java不同版本新特性</p>
<ul>
<li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum</li>
<li>API层面：Stream API、新的日期时间、Optional、String、集合框架</li>
<li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化</li>
</ul>
</blockquote>
<h3 id="1-1-垃圾收集器分类"><a href="#1-1-垃圾收集器分类" class="headerlink" title="1.1 垃圾收集器分类"></a>1.1 垃圾收集器分类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a><strong>按线程数分</strong></h4><p><strong>按线程数分</strong>（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713083030867.png" alt="image-20200713083030867"></p>
<p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>
<ul>
<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
<p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。</p>
<h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p>
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713083443486.png" alt="image-20200713083443486"></p>
<h4 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h4><p>按碎片处理方式分，可分为压缩武垃圾回收器和非压缩式垃圾回收器。</p>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li>
<li>非压缩式的垃圾回收器不进行这步操作。</li>
</ul>
<p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p>
<h3 id="1-2-评估GC的性能指标"><a href="#1-2-评估GC的性能指标" class="headerlink" title="1.2 评估GC的性能指标"></a>1.2 评估GC的性能指标</h3><ul>
<li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li>
<li><strong>垃圾收集开销</strong>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li><strong>收集频率</strong>：相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong>内存占用</strong>：Java堆区所占的内存大小。</li>
<li><strong>快速</strong>：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。<br>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。<br>简单来说，主要抓住两点：</p>
<p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。<br>简单来说，主要抓住两点：</p>
<ul>
<li>吞吐量</li>
<li>暂停时间</li>
</ul>
<h3 id="1-3-性能指标：吞吐量"><a href="#1-3-性能指标：吞吐量" class="headerlink" title="1.3 性能指标：吞吐量"></a>1.3 性能指标：吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</p>
<blockquote>
<p>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
</blockquote>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=e.4</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713084726176.png" alt="image-20200713084726176"></p>
<h3 id="1-4-性能指标：暂停时间"><a href="#1-4-性能指标：暂停时间" class="headerlink" title="1.4 性能指标：暂停时间"></a>1.4 性能指标：暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让Gc线程执行的状态</p>
<p>例如，GC期间1ee毫秒的暂停时间意味着在这1e0毫秒期间内没有应用程序线程是活动的。暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713085306400.png" alt="image-20200713085306400"></p>
<h3 id="1-5-吞吐量vs暂停时间"><a href="#1-5-吞吐量vs暂停时间" class="headerlink" title="1.5 吞吐量vs暂停时间"></a>1.5 吞吐量vs暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
<p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p>
<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</p>
<p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p>
<p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>
<p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p>
<h2 id="2-不同的垃圾回收器概述"><a href="#2-不同的垃圾回收器概述" class="headerlink" title="2 不同的垃圾回收器概述"></a>2 不同的垃圾回收器概述</h2><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p>
<p>那么，Java常见的垃圾收集器有哪些？</p>
<blockquote>
<p>GC垃圾收集器是和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别</p>
</blockquote>
<h3 id="2-1-垃圾回收器发展史"><a href="#2-1-垃圾回收器发展史" class="headerlink" title="2.1 垃圾回收器发展史"></a>2.1 垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p>
<ul>
<li>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li>
<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li>
<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>
<li>2012年，在JDK1.7u4版本中，G1可用。</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>
<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。·2019年9月，JDK13发布。增强zGC，自动返回未用堆内存给操作系统。</li>
<li>2020年3月，JDK14发布。删除cMs垃圾回收器。扩展zGC在macos和Windows上的应用</li>
</ul>
<h3 id="2-2-7种经典的垃圾收集器"><a href="#2-2-7种经典的垃圾收集器" class="headerlink" title="2.2 7种经典的垃圾收集器"></a>2.2 7种经典的垃圾收集器</h3><ul>
<li>串行回收器：Serial、Serial old</li>
<li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li>
<li>并发回收器：CMS、G11</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713093551365.png" alt="image-20200713093551365"></p>
<h3 id="2-3-7款经典收集器与垃圾分代之间的关系"><a href="#2-3-7款经典收集器与垃圾分代之间的关系" class="headerlink" title="2.3 7款经典收集器与垃圾分代之间的关系"></a>2.3 7款经典收集器与垃圾分代之间的关系</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713093757644.png" alt="image-20200713093757644"></p>
<p>新生代收集器：Serial、ParNew、Paralle1 Scavenge；</p>
<p>老年代收集器：Serial old、Parallel old、CMS；</p>
<p>整堆收集器：G1；</p>
<h3 id="2-4-垃圾收集器的组合关系"><a href="#2-4-垃圾收集器的组合关系" class="headerlink" title="2.4 垃圾收集器的组合关系"></a>2.4 垃圾收集器的组合关系</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713094745366.png" alt="image-20200713094745366"></p>
<ul>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial old、Serial/CMS、ParNew/Serial old、ParNew/CMS、Parallel Scavenge/Serial 0ld、Parallel Scavenge/Parallel 01d、G1；</li>
<li>其中Serial o1d作为CMs出现”Concurrent Mode Failure”失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK14中：弃用Paralle1 Scavenge和Serialold GC组合（JEP366）</li>
<li>（青色虚线）JDK14中：删除CMs垃圾回收器（JEP363）</li>
</ul>
<p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p>
<h3 id="2-5-如何查看默认垃圾收集器"><a href="#2-5-如何查看默认垃圾收集器" class="headerlink" title="2.5 如何查看默认垃圾收集器"></a>2.5 如何查看默认垃圾收集器</h3><p>-XX:+PrintcommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p>
<p>使用命令行指令：jinfo -flag  相关垃圾回收器参数  进程ID</p>
<h2 id="3-Serial回收器：串行回收"><a href="#3-Serial回收器：串行回收" class="headerlink" title="3 Serial回收器：串行回收"></a>3 Serial回收器：串行回收</h2><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p>
<p>Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。</p>
<p>Serial收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</p>
<p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了串行回收和”stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<ul>
<li>Serial old是运行在Client模式下默认的老年代的垃圾回收器</li>
<li>Serial 0ld在Server模式下主要有两个用途：<ul>
<li>与新生代的Parallel scavenge配合使用</li>
<li>作为老年代CMS收集器的后备垃圾收集方案</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713100703799.png" alt="image-20200713100703799"></p>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p>
<p>优势：简单而高效（与其他收集器的单线程比），对于限定单个cPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<p>运行在client模式下的虚拟机是个不错的选择。</p>
<p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p>
<p>在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</p>
<p>等价于新生代用Serial GC，且老年代用Serial old GC</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p>
<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p>
<h2 id="4-ParNew回收器：并行回收"><a href="#4-ParNew回收器：并行回收" class="headerlink" title="4 ParNew回收器：并行回收"></a>4 ParNew回收器：并行回收</h2><p>如果说serialGC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。</p>
<ul>
<li>Par是Parallel的缩写，New：只能处理的是新生代</li>
</ul>
<p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”stop-the-World”机制。</p>
<p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713102030127.png" alt="image-20200713102030127"></p>
<ul>
<li>对于新生代，回收次数频繁，使用并行方式高效。</li>
<li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li>
</ul>
<p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p>
<ul>
<li></li>
</ul>
<p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p>
<p>在程序中，开发人员可以通过选项”-XX：+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
<p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p>
<h2 id="5-Parallel回收器：吞吐量优先"><a href="#5-Parallel回收器：吞吐量优先" class="headerlink" title="5 Parallel回收器：吞吐量优先"></a>5 Parallel回收器：吞吐量优先</h2><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p>
<p>那么Parallel 收集器的出现是否多此一举？</p>
<ul>
<li>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li>
<li>自适应调节策略也是Paralle1 Scavenge与ParNew一个重要区别。</li>
</ul>
<p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
<p>Paralle1收集器在JDK1.6时提供了用于执行老年代垃圾收集的Paralle1o1d收集器，用来代替老年代的serialold收集器。</p>
<p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”stop-the-World”机制。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713110359441.png" alt="image-20200713110359441"></p>
<p>在程序吞吐量优先的应用场景中，IParalle1收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>-XX：+UseParallelGC 手动指定年轻代使用Paralle1并行收集器执行内存回收任务。</p>
<p>-XX：+UseParalleloldcc 手动指定老年代都是使用并行回收收集器。</p>
<ul>
<li>分别适用于新生代和老年代。默认jdk8是开启的。</li>
<li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li>
</ul>
<p>-XX:ParallelGcrhreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<p>在默认情况下，当CPU数量小于8个，ParallelGcThreads的值等于CPU数量。</p>
<p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU Count]/8]</p>
<p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。</p>
<p>为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。<br>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</p>
<p>-XX:GCTimeRatio垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p>
<p>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1。</p>
<p>与前一个-xx:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p>
<p>-XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略</p>
<p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>
<p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。</p>
<h2 id="6-CMS回收器：低延迟"><a href="#6-CMS回收器：低延迟" class="headerlink" title="6 CMS回收器：低延迟"></a>6 CMS回收器：低延迟</h2><p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：cMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p>
<p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>
<p>CMS的垃圾收集算法采用标记-清除算法，并且也会”stop-the-world”</p>
<p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p>
<p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713205154007.png" alt="image-20200713205154007"></p>
<p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p>
<ul>
<li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li>
<li><strong>并发标记</strong>（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
</ul>
<p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p>
<p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>
<p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”<br>失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713212230352.png" alt="image-20200713212230352"></p>
<h3 id="6-1-CMS为什么不使用标记整理算法？"><a href="#6-1-CMS为什么不使用标记整理算法？" class="headerlink" title="6.1 CMS为什么不使用标记整理算法？"></a>6.1 CMS为什么不使用标记整理算法？</h3><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”<br>这种场景下使用</p>
<h3 id="6-2-优点"><a href="#6-2-优点" class="headerlink" title="6.2 优点"></a>6.2 优点</h3><ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
<h3 id="6-3-缺点"><a href="#6-3-缺点" class="headerlink" title="6.3 缺点"></a>6.3 缺点</h3><ul>
<li><p>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</p>
</li>
<li><p>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p>
</li>
<li><p>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</p>
</li>
</ul>
<h3 id="6-4-设置的参数"><a href="#6-4-设置的参数" class="headerlink" title="6.4 设置的参数"></a>6.4 设置的参数</h3><ul>
<li>-XX：+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务。</li>
</ul>
<p>开启该参数后会自动将-xx：+UseParNewGC打开。即：ParNew（Young区用）+CMS（01d区用）+Serial old的组合。</p>
<ul>
<li>-XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</li>
</ul>
<p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次cMs回收。JDK6及以上版本默认值为92%</p>
<p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</p>
<ul>
<li>-XX：+UseCMSCompactAtFullCollection用于指定在执行完Ful1</li>
</ul>
<p>GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
<ul>
<li><p>-XX:CMSFullGCsBeforecompaction 设置在执行多少次Ful1GC后对内存空间进行压缩整理。</p>
</li>
<li><p>-XX:ParallelcMSThreads 设置cMs的线程数量。</p>
</li>
</ul>
<p>CMs默认启动的线程数是（Paralle1GCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p>
<h3 id="6-5-小结"><a href="#6-5-小结" class="headerlink" title="6.5 小结"></a>6.5 小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个Gc有什么不同呢？</p>
<p>请记住以下口令：</p>
<ul>
<li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li>
<li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li>
<li>如果你想要最小化GC的中断或停顿时间，请选CMs GC。</li>
</ul>
<h3 id="6-7-JDK后续版本中CMS的变化"><a href="#6-7-JDK后续版本中CMS的变化" class="headerlink" title="6.7 JDK后续版本中CMS的变化"></a>6.7 JDK后续版本中CMS的变化</h3><p><strong>JDK9新特性</strong>：CMS被标记为eprecate了（JEP291）&gt;如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX：<br>+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p>
<p>JDK14新特性：删除CMs垃圾回收器（JEP363）移除了CMS垃圾收集器，如果在JDK14中使用<br>XX：+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p>
<h2 id="7-G1回收器：区域化分代式"><a href="#7-G1回收器：区域化分代式" class="headerlink" title="7 G1回收器：区域化分代式"></a>7 G1回收器：区域化分代式</h2><h3 id="7-1-既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？"><a href="#7-1-既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？" class="headerlink" title="7.1 既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？"></a>7.1 既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</h3><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p>
<p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
<p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p>
<h3 id="7-2-为什么名字叫-Garbage-First-G1-呢？"><a href="#7-2-为什么名字叫-Garbage-First-G1-呢？" class="headerlink" title="7.2 为什么名字叫 Garbage First(G1)呢？"></a>7.2 为什么名字叫 Garbage First(G1)呢？</h3><p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p>
<p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p>
<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p>
<p>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Paralle1+Parallel old组合。被orac1e官方称为“全功能的垃圾收集器”。</p>
<p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-xx：+UseG1GC来启用。</p>
<h3 id="7-3-G1垃圾收集器的优点"><a href="#7-3-G1垃圾收集器的优点" class="headerlink" title="7.3 G1垃圾收集器的优点"></a>7.3 G1垃圾收集器的优点</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p>
<p><strong>并行与并发</strong></p>
<ul>
<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
<p><strong>分代收集</strong></p>
<ul>
<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
</ul>
<p>G1所谓的分代，已经不是下面这样的了</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713215105293.png" alt="image-20200713215105293"></p>
<p>而是这样的一个区域</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713215133839.png" alt="image-20200713215133839"></p>
<p><strong>空间整合</strong></p>
<ul>
<li>CMS：“标记-清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li>
<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>
</ul>
<p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong><br>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
<h3 id="7-4-G1垃圾收集器的缺点"><a href="#7-4-G1垃圾收集器的缺点" class="headerlink" title="7.4 G1垃圾收集器的缺点"></a>7.4 G1垃圾收集器的缺点</h3><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p>
<p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p>
<h3 id="7-5-G1参数设置"><a href="#7-5-G1参数设置" class="headerlink" title="7.5 G1参数设置"></a>7.5 G1参数设置</h3><ul>
<li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li>
<li>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li>
<li>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li>
<li>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</li>
<li>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li>
<li>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li>
</ul>
<h3 id="7-6-G1收集器的常见操作步骤"><a href="#7-6-G1收集器的常见操作步骤" class="headerlink" title="7.6 G1收集器的常见操作步骤"></a>7.6 G1收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ul>
<li>第一步：开启G1垃圾收集器</li>
<li>第二步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ul>
<p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Fu11GC，在不同的条件下被触发。</p>
<h3 id="7-7-G1收集器的适用场景"><a href="#7-7-G1收集器的适用场景" class="headerlink" title="7.7 G1收集器的适用场景"></a>7.7 G1收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>
<p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p>
<p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于e.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次Gc停顿时间不会过长）。<br>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用61可能比CMS好：</p>
<ul>
<li>超过5e%的Java堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC停顿时间过长（长于e.5至1秒）</li>
</ul>
<p>HotSpot垃圾收集器里，除了61以外，其他的垃圾收集器使用内置的JVM线程执行Gc的多线程操作，而G1GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>
<h3 id="7-8-分区Region：化整为零"><a href="#7-8-分区Region：化整为零" class="headerlink" title="7.8 分区Region：化整为零"></a>7.8 分区Region：化整为零</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p>
<p>XX:G1HeapRegionsize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713223244886.png" alt="image-20200713223244886"></p>
<p>一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于01d内存区域。图中空白的表示未使用的内存空间。</p>
<p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p>
<p><strong>设置H的原因：</strong>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Fu11Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
<p>每个Region都是通过指针碰撞来分配空间</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713223509993.png" alt="image-20200713223509993"></p>
<h3 id="7-9-G1垃圾回收器的回收过程"><a href="#7-9-G1垃圾回收器的回收过程" class="headerlink" title="7.9 G1垃圾回收器的回收过程"></a>7.9 G1垃圾回收器的回收过程</h3><p>G1GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>年轻代GC（Young GC）</li>
<li>老年代并发标记过程（Concurrent Marking）</li>
<li>混合回收（Mixed GC）</li>
</ul>
<p>（如果需要，单线程、独占式、高强度的Fu11GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713224113996.png" alt="image-20200713224113996"></p>
<p>顺时针，young gc-&gt;young gc+concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p>
<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>
<p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>
<p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
<h3 id="7-10-Remembered-Set（记忆集）"><a href="#7-10-Remembered-Set（记忆集）" class="headerlink" title="7.10 Remembered Set（记忆集）"></a>7.10 Remembered Set（记忆集）</h3><p>一个对象被不同区域引用的问题</p>
<p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>
<p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？这样的话会降低MinorGC的效率；</p>
<p><strong>解决方法：</strong></p>
<p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p>
<p>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p>
<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过cardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713224716715.png" alt="image-20200713224716715"></p>
<h3 id="7-11-G1回收过程-年轻代GC"><a href="#7-11-G1回收过程-年轻代GC" class="headerlink" title="7.11 G1回收过程-年轻代GC"></a>7.11 G1回收过程-年轻代GC</h3><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p>YGC时，首先G1停止应用程序的执行（stop-The-Wor1d），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713225100632.png" alt="image-20200713225100632"></p>
<p>然后开始如下回收过程：</p>
<ul>
<li>第一阶段，扫描根</li>
</ul>
<p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>
<ul>
<li>第二阶段，更新RSet</li>
</ul>
<p>处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p>
<ul>
<li>第三阶段，处理RSet</li>
</ul>
<p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>
<ul>
<li>第四阶段，复制对象。</li>
</ul>
<p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p>
<ul>
<li>第五阶段，处理引用</li>
</ul>
<p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
<h3 id="7-12-G1回收过程-并发标记过程"><a href="#7-12-G1回收过程-并发标记过程" class="headerlink" title="7.12 G1回收过程-并发标记过程"></a>7.12 G1回收过程-并发标记过程</h3><ul>
<li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是sTw的，并且会触发一次年轻代GC。</li>
<li>根区域扫描（Root Region Scanning）：G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC之前完成。</li>
<li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
<li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li>
<li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是sTw的。这个阶段并不会实际上去做垃圾的收集</li>
<li>并发清理阶段：识别并清理完全空闲的区域。</li>
</ul>
<h3 id="7-13-G1回收过程-混合回收"><a href="#7-13-G1回收过程-混合回收" class="headerlink" title="7.13 G1回收过程 - 混合回收"></a>7.13 G1回收过程 - 混合回收</h3><p>当越来越多的对象晋升到老年代o1d region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old GC，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些o1d Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713225810871.png" alt="image-20200713225810871"></p>
<p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</p>
<p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>
<p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，</p>
<p>XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>
<p>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为1e%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于1e%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p>
<h3 id="7-14-G1回收可选的过程4-Full-GC"><a href="#7-14-G1回收可选的过程4-Full-GC" class="headerlink" title="7.14 G1回收可选的过程4 - Full GC"></a>7.14 G1回收可选的过程4 - Full GC</h3><p>G1的初衷就是要避免Fu11GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（stop-The-world），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>要避免Fu11GC的发生，一旦发生需要进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到ful1gc，这种情况可以通过增大内存解决。<br>导致61Fu11GC的原因可能有两个：</p>
<ul>
<li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ul>
<h3 id="7-15-G1回收的优化建议"><a href="#7-15-G1回收的优化建议" class="headerlink" title="7.15 G1回收的优化建议"></a>7.15 G1回收的优化建议</h3><p> 从oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<p>年轻代大小</p>
<ul>
<li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖</li>
</ul>
<p>暂停时间目标暂停时间目标不要太过严苛</p>
<ul>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>
<li>评估G1GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
<h2 id="8-垃圾回收器总结"><a href="#8-垃圾回收器总结" class="headerlink" title="8 垃圾回收器总结"></a>8 垃圾回收器总结</h2><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714075738203.png" alt="image-20200714075738203"></p>
<p>GC发展阶段：Seria l=&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p>
<p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714080151020.png" alt="image-20200714080151020"></p>
<h3 id="8-1-怎么选择垃圾回收器"><a href="#8-1-怎么选择垃圾回收器" class="headerlink" title="8.1 怎么选择垃圾回收器"></a>8.1 怎么选择垃圾回收器</h3><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p>
<ul>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>
<li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>
<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li>
</ul>
<p>最后需要明确一个观点：</p>
<ul>
<li>没有最好的收集器，更没有万能的收集</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ul>
<h3 id="8-2-面试"><a href="#8-2-面试" class="headerlink" title="8.2 面试"></a>8.2 面试</h3><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。<br>这里较通用、基础性的部分如下：</p>
<p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p>
<p>垃圾收集器工作的基本流程。</p>
<p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p>
<h2 id="9-GC日志分析"><a href="#9-GC日志分析" class="headerlink" title="9 GC日志分析"></a>9 GC日志分析</h2><p>通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。<br>内存分配与垃圾回收的参数列表</p>
<ul>
<li>-XX:+PrintGc输出GC日志。类似：-verbose:gc</li>
<li>-XX:+PrintGcDetails输出Gc的详细日志</li>
<li>-XX:+PrintGcTimestamps 输出Gc的时间戳（以基准时间的形式）</li>
<li>-XX:+PrintGCDatestamps 输出Gc的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</li>
<li>-XX:+PrintHeapAtGC在进行Gc的前后打印出堆的信息</li>
<li>-Xloggc:../logs/gc.1og日志文件的输出路径</li>
</ul>
<h3 id="9-1-verbose-gc"><a href="#9-1-verbose-gc" class="headerlink" title="9.1 verbose:gc"></a>9.1 verbose:gc</h3><p>打开GC日志</p>
<div class="code-wrapper"><pre><code class="hljs bash">-verbose:gc</code></pre></div>

<p>这个只会显示总的GC堆的变化，如下：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714081610474.png" alt="image-20200714081610474"></p>
<p>参数解析</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714081622526.png" alt="image-20200714081622526"></p>
<h3 id="9-2-PrintGCDetails"><a href="#9-2-PrintGCDetails" class="headerlink" title="9.2 PrintGCDetails"></a>9.2 PrintGCDetails</h3><p>打开GC日志</p>
<div class="code-wrapper"><pre><code class="hljs bash">-verbose:gc -XX:+PrintGCDetails</code></pre></div>

<p>输入信息如下</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714081909309.png" alt="image-20200714081909309"></p>
<p>参数解析</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714081925767.png" alt="image-20200714081925767"></p>
<h3 id="9-3-补充"><a href="#9-3-补充" class="headerlink" title="9.3 补充"></a>9.3 补充</h3><ul>
<li>[GC”和”[Fu11GC”说明了这次垃圾收集的停顿类型，如果有”Fu11”则说明GC发生了”stop The World”</li>
<li>使用Seria1收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li>
<li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li>
<li>使用Paralle1 scavenge收集器在新生代的名字是”[PSYoungGen”</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>
<li>使用G1收集器的话，会显示为”garbage-first heap”</li>
</ul>
<p>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>
<p>[PSYoungGen：5986K-&gt;696K（8704K）]5986K-&gt;704K（9216K）中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p>
<p>user代表用户态回收耗时，sys内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过rea1时间</p>
<h3 id="9-4-Young-GC图片"><a href="#9-4-Young-GC图片" class="headerlink" title="9.4 Young GC图片"></a>9.4 Young GC图片</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714082555688.png" alt="image-20200714082555688"></p>
<h3 id="9-5-FullGC图片"><a href="#9-5-FullGC图片" class="headerlink" title="9.5 FullGC图片"></a>9.5 FullGC图片</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714082714690.png" alt="image-20200714082714690"></p>
<h3 id="9-6-GC回收举例"><a href="#9-6-GC回收举例" class="headerlink" title="9.6 GC回收举例"></a>9.6 GC回收举例</h3><p>我们编写一个程序，用来说明GC收集的过程</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * GC垃圾收集过程</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCUseTest</span> </span>&#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">byte</span> [] allocation1, allocation2, allocation3, allocation4;
        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];
        allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];
        allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];
        allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span> *_1MB];
    &#125;
&#125;</code></pre></div>

<p>我们设置JVM启动参数</p>
<div class="code-wrapper"><pre><code class="hljs bash">-Xms10m -Xmx10m -XX:+PrintGCDetails</code></pre></div>

<p>首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714083332238.png" alt="image-20200714083332238"></p>
<p>然后我们将4M对象存入到Eden区中</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714083526790.png" alt="image-20200714083526790"></p>
<p>可以用一些工具去分析这些GC日志</p>
<p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p>
<p><strong>GCViewer</strong></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714084921184.png" alt="image-20200714084921184"></p>
<p><strong>GC easy</strong></p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714084726824.png" alt="image-20200714084726824"></p>
<h2 id="10-垃圾回收器的新发展"><a href="#10-垃圾回收器的新发展" class="headerlink" title="10 垃圾回收器的新发展"></a>10 垃圾回收器的新发展</h2><p>GC仍然处于飞速发展之中，目前的默认选项G1GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Fu11GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</p>
<p>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</p>
<p>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</p>
<p>Epsilon:A No-Op GarbageCollector（Epsilon垃圾回收器，”No-Op（无操作）”回收器）<a href="http://openidk.iava.net/iep">http://openidk.iava.net/iep</a> s/318</p>
<p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</p>
<p>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12）</p>
<blockquote>
<p>主打特点：低停顿时间</p>
</blockquote>
<h3 id="10-1-Open-JDK12的Shenandoash-GC"><a href="#10-1-Open-JDK12的Shenandoash-GC" class="headerlink" title="10.1 Open JDK12的Shenandoash GC"></a>10.1 Open JDK12的Shenandoash GC</h3><p>Open JDK12的shenandoash GC：低停顿时间的GC（实验性）</p>
<p>Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDk没有区别的Oracle公司仍拒绝在oracleJDK12中支持Shenandoah。</p>
<p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</p>
<p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714090608807.png" alt="image-20200714090608807"></p>
<p>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：</p>
<blockquote>
<p>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。<br>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</p>
</blockquote>
<p>总结</p>
<ul>
<li>shenandoah Gc的弱项：高运行负担下的吞吐量下降。</li>
<li>shenandoah GC的强项：低延迟时间。</li>
</ul>
<h3 id="10-2-革命性的ZGC"><a href="#10-2-革命性的ZGC" class="headerlink" title="10.2 革命性的ZGC"></a>10.2 革命性的ZGC</h3><p>zGC与shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p>
<p>《深入理解Java虚拟机》一书中这样定义zGC：2GC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p>
<p>ZGC的工作过程可以分为4个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p>
<p>ZGC几乎在所有地方并发执行的，除了初始标记的是STw的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714091201073.png" alt="image-20200714091201073"></p>
<p>停顿时间对比</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714091401511.png" alt="image-20200714091401511"></p>
<p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。<br>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714093243028.png" alt="image-20200714093243028"></p>
<p>JDK14之前，2GC仅Linux才支持。</p>
<p>尽管许多使用zGc的用户都使用类Linux的环境，但在Windows和macos上，人们也需要zGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，2GC特性被移植到了Windows和macos上。</p>
<p>现在mac或Windows上也能使用zGC了，示例如下：</p>
<div class="code-wrapper"><pre><code class="hljs bash">-XX:+UnlockExperimentalVMOptions-XX：+UseZGC</code></pre></div>

<h3 id="10-3-AliGC"><a href="#10-3-AliGC" class="headerlink" title="10.3 AliGC"></a>10.3 AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200714093604012.png" alt="image-20200714093604012"></p>
<p>当然，其它厂商也提供了各种别具一格的GC实现，例如比较有名的低延迟GC Zing</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Tool</category>
      </categories>
  </entry>
</search>
