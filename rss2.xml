<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>pncalbl</title>
    <link>https://pncalbl.github.io/</link>
    
    <image>
      <url>https://www.gravatar.com/avatar/a8fa4407c843fcd53fbcbe238a6dd153</url>
      <title>pncalbl</title>
      <link>https://pncalbl.github.io/</link>
    </image>
    
    <atom:link href="https://pncalbl.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 05 Sep 2021 01:41:59 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Chocolatey Note</title>
      <link>https://pncalbl.github.io/2021/09/05/choco-cli-Note/</link>
      <guid>https://pncalbl.github.io/2021/09/05/choco-cli-Note/</guid>
      <pubDate>Sat, 04 Sep 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;第1章-简介&quot;&gt;&lt;a href=&quot;#第1章-简介&quot; class=&quot;headerlink&quot; title=&quot;第1章 简介&quot;&gt;&lt;/a&gt;第1章 简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://chocolatey.org/&quot;&gt;&lt;a href=&quot;https://cho</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h1><p><a href="https://chocolatey.org/"><a href="https://chocolatey.org/">巧克力软件|巧克力 - Windows 的包装经理 (chocolatey.org)</a></a></p><p><a href="https://docs.chocolatey.org/en-us/">巧克力软件文档|巧克力 - 窗口软件管理 (chocolatey.org)</a></p><p>Chocolatey 是一种软件管理解决方案，不同于您在 Windows 上体验过的任何其他解决方案。Chocolatey 带来了真正的包装管理概念，让您能够对事物进行版本化、管理依赖性和安装顺序、更好的库存管理以及其他功能。</p><p>Chocolatey 是一种软件管理解决方案，不同于您在 Windows 上体验过的任何其他解决方案。它侧重于简单性、安全性和无限可扩展性。您在 PowerShell 中为任何软件（而不仅仅是安装人员）编写一次软件部署，然后您可以在 Windows 的任何地方部署该软件，并提供任何解决方案来管理系统（配置管理、端点管理等），并随着时间的推移跟踪和管理该软件的更新。在”云”中或在带有巧克力的<a href="https://github.com/Microsoft/vsts-agent-docker/blob/f870fbf259a803c6a6d902e1c01f631936069d66/windows/servercore/10.0.14393/standard/VS2017/Dockerfile">Docker 容器</a>中管理软件。</p><h1 id="第-2-章-chocolatey-软件安装"><a href="#第-2-章-chocolatey-软件安装" class="headerlink" title="第 2 章 chocolatey 软件安装"></a>第 2 章 chocolatey 软件安装</h1><h2 id="1-chocolatey-cli-命令行工具"><a href="#1-chocolatey-cli-命令行工具" class="headerlink" title="1 chocolatey cli 命令行工具"></a>1 chocolatey cli 命令行工具</h2><ul><li><p>使用 cmd.exe 执行安装脚本</p><div class="code-wrapper"><pre><code class="hljs shell">@&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://community.chocolatey.org/install.ps1&#x27;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</code></pre></div></li><li><p>使用 PowerShell.exe 执行安装脚本</p><div class="code-wrapper"><pre><code class="hljs shell">Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://community.chocolatey.org/install.ps1&#x27;))</code></pre></div></li><li><p>升级 chocolatey</p><div class="code-wrapper"><pre><code class="hljs shell">choco upgrade chocolatey</code></pre></div></li><li><p>卸载</p><div class="code-wrapper"><pre><code class="hljs shell">如果您决定不喜欢巧克力，只需删除文件夹（以及它创建的环境变量），即可卸载它。由于它实际上并没有安装在程序和功能中，因此您不必担心它会弄乱您的注册表（但是，对于使用 Chocolatey 或手动安装的应用程序来说，情况就不一样了）。大部分巧克力都包含在或任何评估。您可以简单地删除该文件夹。C:\ProgramData\chocolatey$env:ChocolateyInstall</code></pre></div><blockquote><p>  📝<strong>注</strong></p><p>  您可以首先备后子文件夹，以防您发现删除巧克力的不良结果。请记住，并不是每个巧克力包都是安装包，这些子折中可能包含一些未安装的应用程序可能会丢失。备份将允许您测试这一方面。</p></blockquote></li></ul><h2 id="2-chocolatey-GUI-图形化工具"><a href="#2-chocolatey-GUI-图形化工具" class="headerlink" title="2 chocolatey GUI 图形化工具"></a>2 chocolatey GUI 图形化工具</h2><div class="code-wrapper"><pre><code class="hljs shell">choco install chocolateygui --install-directory &#x27;D:\Program Files\chocolateygui&#x27; -y # 最完整的指定目录安装choco install chocolateygui --dir &#x27;D:\Program Files\chocolateygui&#x27; -y# 简写的命令choco install chocolateygui -y# 采用默认安装路径choco upgrade chocolateygui -y  # 升级 chocolateygui注修改安装目录需要付费可以通过修改 win 默认安装路径，来避免安装在 C:\Program Files建议改为 D:\Program Files</code></pre></div><h1 id="第-3-章-CLI-命令"><a href="#第-3-章-CLI-命令" class="headerlink" title="第 3 章 CLI 命令"></a>第 3 章 CLI 命令</h1><h2 id="1-list-软件列表"><a href="#1-list-软件列表" class="headerlink" title="1 list - 软件列表"></a>1 list - 软件列表</h2><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs shell">choco find &lt;filter&gt; [&lt;options/switches&gt;]choco list &lt;filter&gt; [&lt;options/switches&gt;]clist &lt;filter&gt; [&lt;options/switches&gt;]</code></pre></div></li></ul><ul><li><p>例子</p><div class="code-wrapper"><pre><code class="hljs shell">choco list --local-onlychoco list -lichoco list -laichoco list --page=0 --page-size=25choco search gitchoco search git --source=&quot;&#x27;https://somewhere/out/there&#x27;&quot;choco search bob -s &quot;&#x27;https://somewhere/protected&#x27;&quot; -u user -p pass</code></pre></div></li></ul><h2 id="2-install-安装"><a href="#2-install-安装" class="headerlink" title="2 install - 安装"></a>2 install - 安装</h2><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs shell">choco install &lt;pkg|packages.config&gt; [&lt;pkg2&gt; &lt;pkgN&gt;] [&lt;options/switches&gt;]cinst &lt;pkg|packages.config&gt; [&lt;pkg2&gt; &lt;pkgN&gt;] [&lt;options/switches&gt;]</code></pre></div></li></ul><ul><li><p>例子</p><div class="code-wrapper"><pre><code class="hljs shell">choco install sysinternalschoco install notepadplusplus googlechrome atom 7zipchoco install notepadplusplus --force --force-dependencieschoco install notepadplusplus googlechrome atom 7zip -dvfychoco install git -y --params=&quot;&#x27;/GitAndUnixToolsOnPath /NoAutoCrlf&#x27;&quot;choco install git -y --params=&quot;&#x27;/GitAndUnixToolsOnPath /NoAutoCrlf&#x27;&quot; --install-arguments=&quot;&#x27;/DIR=C:\git&#x27;&quot;<span class="hljs-meta">#</span><span class="bash"> Params are package parameters, passed to the package</span><span class="hljs-meta">#</span><span class="bash"> Install args are installer arguments, appended to the silentArgs</span> <span class="hljs-meta">#</span><span class="bash">  <span class="hljs-keyword">in</span> the package <span class="hljs-keyword">for</span> the installer itself</span>choco install nodejs.install --version 0.10.35choco install git -s &quot;&#x27;https://somewhere/out/there&#x27;&quot;choco install git -s &quot;&#x27;https://somewhere/protected&#x27;&quot; -u user -p pass</code></pre></div></li></ul><h2 id="3-upgrade-升级"><a href="#3-upgrade-升级" class="headerlink" title="3 upgrade - 升级"></a>3 upgrade - 升级</h2><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs shell">choco upgrade &lt;pkg|all&gt; [&lt;pkg2&gt; &lt;pkgN&gt;] [&lt;options/switches&gt;]cup &lt;pkg|all&gt; [&lt;pkg2&gt; &lt;pkgN&gt;] [&lt;options/switches&gt;]</code></pre></div></li></ul><ul><li><p>例子</p><div class="code-wrapper"><pre><code class="hljs shell">choco upgrade chocolateychoco upgrade notepadplusplus googlechrome atom 7zipchoco upgrade notepadplusplus googlechrome atom 7zip -dvfychoco upgrade git -y --params=&quot;&#x27;/GitAndUnixToolsOnPath /NoAutoCrlf&#x27;&quot;choco upgrade git -y --params=&quot;&#x27;/GitAndUnixToolsOnPath /NoAutoCrlf&#x27;&quot; --install-args=&quot;&#x27;/DIR=C:\git&#x27;&quot;<span class="hljs-meta">#</span><span class="bash"> Params are package parameters, passed to the package</span><span class="hljs-meta">#</span><span class="bash"> Install args are installer arguments, appended to the silentArgs</span> <span class="hljs-meta">#</span><span class="bash">  <span class="hljs-keyword">in</span> the package <span class="hljs-keyword">for</span> the installer itself</span>choco upgrade nodejs.install --version 0.10.35choco upgrade git -s &quot;&#x27;https://somewhere/out/there&#x27;&quot;choco upgrade git -s &quot;&#x27;https://somewhere/protected&#x27;&quot; -u user -p passchoco upgrade allchoco upgrade all --except=&quot;&#x27;skype,conemu&#x27;&quot;</code></pre></div></li></ul><h2 id="4-uninstall-卸载"><a href="#4-uninstall-卸载" class="headerlink" title="4 uninstall - 卸载"></a>4 uninstall - 卸载</h2><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs shell">choco uninstall &lt;pkg|all&gt; [pkg2 pkgN] [options/switches]cuninst &lt;pkg|all&gt; [pkg2 pkgN] [options/switches]</code></pre></div></li></ul><ul><li><p>例子</p><div class="code-wrapper"><pre><code class="hljs shell">choco uninstall gitchoco uninstall notepadplusplus googlechrome atom 7zipchoco uninstall notepadplusplus googlechrome atom 7zip -dvchoco uninstall ruby --version 1.8.7.37402choco uninstall nodejs.install --all-versions</code></pre></div></li></ul><h2 id="5-download-下载"><a href="#5-download-下载" class="headerlink" title="5 download - 下载"></a>5 download - 下载</h2><ul><li><p>用法</p><div class="code-wrapper"><pre><code class="hljs shell">choco download &lt;pkg&gt; [&lt;options/switches&gt;] [install_script_variable=value]Install script variables are values that are discovered in the  chocolateyInstall.ps1 (or a script it calls). When you find values there maybe don&#x27;t get found and replaced or they use a default  value and you want to provide a value for them to use instead, you can find them and then provide the value you want to pass instead. For example, in the Firefox package, it uses a default value of  &#x27;en-US&#x27; for `$locale`. If you want to change that, you can add  `locale` and a value, which will replace `$locale` in the script, e.g. `choco download firefox --internalize locale=en-GB`.</code></pre></div></li></ul><ul><li><p>例子</p><div class="code-wrapper"><pre><code class="hljs shell">choco download sysinternals<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">### [Chocolatey for Business](https://chocolatey.org/compare) / Chocolatey for MSP</span></span>choco download notepadplusplus --internalizechoco download notepadplusplus.install --internalize --resources-location \\server\sharechoco download notepadplusplus.install --internalize --resources-location http://somewhere/internal --append-useoriginallocationchoco download KB3033929 --internalize -internalize-all-urls --append-useoriginallocationchoco download firefox --internalize locale=es-AR</code></pre></div></li></ul>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Note/">Note</category>
      
      
      <category domain="https://pncalbl.github.io/tags/choco/">choco</category>
      
      <category domain="https://pncalbl.github.io/tags/win-software-management/">win software management</category>
      
      
      <comments>https://pncalbl.github.io/2021/09/05/choco-cli-Note/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Effective Debugging Note</title>
      <link>https://pncalbl.github.io/2021/09/02/Effective%20Debugging%20Note/</link>
      <guid>https://pncalbl.github.io/2021/09/02/Effective%20Debugging%20Note/</guid>
      <pubDate>Wed, 01 Sep 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;  本篇博客源于 EffectiveDebugging:软件和系统调试的66个有效方法 &lt;/p&gt;
&lt;p&gt;  作者：迪欧米迪斯·斯宾奈里斯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第1章-宏观策略&quot;&gt;&lt;a href=&quot;#第1章-宏观策略&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>  本篇博客源于 EffectiveDebugging:软件和系统调试的66个有效方法 </p><p>  作者：迪欧米迪斯·斯宾奈里斯</p></blockquote><h1 id="第1章-宏观策略"><a href="#第1章-宏观策略" class="headerlink" title="第1章 宏观策略"></a>第1章 宏观策略</h1><h2 id="第1条：通过事务追踪系统处理所有的问题"><a href="#第1条：通过事务追踪系统处理所有的问题" class="headerlink" title="第1条：通过事务追踪系统处理所有的问题"></a>第1条：通过事务追踪系统处理所有的问题</h2><ul><li><p>通过事务追踪系统来处理所有的问题。</p></li><li><p>确保每项事务都能够以短小、自足而又正确的范例（SSCCE），精确地描述出该问题的重现方式。</p></li><li><p>对事务进行分类，并根据每项事务的优先级与严重程度来安排工作。</p></li><li><p>通过事务追踪系统来记录进度。</p></li></ul><h2 id="第2条：在网上确切地查询你所遇到的问题，以寻求解决问题的灵感"><a href="#第2条：在网上确切地查询你所遇到的问题，以寻求解决问题的灵感" class="headerlink" title="第2条：在网上确切地查询你所遇到的问题，以寻求解决问题的灵感"></a>第2条：在网上确切地查询你所遇到的问题，以寻求解决问题的灵感</h2><ul><li>把错误消息打上双引号，以便在网上准确地进行搜索。可以在<a href="https://searchcode.com/">源代码搜索引擎 </a>准确搜索有关具体代码的解决方案。</li><li>认真查看StackExchange系列网站上面的回答。</li><li>如果上述两种办法都不见效，那你可以自己提问或提交事务。自己提问注意：凡是在论坛发问，都应该遵循该SSCCE原则。</li></ul><h2 id="第3条：确保前置条件与后置条件都能够得到满足"><a href="#第3条：确保前置条件与后置条件都能够得到满足" class="headerlink" title="第3条：确保前置条件与后置条件都能够得到满足"></a>第3条：确保前置条件与后置条件都能够得到满足</h2><ul><li>仔细检查例程的前置条件与后置条件。</li><li>例如：数学函数的参数是否在其定义域之内，数据库建表是否成功，可以手动验证。</li></ul><h2 id="第4条：从具体问题入手向上追查bug，或从高层程序入手向下追查bug"><a href="#第4条：从具体问题入手向上追查bug，或从高层程序入手向下追查bug" class="headerlink" title="第4条：从具体问题入手向上追查bug，或从高层程序入手向下追查bug"></a>第4条：从具体问题入手向上追查bug，或从高层程序入手向下追查bug</h2><ul><li>如果能够明确指出故障的原因，那么应该从下往上查找错误，例如，在程序崩溃、程序冻结以及程序发出错误消息等情况下，就应该如此。</li><li>如果故障的原因很难锁定，那么应该从上往下查找错误，例如，在遇到性能问题、安全问题以及可靠性问题的时候，就应该如此。</li></ul><h2 id="第5条：在能够正常运作的系统与发生故障的系统之间寻找差别"><a href="#第5条：在能够正常运作的系统与发生故障的系统之间寻找差别" class="headerlink" title="第5条：在能够正常运作的系统与发生故障的系统之间寻找差别"></a>第5条：在能够正常运作的系统与发生故障的系统之间寻找差别</h2><ul><li>在能够正常运作的系统与出现故障的系统之间对比，找出行为上的区别，以求发现故障的原因。</li><li>影响系统行为的所有因素都要考虑到，包括代码、输入、调用时的参数、环境变量、服务以及动态链接库。</li></ul><h2 id="第6条：使用软件自身的调试机制"><a href="#第6条：使用软件自身的调试机制" class="headerlink" title="第6条：使用软件自身的调试机制"></a>第6条：使用软件自身的调试机制</h2><ul><li>找出你正在调试的这款软件所支持的调试机制，并以此来排查你所遇到的问题。</li></ul><h2 id="第7条：试着用多种工具构建软件，并将其放在不同的环境下执行"><a href="#第7条：试着用多种工具构建软件，并将其放在不同的环境下执行" class="headerlink" title="第7条：试着用多种工具构建软件，并将其放在不同的环境下执行"></a>第7条：试着用多种工具构建软件，并将其放在不同的环境下执行</h2><ul><li>用多种编译工具来构建软件，并将其放在各种平台中执行，可以给调试工作提供很多有价值的思路。</li><li>如果遇到了一个很难调试的算法，那么可以考虑改用高级语言将其重新实现一遍。</li></ul><h2 id="第8条：把工作焦点放在最为重要的问题上"><a href="#第8条：把工作焦点放在最为重要的问题上" class="headerlink" title="第8条：把工作焦点放在最为重要的问题上"></a>第8条：把工作焦点放在最为重要的问题上</h2><ul><li>并不是所有的问题都值得解决。</li><li>修复优先级较低的问题可能会耽误你的时间，使你无法拿出更多时间去处理那些更为紧迫的事务。</li></ul><h1 id="第2章-通用的方法与做法"><a href="#第2章-通用的方法与做法" class="headerlink" title="第2章 通用的方法与做法"></a>第2章 通用的方法与做法</h1><h2 id="第9条：相信自己能够把问题调试好"><a href="#第9条：相信自己能够把问题调试好" class="headerlink" title="第9条：相信自己能够把问题调试好"></a>第9条：相信自己能够把问题调试好</h2><ul><li>确信问题是可以追查并解决的。</li><li>给调试工作留出足够的时间。</li><li>安排好工作环境，使自己不受干扰。</li><li>遇到难题的时候可以先去睡一觉。</li><li>不要彻底放弃。</li><li>投入精力去学习环境、工具及知识。</li></ul><h2 id="第10条：高效地重现程序中的问题"><a href="#第10条：高效地重现程序中的问题" class="headerlink" title="第10条：高效地重现程序中的问题"></a>第10条：高效地重现程序中的问题</h2><ul><li>如果能够准确重现程序中的问题，那么我们的调试过程就会得以简化。</li><li>创建一个简短且自足的范例，以便重现程序中的问题。</li><li>设法创建一套可以制作副本的执行环境。</li><li>采用版本控制系统给特定的软件版本打上标记，以便根据此标记来获取与之对应的代码。</li></ul><h2 id="第11条：修改完代码之后，要能够尽快看到结果"><a href="#第11条：修改完代码之后，要能够尽快看到结果" class="headerlink" title="第11条：修改完代码之后，要能够尽快看到结果"></a>第11条：修改完代码之后，要能够尽快看到结果</h2><ul><li>设法在修改代码之后尽快看到其结果，以提升调试的效率。</li><li>配置一套快速的自动化构建及部署流程。</li><li>测试软件时，要令其尽快地将故障暴露出来。</li></ul><h2 id="第12条：将复杂的测试场景自动化"><a href="#第12条：将复杂的测试场景自动化" class="headerlink" title="第12条：将复杂的测试场景自动化"></a>第12条：将复杂的测试场景自动化</h2><ul><li>通过脚本语言来自动执行复杂的测试用例。</li></ul><h2 id="第13条：使自己尽可能多地观察到与调试有关的数据"><a href="#第13条：使自己尽可能多地观察到与调试有关的数据" class="headerlink" title="第13条：使自己尽可能多地观察到与调试有关的数据"></a>第13条：使自己尽可能多地观察到与调试有关的数据</h2><ul><li>如果能够同时看到比较多的数据，那我们就可以更加专注地进行调试，从而找到数据所体现出的模式以及数据之间的相互关系。</li><li>尽可能地将显示区域扩至最大。</li><li>把相对静态的数据打印到纸上。</li></ul><h2 id="第14条：考虑对软件进行更新"><a href="#第14条：考虑对软件进行更新" class="headerlink" title="第14条：考虑对软件进行更新"></a>第14条：考虑对软件进行更新</h2><ul><li>在更新之后的环境里面重新尝试你所编写的代码，看看这次会不会出错。</li><li>不要对更新软件所带来的效果抱有过高的期望。</li><li>要考虑因第三方组件而引发bug的可能性。</li></ul><h2 id="第15条：查看第三方组件的源代码，以了解其用法"><a href="#第15条：查看第三方组件的源代码，以了解其用法" class="headerlink" title="第15条：查看第三方组件的源代码，以了解其用法"></a>第15条：查看第三方组件的源代码，以了解其用法</h2><ul><li>如果你依赖某个第三方组件，那么就应该获取其源代码。</li><li>通过查看第三方组件的源代码探寻与第三方API及一些奇怪的错误消息有关的问题。</li><li>要和第三方程序库的debug版本相链接。</li><li>只有当其他办法都不可行的时候，才需要对第三方的源代码进行修改。</li></ul><h2 id="第16条：使用专门的监测及测试设备"><a href="#第16条：使用专门的监测及测试设备" class="headerlink" title="第16条：使用专门的监测及测试设备"></a>第16条：使用专门的监测及测试设备</h2><ul><li>逻辑分析器、总线分析器或协议分析器可以帮你锁定接近于硬件层面的问题。</li><li>可以通过自制的设备来探查与硬件有关的问题。</li><li>可以通过将Wireshark与以太网集线器相结合、使用管理型交换机或进行命令行捕获等办法来监测网络数据包。</li></ul><h2 id="第17条：使故障更加突出"><a href="#第17条：使故障更加突出" class="headerlink" title="第17条：使故障更加突出"></a>第17条：使故障更加突出</h2><ul><li>迫使软件去执行那些可疑的路径。</li><li>提升某些效果的幅度，令其变得更加突出，以便于我们进行研究。</li><li>对软件加压，迫使它走出能够从容应对负载的那种舒适状态。</li><li>在版本管理系统中临时创建一个分支，并把所有的修改都放在这个分支上面来做。</li></ul><h2 id="第18条：从自己的桌面计算机上调试那些不太好用的系统"><a href="#第18条：从自己的桌面计算机上调试那些不太好用的系统" class="headerlink" title="第18条：从自己的桌面计算机上调试那些不太好用的系统"></a>第18条：从自己的桌面计算机上调试那些不太好用的系统</h2><ul><li>把设备模拟器配置好，以便通过计算机屏幕和键盘来调试移动app。</li><li>搭建shim机制，以便使用自己计算机中的工具来调试嵌入式代码。</li><li>为远程访问做好准备，以便能够远程调试客户的计算机。</li><li>配置KVM over IP设备，以便调试远程服务器上面的问题。</li></ul><h2 id="第19条：使调试任务自动化"><a href="#第19条：使调试任务自动化" class="headerlink" title="第19条：使调试任务自动化"></a>第19条：使调试任务自动化</h2><ul><li>把寻找程序故障的过程自动化，使得计算机多费一些功夫去搜寻，从而节省你自己的宝贵时间。</li></ul><h2 id="第20条：开始调试之前与调试完毕之后都要把程序清理干净"><a href="#第20条：开始调试之前与调试完毕之后都要把程序清理干净" class="headerlink" title="第20条：开始调试之前与调试完毕之后都要把程序清理干净"></a>第20条：开始调试之前与调试完毕之后都要把程序清理干净</h2><ul><li>在开始调试重大的bug之前，先要确保代码能够达到一定的整洁程度。</li><li>调试完毕之后，要把调试过程中对代码所做的临时改动还原回去，并且要把那些有用的代码提交到代码库。</li></ul>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Note/">Note</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Debugging/">Debugging</category>
      
      <category domain="https://pncalbl.github.io/tags/Crash/">Crash</category>
      
      
      <comments>https://pncalbl.github.io/2021/09/02/Effective%20Debugging%20Note/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java 面试</title>
      <link>https://pncalbl.github.io/2021/07/30/Java%E9%9D%A2%E8%AF%95/</link>
      <guid>https://pncalbl.github.io/2021/07/30/Java%E9%9D%A2%E8%AF%95/</guid>
      <pubDate>Thu, 29 Jul 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;第一部分-Java-并发编程&quot;&gt;&lt;a href=&quot;#第一部分-Java-并发编程&quot; class=&quot;headerlink&quot; title=&quot;第一部分 Java 并发编程&quot;&gt;&lt;/a&gt;第一部分 Java 并发编程&lt;/h1&gt;&lt;h1 id=&quot;第1章-谈谈Volatile&quot;&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="第一部分-Java-并发编程"><a href="#第一部分-Java-并发编程" class="headerlink" title="第一部分 Java 并发编程"></a>第一部分 Java 并发编程</h1><h1 id="第1章-谈谈Volatile"><a href="#第1章-谈谈Volatile" class="headerlink" title="第1章 谈谈Volatile"></a>第1章 谈谈Volatile</h1><h2 id="1-Volatile和JMM内存模型的可见性"><a href="#1-Volatile和JMM内存模型的可见性" class="headerlink" title="1 Volatile和JMM内存模型的可见性"></a>1 Volatile和JMM内存模型的可见性</h2><ul><li>JUC（java.util.concurrent）<ul><li>进程和线程<ul><li>进程：后台运行的程序（我们打开的一个软件，就是进程）</li><li>线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）</li></ul></li><li>并发和并行<ul><li>并发：同时访问某个东西，就是并发</li><li>并行：一起做某些事情，就是并行</li></ul></li></ul></li><li>JUC下的三个包<ul><li>java.util.concurrent<ul><li>java.util.concurrent.atomic</li><li>java.util.concurrent.locks</li></ul></li></ul></li></ul><p>Volatile在日常的单线程环境是应用不到的</p><ul><li>Volatile是Java虚拟机提供的<code>轻量级</code>的同步机制（三大特性）<ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul></li></ul><h3 id="1-1-谈谈对Volatile的理解"><a href="#1-1-谈谈对Volatile的理解" class="headerlink" title="1.1 谈谈对Volatile的理解"></a>1.1 谈谈对Volatile的理解</h3><h3 id="1-2-JMM是什么"><a href="#1-2-JMM是什么" class="headerlink" title="1.2 JMM是什么"></a>1.2 JMM是什么</h3><p>JMM是Java内存模型，也就是Java Memory Model，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM关于同步的规定：</p><ul><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值，到自己的工作内存</li><li>加锁和解锁是同一把锁</li></ul><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，<code>但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存</code>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309153225758.png" alt="image-20200309153225758"></p><p>数据传输速率：硬盘 &lt; 内存 &lt; &lt; cache &lt; CPU   </p><p>上面提到了两个概念：主内存  和 工作内存</p><ul><li><p>主内存：就是计算机的内存，也就是经常提到的8G内存，16G内存</p></li><li><p>工作内存：但我们实例化 new student，那么 age = 25 也是存储在主内存中</p><ul><li>当同时有三个线程同时访问 student中的age变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了变量的拷贝</li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309154435933.png" alt="image-20200309154435933"></p></li></ul><p>即：JMM内存模型的可见性，指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p><h3 id="1-3-缓存一致性"><a href="#1-3-缓存一致性" class="headerlink" title="1.3 缓存一致性"></a>1.3 缓存一致性</h3><p>为什么这里主线程中某个值被更改后，其它线程能马上知晓呢？其实这里是用到了总线嗅探技术</p><p>在说嗅探技术之前，首先谈谈缓存一致性的问题，就是当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一。</p><p>为了解决缓存一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，这类协议主要有MSI、MESI等等。</p><h4 id="1-MESI"><a href="#1-MESI" class="headerlink" title="1 MESI"></a>1 MESI</h4><p>当CPU写数据时，如果发现操作的变量是共享变量，即在其它CPU中也存在该变量的副本，会发出信号通知其它CPU将该内存变量的缓存行设置为无效，因此当其它CPU读取这个变量的时，发现自己缓存该变量的缓存行是无效的，那么它就会从内存中重新读取。</p><h4 id="2-总线嗅探"><a href="#2-总线嗅探" class="headerlink" title="2 总线嗅探"></a>2 总线嗅探</h4><p>那么是如何发现数据是否失效呢？</p><p>这里是用到了总线嗅探技术，就是每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中。</p><h4 id="3-总线风暴"><a href="#3-总线风暴" class="headerlink" title="3 总线风暴"></a>3 总线风暴</h4><p>总线嗅探技术有哪些缺点？</p><p>由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和CAS循环，无效的交互会导致总线带宽达到峰值。因此不要大量使用volatile关键字，至于什么时候使用volatile、什么时候用锁以及Syschonized都是需要根据实际场景的。</p><h3 id="1-4-JMM的特性"><a href="#1-4-JMM的特性" class="headerlink" title="1.4 JMM的特性"></a>1.4 JMM的特性</h3><p>JMM的三大特性，volatile只保证了两个，即可见性和有序性，不满足原子性</p><ul><li>可见性</li><li>原子性</li><li>有序性</li></ul><h3 id="1-5-可见性代码验证"><a href="#1-5-可见性代码验证" class="headerlink" title="1.5 可见性代码验证"></a>1.5 可见性代码验证</h3><p>但我们对于成员变量没有添加任何修饰时，是无法感知其它线程修改后的值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.moxi.interview.study.thread;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Volatile Java虚拟机提供的轻量级同步机制</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 可见性（及时通知）</span><span class="hljs-comment"> * 不保证原子性</span><span class="hljs-comment"> * 禁止指令重排</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 假设是主物理内存</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;    <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 验证volatile的可见性</span><span class="hljs-comment"> * 1. 假设int number = 0， number变量之前没有添加volatile关键字修饰</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args [])</span> </span>&#123;        <span class="hljs-comment">// 资源类</span>        MyData myData = <span class="hljs-keyword">new</span> MyData();        <span class="hljs-comment">// AAA线程 实现了Runnable接口的，lambda表达式</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in&quot;</span>);            <span class="hljs-comment">// 线程睡眠3秒，假设在进行运算</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 修改number的值</span>            myData.addTo60();            <span class="hljs-comment">// 输出修改后的值</span>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t update number value:&quot;</span> + myData.number);        &#125;, <span class="hljs-string">&quot;AAA&quot;</span>).start();        <span class="hljs-keyword">while</span>(myData.number == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// main线程就一直在这里等待循环，直到number的值不等于零</span>        &#125;        <span class="hljs-comment">// 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环</span>        <span class="hljs-comment">// 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了</span>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t mission is over&quot;</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 最后输出结果：</span><span class="hljs-comment">         * AAA come in</span><span class="hljs-comment">         * AAA update number value:60</span><span class="hljs-comment">         * 最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</span><span class="hljs-comment">         */</span>    &#125;&#125;</code></pre></div><p>输出结果为</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309162154191-1628001500488100.png" alt="image-20200309162154191">    </p><p>最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</p><p>当我们修改MyData类中的成员变量时，并且添加volatile关键字修饰</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 假设是主物理内存</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;    &#125;&#125;</code></pre></div><p>最后输出的结果为：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309162154191.png" alt="image-20200309162154191"></p><p>主线程也执行完毕了，说明volatile修饰的变量，是具备JVM轻量级同步机制的，能够感知其它线程的修改后的值。</p><h2 id="2-Volatile不保证原子性"><a href="#2-Volatile不保证原子性" class="headerlink" title="2 Volatile不保证原子性"></a>2 Volatile不保证原子性</h2><h3 id="2-1-前言"><a href="#2-1-前言" class="headerlink" title="2.1 前言"></a>2.1 前言</h3><p>通过前面对JMM的介绍，我们知道，各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后在写回到主内存中的。</p><p>这就可能存在一个线程AAA修改了共享变量X的值，但是还未写入主内存时，另外一个线程BBB又对主内存中同一共享变量X进行操作，但此时A线程工作内存中共享变量X对线程B来说是不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题。</p><h3 id="2-2-原子性"><a href="#2-2-原子性" class="headerlink" title="2.2 原子性"></a>2.2 原子性</h3><p>不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要具体完成，要么同时成功，要么同时失败。</p><p>数据库也经常提到事务具备原子性</p><h3 id="2-3-代码测试"><a href="#2-3-代码测试" class="headerlink" title="2.3 代码测试"></a>2.3 代码测试</h3><p>为了测试volatile是否保证原子性，我们创建了20个线程，然后每个线程分别循环1000次，来调用number++的方法</p><div class="code-wrapper"><pre><code class="hljs java">MyData myData = <span class="hljs-keyword">new</span> MyData();<span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-comment">// 里面</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;            myData.addPlusPlus();        &#125;    &#125;, String.valueOf(i)).start();&#125;</code></pre></div><p>最后通过 Thread.activeCount()，来感知20个线程是否执行完毕，这里判断线程数是否大于2，为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span><span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-comment">// yield表示不执行</span>    Thread.yield();&#125;</code></pre></div><p>然后在线程执行完毕后，我们在查看number的值，假设volatile保证原子性的话，那么最后输出的值应该是</p><p>20 * 1000 = 20000,</p><p>完整代码如下所示：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Volatile Java虚拟机提供的轻量级同步机制</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 可见性（及时通知）</span><span class="hljs-comment"> * 不保证原子性</span><span class="hljs-comment"> * 禁止指令重排</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 假设是主物理内存</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 注意，此时number 前面是加了volatile修饰</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;        number ++;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 验证volatile的可见性</span><span class="hljs-comment"> * 1、 假设int number = 0， number变量之前没有添加volatile关键字修饰</span><span class="hljs-comment"> * 2、添加了volatile，可以解决可见性问题</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 验证volatile不保证原子性</span><span class="hljs-comment"> * 1、原子性指的是什么意思？</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args [])</span> </span>&#123;        MyData myData = <span class="hljs-keyword">new</span> MyData();        <span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-comment">// 里面</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;                    myData.addPlusPlus();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        <span class="hljs-comment">// 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span>        <span class="hljs-comment">// 这里判断线程数是否大于2，为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</span>        <span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123;            <span class="hljs-comment">// yield表示不执行</span>            Thread.yield();        &#125;        <span class="hljs-comment">// 查看最终的值</span>        <span class="hljs-comment">// 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000</span>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally number value: &quot;</span> + myData.number);    &#125;&#125;</code></pre></div><p>最终结果我们会发现，number输出的值并没有20000，而且是每次运行的结果都不一致的，这说明了volatile修饰的变量不保证原子性</p><p>第一次：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309172900462.png" alt="image-20200309172900462"></p><p>第二次：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309172919295.png" alt="image-20200309172919295"></p><p>第三次：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309172929820.png" alt="image-20200309172929820"></p><h3 id="2-4-为什么出现数值丢失"><a href="#2-4-为什么出现数值丢失" class="headerlink" title="2.4 为什么出现数值丢失"></a>2.4 为什么出现数值丢失</h3><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309174220675.png" alt="image-20200309174220675"></p><p>各自线程在写入主内存的时候，出现了数据的丢失，而引起的数值缺失的问题</p><p>下面我们将一个简单的number++操作，转换为字节码文件一探究竟</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span> </span>&#123;    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        n++;    &#125;&#125;</code></pre></div><p>转换后的字节码文件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">moxi</span>.<span class="hljs-title">interview</span>.<span class="hljs-title">study</span>.<span class="hljs-title">thread</span>.<span class="hljs-title">T1</span> </span>&#123;  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> n;  <span class="hljs-keyword">public</span> com.moxi.interview.study.thread.T1();    Code:       <span class="hljs-number">0</span>: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       <span class="hljs-number">4</span>: aload_0       <span class="hljs-number">5</span>: iconst_0       6: putfield      #2                  // Field n:I       <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;    Code:       <span class="hljs-number">0</span>: aload_0       <span class="hljs-number">1</span>: dup       2: getfield      #2                  // Field n:I       <span class="hljs-number">5</span>: iconst_1       <span class="hljs-number">6</span>: iadd       7: putfield      #2                  // Field n:I      <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span>&#125;</code></pre></div><p>这里查看字节码的操作，是用到了IDEA的javap命令</p><p>我们首先，使用IDEA提供的External Tools，来扩展javap命令</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309183026329.png" alt="image-20200309183026329"></p><p>完成上述操作后，我们在需要查看字节码的文件下，右键选择 External Tools即可</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309183115613.png" alt="image-20200309183115613"></p><p>如果出现了找不到指定类，那是因为我们创建的是spring boot的maven项目，我们之前需要执行mvn package命令，进行打包操作，将其编译成class文件</p><p>移动到底部，有一份字节码指令对照表，方便我们进行阅读</p><p>下面我们就针对 add() 这个方法的字节码文件进行分析</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;  Code:     <span class="hljs-number">0</span>: aload_0     <span class="hljs-number">1</span>: dup     2: getfield      #2    // Field n:I     <span class="hljs-number">5</span>: iconst_1     <span class="hljs-number">6</span>: iadd     7: putfield      #2    // Field n:I    <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span></code></pre></div><p>我们能够发现 n++这条命令，被拆分成了3个指令</p><ul><li>执行<code>getfield</code> 从主内存拿到原始n</li><li>执行<code>iadd</code> 进行加1操作</li><li>执行<code>putfileld</code> 把累加后的值写回主内存 </li></ul><p>假设我们没有加 <code>synchronized</code>那么第一步就可能存在着，三个线程同时通过getfield命令，拿到主存中的 n值，然后三个线程，各自在自己的工作内存中进行加1操作，但他们并发进行  <code>iadd</code> 命令的时候，因为只能一个进行写，所以其它操作会被挂起，假设1线程，先进行了写操作，在写完后，volatile的可见性，应该需要告诉其它两个线程，主内存的值已经被修改了，但是因为太快了，其它两个线程，陆续执行 <code>iadd</code>命令，进行写入操作，这就造成了其他线程没有接受到主内存n的改变，从而覆盖了原来的值，出现写丢失，这样也就让最终的结果少于20000</p><h3 id="2-5-如何解决"><a href="#2-5-如何解决" class="headerlink" title="2.5 如何解决"></a>2.5 如何解决</h3><p>因此这也说明，在多线程环境下 number ++ 在多线程环境下是非线程安全的，解决的方法有哪些呢？</p><ul><li>在方法上加入 synchronized</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;number ++;&#125;</code></pre></div><p>运行结果：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309173315294.png" alt="image-20200309173315294"></p><p>我们能够发现引入synchronized关键字后，保证了该方法每次只能够一个线程进行访问和操作，最终输出的结果也就为20000</p><h3 id="2-6-其它解决方法"><a href="#2-6-其它解决方法" class="headerlink" title="2.6  其它解决方法"></a>2.6  其它解决方法</h3><p>上面的方法引入synchronized，虽然能够保证原子性，但是为了解决number++，而引入重量级的同步机制，有种 杀鸡焉用牛刀</p><p>除了引用synchronized关键字外，还可以使用JUC下面的原子包装类，即刚刚的int类型的number，可以使用AtomicInteger来代替</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     *  创建一个原子Integer包装类，默认为0</span><span class="hljs-comment">      */</span>AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtomic</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 相当于 atomicInter ++</span>    atomicInteger.getAndIncrement();&#125;</code></pre></div><p>然后同理，继续刚刚的操作</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <span class="hljs-comment">// 里面</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;            myData.addPlusPlus();            myData.addAtomic();        &#125;    &#125;, String.valueOf(i)).start();&#125;</code></pre></div><p>最后输出</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000</span>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally number value: &quot;</span> + myData.number);System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally atomicNumber value: &quot;</span> + myData.atomicInteger);</code></pre></div><p>下面的结果，一个是引入synchronized，一个是使用了原子包装类AtomicInteger</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309205242622.png" alt="image-20200309205242622"></p><h2 id="3-Volatile禁止指令重排"><a href="#3-Volatile禁止指令重排" class="headerlink" title="3 Volatile禁止指令重排"></a>3 Volatile禁止指令重排</h2><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令重排，一般分为以下三种：</p><div class="code-wrapper"><pre><code class="hljs clean">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</code></pre></div><p>单线程环境里面确保最终执行结果和代码顺序的结果一致</p><p>处理器在进行重排序时，必须要考虑指令之间的<code>数据依赖性</code></p><p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p><h3 id="3-1-指令重排-example-1"><a href="#3-1-指令重排-example-1" class="headerlink" title="3.1 指令重排 - example 1"></a>3.1 指令重排 - example 1</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mySort</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> x = <span class="hljs-number">11</span>;<span class="hljs-keyword">int</span> y = <span class="hljs-number">12</span>;x = x + <span class="hljs-number">5</span>;y = x * x;&#125;</code></pre></div><p>按照正常单线程环境，执行顺序是 1 2 3 4</p><p>但是在多线程环境下，可能出现以下的顺序：</p><ul><li>2 1 3 4</li><li>1 3 2 4 </li></ul><p>上述的过程就可以当做是指令的重排，即内部执行顺序，和我们的代码顺序不一样</p><p>但是指令重排也是有限制的，即不会出现下面的顺序</p><ul><li>4 3 2 1</li></ul><p>因为处理器在进行重排时候，必须考虑到指令之间的数据依赖性</p><p>因为步骤 4：需要依赖于 y的申明，以及x的申明，故因为存在数据依赖，无法首先执行</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>int a,b,x,y = 0</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>x = a;</td><td>y = b;</td></tr><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td></td><td></td></tr><tr><td>x = 0;  y = 0</td><td></td></tr></tbody></table><p>因为上面的代码，不存在数据的依赖性，因此编译器可能对数据进行重排</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>x = a;</td><td>y = b;</td></tr><tr><td></td><td></td></tr><tr><td>x = 2;  y = 1</td><td></td></tr></tbody></table><p>这样造成的结果，和最开始的就不一致了，这就是导致重排后，结果和最开始的不一样，因此为了防止这种结果出现，volatile就规定禁止指令重排，为了保证数据的一致性</p><h3 id="3-2-指令重排-example-2"><a href="#3-2-指令重排-example-2" class="headerlink" title="3.2 指令重排 - example 2"></a>3.2 指令重排 - example 2</h3><p>比如下面这段代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ResortSeqDemo</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResortSeqDemo</span> </span>&#123;    <span class="hljs-keyword">int</span> a= <span class="hljs-number">0</span>;    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;        a = <span class="hljs-number">1</span>;        flag = <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method02</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(flag) &#123;            a = a + <span class="hljs-number">5</span>;            System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);        &#125;    &#125;&#125;</code></pre></div><p>我们按照正常的顺序，分别调用method01()  和 method02() 那么，最终输出就是 a = 6</p><p>但是如果在多线程环境下，因为方法1 和 方法2，他们之间不能存在数据依赖的问题，因此原先的顺序可能是</p><div class="code-wrapper"><pre><code class="hljs java">a = <span class="hljs-number">1</span>;flag = <span class="hljs-keyword">true</span>;a = a + <span class="hljs-number">5</span>;System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);</code></pre></div><p>但是在经过编译器，指令，或者内存的重排后，可能会出现这样的情况</p><div class="code-wrapper"><pre><code class="hljs java">flag = <span class="hljs-keyword">true</span>;a = a + <span class="hljs-number">5</span>;System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);a = <span class="hljs-number">1</span>;</code></pre></div><p>也就是先执行 flag = true后，另外一个线程马上调用方法2，满足 flag的判断，最终让a + 5，结果为5，这样同样出现了数据不一致的问题</p><p>为什么会出现这个结果：多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p><p>这样就需要通过volatile来修饰，来保证线程安全性</p><h3 id="3-3-Volatile针对指令重排做了啥"><a href="#3-3-Volatile针对指令重排做了啥" class="headerlink" title="3.3 Volatile针对指令重排做了啥"></a>3.3 Volatile针对指令重排做了啥</h3><p>Volatile实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象</p><p>首先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：</p><ul><li>保证特定操作的顺序</li><li>保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</li></ul><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说 <code>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</code>。 内存屏障另外一个作用是刷新出各种CPU的缓存数，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310162654437.png" alt="image-20200310162654437"></p><p>也就是过在Volatile的写 和 读的时候，加入屏障，防止出现指令重排的</p><h3 id="3-4-线程安全获得保证"><a href="#3-4-线程安全获得保证" class="headerlink" title="3.4 线程安全获得保证"></a>3.4 线程安全获得保证</h3><p>工作内存与主内存同步延迟现象导致的可见性问题</p><ul><li>可通过synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见</li></ul><p>对于指令重排导致的可见性问题和有序性问题</p><ul><li>可以使用volatile关键字解决，因为volatile关键字的另一个作用就是禁止重排序优化</li></ul><h3 id="3-5-总线嗅探"><a href="#3-5-总线嗅探" class="headerlink" title="3.5 总线嗅探"></a>3.5 总线嗅探</h3><h2 id="4-Volatile的应用"><a href="#4-Volatile的应用" class="headerlink" title="4 Volatile的应用"></a>4 Volatile的应用</h2><h3 id="单例模式DCL代码"><a href="#单例模式DCL代码" class="headerlink" title="单例模式DCL代码"></a>单例模式DCL代码</h3><p>首先回顾一下，单线程下的单例模式代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * SingletonDemo（单例模式）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;            instance = <span class="hljs-keyword">new</span> SingletonDemo();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 这里的 == 是比较内存地址</span>        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());    &#125;&#125;</code></pre></div><p>最后输出的结果</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310164513408.png" alt="image-20200310164513408"></p><p>但是在多线程的环境下，我们的单例模式是否还是同一个对象了</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * SingletonDemo（单例模式）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;            instance = <span class="hljs-keyword">new</span> SingletonDemo();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                SingletonDemo.getInstance();            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><p>从下面的结果我们可以看出，我们通过SingletonDemo.getInstance() 获取到的对象，并不是同一个，而是被下面几个线程都进行了创建，那么在多线程环境下，单例模式如何保证呢？</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310164720940.png" alt="image-20200310164720940"></p><h4 id="1-解决方法1"><a href="#1-解决方法1" class="headerlink" title="1 解决方法1"></a>1 解决方法1</h4><p>引入synchronized关键字</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;        instance = <span class="hljs-keyword">new</span> SingletonDemo();    &#125;    <span class="hljs-keyword">return</span> instance;&#125;</code></pre></div><p>输出结果</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310164946940.png" alt="image-20200310164946940"></p><p>我们能够发现，通过引入Synchronized关键字，能够解决高并发环境下的单例模式问题</p><p>但是synchronized属于重量级的同步机制，它只允许一个线程同时访问获取实例的方法，但是为了保证数据一致性，而减低了并发性，因此采用的比较少</p><h4 id="2-解决方法2"><a href="#2-解决方法2" class="headerlink" title="2 解决方法2"></a>2 解决方法2</h4><p>通过引入DCL   Double Check Lock   双端检锁机制</p><p>就是在进来和出去的时候，进行检测</p><div class="code-wrapper"><pre><code class="hljs smali">public<span class="hljs-keyword"> static</span> SingletonDemo getInstance() &#123;    if(instance == null) &#123;        // 同步代码段的时候，进行检测        synchronized (SingletonDemo.class) &#123;            if(instance == null) &#123;               <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>SingletonDemo();            &#125;        &#125;    &#125;   <span class="hljs-built_in"> return </span>instance;&#125;</code></pre></div><p>最后输出的结果为：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310165703190.png" alt="image-20200310165703190"></p><p>从输出结果来看，确实能够保证单例模式的正确性，但是上面的方法还是存在问题的</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入volatile可以禁止指令重排</p><p>原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象可能没有完成实例化。因为 instance = new SingletonDemo()；可以分为以下三步进行完成：</p><ul><li>memory = allocate();   // 1、分配对象内存空间</li><li>instance(memory);   // 2、初始化对象</li><li>instance = memory;  // 3、设置instance指向刚刚分配的内存地址，此时instance != null</li></ul><p>但是我们通过上面的三个步骤，能够发现，步骤2 和 步骤3之间不存在 数据依赖关系，而且无论重排前 还是重排后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。</p><ul><li>memory = allocate();   // 1、分配对象内存空间</li><li>instance = memory;  // 3、设置instance指向刚刚分配的内存地址，此时instance != null，但是对象还没有初始化完成</li><li>instance(memory);   // 2、初始化对象</li></ul><p>这样就会造成什么问题呢？</p><p>也就是当我们执行到重排后的步骤2，试图获取instance的时候，会得到null，因为对象的初始化还没有完成，而是在重排后的步骤3才完成，因此执行单例模式的代码时候，就会重新在创建一个instance实例</p><p><code>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</code></p><p>所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，这就造成了线程安全的问题</p><p>所以需要引入volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;</code></pre></div><h4 id="3-最终代码"><a href="#3-最终代码" class="headerlink" title="3 最终代码"></a>3 最终代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * SingletonDemo（单例模式）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// a 双重检查加锁多线程情况下会出现某个线程虽然这里已经为空，但是另外一个线程已经执行到d处</span>            <span class="hljs-keyword">synchronized</span> (SingletonDemo.class) <span class="hljs-comment">//b</span>            &#123;            <span class="hljs-comment">//c不加volitale关键字的话有可能会出现尚未完全初始化就获取到的情况。原因是内存模型允许无序写入</span>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;                 <span class="hljs-comment">// d 此时才开始初始化</span>                    instance = <span class="hljs-keyword">new</span> SingletonDemo();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//        // 这里的 == 是比较内存地址</span><span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span><span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span><span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span><span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                SingletonDemo.getInstance();            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><h1 id="第2章-CAS底层原理"><a href="#第2章-CAS底层原理" class="headerlink" title="第2章 CAS底层原理"></a>第2章 CAS底层原理</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>CAS的全称是Compare-And-Swap，它是CPU并发原语</p><p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的</p><p>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的。</p><h2 id="2-代码使用"><a href="#2-代码使用" class="headerlink" title="2 代码使用"></a>2 代码使用</h2><p>首先调用AtomicInteger创建了一个实例， 并初始化为5</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个原子类</span>AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);</code></pre></div><p>然后调用CAS方法，企图更新成2019，这里有两个参数，一个是5，表示期望值，第二个就是我们要更新的值</p><div class="code-wrapper"><pre><code class="hljs java">atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>)</code></pre></div><p>然后再次使用了一个方法，同样将值改成1024</p><div class="code-wrapper"><pre><code class="hljs java">atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">1024</span>)</code></pre></div><p>完整代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * CASDemo</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 比较并交换：compareAndSet</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建一个原子类</span>        AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span><span class="hljs-comment">         * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span><span class="hljs-comment">         */</span>        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());    &#125;&#125;</code></pre></div><p>上面代码的执行结果为</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310201327734.png" alt="image-20200310201327734"></p><p>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，但是第二次后，主内存的值已经修改成了2019，不满足期望值，因此返回了false，本次写入失败</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310201311367.png" alt="image-20200310201311367"></p><p>这个就类似于SVN或者Git的版本号，如果没有人更改过，就能够正常提交，否者需要先将代码pull下来，合并代码后，然后提交</p><h2 id="3-CAS底层原理"><a href="#3-CAS底层原理" class="headerlink" title="3 CAS底层原理"></a>3 CAS底层原理</h2><p>首先我们先看看 atomicInteger.getAndIncrement()方法的源码</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310203030720-162800144543982.png" alt="image-20200310203030720"></p><p>从这里能够看到，底层又调用了一个unsafe类的getAndAddInt方法</p><h3 id="3-1-unsafe类"><a href="#3-1-unsafe类" class="headerlink" title="3.1 unsafe类"></a>3.1 unsafe类</h3><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310203350122.png" alt="image-20200310203350122"></p><p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe类存在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中的CAS操作的执行依赖于Unsafe类的方法。</p><p><code>注意Unsafe类的所有方法都是native修饰的，也就是说unsafe类中的方法都直接调用操作系统底层资源执行相应的任务</code></p><p>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</p><h3 id="3-2-变量valueOffset"><a href="#3-2-变量valueOffset" class="headerlink" title="3.2 变量valueOffset"></a>3.2 变量valueOffset</h3><p>表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310203030720.png" alt="image-20200310203030720"></p><p>从这里我们能够看到，通过valueOffset，直接通过内存地址，获取到值，然后进行加1的操作</p><h3 id="3-3-变量value用volatile修饰"><a href="#3-3-变量value用volatile修饰" class="headerlink" title="3.3 变量value用volatile修饰"></a>3.3 变量value用volatile修饰</h3><p>保证了多线程之间的内存可见性</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310210701761.png" alt="image-20200310210701761"></p><p>var5：就是我们从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值到自己的本地内存，然后执行compareAndSwapInt()在再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p><p>那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较</p><p>假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值得引用地址</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值<ul><li>用该对象当前的值与var5比较</li><li>如果相同，更新var5 + var4 并返回true</li><li>如果不同，继续取值然后再比较，直到更新完成</li></ul></li></ul><p>这里没有用synchronized，而用CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。</p><p>假设线程A和线程B同时执行getAndInt操作（分别跑在不同的CPU上）</p><ol><li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</li><li>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是线程A被挂起（该线程失去CPU执行权）</li><li>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B没有被挂起，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</li><li>这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4不一致，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行do while</li><li>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</li></ol><p>Unsafe类 + CAS思想： 也就是自旋，自我旋转</p><h2 id="4-底层汇编"><a href="#4-底层汇编" class="headerlink" title="4 底层汇编"></a>4 底层汇编</h2><p>Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于unsafe.cpp中</p><ul><li>先想办法拿到变量value在内存中的地址</li><li>通过Atomic::cmpxchg实现比较替换，其中参数X是即将更新的值，参数e是原内存的值</li></ul><h2 id="5-CAS缺点"><a href="#5-CAS缺点" class="headerlink" title="5 CAS缺点"></a>5 CAS缺点</h2><p>CAS不加锁，保证一次性，但是需要多次比较</p><ul><li>循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会无限循环）</li><li>只能保证一个共享变量的原子操作<ul><li>当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作</li><li>但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性</li></ul></li><li>引出来ABA问题？</li></ul><h2 id="6-ABA问题"><a href="#6-ABA问题" class="headerlink" title="6 ABA问题"></a>6 ABA问题</h2><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><h3 id="7-1-CAS"><a href="#7-1-CAS" class="headerlink" title="7.1 CAS"></a>7.1 CAS</h3><p>CAS是compareAndSwap，比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止</p><h3 id="7-2-CAS应用"><a href="#7-2-CAS应用" class="headerlink" title="7.2 CAS应用"></a>7.2 CAS应用</h3><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否者什么都不做</p><h1 id="第3章-原子类AtomicInteger的ABA问题"><a href="#第3章-原子类AtomicInteger的ABA问题" class="headerlink" title="第3章 原子类AtomicInteger的ABA问题"></a>第3章 原子类AtomicInteger的ABA问题</h1><h2 id="1-连环套路"><a href="#1-连环套路" class="headerlink" title="1 连环套路"></a>1 连环套路</h2><p>从AtomicInteger引出下面的问题</p><p>CAS -&gt; Unsafe -&gt; CAS底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避ABA问题</p><h2 id="2-ABA问题是什么"><a href="#2-ABA问题是什么" class="headerlink" title="2 ABA问题是什么"></a>2 ABA问题是什么</h2><p>狸猫换太子</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200311212442057.png" alt="image-20200311212442057"></p><p>假设现在有两个线程，分别是T1 和 T2，然后T1执行某个操作的时间为10秒，T2执行某个时间的操作是2秒，最开始AB两个线程，分别从主内存中获取A值，但是因为B的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了狸猫换太子。</p><p>所以ABA问题就是，在进行获取主内存值的时候，该内存值在我们写入主内存的时候，已经被修改了N次，但是最终又改成原来的值了</p><h2 id="3-CAS导致ABA问题"><a href="#3-CAS导致ABA问题" class="headerlink" title="3 CAS导致ABA问题"></a>3 CAS导致ABA问题</h2><p>CAS算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p><p>比如说一个线程one从内存位置V中取出A，这时候另外一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功</p><p><code>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的</code></p><h2 id="4-ABA问题"><a href="#4-ABA问题" class="headerlink" title="4 ABA问题"></a>4 ABA问题</h2><p>CAS只管开头和结尾，也就是头和尾是一样，那就修改成功，中间的这个过程，可能会被人修改过</p><h2 id="5-原子引用"><a href="#5-原子引用" class="headerlink" title="5 原子引用"></a>5 原子引用</h2><p>原子引用其实和原子包装类是差不多的概念，就是将一个java类，用原子引用类进行包装起来，那么这个类就具备了原子性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 原子引用</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    String userName;    <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String userName, <span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userName = userName;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userName;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserName</span><span class="hljs-params">(String userName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.userName = userName;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +                <span class="hljs-string">&quot;userName=&#x27;&quot;</span> + userName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        User z3 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;z3&quot;</span>, <span class="hljs-number">22</span>);        User l4 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;l4&quot;</span>, <span class="hljs-number">25</span>);        <span class="hljs-comment">// 创建原子引用包装类</span>        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();        <span class="hljs-comment">// 现在主物理内存的共享变量，为z3</span>        atomicReference.set(z3);        <span class="hljs-comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span>        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());        <span class="hljs-comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span>        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());    &#125;&#125;</code></pre></div><h3 id="5-1-基于原子引用的ABA问题"><a href="#5-1-基于原子引用的ABA问题" class="headerlink" title="5.1 基于原子引用的ABA问题"></a>5.1 基于原子引用的ABA问题</h3><p>我们首先创建了两个线程，然后T1线程，执行一次ABA的操作，T2线程在一秒后修改主内存的值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ABA问题的解决，AtomicStampedReference</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABADemo</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 普通的原子引用包装类</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre></div><p>我们发现，它能够成功的修改，这就是ABA问题</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312154752973.png" alt="image-20200312154752973"></p><h2 id="6-解决ABA问题"><a href="#6-解决ABA问题" class="headerlink" title="6 解决ABA问题"></a>6 解决ABA问题</h2><p>新增一种机制，也就是修改版本号，类似于时间戳的概念</p><p>T1：  100 1                      2019 2</p><p>T2：  100 1     101 2       100  3</p><p>如果T1修改的时候，版本号为2，落后于现在的版本号3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路</p><h2 id="7-AtomicStampedReference"><a href="#7-AtomicStampedReference" class="headerlink" title="7 AtomicStampedReference"></a>7 AtomicStampedReference</h2><p>时间戳原子引用，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及期望版本号和当前版本号</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * ABA问题的解决，AtomicStampedReference</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABADemo</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 普通的原子引用包装类</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);    <span class="hljs-comment">// 传递两个值，一个是初始值，一个是初始版本号</span>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的产生==========&quot;</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的解决==========&quot;</span>);        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 获取版本号</span>            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);            <span class="hljs-comment">// 暂停t3一秒钟</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span>            atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());            atomicStampedReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());        &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 获取版本号</span>            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);            <span class="hljs-comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span>            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>, stamp, stamp+<span class="hljs-number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 修改成功否：&quot;</span> + result + <span class="hljs-string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());        &#125;, <span class="hljs-string">&quot;t4&quot;</span>).start();    &#125;&#125;</code></pre></div><p>运行结果为：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312200434776.png" alt="image-20200312200434776"></p><p>我们能够发现，线程t3，在进行ABA操作后，版本号变更成了3，而线程t4在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样</p><h2 id="8-LongAdder（CAS机制优化）"><a href="#8-LongAdder（CAS机制优化）" class="headerlink" title="8 LongAdder（CAS机制优化）"></a>8 LongAdder（CAS机制优化）</h2><p>LongAdder是java8为我们提供的新的类，跟AtomicLong有相同的效果。是对CAS机制的优化</p><div class="code-wrapper"><pre><code class="hljs axapta">LongAdder：<span class="hljs-comment">//变量声明</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LongAdder <span class="hljs-keyword">count</span> = <span class="hljs-keyword">new</span> LongAdder();<span class="hljs-comment">//变量操作</span><span class="hljs-keyword">count</span>.increment();<span class="hljs-comment">//变量取值</span><span class="hljs-keyword">count</span></code></pre></div><h3 id="为什么有了AtomicLong还要新增一个LongAdder呢"><a href="#为什么有了AtomicLong还要新增一个LongAdder呢" class="headerlink" title="为什么有了AtomicLong还要新增一个LongAdder呢"></a>为什么有了AtomicLong还要新增一个LongAdder呢</h3><p>原因是：CAS底层实现是在一个死循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功率很高，否则失败率很高。在失败的时候，这些重复的原子性操作会耗费性能。（不停的<strong>自旋</strong>，进入一个无限重复的循环中）</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429085540554.png" alt="image-20200429085540554"></p><p><strong>核心思想：将热点数据分离。</strong></p><p>比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。这相当于将AtomicLong的单点的更新压力分担到各个节点上。在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。而在高并发的时候通过分散提高了性能。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;    add(<span class="hljs-number">1L</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;    Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||            (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||            !(uncontended = a.cas(v = a.value, v + x)))            longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);    &#125;&#125;</code></pre></div><p>但是这个CAS有没有问题呢？肯定是有的。比如说大量的线程同时并发修改一个AtomicInteger，可能有<strong>很多线程会不停的自旋</strong>，进入一个无限重复的循环中。</p><p>这些线程不停地获取值，然后发起CAS操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起CAS操作又失败了，再次进入下一个循环。</p><p>在大量线程高并发更新AtomicInteger的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。</p><p>于是，当当当当，Java 8推出了一个新的类，<strong>LongAdder</strong>，他就是尝试使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能！</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429085141487.png" alt="image-20200429085141487"></p><p>在LongAdder的底层实现中，首先有一个base值，刚开始多线程来不停的累加数值，都是对base进行累加的，比如刚开始累加成了base = 5。</p><p>接着如果发现并发更新的线程数量过多，在发生竞争的情况下，会有一个Cell数组用于将不同线程的操作离散到不同的节点上去 ==(会根据需要扩容，最大为CPU核）==就会开始施行<strong>分段CAS的机制</strong>，也就是内部会搞一个Cell数组，每个数组是一个数值分段。</p><p>这时，让大量的线程分别去对不同Cell内部的value值进行CAS累加操作，这样就把CAS计算压力分散到了不同的Cell分段数值中了！</p><p>这样就可以大幅度的降低多线程并发更新同一个数值时出现的无限循环的问题，大幅度提升了多线程并发更新数值的性能和效率！</p><p>而且他内部实现了<strong>自动分段迁移的机制</strong>，也就是如果某个Cell的value执行CAS失败了，那么就会自动去找另外一个Cell分段内的value值进行CAS操作。</p><p>这样也解决了线程空旋转、自旋不停等待执行CAS操作的问题，让一个线程过来执行CAS时可以尽快的完成这个操作。</p><p>最后，如果你要从LongAdder中获取当前累加的总值，就会把base值和所有Cell分段数值加起来返回给你。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429085957778.png" alt="image-20200429085957778"></p><p>如上图所示，LongAdder则是内部维护多个Cell变量，每个Cell里面有一个初始值为0的long型变量，在同等并发量的情况下，争夺单个变量的线程会减少，这是变相的减少了争夺共享资源的并发量，另外多个线程在争夺同一个原子变量时候，</p><p>如果失败并不是自旋CAS重试，而是尝试获取其他原子变量的锁，最后当获取当前值时候是把所有变量的值累加后再加上base的值返回的。</p><p>LongAdder维护了要给延迟初始化的原子性更新数组和一个基值变量base数组的大小保持是2的N次方大小，数组表的下标使用每个线程的hashcode值的掩码表示，数组里面的变量实体是Cell类型。</p><p>Cell 类型是Atomic的一个改进，用来减少缓存的争用，对于大多数原子操作字节填充是浪费的，因为原子操作都是无规律的分散在内存中进行的，多个原子性操作彼此之间是没有接触的，但是原子性数组元素彼此相邻存放将能经常共享缓存行，也就是<strong>伪共享</strong>。所以这在性能上是一个提升。（补充：可以看到Cell类用Contended注解修饰，这里主要是解决false sharing(伪共享的问题)，不过个人认为伪共享翻译的不是很好，或者应该是错误的共享，比如两个volatile变量被分配到了同一个缓存行，但是这两个的更新在高并发下会竞争，比如线程A去更新变量a，线程B去更新变量b，但是这两个变量被分配到了同一个缓存行，因此会造成每个线程都去争抢缓存行的所有权，例如A获取了所有权然后执行更新这时由于volatile的语义会造成其刷新到主存，但是由于变量b也被缓存到同一个缓存行，因此就会造成cache miss，这样就会造成极大的性能损失）<br><strong>LongAdder的add操作图</strong></p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429090249633.png" alt="image-20200429090249633"></p><p>可以看到，只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。<br>如果Cell[]数组未初始化，会调用父类的longAccumelate去初始化Cell[]，如果Cell[]已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对Cell[]扩容了。<br><strong>另外由于Cells占用内存是相对比较大的，所以一开始并不创建，而是在需要时候再创建，也就是惰性加载，当一开始没有空间时候，所有的更新都是操作base变量。</strong></p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429090556928.png" alt="image-20200429090556928"></p><p>如上图代码：<br>例如32、64位操作系统的缓存行大小不一样，因此JAVA8中就增加了一个注<code>@sun.misc.Contended</code>解用于解决这个问题,由JVM去插入这些变量，<a href="http://xn--openjdk-hc5k25at0ntqhnpa7548b.java.net/jeps/142">具体可以参考openjdk.java.net/jeps/142</a> ，但是通常来说对象是不规则的分配到内存中的，但是数组由于是连续的内存，因此可能会共享缓存行，因此这里加一个Contended注解以防cells数组发生伪共享的情况。</p><p>为了降低高并发下多线程对一个变量CAS争夺失败后大量线程会自旋而造成降低并发性能问题，LongAdder内部通过根据并发请求量来维护多个Cell元素(一个动态的Cell数组)来分担对单个变量进行争夺资源。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429090713078.png" alt="image-20200429090713078"></p><p>可以看到LongAdder继承自Striped64类，Striped64内部维护着三个变量，LongAdder的真实值其实就是base的值与Cell数组里面所有Cell元素值的累加，base是个基础值，默认是0，cellBusy用来实现自旋锁，当创建Cell元素或者扩容Cell数组时候用来进行线程间的同步。</p><p>在无竞争下直接更新base，类似AtomicLong高并发下，会将每个线程的操作hash到不同的cells数组中，从而将AtomicLong中更新一个value的行为优化之后，分散到多个value中<br>从而降低更新热点，而需要得到当前值的时候，直接 将所有cell中的value与base相加即可，但是跟AtomicLong(compare and change -&gt; xadd)的CAS不同，incrementAndGet操作及其变种可以返回更新后的值，而LongAdder返回的是void。</p><p>由于Cell相对来说比较占内存，因此这里采用懒加载的方式，在无竞争的情况下直接更新base域，在第一次发生竞争的时候(CAS失败)就会创建一个大小为2的cells数组，每次扩容都是加倍，只到达到CPU核数。同时我们知道扩容数组等行为需要只能有一个线程同时执行，因此需要一个锁，这里通过CAS更新cellsBusy来实现一个简单的spin lock。</p><p>数组访问索引是通过Thread里的threadLocalRandomProbe域取模实现的，这个域是ThreadLocalRandom更新的，cells的数组大小被限制为CPU的核数，因为即使有超过核数个线程去更新，但是每个线程也只会和一个CPU绑定，更新的时候顶多会有cpu核数个线程，因此我们只需要通过hash将不同线程的更新行为离散到不同的slot即可。<br>我们知道线程、线程池会被关闭或销毁，这个时候可能这个线程之前占用的slot就会变成没人用的，但我们也不能清除掉，因为一般web应用都是长时间运行的，线程通常也会动态创建、销毁，很可能一段时间后又会被其他线程占用，而对于短时间运行的，例如单元测试，清除掉有啥意义呢？</p><h1 id="第4章-Collection线程不安全的举例"><a href="#第4章-Collection线程不安全的举例" class="headerlink" title="第4章 Collection线程不安全的举例"></a>第4章 Collection线程不安全的举例</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>1、当我们执行下面语句的时候，底层进行了什么操作</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</code></pre></div><p>底层创建了一个空的数组，伴随着初始值为10</p><p>当执行add方法后，如果超过了10，那么会进行扩容，扩容的大小为原值的一半，也就是5个，使用下列方法扩容</p><div class="code-wrapper"><pre><code class="hljs java">Arrays.copyOf(elementData, netCapacity)</code></pre></div><h2 id="2-单线程环境下"><a href="#2-单线程环境下" class="headerlink" title="2 单线程环境下"></a>2 单线程环境下</h2><p>单线程环境的ArrayList是不会有问题的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list.add(<span class="hljs-string">&quot;a&quot;</span>);        list.add(<span class="hljs-string">&quot;b&quot;</span>);        list.add(<span class="hljs-string">&quot;c&quot;</span>);        <span class="hljs-keyword">for</span>(String element : list) &#123;            System.out.println(element);        &#125;    &#125;&#125;</code></pre></div><h2 id="3-多线程环境"><a href="#3-多线程环境" class="headerlink" title="3 多线程环境"></a>3 多线程环境</h2><p>为什么ArrayList是线程不安全的？因为在进行写操作的时候，方法上为了保证并发性，是没有添加synchronized修饰，所以并发写的时候，就会出现问题</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312202720715.png" alt="image-20200312202720715"></p><p>当我们同时启动30个线程去操作List的时候</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 集合类线程不安全举例</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));                System.out.println(list);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><p>这个时候出现了错误，也就是java.util.ConcurrentModificationException</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312205142763.png" alt="image-20200312205142763"></p><p>这个异常是 并发修改的异常</p><h2 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5 解决方案"></a>5 解决方案</h2><h3 id="5-1-方案一：Vector"><a href="#5-1-方案一：Vector" class="headerlink" title="5.1 方案一：Vector"></a>5.1 方案一：Vector</h3><p>第一种方法，就是不用ArrayList这种不安全的List实现类，而采用Vector，线程安全的</p><p>关于Vector如何实现线程安全的，而是在方法上加了锁，即synchronized</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312210401865.png" alt="image-20200312210401865"></p><p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，导致并发性基于下降</p><h3 id="5-2-方案二：Collections-synchronized"><a href="#5-2-方案二：Collections-synchronized" class="headerlink" title="5.2 方案二：Collections.synchronized()"></a>5.2 方案二：Collections.synchronized()</h3><div class="code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());</code></pre></div><p>采用Collections集合工具类，在ArrayList外面包装一层 同步 机制</p><h3 id="5-3-方案三：采用JUC里面的方法"><a href="#5-3-方案三：采用JUC里面的方法" class="headerlink" title="5.3 方案三：采用JUC里面的方法"></a>5.3 方案三：采用JUC里面的方法</h3><p>CopyOnWriteArrayList：写时复制，主要是一种读写分离的思想</p><p>写时复制，CopyOnWrite容器即写时复制的容器，往一个容器中添加元素的时候，不直接往当前容器Object[]添加，而是先将Object[]进行copy，复制出一个新的容器object[] newElements，然后新的容器Object[] newElements里添加原始，添加元素完后，在将原容器的引用指向新的容器 setArray(newElements)；这样做的好处是可以对copyOnWrite容器进行并发的读 ，而不需要加锁，因为当前容器不需要添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p><p>就是写的时候，把ArrayList扩容一个出来，然后把值填写上去，在通知其他的线程，ArrayList的引用指向扩容后的</p><p>查看底层add方法源码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        Object[] elements = getArray();        <span class="hljs-keyword">int</span> len = elements.length;        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);        newElements[len] = e;        setArray(newElements);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre></div><p>首先需要加锁</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;lock.lock();</code></pre></div><p>然后在末尾扩容一个单位</p><div class="code-wrapper"><pre><code class="hljs java">Object[] elements = getArray();<span class="hljs-keyword">int</span> len = elements.length;Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);</code></pre></div><p>然后在把扩容后的空间，填写上需要add的内容</p><div class="code-wrapper"><pre><code class="hljs java">newElements[len] = e;</code></pre></div><p>最后把内容set到Array中</p><h2 id="6-HashSet线程不安全"><a href="#6-HashSet线程不安全" class="headerlink" title="6 HashSet线程不安全"></a>6 HashSet线程不安全</h2><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>底层还是使用CopyOnWriteArrayList进行实例化</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312221602095.png" alt="image-20200312221602095"></p><h3 id="HashSet底层结构"><a href="#HashSet底层结构" class="headerlink" title="HashSet底层结构"></a>HashSet底层结构</h3><p>同理HashSet的底层结构就是HashMap</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312221735178.png" alt="image-20200312221735178"></p><p>但是为什么我调用 HashSet.add()的方法，只需要传递一个元素，而HashMap是需要传递key-value键值对？</p><p>首先我们查看hashSet的add方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>我们能发现但我们调用add的时候，存储一个值进入map中，只是作为key进行存储，而value存储的是一个Object类型的常量，也就是说HashSet只关心key，而不关心value</p><h2 id="7-HashMap线程不安全"><a href="#7-HashMap线程不安全" class="headerlink" title="7 HashMap线程不安全"></a>7 HashMap线程不安全</h2><p>同理HashMap在多线程环境下，也是不安全的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));            System.out.println(map);        &#125;, String.valueOf(i)).start();    &#125;&#125;</code></pre></div><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>1、使用Collections.synchronizedMap(new HashMap&lt;&gt;());</p><p>2、使用 ConcurrentHashMap</p><div class="code-wrapper"><pre><code class="hljs java">Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();</code></pre></div><h1 id="第5章-值传递和引用传递"><a href="#第5章-值传递和引用传递" class="headerlink" title="第5章 值传递和引用传递"></a>第5章 值传递和引用传递</h1><h2 id="1-举例"><a href="#1-举例" class="headerlink" title="1 举例"></a>1 举例</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 值传递和引用传递</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String personName;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String personName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.personName = personName;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferValueDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        age = <span class="hljs-number">30</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue2</span><span class="hljs-params">(Person person)</span> </span>&#123;        person.setPersonName(<span class="hljs-string">&quot;XXXX&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue3</span><span class="hljs-params">(String str)</span> </span>&#123;        str = <span class="hljs-string">&quot;XXX&quot;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        TransferValueDemo test = <span class="hljs-keyword">new</span> TransferValueDemo();        <span class="hljs-comment">// 定义基本数据类型</span>        <span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;        test.changeValue1(age);        System.out.println(<span class="hljs-string">&quot;age ----&quot;</span> + age);        <span class="hljs-comment">// 实例化person类</span>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;abc&quot;</span>);        test.changeValue2(person);        System.out.println(<span class="hljs-string">&quot;personName-----&quot;</span> + person.getPersonName());        <span class="hljs-comment">// String</span>        String str = <span class="hljs-string">&quot;abc&quot;</span>;        test.changeValue3(str);        System.out.println(<span class="hljs-string">&quot;string-----&quot;</span> + str);    &#125;&#125;</code></pre></div><p>最后输出结果</p><div class="code-wrapper"><pre><code class="hljs shell">age ----20personName-----XXXXstring-----abc</code></pre></div><h2 id="2-changeValue1的执行过程"><a href="#2-changeValue1的执行过程" class="headerlink" title="2 changeValue1的执行过程"></a>2 changeValue1的执行过程</h2><p>八种基本数据类型，在栈里面分配内存，属于值传递</p><p><code>栈管运行，堆管存储</code></p><p>当们执行 changeValue1的时候，因为int是基本数据类型，所以传递的是int = 20这个值，相当于传递的是一个副本，main方法里面的age并没有改变，因此输出的结果 age还是20，属于值传递</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200314185317851.png" alt="image-20200314185317851"></p><h2 id="3-changeValue2的执行过程"><a href="#3-changeValue2的执行过程" class="headerlink" title="3 changeValue2的执行过程"></a>3 changeValue2的执行过程</h2><p>因为Person是属于对象，传递的是内存地址，当执行changeValue2的时候，会改变内存中的Person的值，属于引用传递，两个指针都是指向同一个地址</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200314185528034.png" alt="image-20200314185528034"></p><h2 id="4-changeValue3的执行过程"><a href="#4-changeValue3的执行过程" class="headerlink" title="4 changeValue3的执行过程"></a>4 changeValue3的执行过程</h2><p>String不属于基本数据类型，但是为什么执行完成后，还是abc呢？</p><p>这是因为String的特殊性，当我们执行String str = “abc”的时候，它会把 <code>abc</code> 放入常量池中</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200314190021466.png" alt="image-20200314190021466"></p><p>当我们执行changeValue3的时候，会重新新建一个xxx，并没有销毁abc，然后指向xxx，然后最后我们输出的是main中的引用，还是指向的abc，因此最后输出结果还是abc</p><h1 id="第6章-Lock"><a href="#第6章-Lock" class="headerlink" title="第6章 Lock"></a>第6章 Lock</h1><h2 id="1-Java锁之公平锁和非公平锁"><a href="#1-Java锁之公平锁和非公平锁" class="headerlink" title="1 Java锁之公平锁和非公平锁"></a>1 Java锁之公平锁和非公平锁</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）</p><h3 id="1-2-如何创建"><a href="#1-2-如何创建" class="headerlink" title="1.2 如何创建"></a>1.2 如何创建</h3><p>并发包中ReentrantLock的创建可以指定析构函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span><span class="hljs-comment">*/</span>Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);</code></pre></div><h3 id="1-3-两者区别"><a href="#1-3-两者区别" class="headerlink" title="1.3 两者区别"></a>1.3 两者区别</h3><p><strong>公平锁</strong>：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后安装FIFO的规则从队列中取到自己</p><p><strong>非公平锁：</strong> 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p><h3 id="1-4-题外话"><a href="#1-4-题外话" class="headerlink" title="1.4 题外话"></a>1.4 题外话</h3><p>Java ReenttrantLock通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于吞吐量比公平锁大，<code>对于synchronized而言，也是一种非公平锁</code></p><h2 id="2-可重入锁和递归锁ReentrantLock"><a href="#2-可重入锁和递归锁ReentrantLock" class="headerlink" title="2 可重入锁和递归锁ReentrantLock"></a>2 可重入锁和递归锁ReentrantLock</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>可重入锁就是递归锁</p><p>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</p><p>也就是说：<code>线程可以进入任何一个它已经拥有的锁所同步的代码块</code></p><p>ReentrantLock / Synchronized 就是一个典型的可重入锁</p><h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><p>可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是同一把锁</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;method2();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;&#125;</code></pre></div><p>也就是说我们只需要进入method1后，那么它也能直接进入method2方法，因为他们所拥有的锁，是同一把。</p><h3 id="2-3-作用"><a href="#2-3-作用" class="headerlink" title="2.3 作用"></a>2.3 作用</h3><p>可重入锁的最大作用就是避免死锁</p><h3 id="2-4-可重入锁验证"><a href="#2-4-可重入锁验证" class="headerlink" title="2.4 可重入锁验证"></a>2.4 可重入锁验证</h3><h4 id="证明Synchronized"><a href="#证明Synchronized" class="headerlink" title="证明Synchronized"></a>证明Synchronized</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 可重入锁（也叫递归锁）</span><span class="hljs-comment"> * 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 也就是说：`线程可以进入任何一个它已经拥有的锁所同步的代码块`</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送短信</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSMS</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t invoked sendSMS()&quot;</span>);        <span class="hljs-comment">// 在同步方法中，调用另外一个同步方法</span>        sendEmail();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发邮件</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendEmail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        System.out.println(Thread.currentThread().getId() + <span class="hljs-string">&quot;\t invoked sendEmail()&quot;</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Phone phone = <span class="hljs-keyword">new</span> Phone();        <span class="hljs-comment">// 两个线程操作资源列</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre></div><p>在这里，我们编写了一个资源类phone，拥有两个加了synchronized的同步方法，分别是sendSMS 和 sendEmail，我们在sendSMS方法中，调用sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：</p><div class="code-wrapper"><pre><code class="hljs shell">t1 invoked sendSMS()t1 invoked sendEmail()t2 invoked sendSMS()t2 invoked sendEmail()</code></pre></div><p>这就说明当 t1 线程进入sendSMS的时候，拥有了一把锁，同时t2线程无法进入，直到t1线程拿着锁，执行了sendEmail 方法后，才释放锁，这样t2才能够进入</p><div class="code-wrapper"><pre><code class="hljs shell">t1 invoked sendSMS()      t1线程在外层方法获取锁的时候t1 invoked sendEmail()    t1在进入内层方法会自动获取锁t2 invoked sendSMS()      t2线程在外层方法获取锁的时候t2 invoked sendEmail()    t2在进入内层方法会自动获取锁</code></pre></div><h4 id="证明ReentrantLock"><a href="#证明ReentrantLock" class="headerlink" title="证明ReentrantLock"></a>证明ReentrantLock</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * set进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);            setLock();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLock</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t set Lock&quot;</span>);        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        getLock();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Phone phone = <span class="hljs-keyword">new</span> Phone();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 因为Phone实现了Runnable接口</span><span class="hljs-comment">         */</span>        Thread t3 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t3&quot;</span>);        Thread t4 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t4&quot;</span>);        t3.start();        t4.start();    &#125;&#125;</code></pre></div><p>现在我们使用ReentrantLock进行验证，首先资源类实现了Runnable接口，重写Run方法，里面调用get方法，get方法在进入的时候，就加了锁</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);        setLock();    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre></div><p>然后在方法里面，又调用另外一个加了锁的setLock方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLock</span><span class="hljs-params">()</span> </span>&#123;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t set Lock&quot;</span>);    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre></div><p>最后输出结果我们能发现，结果和加synchronized方法是一致的，都是在外层的方法获取锁之后，线程能够直接进入里层</p><div class="code-wrapper"><pre><code class="hljs shell">t3 get Lockt3 set Lockt4 get Lockt4 set Lock</code></pre></div><p><strong>当我们在getLock方法加两把锁会是什么情况呢？</strong>  (阿里面试)</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;    lock.lock();    lock.lock();    <span class="hljs-keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);        setLock();    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();        lock.unlock();    &#125;&#125;</code></pre></div><p>最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是同一把锁，也就是说用同一个钥匙都能够打开</p><p><strong>当我们在getLock方法加两把锁，但是只解一把锁会出现什么情况呢？</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;    lock.lock();    lock.lock();    <span class="hljs-keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);        setLock();    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();        lock.unlock();    &#125;&#125;</code></pre></div><p>得到结果</p><div class="code-wrapper"><pre><code class="hljs pgsql">t3 <span class="hljs-keyword">get</span> <span class="hljs-keyword">Lock</span>t3 <span class="hljs-keyword">set</span> <span class="hljs-keyword">Lock</span></code></pre></div><p>也就是说程序直接卡死，线程不能出来，也就说明我们申请几把锁，最后需要解除几把锁</p><p><strong>当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢？</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);        setLock();    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();        lock.unlock();    &#125;&#125;</code></pre></div><p>这个时候，运行程序会直接报错</p><div class="code-wrapper"><pre><code class="hljs shell">t3 get Lockt3 set Lockt4 get Lockt4 set LockException in thread &quot;t3&quot; Exception in thread &quot;t4&quot; java.lang.IllegalMonitorStateExceptionat java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)at java.lang.Thread.run(Thread.java:745)java.lang.IllegalMonitorStateExceptionat java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)at java.lang.Thread.run(Thread.java:745)</code></pre></div><h2 id="3-Java锁之自旋锁"><a href="#3-Java锁之自旋锁" class="headerlink" title="3 Java锁之自旋锁"></a>3 Java锁之自旋锁</h2><p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p><p>原来提到的比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200315154143781.png" alt="image-20200315154143781"></p><h3 id="3-1-优缺点"><a href="#3-1-优缺点" class="headerlink" title="3.1 优缺点"></a>3.1 优缺点</h3><p>优点：循环比较获取直到成功为止，没有类似于wait的阻塞</p><p>缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源</p><h3 id="3-2-手写自旋锁"><a href="#3-2-手写自旋锁" class="headerlink" title="3.2 手写自旋锁"></a>3.2 手写自旋锁</h3><p>通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 手写一个自旋锁</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 循环比较获取直到成功为止，没有类似于wait的阻塞</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLockDemo</span> </span>&#123;    <span class="hljs-comment">// 现在的泛型装的是Thread，原子引用线程</span>    AtomicReference&lt;Thread&gt;  atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myLock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 获取当前进来的线程</span>        Thread thread = Thread.currentThread();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in &quot;</span>);        <span class="hljs-comment">// 开始自旋，期望值是null，更新值是当前线程，如果是null，则更新为当前线程，否者自旋</span>        <span class="hljs-keyword">while</span>(!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>, thread)) &#123;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 解锁</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myUnLock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 获取当前进来的线程</span>        Thread thread = Thread.currentThread();        <span class="hljs-comment">// 自己用完了后，把atomicReference变成null</span>        atomicReference.compareAndSet(thread, <span class="hljs-keyword">null</span>);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t invoked myUnlock()&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpinLockDemo spinLockDemo = <span class="hljs-keyword">new</span> SpinLockDemo();        <span class="hljs-comment">// 启动t1线程，开始操作</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 开始占有锁</span>            spinLockDemo.myLock();            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-comment">// 开始释放锁</span>            spinLockDemo.myUnLock();        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-comment">// 让main线程暂停1秒，使得t1线程，先执行</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">// 1秒后，启动t2线程，开始占用这个锁</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-comment">// 开始占有锁</span>            spinLockDemo.myLock();            <span class="hljs-comment">// 开始释放锁</span>            spinLockDemo.myUnLock();        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre></div><p>最后输出结果</p><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">t1</span> <span class="hljs-variable">come</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span>.....一秒后.....<span class="hljs-variable">t2</span> <span class="hljs-variable">come</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span>.....五秒后.....<span class="hljs-variable">t1</span> <span class="hljs-variable">invoked</span> <span class="hljs-function"><span class="hljs-title">myUnlock</span>()</span><span class="hljs-variable">t2</span> <span class="hljs-variable">invoked</span> <span class="hljs-function"><span class="hljs-title">myUnlock</span>()</span></code></pre></div><p>首先输出的是 t1     come in </p><p>然后1秒后，t2线程启动，发现锁被t1占有，所有不断的执行 compareAndSet方法，来进行比较，直到t1释放锁后，也就是5秒后，t2成功获取到锁，然后释放</p><h2 id="4-独占锁（写锁）-共享锁（读锁）-互斥锁"><a href="#4-独占锁（写锁）-共享锁（读锁）-互斥锁" class="headerlink" title="4 独占锁（写锁） / 共享锁（读锁） / 互斥锁"></a>4 独占锁（写锁） / 共享锁（读锁） / 互斥锁</h2><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁</p><p>共享锁：指该锁可以被多个线程锁持有</p><p>对ReentrantReadWriteLock其读锁是共享，其写锁是独占</p><p>写的时候只能一个人写，但是读的时候，可以多个人同时读</p><h3 id="4-2-为什么会有写锁和读锁"><a href="#4-2-为什么会有写锁和读锁" class="headerlink" title="4.2 为什么会有写锁和读锁"></a>4.2 为什么会有写锁和读锁</h3><p>原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读</p><div class="code-wrapper"><pre><code class="hljs plain">多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</code></pre></div><p>读-读：能共存</p><p>读-写：不能共存</p><p>写-写：不能共存</p><h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><p>实现一个读写缓存的操作，假设开始没有加锁的时候，会出现什么情况</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 读写锁</span><span class="hljs-comment"> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span><span class="hljs-comment"> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">// private Lock lock = null;</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义写操作</span><span class="hljs-comment">     * 满足：原子 + 独占</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        map.put(key, value);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        Object value = map.get(key);        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();        <span class="hljs-comment">// 线程操作资源类，5个线程写</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-comment">// lambda表达式内部必须是final</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);            &#125;, String.valueOf(i)).start();        &#125;        <span class="hljs-comment">// 线程操作资源类， 5个线程读</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-comment">// lambda表达式内部必须是final</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><p>我们分别创建5个线程写入缓存</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 线程操作资源类，5个线程写</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;    <span class="hljs-comment">// lambda表达式内部必须是final</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);    &#125;, String.valueOf(i)).start();&#125;</code></pre></div><p>5个线程读取缓存，</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 线程操作资源类， 5个线程读</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;    <span class="hljs-comment">// lambda表达式内部必须是final</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);    &#125;, String.valueOf(i)).start();&#125;</code></pre></div><p>最后运行结果：</p><div class="code-wrapper"><pre><code class="hljs 1c"><span class="hljs-number">0</span> 正在写入：<span class="hljs-number">0</span><span class="hljs-number">4</span> 正在写入：<span class="hljs-number">4</span><span class="hljs-number">3</span> 正在写入：<span class="hljs-number">3</span><span class="hljs-number">1</span> 正在写入：<span class="hljs-number">1</span><span class="hljs-number">2</span> 正在写入：<span class="hljs-number">2</span><span class="hljs-number">0</span> 正在读取:<span class="hljs-number">1</span> 正在读取:<span class="hljs-number">2</span> 正在读取:<span class="hljs-number">3</span> 正在读取:<span class="hljs-number">4</span> 正在读取:<span class="hljs-number">2</span> 写入完成<span class="hljs-number">4</span> 写入完成<span class="hljs-number">4</span> 读取完成：<span class="hljs-literal">null</span><span class="hljs-number">0</span> 写入完成<span class="hljs-number">3</span> 读取完成：<span class="hljs-literal">null</span><span class="hljs-number">0</span> 读取完成：<span class="hljs-literal">null</span><span class="hljs-number">1</span> 写入完成<span class="hljs-number">3</span> 写入完成<span class="hljs-number">1</span> 读取完成：<span class="hljs-literal">null</span><span class="hljs-number">2</span> 读取完成：<span class="hljs-literal">null</span></code></pre></div><p>我们可以看到，在写入的时候，写操作都没其它线程打断了，这就造成了，还没写完，其它线程又开始写，这样就造成数据不一致</p><h3 id="4-4-解决方法"><a href="#4-4-解决方法" class="headerlink" title="4.4 解决方法"></a>4.4 解决方法</h3><p>上面的代码是没有加锁的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到读写锁来解决了</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 创建一个读写锁</span><span class="hljs-comment">* 它是一个读写融为一体的锁，在使用的时候，需要转换</span><span class="hljs-comment">*/</span><span class="hljs-keyword">private</span> ReentrantReadWriteLock rwLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();</code></pre></div><p>当我们在进行写操作的时候，就需要转换成写锁</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个写锁</span>rwLock.writeLock().lock();<span class="hljs-comment">// 写锁 释放</span>rwLock.writeLock().unlock();</code></pre></div><p>当们在进行读操作的时候，在转换成读锁</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个读锁</span>rwLock.readLock().lock();<span class="hljs-comment">// 读锁 释放</span>rwLock.readLock().unlock();</code></pre></div><p>这里的读锁和写锁的区别在于，写锁一次只能一个线程进入，执行写操作，而读锁是多个线程能够同时进入，进行读取的操作</p><p>完整代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 读写锁</span><span class="hljs-comment"> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span><span class="hljs-comment"> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 缓存中的东西，必须保持可见性，因此使用volatile修饰</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建一个读写锁</span><span class="hljs-comment">     * 它是一个读写融为一体的锁，在使用的时候，需要转换</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock rwLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义写操作</span><span class="hljs-comment">     * 满足：原子 + 独占</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        <span class="hljs-comment">// 创建一个写锁</span>        rwLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            map.put(key, value);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 写锁 释放</span>            rwLock.writeLock().unlock();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-comment">// 读锁</span>        rwLock.readLock().lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            Object value = map.get(key);            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 读锁释放</span>            rwLock.readLock().unlock();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 清空缓存</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;        map.clear();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();        <span class="hljs-comment">// 线程操作资源类，5个线程写</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-comment">// lambda表达式内部必须是final</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);            &#125;, String.valueOf(i)).start();        &#125;        <span class="hljs-comment">// 线程操作资源类， 5个线程读</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;            <span class="hljs-comment">// lambda表达式内部必须是final</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><p>运行结果：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> 正在写入：<span class="hljs-number">1</span><span class="hljs-attribute">1</span> 写入完成<span class="hljs-attribute">2</span> 正在写入：<span class="hljs-number">2</span><span class="hljs-attribute">2</span> 写入完成<span class="hljs-attribute">3</span> 正在写入：<span class="hljs-number">3</span><span class="hljs-attribute">3</span> 写入完成<span class="hljs-attribute">4</span> 正在写入：<span class="hljs-number">4</span><span class="hljs-attribute">4</span> 写入完成<span class="hljs-attribute">5</span> 正在写入：<span class="hljs-number">5</span><span class="hljs-attribute">5</span> 写入完成<span class="hljs-attribute">2</span> 正在读取:<span class="hljs-attribute">3</span> 正在读取:<span class="hljs-attribute">1</span> 正在读取:<span class="hljs-attribute">4</span> 正在读取:<span class="hljs-attribute">5</span> 正在读取:<span class="hljs-attribute">2</span> 读取完成：<span class="hljs-number">2</span><span class="hljs-attribute">1</span> 读取完成：<span class="hljs-number">1</span><span class="hljs-attribute">4</span> 读取完成：<span class="hljs-number">4</span><span class="hljs-attribute">3</span> 读取完成：<span class="hljs-number">3</span><span class="hljs-attribute">5</span> 读取完成：<span class="hljs-number">5</span></code></pre></div><p>从运行结果我们可以看出，写入操作是一个一个线程进行执行的，并且中间不会被打断，而读操作的时候，是同时5个线程进入，然后并发读取操作</p><h2 id="5-为什么Synchronized无法禁止指令重排，却能保证有序性"><a href="#5-为什么Synchronized无法禁止指令重排，却能保证有序性" class="headerlink" title="5 为什么Synchronized无法禁止指令重排，却能保证有序性"></a>5 为什么Synchronized无法禁止指令重排，却能保证有序性</h2><h3 id="5-1-前言"><a href="#5-1-前言" class="headerlink" title="5.1 前言"></a>5.1 前言</h3><p>首先我们要分析下这道题，这简单的一个问题，其实里面还是包含了很多信息的，要想回答好这个问题，面试者至少要知道一下概念：</p><ul><li>Java内存模型</li><li>并发编程有序性问题</li><li>指令重排</li><li>synchronized锁</li><li>可重入锁</li><li>排它锁</li><li>as-if-serial语义</li><li>单线程&amp;多线程</li></ul><h3 id="5-2-标准解答"><a href="#5-2-标准解答" class="headerlink" title="5.2 标准解答"></a>5.2 标准解答</h3><p>为了进一步提升计算机各方面能力，在硬件层面做了很多优化，如处理器优化和指令重排等，但是这些技术的引入就会导致有序性问题。</p><blockquote><p>先解释什么是有序性问题，也知道是什么原因导致的有序性问题</p></blockquote><p>我们也知道，最好的解决有序性问题的办法，就是禁止处理器优化和指令重排，就像volatile中使用内存屏障一样。</p><blockquote><p>表明你知道啥是指令重排，也知道他的实现原理</p></blockquote><p>但是，虽然很多硬件都会为了优化做一些重排，但是在Java中，不管怎么排序，都不能影响单线程程序的执行结果。这就是as-if-serial语义，所有硬件优化的前提都是必须遵守as-if-serial语义。</p><p>as-if-serial语义把<strong>单线程</strong>程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会 干扰他们，也无需担心内存可见性问题。</p><blockquote><p>重点！解释下什么是as-if-serial语义，因为这是这道题的第一个关键词，答上来就对了一半了</p></blockquote><p>再说下synchronized，他是Java提供的锁，可以通过他对Java中的对象加锁，并且他是一种排他的、可重入的锁。</p><p>所以，当某个线程执行到一段被synchronized修饰的代码之前，会先进行加锁，执行完之后再进行解锁。在加锁之后，解锁之前，其他线程是无法再次获得锁的，只有这条加锁线程可以重复获得该锁。</p><blockquote><p>介绍synchronized的原理，这是本题的第二个关键点，到这里基本就可以拿满分了。</p></blockquote><p>synchronized通过排他锁的方式就保证了同一时间内，被synchronized修饰的代码是单线程执行的。所以呢，这就满足了as-if-serial语义的一个关键前提，那就是<strong>单线程</strong>，因为有as-if-serial语义保证，单线程的有序性就天然存在了。</p><h1 id="第7章-计时器和信号量"><a href="#第7章-计时器和信号量" class="headerlink" title="第7章 计时器和信号量"></a>第7章 计时器和信号量</h1><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1 CountDownLatch"></a>1 CountDownLatch</h2><h3 id="1-1-概念-1"><a href="#1-1-概念-1" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p><p>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程就会被阻塞。其它线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会被阻塞），当计数器的值变成零时，因调用await方法被阻塞的线程会被唤醒，继续执行</p><h3 id="1-2-场景"><a href="#1-2-场景" class="headerlink" title="1.2 场景"></a>1.2 场景</h3><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p><h3 id="1-3-解决方案"><a href="#1-3-解决方案" class="headerlink" title="1.3 解决方案"></a>1.3 解决方案</h3><p>这个时候就用到了CountDownLatch，计数器了。我们一共创建6个线程，然后计数器的值也设置成6</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 计数器</span>CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);</code></pre></div><p>然后每次学生线程执行完，就让计数器的值减1</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 上完自习，离开教室&quot;</span>);        countDownLatch.countDown();    &#125;, String.valueOf(i)).start();&#125;</code></pre></div><p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是一道墙，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p><div class="code-wrapper"><pre><code class="hljs java">countDownLatch.await();System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 班长最后关门&quot;</span>);</code></pre></div><p>不加CountDownLatch的执行结果，我们发现main线程提前已经执行完成了</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span> 上完自习，离开教室<span class="hljs-number">0</span> 上完自习，离开教室<span class="hljs-selector-tag">main</span> 班长最后关门<span class="hljs-number">2</span> 上完自习，离开教室<span class="hljs-number">3</span> 上完自习，离开教室<span class="hljs-number">4</span> 上完自习，离开教室<span class="hljs-number">5</span> 上完自习，离开教室<span class="hljs-number">6</span> 上完自习，离开教室</code></pre></div><p>引入CountDownLatch后的执行结果，我们能够控制住main方法的执行，这样能够保证前提任务的执行</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">0</span> 上完自习，离开教室<span class="hljs-number">2</span> 上完自习，离开教室<span class="hljs-number">4</span> 上完自习，离开教室<span class="hljs-number">1</span> 上完自习，离开教室<span class="hljs-number">5</span> 上完自习，离开教室<span class="hljs-number">6</span> 上完自习，离开教室<span class="hljs-number">3</span> 上完自习，离开教室<span class="hljs-selector-tag">main</span> 班长最后关门</code></pre></div><h3 id="1-4-完整代码"><a href="#1-4-完整代码" class="headerlink" title="1.4 完整代码"></a>1.4 完整代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.moxi.interview.study.thread;<span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">// 计数器</span>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 上完自习，离开教室&quot;</span>);                countDownLatch.countDown();            &#125;, String.valueOf(i)).start();        &#125;        countDownLatch.await();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 班长最后关门&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2 CyclicBarrier"></a>2 CyclicBarrier</h2><h3 id="2-1-概念-1"><a href="#2-1-概念-1" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>和CountDownLatch相反，需要集齐七颗龙珠，召唤神龙。也就是做加法，开始是0，加到某个值的时候就执行</p><p>CyclicBarrier的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法</p><h3 id="2-2-案例"><a href="#2-2-案例" class="headerlink" title="2.2 案例"></a>2.2 案例</h3><p>集齐7个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span><span class="hljs-comment">*/</span>CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">7</span>, () -&gt; &#123;System.out.println(<span class="hljs-string">&quot;召唤神龙&quot;</span>);&#125;);</code></pre></div><p>然后同时编写七个线程，进行龙珠收集，但一个线程收集到了的时候，我们需要让他执行await方法，等待到7个线程全部执行完毕后，我们就执行原来定义好的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;    <span class="hljs-keyword">final</span> Integer tempInt = i;    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="hljs-string">&quot;颗龙珠&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span>            cyclicBarrier.await();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;            e.printStackTrace();        &#125;    &#125;, String.valueOf(i)).start();&#125;</code></pre></div><p>完整代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * CyclicBarrier循环屏障</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span><span class="hljs-comment">         */</span>        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">7</span>, () -&gt; &#123;            System.out.println(<span class="hljs-string">&quot;召唤神龙&quot;</span>);        &#125;);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;            <span class="hljs-keyword">final</span> Integer tempInt = i;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="hljs-string">&quot;颗龙珠&quot;</span>);                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span>                    cyclicBarrier.await();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;                    e.printStackTrace();                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><h2 id="3-Semaphore：信号量"><a href="#3-Semaphore：信号量" class="headerlink" title="3 Semaphore：信号量"></a>3 Semaphore：信号量</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p>信号量主要用于两个目的</p><ul><li>一个是用于共享资源的互斥使用</li><li>另一个用于并发线程数的控制</li></ul><h3 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2 代码"></a>3.2 代码</h3><p>我们模拟一个抢车位的场景，假设一共有6个车，3个停车位</p><p>那么我们首先需要定义信号量为3，也就是3个停车位</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span><span class="hljs-comment">*/</span>Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>, <span class="hljs-keyword">false</span>);</code></pre></div><p>然后我们模拟6辆车同时并发抢占停车位，但第一个车辆抢占到停车位后，信号量需要减1</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 代表一辆车，已经占用了该车位</span>semaphore.acquire(); <span class="hljs-comment">// 抢占</span></code></pre></div><p>同时车辆假设需要等待3秒后，释放信号量</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 每个车停3秒</span><span class="hljs-keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</code></pre></div><p>最后车辆离开，释放信号量</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 释放停车位</span>semaphore.release();</code></pre></div><h3 id="3-3-完整代码"><a href="#3-3-完整代码" class="headerlink" title="3.3 完整代码"></a>3.3 完整代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 信号量Demo</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-03-16-15:01</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span><span class="hljs-comment">         */</span>        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>, <span class="hljs-keyword">false</span>);        <span class="hljs-comment">// 模拟6部车</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 代表一辆车，已经占用了该车位</span>                    semaphore.acquire(); <span class="hljs-comment">// 抢占</span>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 抢到车位&quot;</span>);                    <span class="hljs-comment">// 每个车停3秒</span>                    <span class="hljs-keyword">try</span> &#123;                        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 离开车位&quot;</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">// 释放停车位</span>                    semaphore.release();                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><p>运行结果</p><div class="code-wrapper"><pre><code class="hljs plain">0 抢到车位2 抢到车位1 抢到车位2 离开车位1 离开车位3 抢到车位0 离开车位4 抢到车位5 抢到车位4 离开车位3 离开车位5 离开车位</code></pre></div><p>看运行结果能够发现，0 2 1 车辆首先抢占到了停车位，然后等待3秒后，离开，然后后面 3 4 5 又抢到了车位</p><h1 id="第8章阻塞队列"><a href="#第8章阻塞队列" class="headerlink" title="第8章阻塞队列"></a>第8章阻塞队列</h1><h2 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-队列"><a href="#1-1-队列" class="headerlink" title="1.1 队列"></a>1.1 队列</h3><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭</p><h3 id="1-2-阻塞队列"><a href="#1-2-阻塞队列" class="headerlink" title="1.2 阻塞队列"></a>1.2 阻塞队列</h3><p>BlockingQueue   阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200316152120272.png" alt="image-20200316152120272"></p><p>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素</p><ul><li><p><code>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</code></p><ul><li>当蛋糕店的柜子空的时候，无法从柜子里面获取蛋糕</li></ul></li><li><p><code>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</code></p><ul><li>当蛋糕店的柜子满的时候，无法继续向柜子里面添加蛋糕了</li></ul></li></ul><p>也就是说 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素</p><p>同理，试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增</p><h2 id="2-为什么要用？"><a href="#2-为什么要用？" class="headerlink" title="2 为什么要用？"></a>2 为什么要用？</h2><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞</p><p>在多线程领域：所谓的阻塞，在某些清空下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒</p><h3 id="为什么需要BlockingQueue"><a href="#为什么需要BlockingQueue" class="headerlink" title="为什么需要BlockingQueue"></a>为什么需要BlockingQueue</h3><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都帮你一手包办了</p><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p><h2 id="3-架构"><a href="#3-架构" class="headerlink" title="3 架构"></a>3 架构</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 你用过List集合类</span><span class="hljs-comment">// ArrayList集合类熟悉么？</span><span class="hljs-comment">// 还用过 CopyOnWriteList  和 BlockingQueue</span></code></pre></div><p>BlockingQueue阻塞队列是属于一个接口，底下有七个实现类</p><ul><li>ArrayBlockQueue：由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列<ul><li>有界，但是界限非常大，相当于无界，可以当成无界</li></ul></li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li><li>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列<ul><li>生产一个，消费一个，不存储元素，不消费不生产</li></ul></li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li></ul><p>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p><h2 id="4-BlockingQueue核心方法"><a href="#4-BlockingQueue核心方法" class="headerlink" title="4 BlockingQueue核心方法"></a>4 BlockingQueue核心方法</h2><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200316154442756.png" alt="image-20200316154442756"></p><table><thead><tr><th>抛出异常</th><th>当阻塞队列满时：在往队列中add插入元素会抛出 IIIegalStateException：Queue full                      当阻塞队列空时：再往队列中remove移除元素，会抛出NoSuchException</th></tr></thead><tbody><tr><td>特殊性</td><td>插入方法，成功true，失败false       移除方法：成功返回出队列元素，队列没有就返回空</td></tr><tr><td>一直阻塞</td><td>当阻塞队列满时，生产者继续往队列里put元素，队列会一直阻塞生产线程直到put数据or响应中断退出， 当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用。</td></tr><tr><td>超时退出</td><td>当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table><h3 id="4-1-抛出异常组"><a href="#4-1-抛出异常组" class="headerlink" title="4.1 抛出异常组"></a>4.1 抛出异常组</h3><p>但执行add方法，向已经满的ArrayBlockingQueue中添加元素时候，会抛出异常</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞队列，需要填入默认值</span>BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);System.out.println(blockingQueue.add(<span class="hljs-string">&quot;a&quot;</span>));System.out.println(blockingQueue.add(<span class="hljs-string">&quot;b&quot;</span>));System.out.println(blockingQueue.add(<span class="hljs-string">&quot;c&quot;</span>));System.out.println(blockingQueue.add(<span class="hljs-string">&quot;XXX&quot;</span>));</code></pre></div><p>运行后：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">true</span><span class="hljs-keyword">true</span><span class="hljs-keyword">true</span>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalStateException: Queue fullat java.util.AbstractQueue.add(AbstractQueue.java:<span class="hljs-number">98</span>)at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:<span class="hljs-number">312</span>)at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:<span class="hljs-number">25</span>)</code></pre></div><p>同时如果我们多取出元素的时候，也会抛出异常，我们假设只存储了3个值，但是取的时候，取了四次</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞队列，需要填入默认值</span>BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);System.out.println(blockingQueue.add(<span class="hljs-string">&quot;a&quot;</span>));System.out.println(blockingQueue.add(<span class="hljs-string">&quot;b&quot;</span>));System.out.println(blockingQueue.add(<span class="hljs-string">&quot;c&quot;</span>));System.out.println(blockingQueue.remove());System.out.println(blockingQueue.remove());System.out.println(blockingQueue.remove());System.out.println(blockingQueue.remove());</code></pre></div><p>那么出现异常</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">true</span><span class="hljs-keyword">true</span><span class="hljs-keyword">true</span>abcException in thread <span class="hljs-string">&quot;main&quot;</span> java.util.NoSuchElementExceptionat java.util.AbstractQueue.remove(AbstractQueue.java:<span class="hljs-number">117</span>)at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:<span class="hljs-number">30</span>)</code></pre></div><h3 id="4-2-布尔类型组"><a href="#4-2-布尔类型组" class="headerlink" title="4.2 布尔类型组"></a>4.2 布尔类型组</h3><p>我们使用 offer的方法，添加元素时候，如果阻塞队列满了后，会返回false，否者返回true</p><p>同时在取的时候，如果队列已空，那么会返回null</p><div class="code-wrapper"><pre><code class="hljs java">BlockingQueue blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue(<span class="hljs-number">3</span>);System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;a&quot;</span>));System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;b&quot;</span>));System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;c&quot;</span>));System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;d&quot;</span>));System.out.println(blockingQueue.poll());System.out.println(blockingQueue.poll());System.out.println(blockingQueue.poll());System.out.println(blockingQueue.poll());</code></pre></div><p>运行结果</p><div class="code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-literal">true</span><span class="hljs-literal">true</span><span class="hljs-literal">true</span><span class="hljs-literal">false</span><span class="hljs-keyword">a</span>bc<span class="hljs-literal">null</span></code></pre></div><h3 id="4-3-阻塞队列组"><a href="#4-3-阻塞队列组" class="headerlink" title="4.3 阻塞队列组"></a>4.3 阻塞队列组</h3><p>我们使用 put的方法，添加元素时候，如果阻塞队列满了后，添加消息的线程，会一直阻塞，直到队列元素减少，会被清空，才会唤醒</p><p>一般在消息中间件，比如RabbitMQ中会使用到，因为需要保证消息百分百不丢失，因此只有让它阻塞</p><div class="code-wrapper"><pre><code class="hljs abnf">BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>)<span class="hljs-comment">;</span>blockingQueue.put(<span class="hljs-string">&quot;a&quot;</span>)<span class="hljs-comment">;</span>blockingQueue.put(<span class="hljs-string">&quot;b&quot;</span>)<span class="hljs-comment">;</span>blockingQueue.put(<span class="hljs-string">&quot;c&quot;</span>)<span class="hljs-comment">;</span>System.out.println(<span class="hljs-string">&quot;================&quot;</span>)<span class="hljs-comment">;</span>blockingQueue.take()<span class="hljs-comment">;</span>blockingQueue.take()<span class="hljs-comment">;</span>blockingQueue.take()<span class="hljs-comment">;</span>blockingQueue.take()<span class="hljs-comment">;</span></code></pre></div><p>同时使用take取消息的时候，如果内容不存在的时候，也会被阻塞</p><h3 id="4-4-不见不散组"><a href="#4-4-不见不散组" class="headerlink" title="4.4 不见不散组"></a>4.4 不见不散组</h3><p>offer( )  ， poll 加时间</p><p>使用offer插入的时候，需要指定时间，如果2秒还没有插入，那么就放弃插入</p><div class="code-wrapper"><pre><code class="hljs java">BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));</code></pre></div><p>同时取的时候也进行判断</p><div class="code-wrapper"><pre><code class="hljs java">System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));</code></pre></div><p>如果2秒内取不出来，那么就返回null</p><h2 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5 SynchronousQueue"></a>5 SynchronousQueue</h2><p>SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储的BlockingQueue，每一个put操作必须等待一个take操作，否者不能继续添加元素</p><p>下面我们测试SynchronousQueue添加元素的过程</p><p>首先我们创建了两个线程，一个线程用于生产，一个线程用于消费</p><p>生产的线程分别put了 A、B、C这三个字段</p><div class="code-wrapper"><pre><code class="hljs java">BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;();<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">try</span> &#123;               System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put A &quot;</span>);        blockingQueue.put(<span class="hljs-string">&quot;A&quot;</span>);               System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put B &quot;</span>);        blockingQueue.put(<span class="hljs-string">&quot;B&quot;</span>);                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put C &quot;</span>);        blockingQueue.put(<span class="hljs-string">&quot;C&quot;</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();</code></pre></div><p>消费线程使用take，消费阻塞队列中的内容，并且每次消费前，都等待5秒</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        blockingQueue.take();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take A &quot;</span>);        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        blockingQueue.take();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take B &quot;</span>);        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        blockingQueue.take();        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take C &quot;</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();</code></pre></div><p>最后结果输出为：</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-built_in">t1</span> put A <span class="hljs-built_in">t2</span> take A <span class="hljs-number">5</span>秒后...<span class="hljs-built_in">t1</span> put <span class="hljs-keyword">B </span><span class="hljs-built_in">t2</span> take <span class="hljs-keyword">B </span><span class="hljs-number">5</span>秒后...<span class="hljs-built_in">t1</span> put C <span class="hljs-built_in">t2</span> take C</code></pre></div><p>我们从最后的运行结果可以看出，每次t1线程向队列中添加阻塞队列添加元素后，t1输入线程就会等待 t2消费线程，t2消费后，t2处于挂起状态，等待t1在存入，从而周而复始，形成 一存一取的状态</p><h2 id="6-阻塞队列的用处"><a href="#6-阻塞队列的用处" class="headerlink" title="6 阻塞队列的用处"></a>6 阻塞队列的用处</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p>一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮</p><p>关于多线程的操作，我们需要记住下面几句</p><ul><li>线程 操作 资源类</li><li>判断 干活 通知</li><li>防止虚假唤醒机制</li></ul><p>我们下面实现一个简单的生产者消费者模式，首先有资源类ShareData</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareData</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">// 同步代码块，加锁</span>        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 判断</span>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 等待不能生产</span>                condition.await();            &#125;            <span class="hljs-comment">// 干活</span>            number++;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);            <span class="hljs-comment">// 通知 唤醒</span>            condition.signalAll();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">// 同步代码块，加锁</span>        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 判断</span>            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 等待不能消费</span>                condition.await();            &#125;            <span class="hljs-comment">// 干活</span>            number--;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);            <span class="hljs-comment">// 通知 唤醒</span>            condition.signalAll();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;</code></pre></div><p>里面有一个number变量，同时提供了increment 和 decrement的方法，分别让number 加1和减1</p><p>但是我们在进行判断的时候，为了防止出现虚假唤醒机制，不能使用if来进行判断，而应该使用while</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 判断</span><span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 等待不能生产</span>    condition.await();&#125;</code></pre></div><p>不能使用 if判断</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 判断</span><span class="hljs-keyword">if</span>(number != <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 等待不能生产</span>    condition.await();&#125;</code></pre></div><p>完整代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 生产者消费者 传统版</span><span class="hljs-comment"> * 题目：一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 线程 操作 资源类</span><span class="hljs-comment"> * 判断 干活 通知</span><span class="hljs-comment"> * 防止虚假唤醒机制</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareData</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">// 同步代码块，加锁</span>        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 判断</span>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 等待不能生产</span>                condition.await();            &#125;            <span class="hljs-comment">// 干活</span>            number++;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);            <span class="hljs-comment">// 通知 唤醒</span>            condition.signalAll();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">// 同步代码块，加锁</span>        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 判断</span>            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 等待不能消费</span>                condition.await();            &#125;            <span class="hljs-comment">// 干活</span>            number--;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);            <span class="hljs-comment">// 通知 唤醒</span>            condition.signalAll();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProdConsumerTraditionDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 高内聚，低耦合    内聚指的是，一个空调，自身带有调节温度高低的方法</span>        ShareData shareData = <span class="hljs-keyword">new</span> ShareData();        <span class="hljs-comment">// t1线程，生产</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;                <span class="hljs-keyword">try</span> &#123;                    shareData.increment();                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-comment">// t2线程，消费</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;                <span class="hljs-keyword">try</span> &#123;                    shareData.decrement();                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre></div><p>最后运行成功后，我们一个进行生产，一个进行消费</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">t1</span> <span class="hljs-number">1</span><span class="hljs-attribute">t2</span> <span class="hljs-number">0</span><span class="hljs-attribute">t1</span> <span class="hljs-number">1</span><span class="hljs-attribute">t2</span> <span class="hljs-number">0</span><span class="hljs-attribute">t1</span> <span class="hljs-number">1</span><span class="hljs-attribute">t2</span> <span class="hljs-number">0</span><span class="hljs-attribute">t1</span> <span class="hljs-number">1</span><span class="hljs-attribute">t2</span> <span class="hljs-number">0</span><span class="hljs-attribute">t1</span> <span class="hljs-number">1</span><span class="hljs-attribute">t2</span> <span class="hljs-number">0</span></code></pre></div><h2 id="7-生成者和消费者3-0"><a href="#7-生成者和消费者3-0" class="headerlink" title="7 生成者和消费者3.0"></a>7 生成者和消费者3.0</h2><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，则这会给我们的程序带来不小的时间复杂度</p><p>现在我们使用新版的阻塞队列版生产者和消费者，使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 生产者消费者  阻塞队列版</span><span class="hljs-comment"> * 使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> </span>&#123;    <span class="hljs-comment">// 默认开启，进行生产消费</span>    <span class="hljs-comment">// 这里用到了volatile是为了保持数据的可见性，也就是当TLAG修改时，要马上通知其它线程进行修改</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> FLAG = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 使用原子包装类，而不用number++</span>    <span class="hljs-keyword">private</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();    <span class="hljs-comment">// 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue</span>    BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 而应该采用依赖注入里面的，构造注入方法传入</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyResource</span><span class="hljs-params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;        <span class="hljs-keyword">this</span>.blockingQueue = blockingQueue;        <span class="hljs-comment">// 查询出传入的class是什么</span>        System.out.println(blockingQueue.getClass().getName());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 生产</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myProd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        String data = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">boolean</span> retValue;        <span class="hljs-comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span>        <span class="hljs-comment">// 当FLAG为true的时候，开始生产</span>        <span class="hljs-keyword">while</span>(FLAG) &#123;            data = atomicInteger.incrementAndGet() + <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-comment">// 2秒存入1个data</span>            retValue = blockingQueue.offer(data, <span class="hljs-number">2L</span>, TimeUnit.SECONDS);            <span class="hljs-keyword">if</span>(retValue) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 插入队列:&quot;</span> + data  + <span class="hljs-string">&quot;成功&quot;</span> );            &#125; <span class="hljs-keyword">else</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 插入队列:&quot;</span> + data  + <span class="hljs-string">&quot;失败&quot;</span> );            &#125;            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 停止生产，表示FLAG=false，生产介绍&quot;</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 消费</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myConsumer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        String retValue;        <span class="hljs-comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span>        <span class="hljs-comment">// 当FLAG为true的时候，开始生产</span>        <span class="hljs-keyword">while</span>(FLAG) &#123;            <span class="hljs-comment">// 2秒存入1个data</span>            retValue = blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS);            <span class="hljs-keyword">if</span>(retValue != <span class="hljs-keyword">null</span> &amp;&amp; retValue != <span class="hljs-string">&quot;&quot;</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费队列:&quot;</span> + retValue  + <span class="hljs-string">&quot;成功&quot;</span> );            &#125; <span class="hljs-keyword">else</span> &#123;                FLAG = <span class="hljs-keyword">false</span>;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费失败，队列中已为空，退出&quot;</span> );                <span class="hljs-comment">// 退出消费队列</span>                <span class="hljs-keyword">return</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 停止生产的判断</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.FLAG = <span class="hljs-keyword">false</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProdConsumerBlockingQueueDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 传入具体的实现类， ArrayBlockingQueue</span>        MyResource myResource = <span class="hljs-keyword">new</span> MyResource(<span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="hljs-number">10</span>));        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 生产线程启动&quot;</span>);            System.out.println(<span class="hljs-string">&quot;&quot;</span>);            System.out.println(<span class="hljs-string">&quot;&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                myResource.myProd();                System.out.println(<span class="hljs-string">&quot;&quot;</span>);                System.out.println(<span class="hljs-string">&quot;&quot;</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;prod&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费线程启动&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                myResource.myConsumer();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="hljs-string">&quot;consumer&quot;</span>).start();        <span class="hljs-comment">// 5秒后，停止生产和消费</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">&quot;&quot;</span>);        System.out.println(<span class="hljs-string">&quot;&quot;</span>);        System.out.println(<span class="hljs-string">&quot;5秒中后，生产和消费线程停止，线程结束&quot;</span>);        myResource.stop();    &#125;&#125;</code></pre></div><p>最后运行结果</p><div class="code-wrapper"><pre><code class="hljs java">java.util.concurrent.ArrayBlockingQueueprod 生产线程启动consumer 消费线程启动prod 插入队列:<span class="hljs-number">1</span>成功consumer 消费队列:<span class="hljs-number">1</span>成功prod 插入队列:<span class="hljs-number">2</span>成功consumer 消费队列:<span class="hljs-number">2</span>成功prod 插入队列:<span class="hljs-number">3</span>成功consumer 消费队列:<span class="hljs-number">3</span>成功prod 插入队列:<span class="hljs-number">4</span>成功consumer 消费队列:<span class="hljs-number">4</span>成功prod 插入队列:<span class="hljs-number">5</span>成功consumer 消费队列:<span class="hljs-number">5</span>成功<span class="hljs-number">5</span>秒中后，生产和消费线程停止，线程结束prod 停止生产，表示FLAG=<span class="hljs-keyword">false</span>，生产介绍</code></pre></div><h1 id="第9章-Synchronized和Lock的区别"><a href="#第9章-Synchronized和Lock的区别" class="headerlink" title="第9章 Synchronized和Lock的区别"></a>第9章 Synchronized和Lock的区别</h1><h2 id="1-前言-1"><a href="#1-前言-1" class="headerlink" title="1 前言"></a>1 前言</h2><p>早期的时候我们对线程的主要操作为：</p><ul><li>synchronized wait  notify</li></ul><p>然后后面出现了替代方案</p><ul><li>lock await  signal</li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317101210376.png" alt="image-20200317101210376"></p><h2 id="2-问题"><a href="#2-问题" class="headerlink" title="2 问题"></a>2 问题</h2><h3 id="synchronized-和-lock-有什么区别？用新的lock有什么好处？举例说明"><a href="#synchronized-和-lock-有什么区别？用新的lock有什么好处？举例说明" class="headerlink" title="synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明"></a>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</h3><ul><li>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</li></ul><p>1）synchronized属于JVM层面，属于java的关键字</p><ul><li>monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象 只能在同步块或者方法中才能调用 wait/ notify等方法）</li><li>Lock是具体类（java.util.concurrent.locks.Lock）是api层面的锁</li></ul><p>2）使用方法：</p><ul><li><p>synchronized：不需要用户去手动释放锁，当synchronized代码执行后，系统会自动让线程释放对锁的占用</p></li><li><p>ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要lock() 和 unlock() 配置try catch语句来完成</p></li></ul><p>3）等待是否中断</p><ul><li>synchronized：不可中断，除非抛出异常或者正常运行完成</li><li>ReentrantLock：可中断，可以设置超时方法<ul><li>设置超时方法，trylock(long timeout, TimeUnit unit)</li><li>lockInterrupible() 放代码块中，调用interrupt() 方法可以中断</li></ul></li></ul><p>4）加锁是否公平</p><ul><li>synchronized：非公平锁</li><li>ReentrantLock：默认非公平锁，构造函数可以传递boolean值，true为公平锁，false为非公平锁</li></ul><p>5）锁绑定多个条件Condition</p><ul><li>synchronized：没有，要么随机，要么全部唤醒</li><li>ReentrantLock：用来实现分组唤醒需要唤醒的线程，可以精确唤醒，而不是像synchronized那样，要么随机，要么全部唤醒</li></ul><h2 id="3-举例"><a href="#3-举例" class="headerlink" title="3 举例"></a>3 举例</h2><p>针对刚刚提到的区别的第5条，我们有下面这样的一个场景</p><div class="code-wrapper"><pre><code class="hljs java">题目：多线程之间按顺序调用，实现 A-&gt; B -&gt; C 三个线程启动，要求如下：AA打印<span class="hljs-number">5</span>次，BB打印<span class="hljs-number">10</span>次，CC打印<span class="hljs-number">15</span>次紧接着AA打印<span class="hljs-number">5</span>次，BB打印<span class="hljs-number">10</span>次，CC打印<span class="hljs-number">15</span>次..来<span class="hljs-number">10</span>轮</code></pre></div><p>我们会发现，这样的场景在使用synchronized来完成的话，会非常的困难，但是使用lock就非常方便了</p><p>也就是我们需要实现一个链式唤醒的操作</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317105121435.png" alt="image-20200317105121435"></p><p>当A线程执行完后，B线程才能执行，然后B线程执行完成后，C线程才执行</p><p>首先我们需要创建一个重入锁</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个重入锁</span><span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();</code></pre></div><p>然后定义三个条件，也可以称为锁的钥匙，通过它就可以获取到锁，进入到方法里面</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这三个相当于备用钥匙</span><span class="hljs-keyword">private</span> Condition condition1 = lock.newCondition();<span class="hljs-keyword">private</span> Condition condition2 = lock.newCondition();<span class="hljs-keyword">private</span> Condition condition3 = lock.newCondition();</code></pre></div><p>然后开始记住锁的三部曲： 判断   干活  唤醒</p><p>这里的判断，为了避免虚假唤醒，一定要采用  while</p><p>干活就是把需要的内容，打印出来</p><p>唤醒的话，就是修改资源类的值，然后精准唤醒线程进行干活：这里A 唤醒B， B唤醒C，C又唤醒A</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print5</span><span class="hljs-params">()</span> </span>&#123;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 判断</span>        <span class="hljs-keyword">while</span>(number != <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 不等于1，需要等待</span>            condition1.await();        &#125;        <span class="hljs-comment">// 干活</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);        &#125;        <span class="hljs-comment">// 唤醒 （干完活后，需要通知B线程执行）</span>        number = <span class="hljs-number">2</span>;        <span class="hljs-comment">// 通知2号去干活了</span>        condition2.signal();    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Synchronized 和 Lock的区别</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareResource</span> </span>&#123;    <span class="hljs-comment">// A 1   B 2   c 3</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 创建一个重入锁</span>    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-comment">// 这三个相当于备用钥匙</span>    <span class="hljs-keyword">private</span> Condition condition1 = lock.newCondition();    <span class="hljs-keyword">private</span> Condition condition2 = lock.newCondition();    <span class="hljs-keyword">private</span> Condition condition3 = lock.newCondition();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print5</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 判断</span>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">// 不等于1，需要等待</span>                condition1.await();            &#125;            <span class="hljs-comment">// 干活</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);            &#125;            <span class="hljs-comment">// 唤醒 （干完活后，需要通知B线程执行）</span>            number = <span class="hljs-number">2</span>;            <span class="hljs-comment">// 通知2号去干活了</span>            condition2.signal();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print10</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 判断</span>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">2</span>) &#123;                <span class="hljs-comment">// 不等于2，需要等待</span>                condition2.await();            &#125;            <span class="hljs-comment">// 干活</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);            &#125;            <span class="hljs-comment">// 唤醒 （干完活后，需要通知C线程执行）</span>            number = <span class="hljs-number">3</span>;            <span class="hljs-comment">// 通知2号去干活了</span>            condition3.signal();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print15</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 判断</span>            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">3</span>) &#123;                <span class="hljs-comment">// 不等于3，需要等待</span>                condition3.await();            &#125;            <span class="hljs-comment">// 干活</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);            &#125;            <span class="hljs-comment">// 唤醒 （干完活后，需要通知C线程执行）</span>            number = <span class="hljs-number">1</span>;            <span class="hljs-comment">// 通知1号去干活了</span>            condition1.signal();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncAndReentrantLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ShareResource shareResource = <span class="hljs-keyword">new</span> ShareResource();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                    shareResource.print5();            &#125;        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                shareResource.print10();            &#125;        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                shareResource.print15();            &#125;        &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();    &#125;&#125;</code></pre></div><h1 id="第10章线程池"><a href="#第10章线程池" class="headerlink" title="第10章线程池"></a>第10章线程池</h1><h2 id="1-前言-2"><a href="#1-前言-2" class="headerlink" title="1 前言"></a>1 前言</h2><p>获取多线程的方法，我们都知道有三种，还有一种是实现Callable接口</p><ul><li>实现Runnable接口</li><li>实现Callable接口</li><li>实例化Thread类</li><li>使用线程池获取</li></ul><h2 id="2-Callable接口"><a href="#2-Callable接口" class="headerlink" title="2 Callable接口"></a>2 Callable接口</h2><p>Callable接口，是一种让线程执行完成后，能够返回结果的</p><p>在说到Callable接口的时候，我们不得不提到Runnable接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 实现Runnable接口</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre></div><p>我们知道，实现Runnable接口的时候，需要重写run方法，也就是线程在启动的时候，会自动调用的方法</p><p>同理，我们实现Callable接口，也需要实现call方法，但是这个时候我们还需要有返回值，这个Callable接口的应用场景一般就在于批处理业务，比如转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Callable有返回值</span><span class="hljs-comment"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;come in Callable&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;    &#125;&#125;</code></pre></div><p>最后我们需要做的就是通过Thread线程， 将MyThread2实现Callable接口的类包装起来</p><p>这里需要用到的是FutureTask类，他实现了Runnable接口，并且还需要传递一个实现Callable接口的类作为构造函数</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// FutureTask：实现了Runnable接口，构造函数又需要传入 Callable接口</span><span class="hljs-comment">// 这里通过了FutureTask接触了Callable接口</span>FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());</code></pre></div><p>然后在用Thread进行实例化，传入实现Runnabnle接口的FutureTask的类</p><div class="code-wrapper"><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;aaa&quot;</span>);t1.start();</code></pre></div><p>最后通过 futureTask.get() 获取到返回值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 输出FutureTask的返回值</span>System.out.println(<span class="hljs-string">&quot;result FutureTask &quot;</span> + futureTask.get());</code></pre></div><p>这就相当于原来我们的方式是main方法一条龙之心，后面在引入Callable后，对于执行比较久的线程，可以单独新开一个线程进行执行，最后在进行汇总输出</p><p>最后需要注意的是 要求获得Callable线程的计算结果，如果没有计算完成就要去强求，会导致阻塞，直到计算完成</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317152541284.png" alt="image-20200317152541284"></p><p>也就是说 futureTask.get() 需要放在最后执行，这样不会导致主线程阻塞</p><p>也可以使用下面算法，使用类似于自旋锁的方式来进行判断是否运行完毕</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 判断futureTask是否计算完成</span><span class="hljs-keyword">while</span>(!futureTask.isDone()) &#123;&#125;</code></pre></div><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>多个线程执行 一个FutureTask的时候，只会计算一次</p><div class="code-wrapper"><pre><code class="hljs java">FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());<span class="hljs-comment">// 开启两个线程计算futureTask</span><span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;AAA&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;BBB&quot;</span>).start();</code></pre></div><p>如果我们要两个线程同时计算任务的话，那么需要这样写，需要定义两个futureTask</p><div class="code-wrapper"><pre><code class="hljs java">FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());FutureTask&lt;Integer&gt; futureTask2 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());<span class="hljs-comment">// 开启两个线程计算futureTask</span><span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;AAA&quot;</span>).start();<span class="hljs-keyword">new</span> Thread(futureTask2, <span class="hljs-string">&quot;BBB&quot;</span>).start();</code></pre></div><h2 id="3-ThreadPoolExecutor"><a href="#3-ThreadPoolExecutor" class="headerlink" title="3 ThreadPoolExecutor"></a>3 ThreadPoolExecutor</h2><h3 id="3-1-为什么用线程池"><a href="#3-1-为什么用线程池" class="headerlink" title="3.1 为什么用线程池"></a>3.1 为什么用线程池</h3><p>线程池做的主要工作就是控制运行的线程的数量，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为：线程复用、控制最大并发数、管理线程</p><p>线程池中的任务是放入到阻塞队列中的</p><h3 id="3-2-线程池的好处"><a href="#3-2-线程池的好处" class="headerlink" title="3.2 线程池的好处"></a>3.2 线程池的好处</h3><p>多核处理的好处是：省略的上下文的切换开销</p><p>原来我们实例化对象的时候，是使用 new关键字进行创建，到了Spring后，我们学了IOC依赖注入，发现Spring帮我们将对象已经加载到了Spring容器中，只需要通过@Autowrite注解，就能够自动注入，从而使用</p><p>因此使用多线程有下列的好处</p><ul><li>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就立即执行</li><li>提高线程的可管理性。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul><h3 id="3-3-架构说明"><a href="#3-3-架构说明" class="headerlink" title="3.3 架构说明"></a>3.3 架构说明</h3><p>Java中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors（代表工具类），ExecutorService，ThreadPoolExecutor这几个类。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317175202647.png" alt="image-20200317175202647"></p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317175241007.png" alt="image-20200317175241007"></p><h3 id="3-4-创建线程池"><a href="#3-4-创建线程池" class="headerlink" title="3.4 创建线程池"></a>3.4 创建线程池</h3><ul><li>Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池<ul><li>执行长期的任务，性能好很多</li><li>创建一个定长线程池，可控制线程数最大并发数，超出的线程会在队列中等待</li></ul></li><li>Executors.newSingleThreadExecutor：创建一个只有1个线程的 单线程池<ul><li>一个任务一个任务执行的场景</li><li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li></ul></li><li>Executors.newCacheThreadPool();  创建一个可扩容的线程池<ul><li>执行很多短期异步的小程序或者负载教轻的服务器</li><li>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程</li></ul></li><li>Executors.newScheduledThreadPool(int corePoolSize)：线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li></ul><p>具体使用，首先我们需要使用Executors工具类，进行创建线程池，这里创建了一个拥有5个线程的线程池</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span>ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<span class="hljs-comment">// 创建一个只有一个线程的线程池</span>ExecutorService threadPool = Executors.newSingleThreadExecutor();<span class="hljs-comment">// 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span>ExecutorService threadPool = Executors.newCacheThreadPool();</code></pre></div><p>然后我们执行下面的的应用场景</p><div class="code-wrapper"><pre><code class="hljs plain">模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</code></pre></div><p>我们需要使用 threadPool.execute执行业务，execute需要传入一个实现了Runnable接口的线程</p><div class="code-wrapper"><pre><code class="hljs java">threadPool.execute(() -&gt; &#123;System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户办理业务&quot;</span>);&#125;);</code></pre></div><p>然后我们使用完毕后关闭线程池</p><div class="code-wrapper"><pre><code class="hljs java">threadPool.shutdown();</code></pre></div><p>完整代码为：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 第四种获取 / 使用 Java多线程的方式，通过线程池</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadPoolDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// Array  Arrays(辅助工具类)</span>        <span class="hljs-comment">// Collection Collections(辅助工具类)</span>        <span class="hljs-comment">// Executor Executors(辅助工具类)</span>        <span class="hljs-comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span>        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);        <span class="hljs-comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="hljs-string">&quot; 办理业务&quot;</span>);                &#125;);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            threadPool.shutdown();        &#125;    &#125;&#125;</code></pre></div><p>最后结果：</p><div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">0</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 给用户:<span class="hljs-number">4</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">5</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 给用户:<span class="hljs-number">3</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 给用户:<span class="hljs-number">1</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 给用户:<span class="hljs-number">2</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 给用户:<span class="hljs-number">9</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 给用户:<span class="hljs-number">8</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">7</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 给用户:<span class="hljs-number">6</span> 办理业务</code></pre></div><p>我们能够看到，一共有5个线程，在给10个用户办理业务</p><h3 id="3-5-创建周期性执行任务的线程池"><a href="#3-5-创建周期性执行任务的线程池" class="headerlink" title="3.5  创建周期性执行任务的线程池"></a>3.5  创建周期性执行任务的线程池</h3><p>Executors.newScheduledThreadPool(int corePoolSize)：</p><p><strong>线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</strong></p><p>底层使用 ScheduledThreadPoolExecutor 来实现 ScheduledThreadPoolExecutor 为ThreadPoolExecutor子类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;        <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,              <span class="hljs-keyword">new</span> DelayedWorkQueue());&#125;</code></pre></div><h4 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h4><div class="code-wrapper"><pre><code class="hljs java">  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">   * command：执行的任务 Callable或Runnable接口实现类</span><span class="hljs-comment">* delay：延时执行任务的时间</span><span class="hljs-comment">* unit：延迟时间单位</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,                                     <span class="hljs-keyword">long</span> delay,                                     TimeUnit unit)</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException   &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * command：执行的任务 Callable或Runnable接口实现类</span><span class="hljs-comment"> * initialDelay 第一次执行任务延迟时间</span><span class="hljs-comment"> * period 连续执行任务之间的周期，从上一个任务开始执行时计算延迟多少开始执行下一个任务，但是还会等上一个任务结束之后。</span><span class="hljs-comment"> * unit：延迟时间单位</span><span class="hljs-comment">     */</span><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">long</span> period, TimeUnit unit)</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException   &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     * command：执行的任务 Callable或Runnable接口实现类</span><span class="hljs-comment"> * initialDelay 第一次执行任务延迟时间</span><span class="hljs-comment"> * delay：连续执行任务之间的周期，从上一个任务全部执行完成时计算延迟多少开始执行下一个任务</span><span class="hljs-comment"> * unit：延迟时间单位</span><span class="hljs-comment">     */</span><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">long</span> delay, TimeUnit unit)</code></pre></div><h2 id="4-底层实现"><a href="#4-底层实现" class="headerlink" title="4 底层实现"></a>4 底层实现</h2><p>我们通过查看源码，点击了Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool能够发现底层都是使用了ThreadPoolExecutor</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317182004293.png" alt="image-20200317182004293"></p><p>我们可以看到线程池的内部，还使用到了LinkedBlockingQueue 链表阻塞队列</p><p>同时在查看Executors.newCacheThreadPool 看到底层用的是 SynchronousBlockingQueue阻塞队列</p><p>最后查看一下，完整的三个创建线程的方法</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317183202992.png" alt="image-20200317183202992"></p><h2 id="5-线程池的重要参数"><a href="#5-线程池的重要参数" class="headerlink" title="5 线程池的重要参数"></a>5 线程池的重要参数</h2><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317183600957.png" alt="image-20200317183600957"></p><p>线程池在创建的时候，一共有7大参数</p><ul><li>corePoolSize：核心线程数，线程池中的常驻核心线程数<ul><li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li><li>当线程池中的线程数目达到corePoolSize后，就会把到达的队列放到缓存队列中</li></ul></li><li>maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1、<ul><li>相当有扩容后的线程数，这个线程池能容纳的最多线程数</li></ul></li><li>keepAliveTime：多余的空闲线程存活时间<ul><li>当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的空闲线程会被销毁，直到只剩下corePoolSize个线程为止</li><li>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</li></ul></li><li>unit：keepAliveTime的单位</li><li>workQueue：任务队列，被提交的但未被执行的任务（类似于银行里面的候客区）<ul><li>LinkedBlockingQueue：链表阻塞队列</li><li>SynchronousBlockingQueue：同步阻塞队列</li></ul></li><li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程池 一般用默认即可</li><li>handler：拒绝策略，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的Runnable的策略</li></ul><p>当营业窗口和阻塞队列中都满了时候，就需要设置拒绝策略</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317201150197.png" alt="image-20200317201150197"></p><h2 id="6-拒绝策略"><a href="#6-拒绝策略" class="headerlink" title="6 拒绝策略"></a>6 拒绝策略</h2><p>以下所有拒绝策略都实现了RejectedExecutionHandler接口</p><ul><li>AbortPolicy：默认，直接抛出RejectedExcutionException异常，阻止系统正常运行</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li><li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li></ul><h2 id="7-线程池底层工作原理"><a href="#7-线程池底层工作原理" class="headerlink" title="7 线程池底层工作原理"></a>7 线程池底层工作原理</h2><h3 id="线程池运行架构图"><a href="#线程池运行架构图" class="headerlink" title="线程池运行架构图"></a>线程池运行架构图</h3><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318154414717.png" alt="image-20200318154414717"></p><p>文字说明</p><ol><li><p>在创建了线程池后，等待提交过来的任务请求</p></li><li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断</p><ol><li>如果正在运行的线程池数量小于corePoolSize，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列</li><li>如果这时候队列满了，并且正在运行的线程数量还小于maximumPoolSize，那么还是创建非核心线程like运行这个任务；</li><li>如果队列满了并且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</li></ol></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p></li><li><p>当一个线程无事可做操作一定的时间(keepAliveTime)时，线程池会判断：</p><ol><li>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉</li><li>所以线程池的所有任务完成后，它会最终收缩到corePoolSize的大小</li></ol></li></ol><p>以顾客去银行办理业务为例，谈谈线程池的底层工作原理</p><ol><li>最开始假设来了两个顾客，因为corePoolSize为2，因此这两个顾客直接能够去窗口办理</li><li>后面又来了三个顾客，因为corePool已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待</li><li>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li><li>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略</li><li>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</li></ol><h2 id="8-为什么不用默认创建的线程池？"><a href="#8-为什么不用默认创建的线程池？" class="headerlink" title="8 为什么不用默认创建的线程池？"></a>8 为什么不用默认创建的线程池？</h2><p>线程池创建的方法有：固定数的，单一的，可变的，那么在实际开发中，应该使用哪个？</p><p>我们一个都不用，在生产环境中是使用自己自定义的</p><p>为什么不用 Executors 中JDK提供的？</p><p>根据阿里巴巴手册：并发控制这章</p><ul><li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程<ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</li></ul></li><li>线程池不允许使用Executors去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险<ul><li>Executors返回的线程池对象弊端如下：<ul><li>FixedThreadPool和SingleThreadPool：<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li></ul></li><li>CacheThreadPool和ScheduledThreadPool<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，线程数上限太大导致oom</li></ul></li></ul></li></ul></li></ul><h2 id="9-手写线程池"><a href="#9-手写线程池" class="headerlink" title="9 手写线程池"></a>9 手写线程池</h2><h3 id="9-1-采用默认拒绝策略"><a href="#9-1-采用默认拒绝策略" class="headerlink" title="9.1 采用默认拒绝策略"></a>9.1 采用默认拒绝策略</h3><p>从上面我们知道，因为默认的Executors创建的线程池，底层都是使用LinkBlockingQueue作为阻塞队列的，而LinkBlockingQueue虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有20多亿，可以相当是无界的了，因此我们要使用ThreadPoolExecutor自己手动创建线程池，然后指定阻塞队列的大小</p><p>下面我们创建了一个 核心线程数为2，最大线程数为5，并且阻塞队列数为3的线程池</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 手写线程池</span><span class="hljs-keyword">final</span> Integer corePoolSize = <span class="hljs-number">2</span>;<span class="hljs-keyword">final</span> Integer maximumPoolSize = <span class="hljs-number">5</span>;<span class="hljs-keyword">final</span> Long keepAliveTime = <span class="hljs-number">1L</span>;<span class="hljs-comment">// 自定义线程池，只改变了LinkBlockingQueue的队列大小</span>ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(    corePoolSize,    maximumPoolSize,    keepAliveTime,    TimeUnit.SECONDS,    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>),    Executors.defaultThreadFactory(),    <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());</code></pre></div><p>然后使用for循环，模拟10个用户来进行请求</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span><span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;        executorService.execute(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="hljs-string">&quot; 办理业务&quot;</span>);        &#125;);    &#125;&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;    executorService.shutdown();&#125;</code></pre></div><p>但是在用户执行到第九个的时候，触发了异常，程序中断</p><div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">0</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 给用户:<span class="hljs-number">6</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 给用户:<span class="hljs-number">5</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 给用户:<span class="hljs-number">1</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 给用户:<span class="hljs-number">4</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 给用户:<span class="hljs-number">7</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 给用户:<span class="hljs-number">2</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 给用户:<span class="hljs-number">3</span> 办理业务java.util.concurrent.RejectedExecutionException: Task com.moxi.interview.study.thread.MyThreadPoolDemo$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">1747585824</span>@4dd8dc3 rejected from java.util.concurrent.ThreadPoolExecutor@6d03e736[Running, pool size = <span class="hljs-number">5</span>, active threads = <span class="hljs-number">3</span>, queued tasks = <span class="hljs-number">0</span>, completed tasks = <span class="hljs-number">5</span>]at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="hljs-number">2047</span>)at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="hljs-number">823</span>)at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="hljs-number">1369</span>)at com.moxi.interview.study.thread.MyThreadPoolDemo.main(MyThreadPoolDemo.java:<span class="hljs-number">34</span>)</code></pre></div><p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的AbortPolicy，也就是抛异常的</p><p>触发条件是，请求的线程大于 阻塞队列大小 + 最大线程数 = 8 的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p><h3 id="9-2-采用CallerRunsPolicy拒绝策略"><a href="#9-2-采用CallerRunsPolicy拒绝策略" class="headerlink" title="9.2 采用CallerRunsPolicy拒绝策略"></a>9.2 采用CallerRunsPolicy拒绝策略</h3><p>当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为回退策略，就是把任务丢回原来的请求开启线程着，我们看运行结果</p><div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">0</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 给用户:<span class="hljs-number">7</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 给用户:<span class="hljs-number">6</span> 办理业务main 给用户:<span class="hljs-number">8</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 给用户:<span class="hljs-number">5</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 给用户:<span class="hljs-number">1</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 给用户:<span class="hljs-number">9</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 给用户:<span class="hljs-number">4</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 给用户:<span class="hljs-number">3</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">2</span> 办理业务</code></pre></div><p>我们发现，输出的结果里面出现了main线程，因为线程池出发了拒绝策略，把任务回退到main线程，然后main线程对任务进行处理</p><h3 id="9-3-采用-DiscardPolicy-拒绝策略"><a href="#9-3-采用-DiscardPolicy-拒绝策略" class="headerlink" title="9.3 采用 DiscardPolicy 拒绝策略"></a>9.3 采用 DiscardPolicy 拒绝策略</h3><div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">0</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 给用户:<span class="hljs-number">5</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">2</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 给用户:<span class="hljs-number">1</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">4</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 给用户:<span class="hljs-number">7</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 给用户:<span class="hljs-number">6</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 给用户:<span class="hljs-number">3</span> 办理业务</code></pre></div><p>采用DiscardPolicy拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</p><h3 id="9-4-采用DiscardOldestPolicy拒绝策略"><a href="#9-4-采用DiscardOldestPolicy拒绝策略" class="headerlink" title="9.4 采用DiscardOldestPolicy拒绝策略"></a>9.4 采用DiscardOldestPolicy拒绝策略</h3><div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">0</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 给用户:<span class="hljs-number">6</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">4</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> 给用户:<span class="hljs-number">5</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> 给用户:<span class="hljs-number">1</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 给用户:<span class="hljs-number">9</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> 给用户:<span class="hljs-number">8</span> 办理业务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> 给用户:<span class="hljs-number">7</span> 办理业务</code></pre></div><p>这个策略和刚刚差不多，会把最久的队列中的任务替换掉</p><h2 id="10-线程池的合理参数"><a href="#10-线程池的合理参数" class="headerlink" title="10 线程池的合理参数"></a>10 线程池的合理参数</h2><p>生产环境中如何配置 corePoolSize 和 maximumPoolSize</p><p>这个是根据具体业务来配置的，分为CPU密集型和IO密集型</p><ul><li>CPU密集型</li></ul><p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p><p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p><p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</p><p>CPU密集型任务配置尽可能少的线程数量：</p><p>一般公式：CPU核数 + 1个线程数</p><ul><li>IO密集型</li></ul><p>由于IO密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p><p>IO密集型，即该任务需要大量的IO操作，即大量的阻塞</p><p>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力花费在等待上</p><p>所以IO密集型任务中使用多线程可以大大的加速程序的运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p><p>IO密集时，大部分线程都被阻塞，故需要多配置线程数：</p><p>参考公式：CPU核数 / (1 - 阻塞系数)      阻塞系数在0.8 ~ 0.9左右</p><p>例如：8核CPU：8/ (1 - 0.9) = 80个线程数</p><h1 id="第11章-死锁编码及定位分析"><a href="#第11章-死锁编码及定位分析" class="headerlink" title="第11章 死锁编码及定位分析"></a>第11章 死锁编码及定位分析</h1><h2 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1 概念"></a>1 概念</h2><p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318175441578.png" alt="image-20200318175441578"></p><h2 id="2-产生死锁的原因"><a href="#2-产生死锁的原因" class="headerlink" title="2 产生死锁的原因"></a>2 产生死锁的原因</h2><ul><li>系统资源不足</li><li>进程运行推进的顺序不对</li><li>资源分配不当</li></ul><h2 id="3-死锁产生的四个必要条件"><a href="#3-死锁产生的四个必要条件" class="headerlink" title="3 死锁产生的四个必要条件"></a>3 死锁产生的四个必要条件</h2><ul><li>互斥<ul><li>解决方法：把互斥的共享资源封装成可同时访问</li></ul></li><li>占有且等待<ul><li>解决方法：进程请求资源时，要求它不占有任何其它资源，也就是它必须一次性申请到所有的资源，这种方式会导致资源效率低。</li></ul></li><li>非抢占式<ul><li>解决方法：如果进程不能立即分配资源，要求它不占有任何其他资源，也就是只能够同时获得所有需要资源时，才执行分配操作</li></ul></li><li>循环等待<ul><li>解决方法：对资源进行排序，要求进程按顺序请求资源。</li></ul></li></ul><h2 id="4-死锁代码"><a href="#4-死锁代码" class="headerlink" title="4 死锁代码"></a>4 死锁代码</h2><p>我们创建了一个资源类，然后让两个线程分别持有自己的锁，同时在尝试获取别人的，就会出现死锁现象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 死锁小Demo</span><span class="hljs-comment"> * 死锁是指两个或多个以上的进程在执行过程中，</span><span class="hljs-comment"> * 因争夺资源而造成一种互相等待的现象，</span><span class="hljs-comment"> * 若无外力干涉那他们都将无法推进下去</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 资源类</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HoldLockThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    <span class="hljs-keyword">private</span> String lockA;    <span class="hljs-keyword">private</span> String lockB;    <span class="hljs-comment">// 持有自己的锁，还想得到别人的锁</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HoldLockThread</span><span class="hljs-params">(String lockA, String lockB)</span> </span>&#123;        <span class="hljs-keyword">this</span>.lockA = lockA;        <span class="hljs-keyword">this</span>.lockB = lockB;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lockA) &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 自己持有&quot;</span> + lockA + <span class="hljs-string">&quot;\t 尝试获取：&quot;</span> + lockB);            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">synchronized</span> (lockB) &#123;                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 自己持有&quot;</span> + lockB + <span class="hljs-string">&quot;\t 尝试获取：&quot;</span> + lockA);            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String lockA = <span class="hljs-string">&quot;lockA&quot;</span>;        String lockB = <span class="hljs-string">&quot;lockB&quot;</span>;        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> HoldLockThread(lockA, lockB), <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> HoldLockThread(lockB, lockA), <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre></div><p>运行结果，main线程无法结束</p><div class="code-wrapper"><pre><code class="hljs java">t1 自己持有lockA 尝试获取：lockBt2 自己持有lockB 尝试获取：lockA</code></pre></div><h2 id="5-如何排查死锁"><a href="#5-如何排查死锁" class="headerlink" title="5 如何排查死锁"></a>5 如何排查死锁</h2><p>当我们出现死锁的时候，首先需要使用jps命令查看运行的程序</p><div class="code-wrapper"><pre><code class="hljs java">jps -l</code></pre></div><p>我们能看到DeadLockDemo这个类，一直在运行</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318181504703.png" alt="image-20200318181504703"></p><p>在使用jstack查看堆栈信息</p><div class="code-wrapper"><pre><code class="hljs java">jstack  7560   # 后面参数是 jps输出的该类的pid</code></pre></div><p>得到的结果</p><div class="code-wrapper"><pre><code class="hljs java">Found one Java-level deadlock:=============================<span class="hljs-string">&quot;t2&quot;</span>:  waiting to lock monitor <span class="hljs-number">0x000000001cfc0de8</span> (object <span class="hljs-number">0x000000076b696e80</span>, a java.lang.String),  which is held by <span class="hljs-string">&quot;t1&quot;</span><span class="hljs-string">&quot;t1&quot;</span>:  waiting to lock monitor <span class="hljs-number">0x000000001cfc3728</span> (object <span class="hljs-number">0x000000076b696eb8</span>, a java.lang.String),  which is held by <span class="hljs-string">&quot;t2&quot;</span>Java stack information <span class="hljs-keyword">for</span> the threads listed above:===================================================<span class="hljs-string">&quot;t2&quot;</span>:        at com.moxi.interview.study.Lock.HoldLockThread.run(DeadLockDemo.java:<span class="hljs-number">42</span>)        - waiting to lock &lt;<span class="hljs-number">0x000000076b696e80</span>&gt; (a java.lang.String)        - locked &lt;<span class="hljs-number">0x000000076b696eb8</span>&gt; (a java.lang.String)        at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)<span class="hljs-string">&quot;t1&quot;</span>:        at com.moxi.interview.study.Lock.HoldLockThread.run(DeadLockDemo.java:<span class="hljs-number">42</span>)        - waiting to lock &lt;<span class="hljs-number">0x000000076b696eb8</span>&gt; (a java.lang.String)        - locked &lt;<span class="hljs-number">0x000000076b696e80</span>&gt; (a java.lang.String)        at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)Found <span class="hljs-number">1</span> deadlock.</code></pre></div><p>通过查看最后一行，我们看到  Found 1 deadlock，即存在一个死锁</p><h1 id="第二部分-JVM"><a href="#第二部分-JVM" class="headerlink" title="第二部分 JVM"></a>第二部分 JVM</h1><h1 id="第-12-章-JVM"><a href="#第-12-章-JVM" class="headerlink" title="第 12 章 JVM"></a>第 12 章 JVM</h1><h2 id="1-JVM体系结构"><a href="#1-JVM体系结构" class="headerlink" title="1 JVM体系结构"></a>1 JVM体系结构</h2><h3 id="1-1-概览"><a href="#1-1-概览" class="headerlink" title="1.1 概览"></a>1.1 概览</h3><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318182540332.png" alt="image-20200318182540332"></p><p>java gc 主要回收的是 方法区 和 堆中的内容</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318184401133.png" alt="image-20200318184401133"></p><h3 id="1-2-类加载器"><a href="#1-2-类加载器" class="headerlink" title="1.2 类加载器"></a>1.2 类加载器</h3><ul><li>类加载器是什么</li><li>双亲委派机制</li><li>Java类加载的沙箱安全机制</li></ul><h3 id="1-3-常见的垃圾回收算法"><a href="#1-3-常见的垃圾回收算法" class="headerlink" title="1.3 常见的垃圾回收算法"></a>1.3 常见的垃圾回收算法</h3><ul><li>引用计数</li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318184508982.png" alt="image-20200318184508982"></p><p>在双端循环，互相引用的时候，容易报错，目前很少使用这种方式了</p><ul><li>复制</li></ul><p>复制算法在年轻代的时候，进行使用，复制时候有交换</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318184759295.png" alt="image-20200318184759295"></p><p><img src="images/image-20200318184820787.png" alt="image-20200318184820787"></p><p>优点：没有产生内存碎片</p><ul><li>标记清除</li></ul><p>先标记，后清除，缺点是会产生内存碎片，用于老年代多一些</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318184944878.png" alt="image-20200318184944878"></p><ul><li>标记整理</li></ul><p>标记清除整理</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318185100936.png" alt="image-20200318185100936"></p><p>但是需要付出代价，因为移动对象需要成本</p><h2 id="2-JVM-面试题"><a href="#2-JVM-面试题" class="headerlink" title="2 JVM 面试题"></a>2 JVM 面试题</h2><h3 id="2-1-是么是-GCRoots-能做什么"><a href="#2-1-是么是-GCRoots-能做什么" class="headerlink" title="2.1 是么是 GCRoots 能做什么"></a>2.1 是么是 GCRoots 能做什么</h3><h4 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1 什么是垃圾"></a>1 什么是垃圾</h4><p>简单来说就是内存中已经不再被使用的空间就是垃圾</p><h4 id="2-如何判断一个对象是否可以被回收"><a href="#2-如何判断一个对象是否可以被回收" class="headerlink" title="2 如何判断一个对象是否可以被回收"></a>2 如何判断一个对象是否可以被回收</h4><h5 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h5><p>Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。</p><p>因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器</p><p>每当有一个地方引用它，计数器值加1</p><p>每当有一个引用失效，计数器值减1</p><p>任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。</p><p>那么为什么主流的Java虚拟机里面都没有选用这个方法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p><p>该算法存在但目前无人用了，解决不了循环引用的问题，了解即可。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318213301603.png" alt="image-20200318213301603"></p><h5 id="2-2-枚举根节点做可达性分析"><a href="#2-2-枚举根节点做可达性分析" class="headerlink" title="2.2 枚举根节点做可达性分析"></a>2.2 枚举根节点做可达性分析</h5><p>根搜索路径算法</p><p>为了解决引用计数法的循环引用个问题，Java使用了可达性分析的方法：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200319113611244.png" alt="image-20200319113611244"></p><p>所谓 GC Roots 或者说 Tracing Roots的“根集合” 就是一组必须活跃的引用</p><p>基本思路就是通过一系列名为 GC Roots的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的对象就被判定为死亡</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200319114526625.png" alt="image-20200319114526625"></p><p>必须从GC Roots对象开始，这个类似于linux的 /  也就是根目录</p><p>蓝色部分是从GC Roots出发，能够循环可达</p><p>而白色部分，从GC Roots出发，无法到达</p><h5 id="2-3-一句话理解GC-Roots"><a href="#2-3-一句话理解GC-Roots" class="headerlink" title="2.3 一句话理解GC Roots"></a>2.3 一句话理解GC Roots</h5><p>假设我们现在有三个实体，分别是 人，狗，毛衣</p><p>然后他们之间的关系是：人 牵着 狗，狗穿着毛衣，他们之间是强连接的关系</p><p>有一天人消失了，只剩下狗狗 和 毛衣，这个时候，把人想象成 GC Roots，因为 人 和 狗之间失去了绳子连接，</p><p>那么狗可能被回收，也就是被警察抓起来，被送到流浪狗寄养所</p><p>假设狗和人有强连接的时候，狗狗就不会被当成是流浪狗</p><h5 id="2-4-那些对象可以当做GC-Roots"><a href="#2-4-那些对象可以当做GC-Roots" class="headerlink" title="2.4 那些对象可以当做GC Roots"></a>2.4 那些对象可以当做GC Roots</h5><ul><li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中的JNI（Native方法）的引用对象</li></ul><h5 id="2-5-代码说明"><a href="#2-5-代码说明" class="headerlink" title="2.5 代码说明"></a>2.5 代码说明</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 在Java中，可以作为GC Roots的对象有：</span><span class="hljs-comment"> * - 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</span><span class="hljs-comment"> * - 方法区中的类静态属性引用的对象</span><span class="hljs-comment"> * - 方法区中常量引用的对象</span><span class="hljs-comment"> * - 本地方法栈中的JNI（Native方法）的引用对象</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCRootDemo</span> </span>&#123;    <span class="hljs-comment">// 方法区中的类静态属性引用的对象</span>    <span class="hljs-comment">// private static GCRootDemo2 t2;</span>    <span class="hljs-comment">// 方法区中的常量引用，GC Roots 也会以这个为起点，进行遍历</span>    <span class="hljs-comment">// private static final GCRootDemo3 t3 = new GCRootDemo3(8);</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 第一种，虚拟机栈中的引用对象</span>        GCRootDemo t1 = <span class="hljs-keyword">new</span> GCRootDemo();        System.gc();        System.out.println(<span class="hljs-string">&quot;第一次GC完成&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        m1();    &#125;&#125;</code></pre></div><h3 id="2-2-JVM参数调优"><a href="#2-2-JVM参数调优" class="headerlink" title="2.2  JVM参数调优"></a>2.2  JVM参数调优</h3><h4 id="1-前言-3"><a href="#1-前言-3" class="headerlink" title="1 前言"></a>1 前言</h4><p>你说你做过JVM调优和参数配置，请问如何盘点查看JVM系统默认值</p><p>使用jps和jinfo进行查看</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms：初始堆空间</span><span class="hljs-deletion">-Xmx：堆最大值</span><span class="hljs-deletion">-Xss：栈空间</span></code></pre></div><p>-Xms 和 -Xmx最好调整一致，防止JVM频繁进行收集和回收</p><h4 id="2-JVM参数类型"><a href="#2-JVM参数类型" class="headerlink" title="2 JVM参数类型"></a>2 JVM参数类型</h4><ul><li>标配参数（从JDK1.0 - Java12都在，很稳定）<ul><li>-version</li><li>-help</li><li>java -showversion</li></ul></li><li>X参数（了解）<ul><li>-Xint：解释执行</li><li>-Xcomp：第一次使用就编译成本地代码</li><li>-Xmixed：混合模式</li></ul></li><li>XX参数（重点）<ul><li>Boolean类型<ul><li>公式：-XX:+ 或者-某个属性   + 表示开启，-表示关闭</li><li>Case：-XX:-PrintGCDetails：表示关闭了GC详情输出</li></ul></li><li>key-value类型<ul><li>公式：-XX:属性key=属性value</li><li>不满意初始值，可以通过下列命令调整</li><li>case：如何：-XX:MetaspaceSize=21807104：查看Java元空间的值</li></ul></li></ul></li></ul><h4 id="3-查看运行的Java程序，JVM参数是否开启，具体值为多少？"><a href="#3-查看运行的Java程序，JVM参数是否开启，具体值为多少？" class="headerlink" title="3 查看运行的Java程序，JVM参数是否开启，具体值为多少？"></a>3 查看运行的Java程序，JVM参数是否开启，具体值为多少？</h4><p>首先我们运行一个HelloGC的java程序</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloGC</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello GC&quot;</span>);        Thread.sleep(Integer.MAX_VALUE);    &#125;&#125;</code></pre></div><p>然后使用下列命令查看它的默认参数</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps：查看java的后台进程</span><span class="hljs-keyword">jinfo：查看正在运行的java程序</span></code></pre></div><p>具体使用：</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps </span>-l得到进程号</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-number">12608</span> com.moxi.interview.study.GC.HelloGC<span class="hljs-number">15200</span> sun.tools.jps.Jps<span class="hljs-number">15296</span> org.jetbrains.idea.maven.server.RemoteMavenServer36<span class="hljs-number">4528</span><span class="hljs-number">12216</span> org.jetbrains.jps.cmdline.Launcher<span class="hljs-number">9772</span> org.jetbrains.kotlin.daemon.KotlinCompileDaemon</code></pre></div><p>查看到HelloGC的进程号为：12608</p><p>我们使用jinfo -flag 然后查看是否开启PrintGCDetails这个参数</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">jinfo</span> -flag PrintGCDetails <span class="hljs-number">12608</span></code></pre></div><p>得到的内容为</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:-PrintGCDetails</span></code></pre></div><p>上面提到了，-号表示关闭，即没有开启PrintGCDetails这个参数</p><p>下面我们需要在启动HelloGC的时候，增加 PrintGCDetails这个参数，需要在运行程序的时候配置JVM参数</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200319122922264.png" alt="image-20200319122922264"></p><p>然后在VM Options中加入下面的代码，现在+号表示开启</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+PrintGCDetails</span></code></pre></div><p>然后在使用jinfo查看我们的配置</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps </span>-l<span class="hljs-keyword">jinfo </span>-flag PrintGCDetails <span class="hljs-number">13540</span></code></pre></div><p>得到的结果为</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+PrintGCDetails</span></code></pre></div><p>我们看到原来的-号变成了+号，说明我们通过 VM Options配置的JVM参数已经生效了</p><p>使用下列命令，会把jvm的全部默认参数输出</p><div class="code-wrapper"><pre><code class="hljs asciidoc">jinfo -flags <span class="hljs-strong">***</span></code></pre></div><h4 id="4-题外话（坑题）"><a href="#4-题外话（坑题）" class="headerlink" title="4 题外话（坑题）"></a>4 题外话（坑题）</h4><p>两个经典参数：-Xms  和 -Xmx，这两个参数 如何解释</p><p>这两个参数，还是属于XX参数，因为取了别名</p><ul><li>-Xms  等价于 -XX:InitialHeapSize  ：初始化堆内存（默认只会用最大物理内存的64分1）</li><li>-Xmx 等价于 -XX:MaxHeapSize    ：最大堆内存（默认只会用最大物理内存的4分1）</li></ul><h4 id="5-查看JVM默认参数"><a href="#5-查看JVM默认参数" class="headerlink" title="5 查看JVM默认参数"></a>5 查看JVM默认参数</h4><ul><li><p>-XX:+PrintFlagsInitial</p><ul><li>主要是查看初始默认值</li><li>公式<ul><li>java -XX:+PrintFlagsInitial -version</li><li>java -XX:+PrintFlagsInitial（重要参数）</li></ul></li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200320212256284.png" alt="image-20200320212256284">   </p></li><li><p>-XX:+PrintFlagsFinal：表示修改以后，最终的值</p><div class="code-wrapper"><pre><code>会将JVM的各个结果都进行打印如果有  := 表示修改过的， = 表示没有修改过的</code></pre></div></li></ul><h4 id="6-工作中常用的JVM基本配置参数"><a href="#6-工作中常用的JVM基本配置参数" class="headerlink" title="6 工作中常用的JVM基本配置参数"></a>6 工作中常用的JVM基本配置参数</h4><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200322163252777.png" alt="image-20200322163252777"></p><h5 id="6-1-查看堆内存"><a href="#6-1-查看堆内存" class="headerlink" title="6.1 查看堆内存"></a>6.1 查看堆内存</h5><p>查看JVM的初始化堆内存 -Xms 和最大堆内存 Xmx</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloGC</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">// 返回Java虚拟机中内存的总量</span>        <span class="hljs-keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();        <span class="hljs-comment">// 返回Java虚拟机中试图使用的最大内存量</span>        <span class="hljs-keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();        System.out.println(<span class="hljs-string">&quot;TOTAL_MEMORY(-Xms) = &quot;</span> + totalMemory + <span class="hljs-string">&quot;(字节)、&quot;</span> + (totalMemory / (<span class="hljs-keyword">double</span>)<span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);        System.out.println(<span class="hljs-string">&quot;MAX_MEMORY(-Xmx) = &quot;</span> + maxMemory + <span class="hljs-string">&quot;(字节)、&quot;</span> + (maxMemory / (<span class="hljs-keyword">double</span>)<span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);    &#125;&#125;</code></pre></div><p>运行结果为：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">TOTAL_MEMORY</span>(-Xms) = <span class="hljs-number">257425408</span>(字节)、<span class="hljs-number">245</span>.<span class="hljs-number">5</span>MB<span class="hljs-attribute">MAX_MEMORY</span>(-Xmx) = <span class="hljs-number">3790077952</span>(字节)、<span class="hljs-number">3614</span>.<span class="hljs-number">5</span>MB</code></pre></div><p>-Xms 初始堆内存为：物理内存的1/64          -Xmx 最大堆内存为：系统物理内存的 1/4</p><h5 id="6-2-打印JVM默认参数"><a href="#6-2-打印JVM默认参数" class="headerlink" title="6.2 打印JVM默认参数"></a>6.2 打印JVM默认参数</h5><p>使用 <code>-XX:+PrintCommandLineFlags</code> 打印出JVM的默认的简单初始化参数</p><p>比如我的机器输出为：</p><div class="code-wrapper"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">InitialHeapSize</span>=266376000 -XX:<span class="hljs-attribute">MaxHeapSize</span>=4262016000 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</code></pre></div><h5 id="6-3-生活常用调优参数"><a href="#6-3-生活常用调优参数" class="headerlink" title="6.3 生活常用调优参数"></a>6.3 生活常用调优参数</h5><ul><li>-Xms：初始化堆内存，默认为物理内存的1/64，等价于 -XX:initialHeapSize</li><li>-Xmx：最大堆内存，默认为物理内存的1/4，等价于-XX:MaxHeapSize</li><li>-Xss：设计单个线程栈的大小，一般默认为512K~1024K，等价于 -XX:ThreadStackSize<ul><li>使用 jinfo -flag ThreadStackSize   会发现 -XX:ThreadStackSize = 0</li><li>这个值的大小是取决于平台的</li><li>Linux/x64:1024KB</li><li>OS X：1024KB</li><li>Oracle Solaris：1024KB</li><li>Windows：取决于虚拟内存的大小</li></ul></li><li>-Xmn：设置年轻代大小</li><li>-XX:MetaspaceSize：设置元空间大小<ul><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制。</li><li>-Xms10m -Xmx10m -XX:MetaspaceSize=1024m  -XX:+PrintFlagsFinal</li><li>但是默认的元空间大小：只有20多M</li><li>为了防止在频繁的实例化对象的时候，让元空间出现OOM，因此可以把元空间设置的大一些</li></ul></li><li>-XX:PrintGCDetails：输出详细GC收集日志信息<ul><li>GC</li><li>Full GC</li></ul></li></ul><p>GC日志收集流程图</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200322185639902.png" alt="image-20200322185639902"></p><p>我们使用一段代码，制造出垃圾回收的过程</p><p>首先我们设置一下程序的启动配置:  设置初始堆内存为10M，最大堆内存为10M</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:+PrintGCDetails</span></code></pre></div><p>然后用下列代码，创建一个 非常大空间的byte类型数组</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">byte</span> [] byteArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">50</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];</code></pre></div><p>运行后，发现会出现下列错误，这就是OOM：java内存溢出，也就是堆空间不足</p><div class="code-wrapper"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: Java heap spaceat com<span class="hljs-selector-class">.moxi</span><span class="hljs-selector-class">.interview</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.GC</span><span class="hljs-selector-class">.HelloGC</span><span class="hljs-selector-class">.main</span>(HelloGC<span class="hljs-selector-class">.java</span>:<span class="hljs-number">22</span>)</code></pre></div><p>同时还打印出了GC垃圾回收时候的详情</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">1972</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">504</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">1972</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">740</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0156109</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.03</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">504</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">480</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">740</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">772</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0007815</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">480</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">292</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">772</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0080505</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0003035</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">630</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">630</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058502</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Heap</span> <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">80</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">2048</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">3</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd143d8</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">630</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff69dbd0</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3510</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4500</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span>  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">389</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">392</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span></code></pre></div><p>问题发生的原因：</p><p>因为们通过 -Xms10m  和 -Xmx10m 只给Java堆栈设置了10M的空间，但是创建了50M的对象，因此就会出现空间不足，而导致出错</p><p>同时在垃圾收集的时候，我们看到有两个对象：GC 和 Full GC</p><h5 id="6-4-GC垃圾收集"><a href="#6-4-GC垃圾收集" class="headerlink" title="6.4 GC垃圾收集"></a>6.4 GC垃圾收集</h5><p>GC在新生区</p><div class="code-wrapper"><pre><code class="hljs json">[GC (Allocation Failure) [PSYoungGen: <span class="hljs-number">1972</span>K-&gt;<span class="hljs-number">504</span>K(<span class="hljs-number">2560</span>K)] <span class="hljs-number">1972</span>K-&gt;<span class="hljs-number">740</span>K(<span class="hljs-number">9728</span>K), <span class="hljs-number">0.0156109</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.03</span> secs]</code></pre></div><p>GC (Allocation Failure)：表示分配失败，那么就需要触发年轻代空间中的内容被回收</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">1972</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">504</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">1972</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">740</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0156109</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span></code></pre></div><p>参数对应的图为：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200323124000865.png" alt="image-20200323124000865"></p><h5 id="6-6-Full-GC垃圾回收"><a href="#6-6-Full-GC垃圾回收" class="headerlink" title="6.6 Full GC垃圾回收"></a>6.6 Full GC垃圾回收</h5><p>Full GC大部分发生在养老区</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">630</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">630</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058502</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span></code></pre></div><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200323125839653.png" alt="image-20200323125839653"></p><p>规律：</p><div class="code-wrapper"><pre><code class="hljs clojure">[名称： GC前内存占用 -&gt; GC后内存占用 (该区内存总大小)]</code></pre></div><p>当我们出现了老年代都扛不住的时候，就会出现OOM异常</p><h5 id="6-7-XX-SurvivorRatio"><a href="#6-7-XX-SurvivorRatio" class="headerlink" title="6.7 -XX:SurvivorRatio"></a>6.7 -XX:SurvivorRatio</h5><p>调节新生代中 eden 和 S0、S1的空间比例，默认为 -XX:SuriviorRatio=8，Eden:S0:S1 = 8:1:1</p><p>加入设置成 -XX:SurvivorRatio=4，则为 Eden:S0:S1 = 4:1:1</p><p>SurvivorRatio值就是设置eden区的比例占多少，S0和S1相同</p><p>Java堆从GC的角度还可以细分为：新生代（Eden区，From Survivor区合To Survivor区）和老年代</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200323130442088.png" alt="image-20200323130442088"></p><ul><li>eden、SurvivorFrom复制到SurvivorTo，年龄 + 1</li></ul><p>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom去，当Eden区再次触发GC的时候会扫描Eden区合From区域，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到To区域（如果对象的年龄已经到达老年的标准，则赋值到老年代区），通知把这些对象的年龄 + 1</p><ul><li>清空eden、SurvivorFrom</li></ul><p>然后，清空eden，SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</p><ul><li>SurvivorTo和SurvivorFrom互换</li></ul><p>最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200323150946414.png" alt="image-20200323150946414"></p><h5 id="6-8-XX-NewRatio（了解）"><a href="#6-8-XX-NewRatio（了解）" class="headerlink" title="6.8 -XX:NewRatio（了解）"></a>6.8 -XX:NewRatio（了解）</h5><p>配置年轻代new 和老年代old 在堆结构的占比</p><p>默认： -XX:NewRatio=2 新生代占1，老年代2，年轻代占整个堆的1/3</p><p>-XX:NewRatio=4：新生代占1，老年代占4，年轻代占整个堆的1/5，NewRadio值就是设置老年代的占比，剩下的1个新生代</p><p>新生代特别小，会造成频繁的进行GC收集</p><h5 id="6-9-XX-MaxTenuringThreshold"><a href="#6-9-XX-MaxTenuringThreshold" class="headerlink" title="6.9 -XX:MaxTenuringThreshold"></a>6.9 -XX:MaxTenuringThreshold</h5><p>设置垃圾最大年龄，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代</p><p>这里就是调整这个次数的，默认是15，并且设置的值 在 0~15之间</p><p>查看默认进入老年代年龄：jinfo -flag MaxTenuringThreshold 17344</p><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过Survivor区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概念</p><h3 id="2-3-Java中的引用"><a href="#2-3-Java中的引用" class="headerlink" title="2.3 Java中的引用"></a>2.3 Java中的引用</h3><h4 id="1-前言-4"><a href="#1-前言-4" class="headerlink" title="1 前言"></a>1 前言</h4><p>在原来的时候，我们谈到一个类的实例化</p><div class="code-wrapper"><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Person()</code></pre></div><p>在等号的左边，就是一个对象的引用，存储在栈中</p><p>而等号右边，就是实例化的对象，存储在堆中</p><p>其实这样的一个引用关系，就被称为强引用</p><h4 id="2-整体架构"><a href="#2-整体架构" class="headerlink" title="2 整体架构"></a>2 整体架构</h4><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200323155120778.png" alt="image-20200323155120778"></p><h4 id="3-强引用"><a href="#3-强引用" class="headerlink" title="3 强引用"></a>3 强引用</h4><p>当内存不足的时候，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，打死也不回收~！</p><p>强引用是我们最常见的普通对象引用，只要还有一个强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收，因此强引用是造成Java内存泄漏的主要原因之一。</p><p>对于一个普通的对象，如果没有其它的引用关系，只要超过了引用的作用于或者显示地将相应（强）引用赋值为null，一般可以认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾回收策略）</p><p>强引用小例子：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 强引用</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrongReferenceDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 这样定义的默认就是强应用</span>        Object obj1 = <span class="hljs-keyword">new</span> Object();        <span class="hljs-comment">// 使用第二个引用，指向刚刚创建的Object对象</span>        Object obj2 = obj1;        <span class="hljs-comment">// 置空</span>        obj1 = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 垃圾回收</span>        System.gc();        System.out.println(obj1);        System.out.println(obj2);    &#125;&#125;</code></pre></div><p>输出结果我们能够发现，即使 obj1 被设置成了null，然后调用gc进行回收，但是也没有回收实例出来的对象，obj2还是能够指向该地址，也就是说垃圾回收器，并没有将该对象进行垃圾回收</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">null</span>java.lang.Object@14ae5a5</code></pre></div><h4 id="4-软引用"><a href="#4-软引用" class="headerlink" title="4 软引用"></a>4 软引用</h4><p>软引用是一种相对弱化了一些的引用，需要用Java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集，对于只有软引用的对象来讲：</p><ul><li>当系统内存充足时，它不会被回收</li><li>当系统内存不足时，它会被回收</li></ul><p>软引用通常在对内存敏感的程序中，比如高速缓存就用到了软引用，内存够用 的时候就保留，不够用就回收</p><p>具体使用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 软引用</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SoftReferenceDemo</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 内存够用的时候</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">softRefMemoryEnough</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 创建一个强应用</span>        Object o1 = <span class="hljs-keyword">new</span> Object();        <span class="hljs-comment">// 创建一个软引用</span>        SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(o1);        System.out.println(o1);        System.out.println(softReference.get());        o1 = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 手动GC</span>        System.gc();        System.out.println(o1);        System.out.println(softReference.get());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * JVM配置，故意产生大对象并配置小的内存，让它的内存不够用了导致OOM，看软引用的回收情况</span><span class="hljs-comment">     * -Xms5m -Xmx5m -XX:+PrintGCDetails</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">softRefMemoryNoEnough</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;========================&quot;</span>);        <span class="hljs-comment">// 创建一个强应用</span>        Object o1 = <span class="hljs-keyword">new</span> Object();        <span class="hljs-comment">// 创建一个软引用</span>        SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(o1);        System.out.println(o1);        System.out.println(softReference.get());        o1 = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 模拟OOM自动GC</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 创建30M的大对象</span>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">30</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(o1);            System.out.println(softReference.get());        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        softRefMemoryEnough();        softRefMemoryNoEnough();    &#125;&#125;</code></pre></div><p>我们写了两个方法，一个是内存够用的时候，一个是内存不够用的时候</p><p>我们首先查看内存够用的时候，首先输出的是 o1 和 软引用的 softReference，我们都能够看到值</p><p>然后我们把o1设置为null，执行手动GC后，我们发现softReference的值还存在，说明内存充足的时候，软引用的对象不会被回收</p><div class="code-wrapper"><pre><code class="hljs java">java.lang.Object@14ae5a5java.lang.Object@14ae5a5[GC (System.gc()) [PSYoungGen: 1396K-&gt;504K(1536K)] 1504K-&gt;732K(5632K), <span class="hljs-number">0.0007842</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] [<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 504K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(1536K)</span>] [ParOldGen: 228K-&gt;651<span class="hljs-title">K</span><span class="hljs-params">(4096K)</span>] 732K-&gt;651<span class="hljs-title">K</span><span class="hljs-params">(5632K)</span>, [Metaspace: 3480K-&gt;3480<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0058450 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <span class="hljs-keyword">null</span>java.lang.Object@14ae5a5</code></pre></div><p>下面我们看当内存不够的时候，我们使用了JVM启动参数配置，给初始化堆内存为5M</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms5m -Xmx5m -XX:+PrintGCDetails</span></code></pre></div><p>但是在创建对象的时候，我们创建了一个30M的大对象</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">// 创建30M的大对象</span><span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">30</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];</code></pre></div><p>这就必然会触发垃圾回收机制，这也是中间出现的垃圾回收过程，最后看结果我们发现，o1 和 softReference都被回收了，因此说明，软引用在内存不足的时候，会自动回收</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">Object</span><span class="hljs-operator">@</span><span class="hljs-number">7</span><span class="hljs-variable">f31245a</span><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">Object</span><span class="hljs-operator">@</span><span class="hljs-number">7</span><span class="hljs-variable">f31245a</span><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">31</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">160</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1536</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">682</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">811</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">5632</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0003603</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">160</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">96</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1536</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">811</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">747</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">5632</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0006385</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">96</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1536</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">651</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4096</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">747</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">5632</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3488</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3488</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0067976</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.02</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1536</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">5632</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0004024</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1536</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">627</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4096</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">627</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">5632</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3488</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3488</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0065506</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">null</span><span class="hljs-variable">null</span></code></pre></div><h4 id="5-弱引用"><a href="#5-弱引用" class="headerlink" title="5 弱引用"></a>5 弱引用</h4><p>不管内存是否够，只要有GC操作就会进行回收</p><p>弱引用需要用 <code>java.lang.ref.WeakReference</code> 类来实现，它比软引用生存期更短</p><p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的空间。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 弱引用</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeakReferenceDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Object o1 = <span class="hljs-keyword">new</span> Object();        WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(o1);        System.out.println(o1);        System.out.println(weakReference.get());        o1 = <span class="hljs-keyword">null</span>;        System.gc();        System.out.println(o1);        System.out.println(weakReference.get());    &#125;&#125;</code></pre></div><p>我们看结果，能够发现，我们并没有制造出OOM内存溢出，而只是调用了一下GC操作，垃圾回收就把它给收集了</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">Object</span><span class="hljs-operator">@</span><span class="hljs-number">14</span><span class="hljs-variable">ae5a5</span><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">Object</span><span class="hljs-operator">@</span><span class="hljs-number">14</span><span class="hljs-variable">ae5a5</span><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">5246</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5246</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0008236</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">8</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">675</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">675</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3494</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3494</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0035953</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">null</span><span class="hljs-variable">null</span></code></pre></div><h4 id="6-软引用和弱引用的使用场景"><a href="#6-软引用和弱引用的使用场景" class="headerlink" title="6 软引用和弱引用的使用场景"></a>6 软引用和弱引用的使用场景</h4><p>场景：假如有一个应用需要读取大量的本地图片</p><ul><li>如果每次读取图片都从硬盘读取则会严重影响性能</li><li>如果一次性全部加载到内存中，又可能造成内存溢出</li></ul><p>此时使用软引用可以解决这个问题</p><p>设计思路：使用HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占的空间，从而有效地避免了OOM的问题</p><div class="code-wrapper"><pre><code class="hljs java">Map&lt;String, SoftReference&lt;String&gt;&gt; imageCache = <span class="hljs-keyword">new</span> HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</code></pre></div><h5 id="WeakHashMap是什么？"><a href="#WeakHashMap是什么？" class="headerlink" title="WeakHashMap是什么？"></a>WeakHashMap是什么？</h5><p>比如一些常常和底层打交道的，mybatis等，底层都应用到了WeakHashMap</p><p>WeakHashMap和HashMap类似，只不过它的Key是使用了弱引用的，也就是说，当执行GC的时候，HashMap中的key会进行回收，下面我们使用例子来测试一下</p><p>我们使用了两个方法，一个是普通的HashMap方法</p><p>我们输入一个Key-Value键值对，然后让它的key置空，然后在查看结果</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myHashMap</span><span class="hljs-params">()</span> </span>&#123;    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    Integer key = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);    String value = <span class="hljs-string">&quot;HashMap&quot;</span>;    map.put(key, value);    System.out.println(map);    key = <span class="hljs-keyword">null</span>;    System.gc();    System.out.println(map);&#125;</code></pre></div><p>第二个是使用了WeakHashMap，完整代码如下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * WeakHashMap</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeakHashMapDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        myHashMap();        System.out.println(<span class="hljs-string">&quot;==========&quot;</span>);        myWeakHashMap();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myHashMap</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Integer key = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);        String value = <span class="hljs-string">&quot;HashMap&quot;</span>;        map.put(key, value);        System.out.println(map);        key = <span class="hljs-keyword">null</span>;        System.gc();        System.out.println(map);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myWeakHashMap</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;();        Integer key = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);        String value = <span class="hljs-string">&quot;WeakHashMap&quot;</span>;        map.put(key, value);        System.out.println(map);        key = <span class="hljs-keyword">null</span>;        System.gc();        System.out.println(map);    &#125;&#125;</code></pre></div><p>最后输出结果为：</p><div class="code-wrapper"><pre><code class="hljs java">&#123;<span class="hljs-number">1</span>=HashMap&#125;&#123;<span class="hljs-number">1</span>=HashMap&#125;==========&#123;<span class="hljs-number">1</span>=WeakHashMap&#125;&#123;&#125;</code></pre></div><p>从这里我们看到，对于普通的HashMap来说，key置空并不会影响，HashMap的键值对，因为这个属于强引用，不会被垃圾回收。</p><p>但是WeakHashMap，在进行GC操作后，弱引用的就会被回收</p><h4 id="7-虚引用"><a href="#7-虚引用" class="headerlink" title="7 虚引用"></a>7 虚引用</h4><h5 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 概念</h5><p>虚引用又称为幽灵引用，需要<code>java.lang.ref.PhantomReference</code> 类来实现</p><p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p><p>如果一个对象持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列ReferenceQueue联合使用。</p><p>虚引用的主要作用和跟踪对象被垃圾回收的状态，仅仅是提供一种确保对象被finalize以后，做某些事情的机制。</p><p>PhantomReference的get方法总是返回null，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p><p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候，收到一个系统通知或者后续添加进一步的处理，Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前，做必要的清理工作</p><p>这个就相当于Spring AOP里面的后置通知</p><h5 id="7-2-场景"><a href="#7-2-场景" class="headerlink" title="7.2 场景"></a>7.2 场景</h5><p>一般用于在回收时候做通知相关操作</p><h4 id="8-引用队列-ReferenceQueue"><a href="#8-引用队列-ReferenceQueue" class="headerlink" title="8 引用队列 ReferenceQueue"></a>8 引用队列 ReferenceQueue</h4><p>软引用，弱引用，虚引用在回收之前，需要在引用队列保存一下</p><p>我们在初始化的弱引用或者虚引用的时候，可以传入一个引用队列</p><div class="code-wrapper"><pre><code class="hljs java">Object o1 = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">// 创建引用队列</span>ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<span class="hljs-comment">// 创建一个弱引用</span>WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(o1, referenceQueue);</code></pre></div><p>那么在进行GC回收的时候，弱引用和虚引用的对象都会被回收，但是在回收之前，它会被送至引用队列中</p><p>完整代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 虚引用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhantomReferenceDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Object o1 = <span class="hljs-keyword">new</span> Object();        <span class="hljs-comment">// 创建引用队列</span>        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();        <span class="hljs-comment">// 创建一个弱引用</span>        WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(o1, referenceQueue);        <span class="hljs-comment">// 创建一个弱引用</span><span class="hljs-comment">//        PhantomReference&lt;Object&gt; weakReference = new PhantomReference&lt;&gt;(o1, referenceQueue);</span>        System.out.println(o1);        System.out.println(weakReference.get());        <span class="hljs-comment">// 取队列中的内容</span>        System.out.println(referenceQueue.poll());        o1 = <span class="hljs-keyword">null</span>;        System.gc();        System.out.println(<span class="hljs-string">&quot;执行GC操作&quot;</span>);        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(o1);        System.out.println(weakReference.get());        <span class="hljs-comment">// 取队列中的内容</span>        System.out.println(referenceQueue.poll());    &#125;&#125;</code></pre></div><p>运行结果</p><div class="code-wrapper"><pre><code class="hljs angelscript">java.lang.<span class="hljs-symbol">Object@</span><span class="hljs-number">14</span>ae5a5java.lang.<span class="hljs-symbol">Object@</span><span class="hljs-number">14</span>ae5a5<span class="hljs-literal">null</span>执行GC操作<span class="hljs-literal">null</span><span class="hljs-literal">null</span>java.lang.<span class="hljs-built_in">ref</span>.<span class="hljs-symbol">WeakReference@</span><span class="hljs-number">7f</span>3124</code></pre></div><p>从这里我们能看到，在进行垃圾回收后，我们弱引用对象，也被设置成null，但是在队列中还能够导出该引用的实例，这就说明在回收之前，该弱引用的实例被放置引用队列中了，我们可以通过引用队列进行一些后置操作</p><h4 id="9-GCRoots和四大引用小总结"><a href="#9-GCRoots和四大引用小总结" class="headerlink" title="9 GCRoots和四大引用小总结"></a>9 GCRoots和四大引用小总结</h4><ul><li><p>红色部分在垃圾回收之外，也就是强引用的</p></li><li><p>蓝色部分：属于软引用，在内存不够的时候，才回收</p></li><li><p>虚引用和弱引用：每次垃圾回收的时候，都会被干掉，但是它在干掉之前还会存在引用队列中，我们可以通过引用队列进行一些通知机制</p></li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200324123829937.png" alt="image-20200324123829937"></p><h3 id="2-4-Java内存溢出OOM"><a href="#2-4-Java内存溢出OOM" class="headerlink" title="2.4 Java内存溢出OOM"></a>2.4 Java内存溢出OOM</h3><h4 id="1-经典错误"><a href="#1-经典错误" class="headerlink" title="1 经典错误"></a>1 经典错误</h4><p>JVM中常见的两个错误</p><p>StackoverFlowError ：栈溢出</p><p>OutofMemoryError: java heap space：堆溢出</p><p>除此之外，还有以下的错误</p><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><h4 id="2-架构"><a href="#2-架构" class="headerlink" title="2 架构"></a>2 架构</h4><p>OutOfMemoryError和StackOverflowError是属于Error，不是Exception</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200324144802828.png" alt="image-20200324144802828"></p><h4 id="3-StackoverFlowError"><a href="#3-StackoverFlowError" class="headerlink" title="3 StackoverFlowError"></a>3 StackoverFlowError</h4><p>堆栈溢出，我们有最简单的一个递归调用，就会造成堆栈溢出，也就是深度的方法调用</p><p>栈一般是512K，不断的深度调用，直到栈被撑破</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackOverflowErrorDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        stackOverflowError();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 栈一般是512K，不断的深度调用，直到栈被撑破</span><span class="hljs-comment">     * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stackOverflowError</span><span class="hljs-params">()</span> </span>&#123;        stackOverflowError();    &#125;&#125;</code></pre></div><p>运行结果</p><div class="code-wrapper"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowErrorat com.moxi.interview.study.oom.StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:<span class="hljs-number">17</span>)</code></pre></div><h4 id="4-OutOfMemoryError"><a href="#4-OutOfMemoryError" class="headerlink" title="4 OutOfMemoryError"></a>4 OutOfMemoryError</h4><h5 id="4-1-java-heap-space"><a href="#4-1-java-heap-space" class="headerlink" title="4.1 java heap space"></a>4.1 java heap space</h5><p>创建了很多对象，导致堆空间不够存储</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Java堆内存不足</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaHeapSpaceDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 堆空间的大小 -Xms10m -Xmx10m</span>        <span class="hljs-comment">// 创建一个 80M的字节数组</span>        <span class="hljs-keyword">byte</span> [] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">80</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];    &#125;&#125;</code></pre></div><p>我们创建一个80M的数组，会直接出现Java heap space</p><div class="code-wrapper"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</code></pre></div><h5 id="4-2-GC-overhead-limit-exceeded"><a href="#4-2-GC-overhead-limit-exceeded" class="headerlink" title="4.2 GC overhead limit exceeded"></a>4.2 GC overhead limit exceeded</h5><p>GC回收时间过长时会抛出OutOfMemoryError，过长的定义是，超过了98%的时间用来做GC，并且回收了不到2%的堆内存</p><p>连续多次GC都只回收了不到2%的极端情况下，才会抛出。假设不抛出GC overhead limit 错误会造成什么情况呢？</p><p>那就是GC清理的这点内存很快会再次被填满，迫使GC再次执行，这样就形成了恶性循环，CPU的使用率一直都是100%，而GC却没有任何成果。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200324150646260.png" alt="image-20200324150646260"></p><p>代码演示：</p><p>为了更快的达到效果，我们首先需要设置JVM启动参数</p><div class="code-wrapper"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code></pre></div><p>这个异常出现的步骤就是，我们不断的像list中插入String对象，直到启动GC回收</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * GC 回收超时</span><span class="hljs-comment"> * JVM参数配置: -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCOverheadLimitDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;                list.add(String.valueOf(++i).intern());            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(<span class="hljs-string">&quot;***************i:&quot;</span> + i);            e.printStackTrace();            <span class="hljs-keyword">throw</span> e;        &#125; <span class="hljs-keyword">finally</span> &#123;        &#125;    &#125;&#125;</code></pre></div><p>运行结果</p><div class="code-wrapper"><pre><code class="hljs java">[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;2047<span class="hljs-title">K</span><span class="hljs-params">(2560K)</span>] [ParOldGen: 7106K-&gt;7106<span class="hljs-title">K</span><span class="hljs-params">(7168K)</span>] 9154K-&gt;9154<span class="hljs-title">K</span><span class="hljs-params">(9728K)</span>, [Metaspace: 3504K-&gt;3504<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0311093 secs] [Times: user</span>=<span class="hljs-number">0.13</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.03</span> secs] [<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(2560K)</span>] [ParOldGen: 7136K-&gt;667<span class="hljs-title">K</span><span class="hljs-params">(7168K)</span>] 9184K-&gt;667<span class="hljs-title">K</span><span class="hljs-params">(9728K)</span>, [Metaspace: 3540K-&gt;3540<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0058093 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] Heap PSYoungGen      total 2560K, used 114K [<span class="hljs-number">0x00000000ffd00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)  eden space 2048K, <span class="hljs-number">5</span>% used [<span class="hljs-number">0x00000000ffd00000</span>,<span class="hljs-number">0x00000000ffd1c878</span>,<span class="hljs-number">0x00000000fff00000</span>)  from space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x0000000100000000</span>)  to   space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff80000</span>) ParOldGen       total 7168K, used 667K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ffd00000</span>, <span class="hljs-number">0x00000000ffd00000</span>)  object space 7168K, <span class="hljs-number">9</span>% used [<span class="hljs-number">0x00000000ff600000</span>,<span class="hljs-number">0x00000000ff6a6ff8</span>,<span class="hljs-number">0x00000000ffd00000</span>) Metaspace       used 3605K, capacity 4540K, committed 4864K, reserved 1056768K  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 399<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 428<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><span class="hljs-class">  </span><span class="hljs-class"> </span>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceededat java.lang.Integer.toString(Integer.java:<span class="hljs-number">403</span>)at java.lang.String.valueOf(String.java:<span class="hljs-number">3099</span>)at com.moxi.interview.study.oom.GCOverheadLimitDemo.main(GCOverheadLimitDemo.java:<span class="hljs-number">18</span>)</code></pre></div><p>我们能够看到 多次Full GC，并没有清理出空间，在多次执行GC操作后，就抛出异常 GC overhead limit</p><h5 id="4-3-Direct-buffer-memory"><a href="#4-3-Direct-buffer-memory" class="headerlink" title="4.3 Direct buffer memory"></a>4.3 Direct buffer memory</h5><p>Netty + NIO：这是由于NIO引起的</p><p>写NIO程序的时候经常会使用ByteBuffer来读取或写入数据，这是一种基于通道(Channel) 与 缓冲区(Buffer)的I/O方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>ByteBuffer.allocate(capability)：第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢</p><p>ByteBuffer.allocteDirect(capability)：第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存的拷贝，所以速度相对较快</p><p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会被回收，这时候怼内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那么程序就奔溃了。</p><p>一句话说：本地内存不足，但是堆内存充足的时候，就会出现这个问题</p><p>我们使用 -XX:MaxDirectMemorySize=5m 配置能使用的堆外物理内存为5M</p><div class="code-wrapper"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code></pre></div><p>然后我们申请一个6M的空间</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 只设置了5M的物理内存使用，但是却分配 6M的空间</span>ByteBuffer bb = ByteBuffer.allocateDirect(<span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);</code></pre></div><p>这个时候，运行就会出现问题了</p><div class="code-wrapper"><pre><code class="hljs java">配置的maxDirectMemory：<span class="hljs-number">5.</span>0MB[GC (System.gc()) [PSYoungGen: 2030K-&gt;488K(2560K)] 2030K-&gt;796K(9728K), <span class="hljs-number">0.0008326</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] [<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 488K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(2560K)</span>] [ParOldGen: 308K-&gt;712<span class="hljs-title">K</span><span class="hljs-params">(7168K)</span>] 796K-&gt;712<span class="hljs-title">K</span><span class="hljs-params">(9728K)</span>, [Metaspace: 3512K-&gt;3512<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0052052 secs] [Times: user</span>=<span class="hljs-number">0.09</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memoryat java.nio.Bits.reserveMemory(Bits.java:<span class="hljs-number">693</span>)at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="hljs-number">123</span>)at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="hljs-number">311</span>)at com.moxi.interview.study.oom.DIrectBufferMemoryDemo.main(DIrectBufferMemoryDemo.java:<span class="hljs-number">19</span>)</code></pre></div><h5 id="4-4-unable-to-create-new-native-thread"><a href="#4-4-unable-to-create-new-native-thread" class="headerlink" title="4.4 unable to create new native thread"></a>4.4 unable to create new native thread</h5><p>不能够创建更多的新的线程了，也就是说创建线程的上限达到了</p><p>在高并发场景的时候，会应用到</p><p>高并发请求服务器时，经常会出现如下异常<code>java.lang.OutOfMemoryError:unable to create new native thread</code>，准确说该native thread异常与对应的平台有关</p><p>导致原因：</p><ul><li>应用创建了太多线程，一个应用进程创建多个线程，超过系统承载极限</li><li>服务器并不允许你的应用程序创建这么多线程，linux系统默认运行单个进程可以创建的线程为1024个，如果应用创建超过这个数量，就会报 <code>java.lang.OutOfMemoryError:unable to create new native thread</code></li></ul><p>解决方法：</p><ol><li>想办法降低你应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低</li><li>对于有的应用，确实需要创建很多线程，远超过linux系统默认1024个线程限制，可以通过修改linux服务器配置，扩大linux默认限制</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 无法创建更多的线程</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnableCreateNewThreadDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;            System.out.println(<span class="hljs-string">&quot;************** i = &quot;</span> + i);            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><p>这个时候，就会出现下列的错误，线程数大概在 900多个</p><div class="code-wrapper"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: unable to cerate <span class="hljs-keyword">new</span> <span class="hljs-keyword">native</span> thread</code></pre></div><p>如何查看线程数</p><div class="code-wrapper"><pre><code class="hljs java">ulimit -u</code></pre></div><h5 id="4-5-Metaspace"><a href="#4-5-Metaspace" class="headerlink" title="4.5 Metaspace"></a>4.5 Metaspace</h5><p>元空间内存不足，Matespace元空间应用的是本地内存</p><p><code>-XX:MetaspaceSize</code> 的处理化大小为20M</p><h6 id="元空间是什么"><a href="#元空间是什么" class="headerlink" title="元空间是什么"></a>元空间是什么</h6><p>元空间就是我们的方法区，存放的是类模板，类信息，常量池等</p><p>Metaspace是方法区HotSpot中的实现，它与持久代最大的区别在于：Metaspace并不在虚拟内存中，而是使用本地内存，也即在java8中，class metadata（the virtual machines internal presentation of Java class），被存储在叫做Matespace的native memory</p><p>永久代（java8后背元空间Metaspace取代了）存放了以下信息：</p><ul><li>虚拟机加载的类信息</li><li>常量池</li><li>静态变量</li><li>即时编译后的代码</li></ul><p>模拟Metaspace空间溢出，我们不断生成类 往元空间里灌输，类占据的空间总会超过Metaspace指定的空间大小</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><p>在模拟异常生成时候，因为初始化的元空间为20M，因此我们使用JVM参数调整元空间的大小，为了更好的效果</p><div class="code-wrapper"><pre><code class="hljs java">-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</code></pre></div><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 元空间溢出</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MetaspaceOutOfMemoryDemo</span> </span>&#123;    <span class="hljs-comment">// 静态类</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMTest</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> </span>&#123;        <span class="hljs-comment">// 模拟计数多少次以后发生异常</span>        <span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                i++;                <span class="hljs-comment">// 使用Spring的动态字节码技术</span>                Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();                enhancer.setSuperclass(OOMTest.class);                enhancer.setUseCache(<span class="hljs-keyword">false</span>);                enhancer.setCallback(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                        <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o, args);                    &#125;                &#125;);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.out.println(<span class="hljs-string">&quot;发生异常的次数:&quot;</span> + i);            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;        &#125;    &#125;&#125;</code></pre></div><p>会出现以下错误：</p><div class="code-wrapper"><pre><code class="hljs java">发生异常的次数: <span class="hljs-number">201</span>java.lang.OutOfMemoryError:Metaspace</code></pre></div><h3 id="2-5-垃圾收集器"><a href="#2-5-垃圾收集器" class="headerlink" title="2.5 垃圾收集器"></a>2.5 垃圾收集器</h3><h4 id="1-GC垃圾回收算法和垃圾收集器关系"><a href="#1-GC垃圾回收算法和垃圾收集器关系" class="headerlink" title="1 GC垃圾回收算法和垃圾收集器关系"></a>1 GC垃圾回收算法和垃圾收集器关系</h4><blockquote><p>天上飞的理念，要有落地的实现（垃圾收集器就是GC垃圾回收算法的实现）</p><p>GC算法是内存回收的方法论，垃圾收集器就是算法的落地实现</p></blockquote><p>GC算法主要有以下几种</p><ul><li>引用计数（几乎不用，无法解决循环引用的问题）</li><li>复制拷贝（用于新生代）</li><li>标记清除（用于老年代）</li><li>标记整理（用于老年代）</li></ul><p>因为目前为止还没有完美的收集器出现，更没有万能的收集器，只是针对具体应用最合适的收集器，进行分代收集（那个代用什么收集器）</p><h4 id="2-四种主要的垃圾收集器"><a href="#2-四种主要的垃圾收集器" class="headerlink" title="2 四种主要的垃圾收集器"></a>2 四种主要的垃圾收集器</h4><ul><li>Serial：串行回收  <code>-XX:+UseSeriallGC</code></li><li>Parallel：并行回收  <code>-XX:+UseParallelGC</code></li><li>CMS：并发标记清除</li><li>G1</li><li>ZGC：（java 11 出现的）</li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325084453631.png" alt="image-20200325084453631"></p><h5 id="2-1-Serial"><a href="#2-1-Serial" class="headerlink" title="2.1 Serial"></a>2.1 Serial</h5><p>串行垃圾回收器，它为单线程环境设计且值使用一个线程进行垃圾收集，会暂停所有的用户线程，只有当垃圾回收完成时，才会重新唤醒主线程继续执行。所以不适合服务器环境</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325085320683.png" alt="image-20200325085320683"></p><h5 id="2-2-Parallel"><a href="#2-2-Parallel" class="headerlink" title="2.2 Parallel"></a>2.2 Parallel</h5><p>并行垃圾收集器，多个垃圾收集线程并行工作，此时用户线程也是阻塞的，适用于科学计算 / 大数据处理等弱交互场景，也就是说Serial 和 Parallel其实是类似的，不过是多了几个线程进行垃圾收集，但是主线程都会被暂停，但是并行垃圾收集器处理时间，肯定比串行的垃圾收集器要更短</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325085729428.png" alt="image-20200325085729428"></p><h5 id="2-3-CMS"><a href="#2-3-CMS" class="headerlink" title="2.3 CMS"></a>2.3 CMS</h5><p>并发标记清除，用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），不需要停顿用户线程，互联网公司都在使用，适用于响应时间有要求的场景。并发是可以有交互的，也就是说可以一边进行收集，一边执行应用程序。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325090858921.png" alt="image-20200325090858921"></p><h5 id="2-4-G1"><a href="#2-4-G1" class="headerlink" title="2.4 G1"></a>2.4 G1</h5><p>G1垃圾回收器将堆内存分割成不同区域，然后并发的进行垃圾回收</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325093222711.png" alt="image-20200325093222711"></p><h4 id="3-垃圾收集器总结"><a href="#3-垃圾收集器总结" class="headerlink" title="3 垃圾收集器总结"></a>3 垃圾收集器总结</h4><p>注意：并行垃圾回收在单核CPU下可能会更慢</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325091619082.png" alt="image-20200325091619082"></p><h4 id="4-查看默认垃圾收集器"><a href="#4-查看默认垃圾收集器" class="headerlink" title="4 查看默认垃圾收集器"></a>4 查看默认垃圾收集器</h4><p>使用下面JVM命令，查看配置的初始参数</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+PrintCommandLineFlags</span></code></pre></div><p>然后运行一个程序后，能够看到它的一些初始配置信息</p><div class="code-wrapper"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">InitialHeapSize</span>=266376000 -XX:<span class="hljs-attribute">MaxHeapSize</span>=4262016000 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</code></pre></div><p>移动到最后一句，就能看到 <code>-XX:+UseParallelGC</code> 说明使用的是并行垃圾回收</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+UseParallelGC</span></code></pre></div><h4 id="5-默认垃圾收集器有哪些"><a href="#5-默认垃圾收集器有哪些" class="headerlink" title="5 默认垃圾收集器有哪些"></a>5 默认垃圾收集器有哪些</h4><p>Java中一共有7大垃圾收集器</p><ul><li>UserSerialGC：串行垃圾收集器</li><li>UserParallelGC：并行垃圾收集器</li><li>UseConcMarkSweepGC：（CMS）并发标记清除</li><li>UseParNewGC：年轻代的并行垃圾回收器</li><li>UseParallelOldGC：老年代的并行垃圾回收器</li><li>UseG1GC：G1垃圾收集器</li><li>UserSerialOldGC：串行老年代垃圾收集器（已经被移除）</li></ul><p>底层源码</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325100653829-16280006180638.png" alt="image-20200325100653829"></p><h4 id="6-各垃圾收集器的使用范围"><a href="#6-各垃圾收集器的使用范围" class="headerlink" title="6 各垃圾收集器的使用范围"></a>6 各垃圾收集器的使用范围</h4><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325101451849.png" alt="image-20200325101451849"></p><p>新生代使用的：</p><ul><li>Serial Copying： UserSerialGC，串行垃圾回收器</li><li>Parallel Scavenge：UserParallelGC，并行垃圾收集器</li><li>ParNew：UserParNewGC，新生代并行垃圾收集器</li></ul><p>老年区使用的：</p><ul><li>Serial Old：UseSerialOldGC，老年代串行垃圾收集器</li><li>Parallel Compacting（Parallel Old）：UseParallelOldGC，老年代并行垃圾收集器</li><li>CMS：UseConcMarkSwepp，并行标记清除垃圾收集器</li></ul><p>各区都能使用的：</p><p>G1：UseG1GC，G1垃圾收集器</p><p>垃圾收集器就来具体实现这些GC算法并实现内存回收，不同厂商，不同版本的虚拟机实现差别很大，HotSpot中包含的收集器如下图所示：</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325102329216.png" alt="image-20200325102329216"></p><h4 id="7-部分参数说明"><a href="#7-部分参数说明" class="headerlink" title="7 部分参数说明"></a>7 部分参数说明</h4><ul><li>DefNew：Default New Generation</li><li>Tenured：Old</li><li>ParNew：Parallel New Generation</li><li>PSYoungGen：Parallel Scavenge</li><li>ParOldGen：Parallel Old Generation</li></ul><h4 id="8-Java中的Server和Client模式"><a href="#8-Java中的Server和Client模式" class="headerlink" title="8  Java中的Server和Client模式"></a>8  Java中的Server和Client模式</h4><p>使用范围：一般使用Server模式，Client模式基本不会使用</p><p>操作系统</p><ul><li>32位的Window操作系统，不论硬件如何都默认使用Client的JVM模式</li><li>32位的其它操作系统，2G内存同时有2个cpu以上用Server模式，低于该配置还是Client模式</li><li>64位只有Server模式</li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325175208231.png" alt="image-20200325175208231"></p><h4 id="9-新生代下的垃圾收集器"><a href="#9-新生代下的垃圾收集器" class="headerlink" title="9 新生代下的垃圾收集器"></a>9 新生代下的垃圾收集器</h4><h5 id="9-1-串行GC-Serial"><a href="#9-1-串行GC-Serial" class="headerlink" title="9.1 串行GC(Serial)"></a>9.1 串行GC(Serial)</h5><p>串行GC（Serial）（Serial Copying）</p><p>是一个单线程单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325175704604.png" alt="image-20200325175704604"></p><p>串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在垃圾收集过程中可能会产生较长的停顿(Stop-The-World 状态)。 虽然在收集垃圾过程中需要暂停所有其它的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是Java虚拟机运行在Client模式下默认的新生代垃圾收集器</p><p>对应JVM参数是：-XX:+UseSerialGC</p><p>开启后会使用：Serial(Young区用) + Serial Old(Old区用) 的收集器组合</p><p>表示：新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialGC</span></code></pre></div><h5 id="9-2-并行GC-ParNew"><a href="#9-2-并行GC-ParNew" class="headerlink" title="9.2 并行GC(ParNew)"></a>9.2 并行GC(ParNew)</h5><p>并行收集器，使用多线程进行垃圾回收，在垃圾收集，会Stop-the-World暂停其他所有的工作线程直到它收集结束</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325191328733.png" alt="image-20200325191328733"></p><p>ParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景时配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。它是很多Java虚拟机运行在Server模式下新生代的默认垃圾收集器。</p><p>常见对应JVM参数：-XX:+UseParNewGC     启动ParNew收集器，只影响新生代的收集，不影响老年代</p><p>开启上述参数后，会使用：ParNew（Young区用） + Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParNewGC</span></code></pre></div><p>但是会出现警告，即 ParNew 和 Serial Old 这样搭配，Java8已经不再被推荐</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325194316660.png" alt="image-20200325194316660"></p><p>备注： -XX:ParallelGCThreads   限制线程数量，默认开启和CPU数目相同的线程数</p><h5 id="9-3-并行回收GC（Parallel）-（Parallel-Scavenge）"><a href="#9-3-并行回收GC（Parallel）-（Parallel-Scavenge）" class="headerlink" title="9.3 并行回收GC（Parallel）/ （Parallel Scavenge）"></a>9.3 并行回收GC（Parallel）/ （Parallel Scavenge）</h5><p>因为Serial 和 ParNew都不推荐使用了，因此现在新生代默认使用的是Parallel Scavenge，也就是新生代和老年代都是使用并行</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325204437678.png" alt="image-20200325204437678"></p><p>Parallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。一句话：串行收集器在新生代和老年代的并行化</p><p>它关注的重点是：</p><p>可控制的吞吐量（Thoughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) ），也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%。高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。</p><p>自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间( -XX:MaxGCPauseMills)）或最大的吞吐量。</p><p>常用JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC（可互相激活）使用Parallel Scanvenge收集器</p><p>开启该参数后：新生代使用复制算法，老年代使用标记-整理算法</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelGC</span></code></pre></div><h4 id="10-老年代下的垃圾收集器"><a href="#10-老年代下的垃圾收集器" class="headerlink" title="10 老年代下的垃圾收集器"></a>10 老年代下的垃圾收集器</h4><h5 id="10-1-串行GC（Serial-Old）-Serial-MSC"><a href="#10-1-串行GC（Serial-Old）-Serial-MSC" class="headerlink" title="10.1 串行GC（Serial Old） / (Serial MSC)"></a>10.1 串行GC（Serial Old） / (Serial MSC)</h5><p>Serial Old是Serial垃圾收集器老年代版本，它同样是一个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的Java虚拟机中默认的老年代垃圾收集器</p><p>在Server模式下，主要有两个用途（了解，版本已经到8及以后）</p><ul><li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用（Parallel Scavenge + Serial Old）</li><li>作为老年代版中使用CMS收集器的后备垃圾收集方案。</li></ul><p>配置方法：</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialOldlGC</span></code></pre></div><p>该垃圾收集器，目前已经不推荐使用了</p><h5 id="10-2-并行GC（Parallel-Old）-（Parallel-MSC）"><a href="#10-2-并行GC（Parallel-Old）-（Parallel-MSC）" class="headerlink" title="10.2 并行GC（Parallel Old）/ （Parallel MSC）"></a>10.2 并行GC（Parallel Old）/ （Parallel MSC）</h5><p>Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。</p><p>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6以前(Parallel Scavenge + Serial Old)</p><p>Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8后可以考虑新生代Parallel Scavenge和老年代Parallel Old 收集器的搭配策略。在JDK1.8及后（Parallel Scavenge + Parallel Old）</p><p>JVM常用参数：</p><div class="code-wrapper"><pre><code class="hljs oxygene">-XX +UseParallelOldGC：使用<span class="hljs-keyword">Parallel</span> <span class="hljs-keyword">Old</span>收集器，设置该参数后，新生代<span class="hljs-keyword">Parallel</span>+老年代 <span class="hljs-keyword">Parallel</span> <span class="hljs-keyword">Old</span></code></pre></div><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325211525152.png" alt="image-20200325211525152"></p><p>使用老年代并行收集器：</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelOldlGC</span></code></pre></div><h5 id="10-3-并发标记清除GC（CMS）"><a href="#10-3-并发标记清除GC（CMS）" class="headerlink" title="10.3 并发标记清除GC（CMS）"></a>10.3 并发标记清除GC（CMS）</h5><p>CMS收集器（Concurrent Mark Sweep：并发标记清除）是一种以最短回收停顿时间为目标的收集器</p><p>适合应用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。</p><p>CMS非常适合堆内存大，CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325212836441.png" alt="image-20200325212836441"></p><p>Concurrent Mark Sweep：并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行</p><p>开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC  开启该参数后，会自动将 -XX:+UseParNewGC打开，开启该参数后，使用ParNew(young 区用）+ CMS（Old 区用） + Serial Old 的收集器组合，Serial Old将作为CMS出错的后备收集器</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC</span></code></pre></div><h6 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h6><ul><li>初始标记（CMS initial mark）<ul><li>只是标记一个GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程</li></ul></li><li>并发标记（CMS concurrent mark）和用户线程一起<ul><li>进行GC Roots跟踪过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象</li></ul></li><li>重新标记（CMS remark）<ul><li>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程，由于并发标记时，用户线程依然运行，因此在正式清理前，在做修正</li></ul></li><li>并发清除（CMS concurrent sweep）和用户线程一起<ul><li>清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象，由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</li></ul></li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325215401981-162800094846319.png" alt="image-20200325215401981"></p><p>优点：并发收集低停顿</p><p>缺点：并发执行，对CPU资源压力大，采用的标记清除算法会导致大量碎片</p><p>由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS必须在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW方式进行一次GC，从而造成较大的停顿时间</p><p>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩，CMS也提供了参数 -XX:CMSFullGCSBeForeCompaction（默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC</p><h4 id="11-为什么新生代采用复制算法，老年代采用标整算法"><a href="#11-为什么新生代采用复制算法，老年代采用标整算法" class="headerlink" title="11 为什么新生代采用复制算法，老年代采用标整算法"></a>11 为什么新生代采用复制算法，老年代采用标整算法</h4><h5 id="11-1-新生代使用复制算法"><a href="#11-1-新生代使用复制算法" class="headerlink" title="11.1 新生代使用复制算法"></a>11.1 新生代使用复制算法</h5><p>因为新生代对象的生存时间比较短，80%的都要回收的对象，采用标记-清除算法则内存碎片化比较严重，采用复制算法可以灵活高效，且便与整理空间。</p><h5 id="11-2-老年代采用标记整理"><a href="#11-2-老年代采用标记整理" class="headerlink" title="11.2 老年代采用标记整理"></a>11.2 老年代采用标记整理</h5><p>标记整理算法主要是为了解决标记清除算法存在内存碎片的问题，又解决了复制算法两个Survivor区的问题，因为老年代的空间比较大，不可能采用复制算法，特别占用内存空间</p><h4 id="12-垃圾收集器如何选择"><a href="#12-垃圾收集器如何选择" class="headerlink" title="12 垃圾收集器如何选择"></a>12 垃圾收集器如何选择</h4><h5 id="组合的选择"><a href="#组合的选择" class="headerlink" title="组合的选择"></a>组合的选择</h5><ul><li>单CPU或者小内存，单机程序<ul><li>-XX:+UseSerialGC</li></ul></li><li>多CPU，需要最大的吞吐量，如后台计算型应用<ul><li>-XX:+UseParallelGC（这两个相互激活）</li><li>-XX:+UseParallelOldGC</li></ul></li><li>多CPU，追求低停顿时间，需要快速响应如互联网应用<ul><li>-XX:+UseConcMarkSweepGC</li><li>-XX:+ParNewGC</li></ul></li></ul><table><thead><tr><th align="center">参数</th><th align="center">新生代垃圾收集器</th><th align="center">新生代算法</th><th align="center">老年代垃圾收集器</th><th align="center">老年代算法</th></tr></thead><tbody><tr><td align="center">-XX:+UseSerialGC</td><td align="center">SerialGC</td><td align="center">复制</td><td align="center">SerialOldGC</td><td align="center">标记整理</td></tr><tr><td align="center">-XX:+UseParNewGC</td><td align="center">ParNew</td><td align="center">复制</td><td align="center">SerialOldGC</td><td align="center">标记整理</td></tr><tr><td align="center">-XX:+UseParallelGC</td><td align="center">Parallel [Scavenge]</td><td align="center">复制</td><td align="center">Parallel Old</td><td align="center">标记整理</td></tr><tr><td align="center">-XX:+UseConcMarkSweepGC</td><td align="center">ParNew</td><td align="center">复制</td><td align="center">CMS + Serial Old的收集器组合，Serial Old作为CMS出错的后备收集器</td><td align="center">标记清除</td></tr><tr><td align="center">-XX:+UseG1GC</td><td align="center">G1整体上采用标记整理算法</td><td align="center">局部复制</td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="13-G1垃圾收集器"><a href="#13-G1垃圾收集器" class="headerlink" title="13 G1垃圾收集器"></a>13 G1垃圾收集器</h4><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326115120405.png" alt="image-20200326115120405"></p><h5 id="13-1-开启G1垃圾收集器"><a href="#13-1-开启G1垃圾收集器" class="headerlink" title="13.1 开启G1垃圾收集器"></a>13.1 开启G1垃圾收集器</h5><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+UseG1GC</span></code></pre></div><h5 id="13-2-以前收集器的特点"><a href="#13-2-以前收集器的特点" class="headerlink" title="13.2 以前收集器的特点"></a>13.2 以前收集器的特点</h5><ul><li>年轻代和老年代是各自独立且连续的内存块</li><li>年轻代收集使用单eden + S0 + S1 进行复制算法</li><li>老年代收集必须扫描珍整个老年代区域</li><li>都是以尽可能少而快速地执行GC为设计原则</li></ul><h5 id="13-3-G1是什么"><a href="#13-3-G1是什么" class="headerlink" title="13.3 G1是什么"></a>13.3 G1是什么</h5><p>G1：Garbage-First 收集器，是一款面向服务端应用的收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能满足垃圾收集暂停时间的要求。另外，它还具有一下特征：</p><ul><li>像CMS收集器一样，能与应用程序并发执行</li><li>整理空闲空间更快</li><li>需要更多的时间来预测GC停顿时间</li><li>不希望牺牲大量的吞吐量性能</li><li>不需要更大的Java Heap</li></ul><p>G1收集器设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色</p><ul><li>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。</li><li>G1的Stop The World（STW）更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</li></ul><p>CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器-G1垃圾收集器</p><p>G1是在2012奶奶才在JDK1.7中可用，Oracle官方计划在JDK9中将G1变成默认的垃圾收集器以替代CMS，它是一款面向服务端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换Java8以前的CMS收集器</p><p>主要改变时：Eden，Survivor和Tenured等内存区域不再是连续了，而是变成一个个大小一样的region，每个region从1M到32M不等。一个region有可能属于Eden，Survivor或者Tenured内存区域。</p><h5 id="13-4-特点"><a href="#13-4-特点" class="headerlink" title="13.4 特点"></a>13.4 特点</h5><ul><li>G1能充分利用多CPU，多核环境硬件优势，尽量缩短STW</li><li>G1整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片</li><li>宏观上看G1之中不再区分年轻代和老年代。把内存划分成多个独立的子区域（Region），可以近似理解为一个围棋的棋盘</li><li>G1收集器里面将整个内存区域都混合在一起了，但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代，但他们不再是物理隔离的，而是通过一部分Region的集合且不需要Region是连续的，也就是说依然会采取不同的GC方式来处理不同的区域</li><li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代和老年代的区别，也不需要完全独立的Survivor（to space）堆做复制准备，G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换。</li></ul><h5 id="13-5-底层原理"><a href="#13-5-底层原理" class="headerlink" title="13.5 底层原理"></a>13.5 底层原理</h5><p>Region区域化垃圾收集器，化整为零，打破了原来新生区和老年区的壁垒，避免了全内存扫描，只需要按照区域来进行扫描即可。</p><p>区域化内存划片Region，整体遍为了一些列不连续的内存区域，避免了全内存区的GC操作。</p><p>核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动时会自动设置子区域大小</p><p>在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code> 可指定分区大小（1MB~32MB，且必须是2的幂），默认将整堆划分为2048个分区。</p><p>大小范围在1MB~32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048 = 64G内存</p><p>Region区域化垃圾收集器</p><h5 id="13-6-Region区域化垃圾收集器"><a href="#13-6-Region区域化垃圾收集器" class="headerlink" title="13.6 Region区域化垃圾收集器"></a>13.6 Region区域化垃圾收集器</h5><p>G1将新生代、老年代的物理空间划分取消了</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326120105859.png" alt="image-20200326120105859"></p><p>同时对内存进行了区域划分</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326120130427.png" alt="image-20200326120130427"></p><p>G1算法将堆划分为若干个区域（Reign），它仍然属于分代收集器，这些Region的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间</p><p>这些Region的一部分包含老年代，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片的问题存在了。</p><p>在G1中，还有一种特殊的区域，叫做Humongous（巨大的）区域，如果一个对象占用了空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象，这些巨型对象默认直接分配在老年代，但是如果他是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响，为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H区来存储，为了能找到连续的H区，有时候不得不启动Full GC。</p><h5 id="13-7-回收步骤"><a href="#13-7-回收步骤" class="headerlink" title="13.7 回收步骤"></a>13.7 回收步骤</h5><p>针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集 + 形成连续的内存块，避免内碎片</p><ul><li>Eden区的数据移动到Survivor区，加入出现Survivor区空间不够，Eden区数据会晋升到Old区</li><li>Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区</li><li>最后Eden区收拾干净了，GC结束，用户的应用程序继续执行</li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326121409237.png" alt="image-20200326121409237"></p><p>回收完成后</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326121622208.png" alt="image-20200326121622208"></p><p>小区域收集 + 形成连续的内存块，最后在收集完成后，就会形成连续的内存空间，这样就解决了内存碎片的问题</p><h5 id="13-8-四步过程"><a href="#13-8-四步过程" class="headerlink" title="13.8 四步过程"></a>13.8 四步过程</h5><ul><li>初始标记：只标记GC Roots能直接关联到的对象</li><li>并发标记：进行GC Roots Tracing（链路扫描）的过程</li><li>最终标记：修正并发标记期间，因为程序运行导致标记发生变化的那一部分对象</li><li>筛选回收：根据时间来进行价值最大化回收</li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326121914326.png" alt="image-20200326121914326"></p><h5 id="13-9-参数配置"><a href="#13-9-参数配置" class="headerlink" title="13.9 参数配置"></a>13.9 参数配置</h5><p>开发人员仅仅需要申明以下参数即可</p><p>三步归纳：<code>-XX:+UseG1GC  -Xmx32G  -XX:MaxGCPauseMillis=100</code></p><p>-XX:MaxGCPauseMillis=n：最大GC停顿时间单位毫秒，这是个软目标，JVM尽可能停顿小于这个时间</p><h5 id="13-10-G1和CMS比较"><a href="#13-10-G1和CMS比较" class="headerlink" title="13.10 G1和CMS比较"></a>13.10 G1和CMS比较</h5><ul><li>G1不会产生内碎片</li><li>是可以精准控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间去收集垃圾最多的区域。</li></ul><h4 id="14SpringBoot结合JVMGC"><a href="#14SpringBoot结合JVMGC" class="headerlink" title="14SpringBoot结合JVMGC"></a>14SpringBoot结合JVMGC</h4><p>启动微服务时候，就可以带上JVM和GC的参数</p><ul><li>IDEA开发完微服务工程</li><li>maven进行clean package</li><li>要求微服务启动的时候，同时配置我们的JVM/GC的调优参数<ul><li>我们就可以根据具体的业务配置我们启动的JVM参数</li></ul></li></ul><p>例如：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -Xms<span class="hljs-number">1024</span>m -Xmx<span class="hljs-number">1024</span> -XX:UseG<span class="hljs-number">1</span>GC -jar   xxx.jar</code></pre></div><h1 id="第-13-章-Linux诊断原因"><a href="#第-13-章-Linux诊断原因" class="headerlink" title="第 13 章 Linux诊断原因"></a>第 13 章 Linux诊断原因</h1><h3 id="1-整机：top，查看整机系统性能"><a href="#1-整机：top，查看整机系统性能" class="headerlink" title="1 整机：top，查看整机系统性能"></a>1 整机：top，查看整机系统性能</h3><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326162329550.png" alt="image-20200326162329550"></p><p>使用top命令的话，重点关注的是 %CPU、%MEM 、load average 三个指标</p><ul><li>load average三个指标：分别代表1、5、15分钟的负载情况</li></ul><p>在这个命令下，按1的话，可以看到每个CPU的占用情况</p><p>uptime：系统性能命令的精简版</p><h3 id="2-CPU：vmstat"><a href="#2-CPU：vmstat" class="headerlink" title="2 CPU：vmstat"></a>2 CPU：vmstat</h3><ul><li>查看CPU（包含但是不限于）</li><li>查看额外<ul><li>查看所有CPU核信息：mpstat -p ALL 2</li><li>每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号</li></ul></li></ul><p>命令格式：<code>vmstat -n 2 3</code></p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326162803165.png" alt="image-20200326162803165"></p><p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是残阳的时间间隔数（单位秒），第二个参数是采样的次数</p><p><strong>procs</strong></p><div class="code-wrapper"><pre><code>r：运行和等待的CPU时间片的进程数，原则上1核的CPU的运行队列不要超过2，整个系统的运行队列不超过总核数的2倍，否则代表系统压力过大，我们看蘑菇博客测试服务器，能发现都超过了2，说明现在压力过大b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等</code></pre></div><p><strong>cpu</strong></p><div class="code-wrapper"><pre><code>us：用户进程消耗CPU时间百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，优化程序sy：内核进程消耗的CPU时间百分比</code></pre></div><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326164521263.png" alt="image-20200326164521263"></p><div class="code-wrapper"><pre><code>us + sy 参考值为80%，如果us + sy 大于80%，说明可能存在CPU不足，从上面的图片可以看出，us + sy还没有超过百分80，因此说明蘑菇博客的CPU消耗不是很高id：处于空闲的CPU百分比wa：系统等待IO的CPU时间百分比st：来自于一个虚拟机偷取的CPU时间比</code></pre></div><h3 id="3-内存：free"><a href="#3-内存：free" class="headerlink" title="3 内存：free"></a>3 内存：free</h3><ul><li><p>应用程序可用内存数：free -m</p></li><li><p>应用程序可用内存/系统物理内存 &gt; 70% 内存充足</p></li><li><p>应用程序可用内存/系统物理内存 &lt; 20% 内存不足，需要增加内存</p></li><li><p>20% &lt;  应用程序可用内存/系统物理内存 &lt; 70%，表示内存基本够用</p></li></ul><p>free -h：以人类能看懂的方式查看物理内存</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326170217637.png" alt="image-20200326170217637"></p><p>free -m：以MB为单位，查看物理内存</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326165815071.png" alt="image-20200326165815071"></p><p>free -g：以GB为单位，查看物理内存</p><h3 id="4-硬盘：df"><a href="#4-硬盘：df" class="headerlink" title="4 硬盘：df"></a>4 硬盘：df</h3><p>格式：<code>df -h  /</code>  (-h：human，表示以人类能看到的方式换算)</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326170318733.png" alt="image-20200326170318733"></p><ul><li>硬盘IO：iostat</li></ul><p>系统慢有两种原因引起的，一个是CPU高，一个是大量IO操作</p><p>格式：<code>iostat -xdk 2 3</code></p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326170522559.png" alt="image-20200326170522559"></p><p>磁盘块设备分布：</p><p>rkB /s：每秒读取数据量kB；</p><p>wkB/s：每秒写入数据量kB；</p><p>svctm I/O：请求的平均服务时间，单位毫秒</p><p>await I/O：请求的平均等待时间，单位毫秒，值越小，性能越好</p><p>util：一秒钟有百分几的时间用于I/O操作。接近100%时，表示磁盘带宽跑满，需要优化程序或者增加磁盘；</p><p>rkB/s，wkB/s根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据读写，肯定不正常，需要优化程序读取。</p><p>svctm的值与await的值很接近，表示几乎没有I/O等待，磁盘性能好，如果await的值远高于svctm的值，则表示I/O队列等待太长，需要优化程序或更换更快磁盘</p><h3 id="5-网络IO：ifstat"><a href="#5-网络IO：ifstat" class="headerlink" title="5 网络IO：ifstat"></a>5 网络IO：ifstat</h3><ul><li>默认本地没有，下载ifstat</li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326171559406.png" alt="image-20200326171559406"></p><h3 id="6-生产环境服务器变慢，诊断思路和性能评估"><a href="#6-生产环境服务器变慢，诊断思路和性能评估" class="headerlink" title="6 生产环境服务器变慢，诊断思路和性能评估"></a>6 生产环境服务器变慢，诊断思路和性能评估</h3><p>记一次印象深刻的故障？</p><p>结合Linux 和 JDK命令一起分析，步骤如下</p><ul><li><p>使用top命令找出CPU占比最高的</p></li><li><p>ps -ef 或者 jps 进一步定位，得知是一个怎么样的后台程序出的问题</p></li><li><p>定位到具体线程或者代码</p><ul><li>ps -mp 进程  -o THREAD，tid，time</li><li>参数解释<ul><li>-m：显示所有的线程</li><li>-p：pid进程使用CPU的时间</li><li>-o：该参数后是用户自定义格式</li></ul></li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326173656164.png" alt="image-20200326173656164"></p></li><li><p>将需要的线程ID转换为16进制格式（英文小写格式）</p><ul><li>printf “%x\n” 有问题的线程ID</li></ul></li><li><p>jstack 进程ID | grep tid（16进制线程ID小写英文） -A60</p><p>精准定位到错误的地方</p></li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326174107444.png" alt="image-20200326174107444"></p><h1 id="第-14-章-Github-使用"><a href="#第-14-章-Github-使用" class="headerlink" title="第 14 章 Github 使用"></a>第 14 章 Github 使用</h1><p>使用Github优秀框架 + 源码 提升自己</p><h2 id="1-常用词含义"><a href="#1-常用词含义" class="headerlink" title="1 常用词含义"></a>1 常用词含义</h2><ul><li><p>watch：会持续收到该项目的动态</p></li><li><p>fork：复制某个仓库到自己的Github仓库中</p></li><li><p>star：可以理解为点赞</p></li><li><p>clone：将项目下载至本地</p></li><li><p>follow：关注你感兴趣的作者，会收到他们的动态</p><p>in关键字限制搜索范围</p></li><li><p>公式：<code>XXX关键字 in:name 或 description 或 readme</code></p></li><li><p>xxx in:name   项目名称含有XXX的</p></li><li><p>xxx in:description   项目描述含有XXX的</p></li><li><p>xxx in:readme   项目的readme文件中包含XXX的</p></li><li><p>组合使用</p><ul><li>xxx   in:name,readme    项目的名称和readme中包含xxx的</li></ul></li></ul><h2 id="2-stars或fork数量关键字查找"><a href="#2-stars或fork数量关键字查找" class="headerlink" title="2 stars或fork数量关键字查找"></a>2 stars或fork数量关键字查找</h2><ul><li>公式：<ul><li><code>xxx关键字  stars 通配符</code>  :&gt;  或者 :&gt;=</li><li>区间范围数字：  <code>stars:数字1..数字2</code></li></ul></li><li>案例<ul><li>查找stars数大于等于5000的Springboot项目：springboot  stars:&gt;=5000</li><li>查找forks数在1000~2000之间的springboot项目：springboot forks:1000..5000</li></ul></li><li>组合使用<ul><li>查找star大于1000，fork数在500到1000：<code>springboot stars:&gt;1000 forks:500..1000</code></li></ul></li></ul><h2 id="3-awesome加强搜索"><a href="#3-awesome加强搜索" class="headerlink" title="3 awesome加强搜索"></a>3 awesome加强搜索</h2><ul><li>公式：<code>awesome 关键字</code>：awesome系列，一般用来收集学习、工具、书籍类相关的项目</li><li>搜索优秀的redis相关的项目，包括框架，教程等  awesome redis</li></ul><h2 id="4-高亮显示某行代码"><a href="#4-高亮显示某行代码" class="headerlink" title="4 高亮显示某行代码"></a>4 高亮显示某行代码</h2><ul><li>一行：地址后面紧跟  #L10<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13</code></li></ul></li><li>多行：地址后面紧跟 #Lx - #Ln<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13-L30</code></li></ul></li></ul><h2 id="5-项目内搜索"><a href="#5-项目内搜索" class="headerlink" title="5 项目内搜索"></a>5 项目内搜索</h2><ul><li>使用英文字母 <code>t</code> ,开启项目内搜索</li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326212650322.png" alt="image-20200326212650322"></p><h2 id="6-搜索某个地区内的大佬"><a href="#6-搜索某个地区内的大佬" class="headerlink" title="6 搜索某个地区内的大佬"></a>6 搜索某个地区内的大佬</h2><ul><li>location：地区</li><li>language：语言</li><li>例如：<code>location:beijing language:java</code></li></ul><h1 id="第-15-章-乐观锁和悲观锁"><a href="#第-15-章-乐观锁和悲观锁" class="headerlink" title="第 15 章 乐观锁和悲观锁"></a>第 15 章 乐观锁和悲观锁</h1><h2 id="1-乐观锁"><a href="#1-乐观锁" class="headerlink" title="1 乐观锁"></a>1 乐观锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>乐观锁：顾名思义，就是十分乐观，它总是认为不会出现问题，无论干什么都不去上锁~，如果出现了问题，再次更新值测试，这里使用了version字段。</p><p>也就是每次更新的时候同时维护一个version字段</p><h3 id="乐观锁实现方式"><a href="#乐观锁实现方式" class="headerlink" title="乐观锁实现方式"></a>乐观锁实现方式</h3><ul><li>取出记录时，获取当前的version</li><li>更新时，带上这个version</li><li>执行更新时，set version = newVersion where version = oldVersion</li><li>如果version不对，就更新失败</li></ul><div class="code-wrapper"><pre><code class="hljs shell">乐观锁：1：先查询，获得版本号 version =1-- A 线程update user set name = &quot;陌溪&quot;, version = version + 1 where id = 2 and version = 1-- B 线程抢先完成，这个时候Version = 2，导致A修改失败update user set name = &quot;陌溪&quot;, version = version + 1 where id = 2 and version = 1</code></pre></div><h2 id="2-MybatisPlus使用乐观锁"><a href="#2-MybatisPlus使用乐观锁" class="headerlink" title="2 MybatisPlus使用乐观锁"></a>2 MybatisPlus使用乐观锁</h2><p>首先需要在数据库增加version字典，默认为1</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200329172158610.png" alt="image-20200329172158610"></p><p>然后在实体类增加对应的字段</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 乐观锁Version注解</span><span class="hljs-meta">@Version</span><span class="hljs-keyword">private</span> Integer version;</code></pre></div><p>注册组件，在MybatisPlusConfig中配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 注册乐观锁</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> OptimisticLockerInterceptor <span class="hljs-title">optimisticLockerInterceptor</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OptimisticLockerInterceptor();&#125;</code></pre></div><h2 id="3-悲观锁"><a href="#3-悲观锁" class="headerlink" title="3 悲观锁"></a>3 悲观锁</h2><p>顾名思义，就是十分悲观，它总是认为什么时候都会出现问题，无论什么操作都会上锁，再次操作</p><h1 id="第3部分-框架"><a href="#第3部分-框架" class="headerlink" title="第3部分 框架"></a>第3部分 框架</h1><h1 id="第16-章-Spring-源码"><a href="#第16-章-Spring-源码" class="headerlink" title="第16 章 Spring 源码"></a>第16 章 Spring 源码</h1><h2 id="1-Spring源码方面的知识"><a href="#1-Spring源码方面的知识" class="headerlink" title="1 Spring源码方面的知识"></a>1 Spring源码方面的知识</h2><ul><li>Spring bean的生命周期</li><li>Spring 工厂，Spring容器，上下文 </li><li>Spring BeanPostprocessor</li><li>Spring 和 主流框架的源码</li><li>Spring BeanFactory 和 FactoryBean的区别</li></ul><h2 id="2-谈谈你对Spring的理解"><a href="#2-谈谈你对Spring的理解" class="headerlink" title="2 谈谈你对Spring的理解"></a>2 谈谈你对Spring的理解</h2><p>IOC、AOP只是作为Spring Framework里面一部分，同时还有还有events，resources，i18n，validation，data binding，type conversion，SpEL</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402092317669.png" alt="image-20200402092317669"></p><h2 id="3-Spring上下文"><a href="#3-Spring上下文" class="headerlink" title="3 Spring上下文"></a>3 Spring上下文</h2><p>从代码级别来说，就是指Spring Context</p><p>从源码级别，但我们初始化Spring Context的时候，一堆的Spring组件围绕在一起，使其能够正常工作，这个状态就被称为Spring环境</p><h2 id="4-Spring初始化"><a href="#4-Spring初始化" class="headerlink" title="4 Spring初始化"></a>4 Spring初始化</h2><p>首先需要引入Spring的依赖，因为我们暂时只是初始化过程，只需要用到IOC</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>为了更加了解Spring初始化的过程，我们需要定义三个类</p><p>1、AppConfig.java，可以当成是扫描类，也就是配置我们需要扫描的目录</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ComponentScan(&quot;com.pnca.interview.study.spring&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;&#125;</code></pre></div><p>2、BeanTest.java，我们需要被扫描到的Bean</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanTest</span> </span>&#123;&#125;</code></pre></div><p>3、Test.java，启动测试类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 初始化</span>        AnnotationConfigApplicationContext annotationConfigApplicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);        System.out.println(annotationConfigApplicationContext.getBean(BeanTest.class));    &#125;&#125;</code></pre></div><p>最后我们通过注解的方式，来获取Spring IOC扫描到的Bean，最后打印出来</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402091642787.png" alt="image-20200402091642787"></p><p>tip：IDEA点击进去的源码目录，其实是IDEA反编译得到的，和原来的源码会存在一些出入，是IDEA专门优化过的，因此如果你需要修改源码的话，还是需要在官网下载对应的源码包</p><div class="code-wrapper"><pre><code class="hljs http">https://github.com/spring-projects/spring-framework</code></pre></div><h2 id="5-SpringBean的生命周期"><a href="#5-SpringBean的生命周期" class="headerlink" title="5 SpringBean的生命周期"></a>5 SpringBean的生命周期</h2><p>Spring中的Bean不可能是直接new关键字创建出来的</p><ul><li>把类扫描出来（扫描出来后做了什么？）</li><li>把Bean实例化</li></ul><p>初始化Spring环境有两种方法，一种是通过注解的方式，一个是通过XML的方式</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 方式1，目前用的比较多</span>AnnotationConfigApplicationContext annotationConfigApplicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class)</code></pre></div><p>同时在这个方法的内部，使用了this()</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402100813001.png" alt="image-20200402100813001"></p><p>调用AnnotationConfigApplicationContext无参构造方法，同时因为该类又继承了一个父类 GenericApplicationContext，子类在初始化的时候，还会调用父类的无参构造方法，在父类中，我们能够看到它初始化了一个BeanFactory，这就是我们经常提到的Spring工厂</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402100434794-16295172680416.png" alt="image-20200402100434794"></p><p>这个工厂最重要的功能就是产生Bean</p><p>同时在AnnotationConfigApplication方法的最后，还有一个refresh()方法，这个方法是整个Spring最核心的方法，这个方法的内部，同时调用了十多个方法，其中最重要的是 invokeBeanFactoryPostProcessors()</p><div class="code-wrapper"><pre><code class="hljs java">invokeBeanFactoryPostProcessors() &#123;<span class="hljs-comment">// 扫描类：</span><span class="hljs-comment">// 处理了各种import：例如@import(&quot;xxx.xml&quot;), @MapperScanner, @CompoentScanner ..... </span>&#125;</code></pre></div><h3 id="普通类的实例化"><a href="#普通类的实例化" class="headerlink" title="普通类的实例化"></a>普通类的实例化</h3><p>普通类的实例化，就是通过javac编译成xxx.class文件，然后某一天通过new关键字进行实例化，JVM就会把这个class类加载到JVM内存中，这里面就涉及到了方法区，堆栈存储等。</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402101551621.png" alt="image-20200402101551621"></p><h3 id="Spring-Bean实例化过程"><a href="#Spring-Bean实例化过程" class="headerlink" title="Spring Bean实例化过程"></a>Spring Bean实例化过程</h3><ul><li><p>首先Spring会将全部的Class类，通过classLoader加载到JVM中</p></li><li><p>然后在通过扫描，创建很多BeanDefinition，我们通过反射将对应Class的信息填充到BeanDefinition中</p><ul><li><p>这里的BeanDefinition是用来描述Bean的，也就是Bean的一些信息存储</p><div class="code-wrapper"><pre><code class="hljs java">RootBeanDefinition rootBeanDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition();rootBeanDefinition.setBeanClassName(<span class="hljs-string">&quot;BeanTest&quot;</span>);rootBeanDefinition.setBeanClass(BeanTest.class);rootBeanDefinition.setScope(<span class="hljs-string">&quot;prototype&quot;</span>);rootBeanDefinition.setLazyInit();</code></pre></div></li></ul></li></ul><ul><li>然后在把填充好的BeanDefinition一个个放入到Map中，Spring扫描了几个类，Map中就有几个类，这个Map被称为 BeanDefinitionMap</li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402102958645.png" alt="image-20200402102958645"></p><ul><li>最后我们将这个BeanDefinationMap放入了Spring单例池中</li></ul><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402104318234.png" alt="image-20200402104318234"></p><p>完整的加载图，左边红色部分就是Spring的加载过程，然后开放的原则，它还提供了很多扩展接口，让你可以干扰到Sring的加载过程，使得</p><p><img src="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402104306006.png" alt="image-20200402104306006"></p><p>例如，很多需要对Spring进行扩展的，例如Mybatis，其实都是实现了 BeanFactoryPostProcessor接口</p><p>在执行扫描的时候，它会扫描Spring 提供的 BeanFactoryPostProcessor，以及程序员扩展的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;    &#125;&#125;</code></pre></div>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Java/">Java</category>
      
      <category domain="https://pncalbl.github.io/categories/Java/Tool/">Tool</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Java/">Java</category>
      
      
      <comments>https://pncalbl.github.io/2021/07/30/Java%E9%9D%A2%E8%AF%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>K8s 学习</title>
      <link>https://pncalbl.github.io/2021/07/22/K8s%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/07/22/K8s%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Wed, 21 Jul 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;第1章-Kubernetes简介&quot;&gt;&lt;a href=&quot;#第1章-Kubernetes简介&quot; class=&quot;headerlink&quot; title=&quot;第1章 Kubernetes简介&quot;&gt;&lt;/a&gt;第1章 Kubernetes简介&lt;/h1&gt;&lt;h2 id=&quot;1-来源&quot;&gt;&lt;a </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="第1章-Kubernetes简介"><a href="#第1章-Kubernetes简介" class="headerlink" title="第1章 Kubernetes简介"></a>第1章 Kubernetes简介</h1><h2 id="1-来源"><a href="#1-来源" class="headerlink" title="1 来源"></a>1 来源</h2><p>bilibili尚硅谷K8s视频：<a href="https://www.bilibili.com/video/BV1GT4y1A756">https://www.bilibili.com/video/BV1GT4y1A756</a></p><p>中文官网：<a href="https://kubernetes.io/zh">https://kubernetes.io/zh</a></p><p>中文社区：<a href="https://www.kubernetes.org.cn/">https://www.kubernetes.org.cn/</a></p><h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2 介绍"></a>2 介绍</h2><p>K8s主要讲的就是Kubernetes，首先Kubernetes首字母为K，末尾为s，中间一共有8个字母，所以简称K8s</p><h2 id="3-前置知识"><a href="#3-前置知识" class="headerlink" title="3 前置知识"></a>3 前置知识</h2><ul><li>Linux操作系统</li><li>Docker</li></ul><h2 id="4-课程简介"><a href="#4-课程简介" class="headerlink" title="4 课程简介"></a>4 课程简介</h2><ul><li><p>K8s概念和架构</p></li><li><p>从零搭建K8s集群</p><ul><li>基于客户端工具kubeadm搭建（简单，最多半小时）</li><li>基于二进制包方式（能看到内部的架构）</li></ul></li><li><p>K8s核心概念</p><ul><li>Pod：K8s管理的最小单位级，是所有业务类型的基础</li><li>Controller：控制器，有状态，无状态，一次任务，定时任务，守护进程</li><li>Service Ingress：对外暴露端口</li><li>RBAC：安全机制，权限模型</li><li>Helm：下载机制</li><li>持久化存储</li></ul></li><li><p>搭建集群监控平台系统</p></li><li><p>从零搭建高可用K8s集群</p></li><li><p>在集群环境部署项目</p></li></ul><h2 id="5-K8s概念和特性"><a href="#5-K8s概念和特性" class="headerlink" title="5 K8s概念和特性"></a>5 K8s概念和特性</h2><h3 id="5-1-部署发展历程"><a href="#5-1-部署发展历程" class="headerlink" title="5.1 部署发展历程"></a>5.1 部署发展历程</h3><p>我们的项目部署也在经历下面的这样一个历程</p><blockquote><p>传统部署 -&gt; 虚拟化部署时代 -&gt; 容器部署时代</p></blockquote><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122104102715.png" alt="image-20201122104102715"></p><ul><li><strong>传统部署时代</strong>：早期，组织在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。例如，如果在物理服务器上运行多个应用程序，则可能会出现-一个应用程序占用大部分资源的情况，结果可能导致其他应用程序的性能下降。–种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展，并且组织维护许多物理服务器的成本很高。</li><li><strong>虚拟化部署时代</strong>：作为解决方案，引入了虚拟化功能，它允许您在单个物理服务器的CPU.上运行多个虚拟机（VM）。虚拟化功能允许应用程序在VM之间隔离，并提供安全级别，因为一一个应用程序的信息不能被另一应用程序自由地访问。因为虚拟化可以轻松地添加或更新应用程序、降低硬件成本等等，所以虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性。每个VM是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</li><li><strong>容器部署时代</strong>：容器类似于VM，但是它们具有轻量级的隔离属性，可以在应用程序之间共享操作系统<br>（OS），因此，容器被认为是轻量级的。容器与VM类似，具有自己的文件系统、CPU、内存、进程空间等。由于它们与基础架构分离，因此可以跨云和OS分发进行移植。</li></ul><p>容器因具有许多优势而变得流行起来。下面列出了容器的一些好处：</p><ul><li>敏捷应用程序的创建和部署：与使用VM镜像相比，提高了容器镜像创建的简便性和效率。</li><li>持续开发、集成和部署：通过简单的回滚（由于镜像不可变性），提供可靠且频繁的容器镜像构建和部署。</li><li>关注开发与运维的分离：在构建/时而不是在部署时创建应用程序容器镜像，将应用程序与基础架构分离。</li><li>可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li><li>跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。</li><li>云和操作系统分发的可移植性：可在Ubuntu、RHEL、RHEL、CoreOS、本地、Google Kubernetes Engine和其它任何其它地方运行。</li><li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行OS到使用逻辑资源在OS上运行应用程序。</li><li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分，并且可以动态部署和管理-而不是在一台大型单机上器体运行。</li><li>资源隔离：可预测的应用程序性能。</li></ul><h3 id="5-2-K8s概述"><a href="#5-2-K8s概述" class="headerlink" title="5.2 K8s概述"></a>5.2 K8s概述</h3><p>kubernetes，简称K8s，是用8 代替8 个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes 提供了应用部署，规划，更新，维护的一种机制。</p><p>传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新/回滚等操作，当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。</p><p>新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的。</p><blockquote><p>总结：</p><ul><li>K8s是谷歌在2014年发布的容器化集群管理系统</li><li>使用k8s进行容器化应用部署</li><li>使用k8s利于应用扩展</li><li>k8s目标实施让部署容器化应用更加简洁和高效</li></ul></blockquote><h3 id="5-3-K8s概述"><a href="#5-3-K8s概述" class="headerlink" title="5.3 K8s概述"></a>5.3 K8s概述</h3><p>Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes 能够进行应用的自动化部署和扩缩容。在Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。</p><p>Kubernetes 积累了作为Google 生产环境运行工作负载15 年的经验，并吸收了来自于社区的最佳想法和实践。</p><h3 id="5-4-K8s功能"><a href="#5-4-K8s功能" class="headerlink" title="5.4 K8s功能"></a>5.4 K8s功能</h3><h4 id="1-自动装箱"><a href="#1-自动装箱" class="headerlink" title="1 自动装箱"></a>1 自动装箱</h4><p>基于容器对应用运行环境的资源配置要求自动部署应用容器</p><h4 id="2-自我修复-自愈能力"><a href="#2-自我修复-自愈能力" class="headerlink" title="2 自我修复(自愈能力)"></a>2 自我修复(自愈能力)</h4><p>当容器失败时，会对容器进行重启</p><p>当所部署的Node节点有问题时，会对容器进行重新部署和重新调度</p><p>当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928101336750.png" alt="image-20200928101336750"></p><p>如果某个服务器上的应用不响应了，Kubernetes会自动在其它的地方创建一个</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122112241092.png" alt="image-20201122112241092"></p><h4 id="3-水平扩展"><a href="#3-水平扩展" class="headerlink" title="3 水平扩展"></a>3 水平扩展</h4><p>通过简单的命令、用户UI 界面或基于CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁</p><blockquote><p>当我们有大量的请求来临时，我们可以增加副本数量，从而达到水平扩展的效果</p></blockquote><p>当黄色应用过度忙碌，会来扩展一个应用</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122112301750.png" alt="image-20201122112301750"></p><h4 id="4-服务发现"><a href="#4-服务发现" class="headerlink" title="4 服务发现"></a>4 服务发现</h4><p>用户不需使用额外的服务发现机制，就能够基于Kubernetes 自身能力实现服务发现和负载均衡</p><blockquote><p>对外提供统一的入口，让它来做节点的调度和负载均衡， 相当于微服务里面的网关？</p></blockquote><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928101711968.png" alt="image-20200928101711968"></p><h4 id="5-滚动更新"><a href="#5-滚动更新" class="headerlink" title="5 滚动更新"></a>5 滚动更新</h4><p>可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新</p><blockquote><p>添加应用的时候，不是加进去就马上可以进行使用，而是需要判断这个添加进去的应用是否能够正常使用</p></blockquote><h4 id="6-版本回退"><a href="#6-版本回退" class="headerlink" title="6 版本回退"></a>6 版本回退</h4><p>可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</p><blockquote><p>类似于Git中的回滚</p></blockquote><h4 id="7-密钥和配置管理"><a href="#7-密钥和配置管理" class="headerlink" title="7 密钥和配置管理"></a>7 密钥和配置管理</h4><p>在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。</p><h4 id="8-存储编排"><a href="#8-存储编排" class="headerlink" title="8 存储编排"></a>8 存储编排</h4><p>自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要</p><p>存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务</p><h4 id="9-批处理"><a href="#9-批处理" class="headerlink" title="9 批处理"></a>9 批处理</h4><p>提供一次性任务，定时任务；满足批量数据处理和分析的场景</p><h2 id="6-K8s架构组件"><a href="#6-K8s架构组件" class="headerlink" title="6 K8s架构组件"></a>6 K8s架构组件</h2><h3 id="6-1-完整架构图"><a href="#6-1-完整架构图" class="headerlink" title="6.1 完整架构图"></a>6.1 完整架构图</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928103059652.png" alt="image-20200928103059652"></p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928110124821.png" alt="image-20200928110124821"></p><h3 id="6-2-架构细节"><a href="#6-2-架构细节" class="headerlink" title="6.2 架构细节"></a>6.2 架构细节</h3><p>K8s架构主要包含两部分：Master（主控节点）和 node（工作节点）</p><p>master节点架构图</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122113057343.png" alt="image-20201122113057343"></p><p>Node节点架构图</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122155629990.png" alt="image-20201122155629990"></p><p>k8s 集群控制节点，对集群进行调度管理，接受集群外用户去集群操作请求；</p><ul><li><p><strong>master</strong>：主控节点</p><ul><li>API Server：集群统一入口，以restful风格进行操作，同时交给etcd存储<ul><li>提供认证、授权、访问控制、API注册和发现等机制</li></ul></li><li>scheduler：节点的调度，选择node节点应用部署</li><li>controller-manager：处理集群中常规后台任务，一个资源对应一个控制器</li><li>etcd：存储系统，用于保存集群中的相关数据</li></ul></li><li><p><strong>Work node</strong>：工作节点</p><ul><li>Kubelet：master派到node节点代表，管理本机容器<ul><li>一个集群中每个节点上运行的代理，它保证容器都运行在Pod中</li><li>负责维护容器的生命周期，同时也负责Volume(CSI) 和 网络(CNI)的管理</li></ul></li><li>kube-proxy：提供网络代理，负载均衡等操作</li></ul></li><li><p>容器运行环境【<strong>Container Runtime</strong>】</p><ul><li>容器运行环境是负责运行容器的软件</li><li>Kubernetes支持多个容器运行环境：Docker、containerd、cri-o、rktlet以及任何实现Kubernetes CRI (容器运行环境接口) 的软件。</li></ul></li><li><p>fluentd：是一个守护进程，它有助于提升 集群层面日志</p></li></ul><h2 id="7-K8s核心概念"><a href="#7-K8s核心概念" class="headerlink" title="7 K8s核心概念"></a>7 K8s核心概念</h2><h3 id="7-1-Pod"><a href="#7-1-Pod" class="headerlink" title="7.1 Pod"></a>7.1 Pod</h3><ul><li>Pod是K8s中最小的单元</li><li>一组容器的集合</li><li>共享网络【一个Pod中的所有容器共享同一网络】</li><li>生命周期是短暂的（服务器重启后，就找不到了）</li></ul><h3 id="7-2-Volume"><a href="#7-2-Volume" class="headerlink" title="7.2 Volume"></a>7.2 Volume</h3><ul><li>声明在Pod容器中可访问的文件目录</li><li>可以被挂载到Pod中一个或多个容器指定路径下</li><li>支持多种后端存储抽象【本地存储、分布式存储、云存储】</li></ul><h3 id="7-3-Controller"><a href="#7-3-Controller" class="headerlink" title="7.3 Controller"></a>7.3 Controller</h3><ul><li>确保预期的pod副本数量【ReplicaSet】</li><li>无状态应用部署【Depoltment】<ul><li>无状态就是指，不需要依赖于网络或者ip</li></ul></li><li>有状态应用部署【StatefulSet】<ul><li>有状态需要特定的条件</li></ul></li><li>确保所有的node运行同一个pod 【DaemonSet】</li><li>一次性任务和定时任务【Job和CronJob】</li></ul><h3 id="7-4-Deployment"><a href="#7-4-Deployment" class="headerlink" title="7.4 Deployment"></a>7.4 Deployment</h3><ul><li>定义一组Pod副本数目，版本等</li><li>通过控制器【Controller】维持Pod数目【自动回复失败的Pod】</li><li>通过控制器以指定的策略控制版本【滚动升级、回滚等】</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122161601349.png" alt="image-20201122161601349"></p><h3 id="7-5-Service"><a href="#7-5-Service" class="headerlink" title="7.5 Service"></a>7.5 Service</h3><ul><li>定义一组pod的访问规则</li><li>Pod的负载均衡，提供一个或多个Pod的稳定访问地址</li><li>支持多种方式【ClusterIP、NodePort、LoadBalancer】</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122161132055.png" alt="image-20201122161132055"></p><p>可以用来组合pod，同时对外提供服务</p><h3 id="7-6-Label"><a href="#7-6-Label" class="headerlink" title="7.6 Label"></a>7.6 Label</h3><p>label：标签，用于对象资源查询，筛选</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122161713638.png" alt="image-20201122161713638"></p><h3 id="7-7-Namespace"><a href="#7-7-Namespace" class="headerlink" title="7.7 Namespace"></a>7.7 Namespace</h3><p>命名空间，逻辑隔离</p><ul><li>一个集群内部的逻辑隔离机制【鉴权、资源】</li><li>每个资源都属于一个namespace</li><li>同一个namespace所有资源不能重复</li><li>不同namespace可以资源名重复</li></ul><h3 id="7-8-API"><a href="#7-8-API" class="headerlink" title="7.8 API"></a>7.8 API</h3><p>我们通过Kubernetes的API来操作整个集群</p><p>同时我们可以通过 kubectl 、ui、curl 最终发送 http + json/yaml 方式的请求给API Server，然后控制整个K8s集群，K8s中所有的资源对象都可以采用 yaml 或 json 格式的文件定义或描述</p><p>如下：使用yaml部署一个nginx的pod</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122162612448.png" alt="image-20201122162612448"></p><h2 id="8-完整流程"><a href="#8-完整流程" class="headerlink" title="8 完整流程"></a>8 完整流程</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122163512535.png" alt="image-20201122163512535"></p><ul><li>通过Kubectl提交一个创建RC（Replication Controller）的请求，该请求通过APlserver写入etcd</li><li>此时Controller Manager通过API Server的监听资源变化的接口监听到此RC事件</li><li>分析之后，发现当前集群中还没有它所对应的Pod实例</li><li>于是根据RC里的Pod模板定义一个生成Pod对象，通过APIServer写入etcd</li><li>此事件被Scheduler发现，它立即执行执行一个复杂的调度流程，为这个新的Pod选定一个落户的Node，然后通过API Server讲这一结果写入etcd中</li><li>目标Node上运行的Kubelet进程通过APiserver监测到这个”新生的Pod，并按照它的定义，启动该Pod并任劳任怨地负责它的下半生，直到Pod的生命结束</li><li>随后，我们通过Kubectl提交一个新的映射到该Pod的Service的创建请求</li><li>ControllerManager通过Label标签查询到关联的Pod实例，然后生成Service的Endpoints信息，并通过APIServer写入到etod中，</li><li>接下来，所有Node上运行的Proxy进程通过APIServer查询并监听Service对象与其对应的Endponts信息，建立一个软件方式的负载均衡器来实现Service访问到后端Pod的流量转发功能</li></ul><h1 id="第2章-搭建K8S集群"><a href="#第2章-搭建K8S集群" class="headerlink" title="第2章 搭建K8S集群"></a>第2章 搭建K8S集群</h1><h2 id="1-搭建k8s环境平台规划"><a href="#1-搭建k8s环境平台规划" class="headerlink" title="1 搭建k8s环境平台规划"></a>1 搭建k8s环境平台规划</h2><h3 id="单master集群"><a href="#单master集群" class="headerlink" title="单master集群"></a>单master集群</h3><p>单个master节点，然后管理多个node节点</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/2_%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/images/image-20200928110456495.png" alt="image-20200928110456495"></p><h3 id="多master集群"><a href="#多master集群" class="headerlink" title="多master集群"></a>多master集群</h3><p>多个master节点，管理多个node节点，同时中间多了一个负载均衡的过程</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/2_%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/images/image-20200928110543829.png" alt="image-20200928110543829"></p><h2 id="2-服务器硬件配置要求"><a href="#2-服务器硬件配置要求" class="headerlink" title="2 服务器硬件配置要求"></a>2 服务器硬件配置要求</h2><h3 id="2-1-测试环境"><a href="#2-1-测试环境" class="headerlink" title="2.1 测试环境"></a>2.1 测试环境</h3><p>master：2核  4G  20G</p><p>node：   4核  8G  40G</p><h3 id="2-2-生产环境"><a href="#2-2-生产环境" class="headerlink" title="2.2 生产环境"></a>2.2 生产环境</h3><p>master：8核  16G  100G</p><p>node：   16核  64G  200G</p><p>目前生产部署Kubernetes集群主要有两种方式</p><h3 id="2-3-kubeadm"><a href="#2-3-kubeadm" class="headerlink" title="2.3 kubeadm"></a>2.3 kubeadm</h3><p>kubeadm是一个K8S部署工具，提供kubeadm init 和 kubeadm join，用于快速部署Kubernetes集群</p><p>官网地址：<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">点我传送</a></p><h3 id="2-4-二进制包"><a href="#2-4-二进制包" class="headerlink" title="2.4 二进制包"></a>2.4 二进制包</h3><p>从github下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</p><p>Kubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p><h2 id="3-Kubeadm部署集群"><a href="#3-Kubeadm部署集群" class="headerlink" title="3 Kubeadm部署集群"></a>3 Kubeadm部署集群</h2><p>kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：</p><ul><li>创建一个Master 节点kubeadm init</li><li>将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;</li></ul><h2 id="4-安装要求"><a href="#4-安装要求" class="headerlink" title="4 安装要求"></a>4 安装要求</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件</p><ul><li>一台或多台机器，操作系统为Centos7.X</li><li>硬件配置：2GB或更多GAM，2个CPU或更多CPU，硬盘30G</li><li>集群中所有机器之间网络互通</li><li>可以访问外网，需要拉取镜像</li><li>禁止swap分区</li></ul><h1 id="第3章-使用kubeadm方式搭建K8S集群"><a href="#第3章-使用kubeadm方式搭建K8S集群" class="headerlink" title="第3章 使用kubeadm方式搭建K8S集群"></a>第3章 使用kubeadm方式搭建K8S集群</h1><p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。</p><p>这个工具能通过两条指令完成一个kubernetes集群的部署：</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建一个 Master 节点</span>kubeadm init<span class="hljs-meta">#</span><span class="bash"> 将一个 Node 节点加入到当前集群中</span>kubeadm join &lt;Master节点的IP和端口 &gt;</code></pre></div><h2 id="1-Kubeadm方式搭建K8S集群"><a href="#1-Kubeadm方式搭建K8S集群" class="headerlink" title="1 Kubeadm方式搭建K8S集群"></a>1 Kubeadm方式搭建K8S集群</h2><p>使用kubeadm方式搭建K8s集群主要分为以下几步</p><ul><li>准备三台虚拟机，同时安装操作系统CentOS 7.x</li><li>对三个安装之后的操作系统进行初始化操作</li><li>在三个节点安装 docker kubelet kubeadm kubectl</li><li>在master节点执行kubeadm init命令初始化</li><li>在node节点上执行 kubeadm join命令，把node节点添加到当前集群</li><li>配置CNI网络插件，用于节点之间的连通【失败了可以多试几次】</li><li>通过拉取一个nginx进行测试，能否进行外网测试</li></ul><h2 id="2-安装要求"><a href="#2-安装要求" class="headerlink" title="2 安装要求"></a>2 安装要求</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件：</p><ul><li>一台或多台机器，操作系统 CentOS7.x-86_x64</li><li>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多【注意master需要两核】</li><li>可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像并导入节点</li><li>禁止swap分区</li></ul><h2 id="3-准备环境"><a href="#3-准备环境" class="headerlink" title="3 准备环境"></a>3 准备环境</h2><table><thead><tr><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>master</td><td>192.168.177.130</td></tr><tr><td>node1</td><td>192.168.177.131</td></tr><tr><td>node2</td><td>192.168.177.132</td></tr></tbody></table><p>然后开始在每台机器上执行下面的命令</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭防火墙</span>systemctl stop firewalldsystemctl <span class="hljs-built_in">disable</span> firewalld<span class="hljs-comment"># 关闭selinux</span><span class="hljs-comment"># 永久关闭</span>sed -i <span class="hljs-string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  <span class="hljs-comment"># 临时关闭</span>setenforce 0  <span class="hljs-comment"># 关闭swap</span><span class="hljs-comment"># 临时</span>swapoff -a <span class="hljs-comment"># 永久关闭</span>sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab<span class="hljs-comment"># 根据规划设置主机名【master节点上操作】</span>hostnamectl set-hostname k8smaster<span class="hljs-comment"># 根据规划设置主机名【node1节点操作】</span>hostnamectl set-hostname k8snode1<span class="hljs-comment"># 根据规划设置主机名【node2节点操作】</span>hostnamectl set-hostname k8snode2<span class="hljs-comment"># 在master添加hosts</span>cat &gt;&gt; /etc/hosts &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">192.168.177.130 k8smaster</span><span class="hljs-string">192.168.177.131 k8snode1</span><span class="hljs-string">192.168.177.132 k8snode2</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 将桥接的IPv4流量传递到iptables的链</span>cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 生效</span>sysctl --system  <span class="hljs-comment"># 时间同步</span>yum install ntpdate -yntpdate time.windows.com</code></pre></div><h2 id="4-安装Docker-kubeadm-kubelet"><a href="#4-安装Docker-kubeadm-kubelet" class="headerlink" title="4 安装Docker/kubeadm/kubelet"></a>4 安装Docker/kubeadm/kubelet</h2><p>所有节点安装Docker/kubeadm/kubelet ，Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker</p><h3 id="4-1-安装Docker"><a href="#4-1-安装Docker" class="headerlink" title="4.1 安装Docker"></a>4.1 安装Docker</h3><p>首先配置一下Docker的阿里yum源</p><div class="code-wrapper"><pre><code class="hljs bash">cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;<span class="hljs-string">EOF</span><span class="hljs-string">[docker-ce-edge]</span><span class="hljs-string">name=Docker CE Edge - \$basearch</span><span class="hljs-string">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\$basearch/edge</span><span class="hljs-string">enabled=1</span><span class="hljs-string">gpgcheck=1</span><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><span class="hljs-string">EOF</span></code></pre></div><p>然后yum方式安装docker</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># yum安装</span>yum -y install docker-ce<span class="hljs-comment"># 查看docker版本</span>docker --version  <span class="hljs-comment"># 启动docker</span>systemctl <span class="hljs-built_in">enable</span> dockersystemctl start docker</code></pre></div><p>配置docker的镜像源</p><div class="code-wrapper"><pre><code class="hljs bash">cat &gt;&gt; /etc/docker/daemon.json &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">&#123;</span><span class="hljs-string">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span><span class="hljs-string">&#125;</span><span class="hljs-string">EOF</span></code></pre></div><p>然后重启docker</p><div class="code-wrapper"><pre><code class="hljs bash">systemctl restart docker</code></pre></div><h3 id="4-2-添加kubernetes软件源"><a href="#4-2-添加kubernetes软件源" class="headerlink" title="4.2 添加kubernetes软件源"></a>4.2 添加kubernetes软件源</h3><p>然后我们还需要配置一下yum的k8s软件源</p><div class="code-wrapper"><pre><code class="hljs bash">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">[kubernetes]</span><span class="hljs-string">name=Kubernetes</span><span class="hljs-string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><span class="hljs-string">enabled=1</span><span class="hljs-string">gpgcheck=0</span><span class="hljs-string">repo_gpgcheck=0</span><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><span class="hljs-string">EOF</span></code></pre></div><h3 id="4-3-安装kubeadm，kubelet和kubectl"><a href="#4-3-安装kubeadm，kubelet和kubectl" class="headerlink" title="4.3 安装kubeadm，kubelet和kubectl"></a>4.3 安装kubeadm，kubelet和kubectl</h3><p>由于版本更新频繁，这里指定版本号部署：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装kubelet、kubeadm、kubectl，同时指定版本</span>yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0<span class="hljs-comment"># 设置开机启动</span>systemctl <span class="hljs-built_in">enable</span> kubelet</code></pre></div><h2 id="5-部署Kubernetes-Master【master节点】"><a href="#5-部署Kubernetes-Master【master节点】" class="headerlink" title="5 部署Kubernetes Master【master节点】"></a>5 部署Kubernetes Master【master节点】</h2><p>在   192.168.177.130  执行，也就是master节点</p><div class="code-wrapper"><pre><code class="hljs bash">kubeadm init --apiserver-advertise-address=192.168.177.130 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</code></pre></div><p>由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址，【执行上述命令会比较慢，因为后台其实已经在拉取镜像了】，我们 docker images 命令即可查看已经拉取的镜像</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20200929094302491.png" alt="image-20200929094302491"></p><p>当我们出现下面的情况时，表示kubernetes的镜像已经安装成功</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20200929094620145.png" alt="image-20200929094620145"></p><p>使用kubectl工具 【master节点操作】</p><div class="code-wrapper"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kubesudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/configsudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</code></pre></div><p>执行完成后，我们使用下面命令，查看我们正在运行的节点</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get nodes</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20200929094933142.png" alt="image-20200929094933142"></p><p>能够看到，目前有一个master节点已经运行了，但是还处于未准备状态</p><p>下面我们还需要在Node节点执行其它的命令，将node1和node2加入到我们的master节点上</p><h2 id="6-加入Kubernetes-Node【Slave节点】"><a href="#6-加入Kubernetes-Node【Slave节点】" class="headerlink" title="6 加入Kubernetes Node【Slave节点】"></a>6 加入Kubernetes Node【Slave节点】</h2><p>下面我们需要到 node1 和 node2服务器，执行下面的代码向集群添加新节点</p><p>执行在kubeadm init输出的kubeadm join命令：</p><blockquote><p>注意，以下的命令是在master初始化完成后，每个人的都不一样！！！需要复制自己生成的</p></blockquote><div class="code-wrapper"><pre><code class="hljs bash">kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf \    --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</code></pre></div><p>默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</p><div class="code-wrapper"><pre><code class="hljs gauss">kubeadm <span class="hljs-built_in">token</span> <span class="hljs-keyword">create</span> --<span class="hljs-keyword">print</span>-join-command</code></pre></div><p>当我们把两个节点都加入进来后，我们就可以去Master节点 执行下面命令查看情况</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get node</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113165358663.png" alt="image-20201113165358663"></p><h2 id="7-部署CNI网络插件"><a href="#7-部署CNI网络插件" class="headerlink" title="7 部署CNI网络插件"></a>7 部署CNI网络插件</h2><p>上面的状态还是NotReady，下面我们需要网络插件，来进行联网访问</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 下载网络插件配置</span>wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre></div><p>默认镜像地址无法访问，sed命令修改为docker hub镜像仓库。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 添加</span>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<span class="hljs-comment">##①首先下载v0.13.1-rc2-amd64 镜像</span><span class="hljs-comment">##参考博客：https://www.cnblogs.com/pyxuexi/p/14288591.html</span><span class="hljs-comment">##② 导入镜像，命令，，特别提示，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，重要的事情说3遍。不然抱错。如果没有操作，报错后，需要删除节点，重置，在导入镜像，重新加入才行。本地就是这样操作成功的！</span>docker load &lt; flanneld-v0.13.1-rc2-amd64.docker<span class="hljs-comment">#####下载本地，替换将image: quay.io/coreos/flannel:v0.13.1-rc2 替换为 image: quay.io/coreos/flannel:v0.13.1-rc2-amd64</span><span class="hljs-comment"># 查看状态 【kube-system是k8s中的最小单元】</span>kubectl get pods -n kube-system</code></pre></div><p>运行后的结果</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113165929510.png" alt="image-20201113165929510"></p><p>运行完成后，我们查看状态可以发现，已经变成了Ready状态了</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113194557147.png" alt="image-20201113194557147"></p><p>如果上述操作完成后，还存在某个节点处于NotReady状态，可以在Master将该节点删除</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># master节点将该节点删除</span><span class="hljs-comment">##20210223 yan 查阅资料添加###kubectl drain k8snode1 --delete-local-data --force --ignore-daemonsets</span>kubectl delete node k8snode1 <span class="hljs-comment"># 然后到k8snode1节点进行重置</span> kubeadm reset<span class="hljs-comment"># 重置完后在加入</span>kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf     --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</code></pre></div><h2 id="8-测试kubernetes集群"><a href="#8-测试kubernetes集群" class="headerlink" title="8 测试kubernetes集群"></a>8 测试kubernetes集群</h2><p>我们都知道K8S是容器化技术，它可以联网去下载镜像，用容器的方式进行启动</p><p>在Kubernetes集群中创建一个pod，验证是否正常运行：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 下载nginx 【会联网拉取nginx镜像】</span>kubectl create deployment nginx --image=nginx<span class="hljs-comment"># 查看状态</span>kubectl get pod</code></pre></div><p>如果我们出现Running状态的时候，表示已经成功运行了</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113203537028.png" alt="image-20201113203537028"></p><p>下面我们就需要将端口暴露出去，让其它外界能够访问</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 暴露端口</span>kubectl expose deployment nginx --port=80 --<span class="hljs-built_in">type</span>=NodePort<span class="hljs-comment"># 查看一下对外的端口</span>kubectl get pod,svc</code></pre></div><p>能够看到，我们已经成功暴露了 80端口  到 30529上</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113203840915.png" alt="image-20201113203840915"></p><p>我们到我们的宿主机浏览器上，访问如下地址</p><div class="code-wrapper"><pre><code class="hljs bash">http://192.168.177.130:30529/</code></pre></div><p>发现我们的nginx已经成功启动了</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113204056851.png" alt="image-20201113204056851"></p><p>到这里为止，我们就搭建了一个单master的k8s集群</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113204158884.png" alt="image-20201113204158884"></p><h2 id="9-错误汇总"><a href="#9-错误汇总" class="headerlink" title="9 错误汇总"></a>9 错误汇总</h2><h3 id="9-1-错误一"><a href="#9-1-错误一" class="headerlink" title="9.1 错误一"></a>9.1 错误一</h3><p>在执行Kubernetes  init方法的时候，出现这个问题</p><div class="code-wrapper"><pre><code class="hljs bash">error execution phase preflight: [preflight] Some fatal errors occurred:[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2</code></pre></div><p>是因为VMware设置的核数为1，而K8S需要的最低核数应该是2，调整核数重启系统即可</p><h3 id="9-2-错误二"><a href="#9-2-错误二" class="headerlink" title="9.2 错误二"></a>9.2 错误二</h3><p>我们在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><div class="code-wrapper"><pre><code class="hljs bash">error execution phase preflight: [preflight] Some fatal errors occurred:[ERROR Swap]: running with swap on is not supported. Please <span class="hljs-built_in">disable</span> swap</code></pre></div><p>错误原因是我们需要关闭swap</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭swap</span><span class="hljs-comment"># 临时</span>swapoff -a <span class="hljs-comment"># 临时</span>sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</code></pre></div><h3 id="9-3-错误三"><a href="#9-3-错误三" class="headerlink" title="9.3 错误三"></a>9.3 错误三</h3><p>在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><div class="code-wrapper"><pre><code class="hljs bash">The HTTP call equal to <span class="hljs-string">&#x27;curl -sSL http://localhost:10248/healthz&#x27;</span> failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused</code></pre></div><p>解决方法，首先需要到 master 节点，创建一个文件</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建文件夹</span>mkdir /etc/systemd/system/kubelet.service.d<span class="hljs-comment"># 创建文件</span>vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf<span class="hljs-comment"># 添加如下内容</span>Environment=<span class="hljs-string">&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --fail-swap-on=false&quot;</span><span class="hljs-comment"># 重置</span>kubeadm reset</code></pre></div><p>然后删除刚刚创建的配置目录</p><div class="code-wrapper"><pre><code class="hljs bash">rm -rf <span class="hljs-variable">$HOME</span>/.kube</code></pre></div><p>然后 在master重新初始化</p><div class="code-wrapper"><pre><code class="hljs bash">kubeadm init --apiserver-advertise-address=202.193.57.11 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</code></pre></div><p>初始完成后，我们再到 node1节点，执行 kubeadm join命令，加入到master</p><div class="code-wrapper"><pre><code class="hljs bash">kubeadm join 202.193.57.11:6443 --token c7a7ou.z00fzlb01d76r37s \    --discovery-token-ca-cert-hash sha256:9c3f3cc3f726c6ff8bdff14e46b1a856e3b8a4cbbe30cab185f6c5ee453aeea5</code></pre></div><p>添加完成后，我们使用下面命令，查看节点是否成功添加</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get nodes</code></pre></div><h3 id="9-4-错误四"><a href="#9-4-错误四" class="headerlink" title="9.4 错误四"></a>9.4 错误四</h3><p>我们再执行查看节点的时候，  kubectl get nodes 会出现问题</p><div class="code-wrapper"><pre><code class="hljs bash">Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of <span class="hljs-string">&quot;crypto/rsa: verification error&quot;</span> <span class="hljs-keyword">while</span> trying to verify candidate authority certificate <span class="hljs-string">&quot;kubernetes&quot;</span>)</code></pre></div><p>这是因为我们之前创建的配置文件还存在，也就是这些配置</p><div class="code-wrapper"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kubesudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/configsudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</code></pre></div><p>我们需要做的就是把配置文件删除，然后重新执行一下</p><div class="code-wrapper"><pre><code class="hljs bash">rm -rf <span class="hljs-variable">$HOME</span>/.kube</code></pre></div><p>然后再次创建一下即可</p><div class="code-wrapper"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kubesudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/configsudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</code></pre></div><p>这个问题主要是因为我们在执行 kubeadm reset 的时候，没有把 $HOME/.kube 给移除掉，再次创建时就会出现问题了</p><h3 id="9-5-错误五"><a href="#9-5-错误五" class="headerlink" title="9.5 错误五"></a>9.5 错误五</h3><p>安装的时候，出现以下错误</p><div class="code-wrapper"><pre><code class="hljs bash">Another app is currently holding the yum lock; waiting <span class="hljs-keyword">for</span> it to <span class="hljs-built_in">exit</span>...</code></pre></div><p>是因为yum上锁占用，解决方法</p><div class="code-wrapper"><pre><code class="hljs bash">yum -y install docker-ce</code></pre></div><h3 id="9-6-错误六"><a href="#9-6-错误六" class="headerlink" title="9.6 错误六"></a>9.6 错误六</h3><p>在使用下面命令，添加node节点到集群上的时候</p><div class="code-wrapper"><pre><code class="hljs bash">kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb  --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</code></pre></div><p>然后出现了这个错误</p><div class="code-wrapper"><pre><code class="hljs bash">[root@k8smaster ~]<span class="hljs-comment"># kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb     --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</span>W1117 06:55:11.220907   11230 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not <span class="hljs-built_in">set</span>.[preflight] Running pre-flight checks[WARNING IsDockerSystemdCheck]: detected <span class="hljs-string">&quot;cgroupfs&quot;</span> as the Docker cgroup driver. The recommended driver is <span class="hljs-string">&quot;systemd&quot;</span>. Please follow the guide at https://kubernetes.io/docs/setup/cri/error execution phase preflight: [preflight] Some fatal errors occurred:[ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not <span class="hljs-built_in">set</span> to 1[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`To see the stack trace of this error execute with --v=5 or higher</code></pre></div><p>出于安全考虑，Linux系统<strong>默认是禁止数据包转发</strong>的。所谓<strong>转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包</strong>。这通常就是路由器所要实现的功能。也就是说  <strong>/proc/sys/net/ipv4/ip_forward</strong> 文件的值不支持转发</p><ul><li>0：禁止</li><li>1：转发</li></ul><p>所以我们需要将值修改成1即可</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> “1” &gt; /proc/sys/net/ipv4/ip_forward</code></pre></div><p>修改完成后，重新执行命令即可</p><h1 id="第4章-使用二进制方式搭建K8S集群"><a href="#第4章-使用二进制方式搭建K8S集群" class="headerlink" title="第4章 使用二进制方式搭建K8S集群"></a>第4章 使用二进制方式搭建K8S集群</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件</p><ul><li>一台或多台机器，操作系统CentOS 7.x</li><li>硬件配置：2GB ，2个CPU，硬盘30GB</li><li>集群中所有机器之间网络互通</li><li>可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像导入节点</li><li>禁止swap分区</li></ul><h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2 步骤"></a>2 步骤</h2><ul><li>创建多台虚拟机，安装Linux系统</li><li>操作系统的初始化</li><li>为etcd 和 apiserver 自签证书</li><li>部署etcd集群</li><li>部署master组件【安装docker、kube-apiserver、kube-controller-manager、kube-scheduler、etcd】</li><li>部署node组件【安装kubelet、kube-proxy、docker、etcd】</li><li>部署集群网络</li></ul><h2 id="3-准备虚拟机"><a href="#3-准备虚拟机" class="headerlink" title="3 准备虚拟机"></a>3 准备虚拟机</h2><p>首先我们准备了两台虚拟机，来进行安装测试</p><table><thead><tr><th>主机名</th><th>ip</th></tr></thead><tbody><tr><td>k8s_2_master</td><td>192.168.177.140</td></tr><tr><td>k8s_2_node</td><td>192.168.177.141</td></tr></tbody></table><h2 id="4-操作系统的初始化"><a href="#4-操作系统的初始化" class="headerlink" title="4 操作系统的初始化"></a>4 操作系统的初始化</h2><p>然后我们需要进行一些系列的初始化操作</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭防火墙</span>systemctl stop firewalldsystemctl <span class="hljs-built_in">disable</span> firewalld<span class="hljs-comment"># 关闭selinux</span><span class="hljs-comment"># 永久关闭</span>sed -i <span class="hljs-string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  <span class="hljs-comment"># 临时关闭</span>setenforce 0  <span class="hljs-comment"># 关闭swap</span><span class="hljs-comment"># 临时</span>swapoff -a <span class="hljs-comment"># 永久关闭</span>sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab<span class="hljs-comment"># 根据规划设置主机名【master节点上操作】</span>hostnamectl set-hostname k8s_2_master<span class="hljs-comment"># 根据规划设置主机名【node1节点操作】</span>hostnamectl set-hostname k8s_2_node1<span class="hljs-comment"># 在master添加hosts</span>cat &gt;&gt; /etc/hosts &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">192.168.177.140 k8s_2_master</span><span class="hljs-string">192.168.177.141 k8s_2_node1</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 将桥接的IPv4流量传递到iptables的链</span>cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 生效</span>sysctl --system  <span class="hljs-comment"># 时间同步</span>yum install ntpdate -yntpdate time.windows.com</code></pre></div><h2 id="5-部署Etcd集群"><a href="#5-部署Etcd集群" class="headerlink" title="5 部署Etcd集群"></a>5 部署Etcd集群</h2><p>Etcd是一个分布式键值存储系统，Kubernetes使用Etcd进行数据存储，所以先准备一个Etcd数据库，为了解决Etcd单点故障，应采用集群方式部署，这里使用3台组建集群，可容忍一台机器故障，当然也可以使用5台组件集群，可以容忍2台机器故障</p><h3 id="自签证书"><a href="#自签证书" class="headerlink" title="自签证书"></a>自签证书</h3><p>提到证书，我们想到的就是下面这个情况</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113213116353.png" alt="image-20201113213116353"></p><p>这个https证书，其实就是服务器颁发给网站的，代表这是一个安全可信任的网站。</p><p>而在我们K8S集群的内部，其实也是有证书的，如果不带证书，那么访问就会受限</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113213353267.png" alt="image-20201113213353267"></p><p>同时在集群内部 和 外部的访问，我们也需要签发证书</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113213416013.png" alt="image-20201113213416013"></p><p>如果我们使用二进制的方式，那么就需要自己手动签发证书。</p><p>自签证书：我们可以想象成在一家公司上班，然后会颁发一个门禁卡，同时一般门禁卡有两种，一个是内部员工的门禁卡，和外部访客门禁卡。这两种门禁卡的权限可能不同，员工的门禁卡可以进入公司的任何地方，而访客的门禁卡是受限的，这个门禁卡其实就是自签证书</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113214234194.png" alt="image-20201113214234194"></p><h3 id="准备cfssl证书生成工具"><a href="#准备cfssl证书生成工具" class="headerlink" title="准备cfssl证书生成工具"></a>准备cfssl证书生成工具</h3><p>cfssl是一个开源的证书管理工具，使用json文件生成证书，相比openssl 更方便使用。找任意一台服务器操作，这里用Master节点。</p><div class="code-wrapper"><pre><code class="hljs bash">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64mv cfssl_linux-amd64 /usr/<span class="hljs-built_in">local</span>/bin/cfsslmv cfssljson_linux-amd64 /usr/<span class="hljs-built_in">local</span>/bin/cfssljsonmv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</code></pre></div><h1 id="第5章-Kubeadm和二进制方式对比"><a href="#第5章-Kubeadm和二进制方式对比" class="headerlink" title="第5章 Kubeadm和二进制方式对比"></a>第5章 Kubeadm和二进制方式对比</h1><h2 id="1-Kubeadm方式搭建K8S集群-1"><a href="#1-Kubeadm方式搭建K8S集群-1" class="headerlink" title="1 Kubeadm方式搭建K8S集群"></a>1 Kubeadm方式搭建K8S集群</h2><ul><li><p>安装虚拟机，在虚拟机安装Linux操作系统【3台虚拟机】</p></li><li><p>对操作系统初始化操作</p></li><li><p>所有节点安装Docker、kubeadm、kubelet、kubectl【包含master和slave节点】</p><ul><li>安装docker、使用yum，不指定版本默认安装最新的docker版本</li><li>修改docker仓库地址，yum源地址，改为阿里云地址</li><li>安装kubeadm，kubelet 和 kubectl<ul><li>k8s已经发布最新的1.19版本，可以指定版本安装，不指定安装最新版本</li><li><code>yum install -y kubelet kubeadm kubectl</code></li></ul></li></ul></li><li><p>在master节点执行初始化命令操作</p><ul><li><code>kubeadm init</code></li><li>默认拉取镜像地址 K8s.gcr.io国内地址，需要使用国内地址</li></ul></li><li><p>安装网络插件(CNI)</p><ul><li><code>kubectl apply -f kube-flannel.yml</code></li><li></li></ul></li><li><p>在所有的node节点上，使用join命令，把node添加到master节点上</p></li><li><p>测试kubernetes集群</p></li></ul><h2 id="2-二进制方式搭建K8S集群"><a href="#2-二进制方式搭建K8S集群" class="headerlink" title="2 二进制方式搭建K8S集群"></a>2 二进制方式搭建K8S集群</h2><ul><li>安装虚拟机和操作系统，对操作系统进行初始化操作</li><li>生成cfssl 自签证书<ul><li><code>ca-key.pem</code>、<code>ca.pem</code></li><li><code>server-key.pem</code>、<code>server.pem</code></li></ul></li><li>部署Etcd集群<ul><li>部署的本质，就是把etcd集群交给 systemd 管理</li><li>把生成的证书复制过来，启动，设置开机启动</li></ul></li><li>为apiserver自签证书，生成过程和etcd类似</li><li>部署master组件，主要包含以下组件<ul><li>apiserver</li><li>controller-manager</li><li>scheduler</li><li>交给systemd管理，并设置开机启动</li><li>如果要安装最新的1.19版本，下载二进制文件进行安装</li></ul></li><li>部署node组件<ul><li>docker</li><li>kubelet</li><li>kube-proxy【需要批准kubelet证书申请加入集群】</li><li>交给systemd管理组件- 组件启动，设置开机启动</li></ul></li><li>批准kubelet证书申请 并加入集群</li><li>部署CNI网络插件</li><li>测试Kubernets集群【安装nginx测试】</li></ul><h1 id="第6章-Kubernetes集群管理工具kubectl"><a href="#第6章-Kubernetes集群管理工具kubectl" class="headerlink" title="第6章 Kubernetes集群管理工具kubectl"></a>第6章 Kubernetes集群管理工具kubectl</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>kubectl是Kubernetes集群的命令行工具，通过kubectl能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2 命令格式"></a>2 命令格式</h2><p>命令格式如下</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl [<span class="hljs-built_in">command</span>] [<span class="hljs-built_in">type</span>] [name] [flags]</code></pre></div><p>参数</p><ul><li>command：指定要对资源执行的操作，例如create、get、describe、delete</li><li>type：指定资源类型，资源类型是大小写敏感的，开发者能够以单数 、复数 和 缩略的形式</li></ul><p>例如：</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pod pod1kubectl get pods pod1kubectl get po pod1</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/6_Kubernetes%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7kubectl/images/image-20201114095544185.png" alt="image-20201114095544185"></p><ul><li>name：指定资源的名称，名称也是大小写敏感的，如果省略名称，则会显示所有的资源，例如</li></ul><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods</code></pre></div><ul><li>flags：指定可选的参数，例如，可用 -s 或者 -server参数指定Kubernetes API server的地址和端口</li></ul><h2 id="3-常见命令"><a href="#3-常见命令" class="headerlink" title="3 常见命令"></a>3 常见命令</h2><h3 id="3-1-kubectl-help-获取更多信息"><a href="#3-1-kubectl-help-获取更多信息" class="headerlink" title="3.1 kubectl help 获取更多信息"></a>3.1 kubectl help 获取更多信息</h3><p>通过 help命令，能够获取帮助信息</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 获取kubectl的命令</span>kubectl --<span class="hljs-built_in">help</span><span class="hljs-comment"># 获取某个命令的介绍和使用</span>kubectl get --<span class="hljs-built_in">help</span></code></pre></div><h3 id="3-2-基础命令"><a href="#3-2-基础命令" class="headerlink" title="3.2 基础命令"></a>3.2 基础命令</h3><p>常见的基础命令</p><table><thead><tr><th align="center">命令</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">create</td><td align="center">通过文件名或标准输入创建资源</td></tr><tr><td align="center">expose</td><td align="center">将一个资源公开为一个新的Service</td></tr><tr><td align="center">run</td><td align="center">在集群中运行一个特定的镜像</td></tr><tr><td align="center">set</td><td align="center">在对象上设置特定的功能</td></tr><tr><td align="center">get</td><td align="center">显示一个或多个资源</td></tr><tr><td align="center">explain</td><td align="center">文档参考资料</td></tr><tr><td align="center">edit</td><td align="center">使用默认的编辑器编辑一个资源</td></tr><tr><td align="center">delete</td><td align="center">通过文件名，标准输入，资源名称或标签来删除资源</td></tr></tbody></table><h3 id="3-3-部署命令"><a href="#3-3-部署命令" class="headerlink" title="3.3 部署命令"></a>3.3 部署命令</h3><table><thead><tr><th align="center">命令</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">rollout</td><td align="center">管理资源的发布</td></tr><tr><td align="center">rolling-update</td><td align="center">对给定的复制控制器滚动更新</td></tr><tr><td align="center">scale</td><td align="center">扩容或缩容Pod数量，Deployment、ReplicaSet、RC或Job</td></tr><tr><td align="center">autoscale</td><td align="center">创建一个自动选择扩容或缩容并设置Pod数量</td></tr></tbody></table><h3 id="3-4-集群管理命令"><a href="#3-4-集群管理命令" class="headerlink" title="3.4 集群管理命令"></a>3.4 集群管理命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>certificate</td><td>修改证书资源</td></tr><tr><td>cluster-info</td><td>显示集群信息</td></tr><tr><td>top</td><td>显示资源(CPU/M)</td></tr><tr><td>cordon</td><td>标记节点不可调度</td></tr><tr><td>uncordon</td><td>标记节点可被调度</td></tr><tr><td>drain</td><td>驱逐节点上的应用，准备下线维护</td></tr><tr><td>taint</td><td>修改节点taint标记</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="3-5-故障和调试命令"><a href="#3-5-故障和调试命令" class="headerlink" title="3.5 故障和调试命令"></a>3.5 故障和调试命令</h3><table><thead><tr><th align="center">命令</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">describe</td><td align="center">显示特定资源或资源组的详细信息</td></tr><tr><td align="center">logs</td><td align="center">在一个Pod中打印一个容器日志，如果Pod只有一个容器，容器名称是可选的</td></tr><tr><td align="center">attach</td><td align="center">附加到一个运行的容器</td></tr><tr><td align="center">exec</td><td align="center">执行命令到容器</td></tr><tr><td align="center">port-forward</td><td align="center">转发一个或多个</td></tr><tr><td align="center">proxy</td><td align="center">运行一个proxy到Kubernetes API Server</td></tr><tr><td align="center">cp</td><td align="center">拷贝文件或目录到容器中</td></tr><tr><td align="center">auth</td><td align="center">检查授权</td></tr></tbody></table><h3 id="3-6-其它命令"><a href="#3-6-其它命令" class="headerlink" title="3.6 其它命令"></a>3.6 其它命令</h3><table><thead><tr><th align="center">命令</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">apply</td><td align="center">通过文件名或标准输入对资源应用配置</td></tr><tr><td align="center">patch</td><td align="center">使用补丁修改、更新资源的字段</td></tr><tr><td align="center">replace</td><td align="center">通过文件名或标准输入替换一个资源</td></tr><tr><td align="center">convert</td><td align="center">不同的API版本之间转换配置文件</td></tr><tr><td align="center">label</td><td align="center">更新资源上的标签</td></tr><tr><td align="center">annotate</td><td align="center">更新资源上的注释</td></tr><tr><td align="center">completion</td><td align="center">用于实现kubectl工具自动补全</td></tr><tr><td align="center">api-versions</td><td align="center">打印受支持的API版本</td></tr><tr><td align="center">config</td><td align="center">修改kubeconfig文件（用于访问API，比如配置认证信息）</td></tr><tr><td align="center">help</td><td align="center">所有命令帮助</td></tr><tr><td align="center">plugin</td><td align="center">运行一个命令行插件</td></tr><tr><td align="center">version</td><td align="center">打印客户端和服务版本信息</td></tr></tbody></table><h3 id="3-7-目前使用的命令"><a href="#3-7-目前使用的命令" class="headerlink" title="3.7 目前使用的命令"></a>3.7 目前使用的命令</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个nginx镜像</span>kubectl create deployment nginx --image=nginx<span class="hljs-comment"># 对外暴露端口</span>kubectl expose deployment nginx --port=80 --<span class="hljs-built_in">type</span>=NodePort<span class="hljs-comment"># 查看资源</span>kubectl get pod, svc</code></pre></div><h1 id="第7章-Kubernetes集群YAML文件详解"><a href="#第7章-Kubernetes集群YAML文件详解" class="headerlink" title="第7章 Kubernetes集群YAML文件详解"></a>第7章 Kubernetes集群YAML文件详解</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h2><p>k8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，也就是可以把需要对资源对象操作编辑到YAML 格式文件中，我们把这种文件叫做资源清单文件，通过kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。一般在我们开发的时候，都是通过配置YAML文件来部署集群的。</p><p>YAML文件：就是资源清单文件，用于资源编排</p><h2 id="2-YAML文件介绍"><a href="#2-YAML文件介绍" class="headerlink" title="2 YAML文件介绍"></a>2 YAML文件介绍</h2><h3 id="2-1-YAML概述"><a href="#2-1-YAML概述" class="headerlink" title="2.1 YAML概述"></a>2.1 YAML概述</h3><p>YAML ：仍是一种标记语言。为了强调这种语言以数据做为中心，而不是以标记语言为重点。</p><p>YAML 是一个可读性高，用来表达数据序列的格式。</p><h3 id="2-2-YAML-基本语法"><a href="#2-2-YAML-基本语法" class="headerlink" title="2.2 YAML 基本语法"></a>2.2 YAML 基本语法</h3><ul><li>使用空格做为缩进</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li>低版本缩进时不允许使用Tab 键，只允许使用空格</li><li>使用#标识注释，从这个字符一直到行尾，都会被解释器忽略</li><li>使用 — 表示新的yaml文件开始</li></ul><h3 id="2-3-YAML-支持的数据结构"><a href="#2-3-YAML-支持的数据结构" class="headerlink" title="2.3 YAML 支持的数据结构"></a>2.3 YAML 支持的数据结构</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>键值对的集合，又称为映射(mapping) / 哈希（hashes） / 字典（dictionary）</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 对象类型：对象的一组键值对，使用冒号结构表示</span><span class="hljs-attr">name:</span> <span class="hljs-string">Tom</span><span class="hljs-attr">age:</span> <span class="hljs-number">18</span><span class="hljs-comment"># yaml 也允许另一种写法，将所有键值对写成一个行内对象</span><span class="hljs-attr">hash:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">Tom</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">18</span>&#125;</code></pre></div><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 数组类型：一组连词线开头的行，构成一个数组</span>People- Tom- Jack<span class="hljs-comment"># 数组也可以采用行内表示法</span>People: [Tom, Jack]</code></pre></div><h2 id="3-YAML文件组成部分"><a href="#3-YAML文件组成部分" class="headerlink" title="3 YAML文件组成部分"></a>3 YAML文件组成部分</h2><p>主要分为了两部分，一个是控制器的定义和被控制的对象</p><h3 id="3-1-控制器的定义"><a href="#3-1-控制器的定义" class="headerlink" title="3.1 控制器的定义"></a>3.1 控制器的定义</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114110444032.png" alt="image-20201114110444032"></p><h3 id="3-2-被控制的对象"><a href="#3-2-被控制的对象" class="headerlink" title="3.2 被控制的对象"></a>3.2 被控制的对象</h3><p>包含一些 镜像，版本、端口等</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114110600165.png" alt="image-20201114110600165"></p><h3 id="3-3-属性说明"><a href="#3-3-属性说明" class="headerlink" title="3.3 属性说明"></a>3.3 属性说明</h3><p>在一个YAML文件的控制器定义中，有很多属性名称</p><table><thead><tr><th align="center">属性名称</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">apiVersion</td><td align="center">API版本</td></tr><tr><td align="center">kind</td><td align="center">资源类型</td></tr><tr><td align="center">metadata</td><td align="center">资源元数据</td></tr><tr><td align="center">spec</td><td align="center">资源规格</td></tr><tr><td align="center">replicas</td><td align="center">副本数量</td></tr><tr><td align="center">selector</td><td align="center">标签选择器</td></tr><tr><td align="center">template</td><td align="center">Pod模板</td></tr><tr><td align="center">metadata</td><td align="center">Pod元数据</td></tr><tr><td align="center">spec</td><td align="center">Pod规格</td></tr><tr><td align="center">containers</td><td align="center">容器配置</td></tr></tbody></table><h2 id="4-如何快速编写YAML文件"><a href="#4-如何快速编写YAML文件" class="headerlink" title="4 如何快速编写YAML文件"></a>4 如何快速编写YAML文件</h2><p>一般来说，我们很少自己手写YAML文件，因为这里面涉及到了很多内容，我们一般都会借助工具来创建</p><h3 id="使用kubectl-create命令"><a href="#使用kubectl-create命令" class="headerlink" title="使用kubectl create命令"></a>使用kubectl create命令</h3><p>这种方式一般用于资源没有部署的时候，我们可以直接创建一个YAML配置文件</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 尝试运行,并不会真正的创建镜像</span>kubectl create deployment web --image=nginx -o yaml --dry-run</code></pre></div><p>或者我们可以输出到一个文件中</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl create deployment web --image=nginx -o yaml --dry-run &gt; hello.yaml</code></pre></div><p>然后我们就在文件中直接修改即可</p><h3 id="使用kubectl-get命令导出yaml文件"><a href="#使用kubectl-get命令导出yaml文件" class="headerlink" title="使用kubectl get命令导出yaml文件"></a>使用kubectl get命令导出yaml文件</h3><p>可以首先查看一个目前已经部署的镜像</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get deploy</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114113115649.png" alt="image-20201114113115649"></p><p>然后我们导出 nginx的配置</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 注意 --export在新版本中已经被去除了</span>kubectl get deploy nginx -o=yaml --<span class="hljs-built_in">export</span> &gt; nginx.yaml</code></pre></div><p>然后会生成一个 <code>nginx.yaml</code> 的配置文件</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114184538797.png" alt="image-20201114184538797"></p><h1 id="第8章-Kubernetes核心技术Pod"><a href="#第8章-Kubernetes核心技术Pod" class="headerlink" title="第8章 Kubernetes核心技术Pod"></a>第8章 Kubernetes核心技术Pod</h1><h2 id="1-Pod概述"><a href="#1-Pod概述" class="headerlink" title="1 Pod概述"></a>1 Pod概述</h2><p>Pod是K8S系统中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最小资源对象模型，也是在K8S上运行容器化应用的资源对象，其它的资源对象都是用来支撑或者扩展Pod对象功能的，比如控制器对象是用来管控Pod对象的，Service或者Ingress资源对象是用来暴露Pod引用对象的，PersistentVolume资源对象是用来为Pod提供存储等等，K8S不会直接处理容器，而是Pod，Pod是由一个或多个container组成。</p><p>Pod是Kubernetes的最重要概念，每一个Pod都有一个特殊的被称为 “根容器”的Pause容器。Pause容器对应的镜像属于Kubernetes平台的一部分，除了Pause容器，每个Pod还包含一个或多个紧密相关的用户业务容器。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114185528215.png" alt="image-20201114185528215"></p><h3 id="Pod基本概念"><a href="#Pod基本概念" class="headerlink" title="Pod基本概念"></a>Pod基本概念</h3><ul><li>最小部署的单元</li><li>Pod里面是由一个或多个容器组成【一组容器的集合】</li><li>一个pod中的容器是共享网络命名空间</li><li>Pod是短暂的</li><li>每个Pod包含一个或多个紧密相关的用户业务容器</li></ul><h3 id="Pod存在的意义"><a href="#Pod存在的意义" class="headerlink" title="Pod存在的意义"></a>Pod存在的意义</h3><ul><li>创建容器使用docker，一个docker对应一个容器，一个容器运行一个应用进程</li><li>Pod是多进程设计，运用多个应用程序，也就是一个Pod里面有多个容器，而一个容器里面运行一个应用程序</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114190018948.png" alt="image-20201114190018948"></p><ul><li>Pod的存在是为了亲密性应用<ul><li>两个应用之间进行交互</li><li>网络之间的调用【通过127.0.0.1 或 socket】</li><li>两个应用之间需要频繁调用</li></ul></li></ul><p>Pod是在K8S集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。同时Pod对多容器的支持是K8S中最基础的设计理念。在生产环境中，通常是由不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。</p><p>Pod是K8S集群中所有业务类型的基础，可以把Pod看作运行在K8S集群上的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前K8S的业务主要可以分为以下几种</p><ul><li>长期伺服型：long-running</li><li>批处理型：batch</li><li>节点后台支撑型：node-daemon</li><li>有状态应用型：stateful application</li></ul><p>上述的几种类型，分别对应的小机器人控制器为：Deployment、Job、DaemonSet 和 StatefulSet  (后面将介绍控制器)</p><h2 id="2-Pod实现机制"><a href="#2-Pod实现机制" class="headerlink" title="2 Pod实现机制"></a>2 Pod实现机制</h2><p>主要有以下两大机制</p><ul><li>共享网络</li><li>共享存储</li></ul><h3 id="共享网络"><a href="#共享网络" class="headerlink" title="共享网络"></a>共享网络</h3><p>容器本身之间相互隔离的，一般是通过 <strong>namespace</strong> 和 <strong>group</strong> 进行隔离，那么Pod里面的容器如何实现通信？</p><ul><li>首先需要满足前提条件，也就是容器都在同一个<strong>namespace</strong>之间</li></ul><p>关于Pod实现原理，首先会在Pod会创建一个根容器： <code>pause容器</code>，然后我们在创建业务容器 【nginx，redis 等】，在我们创建业务容器的时候，会把它添加到 <code>info容器</code> 中</p><p>而在 <code>info容器</code> 中会独立出  ip地址，mac地址，port 等信息，然后实现网络的共享</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114190913859.png" alt="image-20201114190913859"></p><p>完整步骤如下</p><ul><li>通过 Pause 容器，把其它业务容器加入到Pause容器里，让所有业务容器在同一个名称空间中，可以实现网络共享</li></ul><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>Pod持久化数据，专门存储到某个地方中</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114193124160.png" alt="image-20201114193124160"></p><p>使用 Volumn数据卷进行共享存储，案例如下所示</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114193341993.png" alt="image-20201114193341993"></p><h2 id="3-Pod镜像拉取策略"><a href="#3-Pod镜像拉取策略" class="headerlink" title="3 Pod镜像拉取策略"></a>3 Pod镜像拉取策略</h2><p>我们以具体实例来说，拉取策略就是 <code>imagePullPolicy</code></p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114193605230.png" alt="image-20201114193605230"></p><p>拉取策略主要分为了以下几种</p><ul><li>IfNotPresent：默认值，镜像在宿主机上不存在才拉取</li><li>Always：每次创建Pod都会重新拉取一次镜像</li><li>Never：Pod永远不会主动拉取这个镜像</li></ul><h2 id="4-Pod资源限制"><a href="#4-Pod资源限制" class="headerlink" title="4 Pod资源限制"></a>4 Pod资源限制</h2><p>也就是我们Pod在进行调度的时候，可以对调度的资源进行限制，例如我们限制 Pod调度是使用的资源是 2C4G，那么在调度对应的node节点时，只会占用对应的资源，对于不满足资源的节点，将不会进行调度</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194057920.png" alt="image-20201114194057920"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们在下面的地方进行资源的限制</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194245517.png" alt="image-20201114194245517"></p><p>这里分了两个部分</p><ul><li>request：表示调度所需的资源</li><li>limits：表示最大所占用的资源</li></ul><h2 id="5-Pod重启机制"><a href="#5-Pod重启机制" class="headerlink" title="5 Pod重启机制"></a>5 Pod重启机制</h2><p>因为Pod中包含了很多个容器，假设某个容器出现问题了，那么就会触发Pod重启机制</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194722125.png" alt="image-20201114194722125"></p><p>重启策略主要分为以下三种</p><ul><li>Always：当容器终止退出后，总是重启容器，默认策略 【nginx等，需要不断提供服务】</li><li>OnFailure：当容器异常退出（退出状态码非0）时，才重启容器。</li><li>Never：当容器终止退出，从不重启容器 【批量任务】</li></ul><h2 id="6-Pod健康检查"><a href="#6-Pod健康检查" class="headerlink" title="6 Pod健康检查"></a>6 Pod健康检查</h2><p>通过容器检查，原来我们使用下面的命令来检查</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pod</code></pre></div><p>但是有的时候，程序可能出现了 <strong>Java</strong> 堆内存溢出，程序还在运行，但是不能对外提供服务了，这个时候就不能通过 容器检查来判断服务是否可用了</p><p>这个时候就可以使用应用层面的检查</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 存活检查，如果检查失败，将杀死容器，根据Pod的restartPolicy【重启策略】来操作</span>livenessProbe<span class="hljs-comment"># 就绪检查，如果检查失败，Kubernetes会把Pod从Service endpoints中剔除</span>readinessProbe</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114195807564.png" alt="image-20201114195807564"></p><p>Probe支持以下三种检查方式</p><ul><li>http Get：发送HTTP请求，返回200 - 400 范围状态码为成功</li><li>exec：执行Shell命令返回状态码是0为成功</li><li>tcpSocket：发起TCP Socket建立成功</li></ul><h2 id="7-Pod调度策略"><a href="#7-Pod调度策略" class="headerlink" title="7 Pod调度策略"></a>7 Pod调度策略</h2><h3 id="创建Pod流程"><a href="#创建Pod流程" class="headerlink" title="创建Pod流程"></a>创建Pod流程</h3><ul><li>首先创建一个pod，然后创建一个API Server 和 Etcd【把创建出来的信息存储在etcd中】</li><li>然后创建 Scheduler，监控API Server是否有新的Pod，如果有的话，会通过调度算法，把pod调度某个node上</li><li>在node节点，会通过 <code>kubelet -- apiserver</code> 读取etcd 拿到分配在当前node节点上的pod，然后通过docker创建容器</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114201611308.png" alt="image-20201114201611308"></p><h3 id="影响Pod调度的属性"><a href="#影响Pod调度的属性" class="headerlink" title="影响Pod调度的属性"></a>影响Pod调度的属性</h3><p>Pod资源限制对Pod的调度会有影响</p><h4 id="根据request找到足够node节点进行调度"><a href="#根据request找到足够node节点进行调度" class="headerlink" title="根据request找到足够node节点进行调度"></a>根据request找到足够node节点进行调度</h4><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194245517.png" alt="image-20201114194245517"></p><h4 id="节点选择器标签影响Pod调度"><a href="#节点选择器标签影响Pod调度" class="headerlink" title="节点选择器标签影响Pod调度"></a>节点选择器标签影响Pod调度</h4><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114202456151.png" alt="image-20201114202456151"></p><p>关于节点选择器，其实就是有两个环境，然后环境之间所用的资源配置不同</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114202643905.png" alt="image-20201114202643905"></p><p>我们可以通过以下命令，给我们的节点新增标签，然后节点选择器就会进行调度了</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl label node node1 env_role=prod</code></pre></div><h4 id="节点亲和性"><a href="#节点亲和性" class="headerlink" title="节点亲和性"></a>节点亲和性</h4><p>节点亲和性 <strong>nodeAffinity</strong> 和 之前nodeSelector 基本一样的，根据节点上标签约束来决定Pod调度到哪些节点上</p><ul><li>硬亲和性：约束条件必须满足</li><li>软亲和性：尝试满足，不保证</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114203433939.png" alt="image-20201114203433939"></p><p>支持常用操作符：in、NotIn、Exists、Gt、Lt、DoesNotExists</p><p>反亲和性：就是和亲和性刚刚相反，如 NotIn、DoesNotExists等</p><h2 id="8-污点和污点容忍"><a href="#8-污点和污点容忍" class="headerlink" title="8 污点和污点容忍"></a>8 污点和污点容忍</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><p>nodeSelector 和 NodeAffinity，都是Prod调度到某些节点上，属于Pod的属性，是在调度的时候实现的。</p><p>Taint 污点：节点不做普通分配调度，是节点属性</p><h3 id="8-2-场景"><a href="#8-2-场景" class="headerlink" title="8.2 场景"></a>8.2 场景</h3><ul><li>专用节点【限制ip】</li><li>配置特定硬件的节点【固态硬盘】</li><li>基于Taint驱逐【在node1不放，在node2放】</li></ul><h3 id="8-3-查看污点情况"><a href="#8-3-查看污点情况" class="headerlink" title="8.3 查看污点情况"></a>8.3 查看污点情况</h3><div class="code-wrapper"><pre><code class="hljs bash">kubectl describe node k8smaster | grep Taint</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114204124819.png" alt="image-20201114204124819"></p><p>污点值有三个</p><ul><li>NoSchedule：一定不被调度</li><li>PreferNoSchedule：尽量不被调度【也有被调度的几率】</li><li>NoExecute：不会调度，并且还会驱逐Node已有Pod</li></ul><h3 id="8-4-未节点添加污点"><a href="#8-4-未节点添加污点" class="headerlink" title="8.4 未节点添加污点"></a>8.4 未节点添加污点</h3><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node [node] key=value:污点的三个值</code></pre></div><p>举例：</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role=yes:NoSchedule</code></pre></div><h3 id="8-5-删除污点"><a href="#8-5-删除污点" class="headerlink" title="8.5 删除污点"></a>8.5 删除污点</h3><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role:NoSchedule-</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114210022883.png" alt="image-20201114210022883"></p><h3 id="8-6-演示"><a href="#8-6-演示" class="headerlink" title="8.6 演示"></a>8.6 演示</h3><p>我们现在创建多个Pod，查看最后分配到Node上的情况</p><p>首先我们创建一个 nginx 的pod</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl create deployment web --image=nginx</code></pre></div><p>然后使用命令查看</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods -o wide</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114204917548.png" alt="image-20201114204917548"></p><p>我们可以非常明显的看到，这个Pod已经被分配到 k8snode1 节点上了</p><p>下面我们把pod复制5份，在查看情况pod情况</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl scale deployment web --replicas=5</code></pre></div><p>我们可以发现，因为master节点存在污点的情况，所以节点都被分配到了 node1 和 node2节点上</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114205135282.png" alt="image-20201114205135282"></p><p>我们可以使用下面命令，把刚刚我们创建的pod都删除</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl delete deployment web</code></pre></div><p>现在给了更好的演示污点的用法，我们现在给 node1节点打上污点</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role=yes:NoSchedule</code></pre></div><p>然后我们查看污点是否成功添加</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl describe node k8snode1 | grep Taint</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114205516154.png" alt="image-20201114205516154"></p><p>然后我们在创建一个 pod</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建nginx pod</span>kubectl create deployment web --image=nginx<span class="hljs-comment"># 复制五次</span>kubectl scale deployment web --replicas=5</code></pre></div><p>然后我们在进行查看</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods -o wide</code></pre></div><p>我们能够看到现在所有的pod都被分配到了 k8snode2上，因为刚刚我们给node1节点设置了污点</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114205654867.png" alt="image-20201114205654867"></p><p>最后我们可以删除刚刚添加的污点</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role:NoSchedule-</code></pre></div><h3 id="8-7-污点容忍"><a href="#8-7-污点容忍" class="headerlink" title="8.7 污点容忍"></a>8.7 污点容忍</h3><p>污点容忍就是某个节点可能被调度，也可能不被调度</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114210146123.png" alt="image-20201114210146123"></p><h1 id="第9章-Kubernetes核心技术-Controller"><a href="#第9章-Kubernetes核心技术-Controller" class="headerlink" title="第9章 Kubernetes核心技术-Controller"></a>第9章 Kubernetes核心技术-Controller</h1><h2 id="1-内容"><a href="#1-内容" class="headerlink" title="1 内容"></a>1 内容</h2><ul><li>什么是Controller</li><li>Pod和Controller的关系</li><li>Deployment控制器应用场景</li><li>yaml文件字段说明</li><li>Deployment控制器部署应用</li><li>升级回滚</li><li>弹性伸缩</li></ul><h2 id="2-什么是Controller"><a href="#2-什么是Controller" class="headerlink" title="2 什么是Controller"></a>2 什么是Controller</h2><p>Controller是在集群上管理和运行容器的对象，Controller是实际存在的，Pod是虚拟机的</p><h2 id="3-Pod和Controller的关系"><a href="#3-Pod和Controller的关系" class="headerlink" title="3 Pod和Controller的关系"></a>3 Pod和Controller的关系</h2><p>Pod是通过Controller实现应用的运维，比如弹性伸缩，滚动升级等</p><p>Pod 和 Controller之间是通过label标签来建立关系，同时Controller又被称为控制器工作负载</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116092431237.png" alt="image-20201116092431237"></p><h2 id="4-Deployment控制器应用"><a href="#4-Deployment控制器应用" class="headerlink" title="4 Deployment控制器应用"></a>4 Deployment控制器应用</h2><ul><li>Deployment控制器可以部署无状态应用</li><li>管理Pod和ReplicaSet</li><li>部署，滚动升级等功能</li><li>应用场景：web服务，微服务</li></ul><p>Deployment表示用户对K8S集群的一次更新操作。Deployment是一个比RS( Replica Set, RS) 应用模型更广的 API 对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧RS中的副本数减少到0的复合操作。</p><p>这样一个复合操作用一个RS是不好描述的，所以用一个更通用的Deployment来描述。以K8S的发展方向，未来对所有长期伺服型的业务的管理，都会通过Deployment来管理。</p><h2 id="5-Deployment部署应用"><a href="#5-Deployment部署应用" class="headerlink" title="5 Deployment部署应用"></a>5 Deployment部署应用</h2><p>之前我们也使用Deployment部署过应用，如下代码所示</p><div class="code-wrapper"><pre><code class="hljs bash">kubectrl create deployment web --image=nginx</code></pre></div><p>但是上述代码不是很好的进行复用，因为每次我们都需要重新输入代码，所以我们都是通过YAML进行配置</p><p>但是我们可以尝试使用上面的代码创建一个镜像【只是尝试，不会创建】</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl create deployment web --image=nginx --dry-run -o yaml &gt; nginx.yaml</code></pre></div><p>然后输出一个yaml配置文件 <code>nginx.yml</code> ，配置文件如下所示</p><div class="code-wrapper"><pre><code class="hljs bash">apiVersion: apps/v1kind: Deploymentmetadata:  creationTimestamp: null  labels:    app: web  name: webspec:  replicas: 1  selector:    matchLabels:      app: web  strategy: &#123;&#125;  template:    metadata:      creationTimestamp: null      labels:        app: web    spec:      containers:      - image: nginx        name: nginx        resources: &#123;&#125;status: &#123;&#125;</code></pre></div><p>我们看到的 selector 和 label 就是我们Pod 和 Controller之间建立关系的桥梁</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116093638951.png" alt="image-20201116093638951"></p><h3 id="使用YAML创建Pod"><a href="#使用YAML创建Pod" class="headerlink" title="使用YAML创建Pod"></a>使用YAML创建Pod</h3><p>通过刚刚的代码，我们已经生成了YAML文件，下面我们就可以使用该配置文件快速创建Pod镜像了</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl apply -f nginx.yaml</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116094046007.png" alt="image-20201116094046007"></p><p>但是因为这个方式创建的，我们只能在集群内部进行访问，所以我们还需要对外暴露端口</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl expose deployment web --port=80 --<span class="hljs-built_in">type</span>=NodePort --target-port=80 --name=web1</code></pre></div><p>关于上述命令，有几个参数</p><ul><li>–port：就是我们内部的端口号</li><li>–target-port：就是暴露外面访问的端口号</li><li>–name：名称</li><li>–type：类型</li></ul><p>同理，我们一样可以导出对应的配置文件</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl expose deployment web --port=80 --<span class="hljs-built_in">type</span>=NodePort --target-port=80 --name=web1 -o yaml &gt; web1.yaml</code></pre></div><p>得到的web1.yaml如下所示</p><div class="code-wrapper"><pre><code class="hljs bash">apiVersion: v1kind: Servicemetadata:  creationTimestamp: <span class="hljs-string">&quot;2020-11-16T02:26:53Z&quot;</span>  labels:    app: web  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:metadata:        f:labels:          .: &#123;&#125;          f:app: &#123;&#125;      f:spec:        f:externalTrafficPolicy: &#123;&#125;        f:ports:          .: &#123;&#125;          k:&#123;<span class="hljs-string">&quot;port&quot;</span>:80,<span class="hljs-string">&quot;protocol&quot;</span>:<span class="hljs-string">&quot;TCP&quot;</span>&#125;:            .: &#123;&#125;            f:port: &#123;&#125;            f:protocol: &#123;&#125;            f:targetPort: &#123;&#125;        f:selector:          .: &#123;&#125;          f:app: &#123;&#125;        f:sessionAffinity: &#123;&#125;        f:<span class="hljs-built_in">type</span>: &#123;&#125;    manager: kubectl    operation: Update    time: <span class="hljs-string">&quot;2020-11-16T02:26:53Z&quot;</span>  name: web2  namespace: default  resourceVersion: <span class="hljs-string">&quot;113693&quot;</span>  selfLink: /api/v1/namespaces/default/services/web2  uid: d570437d-a6b4-4456-8dfb-950f09534516spec:  clusterIP: 10.104.174.145  externalTrafficPolicy: Cluster  ports:  - nodePort: 32639    port: 80    protocol: TCP    targetPort: 80  selector:    app: web  sessionAffinity: None  <span class="hljs-built_in">type</span>: NodePortstatus:  loadBalancer: &#123;&#125;</code></pre></div><p>然后我们可以通过下面的命令来查看对外暴露的服务</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods,svc</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116104021357.png" alt="image-20201116104021357"></p><p>然后我们访问对应的url，即可看到 nginx了 <code>http://192.168.177.130:32639/</code></p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116104131968.png" alt="image-20201116104131968"></p><h2 id="6-升级回滚和弹性伸缩"><a href="#6-升级回滚和弹性伸缩" class="headerlink" title="6 升级回滚和弹性伸缩"></a>6 升级回滚和弹性伸缩</h2><ul><li>升级：  假设从版本为1.14 升级到 1.15 ，这就叫应用的升级【升级可以保证服务不中断】</li><li>回滚：从版本1.15 变成 1.14，这就叫应用的回滚</li><li>弹性伸缩：我们根据不同的业务场景，来改变Pod的数量对外提供服务，这就是弹性伸缩</li></ul><h3 id="应用升级和回滚"><a href="#应用升级和回滚" class="headerlink" title="应用升级和回滚"></a>应用升级和回滚</h3><p>首先我们先创建一个 1.14版本的Pod</p><div class="code-wrapper"><pre><code class="hljs bash">apiVersion: apps/v1kind: Deploymentmetadata:  creationTimestamp: null  labels:    app: web  name: webspec:  replicas: 1  selector:    matchLabels:      app: web  strategy: &#123;&#125;  template:    metadata:      creationTimestamp: null      labels:        app: web    spec:      containers:      - image: nginx:1.14        name: nginx        resources: &#123;&#125;status: &#123;&#125;</code></pre></div><p>我们先指定版本为1.14，然后开始创建我们的Pod</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl apply -f nginx.yaml</code></pre></div><p>同时，我们使用docker images命令，就能看到我们成功拉取到了一个 1.14版本的镜像</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116105710966.png" alt="image-20201116105710966"></p><p>我们使用下面的命令，可以将nginx从 1.14 升级到 1.15</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">set</span> image deployment web nginx=nginx:1.15</code></pre></div><p>在我们执行完命令后，能看到升级的过程</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116105847069.png" alt="image-20201116105847069"></p><ul><li>首先是开始的nginx 1.14版本的Pod在运行，然后 1.15版本的在创建</li><li>然后在1.15版本创建完成后，就会暂停1.14版本</li><li>最后把1.14版本的Pod移除，完成我们的升级</li></ul><p>我们在下载 1.15版本，容器就处于ContainerCreating状态，然后下载完成后，就用 1.15版本去替换1.14版本了，这么做的好处就是：升级可以保证服务不中断</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116111614085.png" alt="image-20201116111614085"></p><p>我们到我们的node2节点上，查看我们的 docker images;</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116111315000.png" alt="image-20201116111315000"></p><p>能够看到，我们已经成功拉取到了 1.15版本的nginx了</p><h4 id="查看升级状态"><a href="#查看升级状态" class="headerlink" title="查看升级状态"></a>查看升级状态</h4><p>下面可以，查看升级状态</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout status deployment web</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116112139645.png" alt="image-20201116112139645"></p><h4 id="查看历史版本"><a href="#查看历史版本" class="headerlink" title="查看历史版本"></a>查看历史版本</h4><p>我们还可以查看历史版本</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout <span class="hljs-built_in">history</span> deployment web</code></pre></div><h4 id="应用回滚"><a href="#应用回滚" class="headerlink" title="应用回滚"></a>应用回滚</h4><p>我们可以使用下面命令，完成回滚操作，也就是回滚到上一个版本</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout undo deployment web</code></pre></div><p>然后我们就可以查看状态</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout status deployment web</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116112524601.png" alt="image-20201116112524601"></p><p>同时我们还可以回滚到指定版本</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout undo deployment web --to-revision=2</code></pre></div><h3 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h3><p>弹性伸缩，也就是我们通过命令一下创建多个副本</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl scale deployment web --replicas=10</code></pre></div><p>能够清晰看到，我们一下创建了10个副本</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201117092841865.png" alt="image-20201117092841865"></p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Distributed/">Distributed</category>
      
      
      <category domain="https://pncalbl.github.io/tags/k8s/">k8s</category>
      
      
      <comments>https://pncalbl.github.io/2021/07/22/K8s%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM 学习</title>
      <link>https://pncalbl.github.io/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Mon, 19 Jul 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;第一部分-内存与垃圾回收&quot;&gt;&lt;a href=&quot;#第一部分-内存与垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;第一部分 内存与垃圾回收&quot;&gt;&lt;/a&gt;第一部分 内存与垃圾回收&lt;/h1&gt;&lt;h1 id=&quot;第1章-JVM与Java体系结构&quot;&gt;&lt;a href</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="第一部分-内存与垃圾回收"><a href="#第一部分-内存与垃圾回收" class="headerlink" title="第一部分 内存与垃圾回收"></a>第一部分 内存与垃圾回收</h1><h1 id="第1章-JVM与Java体系结构"><a href="#第1章-JVM与Java体系结构" class="headerlink" title="第1章 JVM与Java体系结构"></a>第1章 JVM与Java体系结构</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？</p><p>运行着的线上系统突然卡死，系统无法访问，甚至直接OOMM！</p><ul><li>想解决线上JVM GC问题，但却无从下手。</li><li>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了</li><li>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200704111417472.png" alt="image-20200704111417472"></p><p>大部分Java开发人员，除会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</p><p>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</p><p>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200704112119729.png" alt="image-20200704112119729"></p><h2 id="2-架构师每天都在思考什么？"><a href="#2-架构师每天都在思考什么？" class="headerlink" title="2 架构师每天都在思考什么？"></a>2 架构师每天都在思考什么？</h2><ul><li>应该如何让我的系统更快？</li><li>如何避免系统出现瓶颈？</li></ul><p>知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？</p><ul><li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li><li>根据业务场景和需求，决定技术方向，做技术选型</li><li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li><li>解决各类潜在系统风险，核心功能的架构与代码编写</li><li>分析系统瓶颈，解决各种疑难杂症，性能调优等</li></ul><h2 id="3-为什么要学习JVM"><a href="#3-为什么要学习JVM" class="headerlink" title="3 为什么要学习JVM"></a>3 为什么要学习JVM</h2><ul><li><p>面试的需要（BATJ、TMD，PKQ等面试都爱问）</p></li><li><p>中高级程序员必备技能</p><ul><li>项目管理、调优的需求</li></ul></li><li><p>追求极客的精神</p><ul><li>比如：垃圾回收算法、JIT（及时编译器）、底层原理</li></ul></li></ul><h2 id="4-Java-vs-C"><a href="#4-Java-vs-C" class="headerlink" title="4 Java vs C++"></a>4 Java vs C++</h2><p>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200704112700211.png" alt="image-20200704112700211"></p><p>C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。</p><h2 id="5-推荐书籍"><a href="#5-推荐书籍" class="headerlink" title="5 推荐书籍"></a>5 推荐书籍</h2><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200704145340513.png" alt="image-20200704145340513"></p><h2 id="6-Java生态圈"><a href="#6-Java生态圈" class="headerlink" title="6 Java生态圈"></a>6 Java生态圈</h2><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p><ul><li><p>作为一个平台，Java虚拟机扮演着举足轻重的作用</p><ul><li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li></ul></li><li><p>作为灯种文化，Java几乎成为了“开源”的代名词。</p><ul><li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li><li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li></ul></li><li><p>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</p></li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200704151731216.png" alt="image-20200704151731216"></p><p>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200704152052489.png" alt="image-20200704152052489"></p><p>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</p><p>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p><h2 id="7-字节码"><a href="#7-字节码" class="headerlink" title="7 字节码"></a>7 字节码</h2><p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</p><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p><p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</p><h2 id="8-多语言混合编程"><a href="#8-多语言混合编程" class="headerlink" title="8 多语言混合编程"></a>8 多语言混合编程</h2><p>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p><p>试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</p><p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</p><h2 id="9-Java发展的重大事件"><a href="#9-Java发展的重大事件" class="headerlink" title="9 Java发展的重大事件"></a>9 Java发展的重大事件</h2><ul><li><p>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java</p></li><li><p>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</p></li><li><p>1996年1月23日sun Microsystems发布了JDK 1.0。</p></li><li><p>1998年，JDK1.2版本发布。同时，sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</p></li><li><p>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</p></li><li><p>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</p></li><li><p>2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</p></li><li><p>2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</p></li><li><p>2006年，JDK6发布。同年，Java开源并建立了openJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。</p></li><li><p>2007年，Java平台迎来了新伙伴Clojure。</p></li><li><p>2008年，oracle收购了BEA，得到了JRockit虚拟机。</p></li><li><p>2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。</p></li><li><p>2010年，oracle收购了sun，获得Java商标和最真价值的HotSpot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit</p></li><li><p>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</p></li><li><p>2017年，JDK9发布。将G1设置为默认Gc，替代CMS</p></li><li><p>同年，IBM的J9开源，形成了现在的open J9社区</p></li><li><p>2018年，Android的Java侵权案判决，Google赔偿oracle计88亿美元</p></li><li><p>同年，oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</p></li><li><p>同年，JDK11发布，LTS版本的JDK，发布革命性的zGc，调整JDK授权许可</p></li><li><p>2019年，JDK12发布，加入RedHat领导开发的shenandoah GC</p></li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200704182035810.png" alt="image-20200704182035810"></p><p>在JDK11之前，oracleJDK中还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，我们可以认为openJDK和oracleJDK代码实质上已经完全一致的程度。</p><h2 id="10-虚拟机与Java虚拟机"><a href="#10-虚拟机与Java虚拟机" class="headerlink" title="10 虚拟机与Java虚拟机"></a>10 虚拟机与Java虚拟机</h2><h3 id="10-1-虚拟机"><a href="#10-1-虚拟机" class="headerlink" title="10.1 虚拟机"></a>10.1 虚拟机</h3><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li>大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</li><li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li></ul><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p><h3 id="10-2-Java虚拟机"><a href="#10-2-Java虚拟机" class="headerlink" title="10.2 Java虚拟机"></a>10.2 Java虚拟机</h3><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p><p>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p><p>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</p><p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p>特点：</p><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><h2 id="11-JVM的位置"><a href="#11-JVM的位置" class="headerlink" title="11 JVM的位置"></a>11 JVM的位置</h2><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200704183048061.png" alt="image-20200704183048061"></p><p>Java的体系结构</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200704183236169.png" alt="image-20200704183236169"></p><h2 id="12-JVM整体结构"><a href="#12-JVM整体结构" class="headerlink" title="12 JVM整体结构"></a>12 JVM整体结构</h2><ul><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200704183436495.png" alt="image-20200704183436495"></p><p>执行引擎包含三部分：解释器，及时编译器，垃圾回收器</p><h2 id="13-Java代码执行流程"><a href="#13-Java代码执行流程" class="headerlink" title="13 Java代码执行流程"></a>13 Java代码执行流程</h2><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200704210429535.png" alt="image-20200704210429535"></p><p>只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了</p><h2 id="14-JVM的架构模型"><a href="#14-JVM的架构模型" class="headerlink" title="14 JVM的架构模型"></a>14 JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p><p>基于栈式架构的特点</p><ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配。</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul><p>基于寄存器架构的特点</p><ul><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作。</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p><p>基于栈的计算流程（以Java虚拟机为例）：</p><div class="code-wrapper"><pre><code class="hljs bash">iconst_2 //常量2入栈istore_1iconst_3 // 常量3入栈istore_2iload_1iload_2iadd //常量2/3出栈，执行相加istore_0 // 结果5入栈</code></pre></div><p>而基于寄存器的计算流程</p><div class="code-wrapper"><pre><code class="hljs bash">mov eax,2 //将eax寄存器的值设为1add eax,3 //使eax寄存器的值加3</code></pre></div><h3 id="字节码反编译"><a href="#字节码反编译" class="headerlink" title="字节码反编译"></a>字节码反编译</h3><p>我们编写一个简单的代码，然后查看一下字节码的反编译后的结果</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/7/20 21:31</span><span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackStruTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;    &#125;&#125;</code></pre></div><p>然后我们找到编译后的 class文件，使用下列命令进行反编译</p><div class="code-wrapper"><pre><code class="hljs bash">javap -v StackStruTest.class</code></pre></div><p>得到的文件为:</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> static void main(java.lang.String[]);  <span class="hljs-attribute">descriptor</span>: ([Ljava/lang/String;)V  <span class="hljs-attribute">flags</span>: ACC_PUBLIC, ACC_STATIC  <span class="hljs-attribute">Code</span>:    <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span>       <span class="hljs-attribute">0</span>: iconst_<span class="hljs-number">2</span>       <span class="hljs-attribute">1</span>: istore_<span class="hljs-number">1</span>       <span class="hljs-attribute">2</span>: iconst_<span class="hljs-number">3</span>       <span class="hljs-attribute">3</span>: istore_<span class="hljs-number">2</span>       <span class="hljs-attribute">4</span>: iload_<span class="hljs-number">1</span>       <span class="hljs-attribute">5</span>: iload_<span class="hljs-number">2</span>       <span class="hljs-attribute">6</span>: iadd       <span class="hljs-attribute">7</span>: istore_<span class="hljs-number">3</span>       <span class="hljs-attribute">8</span>: return    <span class="hljs-attribute">LineNumberTable</span>:      <span class="hljs-attribute">line</span> <span class="hljs-number">9</span>: <span class="hljs-number">0</span>      <span class="hljs-attribute">line</span> <span class="hljs-number">10</span>: <span class="hljs-number">2</span>      <span class="hljs-attribute">line</span> <span class="hljs-number">11</span>: <span class="hljs-number">4</span>      <span class="hljs-attribute">line</span> <span class="hljs-number">12</span>: <span class="hljs-number">8</span>    <span class="hljs-attribute">LocalVariableTable</span>:      <span class="hljs-attribute">Start</span>  Length  Slot  Name   Signature          <span class="hljs-attribute">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args  <span class="hljs-meta"> [Ljava/lang/String;</span><span class="hljs-meta">          2       7     1     i   I</span><span class="hljs-meta">          4       5     2     j   I</span><span class="hljs-meta">          8       1     3     k   I</span></code></pre></div><h2 id="15-总结"><a href="#15-总结" class="headerlink" title="15 总结"></a>15 总结</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>跨平台性</li><li>指令集小</li><li>指令多</li><li>执行性能比寄存器差</li></ul><h2 id="16-JVM生命周期"><a href="#16-JVM生命周期" class="headerlink" title="16 JVM生命周期"></a>16 JVM生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li></ul><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下的几种情况：</p><ul><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常或错误而异常终止</p></li><li><p>由于操作系统用现错误而导致Java虚拟机进程终止</p></li><li><p>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</p></li><li><p>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</p></li></ul><h2 id="17-JVM发展历程"><a href="#17-JVM发展历程" class="headerlink" title="17 JVM发展历程"></a>17 JVM发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul><li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</li><li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在hotspot内置了此虚拟机。</li></ul><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><p>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。<br>Exact Memory Management：准确式内存管理</p><ul><li>也可以叫Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型。|</li></ul><p>具备现代高性能虚拟机的维形</p><ul><li>热点探测（寻找出热点代码进行缓存）</li><li>编译器与解释器混合工作模式</li></ul><p>只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p><h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><p>HotSpot历史</p><ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。</li><li>JDK1.3时，HotSpot VM成为默认虚拟机</li></ul><p>目前Hotspot占有绝对的市场地位，称霸武林。</p><ul><li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li><li>Sun/oracle JDK和openJDK的默认虚拟机</li><li>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念）</li></ul><p>从服务器、桌面到移动端、嵌入式都有应用。</p><p>名称中的HotSpot指的就是它的热点代码探测技术。</p><ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul><h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><p>专注于服务器端应用</p><ul><li>它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li></ul><p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</p><ul><li>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li></ul><p>优势：全面的Java运行时解决方案组合</p><ul><li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li><li>MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul><p>2008年，JRockit被oracle收购。</p><p>oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p><h3 id="IBM的J9"><a href="#IBM的J9" class="headerlink" title="IBM的J9"></a>IBM的J9</h3><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p><p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p><p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</p><p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9</p><p>OpenJDK   -&gt; 是JDK开源了，包括了虚拟机</p><h3 id="KVM和CDC-CLDC-Hotspot"><a href="#KVM和CDC-CLDC-Hotspot" class="headerlink" title="KVM和CDC / CLDC  Hotspot"></a>KVM和CDC / CLDC  Hotspot</h3><p>oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。</p><p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li>智能控制器、传感器</li><li>老人手机、经济欠发达地区的功能手机</li></ul><p>所有的虚拟机的原则：一次编译，到处运行。</p><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><p>前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azu1VW和BEALiquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机I</p><ul><li>高性能Java虚拟机中的战斗机。</li></ul><p>Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。</p><p>每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</p><p>2010年，AzulSystems公司开始从硬件转向软件，发布了自己的zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</p><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><p>高性能Java虚拟机中的战斗机。</p><p>BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition），</p><p>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</p><p>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</p><h3 id="Apache-Marmony"><a href="#Apache-Marmony" class="headerlink" title="Apache Marmony"></a>Apache Marmony</h3><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p><p>它是IElf和Inte1联合开发的开源JVM，受到同样开源的openJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p><p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p><h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p><p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p><p>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXPSP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</p><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p><p>基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</p><p>基于openJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p><ul><li>创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且Gc不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。</li><li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li><li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li><li>PMU hardware的Java profiling tool和诊断协助功能</li><li>针对大数据场景的ZenGc </li></ul><p>taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</p><p>目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。</p><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p><p>Dalvik y只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范</p><p>不能直接执行Java的Class文件</p><p>基于寄存器架构，不是jvm的栈架构。</p><p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p><ul><li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li></ul><p>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</p><h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><p>2018年4月，oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p><p>GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”<br>的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p><p>如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle HotSpot VM为默认虚拟机。</p><h1 id="第2章-类加载子系统"><a href="#第2章-类加载子系统" class="headerlink" title="第2章 类加载子系统"></a>第2章 类加载子系统</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705080719531.png" alt="image-20200705080719531"></p><p>完整图如下</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705080911284.png" alt="image-20200705080911284"></p><p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p><ul><li>类加载器</li><li>执行引擎</li></ul><h2 id="2-类加载器子系统作用"><a href="#2-类加载器子系统作用" class="headerlink" title="2 类加载器子系统作用"></a>2 类加载器子系统作用</h2><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705081813409.png" alt="image-20200705081813409"></p><ul><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li><li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705081913538.png" alt="image-20200705081913538"></p><h2 id="3-类的加载过程"><a href="#3-类的加载过程" class="headerlink" title="3 类的加载过程"></a>3 类的加载过程</h2><p>例如下面的一段简单的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloLoader</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;我已经被加载啦&quot;</span>);    &#125;&#125;</code></pre></div><p>它的加载过程是怎么样的呢?</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705082255746.png" alt="image-20200705082255746"></p><p>完整的流程图如下所示</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705082601441.png" alt="image-20200705082601441"></p><h2 id="4-加载阶段"><a href="#4-加载阶段" class="headerlink" title="4 加载阶段"></a>4 加载阶段</h2><p>通过一个类的全限定名获取定义此类的二进制字节流</p><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><h3 id="4-1-加载class文件的方式"><a href="#4-1-加载class文件的方式" class="headerlink" title="4.1 加载class文件的方式"></a>4.1 加载class文件的方式</h3><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h3 id="4-2-链接阶段"><a href="#4-2-链接阶段" class="headerlink" title="4.2 链接阶段"></a>4.2 链接阶段</h3><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p><blockquote><p>工具：Binary Viewer查看</p></blockquote><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705084038680.png" alt="image-20200705084038680"></p><p>如果出现不合法的字节码文件，那么将会验证不通过</p><p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705090237078.png" alt="image-20200705090237078"></p><p>安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705090328171.png" alt="image-20200705090328171"></p><h3 id="4-3-准备-Prepare"><a href="#4-3-准备-Prepare" class="headerlink" title="4.3 准备 Prepare"></a>4.3 准备 Prepare</h3><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloApp</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(a);    &#125;&#125;</code></pre></div><p>上面的变量a在准备阶段会赋初始值，但不是1，而是0。</p><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p><p>例如下面这段代码</p><h3 id="4-4-解析-Resolve"><a href="#4-4-解析-Resolve" class="headerlink" title="4.4 解析 Resolve"></a>4.4 解析 Resolve</h3><p>将常量池内的符号引用转换为直接引用的过程。</p><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p><h3 id="4-5-初始化阶段"><a href="#4-5-初始化阶段" class="headerlink" title="4.5 初始化阶段"></a>4.5 初始化阶段</h3><p>初始化阶段就是执行类构造器法<clinit>（）的过程。</clinit></p><p>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p><ul><li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li></ul><p>构造器方法中指令按语句在源文件中出现的顺序执行。</p><p><clinit>（）不同于类的构造器。（关联：构造器是虚拟机视角下的<init>（））若该类具有父类，JVM会保证子类的<clinit>（）执行前，父类的<clinit>（）已经执行完毕。</clinit></clinit></init></clinit></p><ul><li>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassInitTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> &#123;        num = <span class="hljs-number">2</span>;        number = <span class="hljs-number">20</span>;        System.out.println(num);        System.out.println(number);  <span class="hljs-comment">//报错，非法的前向引用</span>    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(ClassInitTest.num); <span class="hljs-comment">// 2</span>        System.out.println(ClassInitTest.number); <span class="hljs-comment">// 10</span>    &#125;&#125;</code></pre></div><p>关于涉及到父类时候的变量赋值过程</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClinitTest1</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">1</span>;        <span class="hljs-keyword">static</span> &#123;            A = <span class="hljs-number">2</span>;        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = A;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(Son.b);    &#125;&#125;</code></pre></div><p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回</p><div class="code-wrapper"><pre><code class="hljs bash">iconst_1putstatic <span class="hljs-comment">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span>iconst_2putstatic <span class="hljs-comment">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><span class="hljs-built_in">return</span></code></pre></div><p>虚拟机必须保证一个类的<clinit>（）方法在多线程下被同步加锁。</clinit></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadThreadTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 线程t1开始&quot;</span>);            <span class="hljs-keyword">new</span> DeadThread();        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 线程t2开始&quot;</span>);            <span class="hljs-keyword">new</span> DeadThread();        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadThread</span> </span>&#123;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 初始化当前类&quot;</span>);            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>上面的代码，输出结果为</p><div class="code-wrapper"><pre><code class="hljs mipsasm">线程<span class="hljs-built_in">t1</span>开始线程<span class="hljs-built_in">t2</span>开始线程<span class="hljs-built_in">t2</span> 初始化当前类</code></pre></div><p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p><h2 id="5-类加载器的分类"><a href="#5-类加载器的分类" class="headerlink" title="5 类加载器的分类"></a>5 类加载器的分类</h2><p>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705094149223.png" alt="image-20200705094149223"></p><p>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。</p><p>我们通过一个类，获取它不同的加载器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 获取系统类加载器</span>        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);        <span class="hljs-comment">// 获取其上层的：扩展类加载器</span>        ClassLoader extClassLoader = systemClassLoader.getParent();        System.out.println(extClassLoader);        <span class="hljs-comment">// 试图获取 根加载器</span>        ClassLoader bootstrapClassLoader = extClassLoader.getParent();        System.out.println(bootstrapClassLoader);        <span class="hljs-comment">// 获取自定义加载器</span>        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();        System.out.println(classLoader);                <span class="hljs-comment">// 获取String类型的加载器</span>        ClassLoader classLoader1 = String.class.getClassLoader();        System.out.println(classLoader1);    &#125;&#125;</code></pre></div><p>得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">sun</span>.misc.Launcher$AppClassLoader@<span class="hljs-number">18</span>b<span class="hljs-number">4</span>aac<span class="hljs-number">2</span><span class="hljs-attribute">sun</span>.misc.Launcher$ExtClassLoader@<span class="hljs-number">1540</span>e<span class="hljs-number">19</span>d<span class="hljs-attribute">null</span><span class="hljs-attribute">sun</span>.misc.Launcher$AppClassLoader@<span class="hljs-number">18</span>b<span class="hljs-number">4</span>aac<span class="hljs-number">2</span><span class="hljs-attribute">null</span></code></pre></div><h3 id="5-1-虚拟机自带的加载器"><a href="#5-1-虚拟机自带的加载器" class="headerlink" title="5.1 虚拟机自带的加载器"></a>5.1 虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h3 id="5-2-扩展类加载器（Extension-ClassLoader）"><a href="#5-2-扩展类加载器（Extension-ClassLoader）" class="headerlink" title="5.2 扩展类加载器（Extension ClassLoader）"></a>5.2 扩展类加载器（Extension ClassLoader）</h3><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h3 id="5-3-应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#5-3-应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="5.3 应用程序类加载器（系统类加载器，AppClassLoader）"></a>5.3 应用程序类加载器（系统类加载器，AppClassLoader）</h3><ul><li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul><h3 id="5-4-用户自定义类加载器"><a href="#5-4-用户自定义类加载器" class="headerlink" title="5.4 用户自定义类加载器"></a>5.4 用户自定义类加载器</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。<br>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>用户自定义类加载器实现步骤：</p><ul><li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul><h3 id="5-5-查看根加载器所能加载的目录"><a href="#5-5-查看根加载器所能加载的目录" class="headerlink" title="5.5 查看根加载器所能加载的目录"></a>5.5 查看根加载器所能加载的目录</h3><p>刚刚我们通过概念了解到了，根加载器只能够加载 java /lib目录下的class，我们通过下面代码验证一下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderTest1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;*********启动类加载器************&quot;</span>);        <span class="hljs-comment">// 获取BootstrapClassLoader 能够加载的API的路径</span>        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();        <span class="hljs-keyword">for</span> (URL url : urls) &#123;            System.out.println(url.toExternalForm());        &#125;        <span class="hljs-comment">// 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器</span>        ClassLoader classLoader = Provider.class.getClassLoader();    &#125;&#125;</code></pre></div><p>得到的结果</p><div class="code-wrapper"><pre><code class="hljs gradle">*********启动类加载器************<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/resources.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/rt.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/sunrsasign.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jsse.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jce.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/charsets.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jfr.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>classes<span class="hljs-keyword">null</span></code></pre></div><h3 id="5-6-关于ClassLoader"><a href="#5-6-关于ClassLoader" class="headerlink" title="5.6 关于ClassLoader"></a>5.6 关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705103516138.png" alt="image-20200705103516138"></p><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705103636003.png" alt="image-20200705103636003"></p><p>获取ClassLoader的途径</p><ul><li>获取当前ClassLoader：clazz.getClassLoader()</li><li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li><li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li><li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li></ul><h2 id="6-双亲委派机制"><a href="#6-双亲委派机制" class="headerlink" title="6 双亲委派机制"></a>6 双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><h3 id="6-1-工作原理"><a href="#6-1-工作原理" class="headerlink" title="6.1 工作原理"></a>6.1 工作原理</h3><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705105151258.png" alt="image-20200705105151258"></p><h3 id="6-2-双亲委派机制举例"><a href="#6-2-双亲委派机制举例" class="headerlink" title="6.2 双亲委派机制举例"></a>6.2 双亲委派机制举例</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705105810107.png" alt="image-20200705105810107"></p><h3 id="6-3-沙箱安全机制"><a href="#6-3-沙箱安全机制" class="headerlink" title="6.3 沙箱安全机制"></a>6.3 沙箱安全机制</h3><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><h3 id="6-4-双亲委派机制的优势"><a href="#6-4-双亲委派机制的优势" class="headerlink" title="6.4 双亲委派机制的优势"></a>6.4 双亲委派机制的优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul><h2 id="7-其它"><a href="#7-其它" class="headerlink" title="7 其它"></a>7 其它</h2><h3 id="如何判断两个class对象是否相同"><a href="#如何判断两个class对象是否相同" class="headerlink" title="如何判断两个class对象是否相同"></a>如何判断两个class对象是否相同</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul><p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：王动使用和被动使用。<br>主动使用，又分为七种情况：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法I</li><li>反射（比如：Class.forName（”com.atguigu.Test”））</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：</li><li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p><h1 id="第3章-运行时数据区概述及线程"><a href="#第3章-运行时数据区概述及线程" class="headerlink" title="第3章  运行时数据区概述及线程"></a>第3章  运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705111640511.png" alt="image-20200705111640511"></p><p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705111843003.png" alt="image-20200705111843003"></p><p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705112036630.png" alt="image-20200705112036630"></p><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p><blockquote><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></blockquote><p>运行时数据区的完整图</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705112416101.png" alt="image-20200705112416101"></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p>!<img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705112601211.png" alt="image-20200705112601211"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p><h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|<br>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><h1 id="第4章-程序计数器"><a href="#第4章-程序计数器" class="headerlink" title="第4章 程序计数器"></a>第4章 程序计数器</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705155551919.png" alt="image-20200705155551919"></p><p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p><p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705155728557.png" alt="image-20200705155728557"></p><h2 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3 代码演示"></a>3 代码演示</h2><p>我们首先写一个简单的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCRegisterTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">20</span>;        <span class="hljs-keyword">int</span> k = i + j;    &#125;&#125;</code></pre></div><p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p><div class="code-wrapper"><pre><code class="hljs bash">0: bipush        102: istore_13: bipush        205: istore_26: iload_17: iload_28: iadd9: istore_310: <span class="hljs-built_in">return</span></code></pre></div><p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了 </p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705161007423.png" alt="image-20200705161007423"></p><h2 id="4-使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#4-使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="4 使用PC寄存器存储字节码指令地址有什么用呢？"></a>4 使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705161409533.png" alt="image-20200705161409533"></p><h2 id="5-PC寄存器为什么被设定为私有的？"><a href="#5-PC寄存器为什么被设定为私有的？" class="headerlink" title="5 PC寄存器为什么被设定为私有的？"></a>5 PC寄存器为什么被设定为私有的？</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705161812542.png" alt="image-20200705161812542"></p><h2 id="6-CPU时间片"><a href="#6-CPU时间片" class="headerlink" title="6 CPU时间片"></a>6 CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161849557.png" alt="image-20200705161849557"></p><h1 id="第5章-虚拟机栈"><a href="#第5章-虚拟机栈" class="headerlink" title="第5章 虚拟机栈"></a>第5章 虚拟机栈</h1><h2 id="1-虚拟机栈概述"><a href="#1-虚拟机栈概述" class="headerlink" title="1 虚拟机栈概述"></a>1 虚拟机栈概述</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。<br>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java战（stack）？为什么？</p><p>首先栈是运行时的单位，而堆是存储的单位</p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705163928652.png" alt="image-20200705163928652"></p><h3 id="1-1-Java虚拟机栈是什么"><a href="#1-1-Java虚拟机栈是什么" class="headerlink" title="1.1 Java虚拟机栈是什么"></a>1.1 Java虚拟机栈是什么</h3><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><blockquote><p>是线程私有的</p></blockquote><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705164722033.png" alt="image-20200705164722033"></p><h3 id="1-2-生命周期"><a href="#1-2-生命周期" class="headerlink" title="1.2 生命周期"></a>1.2 生命周期</h3><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p><h3 id="1-3-作用"><a href="#1-3-作用" class="headerlink" title="1.3 作用"></a>1.3 作用</h3><p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><blockquote><p>局部变量，它是相比于成员变量来说的（或属性）</p><p>基本数据类型变量 VS  引用类型变量（类、数组、接口）</p></blockquote><h3 id="1-4-栈的特点"><a href="#1-4-栈的特点" class="headerlink" title="1.4 栈的特点"></a>1.4 栈的特点</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705165025382.png" alt="image-20200705165025382"></p><h3 id="1-5-开发中遇到哪些异常？"><a href="#1-5-开发中遇到哪些异常？" class="headerlink" title="1.5 开发中遇到哪些异常？"></a>1.5 开发中遇到哪些异常？</h3><p>栈中可能出现的异常</p><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</p><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 outofMemoryError 异常。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackErrorTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(count++);        main(args);    &#125;&#125;</code></pre></div><p>当栈深度达到9872的时候，就出现栈内存空间不足</p><h3 id="1-6-设置栈内存大小"><a href="#1-6-设置栈内存大小" class="headerlink" title="1.6 设置栈内存大小"></a>1.6 设置栈内存大小</h3><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><div class="code-wrapper"><pre><code class="hljs shell">-Xss1m-Xss1k</code></pre></div><h2 id="2-栈的存储单位"><a href="#2-栈的存储单位" class="headerlink" title="2 栈的存储单位"></a>2 栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h3 id="2-1-栈中存储什么？"><a href="#2-1-栈中存储什么？" class="headerlink" title="2.1 栈中存储什么？"></a>2.1 栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。在这个线程上正在执行的每个方法都各自对应一个栈颜（Stack Frame）。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><blockquote><p>OOP的基本概念：类和对象</p><p>类中基本结构：field（属性、字段、域）、method</p></blockquote><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705203142545.png" alt="image-20200705203142545"></p><p>下面写一个简单的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackFrameTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        method01();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;方法1的开始&quot;</span>);        <span class="hljs-keyword">int</span> i = method02();        System.out.println(<span class="hljs-string">&quot;方法1的结束&quot;</span>);        <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method02</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;方法2的开始&quot;</span>);        <span class="hljs-keyword">int</span> i = method03();;        System.out.println(<span class="hljs-string">&quot;方法2的结束&quot;</span>);        <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method03</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;方法3的开始&quot;</span>);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>;        System.out.println(<span class="hljs-string">&quot;方法3的结束&quot;</span>);        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre></div><p>输出结果为</p><div class="code-wrapper"><pre><code class="hljs bash">方法1的开始方法2的开始方法3的开始方法3的结束方法2的结束方法1的结束</code></pre></div><p>满足栈先进后出的概念，通过Idea的 DEBUG，能够看到栈信息</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705203916023.png" alt="image-20200705203916023"></p><h3 id="2-2-栈运行原理"><a href="#2-2-栈运行原理" class="headerlink" title="2.2 栈运行原理"></a>2.2 栈运行原理</h3><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h3 id="2-3-栈帧的内部结构"><a href="#2-3-栈帧的内部结构" class="headerlink" title="2.3 栈帧的内部结构"></a>2.3 栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack）（或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705204836977.png" alt="image-20200705204836977"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705205443993.png" alt="image-20200705205443993"></p><h2 id="3-局部变量表"><a href="#3-局部变量表" class="headerlink" title="3 局部变量表"></a>3 局部变量表</h2><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p><p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p><h3 id="3-1-关于Slot的理解"><a href="#3-1-关于Slot的理解" class="headerlink" title="3.1 关于Slot的理解"></a>3.1 关于Slot的理解</h3><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p><p>局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p><p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。</p><blockquote><p>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。<br>1ong和double则占据两个slot。</p></blockquote><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）</p><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705212454445.png" alt="image-20200705212454445"></p><h3 id="3-2-Slot的重复利用"><a href="#3-2-Slot的重复利用" class="headerlink" title="3.2 Slot的重复利用"></a>3.2 Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200705213106749.png" alt="image-20200705213106749"></p><h3 id="3-3-静态变量与局部变量的对比"><a href="#3-3-静态变量与局部变量的对比" class="headerlink" title="3.3 静态变量与局部变量的对比"></a>3.3 静态变量与局部变量的对比</h3><p>变量的分类：</p><ul><li>按数据类型分：基本数据类型、引用数据类型</li><li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量<ul><li>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块</li><li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li><li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li></ul></li></ul><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h2 id="4-操作数栈"><a href="#4-操作数栈" class="headerlink" title="4 操作数栈"></a>4 操作数栈</h2><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>操作数栈：Operand Stack</p><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 <strong>操作数栈</strong>，也可以称之为 <strong>表达式栈</strong>（Expression Stack）</p><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706090618332.png" alt="image-20200706090618332"></p><p>代码举例</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706090833697.png" alt="image-20200706090833697"></p><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。.</p><blockquote><p>这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的</p></blockquote><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</p><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p><p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p><h3 id="4-2-代码追踪"><a href="#4-2-代码追踪" class="headerlink" title="4.2 代码追踪"></a>4.2 代码追踪</h3><p>我们给定代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAddOperation</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">byte</span> i = <span class="hljs-number">15</span>;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">8</span>;    <span class="hljs-keyword">int</span> k = i + j;&#125;</code></pre></div><p>使用javap 命令反编译class文件： javap -v 类名.class</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706092610730.png" alt="image-20200706092610730"></p><blockquote><p>byte、short、char、boolean 内部都是使用int型来进行保存的</p><p>从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和  8进行入栈操作</p><p>同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作</p></blockquote><p>执行流程如下所示：</p><p>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入栈。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706093131621.png" alt="image-20200706093131621"></p><p>执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706093251302.png" alt="image-20200706093251302"></p><blockquote><p>为什么局部变量表不是从0开始的呢？</p><p>其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了~</p></blockquote><p>然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706093646406.png" alt="image-20200706093646406"></p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706093751711.png" alt="image-20200706093751711"></p><p>然后从局部变量表中，依次将数据放在操作数栈中</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706093859191.png" alt="image-20200706093859191"></p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706093921573.png" alt="image-20200706093921573"></p><p>然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706094046782.png" alt="image-20200706094046782"></p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706094109629.png" alt="image-20200706094109629"></p><p>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</p><p>i++和++i的区别</p><h2 id="5-栈顶缓存技术"><a href="#5-栈顶缓存技术" class="headerlink" title="5 栈顶缓存技术"></a>5 栈顶缓存技术</h2><p>栈顶缓存技术：Top Of Stack Cashing</p><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p><blockquote><p>寄存器：指令更少，执行速度快</p></blockquote><h2 id="6-动态链接"><a href="#6-动态链接" class="headerlink" title="6 动态链接"></a>6 动态链接</h2><p>动态链接：Dynamic Linking</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706100311886.png" alt="image-20200706100311886"></p><blockquote><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p></blockquote><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</p><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706101251847.png" alt="image-20200706101251847"></p><blockquote><p>为什么需要运行时常量池？</p><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></blockquote><h2 id="7-方法调用：解析与分配"><a href="#7-方法调用：解析与分配" class="headerlink" title="7 方法调用：解析与分配"></a>7 方法调用：解析与分配</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h3 id="7-1-链接"><a href="#7-1-链接" class="headerlink" title="7.1 链接"></a>7.1 链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期被确定，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h3 id="7-2-绑定机制"><a href="#7-2-绑定机制" class="headerlink" title="7.2 绑定机制"></a>7.2 绑定机制</h3><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h4 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h4><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><h4 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h4><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><h3 id="早晚期绑定的发展历史"><a href="#早晚期绑定的发展历史" class="headerlink" title="早晚期绑定的发展历史"></a>早晚期绑定的发展历史</h3><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><h3 id="7-3-虚方法和非虚方法"><a href="#7-3-虚方法和非虚方法" class="headerlink" title="7.3 虚方法和非虚方法"></a>7.3 虚方法和非虚方法</h3><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><blockquote><p>子类对象的多态的使用前提</p><ul><li>类的继承关系</li><li>方法的重写</li></ul></blockquote><p>虚拟机中提供了以下几条方法调用指令：</p><h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本</init></li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul><h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</p><h3 id="7-4-invokedynamic指令"><a href="#7-4-invokedynamic指令" class="headerlink" title="7.4 invokedynamic指令"></a>7.4 invokedynamic指令</h3><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现动态类型语言】支持而做的一种改进。</p><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p><h3 id="7-5-动态类型语言和静态类型语言"><a href="#7-5-动态类型语言和静态类型语言" class="headerlink" title="7.5 动态类型语言和静态类型语言"></a>7.5 动态类型语言和静态类型语言</h3><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p><blockquote><p>Java：String info = “mogu blog”;     (Java是静态类型语言的，会先编译就进行类型检查)</p><p>JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查）</p></blockquote><h3 id="7-6-方法重写的本质"><a href="#7-6-方法重写的本质" class="headerlink" title="7.6 方法重写的本质"></a>7.6 方法重写的本质</h3><h4 id="Java-语言中方法重写的本质："><a href="#Java-语言中方法重写的本质：" class="headerlink" title="Java 语言中方法重写的本质："></a>Java 语言中方法重写的本质：</h4><ul><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.1ang.I1legalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。</li></ul><h4 id="IllegalAccessError介绍"><a href="#IllegalAccessError介绍" class="headerlink" title="IllegalAccessError介绍"></a>IllegalAccessError介绍</h4><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h3 id="7-7-方法的调用：虚方法表"><a href="#7-7-方法的调用：虚方法表" class="headerlink" title="7.7 方法的调用：虚方法表"></a>7.7 方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表<br>（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表是什么时候被创建的呢？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706144954070.png" alt="image-20200706144954070"></p><p>如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。</p><h2 id="8-方法返回地址"><a href="#8-方法返回地址" class="headerlink" title="8 方法返回地址"></a>8 方法返回地址</h2><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li><p>正常执行完成</p></li><li><p>出现未处理的异常，非正常退出</p></li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p><ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706154554604.png" alt="image-20200706154554604"></p><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p><h2 id="9-一些附加信息"><a href="#9-一些附加信息" class="headerlink" title="9 一些附加信息"></a>9 一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="10-栈的相关面试题"><a href="#10-栈的相关面试题" class="headerlink" title="10 栈的相关面试题"></a>10 栈的相关面试题</h2><ul><li>举例栈溢出的情况？（StackOverflowError）<ul><li>通过 -Xss设置栈的大小</li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出</li></ul></li><li>分配的栈内存越大越好么？<ul><li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li>垃圾回收是否涉及到虚拟机栈？<ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>具体问题具体分析</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 面试题</span><span class="hljs-comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span><span class="hljs-comment"> * 何为线程安全？</span><span class="hljs-comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span><span class="hljs-comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderTest</span> </span>&#123;    <span class="hljs-comment">// s1的声明方式是线程安全的</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 线程内部创建的，属于局部变量</span>        StringBuilder s1 = <span class="hljs-keyword">new</span> StringBuilder();        s1.append(<span class="hljs-string">&quot;a&quot;</span>);        s1.append(<span class="hljs-string">&quot;b&quot;</span>);    &#125;    <span class="hljs-comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title">method04</span><span class="hljs-params">()</span> </span>&#123;        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-keyword">return</span> stringBuilder;    &#125;    <span class="hljs-comment">// stringBuilder 是线程不安全的，操作的是共享数据</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method02</span><span class="hljs-params">(StringBuilder stringBuilder)</span> </span>&#123;        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 同时并发的执行，会出现线程不安全的问题</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method03</span><span class="hljs-params">()</span> </span>&#123;        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);            stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        method02(stringBuilder);    &#125;    <span class="hljs-comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">method05</span><span class="hljs-params">()</span> </span>&#123;        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-keyword">return</span> stringBuilder.toString();    &#125;&#125;</code></pre></div><p>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p><p>运行时数据区，是否存在Error和GC？</p><table><thead><tr><th>运行时数据区</th><th>是否存在Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>否</td></tr><tr><td>虚拟机栈</td><td>是</td><td>否</td></tr><tr><td>本地方法栈</td><td>是</td><td>否</td></tr><tr><td>方法区</td><td>是（OOM）</td><td>是</td></tr><tr><td>堆</td><td>是</td><td>是</td></tr></tbody></table><h1 id="第6章-本地方法接口"><a href="#第6章-本地方法接口" class="headerlink" title="第6章 本地方法接口"></a>第6章 本地方法接口</h1><h2 id="1-什么是本地方法"><a href="#1-什么是本地方法" class="headerlink" title="1 什么是本地方法"></a>1 什么是本地方法</h2><p>简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p><p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706164139252.png" alt="image-20200706164139252"></p><p>代码举例说明Native方法是如何编写的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IhaveNatives</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Native1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Native2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Native3</span><span class="hljs-params">(Object o)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Natives</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ary)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><blockquote><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p></blockquote><h2 id="2-为什么使用Native-Method？"><a href="#2-为什么使用Native-Method？" class="headerlink" title="2 为什么使用Native Method？"></a>2 为什么使用Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h3 id="2-1-与Java环境的交互"><a href="#2-1-与Java环境的交互" class="headerlink" title="2.1 与Java环境的交互"></a>2.1 与Java环境的交互</h3><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="2-2-与操作系统的交互"><a href="#2-2-与操作系统的交互" class="headerlink" title="2.2 与操作系统的交互"></a>2.2 与操作系统的交互</h3><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><h3 id="2-3-Sun’s-Java"><a href="#2-3-Sun’s-Java" class="headerlink" title="2.3 Sun’s Java"></a>2.3 Sun’s Java</h3><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p><h2 id="3-现状"><a href="#3-现状" class="headerlink" title="3 现状"></a>3 现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h1 id="第7章-本地方法栈"><a href="#第7章-本地方法栈" class="headerlink" title="第7章 本地方法栈"></a>第7章 本地方法栈</h1><p>Java虚拟机栈于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul><p>本地方法是使用C语言实现的。</p><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706174708418.png" alt="image-20200706174708418"></p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p><p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p><h1 id="第8章-堆"><a href="#第8章-堆" class="headerlink" title="第8章 堆"></a>第8章 堆</h1><h2 id="1-堆的核心概念"><a href="#1-堆的核心概念" class="headerlink" title="1 堆的核心概念"></a>1 堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706195127740.png" alt="image-20200706195127740"></p><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p><ul><li>堆内存的大小是可以调节的。</li></ul><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p><blockquote><p>-Xms10m：最小堆内存</p><p>-Xmx10m：最大堆内存</p></blockquote><p>下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706200739392.png" alt="image-20200706200739392"></p><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><p>我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p><ul><li>因为还有一些对象是在栈上分配的</li></ul><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706201904057.png" alt="image-20200706201904057"></p><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>Young Generation Space 新生区  Young/New   又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space永久区   Perm</li></ul><p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p><ul><li>Young Generation Space新生区  Young/New  又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区  Old/Tenure</li><li>Meta Space  元空间   Meta</li></ul><p>约定：新生区 -&gt; 新生代 -&gt; 年轻代   、  养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706203419496.png" alt="image-20200706203419496"></p><p>堆空间内部结构，JDK1.8之前从永久代  替换成 元空间</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706203835403.png" alt="image-20200706203835403"></p><h2 id="2-设置堆内存大小与OOM"><a href="#2-设置堆内存大小与OOM" class="headerlink" title="2 设置堆内存大小与OOM"></a>2 设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li><li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p><p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p><p>默认情况下</p><ul><li><p>初始内存大小：物理电脑内存大小/64</p></li><li><p>最大内存大小：物理电脑内存大小/4</p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span><span class="hljs-comment"> *  -X：是jvm运行参数</span><span class="hljs-comment"> *  ms：memory start</span><span class="hljs-comment"> * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSpaceInitial</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 返回Java虚拟机中的堆内存总量</span>        <span class="hljs-keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;        <span class="hljs-comment">// 返回Java虚拟机试图使用的最大堆内存</span>        <span class="hljs-keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;        System.out.println(<span class="hljs-string">&quot;-Xms:&quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);        System.out.println(<span class="hljs-string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);    &#125;&#125;</code></pre></div><p>输出结果</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms:245M</span><span class="hljs-deletion">-Xmx:3614M</span></code></pre></div><p>如何查看堆内存的内存分配情况</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps </span> -&gt;  <span class="hljs-keyword">jstat </span>-gc 进程id</code></pre></div><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706205756045.png" alt="image-20200706205756045"></p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+PrintGCDetails</span></code></pre></div><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706205821919.png" alt="image-20200706205821919"></p><h3 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h3><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706205947535.png" alt="image-20200706205947535"></p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706210000461.png" alt="image-20200706210000461"></p><p>我们简单的写一个OOM例子</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            list.add(<span class="hljs-number">999999999</span>);        &#125;    &#125;&#125;</code></pre></div><p>然后设置启动参数</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx:10m</span></code></pre></div><p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200706211652779.png" alt="image-20200706211652779"></p><h2 id="3-年轻代与老年代"><a href="#3-年轻代与老年代" class="headerlink" title="3 年轻代与老年代"></a>3 年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul><li>生命周期短的，及时回收即可</li></ul></li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707075847954.png" alt="image-20200707075847954"></p><p>下面这参数开发中一般不会调：</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707080154039.png" alt="image-20200707080154039"></p><ul><li>Eden：From：to -&gt;  8:1:1</li><li>新生代：老年代  - &gt;  1 : 2</li></ul><p>配置新生代与老年代在堆结构的占比。</p><ul><li><p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p></li><li><p>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p></li></ul><blockquote><p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p></blockquote><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p><p>可以使用选项”-Xmn”设置新生代最大内存大小</p><p>这个参数一般使用默认值就可以了。</p></blockquote><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707084208115.png" alt="image-20200707084208115"></p><h2 id="4-图解对象分配过程"><a href="#4-图解对象分配过程" class="headerlink" title="4 图解对象分配过程"></a>4 图解对象分配过程</h2><h3 id="4-1-概念-1"><a href="#4-1-概念-1" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ul><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><p>可以设置参数：-Xx:MaxTenuringThreshold= N进行设置</p><h3 id="4-2-图解过程"><a href="#4-2-图解过程" class="headerlink" title="4.2 图解过程"></a>4.2 图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707084714886.png" alt="image-20200707084714886"></p><p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707085232646.png" alt="image-20200707085232646"></p><p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象  晋升到 老年代中</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707085737207.png" alt="image-20200707085737207"></p><h3 id="4-3-思考：幸存区区满了后？"><a href="#4-3-思考：幸存区区满了后？" class="headerlink" title="4.3 思考：幸存区区满了后？"></a>4.3 思考：幸存区区满了后？</h3><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p><p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p><blockquote><p>举例：以当兵为例，正常人的晋升可能是 ：  新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p><p>但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -&gt; 排长</p></blockquote><h3 id="4-4-对象分配的特殊情况"><a href="#4-4-对象分配的特殊情况" class="headerlink" title="4.4 对象分配的特殊情况"></a>4.4 对象分配的特殊情况</h3><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707091058346.png" alt="image-20200707091058346"></p><h3 id="4-5-代码演示对象分配过程"><a href="#4-5-代码演示对象分配过程" class="headerlink" title="4.5 代码演示对象分配过程"></a>4.5 代码演示对象分配过程</h3><p>我们不断的创建大对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapInstanceTest</span> </span>&#123;    <span class="hljs-keyword">byte</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">200</span>)];    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        ArrayList&lt;HeapInstanceTest&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            list.add(<span class="hljs-keyword">new</span> HeapInstanceTest());            Thread.sleep(<span class="hljs-number">10</span>);        &#125;    &#125;&#125;</code></pre></div><p>然后设置JVM参数</p><div class="code-wrapper"><pre><code class="hljs bash">-Xms600m -Xmx600m</code></pre></div><p>然后cmd输入下面命令，打开VisualVM图形化界面</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">jvisualvm</span></code></pre></div><p>然后通过执行上面代码，通过VisualGC进行动态化查看</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.gif" alt="垃圾回收"></p><p>最终，在老年代和新生代都满了，就出现OOM</p><div class="code-wrapper"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.java.chapter08.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:<span class="hljs-number">13</span>)at com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:<span class="hljs-number">17</span>)</code></pre></div><h3 id="4-6-常用的调优工具"><a href="#4-6-常用的调优工具" class="headerlink" title="4.6 常用的调优工具"></a>4.6 常用的调优工具</h3><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控  推荐~）</li><li>Jprofiler（推荐~）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ul><h3 id="4-7-总结"><a href="#4-7-总结" class="headerlink" title="4.7 总结"></a>4.7 总结</h3><ul><li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li><li>新生代采用复制算法的目的：是为了减少内碎片</li></ul><h2 id="5-Minor-GC，MajorGC、Full-GC"><a href="#5-Minor-GC，MajorGC、Full-GC" class="headerlink" title="5 Minor GC，MajorGC、Full GC"></a>5 Minor GC，MajorGC、Full GC</h2><ul><li>Minor GC：新生代的GC</li><li>Major GC：老年代的GC</li><li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li></ul><blockquote><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p><p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p></blockquote><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li><li>老年代收集（MajorGC/OldGC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和FullGC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p><h3 id="5-1-Minor-GC"><a href="#5-1-Minor-GC" class="headerlink" title="5.1 Minor GC"></a>5.1 Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><blockquote><p>STW：stop the word</p></blockquote><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707095606813.png" alt="image-20200707095606813"></p><h3 id="5-2-Major-GC"><a href="#5-2-Major-GC" class="headerlink" title="5.2 Major GC"></a>5.2 Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p><p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li></ul><p>Major GC的速度一般会比MinorGc慢10倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p><h3 id="5-3-Full-GC"><a href="#5-3-Full-GC" class="headerlink" title="5.3 Full GC"></a>5.3 Full GC</h3><p>触发FullGC执行的情况有如下五种：</p><ul><li>调用System.gc（）时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p><h3 id="5-4-GC-举例"><a href="#5-4-GC-举例" class="headerlink" title="5.4 GC 举例"></a>5.4 GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            String a = <span class="hljs-string">&quot;mogu blog&quot;</span>;            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;                list.add(a);                a = a + a;                i++;            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;            e.getStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>设置JVM启动参数</p><div class="code-wrapper"><pre><code class="hljs bash">-Xms10m -Xmx10m -XX:+PrintGCDetails</code></pre></div><p>打印出的日志</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2038</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">500</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">2038</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">797</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.3532002</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.36</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2108</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">480</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">2405</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">1565</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0014069</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2288</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">6845</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">9133</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058675</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0002857</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5263</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5263</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058564</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Heap</span> <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">60</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">2048</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd0f138</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">5263</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">73</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffb23cf0</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3514</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4498</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span>  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">388</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">390</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span>    <span class="hljs-variable">Exception</span> <span class="hljs-variable">in</span> <span class="hljs-variable">thread</span> <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">OutOfMemoryError</span><span class="hljs-operator">:</span> <span class="hljs-variable">Java</span> <span class="hljs-variable">heap</span> <span class="hljs-variable">space</span><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">util</span><span class="hljs-operator">.</span><span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">copyOfRange</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">3664</span><span class="hljs-punctuation">)</span><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-built_in">String</span><span class="hljs-operator">.&lt;</span><span class="hljs-variable">init</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">String</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">207</span><span class="hljs-punctuation">)</span><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">StringBuilder</span><span class="hljs-operator">.</span><span class="hljs-variable">toString</span><span class="hljs-punctuation">(</span><span class="hljs-variable">StringBuilder</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">407</span><span class="hljs-punctuation">)</span><span class="hljs-variable">at</span> <span class="hljs-variable">com</span><span class="hljs-operator">.</span><span class="hljs-variable">atguigu</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">chapter08</span><span class="hljs-operator">.</span><span class="hljs-variable">GCTest</span><span class="hljs-operator">.</span><span class="hljs-variable">main</span><span class="hljs-punctuation">(</span><span class="hljs-variable">GCTest</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">20</span><span class="hljs-punctuation">)</span></code></pre></div><p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p><h2 id="6-堆空间分代思想"><a href="#6-堆空间分代思想" class="headerlink" title="6 堆空间分代思想"></a>6 堆空间分代思想</h2><p> 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><blockquote><p>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p></blockquote><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707101511025.png" alt="image-20200707101511025"></p><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707101543871.png" alt="image-20200707101543871"></p><h2 id="7-内存分配策略"><a href="#7-内存分配策略" class="headerlink" title="7 内存分配策略"></a>7 内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden<ul><li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li></ul></li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li></ul></li></ul><p>空间分配担保： -Xx:HandlePromotionFailure</p><ul><li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li></ul><h2 id="8-为对象分配内存：TLAB"><a href="#8-为对象分配内存：TLAB" class="headerlink" title="8 为对象分配内存：TLAB"></a>8 为对象分配内存：TLAB</h2><h3 id="8-1-问题：堆空间都是共享的么？"><a href="#8-1-问题：堆空间都是共享的么？" class="headerlink" title="8.1 问题：堆空间都是共享的么？"></a>8.1 问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p><h3 id="8-2-为什么有TLAB？"><a href="#8-2-为什么有TLAB？" class="headerlink" title="8.2 为什么有TLAB？"></a>8.2 为什么有TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><h3 id="8-3-什么是TLAB"><a href="#8-3-什么是TLAB" class="headerlink" title="8.3 什么是TLAB"></a>8.3 什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707103547712.png" alt="image-20200707103547712"></p><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><h3 id="8-4-TLAB分配过程"><a href="#8-4-TLAB分配过程" class="headerlink" title="8.4 TLAB分配过程"></a>8.4 TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707104253530.png" alt="image-20200707104253530"></p><h2 id="9-小结：堆空间的参数设置"><a href="#9-小结：堆空间的参数设置" class="headerlink" title="9 小结：堆空间的参数设置"></a>9 小结：堆空间的参数设置</h2><ul><li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p></li><li><p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p></li><li><p>-Xms：初始堆空间内存（默认为物理内存的1/64）</p></li><li><p>-Xmx：最大堆空间内存（默认为物理内存的1/4）</p></li><li><p>-Xmn：设置新生代的大小。（初始值及最大值）</p></li><li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p></li><li><p>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</p></li><li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p></li><li><p>-XX：+PrintGCDetails：输出详细的GC处理日志</p><ul><li>打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc</li></ul></li><li><p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p></li></ul><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul><li>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则改为进行一次FullGC。</li><li>如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。</li></ul></li></ul><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p><h2 id="10-堆是分配对象的唯一选择么？"><a href="#10-堆是分配对象的唯一选择么？" class="headerlink" title="10 堆是分配对象的唯一选择么？"></a>10 堆是分配对象的唯一选择么？</h2><h3 id="10-1-逃逸分析"><a href="#10-1-逃逸分析" class="headerlink" title="10.1 逃逸分析"></a>10.1 逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><h4 id="1-逃逸分析举例"><a href="#1-逃逸分析举例" class="headerlink" title="1 逃逸分析举例"></a>1 逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">my_method</span><span class="hljs-params">()</span> </span>&#123;    V v = <span class="hljs-keyword">new</span> V();    <span class="hljs-comment">// use v</span>    <span class="hljs-comment">// ....</span>    v = <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>针对下面的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();    sb.append(s1);    sb.append(s2);    <span class="hljs-keyword">return</span> sb;&#125;</code></pre></div><p>如果想要StringBuffer sb不发生逃逸，可以这样写</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();    sb.append(s1);    sb.append(s2);    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre></div><p>完整的逃逸分析代码举例</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 逃逸分析</span><span class="hljs-comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EscapeAnalysis</span> </span>&#123;    <span class="hljs-keyword">public</span> EscapeAnalysis obj;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> EscapeAnalysis <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> obj == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> EscapeAnalysis():obj;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 为成员属性赋值，发生逃逸</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setObj</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.obj = <span class="hljs-keyword">new</span> EscapeAnalysis();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useEscapeAnalysis</span><span class="hljs-params">()</span> </span>&#123;        EscapeAnalysis e = <span class="hljs-keyword">new</span> EscapeAnalysis();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 引用成员变量的值，发生逃逸</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useEscapeAnalysis2</span><span class="hljs-params">()</span> </span>&#123;        EscapeAnalysis e = getInstance();        <span class="hljs-comment">// getInstance().XXX  发生逃逸</span>    &#125;&#125;</code></pre></div><h4 id="2-参数设置"><a href="#2-参数设置" class="headerlink" title="2 参数设置"></a>2 参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li><li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul><h4 id="3-结论"><a href="#3-结论" class="headerlink" title="3 结论"></a>3 结论</h4><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h3 id="10-2-栈上分配"><a href="#10-2-栈上分配" class="headerlink" title="10.2 栈上分配"></a>10.2 栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>常见的栈上分配的场景</p><blockquote><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p></blockquote><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 栈上分配</span><span class="hljs-comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String age;    <span class="hljs-keyword">private</span> String gender;    <span class="hljs-keyword">private</span> String phone;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackAllocation</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;            alloc();        &#125;        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);        <span class="hljs-comment">// 为了方便查看堆内存中对象个数，线程sleep</span>        Thread.sleep(<span class="hljs-number">10000000</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 未发生逃逸</span>        User user = <span class="hljs-keyword">new</span> User();     &#125;&#125;</code></pre></div><p>设置JVM参数，表示未开启逃逸分析</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></code></pre></div><p>运行结果，同时还触发了GC操作</p><div class="code-wrapper"><pre><code class="hljs plain">花费的时间为：664 ms</code></pre></div><p>然后查看内存的情况，发现有大量的User存储在堆中</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707203038615.png" alt="image-20200707203038615"></p><p>我们在开启逃逸分析</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span></code></pre></div><p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p><div class="code-wrapper"><pre><code class="hljs plain">花费的时间为：5 ms</code></pre></div><p>在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707203441718.png" alt="image-20200707203441718"></p><h3 id="10-3-同步省略"><a href="#10-3-同步省略" class="headerlink" title="10.3 同步省略"></a>10.3 同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p><p>例如下面的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;    Object hellis = <span class="hljs-keyword">new</span> Object();    <span class="hljs-keyword">synchronized</span>(hellis) &#123;        System.out.println(hellis);    &#125;&#125;</code></pre></div><p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;    Object hellis = <span class="hljs-keyword">new</span> Object();System.out.println(hellis);&#125;</code></pre></div><p>我们将其转换成字节码</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200707205634266.png" alt="image-20200707205634266"></p><h3 id="10-4-分离对象和标量替换"><a href="#10-4-分离对象和标量替换" class="headerlink" title="10.4 分离对象和标量替换"></a>10.4 分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;    alloc();&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;    Point point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);    System.out.println(<span class="hljs-string">&quot;point.x&quot;</span> + point.x + <span class="hljs-string">&quot;;point.y&quot;</span> + point.y);&#125;</code></pre></div><p>以上代码，经过标量替换后，就会变成</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>;    System.out.println(<span class="hljs-string">&quot;point.x = &quot;</span> + x + <span class="hljs-string">&quot;; point.y=&quot;</span> + y);&#125;</code></pre></div><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p><h3 id="10-5-代码优化之标量替换"><a href="#10-5-代码优化之标量替换" class="headerlink" title="10.5 代码优化之标量替换"></a>10.5 代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><div class="code-wrapper"><pre><code class="hljs bash">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></pre></div><p>这里设置参数如下：</p><ul><li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li><li>参数-Xmx10m：指定了堆空间最大为10MB</li><li>参数-XX:+PrintGC：将打印Gc日志</li><li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h3 id="10-6-逃逸分析的不足"><a href="#10-6-逃逸分析的不足" class="headerlink" title="10.6 逃逸分析的不足"></a>10.6 逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。<br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p><h2 id="11-小结"><a href="#11-小结" class="headerlink" title="11 小结"></a>11 小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p><p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p><h1 id="第9章-方法区"><a href="#第9章-方法区" class="headerlink" title="第9章 方法区"></a>第9章 方法区</h1><h2 id="9-1-前言"><a href="#9-1-前言" class="headerlink" title="9.1 前言"></a>9.1 前言</h2><p>这次所讲述的是运行时数据区的最后一个部分</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708093918121.png" alt="image-20200708093918121"></p><p>从线程共享与否的角度来看</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708093918121-1628001815741190.png" alt="image-20200708093918121"></p><p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p><h2 id="9-2-栈、堆、方法区的交互关系"><a href="#9-2-栈、堆、方法区的交互关系" class="headerlink" title="9.2 栈、堆、方法区的交互关系"></a>9.2 栈、堆、方法区的交互关系</h2><p>下面就涉及了对象的访问定位</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708094747667.png" alt="image-20200708094747667"></p><ul><li>Person：存放在元空间，也可以说方法区</li><li>person：存放在Java栈的局部变量表中</li><li>new Person()：存放在Java堆中</li></ul><h2 id="9-3-方法区的理解"><a href="#9-3-方法区的理解" class="headerlink" title="9.3 方法区的理解"></a>9.3 方法区的理解</h2><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，方法区看作是一块独立于Java堆的内存空间。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708095853544.png" alt="image-20200708095853544"></p><p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><ul><li>JDK 1.8后，元空间存放在堆外内存中</li></ul><p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。            </p><blockquote><p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）</p></blockquote><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708102919149.png" alt="image-20200708102919149"></p><p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708103055914.png" alt="image-20200708103055914"></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p><h2 id="9-4-设置方法区大小与OOM"><a href="#9-4-设置方法区大小与OOM" class="headerlink" title="9.4 设置方法区大小与OOM"></a>9.4 设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 </p><h3 id="1-jdk7及以前"><a href="#1-jdk7及以前" class="headerlink" title="1 jdk7及以前"></a>1 jdk7及以前</h3><ul><li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708111756800.png" alt="image-20200708111756800"></p><h3 id="2-JDK8以后"><a href="#2-JDK8以后" class="headerlink" title="2 JDK8以后"></a>2 JDK8以后</h3><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p><p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，FullGC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到FullGC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p><h3 id="3-如何解决这些OOM"><a href="#3-如何解决这些OOM" class="headerlink" title="3 如何解决这些OOM"></a>3 如何解决这些OOM</h3><ul><li><p>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</p><ul><li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li></ul></li><li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p></li><li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p></li></ul><h2 id="9-5-方法区的内部结构"><a href="#9-5-方法区的内部结构" class="headerlink" title="9.5  方法区的内部结构"></a>9.5  方法区的内部结构</h2><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708161728320.png" alt="image-20200708161728320"></p><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708161856504.png" alt="image-20200708161856504"></p><h3 id="1-类型信息"><a href="#1-类型信息" class="headerlink" title="1 类型信息"></a>1 类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h3 id="2-域信息"><a href="#2-域信息" class="headerlink" title="2 域信息"></a>2 域信息</h3><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p><h3 id="3-方法（Method）信息"><a href="#3-方法（Method）信息" class="headerlink" title="3 方法（Method）信息"></a>3 方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><blockquote><p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p></blockquote><h3 id="4-non-final的类变量"><a href="#4-non-final的类变量" class="headerlink" title="4 non-final的类变量"></a>4 non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * non-final的类变量</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Order order = <span class="hljs-keyword">new</span> Order();        order.hello();        System.out.println(order.count);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">2</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);    &#125;&#125;</code></pre></div><p>如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p><h3 id="5-全局常量"><a href="#5-全局常量" class="headerlink" title="5 全局常量"></a>5 全局常量</h3><p>全局常量就是使用 static final 进行修饰</p><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 </p><h3 id="6-运行时常量池-VS-常量池"><a href="#6-运行时常量池-VS-常量池" class="headerlink" title="6 运行时常量池 VS 常量池"></a>6 运行时常量池 VS 常量池</h3><p>运行时常量池，就是运行时常量池</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708171151384.png" alt="image-20200708171151384"></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li></ul><h3 id="7-常量池"><a href="#7-常量池" class="headerlink" title="7 常量池"></a>7 常量池</h3><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708172357052.png" alt="image-20200708172357052"></p><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p><h4 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。</p><p>比如：如下的代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleClass</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;</code></pre></div><p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p><h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h4><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p>例如下面这段代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaTest2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;        Object obj = <span class="hljs-keyword">new</span> Object();    &#125;&#125;</code></pre></div><p>将会被翻译成如下字节码</p><div class="code-wrapper"><pre><code class="hljs bash">new <span class="hljs-comment">#2  </span>dupinvokespecial</code></pre></div><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><h3 id="8-运行时常量池"><a href="#8-运行时常量池" class="headerlink" title="8 运行时常量池"></a>8 运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p><p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</p><p>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</p><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p><h2 id="9-6-方法区使用举例"><a href="#9-6-方法区使用举例" class="headerlink" title="9.6 方法区使用举例"></a>9.6 方法区使用举例</h2><p>如下代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;        <span class="hljs-keyword">int</span> x = <span class="hljs-number">500</span>;        <span class="hljs-keyword">int</span> y = <span class="hljs-number">100</span>;        <span class="hljs-keyword">int</span> a = x / y;        <span class="hljs-keyword">int</span> b = <span class="hljs-number">50</span>;        System.out.println(a+b);    &#125;&#125;</code></pre></div><p>字节码执行过程展示</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708204750374.png" alt="image-20200708204750374"></p><p>首先现将操作数500放入到操作数栈中</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708204953552.png" alt="image-20200708204953552"></p><p>然后存储到局部变量表中</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708205029376.png" alt="image-20200708205029376"></p><p>然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205221737.png" alt="image-20200708205221737"></p><p>将500 和 100 进行一个除法运算，在把结果入栈</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708205413721.png" alt="image-20200708205413721"></p><p>在最后就是输出流，需要调用运行时常量池的常量</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708205708057.png" alt="image-20200708205708057"></p><p>最后调用invokevirtual（虚方法调用），然后返回</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708205909176.png" alt="image-20200708205909176"></p><p>返回时</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708210540696.png" alt="image-20200708210540696"></p><p>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p><h2 id="9-7-方法区的演进细节"><a href="#9-7-方法区的演进细节" class="headerlink" title="9.7 方法区的演进细节"></a>9.7 方法区的演进细节</h2><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p><p>Hotspot中方法区的变化：</p><table><thead><tr><th>JDK1.6及以前</th><th>有永久代，静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p>JDK6的时候</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708211541300.png" alt="image-20200708211541300"></p><p>JDK7的时候</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708211609911.png" alt="image-20200708211609911"></p><p>JDK8的时候，元空间大小只受物理内存影响</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708211637952.png" alt="image-20200708211637952"></p><h3 id="1-为什么永久代要被元空间替代？"><a href="#1-为什么永久代要被元空间替代？" class="headerlink" title="1 为什么永久代要被元空间替代？"></a>1 为什么永久代要被元空间替代？</h3><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p><ul><li>为永久代设置空间大小是很难确定的。</li></ul><p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工<br>程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。<br>因此，默认情况下，元空间的大小仅受本地内存限制。</p><ul><li>对永久代进行调优是很困难的。<ul><li>主要是为了降低Full GC</li></ul></li></ul><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。<br>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p><h3 id="2-StringTable为什么要调整位置"><a href="#2-StringTable为什么要调整位置" class="headerlink" title="2 StringTable为什么要调整位置"></a>2 StringTable为什么要调整位置</h3><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而ful1gc是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h3 id="3-静态变量存放在那里？"><a href="#3-静态变量存放在那里？" class="headerlink" title="3 静态变量存放在那里？"></a>3 静态变量存放在那里？</h3><p>静态引用对应的对象实体始终都存在堆空间</p><p>可以使用 jhsdb.ext，需要在jdk9的时候才引入的</p><p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708215025527.png" alt="image-20200708215025527"></p><p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。</p><p>接着，找到了一个引用该staticobj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708215218078.png" alt="image-20200708215218078"></p><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点</p><h2 id="9-8-方法区的垃圾回收"><a href="#9-8-方法区的垃圾回收" class="headerlink" title="9.8 方法区的垃圾回收"></a>9.8 方法区的垃圾回收</h2><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h2 id="9-9-总结"><a href="#9-9-总结" class="headerlink" title="9.9 总结"></a>9.9 总结</h2><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200708220303243.png" alt="image-20200708220303243"></p><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p>百度<br>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p><p>蚂蚁金服：<br>Java8的内存分代改进<br>JVM内存分哪几个区，每个区的作用是什么？<br>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？<br>二面：Eden和survior的比例分配</p><p>小米：<br>jvm内存分区，为什么要有新生代和老年代</p><p>字节跳动：<br>二面：Java的内存分区<br>二面：讲讲vm运行时数据库区<br>什么时候对象会进入老年代？</p><p>京东：<br>JVM的内存结构，Eden和Survivor比例。<br>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p><p>天猫：<br>一面：Jvm内存模型以及分区，需要详细到每个区放什么。<br>一面：JVM的内存模型，Java8做了什么改</p><p>拼多多：<br>JVM内存分哪几个区，每个区的作用是什么？</p><p>美团：<br>java内存分配<br>jvm的永久代中会发生垃圾回收吗？<br>一面：jvm内存分区，为什么要有新生代和老年代？</p><h1 id="第10章-对象实例化内存布局与访问定位"><a href="#第10章-对象实例化内存布局与访问定位" class="headerlink" title="第10章 对象实例化内存布局与访问定位"></a>第10章 对象实例化内存布局与访问定位</h1><h2 id="1-对象实例化"><a href="#1-对象实例化" class="headerlink" title="1 对象实例化"></a>1 对象实例化</h2><h3 id="1-1-面试题"><a href="#1-1-面试题" class="headerlink" title="1.1 面试题"></a>1.1 面试题</h3><ul><li>对象在JVM中是怎么存储的？</li><li>对象头信息里面有哪些东西？</li><li>Java对象头有什么？</li></ul><p>从对象创建的方式 和 步骤开始说</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200709095356247.png" alt="image-20200709095356247"></p><h3 id="1-2-对象创建方式"><a href="#1-2-对象创建方式" class="headerlink" title="1.2 对象创建方式"></a>1.2 对象创建方式</h3><ul><li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li><li>使用序列化：序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ul><h3 id="1-3-创建对象的步骤"><a href="#1-3-创建对象的步骤" class="headerlink" title="1.3 创建对象的步骤"></a>1.3 创建对象的步骤</h3><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p><h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li><p>如果内存规整：指针碰撞</p></li><li><p>如果内存不规整</p><ul><li>虚拟表需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul><li>在Eden区给每个线程分配一块区域</li></ul></li></ul><h3 id="1-4-初始化分配到的内存"><a href="#1-4-初始化分配到的内存" class="headerlink" title="1.4 初始化分配到的内存"></a>1.4 初始化分配到的内存</h3><p>给对象属性赋值的操作</p><ul><li><p>属性的默认初始化</p></li><li><p>显示初始化</p></li><li><p>代码块中的初始化</p></li><li><p>构造器初始化</p></li><li><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p></li></ul><h3 id="1-5-设置对象的对象头"><a href="#1-5-设置对象的对象头" class="headerlink" title="1.5 设置对象的对象头"></a>1.5 设置对象的对象头</h3><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h3 id="1-6-执行init方法进行初始化"><a href="#1-6-执行init方法进行初始化" class="headerlink" title="1.6 执行init方法进行初始化"></a>1.6 执行init方法进行初始化</h3><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><h3 id="1-7-对象实例化的过程"><a href="#1-7-对象实例化的过程" class="headerlink" title="1.7 对象实例化的过程"></a>1.7 对象实例化的过程</h3><ul><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ul><h2 id="1-8-对象内存布局"><a href="#1-8-对象内存布局" class="headerlink" title="1.8 对象内存布局"></a>1.8 对象内存布局</h2><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200709151033237.png" alt="image-20200709151033237"></p><h3 id="1-9-对象头"><a href="#1-9-对象头" class="headerlink" title="1.9 对象头"></a>1.9 对象头</h3><p>对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针</p><blockquote><p>如果是数组，还需要记录数组的长度</p></blockquote><h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>翩向时间戳</li></ul><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</p><h3 id="1-10-实例数据（Instance-Data）"><a href="#1-10-实例数据（Instance-Data）" class="headerlink" title="1.10 实例数据（Instance Data）"></a>1.10 实例数据（Instance Data）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><h3 id="1-11-小结"><a href="#1-11-小结" class="headerlink" title="1.11 小结"></a>1.11 小结</h3><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200709152801713.png" alt="image-20200709152801713"></p><h2 id="2-对象的访问定位"><a href="#2-对象的访问定位" class="headerlink" title="2 对象的访问定位"></a>2 对象的访问定位</h2><h3 id="2-1-图示"><a href="#2-1-图示" class="headerlink" title="2.1 图示"></a>2.1 图示</h3><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709164149920.png" alt="image-20200709164149920"></p><h3 id="2-2-对象访问的两种方式"><a href="#2-2-对象访问的两种方式" class="headerlink" title="2.2 对象访问的两种方式"></a>2.2 对象访问的两种方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200709164342002.png" alt="image-20200709164342002"></p><p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p><h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200709164350466.png" alt="image-20200709164350466"></p><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p><h1 id="第11章-直接内存-Direct-Memory"><a href="#第11章-直接内存-Direct-Memory" class="headerlink" title="第11章 直接内存 Direct Memory"></a>第11章 直接内存 Direct Memory</h1><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p><p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul><p>使用下列代码，直接分配本地内存空间</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> BUFFER = <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; <span class="hljs-comment">// 1GB</span>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</code></pre></div><h2 id="非直接缓存区和缓存区"><a href="#非直接缓存区和缓存区" class="headerlink" title="非直接缓存区和缓存区"></a>非直接缓存区和缓存区</h2><p>原来采用BIO的架构，我们需要从用户态切换成内核态</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200709170907611.png" alt="image-20200709170907611"></p><p>NIO的方式使用了缓存区的概念</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>也可能导致outofMemoryError异常</p><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。<br>缺点</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul><p>直接内存大小可以通过MaxDirectMemorySize设置</p><p>如果不指定，默认与堆的最大值-xmx参数值一致</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200709230647277.png" alt="image-20200709230647277"></p><h1 id="第12章执行引擎"><a href="#第12章执行引擎" class="headerlink" title="第12章执行引擎"></a>第12章执行引擎</h1><h2 id="1-执行引擎概述"><a href="#1-执行引擎概述" class="headerlink" title="1 执行引擎概述"></a>1 执行引擎概述</h2><p>执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710080707873.png" alt="image-20200710080707873"></p><p>执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p><p>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710081118053.png" alt="image-20200710081118053"></p><p>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p><h3 id="执行引擎的工作流程"><a href="#执行引擎的工作流程" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h3><ul><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710081627217.png" alt="image-20200710081627217"></p><p>从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p><h2 id="2-Java代码编译和执行过程"><a href="#2-Java代码编译和执行过程" class="headerlink" title="2 Java代码编译和执行过程"></a>2 Java代码编译和执行过程</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p><ul><li>前面橙色部分是生成字节码文件的过程，和JVM无关</li><li>后面蓝色和绿色才是JVM需要考虑的过程</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710082141643.png" alt="image-20200710082141643"></p><p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710082433146.png" alt="image-20200710082433146"></p><p>Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710083036258.png" alt="image-20200710083036258"></p><p>我们用一个总的图，来说说 解释器和编译器</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710083656277.png" alt="image-20200710083656277"></p><h3 id="2-1-什么是解释器（Interpreter）"><a href="#2-1-什么是解释器（Interpreter）" class="headerlink" title="2.1 什么是解释器（Interpreter）"></a>2.1 什么是解释器（Interpreter）</h3><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><h3 id="2-2-什么是IT编译器"><a href="#2-2-什么是IT编译器" class="headerlink" title="2.2 什么是IT编译器"></a>2.2 什么是IT编译器</h3><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><h3 id="2-3-为什么Java是半编译半解释型语言"><a href="#2-3-为什么Java是半编译半解释型语言" class="headerlink" title="2.3 为什么Java是半编译半解释型语言"></a>2.3 为什么Java是半编译半解释型语言</h3><p>JDK1.x时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p>翻译成本地代码后，就可以做一个缓存操作，存储在方法区中</p><h2 id="3-机器码、指令、汇编语言"><a href="#3-机器码、指令、汇编语言" class="headerlink" title="3 机器码、指令、汇编语言"></a>3 机器码、指令、汇编语言</h2><h3 id="3-1-机器码"><a href="#3-1-机器码" class="headerlink" title="3.1 机器码"></a>3.1 机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p><p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p><p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p><p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p><h3 id="3-2-指令"><a href="#3-2-指令" class="headerlink" title="3.2 指令"></a>3.2 指令</h3><p>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p><p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p><h3 id="3-3-指令集"><a href="#3-3-指令集" class="headerlink" title="3.3 指令集"></a>3.3 指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。<br>如常见的</p><ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul><h3 id="3-4-汇编语言"><a href="#3-4-汇编语言" class="headerlink" title="3.4 汇编语言"></a>3.4 汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p><p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbo1）或标号（Labe1）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><blockquote><p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</p></blockquote><h3 id="3-5-高级语言"><a href="#3-5-高级语言" class="headerlink" title="3.5 高级语言"></a>3.5 高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。</p><p>高级语言比机器语言、汇编语言更接近人的语言当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710085323733.png" alt="image-20200710085323733"></p><p>高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++</p><h3 id="3-6-C、C-源程序执行过程"><a href="#3-6-C、C-源程序执行过程" class="headerlink" title="3.6 C、C++源程序执行过程"></a>3.6 C、C++源程序执行过程</h3><p>编译过程又可以分成两个阶段：编译和汇编。</p><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710085553258.png" alt="image-20200710085553258"></p><h3 id="3-7-字节码"><a href="#3-7-字节码" class="headerlink" title="3.7 字节码"></a>3.7 字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p><ul><li>字节码典型的应用为：Java bytecode</li></ul><h2 id="4-解释器"><a href="#4-解释器" class="headerlink" title="4 解释器"></a>4 解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710090203674.png" alt="image-20200710090203674"></p><p>为什么Java源文件不直接翻译成JMV，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的</p><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p><h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><p>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</p><p>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p><p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p><ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</p><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p><h2 id="5-JIT编译器"><a href="#5-JIT编译器" class="headerlink" title="5 JIT编译器"></a>5 JIT编译器</h2><h3 id="5-1-Java代码的执行分类"><a href="#5-1-Java代码的执行分类" class="headerlink" title="5.1 Java代码的执行分类"></a>5.1 Java代码的执行分类</h3><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p><p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</p><h3 id="5-2-问题来了"><a href="#5-2-问题来了" class="headerlink" title="5.2 问题来了"></a>5.2 问题来了</h3><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p><ul><li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li></ul><p>首先明确：<br>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。<br>编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p>所以：<br>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</p><p>在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h3 id="5-3-HotSpot-JVM执行方式"><a href="#5-3-HotSpot-JVM执行方式" class="headerlink" title="5.3 HotSpot JVM执行方式"></a>5.3 HotSpot JVM执行方式</h3><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p><h3 id="5-4-案例"><a href="#5-4-案例" class="headerlink" title="5.4 案例"></a>5.4 案例</h3><p>注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710095417462.png" alt="image-20200710095417462"></p><h3 id="5-5-概念解释"><a href="#5-5-概念解释" class="headerlink" title="5.5 概念解释"></a>5.5 概念解释</h3><ul><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）</li><li>把字节码转变成机器码的过程。</li><li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。</li></ul><p>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p><p>JIT编译器：HotSpot VM的C1、C2编译器。</p><p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p><h3 id="5-6-热点探测技术"><a href="#5-6-热点探测技术" class="headerlink" title="5.6 热点探测技术"></a>5.6 热点探测技术</h3><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。</p><p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p><p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</p><p>采用基于计数器的热点探测，HotSpot V将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p><ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul><h3 id="5-7-方法调用计数器"><a href="#5-7-方法调用计数器" class="headerlink" title="5.7 方法调用计数器"></a>5.7 方法调用计数器</h3><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p><p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710101829934.png" alt="image-20200710101829934"></p><h3 id="5-8-热点衰减"><a href="#5-8-热点衰减" class="headerlink" title="5.8 热点衰减"></a>5.8 热点衰减</h3><p> 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）</p><ul><li>半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄</li></ul><p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<br>-XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p><p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p><h3 id="5-9-回边计数器"><a href="#5-9-回边计数器" class="headerlink" title="5.9 回边计数器"></a>5.9 回边计数器</h3><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710103103869.png" alt="image-20200710103103869"></p><h3 id="5-10-HotSpotVM-可以设置程序执行方法"><a href="#5-10-HotSpotVM-可以设置程序执行方法" class="headerlink" title="5.10 HotSpotVM 可以设置程序执行方法"></a>5.10 HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>-Xint：完全采用解释器模式执行程序；</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200710103340273.png" alt="image-20200710103340273"></p><h3 id="5-11-HotSpotVM中-JIT-分类"><a href="#5-11-HotSpotVM中-JIT-分类" class="headerlink" title="5.11 HotSpotVM中 JIT 分类"></a>5.11 HotSpotVM中 JIT 分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><p>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；</p><ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。</li></ul></li><li><p>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。</p><ul><li>C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用C++）</li></ul></li></ul><h3 id="5-12-C1-和-C2编译器不同的优化策略"><a href="#5-12-C1-和-C2编译器不同的优化策略" class="headerlink" title="5.12 C1 和 C2编译器不同的优化策略"></a>5.12 C1 和 C2编译器不同的优化策略</h3><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现樊进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul><h3 id="5-13-分层编译策略"><a href="#5-13-分层编译策略" class="headerlink" title="5.13 分层编译策略"></a>5.13 分层编译策略</h3><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p><p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p><h3 id="5-14-总结"><a href="#5-14-总结" class="headerlink" title="5.14 总结"></a>5.14 总结</h3><ul><li>一般来讲，JIT编译出来的机器码性能比解释器搞</li><li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li></ul><h3 id="5-15-AOT编译器"><a href="#5-15-AOT编译器" class="headerlink" title="5.15 AOT编译器"></a>5.15 AOT编译器</h3><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p><p>Java 9引入了实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p><div class="code-wrapper"><pre><code class="hljs livescript">.java -&gt; .<span class="hljs-keyword">class</span> -&gt; <span class="hljs-function"><span class="hljs-params">(使用jaotc)</span> -&gt;</span> .so</code></pre></div><p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</p><p>缺点：</p><ul><li>破坏了 java  “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ul><h3 id="5-16-写到最后"><a href="#5-16-写到最后" class="headerlink" title="5.16 写到最后"></a>5.16 写到最后</h3><ul><li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器</li><li>编译效果短短几年时间就追评了G2编译器，未来可期</li><li>目前，带着实验状态标签，需要使用开关参数去激活才能使用</li></ul><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</span></code></pre></div><h1 id="第13章-StringTable"><a href="#第13章-StringTable" class="headerlink" title="第13章 StringTable"></a>第13章 StringTable</h1><h2 id="1-String的基本特性"><a href="#1-String的基本特性" class="headerlink" title="1 String的基本特性"></a>1 String的基本特性</h2><ul><li>String：字符串，使用一对 ”” 引起来表示<ul><li>String s1 = “mogublog” ;   // 字面量的定义方式</li><li>String s2 =  new String(“moxi”); </li></ul></li><li>string声明为final的，不可被继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小</li><li>string在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</li></ul><h3 id="1-1-为什么JDK9改变了结构"><a href="#1-1-为什么JDK9改变了结构" class="headerlink" title="1.1 为什么JDK9改变了结构"></a>1.1 为什么JDK9改变了结构</h3><p>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且，大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用。</p><p>我们建议改变字符串的内部表示class从utf - 16字符数组到字节数组+一个encoding-flag字段。新的String类将根据字符串的内容存储编码为ISO-8859-1/Latin-1(每个字符一个字节)或UTF-16(每个字符两个字节)的字符。编码标志将指示使用哪种编码。</p><p>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 之前</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<span class="hljs-comment">// 之后</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] value</code></pre></div><p>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</p><h3 id="1-2-String的不可变性"><a href="#1-2-String的不可变性" class="headerlink" title="1.2 String的不可变性"></a>1.2 String的不可变性</h3><p>String：代表不可变的字符序列。简称：不可变性。</p><blockquote><p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p></blockquote><p>代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * String的不可变性</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTest1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span>        String s1 = <span class="hljs-string">&quot;abc&quot;</span>;        String s2 = <span class="hljs-string">&quot;abc&quot;</span>;        System.out.println(s1 == s2);        s1 = <span class="hljs-string">&quot;hello&quot;</span>;        System.out.println(s1 == s2);        System.out.println(s1);        System.out.println(s2);        System.out.println(<span class="hljs-string">&quot;----------------&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;        String s1 = <span class="hljs-string">&quot;abc&quot;</span>;        String s2 = <span class="hljs-string">&quot;abc&quot;</span>;        <span class="hljs-comment">// 只要进行了修改，就会重新创建一个对象，这就是不可变性</span>        s2 += <span class="hljs-string">&quot;def&quot;</span>;        System.out.println(s1);        System.out.println(s2);        System.out.println(<span class="hljs-string">&quot;----------------&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;        String s1 = <span class="hljs-string">&quot;abc&quot;</span>;        String s2 = s1.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>);        System.out.println(s1);        System.out.println(s2);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        test1();        test2();        test3();    &#125;&#125;</code></pre></div><p>运行结果</p><div class="code-wrapper"><pre><code class="hljs asciidoc">truefalsehelloabc----------------abcabcdef----------------abcmbc</code></pre></div><h3 id="1-3-面试题"><a href="#1-3-面试题" class="headerlink" title="1.3 面试题"></a>1.3 面试题</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 面试题</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringExer</span> </span>&#123;    String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;good&quot;</span>);    <span class="hljs-keyword">char</span> [] ch = &#123;<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(String str, <span class="hljs-keyword">char</span> ch [])</span> </span>&#123;        str = <span class="hljs-string">&quot;test ok&quot;</span>;        ch[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        StringExer ex = <span class="hljs-keyword">new</span> StringExer();        ex.change(ex.str, ex.ch);        System.out.println(ex.str);        System.out.println(ex.ch);    &#125;&#125;</code></pre></div><p>输出结果</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">good</span><span class="hljs-attribute">best</span></code></pre></div><h3 id="1-4-注意"><a href="#1-4-注意" class="headerlink" title="1.4 注意"></a>1.4 注意</h3><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p><p>String的string Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进string Pool的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。</p><p>使用-XX:StringTablesize可设置stringTab1e的长度</p><p>在jdk6中stringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。stringTablesize设置没有要求</p><p>在jdk7中，stringTable的长度默认值是60013，</p><p>在JDK8中，StringTable可以设置的最小值为1009</p><h2 id="2-String的内存分配"><a href="#2-String的内存分配" class="headerlink" title="2 String的内存分配"></a>2 String的内存分配</h2><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p><p>直接使用双引号声明出来的String对象会直接存储在常量池中。</p><ul><li>比如：String info=”atguigu.com”；</li></ul><p>如果不是用双引号声明的String对象，可以使用String提供的intern（）方法。</p><p>Java 6及以前，字符串常量池存放在永久代</p><p>Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p><blockquote><p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p><p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用string.intern（）。</p></blockquote><p>Java8元空间，字符串常量在堆</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200711093546398.png" alt="image-20200711093546398"></p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200711093558709.png" alt="image-20200711093558709"></p><h3 id="2-1-为什么StringTable从永久代调整到堆中"><a href="#2-1-为什么StringTable从永久代调整到堆中" class="headerlink" title="2.1 为什么StringTable从永久代调整到堆中"></a>2.1 为什么StringTable从永久代调整到堆中</h3><p>在JDK 7中，interned字符串不再在Java堆的永久生成中分配，而是在Java堆的主要部分(称为年轻代和年老代)中分配，与应用程序创建的其他对象一起分配。此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。由于这一变化，大多数应用程序在堆使用方面只会看到相对较小的差异，但加载许多类或大量使用字符串的较大应用程序会出现这种差异。intern()方法会看到更显著的差异。</p><ul><li>永久代的默认比较小</li><li>永久代垃圾回收频率低</li></ul><h2 id="3-String的基本操作"><a href="#3-String的基本操作" class="headerlink" title="3 String的基本操作"></a>3 String的基本操作</h2><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p><h2 id="4-字符串拼接操作"><a href="#4-字符串拼接操作" class="headerlink" title="4 字符串拼接操作"></a>4 字符串拼接操作</h2><ul><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul><div class="code-wrapper"><pre><code class="hljs java">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;       String s1 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>;  <span class="hljs-comment">// 得到 abc的常量池</span>       String s2 = <span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">// abc存放在常量池，直接将常量池的地址返回</span>       <span class="hljs-comment">/**</span><span class="hljs-comment">        * 最终java编译成.class，再执行.class</span><span class="hljs-comment">        */</span>       System.out.println(s1 == s2); <span class="hljs-comment">// true，因为存放在字符串常量池</span>       System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span>   &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;       String s1 = <span class="hljs-string">&quot;javaEE&quot;</span>;       String s2 = <span class="hljs-string">&quot;hadoop&quot;</span>;       String s3 = <span class="hljs-string">&quot;javaEEhadoop&quot;</span>;       String s4 = <span class="hljs-string">&quot;javaEE&quot;</span> + <span class="hljs-string">&quot;hadoop&quot;</span>;           String s5 = s1 + <span class="hljs-string">&quot;hadoop&quot;</span>;       String s6 = <span class="hljs-string">&quot;javaEE&quot;</span> + s2;       String s7 = s1 + s2;       System.out.println(s3 == s4); <span class="hljs-comment">// true</span>       System.out.println(s3 == s5); <span class="hljs-comment">// false</span>       System.out.println(s3 == s6); <span class="hljs-comment">// false</span>       System.out.println(s3 == s7); <span class="hljs-comment">// false</span>       System.out.println(s5 == s6); <span class="hljs-comment">// false</span>       System.out.println(s5 == s7); <span class="hljs-comment">// false</span>       System.out.println(s6 == s7); <span class="hljs-comment">// false</span>       String s8 = s6.intern();       System.out.println(s3 == s8); <span class="hljs-comment">// true</span>   &#125;</code></pre></div><p>从上述的结果我们可以知道：</p><p>如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果</p><p>而调用intern方法，则会判断字符串常量池中是否存在JavaEEhadoop值，如果存在则返回常量池中的值，否者就在常量池中创建</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>拼接操作的底层其实使用了StringBuilder</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200711102231129.png" alt="image-20200711102231129"></p><p>s1 + s2的执行细节</p><ul><li>StringBuilder s = new StringBuilder();</li><li>s.append(s1);</li><li>s.append(s2);</li><li>s.toString();  -&gt; 类似于new String(“ab”);</li></ul><p>在JDK5之后，使用的是StringBuilder，在JDK5之前使用的是StringBuffer</p><table><thead><tr><th>String</th><th>StringBuffer</th><th>StringBuilder</th></tr></thead><tbody><tr><td>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td><td>StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td><td>可变类，速度更快</td></tr><tr><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td></td><td>线程安全</td><td>线程不安全</td></tr><tr><td></td><td>多线程操作字符串</td><td>单线程操作字符串</td></tr></tbody></table><p>注意，我们左右两边如果是变量的话，就是需要new StringBuilder进行拼接，但是如果使用的是final修饰，则是从常量池中获取。所以说拼接符号左右两边都是字符串常量或常量引用 则仍然使用编译器优化。也就是说被final修饰的变量，将会变成常量，类和方法将不能被继承、</p><ul><li>在开发中，能够使用final的时候，建议使用上</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> String s1 = <span class="hljs-string">&quot;a&quot;</span>;    <span class="hljs-keyword">final</span> String s2 = <span class="hljs-string">&quot;b&quot;</span>;    String s3 = <span class="hljs-string">&quot;ab&quot;</span>;    String s4 = s1 + s2;    System.out.println(s3 == s4);&#125;</code></pre></div><p>运行结果</p><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span></code></pre></div><h3 id="拼接操作和append性能对比"><a href="#拼接操作和append性能对比" class="headerlink" title="拼接操作和append性能对比"></a>拼接操作和append性能对比</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> highLevel)</span> </span>&#123;    String src = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; highLevel; i++) &#123;        src += <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 每次循环都会创建一个StringBuilder对象</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> highLevel)</span> </span>&#123;    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; highLevel; i++) &#123;        sb.append(<span class="hljs-string">&quot;a&quot;</span>);    &#125;&#125;</code></pre></div><p>方法1耗费的时间：4005ms，方法2消耗时间：7ms</p><p>结论：</p><ul><li>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</li></ul><p>好处</p><ul><li>StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象</li><li>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</li><li>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间</li></ul><p>改进的空间</p><ul><li>我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li><li>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</li></ul><h2 id="5-intern-的使用"><a href="#5-intern-的使用" class="headerlink" title="5 intern()的使用"></a>5 intern()的使用</h2><p>intern是一个native方法，调用的是底层C的方法</p><p>字符串池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串对象相等的字符串，则返回池中的字符串。否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。</p><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p><p>比如：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> myInfo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;I love atguigu&quot;</span>).<span class="hljs-built_in">intern</span>();</code></pre></div><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p><div class="code-wrapper"><pre><code class="hljs java">（<span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>+<span class="hljs-string">&quot;c&quot;</span>）.intern（）==<span class="hljs-string">&quot;abc&quot;</span></code></pre></div><p>通俗点讲，Interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p><h3 id="intern的空间效率测试"><a href="#intern的空间效率测试" class="headerlink" title="intern的空间效率测试"></a>intern的空间效率测试</h3><p>我们通过测试一下，使用了intern和不使用的时候，其实相差还挺多的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 使用Intern() 测试执行效率</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringIntern2</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_COUNT = <span class="hljs-number">1000</span> * <span class="hljs-number">10000</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] arr = <span class="hljs-keyword">new</span> String[MAX_COUNT];    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Integer [] data = <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_COUNT; i++) &#123;            arr[i] = <span class="hljs-keyword">new</span> String(String.valueOf(data[i%data.length])).intern();        &#125;        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start));        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000000</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.getStackTrace();        &#125;    &#125;&#125;</code></pre></div><p><strong>结论</strong>：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省内存空间。</p><p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</p><h2 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6 面试题"></a>6 面试题</h2><h3 id="6-1-new-String-“ab”-会创建几个对象"><a href="#6-1-new-String-“ab”-会创建几个对象" class="headerlink" title="6.1 new String(“ab”)会创建几个对象"></a>6.1 new String(“ab”)会创建几个对象</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * new String(&quot;ab&quot;) 会创建几个对象？ 看字节码就知道是2个对象</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringNewTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ab&quot;</span>);    &#125;&#125;</code></pre></div><p>我们转换成字节码来查看</p><div class="code-wrapper"><pre><code class="hljs tap"><span class="hljs-number"> 0 </span>new <span class="hljs-comment">#2 &lt;java/lang/String&gt;</span><span class="hljs-number"> 3 </span>dup<span class="hljs-number"> 4 </span>ldc <span class="hljs-comment">#3 &lt;ab&gt;</span><span class="hljs-number"> 6 </span>invokespecial <span class="hljs-comment">#4 &lt;java/lang/String.&lt;init&gt;&gt;</span><span class="hljs-number"> 9 </span>astore_110 return</code></pre></div><p>这里面就是两个对象</p><ul><li>一个对象是：new关键字在堆空间中创建</li><li>另一个对象：字符串常量池中的对象</li></ul><h3 id="6-2-new-String-“a”-new-String-“b”-会创建几个对象"><a href="#6-2-new-String-“a”-new-String-“b”-会创建几个对象" class="headerlink" title="6.2 new String(“a”) + new String(“b”) 会创建几个对象"></a>6.2 new String(“a”) + new String(“b”) 会创建几个对象</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * new String(&quot;ab&quot;) 会创建几个对象？ 看字节码就知道是2个对象</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringNewTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);    &#125;&#125;</code></pre></div><p>字节码文件为</p><div class="code-wrapper"><pre><code class="hljs gradle"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder&gt; <span class="hljs-number">3</span> dup <span class="hljs-number">4</span> invokespecial #<span class="hljs-number">3</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.&lt;init&gt;&gt; <span class="hljs-number">7</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/lang/</span>String&gt;<span class="hljs-number">10</span> dup<span class="hljs-number">11</span> ldc #<span class="hljs-number">5</span> &lt;a&gt;<span class="hljs-number">13</span> invokespecial #<span class="hljs-number">6</span> &lt;java<span class="hljs-regexp">/lang/</span>String.&lt;init&gt;&gt;<span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.<span class="hljs-keyword">append</span>&gt;<span class="hljs-number">19</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java<span class="hljs-regexp">/lang/</span>String&gt;<span class="hljs-number">22</span> dup<span class="hljs-number">23</span> ldc #<span class="hljs-number">8</span> &lt;b&gt;<span class="hljs-number">25</span> invokespecial #<span class="hljs-number">6</span> &lt;java<span class="hljs-regexp">/lang/</span>String.&lt;init&gt;&gt;<span class="hljs-number">28</span> invokevirtual #<span class="hljs-number">7</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.<span class="hljs-keyword">append</span>&gt;<span class="hljs-number">31</span> invokevirtual #<span class="hljs-number">9</span> &lt;java<span class="hljs-regexp">/lang/</span>StringBuilder.toString&gt;<span class="hljs-number">34</span> astore_1<span class="hljs-number">35</span> <span class="hljs-keyword">return</span></code></pre></div><p>我们创建了6个对象</p><ul><li>对象1：new StringBuilder()</li><li>对象2：new String(“a”)</li><li>对象3：常量池的 a</li><li>对象4：new String(“b”)</li><li>对象5：常量池的 b</li><li>对象6：toString中会创建一个 new String(“ab”)<ul><li>调用toString方法，不会在常量池中生成ab</li></ul></li></ul><h3 id="6-3-intern的使用：JDK6和JDK7"><a href="#6-3-intern的使用：JDK6和JDK7" class="headerlink" title="6.3 intern的使用：JDK6和JDK7"></a>6.3 intern的使用：JDK6和JDK7</h3><h4 id="JDK6中"><a href="#JDK6中" class="headerlink" title="JDK6中"></a>JDK6中</h4><div class="code-wrapper"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);  <span class="hljs-comment">// 在常量池中已经有了</span>s.intern(); <span class="hljs-comment">// 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1</span>String s2 = <span class="hljs-string">&quot;1&quot;</span>;System.out.println(s == s2); <span class="hljs-comment">// false</span>String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);s3.intern();String s4 = <span class="hljs-string">&quot;11&quot;</span>;System.out.println(s3 == s4); <span class="hljs-comment">// true</span></code></pre></div><p>输出结果</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">false</span><span class="hljs-keyword">true</span></code></pre></div><p>为什么对象会不一样呢？</p><ul><li>一个是new创建的对象，一个是常量池中的对象，显然不是同一个</li></ul><p>如果是下面这样的，那么就是true</p><div class="code-wrapper"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);s = s.intern();String s2 = <span class="hljs-string">&quot;1&quot;</span>;System.out.println(s == s2); <span class="hljs-comment">// true</span></code></pre></div><p>而对于下面的来说，因为 s3变量记录的地址是  new String(“11”)，然后这段代码执行完以后，常量池中不存在 “11”，这是JDK6的关系，然后执行 s3.intern()后，就会在常量池中生成 “11”，最后 s4用的就是s3的地址</p><blockquote><p>为什么最后输出的 s3 == s4  会为false呢？</p><p>这是因为在JDK6中创建了一个新的对象 “11”，也就是有了新的地址， s2 = 新地址</p><p>而在JDK7中，在JDK7中，并没有创新一个新对象，而是指向常量池中的新对象</p></blockquote><h4 id="JDK7中"><a href="#JDK7中" class="headerlink" title="JDK7中"></a>JDK7中</h4><div class="code-wrapper"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);s.intern();String s2 = <span class="hljs-string">&quot;1&quot;</span>;System.out.println(s == s2); <span class="hljs-comment">// true</span>String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);s3.intern();String s4 = <span class="hljs-string">&quot;11&quot;</span>;System.out.println(s3 == s4); <span class="hljs-comment">// true</span></code></pre></div><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200711145925091.png" alt="image-20200711145925091"></p><h3 id="6-4-扩展"><a href="#6-4-扩展" class="headerlink" title="6.4 扩展"></a>6.4 扩展</h3><div class="code-wrapper"><pre><code class="hljs java">String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;1&quot;</span>);String s4 = <span class="hljs-string">&quot;11&quot;</span>;  <span class="hljs-comment">// 在常量池中生成的字符串</span>s3.intern();  <span class="hljs-comment">// 然后s3就会从常量池中找，发现有了，就什么事情都不做</span>System.out.println(s3 == s4);</code></pre></div><p>我们将 s4的位置向上移动一行，发现变化就会很大，最后得到的是 false</p><h3 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h3><p>总结string的intern（）的使用：</p><p>JDK1.6中，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，会把此<strong>对象复制一份</strong>，放入串池，并返回串池中的对象地址</li></ul><p>JDK1.7起，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，则会把<strong>对象的引用地址</strong>复制一份，放入串池，并返回串池中的引用地址</li></ul><p>练习：</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200711150859709.png" alt="image-20200711150859709"></p><ul><li>在JDK6中，在字符串常量池中创建一个字符串 “ab”</li><li>在JDK8中，在字符串常量池中没有创建 “ab”，而是将堆中的地址复制到 串池中。</li></ul><p>所以上述结果，在JDK6中是：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">true</span><span class="hljs-keyword">false</span></code></pre></div><p>在JDK8中是</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">false</span><span class="hljs-keyword">true</span></code></pre></div><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200711151326909.png" alt="image-20200711151326909"></p><p>针对下面这题，在JDK6和8中表现的是一样的</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200711151433277.png" alt="image-20200711151433277"></p><h2 id="7-StringTable的垃圾回收"><a href="#7-StringTable的垃圾回收" class="headerlink" title="7 StringTable的垃圾回收"></a>7 StringTable的垃圾回收</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * String的垃圾回收</span><span class="hljs-comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringGCTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;            String.valueOf(i).intern();        &#125;    &#125;&#125;</code></pre></div><h2 id="8-G1中的String去重操作"><a href="#8-G1中的String去重操作" class="headerlink" title="8 G1中的String去重操作"></a>8 G1中的String去重操作</h2><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p><h3 id="8-1-描述"><a href="#8-1-描述" class="headerlink" title="8.1 描述"></a>8.1 描述</h3><p>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：</p><ul><li><p>堆存活数据集合里面string对象占了25%</p></li><li><p>堆存活数据集合里面重复的string对象有13.5%</p></li><li><p>string对象的平均长度是45</p></li></ul><p>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说：<br>stringl.equals（string2）= true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。</p><h3 id="8-2-实现"><a href="#8-2-实现" class="headerlink" title="8.2 实现"></a>8.2 实现</h3><ul><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的string对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。</li><li>使用一个hashtab1e来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，string对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li></ul><h3 id="8-3-开启"><a href="#8-3-开启" class="headerlink" title="8.3 开启"></a>8.3 开启</h3><p>命令行选项</p><blockquote><p>UsestringDeduplication（bool）：开启string去重，默认是不开启的，需要手动开启。<br>Printstringbeduplicationstatistics（bool）：打印详细的去重统计信息<br>stringpeduplicationAgeThreshold（uintx）：达到这个年龄的string对象被认为是去重的候选对象</p></blockquote><h1 id="第14章-垃圾回收概述"><a href="#第14章-垃圾回收概述" class="headerlink" title="第14章 垃圾回收概述"></a>第14章 垃圾回收概述</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>这次我们主要关注的是黄色部分，内存的分配与回收</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712084539884.png" alt="image-20200712084539884"></p><h2 id="2-什么是垃圾"><a href="#2-什么是垃圾" class="headerlink" title="2 什么是垃圾"></a>2 什么是垃圾</h2><p>在提到什么是垃圾之前，我们先看下面一张图</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/images/image-20200712085456113.png" alt="image-20200712085456113"></p><p>从上图我们可以很明确的知道，Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C语言没有垃圾收集技术，需要我们手动的收集。</p><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。<br>关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><h3 id="2-1-什么是垃圾？"><a href="#2-1-什么是垃圾？" class="headerlink" title="2.1 什么是垃圾？"></a>2.1 什么是垃圾？</h3><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p><h3 id="2-2-磁盘碎片整理"><a href="#2-2-磁盘碎片整理" class="headerlink" title="2.2 磁盘碎片整理"></a>2.2 磁盘碎片整理</h3><p>机械硬盘需要进行磁盘整理，同时还有坏道</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712090848669.png" alt="image-20200712090848669"></p><h3 id="2-3-大厂面试题"><a href="#2-3-大厂面试题" class="headerlink" title="2.3 大厂面试题"></a>2.3 大厂面试题</h3><h4 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h4><ul><li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1？</li><li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li><li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li><li>GC的两种判定方法？CMS收集器与G1收集器的特点</li></ul><h4 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h4><ul><li>说一下GC算法，分代回收说下</li><li>垃圾收集策略和算法</li></ul><h4 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h4><ul><li>JVM GC原理，JVM怎么回收内存</li><li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li></ul><h4 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h4><p>Java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的</p><h4 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h4><ul><li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，</li><li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li></ul><h4 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h4><ul><li>讲一讲垃圾回收算法。</li><li>什么情况下触发垃圾回收？</li><li>如何选择合适的垃圾收集算法？</li><li>JVM有哪三种垃圾回收器？</li></ul><h4 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h4><ul><li>常见的垃圾回收器算法有哪些，各有什么优劣？</li><li>System.gc（）和Runtime.gc（）会做什么事情？</li><li>Java GC机制？GC Roots有哪些？</li><li>Java对象的回收方式，回收算法。</li><li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li><li>CMS回收停顿了几次，为什么要停顿两次?</li></ul><h2 id="3-为什么需要GC"><a href="#3-为什么需要GC" class="headerlink" title="3 为什么需要GC"></a>3 为什么需要GC</h2><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。</p><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p><h2 id="4-早期垃圾回收"><a href="#4-早期垃圾回收" class="headerlink" title="4 早期垃圾回收"></a>4 早期垃圾回收</h2><p>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p><div class="code-wrapper"><pre><code class="hljs c++">MibBridge *pBridge= <span class="hljs-keyword">new</span> cmBaseGroupBridge（）；<span class="hljs-comment">//如果注册失败，使用Delete释放该对象所占内存区域</span><span class="hljs-keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）<span class="hljs-keyword">delete</span> pBridge；</code></pre></div><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。 </p><p>有了垃圾回收机制后，上述代码极有可能变成这样</p><div class="code-wrapper"><pre><code class="hljs c++">MibBridge *pBridge=<span class="hljs-keyword">new</span> <span class="hljs-built_in">cmBaseGroupBridge</span>(); pBridge-&gt;<span class="hljs-built_in">Register</span>(kDestroy);</code></pre></div><p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。</p><h2 id="5-Java垃圾回收机制"><a href="#5-Java垃圾回收机制" class="headerlink" title="5 Java垃圾回收机制"></a>5 Java垃圾回收机制</h2><h3 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h3><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p><p>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</p><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p><p>oracle官网关于垃圾回收的介绍<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p><h3 id="5-2-担忧"><a href="#5-2-担忧" class="headerlink" title="5.2 担忧"></a>5.2 担忧</h3><p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p><p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</p><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p><h3 id="5-3-GC主要关注的区域"><a href="#5-3-GC主要关注的区域" class="headerlink" title="5.3 GC主要关注的区域"></a>5.3 GC主要关注的区域</h3><p>GC主要关注于 方法区 和堆中的垃圾收集</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712092427246.png" alt="image-20200712092427246"></p><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收</p><ul><li>其中，Java堆是垃圾收集器的工作重点</li></ul><p>从次数上讲：</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul><h1 id="第15章-垃圾回收相关算法"><a href="#第15章-垃圾回收相关算法" class="headerlink" title="第15章 垃圾回收相关算法"></a>第15章 垃圾回收相关算法</h1><h2 id="1-标记阶段：引用计数算法"><a href="#1-标记阶段：引用计数算法" class="headerlink" title="1 标记阶段：引用计数算法"></a>1 标记阶段：引用计数算法</h2><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p><p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法。</strong></p><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p><p>缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</p><blockquote><p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。<br>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</p></blockquote><h3 id="1-1-循环引用"><a href="#1-1-循环引用" class="headerlink" title="1.1 循环引用"></a>1.1 循环引用</h3><p>当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712102205795.png" alt="image-20200712102205795"></p><h3 id="1-2-举例"><a href="#1-2-举例" class="headerlink" title="1.2 举例"></a>1.2 举例</h3><p>我们使用一个案例来测试Java中是否采用的是引用计数算法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 引用计数算法测试</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefCountGC</span> </span>&#123;    <span class="hljs-comment">// 这个成员属性的唯一作用就是占用一点内存</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] bigSize = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];    <span class="hljs-comment">// 引用</span>    Object reference = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        RefCountGC obj1 = <span class="hljs-keyword">new</span> RefCountGC();        RefCountGC obj2 = <span class="hljs-keyword">new</span> RefCountGC();        obj1.reference = obj2;        obj2.reference = obj1;        obj1 = <span class="hljs-keyword">null</span>;        obj2 = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span>        System.gc();    &#125;&#125;</code></pre></div><p>运行结果</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">15490</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">15490</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0061980</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.36</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">8</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">672</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">672</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3479</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3479</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0045983</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Heap</span> <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">655</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000770a00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000007c0000000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">65536</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">1</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076b5a3ee8</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">10752</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076f500000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">10752</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x000000076ff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000770a00000</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">672</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1e00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000006cc900000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x000000076b500000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1e00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006c1ea8070</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000006cc900000</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3486</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4496</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span>  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">385</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">388</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span></code></pre></div><p>我们能够看到，上述进行了GC收集的行为，将上述的新生代中的两个对象都进行回收了</p><div class="code-wrapper"><pre><code class="hljs shell">PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)</code></pre></div><p>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712103230349.png" alt="image-20200712103230349"></p><h3 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h3><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。Python如何解决循环引用？</p><blockquote><p>手动解除：很好理解，就是在合适的时机，解除引用关系。<br>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</p></blockquote><h2 id="2-标记阶段：可达性分析算法"><a href="#2-标记阶段：可达性分析算法" class="headerlink" title="2 标记阶段：可达性分析算法"></a>2 标记阶段：可达性分析算法</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>可达性分析算法：也可以称为 根搜索算法、追踪性垃圾收集</p><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p><p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p><h3 id="2-2-思路"><a href="#2-2-思路" class="headerlink" title="2.2 思路"></a>2.2 思路</h3><p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p><p>基本思路：</p><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712104149246.png" alt="image-20200712104149246"></p><p>官场上的裙带关系，可达性分析在人类关系网中</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712104312406.png" alt="image-20200712104312406"></p><h3 id="2-3-GC-Roots可以是哪些？"><a href="#2-3-GC-Roots可以是哪些？" class="headerlink" title="2.3 GC Roots可以是哪些？"></a>2.3 GC Roots可以是哪些？</h3><ul><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象<ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（string Table）里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712104622677.png" alt="image-20200712104622677"></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。</p><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致GC进行时必须“stop The World”的一个重要原因。</p><p>即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p><h2 id="3-对象的finalization机制"><a href="#3-对象的finalization机制" class="headerlink" title="3 对象的finalization机制"></a>3 对象的finalization机制</h2><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p><p>finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><h3 id="3-1-注意"><a href="#3-1-注意" class="headerlink" title="3.1 注意"></a>3.1 注意</h3><p>永远不要主动调用某个对象的finalize（）方法I应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li>在finalize（）时可能会导致对象复活。</li><li>finalize（）方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。<ul><li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ul></li><li>一个糟糕的finalize（）会严重影响Gc的性能。</li></ul><p>从功能上来说，finalize（）方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于C++中的析构函数。</p><p>由于finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态。</p><h3 id="3-2-生存还是死亡？"><a href="#3-2-生存还是死亡？" class="headerlink" title="3.2 生存还是死亡？"></a>3.2 生存还是死亡？</h3><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</li><li>不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong>。</li></ul><p>以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h3 id="3-3-具体过程"><a href="#3-3-具体过程" class="headerlink" title="3.3 具体过程"></a>3.3 具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ul><li><p>如果对象objA到GC Roots没有引用链，则进行第一次标记。</p></li><li><p>进行筛选，判断此对象是否有必要执行finalize（）方法</p><ul><li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li><li>finalize（）方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</li></ul></li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712110411885.png" alt="image-20200712110411885"></p><p>上图就是我们看到的Finalizer线程</p><h3 id="3-4-代码演示"><a href="#3-4-代码演示" class="headerlink" title="3.4 代码演示"></a>3.4 代码演示</h3><p>我们使用重写 finalize()方法，然后在方法的内部，重写将其存放到GC Roots中</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 测试Object类中finalize()方法</span><span class="hljs-comment"> * 对象复活场景</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CanReliveObj</span> </span>&#123;    <span class="hljs-comment">// 类变量，属于GC Roots的一部分</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CanReliveObj canReliveObj;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-keyword">super</span>.finalize();        System.out.println(<span class="hljs-string">&quot;调用当前类重写的finalize()方法&quot;</span>);        canReliveObj = <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        canReliveObj = <span class="hljs-keyword">new</span> CanReliveObj();        canReliveObj = <span class="hljs-keyword">null</span>;        System.gc();        System.out.println(<span class="hljs-string">&quot;-----------------第一次gc操作------------&quot;</span>);        <span class="hljs-comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span>        Thread.sleep(<span class="hljs-number">2000</span>);        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-keyword">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);        &#125;        System.out.println(<span class="hljs-string">&quot;-----------------第二次gc操作------------&quot;</span>);        canReliveObj = <span class="hljs-keyword">null</span>;        System.gc();        <span class="hljs-comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span>        Thread.sleep(<span class="hljs-number">2000</span>);        <span class="hljs-keyword">if</span> (canReliveObj == <span class="hljs-keyword">null</span>) &#123;            System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>最后运行结果</p><div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-comment">-----------------第一次gc操作------------</span>调用当前类重写的finalize()方法obj <span class="hljs-keyword">is</span> still alive<span class="hljs-comment">-----------------第二次gc操作------------</span>obj <span class="hljs-keyword">is</span> dead</code></pre></div><p>在进行第一次清除的时候，我们会执行finalize方法，然后 对象 进行了一次自救操作，但是因为finalize()方法只会被调用一次，因此第二次该对象将会被垃圾清除。</p><h2 id="4-MAT与JProfiler的GC-Roots溯源"><a href="#4-MAT与JProfiler的GC-Roots溯源" class="headerlink" title="4 MAT与JProfiler的GC Roots溯源"></a>4 MAT与JProfiler的GC Roots溯源</h2><h3 id="4-1-MAT是什么？"><a href="#4-1-MAT是什么？" class="headerlink" title="4.1 MAT是什么？"></a>4.1 MAT是什么？</h3><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p><p>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</p><p>大家可以在<a href="http://www.eclipse.org/mat/下载并使用MAT">http://www.eclipse.org/mat/下载并使用MAT</a></p><h3 id="4-2-命令行使用-jmap"><a href="#4-2-命令行使用-jmap" class="headerlink" title="4.2 命令行使用 jmap"></a>4.2 命令行使用 jmap</h3><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712112026317.png" alt="image-20200712112026317"></p><h3 id="4-3-使用JVIsualVM"><a href="#4-3-使用JVIsualVM" class="headerlink" title="4.3 使用JVIsualVM"></a>4.3 使用JVIsualVM</h3><p>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</p><p>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）。</p><p>在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。</p><p>右击这个节点选择save as（另存为）即可将heap dump保存到本地。</p><h3 id="4-4-使用MAT打开Dump文件"><a href="#4-4-使用MAT打开Dump文件" class="headerlink" title="4.4 使用MAT打开Dump文件"></a>4.4 使用MAT打开Dump文件</h3><p>打开后，我们就可以看到有哪些可以作为GC Roots的对象</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712112512720.png" alt="image-20200712112512720"></p><p>里面我们能够看到有一些常用的Java类，然后Thread线程。</p><h3 id="4-5-JProfiler的GC-Roots溯源"><a href="#4-5-JProfiler的GC-Roots溯源" class="headerlink" title="4.5 JProfiler的GC Roots溯源"></a>4.5 JProfiler的GC Roots溯源</h3><p>我们在实际的开发中，一般不会查找全部的GC Roots，可能只是查找某个对象的整个链路，或者称为GC Roots溯源，这个时候，我们就可以使用JProfiler</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712113256075.png" alt="image-20200712113256075"></p><h3 id="4-6-如何判断什么原因造成OOM"><a href="#4-6-如何判断什么原因造成OOM" class="headerlink" title="4.6 如何判断什么原因造成OOM"></a>4.6 如何判断什么原因造成OOM</h3><p>当我们程序出现OOM的时候，我们就需要进行排查，我们首先使用下面的例子进行说明</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 内存溢出排查</span><span class="hljs-comment"> * -Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapOOM</span> </span>&#123;    <span class="hljs-comment">// 创建1M的文件</span>    <span class="hljs-keyword">byte</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ArrayList&lt;HeapOOM&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                list.add(<span class="hljs-keyword">new</span> HeapOOM());                count++;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.getStackTrace();            System.out.println(<span class="hljs-string">&quot;count:&quot;</span> + count);        &#125;    &#125;&#125;</code></pre></div><p>上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用HeapDumpOnOutOfMemoryError将出错时候的dump文件输出</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms8m -Xmx8m -XX:HeapDumpOnOutOfMemoryError</span></code></pre></div><p>我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712150229048.png" alt="image-20200712150229048"></p><p>然后我们通过线程，还能够定位到哪里出现OOM</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712150303710.png" alt="image-20200712150303710"></p><h2 id="5-清除阶段：标记-清除算法"><a href="#5-清除阶段：标记-清除算法" class="headerlink" title="5 清除阶段：标记-清除算法"></a>5 清除阶段：标记-清除算法</h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p><ul><li>标记一清除算法（Mark-Sweep）</li><li>复制算法（copying）</li><li>标记-压缩算法（Mark-Compact）</li></ul><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><h3 id="5-1-执行过程"><a href="#5-1-执行过程" class="headerlink" title="5.1 执行过程"></a>5.1 执行过程</h3><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ul><li><strong>标记</strong>：Collector从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>。一般是在对象的Header中记录为可达对象。<ul><li><strong>标记的是引用的对象，不是垃圾！！</strong></li></ul></li><li><strong>清除</strong>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712150935078.png" alt="image-20200712150935078"></p><h3 id="5-2-什么是清除？"><a href="#5-2-什么是清除？" class="headerlink" title="5.2 什么是清除？"></a>5.2 什么是清除？</h3><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p><p>关于空闲列表是在为对象分配内存的时候 提过</p><ul><li>如果内存规整<ul><li>采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>虚拟机需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><h3 id="5-3-缺点"><a href="#5-3-缺点" class="headerlink" title="5.3 缺点"></a>5.3 缺点</h3><ul><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><h2 id="6-清除阶段：复制算法"><a href="#6-清除阶段：复制算法" class="headerlink" title="6 清除阶段：复制算法"></a>6 清除阶段：复制算法</h2><h3 id="6-1-背景"><a href="#6-1-背景" class="headerlink" title="6.1 背景"></a>6.1 背景</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p><h3 id="6-2-核心思想"><a href="#6-2-核心思想" class="headerlink" title="6.2 核心思想"></a>6.2 核心思想</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712151916991.png" alt="image-20200712151916991"></p><p>把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实里面的新生代里面就用到了复制算法</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712152029615.png" alt="image-20200712152029615"></p><h3 id="6-3-优点"><a href="#6-3-优点" class="headerlink" title="6.3 优点"></a>6.3 优点</h3><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><h3 id="6-4-缺点"><a href="#6-4-缺点" class="headerlink" title="6.4 缺点"></a>6.4 缺点</h3><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><h3 id="6-5-注意"><a href="#6-5-注意" class="headerlink" title="6.5 注意"></a>6.5 注意</h3><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</p><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712152847218.png" alt="image-20200712152847218"></p><h2 id="7-清除阶段：标记-整理算法"><a href="#7-清除阶段：标记-整理算法" class="headerlink" title="7 清除阶段：标记-整理算法"></a>7 清除阶段：标记-整理算法</h2><h3 id="7-1-背景"><a href="#7-1-背景" class="headerlink" title="7.1 背景"></a>7.1 背景</h3><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JvM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p><p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p><h3 id="7-2-执行过程"><a href="#7-2-执行过程" class="headerlink" title="7.2 执行过程"></a>7.2 执行过程</h3><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712153236508.png" alt="image-20200712153236508"></p><h3 id="7-3-标清和标整的区别"><a href="#7-3-标清和标整的区别" class="headerlink" title="7.3 标清和标整的区别"></a>7.3 标清和标整的区别</h3><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p><p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><h3 id="7-4-标整的优缺点"><a href="#7-4-标整的优缺点" class="headerlink" title="7.4 标整的优缺点"></a>7.4 标整的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8 小结"></a>8 小结</h2><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p>综合我们可以找到，没有最好的算法，只有最合适的算法</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li>年轻代（Young Gen）</li></ul><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><ul><li>老年代（Tenured Gen）</li></ul><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>compact阶段的开销与存活对象的数据成正比。</li></ul><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h2 id="9-增量收集算法"><a href="#9-增量收集算法" class="headerlink" title="9 增量收集算法"></a>9 增量收集算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理</strong>，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><h2 id="10-分区算法"><a href="#10-分区算法" class="headerlink" title="10 分区算法"></a>10 分区算法</h2><p>一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。<br>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712165318590.png" alt="image-20200712165318590"></p><h2 id="11-写到最后"><a href="#11-写到最后" class="headerlink" title="11 写到最后"></a>11 写到最后</h2><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p><h1 id="第16章-垃圾回收相关概念"><a href="#第16章-垃圾回收相关概念" class="headerlink" title="第16章 垃圾回收相关概念"></a>第16章 垃圾回收相关概念</h1><h2 id="1-System-gc-的理解"><a href="#1-System-gc-的理解" class="headerlink" title="1 System.gc()的理解"></a>1 System.gc()的理解</h2><p>在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p><p>JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc() </p><p>代码演示是否出发GC操作</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * System.gc()</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemGCTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> SystemGCTest();        <span class="hljs-comment">// 提醒JVM进行垃圾回收</span>        System.gc();        <span class="hljs-comment">//System.runFinalization();</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-keyword">super</span>.finalize();        System.out.println(<span class="hljs-string">&quot;SystemGCTest 执行了 finalize方法&quot;</span>);    &#125;&#125;</code></pre></div><p>运行结果，但是不一定会触发销毁的方法，调用System.runFinalization()会强制调用 失去引用对象的finalize()</p><div class="code-wrapper"><pre><code class="hljs mercury">SystemGCTest 执行了 <span class="hljs-keyword">finalize</span>方法</code></pre></div><h3 id="手动GC来理解不可达对象的回收"><a href="#手动GC来理解不可达对象的回收" class="headerlink" title="手动GC来理解不可达对象的回收"></a>手动GC来理解不可达对象的回收</h3><p>代码如下所示：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 局部变量回收</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalVarGC</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];        System.gc();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 触发YoungGC的时候，已经被回收了</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];        buffer = <span class="hljs-keyword">null</span>;        System.gc();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 不会被回收，因为它还存放在局部变量表索引为1的槽中</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC3</span><span class="hljs-params">()</span> </span>&#123;        &#123;            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];        &#125;        System.gc();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC4</span><span class="hljs-params">()</span> </span>&#123;        &#123;            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];        &#125;        <span class="hljs-keyword">int</span> value = <span class="hljs-number">10</span>;        System.gc();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * localvarGC5中的数组已经被回收</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localvarGC5</span><span class="hljs-params">()</span> </span>&#123;        localvarGC1();        System.gc();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        LocalVarGC localVarGC = <span class="hljs-keyword">new</span> LocalVarGC();        localVarGC.localvarGC3();    &#125;&#125;</code></pre></div><h2 id="2-内存溢出"><a href="#2-内存溢出" class="headerlink" title="2 内存溢出"></a>2 内存溢出</h2><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p><p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现ooM的情况。</p><p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Fu11GC操作，这时候会回收大量的内存，供应用程序继续使用。</p><p>javadoc中对outofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p><ul><li>Java虚拟机的堆内存设置不够。</li></ul><p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</p><ul><li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li></ul><p>对于老版本的oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</p><p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的ooM有所改观，出现ooM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</p><p>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><blockquote><p>例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。<br>在java.nio.BIts.reserveMemory（）方法中，我们能清楚的看到，System.gc（）会被调用，以清理空间。</p></blockquote><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><p>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</p><h2 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3 内存泄漏"></a>3 内存泄漏</h2><p>也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。</p><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现outofMemory异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p><blockquote><p>买房子：80平的房子，但是有10平是公摊的面积，我们是无法使用这10平的空间，这就是所谓的内存泄漏</p></blockquote><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712195158470.png" alt="image-20200712195158470"></p><p>Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。</p><h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><ul><li>单例模式</li></ul><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p><ul><li>一些提供close的资源未关闭导致内存泄漏</li></ul><p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</p><h2 id="4-Stop-The-World"><a href="#4-Stop-The-World" class="headerlink" title="4 Stop The World"></a>4 Stop The World</h2><p> stop-the-world，简称STw，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p><p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p><ul><li><p>分析工作必须在一个能确保一致性的快照中进行</p></li><li><p>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</p></li><li><p>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</p></li></ul><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STw的发生。</p><p>STW事件和采用哪款GC无关所有的GC都有这个事件。</p><p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>开发中不要用system.gc() 会导致stop-the-world的发生。</p><h2 id="5-垃圾回收的并行与并发"><a href="#5-垃圾回收的并行与并发" class="headerlink" title="5 垃圾回收的并行与并发"></a>5 垃圾回收的并行与并发</h2><h3 id="5-1-并发"><a href="#5-1-并发" class="headerlink" title="5.1 并发"></a>5.1 并发</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p><p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712202522051.png" alt="image-20200712202522051"></p><h3 id="5-2-并行"><a href="#5-2-并行" class="headerlink" title="5.2 并行"></a>5.2 并行</h3><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Paralle1）。</p><p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p><p>适合科学计算，后台处理等弱交互场景</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712202822129.png" alt="image-20200712202822129"></p><h3 id="5-3-并发和并行对比"><a href="#5-3-并发和并行对比" class="headerlink" title="5.3 并发和并行对比"></a>5.3 并发和并行对比</h3><p><strong>并发</strong>，指的是多个事情，在同一时间段内同时发生了。</p><p><strong>并行</strong>，指的是多个事情，在同一时间点上同时发生了。</p><p>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</p><p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。</p><p>否则，看似同时发生的事情，其实都是并发执行的。</p><h3 id="5-4-垃圾回收的并行与并发"><a href="#5-4-垃圾回收的并行与并发" class="headerlink" title="5.4 垃圾回收的并行与并发"></a>5.4 垃圾回收的并行与并发</h3><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ul><li><p>并行（Paralle1）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel old；</p></li><li><p>串行（Serial）</p><ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li></ul></li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712203607845.png" alt="image-20200712203607845"></p><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。&gt;用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</p><blockquote><p>如：CMS、G1</p></blockquote><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712203815517.png" alt="image-20200712203815517"></p><h2 id="6-安全点与安全区域"><a href="#6-安全点与安全区域" class="headerlink" title="6 安全点与安全区域"></a>6 安全点与安全区域</h2><h3 id="6-1-安全点"><a href="#6-1-安全点" class="headerlink" title="6.1 安全点"></a>6.1 安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p><p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p><p>如何在cc发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><ul><li><strong>抢先式中断</strong>：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li></ul><h3 id="6-2-安全区域"><a href="#6-2-安全区域" class="headerlink" title="6.2 安全区域"></a>6.2 安全区域</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于sleep-状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p><p><strong>执行流程：</strong></p><ul><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ul><h2 id="7-再谈引用"><a href="#7-再谈引用" class="headerlink" title="7 再谈引用"></a>7 再谈引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？<br>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p><ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ul><p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.1ang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712205813321.png" alt="image-20200712205813321"></p><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ul><li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object（）”这种引用关系。无论任何情况下，==只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象==。</li><li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li><li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。==为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知==。</li></ul><h2 id="8-再谈引用：强引用"><a href="#8-再谈引用：强引用" class="headerlink" title="8 再谈引用：强引用"></a>8 再谈引用：强引用</h2><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p><h3 id="8-1-举例"><a href="#8-1-举例" class="headerlink" title="8.1 举例"></a>8.1 举例</h3><p>强引用的案例说明</p><div class="code-wrapper"><pre><code class="hljs java">StringBuffer str = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello mogublog&quot;</span>);</code></pre></div><p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712211501377.png" alt="image-20200712211501377"></p><p>如果此时，在运行一个赋值语句</p><div class="code-wrapper"><pre><code class="hljs java">StringBuffer str = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello mogublog&quot;</span>);StringBuffer str1 = str;</code></pre></div><p>对应的内存结构为:</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200712211732976.png" alt="image-20200712211732976"></p><p>那么我们将 str = null; 则 原来堆中的对象也不会被回收，因为还有其它对象指向该区域</p><h3 id="8-2-总结"><a href="#8-2-总结" class="headerlink" title="8.2 总结"></a>8.2 总结</h3><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ul><h2 id="9-再谈引用：-软引用"><a href="#9-再谈引用：-软引用" class="headerlink" title="9 再谈引用： 软引用"></a>9 再谈引用： 软引用</h2><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><blockquote><p>注意，这里的第一次回收是不可达的对象</p></blockquote><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p><blockquote><p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</p></blockquote><p>在JDK1.2版之后提供了SoftReference类来实现软引用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span>Object obj = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">// 创建一个软引用</span>SoftReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(obj);obj = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//销毁强引用，这是必须的，不然会存在强引用和软引用</span></code></pre></div><h2 id="10-再谈引用：弱引用"><a href="#10-再谈引用：弱引用" class="headerlink" title="10 再谈引用：弱引用"></a>10 再谈引用：弱引用</h2><blockquote><p>发现即回收</p></blockquote><p>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p><p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span>Object obj = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">// 创建一个弱引用</span>WeakReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(obj);obj = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//销毁强引用，这是必须的，不然会存在强引用和弱引用</span></code></pre></div><p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p><p>面试题：你开发中使用过WeakHashMap吗？</p><p>WeakHashMap用来存储图片信息，可以在内存不足的时候，及时回收，避免了OOM</p><h2 id="11-再谈引用：虚引用"><a href="#11-再谈引用：虚引用" class="headerlink" title="11 再谈引用：虚引用"></a>11 再谈引用：虚引用</h2><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null</p><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><blockquote><p>虚引用无法获取到我们的数据</p></blockquote><p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span>Object obj = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">// 声明引用队列</span>ReferenceQueue phantomQueue = <span class="hljs-keyword">new</span> ReferenceQueue();<span class="hljs-comment">// 声明虚引用（还需要传入引用队列）</span>PhantomReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);obj = <span class="hljs-keyword">null</span>;</code></pre></div><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>我们使用一个案例，来结合虚引用，引用队列，finalize进行讲解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-07-12-21:42</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhantomReferenceTest</span> </span>&#123;    <span class="hljs-comment">// 当前类对象的声明</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PhantomReferenceTest obj;    <span class="hljs-comment">// 引用队列</span>    <span class="hljs-keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="hljs-keyword">null</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-keyword">super</span>.finalize();        System.out.println(<span class="hljs-string">&quot;调用当前类的finalize方法&quot;</span>);        obj = <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">if</span> (phantomQueue != <span class="hljs-keyword">null</span>) &#123;                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="hljs-keyword">null</span>;                    <span class="hljs-keyword">try</span> &#123;                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                        e.getStackTrace();                    &#125;                    <span class="hljs-keyword">if</span> (objt != <span class="hljs-keyword">null</span>) &#123;                        System.out.println(<span class="hljs-string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);                    &#125;                &#125;            &#125;        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);        thread.setDaemon(<span class="hljs-keyword">true</span>);        thread.start();        phantomQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();        obj = <span class="hljs-keyword">new</span> PhantomReferenceTest();        <span class="hljs-comment">// 构造了PhantomReferenceTest对象的虚引用，并指定了引用队列</span>        PhantomReference&lt;PhantomReferenceTest&gt; phantomReference = <span class="hljs-keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);        <span class="hljs-keyword">try</span> &#123;            System.out.println(phantomReference.get());            <span class="hljs-comment">// 去除强引用</span>            obj = <span class="hljs-keyword">null</span>;            <span class="hljs-comment">// 第一次进行GC，由于对象可复活，GC无法回收该对象</span>            System.out.println(<span class="hljs-string">&quot;第一次GC操作&quot;</span>);            System.gc();            Thread.sleep(<span class="hljs-number">1000</span>);            <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123;                System.out.println(<span class="hljs-string">&quot;obj 是 null&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                System.out.println(<span class="hljs-string">&quot;obj 不是 null&quot;</span>);            &#125;            System.out.println(<span class="hljs-string">&quot;第二次GC操作&quot;</span>);            obj = <span class="hljs-keyword">null</span>;            System.gc();            Thread.sleep(<span class="hljs-number">1000</span>);            <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123;                System.out.println(<span class="hljs-string">&quot;obj 是 null&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                System.out.println(<span class="hljs-string">&quot;obj 不是 null&quot;</span>);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;        &#125;    &#125;&#125;</code></pre></div><p>最后运行结果</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">null</span>第一次GC操作调用当前类的finalize方法obj 不是 <span class="hljs-keyword">null</span>第二次GC操作追踪垃圾回收过程：PhantomReferenceTest实例被GC了obj 是 <span class="hljs-keyword">null</span></code></pre></div><p>从上述运行结果我们知道，第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次gc，因为会调用finalize方法，将对象复活了，所以对象没有被回收，但是调用第二次gc操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是 将回收的值存入到引用队列中。</p><h2 id="12-终结器引用"><a href="#12-终结器引用" class="headerlink" title="12 终结器引用"></a>12 终结器引用</h2><p>它用于实现对象的finalize() 方法，也可以称为终结器引用</p><p>无需手动编码，其内部配合引用队列使用</p><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p><h1 id="第17章-垃圾回收器"><a href="#第17章-垃圾回收器" class="headerlink" title="第17章 垃圾回收器"></a>第17章 垃圾回收器</h1><h2 id="1-GC分类与性能指标"><a href="#1-GC分类与性能指标" class="headerlink" title="1 GC分类与性能指标"></a>1 GC分类与性能指标</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p><p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p><p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p><blockquote><p>Java不同版本新特性</p><ul><li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum</li><li>API层面：Stream API、新的日期时间、Optional、String、集合框架</li><li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化</li></ul></blockquote><h3 id="1-1-垃圾收集器分类"><a href="#1-1-垃圾收集器分类" class="headerlink" title="1.1 垃圾收集器分类"></a>1.1 垃圾收集器分类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a><strong>按线程数分</strong></h4><p><strong>按线程数分</strong>（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713083030867.png" alt="image-20200713083030867"></p><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li></ul><p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。</p><h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713083443486.png" alt="image-20200713083443486"></p><h4 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h4><p>按碎片处理方式分，可分为压缩武垃圾回收器和非压缩式垃圾回收器。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li><li>非压缩式的垃圾回收器不进行这步操作。</li></ul><p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p><h3 id="1-2-评估GC的性能指标"><a href="#1-2-评估GC的性能指标" class="headerlink" title="1.2 评估GC的性能指标"></a>1.2 评估GC的性能指标</h3><ul><li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li><li><strong>垃圾收集开销</strong>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li><strong>收集频率</strong>：相对于应用程序的执行，收集操作发生的频率。</li><li><strong>内存占用</strong>：Java堆区所占的内存大小。</li><li><strong>快速</strong>：一个对象从诞生到被回收所经历的时间。</li></ul><p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。<br>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。<br>简单来说，主要抓住两点：</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。<br>简单来说，主要抓住两点：</p><ul><li>吞吐量</li><li>暂停时间</li></ul><h3 id="1-3-性能指标：吞吐量"><a href="#1-3-性能指标：吞吐量" class="headerlink" title="1.3 性能指标：吞吐量"></a>1.3 性能指标：吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</p><blockquote><p>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p></blockquote><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=e.4</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713084726176.png" alt="image-20200713084726176"></p><h3 id="1-4-性能指标：暂停时间"><a href="#1-4-性能指标：暂停时间" class="headerlink" title="1.4 性能指标：暂停时间"></a>1.4 性能指标：暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让Gc线程执行的状态</p><p>例如，GC期间1ee毫秒的暂停时间意味着在这1e0毫秒期间内没有应用程序线程是活动的。暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713085306400.png" alt="image-20200713085306400"></p><h3 id="1-5-吞吐量vs暂停时间"><a href="#1-5-吞吐量vs暂停时间" class="headerlink" title="1.5 吞吐量vs暂停时间"></a>1.5 吞吐量vs暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</p><p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p><p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p><p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><h2 id="2-不同的垃圾回收器概述"><a href="#2-不同的垃圾回收器概述" class="headerlink" title="2 不同的垃圾回收器概述"></a>2 不同的垃圾回收器概述</h2><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p><p>那么，Java常见的垃圾收集器有哪些？</p><blockquote><p>GC垃圾收集器是和JVM一脉相承的，它是和JVM进行搭配使用，在不同的使用场景对应的收集器也是有区别</p></blockquote><h3 id="2-1-垃圾回收器发展史"><a href="#2-1-垃圾回收器发展史" class="headerlink" title="2.1 垃圾回收器发展史"></a>2.1 垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p><ul><li>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li><li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li><li>Parallel GC在JDK6之后成为HotSpot默认GC。</li><li>2012年，在JDK1.7u4版本中，G1可用。</li><li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li><li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。·2019年9月，JDK13发布。增强zGC，自动返回未用堆内存给操作系统。</li><li>2020年3月，JDK14发布。删除cMs垃圾回收器。扩展zGC在macos和Windows上的应用</li></ul><h3 id="2-2-7种经典的垃圾收集器"><a href="#2-2-7种经典的垃圾收集器" class="headerlink" title="2.2 7种经典的垃圾收集器"></a>2.2 7种经典的垃圾收集器</h3><ul><li>串行回收器：Serial、Serial old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G11</li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713093551365.png" alt="image-20200713093551365"></p><h3 id="2-3-7款经典收集器与垃圾分代之间的关系"><a href="#2-3-7款经典收集器与垃圾分代之间的关系" class="headerlink" title="2.3 7款经典收集器与垃圾分代之间的关系"></a>2.3 7款经典收集器与垃圾分代之间的关系</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/17_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/images/image-20200713093757644.png" alt="image-20200713093757644"></p><p>新生代收集器：Serial、ParNew、Paralle1 Scavenge；</p><p>老年代收集器：Serial old、Parallel old、CMS；</p><p>整堆收集器：G1；</p><h3 id="2-4-垃圾收集器的组合关系"><a href="#2-4-垃圾收集器的组合关系" class="headerlink" title="2.4 垃圾收集器的组合关系"></a>2.4 垃圾收集器的组合关系</h3><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713094745366.png" alt="image-20200713094745366"></p><ul><li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial old、Serial/CMS、ParNew/Serial old、ParNew/CMS、Parallel Scavenge/Serial 0ld、Parallel Scavenge/Parallel 01d、G1；</li><li>其中Serial o1d作为CMs出现”Concurrent Mode Failure”失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14中：弃用Paralle1 Scavenge和Serialold GC组合（JEP366）</li><li>（青色虚线）JDK14中：删除CMs垃圾回收器（JEP363）</li></ul><p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p><h3 id="2-5-如何查看默认垃圾收集器"><a href="#2-5-如何查看默认垃圾收集器" class="headerlink" title="2.5 如何查看默认垃圾收集器"></a>2.5 如何查看默认垃圾收集器</h3><p>-XX:+PrintcommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p><p>使用命令行指令：jinfo -flag  相关垃圾回收器参数  进程ID</p><h2 id="3-Serial回收器：串行回收"><a href="#3-Serial回收器：串行回收" class="headerlink" title="3 Serial回收器：串行回收"></a>3 Serial回收器：串行回收</h2><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p><p>Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。</p><p>Serial收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</p><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了串行回收和”stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p><ul><li>Serial old是运行在Client模式下默认的老年代的垃圾回收器</li><li>Serial 0ld在Server模式下主要有两个用途：<ul><li>与新生代的Parallel scavenge配合使用</li><li>作为老年代CMS收集器的后备垃圾收集方案</li></ul></li></ul><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713100703799.png" alt="image-20200713100703799"></p><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><p>优势：简单而高效（与其他收集器的单线程比），对于限定单个cPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><p>运行在client模式下的虚拟机是个不错的选择。</p><p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</p><p>等价于新生代用Serial GC，且老年代用Serial old GC</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p><h2 id="4-ParNew回收器：并行回收"><a href="#4-ParNew回收器：并行回收" class="headerlink" title="4 ParNew回收器：并行回收"></a>4 ParNew回收器：并行回收</h2><p>如果说serialGC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。</p><ul><li>Par是Parallel的缩写，New：只能处理的是新生代</li></ul><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”stop-the-World”机制。</p><p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713102030127.png" alt="image-20200713102030127"></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p><ul><li></li></ul><p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p><p>在程序中，开发人员可以通过选项”-XX：+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p><h2 id="5-Parallel回收器：吞吐量优先"><a href="#5-Parallel回收器：吞吐量优先" class="headerlink" title="5 Parallel回收器：吞吐量优先"></a>5 Parallel回收器：吞吐量优先</h2><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p><p>那么Parallel 收集器的出现是否多此一举？</p><ul><li>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是Paralle1 Scavenge与ParNew一个重要区别。</li></ul><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Paralle1收集器在JDK1.6时提供了用于执行老年代垃圾收集的Paralle1o1d收集器，用来代替老年代的serialold收集器。</p><p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”stop-the-World”机制。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713110359441.png" alt="image-20200713110359441"></p><p>在程序吞吐量优先的应用场景中，IParalle1收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。</p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>-XX：+UseParallelGC 手动指定年轻代使用Paralle1并行收集器执行内存回收任务。</p><p>-XX：+UseParalleloldcc 手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代。默认jdk8是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul><p>-XX:ParallelGcrhreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>在默认情况下，当CPU数量小于8个，ParallelGcThreads的值等于CPU数量。</p><p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU Count]/8]</p><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。</p><p>为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。<br>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</p><p>-XX:GCTimeRatio垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p><p>取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1。</p><p>与前一个-xx:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p><p>-XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略</p><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。</p><h2 id="6-CMS回收器：低延迟"><a href="#6-CMS回收器：低延迟" class="headerlink" title="6 CMS回收器：低延迟"></a>6 CMS回收器：低延迟</h2><p>在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：cMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>CMS的垃圾收集算法采用标记-清除算法，并且也会”stop-the-world”</p><p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p><p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713205154007.png" alt="image-20200713205154007"></p><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p><ul><li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”<br>失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713212230352.png" alt="image-20200713212230352"></p><h3 id="6-1-CMS为什么不使用标记整理算法？"><a href="#6-1-CMS为什么不使用标记整理算法？" class="headerlink" title="6.1 CMS为什么不使用标记整理算法？"></a>6.1 CMS为什么不使用标记整理算法？</h3><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”<br>这种场景下使用</p><h3 id="6-2-优点"><a href="#6-2-优点" class="headerlink" title="6.2 优点"></a>6.2 优点</h3><ul><li>并发收集</li><li>低延迟</li></ul><h3 id="6-3-缺点"><a href="#6-3-缺点" class="headerlink" title="6.3 缺点"></a>6.3 缺点</h3><ul><li><p>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</p></li><li><p>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p></li><li><p>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</p></li></ul><h3 id="6-4-设置的参数"><a href="#6-4-设置的参数" class="headerlink" title="6.4 设置的参数"></a>6.4 设置的参数</h3><ul><li>-XX：+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务。</li></ul><p>开启该参数后会自动将-xx：+UseParNewGC打开。即：ParNew（Young区用）+CMS（01d区用）+Serial old的组合。</p><ul><li>-XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</li></ul><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次cMs回收。JDK6及以上版本默认值为92%</p><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</p><ul><li>-XX：+UseCMSCompactAtFullCollection用于指定在执行完Ful1</li></ul><p>GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p><ul><li><p>-XX:CMSFullGCsBeforecompaction 设置在执行多少次Ful1GC后对内存空间进行压缩整理。</p></li><li><p>-XX:ParallelcMSThreads 设置cMs的线程数量。</p></li></ul><p>CMs默认启动的线程数是（Paralle1GCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p><h3 id="6-5-小结"><a href="#6-5-小结" class="headerlink" title="6.5 小结"></a>6.5 小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个Gc有什么不同呢？</p><p>请记住以下口令：</p><ul><li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li><li>如果你想要最小化GC的中断或停顿时间，请选CMs GC。</li></ul><h3 id="6-7-JDK后续版本中CMS的变化"><a href="#6-7-JDK后续版本中CMS的变化" class="headerlink" title="6.7 JDK后续版本中CMS的变化"></a>6.7 JDK后续版本中CMS的变化</h3><p><strong>JDK9新特性</strong>：CMS被标记为eprecate了（JEP291）&gt;如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX：<br>+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</p><p>JDK14新特性：删除CMs垃圾回收器（JEP363）移除了CMS垃圾收集器，如果在JDK14中使用<br>XX：+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p><h2 id="7-G1回收器：区域化分代式"><a href="#7-G1回收器：区域化分代式" class="headerlink" title="7 G1回收器：区域化分代式"></a>7 G1回收器：区域化分代式</h2><h3 id="7-1-既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？"><a href="#7-1-既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First（G1）？" class="headerlink" title="7.1 既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？"></a>7.1 既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</h3><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p><p><strong>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p><h3 id="7-2-为什么名字叫-Garbage-First-G1-呢？"><a href="#7-2-为什么名字叫-Garbage-First-G1-呢？" class="headerlink" title="7.2 为什么名字叫 Garbage First(G1)呢？"></a>7.2 为什么名字叫 Garbage First(G1)呢？</h3><p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p><p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Paralle1+Parallel old组合。被orac1e官方称为“全功能的垃圾收集器”。</p><p>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-xx：+UseG1GC来启用。</p><h3 id="7-3-G1垃圾收集器的优点"><a href="#7-3-G1垃圾收集器的优点" class="headerlink" title="7.3 G1垃圾收集器的优点"></a>7.3 G1垃圾收集器的优点</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><p><strong>并行与并发</strong></p><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><p><strong>分代收集</strong></p><ul><li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p>G1所谓的分代，已经不是下面这样的了</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713215105293.png" alt="image-20200713215105293"></p><p>而是这样的一个区域</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713215133839.png" alt="image-20200713215133839"></p><p><strong>空间整合</strong></p><ul><li>CMS：“标记-清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li><li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ul><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong><br>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><h3 id="7-4-G1垃圾收集器的缺点"><a href="#7-4-G1垃圾收集器的缺点" class="headerlink" title="7.4 G1垃圾收集器的缺点"></a>7.4 G1垃圾收集器的缺点</h3><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><h3 id="7-5-G1参数设置"><a href="#7-5-G1参数设置" class="headerlink" title="7.5 G1参数设置"></a>7.5 G1参数设置</h3><ul><li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li><li>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li><li>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li><li>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</li><li>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li><li>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li></ul><h3 id="7-6-G1收集器的常见操作步骤"><a href="#7-6-G1收集器的常见操作步骤" class="headerlink" title="7.6 G1收集器的常见操作步骤"></a>7.6 G1收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Fu11GC，在不同的条件下被触发。</p><h3 id="7-7-G1收集器的适用场景"><a href="#7-7-G1收集器的适用场景" class="headerlink" title="7.7 G1收集器的适用场景"></a>7.7 G1收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p><p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</p><p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于e.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次Gc停顿时间不会过长）。<br>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用61可能比CMS好：</p><ul><li>超过5e%的Java堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC停顿时间过长（长于e.5至1秒）</li></ul><p>HotSpot垃圾收集器里，除了61以外，其他的垃圾收集器使用内置的JVM线程执行Gc的多线程操作，而G1GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h3 id="7-8-分区Region：化整为零"><a href="#7-8-分区Region：化整为零" class="headerlink" title="7.8 分区Region：化整为零"></a>7.8 分区Region：化整为零</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p><p>XX:G1HeapRegionsize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713223244886.png" alt="image-20200713223244886"></p><p>一个region有可能属于Eden，Survivor或者old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于01d内存区域。图中空白的表示未使用的内存空间。</p><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p><p><strong>设置H的原因：</strong>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Fu11Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p>每个Region都是通过指针碰撞来分配空间</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713223509993.png" alt="image-20200713223509993"></p><h3 id="7-9-G1垃圾回收器的回收过程"><a href="#7-9-G1垃圾回收器的回收过程" class="headerlink" title="7.9 G1垃圾回收器的回收过程"></a>7.9 G1垃圾回收器的回收过程</h3><p>G1GC的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li></ul><p>（如果需要，单线程、独占式、高强度的Fu11GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713224113996.png" alt="image-20200713224113996"></p><p>顺时针，young gc-&gt;young gc+concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p><p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p><p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h3 id="7-10-Remembered-Set（记忆集）"><a href="#7-10-Remembered-Set（记忆集）" class="headerlink" title="7.10 Remembered Set（记忆集）"></a>7.10 Remembered Set（记忆集）</h3><p>一个对象被不同区域引用的问题</p><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p><p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？这样的话会降低MinorGC的效率；</p><p><strong>解决方法：</strong></p><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p><p>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过cardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713224716715.png" alt="image-20200713224716715"></p><h3 id="7-11-G1回收过程-年轻代GC"><a href="#7-11-G1回收过程-年轻代GC" class="headerlink" title="7.11 G1回收过程-年轻代GC"></a>7.11 G1回收过程-年轻代GC</h3><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p><p>YGC时，首先G1停止应用程序的执行（stop-The-Wor1d），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713225100632.png" alt="image-20200713225100632"></p><p>然后开始如下回收过程：</p><ul><li>第一阶段，扫描根</li></ul><p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p><ul><li>第二阶段，更新RSet</li></ul><p>处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p><ul><li>第三阶段，处理RSet</li></ul><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p><ul><li>第四阶段，复制对象。</li></ul><p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p><ul><li>第五阶段，处理引用</li></ul><p>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p><h3 id="7-12-G1回收过程-并发标记过程"><a href="#7-12-G1回收过程-并发标记过程" class="headerlink" title="7.12 G1回收过程-并发标记过程"></a>7.12 G1回收过程-并发标记过程</h3><ul><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是sTw的，并且会触发一次年轻代GC。</li><li>根区域扫描（Root Region Scanning）：G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC之前完成。</li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是sTw的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ul><h3 id="7-13-G1回收过程-混合回收"><a href="#7-13-G1回收过程-混合回收" class="headerlink" title="7.13 G1回收过程 - 混合回收"></a>7.13 G1回收过程 - 混合回收</h3><p>当越来越多的对象晋升到老年代o1d region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old GC，除了回收整个Young Region，还会回收一部分的old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些o1d Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200713225810871.png" alt="image-20200713225810871"></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，</p><p>XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为1e%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于1e%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p><h3 id="7-14-G1回收可选的过程4-Full-GC"><a href="#7-14-G1回收可选的过程4-Full-GC" class="headerlink" title="7.14 G1回收可选的过程4 - Full GC"></a>7.14 G1回收可选的过程4 - Full GC</h3><p>G1的初衷就是要避免Fu11GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（stop-The-world），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免Fu11GC的发生，一旦发生需要进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到ful1gc，这种情况可以通过增大内存解决。<br>导致61Fu11GC的原因可能有两个：</p><ul><li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h3 id="7-15-G1回收的优化建议"><a href="#7-15-G1回收的优化建议" class="headerlink" title="7.15 G1回收的优化建议"></a>7.15 G1回收的优化建议</h3><p> 从oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><p>年轻代大小</p><ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖</li></ul><p>暂停时间目标暂停时间目标不要太过严苛</p><ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul><h2 id="8-垃圾回收器总结"><a href="#8-垃圾回收器总结" class="headerlink" title="8 垃圾回收器总结"></a>8 垃圾回收器总结</h2><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714075738203.png" alt="image-20200714075738203"></p><p>GC发展阶段：Seria l=&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714080151020.png" alt="image-20200714080151020"></p><h3 id="8-1-怎么选择垃圾回收器"><a href="#8-1-怎么选择垃圾回收器" class="headerlink" title="8.1 怎么选择垃圾回收器"></a>8.1 怎么选择垃圾回收器</h3><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p><ul><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li><li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ul><p>最后需要明确一个观点：</p><ul><li>没有最好的收集器，更没有万能的收集</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ul><h3 id="8-2-面试"><a href="#8-2-面试" class="headerlink" title="8.2 面试"></a>8.2 面试</h3><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。<br>这里较通用、基础性的部分如下：</p><p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p><p>垃圾收集器工作的基本流程。</p><p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p><h2 id="9-GC日志分析"><a href="#9-GC日志分析" class="headerlink" title="9 GC日志分析"></a>9 GC日志分析</h2><p>通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。<br>内存分配与垃圾回收的参数列表</p><ul><li>-XX:+PrintGc输出GC日志。类似：-verbose:gc</li><li>-XX:+PrintGcDetails输出Gc的详细日志</li><li>-XX:+PrintGcTimestamps 输出Gc的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDatestamps 输出Gc的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</li><li>-XX:+PrintHeapAtGC在进行Gc的前后打印出堆的信息</li><li>-Xloggc:../logs/gc.1og日志文件的输出路径</li></ul><h3 id="9-1-verbose-gc"><a href="#9-1-verbose-gc" class="headerlink" title="9.1 verbose:gc"></a>9.1 verbose:gc</h3><p>打开GC日志</p><div class="code-wrapper"><pre><code class="hljs bash">-verbose:gc</code></pre></div><p>这个只会显示总的GC堆的变化，如下：</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714081610474.png" alt="image-20200714081610474"></p><p>参数解析</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714081622526.png" alt="image-20200714081622526"></p><h3 id="9-2-PrintGCDetails"><a href="#9-2-PrintGCDetails" class="headerlink" title="9.2 PrintGCDetails"></a>9.2 PrintGCDetails</h3><p>打开GC日志</p><div class="code-wrapper"><pre><code class="hljs bash">-verbose:gc -XX:+PrintGCDetails</code></pre></div><p>输入信息如下</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714081909309.png" alt="image-20200714081909309"></p><p>参数解析</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714081925767.png" alt="image-20200714081925767"></p><h3 id="9-3-补充"><a href="#9-3-补充" class="headerlink" title="9.3 补充"></a>9.3 补充</h3><ul><li>[GC”和”[Fu11GC”说明了这次垃圾收集的停顿类型，如果有”Fu11”则说明GC发生了”stop The World”</li><li>使用Seria1收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li><li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li><li>使用Paralle1 scavenge收集器在新生代的名字是”[PSYoungGen”</li><li>老年代的收集和新生代道理一样，名字也是收集器决定的</li><li>使用G1收集器的话，会显示为”garbage-first heap”</li></ul><p>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p><p>[PSYoungGen：5986K-&gt;696K（8704K）]5986K-&gt;704K（9216K）中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p><p>user代表用户态回收耗时，sys内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过rea1时间</p><h3 id="9-4-Young-GC图片"><a href="#9-4-Young-GC图片" class="headerlink" title="9.4 Young GC图片"></a>9.4 Young GC图片</h3><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714082555688.png" alt="image-20200714082555688"></p><h3 id="9-5-FullGC图片"><a href="#9-5-FullGC图片" class="headerlink" title="9.5 FullGC图片"></a>9.5 FullGC图片</h3><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714082714690.png" alt="image-20200714082714690"></p><h3 id="9-6-GC回收举例"><a href="#9-6-GC回收举例" class="headerlink" title="9.6 GC回收举例"></a>9.6 GC回收举例</h3><p>我们编写一个程序，用来说明GC收集的过程</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * GC垃圾收集过程</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCUseTest</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">byte</span> [] allocation1, allocation2, allocation3, allocation4;        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];        allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];        allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> *_1MB];        allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span> *_1MB];    &#125;&#125;</code></pre></div><p>我们设置JVM启动参数</p><div class="code-wrapper"><pre><code class="hljs bash">-Xms10m -Xmx10m -XX:+PrintGCDetails</code></pre></div><p>首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714083332238.png" alt="image-20200714083332238"></p><p>然后我们将4M对象存入到Eden区中</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714083526790.png" alt="image-20200714083526790"></p><p>可以用一些工具去分析这些GC日志</p><p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p><p><strong>GCViewer</strong></p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714084921184.png" alt="image-20200714084921184"></p><p><strong>GC easy</strong></p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714084726824.png" alt="image-20200714084726824"></p><h2 id="10-垃圾回收器的新发展"><a href="#10-垃圾回收器的新发展" class="headerlink" title="10 垃圾回收器的新发展"></a>10 垃圾回收器的新发展</h2><p>GC仍然处于飞速发展之中，目前的默认选项G1GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Fu11GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</p><p>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</p><p>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</p><p>Epsilon:A No-Op GarbageCollector（Epsilon垃圾回收器，”No-Op（无操作）”回收器）<a href="http://openidk.iava.net/iep">http://openidk.iava.net/iep</a> s/318</p><p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</p><p>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12）</p><blockquote><p>主打特点：低停顿时间</p></blockquote><h3 id="10-1-Open-JDK12的Shenandoash-GC"><a href="#10-1-Open-JDK12的Shenandoash-GC" class="headerlink" title="10.1 Open JDK12的Shenandoash GC"></a>10.1 Open JDK12的Shenandoash GC</h3><p>Open JDK12的shenandoash GC：低停顿时间的GC（实验性）</p><p>Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDk没有区别的Oracle公司仍拒绝在oracleJDK12中支持Shenandoah。</p><p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</p><p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714090608807.png" alt="image-20200714090608807"></p><p>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：</p><blockquote><p>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。<br>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</p></blockquote><p>总结</p><ul><li>shenandoah Gc的弱项：高运行负担下的吞吐量下降。</li><li>shenandoah GC的强项：低延迟时间。</li></ul><h3 id="10-2-革命性的ZGC"><a href="#10-2-革命性的ZGC" class="headerlink" title="10.2 革命性的ZGC"></a>10.2 革命性的ZGC</h3><p>zGC与shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p><p>《深入理解Java虚拟机》一书中这样定义zGC：2GC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p><p>ZGC的工作过程可以分为4个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p><p>ZGC几乎在所有地方并发执行的，除了初始标记的是STw的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714091201073.png" alt="image-20200714091201073"></p><p>停顿时间对比</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714091401511.png" alt="image-20200714091401511"></p><p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。<br>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714093243028.png" alt="image-20200714093243028"></p><p>JDK14之前，2GC仅Linux才支持。</p><p>尽管许多使用zGc的用户都使用类Linux的环境，但在Windows和macos上，人们也需要zGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，2GC特性被移植到了Windows和macos上。</p><p>现在mac或Windows上也能使用zGC了，示例如下：</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:+UnlockExperimentalVMOptions-XX：+UseZGC</code></pre></div><h3 id="10-3-AliGC"><a href="#10-3-AliGC" class="headerlink" title="10.3 AliGC"></a>10.3 AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src="/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/image-20200714093604012.png" alt="image-20200714093604012"></p><p>当然，其它厂商也提供了各种别具一格的GC实现，例如比较有名的低延迟GC Zing</p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Java/">Java</category>
      
      <category domain="https://pncalbl.github.io/categories/Java/Tool/">Tool</category>
      
      
      
      <comments>https://pncalbl.github.io/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>基于物联网(IoT)的太阳能跟踪器</title>
      <link>https://pncalbl.github.io/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/</link>
      <guid>https://pncalbl.github.io/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/</guid>
      <pubDate>Mon, 07 Jun 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;基于物联网-IoT-的太阳能跟踪器&quot;&gt;&lt;a href=&quot;#基于物联网-IoT-的太阳能跟踪器&quot; class=&quot;headerlink&quot; title=&quot;基于物联网(IoT)的太阳能跟踪器&quot;&gt;&lt;/a&gt;基于物联网(IoT)的太阳能跟踪器&lt;/h1&gt;&lt;h2 id=&quot;1-项目概</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基于物联网-IoT-的太阳能跟踪器"><a href="#基于物联网-IoT-的太阳能跟踪器" class="headerlink" title="基于物联网(IoT)的太阳能跟踪器"></a>基于物联网(IoT)的太阳能跟踪器</h1><h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1 项目概述"></a>1 项目概述</h2><ul><li><p>该项目提供了一个简单和低成本的 IoT 解决方案，用于监控和控制智能双轴太阳能跟踪系统，用于性能评估。</p></li><li><p>项目中的基于 IoT 的太阳能跟踪系统在图 1 中进行了描述。它是一种双轴太阳能跟踪器，可以自动旋转，使用LDR传感器跟踪太阳的位置，或者用户通过物理控制的仪表板手动跟踪太阳的位置。系统从 LDR 传感器检测太阳位置（光的强度）开始，并将数据发送到控制器（Arduino Mega 板）。后者然后处理这些数据以命令保存器 （SM1 和 SM2），这些存储器将光伏面板旋转到太阳。产生的光伏电压值和电流、温度和湿度也通过相关传感器发送到 Arduino。</p></li><li><p>接下来，安装在 Arduino 并允许其连接到 Internet 的以太网扩展模块将把Arduino正在获取或处理的数据发送到云（Webserver）。最后，通过预制的小部件实时显示太阳跟踪器数据，包括LDR传感器、光伏功率、温度和湿度。物联网监控应用程序是使用我的设备卡宴。一旦用户从计算机或智能手机连接到互联网，他可以在物联网应用程序的仪表板中在其相关小部件中可视化所有太阳能跟踪器数据。因此，用户拥有与光伏面板的环境和性能相关的必要数据。</p></li><li><p>此外，在手动模式下，伺服运动器将从仪表板中的相关小部件中获取角度方向。因此，用户可以控制自己的系统，以寻求最佳的环境条件，并从光伏面板中提取最大能量。物联网应用程序还被编程为在senor达到预定阈值时发送通知警报（短信或电子邮件）。</p></li></ul><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/clip_image002.png" alt="图1. 项目总体设计图。"></p><p>​                                            </p><h2 id="2-硬件设计"><a href="#2-硬件设计" class="headerlink" title="2 硬件设计"></a>2 硬件设计</h2><ul><li>如图2所示，物联网太阳能跟踪系统由光伏电池板、两台伺服电机、四个LDR传感器、电压分频器电路、温度和湿度传感器、Led和Arduino Mega 板组成。</li></ul><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/electronic_circuit_of_the_iot-based_solar_tracker_system_9ORL3xysVy.png" alt="图2. 基于物联网（IoT）的太阳能跟踪器的硬件电路图。"></p><ul><li><p>使用的光伏面板尺寸为 115 mm 乘 85mm，输出为 1.6 W，可产生高达 6 V 的电压。两个180度的伺服器用于使太阳能跟踪器电机化，它们由阿尔杜伊诺板通过PWM引脚5和6控制。左右 （L-R） 伺服电机 （MG996R） 在垂直轴上（东/西）旋转太阳跟踪器，而上下 （U-D） 伺服电机 （SG90） 在水平轴 （南/北） 上旋转太阳跟踪器。</p></li><li><p>四个LDR（Cds GL5528）用于感应太阳的位置，这些位置已固定在面板的四个角落。LDR 传感器通过 A0 到 A3 的模拟引脚连接到阿尔杜伊诺。LDR 是一种电阻器，其值随着表面光强度事件的增加而降低。LDR 传感器设计为电压分流器电路，如图 2 所见。分频器输出电压由 Arduino Mega 的微控制器从模拟值转换为 0 到 1023 之间的数字值。因为微控制器的模拟数字转换器 （ADC） 编码为 10 位。LDR 传感器电路中的系列电阻器值为 330 Ω。</p></li><li><p>温度和湿度通过 DHT22 传感器测量。DHT22 内嵌有一个热电容器和电容湿度传感器，可测量温度和相对湿度。其温度范围为 -40 至 80 °C，准确度为 &lt; ±0.5°C，湿度范围为 0 至 100%，±2%（最大±5%）准确性。此传感器使用一根信号线将数据传输到 Arduino（数字引脚 2）和两根用于电源的电线。</p></li><li><p>光伏电压和电流通过电压分隔电路测量，该分频器也作为负载，由两个 10 Ohms 的系列电阻器组成。分频器电路输出与阿尔杜伊诺的模拟引脚 A4 相连。此外，连接到数字引脚 3 的 LED 在系统电路中反映了太阳能跟踪器（手动或自动）的模式状态。</p></li><li><p>Arduino Mega 与ATmega2560 微控制器用作嵌入式控制器，与阿尔杜伊诺以太网屏蔽以及监控平台交互。安装在 Arduino 板上方的以太网防护罩必须通过图 3 中显示的 RJ45 电缆与 Wi-Fi 路由器 （或 PC） 连接。以太网盾基于 Wiznet W5100 以太网芯片，该芯片为 TCP 和 UDP 协议提供了网络 （IP） 堆栈。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/image2_7PtCrbSgOy.png" alt="图3. arduino 和以太网扩展模块之间的硬件连接图。"></p></li></ul><h2 id="3-软件设计"><a href="#3-软件设计" class="headerlink" title="3 软件设计"></a>3 软件设计</h2><h3 id="3-1-Arduino-IDE"><a href="#3-1-Arduino-IDE" class="headerlink" title="3.1 Arduino IDE"></a>3.1 Arduino IDE</h3><p>Arduino 是一个开源电子原型平台，具有易于使用的硬件和软件。Arduino 平台提供集成开发环境 （IDE），其中包括对 C 和C++编程语言的支持。本作品中使用的 Arduino 板由 IDE 编程，该 IDE 充当代码编辑器，程序代码可以通过 USB 电缆上传到微控制器，如图 3 所示。Arduino 巨型板用于实现基于物联网的太阳能跟踪器的所有软件要求。</p><h3 id="3-2-myDevices-Cayenne-我的设备卡宴"><a href="#3-2-myDevices-Cayenne-我的设备卡宴" class="headerlink" title="3.2 myDevices Cayenne (我的设备卡宴)"></a>3.2 myDevices Cayenne (我的设备卡宴)</h3><ul><li>MyDevices 是一家提供完美的物联网解决方案的公司。它为 IoT 提供了端到端平台。在我们的项目中，我们将专注于卡宴，这是来自我的设备的解决方案之一。此工具允许开发人员、设计师和工程师构建物机原型。卡宴使用消息排队电信传输 （MQTT） 协议将任何设备与卡延内克云连接起来。连接后，用户可以通过创建的小部件将设备中的数据发送并接收到 Cayenne 仪表板。MQTT 是基于 TCP/IP 协议的发布订阅消息协议。发布订阅方法使用负责向客户端传递消息的消息代理。MQTT 是用于向卡宴云或卡宴控制的设备发送信息的 API。此连接中的消息代理是云，它管理发送和接收数据的不同客户端（传感器和执行器）。</li><li>要使用 MQTT 与卡宴， 我们需要使用卡宴库。对于阿尔杜伊诺，可以从 IDE 的图书馆经理安装卡延内MQTT 库。要对基于 Cayenne 物联网平台的物联网应用进行编程，我们将利用预先定义的功能。例如，为了建立 Cayenne 云和配备以太网模块的 Arduino Mega 之间的连接，我们调用 CayenneMQTT 以太网库，在那里我们声明我们的身份验证信息（用户名、密码和客户 ID），这些信息应从 Cayenne 仪表板获得。然后，在程序的设置部分，我们调用 <em>Cayenne.开始 （）</em>功能来建立与 Cayenne 仪表板的连接。对于每个执行器，我们创建一个功能，其整数参数在 0 到 31 之间，称为 <em>CAYENNE IN（虚拟通道）。</em>对于每个传感器，我们创建一个功能，其整数参数在 0 到 31 之间，称为<em>CAYENNE_OUT （VIRTUAL_CHANNEL）</em>。在程序的循环部分，我们称为预先定义的函数 <em>Cayenne.loop （），</em>该函数本身称为功能<em>CAYENNE_OUT</em>和<em>CAYENNE_IN。</em>虚拟通道，因为它的名称建议是一个通道，没有物理存在，它的特点是可视化或命令小部件。它允许它们与相应的传感器或执行器连接。</li></ul><h3 id="3-3-The-embedded-software-design-嵌入式软件设计"><a href="#3-3-The-embedded-software-design-嵌入式软件设计" class="headerlink" title="3.3 The embedded software design(嵌入式软件设计)"></a>3.3 The embedded software design(嵌入式软件设计)</h3><p>嵌入式软件将嵌入到 Arduino Mega 中，以便在以太网模块和 Cayenne 云之间进行交互（参见附录）。其设计如下：</p><h4 id="1-功能模式"><a href="#1-功能模式" class="headerlink" title="1 功能模式"></a>1 功能模式</h4><ul><li><p>基于物联网的太阳能跟踪器具有两种功能模式：手动和自动。在 Cayenne 仪表板中创建的按钮具有在两种模式之间切换的作用。非活动时，选择手动模式，否则自动模式。此外，在 Arduino 代码中还建立了一个功能，允许恢复按钮的状态。系统电路中的 LED 反映了此开关的状态。</p></li><li><p>因此，要使控制器了解所选的操作模式，我们只需要测试 LED 连接的引脚状态。例如，如果 LED 状态较低，控制器将调用手动模式功能执行，否则将调用自动功能。</p></li></ul><h4 id="2-手动模式"><a href="#2-手动模式" class="headerlink" title="2 手动模式"></a>2 手动模式</h4><ul><li><p>如果选择手动模式，用户可以直接控制伺服器的位置，通过 L-R 伺服器将光伏板从东向西定向，或通过 U-D 伺服器从南向北定向。该控制由物联网应用程序仪表板中服务器运动器的相关小部件组成。</p></li><li><p>在此模式下，控制器调用 <strong><em>Cayenne.loop（）</em></strong>功能，该函数本身调用所有<strong><em>功能CAYENNE_IN（</em></strong>包括与伺服器相关的功能）执行。 <strong>Cayenne.loop（）</strong>功能还将调用与传感器相连的所有功能CAYENNE_OUT执行。如果将与 LDR 传感器、光伏电流、电压和功率、温度和湿度相关的数据发送到服务器，以便在物联网应用程序中的相关小部件中可视化这些数据。</p></li></ul><h4 id="3-自动模式"><a href="#3-自动模式" class="headerlink" title="3 自动模式"></a>3 自动模式</h4><ul><li><p>如果选择自动模式，将执行图 4 中显示的算法。该算法首先阅读 LDR 传感器返回的模拟值。然后，它会处理这些数据以命令将光伏面板移向太阳位置的伺服运动器。考虑到基于垂直轴的太阳能跟踪器运动，比较了左侧两个LDR和右侧两个LDR的平均值，如果左侧接收到更多的光，光伏电池板将朝这个方向（顺时针方向）穿过L-R伺服器。当差额结果在 -10 和 10 之间时，后者将停止。此范围用于稳定控制器并降低伺服器的功耗。否则，如果正确的LDR集接收更多的光，光伏面板将朝这个方向移动（逆时针）通过L-R伺服器，并将继续旋转，直到差异结果在范围内[−10，10]。同一方法用于基于水平轴的太阳能跟踪器运动，比较顶部两个LDR和底部两个LDR的平均值。</p></li><li><p>除了在自动模式下，控制器还将调用 <strong><em>Cayenne.loop（）</em></strong>功能将太阳能跟踪器数据发送到 IoT 应用程序。</p></li></ul><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/image_3_pZv5s80gr2.png" alt="图4. 太阳能跟踪器自动模式的流程图。"></p><h3 id="3-4-Development-of-the-IoT-monitoring-application-开发-IoT-监控应用程序"><a href="#3-4-Development-of-the-IoT-monitoring-application-开发-IoT-监控应用程序" class="headerlink" title="3.4 Development of the IoT monitoring application(开发 IoT 监控应用程序)"></a>3.4 Development of the IoT monitoring application(开发 IoT 监控应用程序)</h3><h4 id="1-硬件与卡宴-IoT-平台的连接"><a href="#1-硬件与卡宴-IoT-平台的连接" class="headerlink" title="1 硬件与卡宴 IoT 平台的连接"></a>1 硬件与卡宴 IoT 平台的连接</h4><p>要将硬件（包括传感器和执行器）与物联网络平台对接，我们需要遵循以下步骤：</p><ul><li><p>创建帐户后登录卡宴我的Device网站（图5（a））。</p></li><li><p>然后，单击 Cayenne API 中的”自带东西”（图 5（b））。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig5_jaSC4EBHxI.png" alt="图5. 卡宴IoT平台注册（a）。卡宴API（b）。"></p></li><li><p>从克里特岛应用程序（图6）复制 MQTT 凭据（用户名、密码和客户 ID），并将其粘贴到 Arduino 源代码中，如前所述。在成功编译并上传整个代码到 Arduino Mega 后，在 Arduino IDE 中打开串行监视器以获取 Cayenne 日志打印（图 7）。一旦我们的设备上线并连接到 Cayenne，上一页（图 6）将自动更新，我们将在在线仪表板中看到我们的设备，如图 8 所见。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig6_qCu0wEtQwz.png" alt="图6. MQTT凭据和设备连接到卡宴。"></p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fige_yYB61wSOY4.png" alt="图7. 卡宴日志打印在串行监视器上。"></p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig8_lQi9h5PnKM.png" alt="图8. 设备设置。"></p></li><li><p>然后，要接口传感器和执行器，即创建其小部件，单击”添加新…”，选择”设备/小部件”，然后单击”自定义小部件”（图 9）。然后，选择小部件并填充相关设置（通道号必须与代码相同），最后单击”添加小部件”将其添加到设备的仪表板。对于我们来说，我们为所有传感器选择了”价值”小部件，为模式切换选择了”按钮”小部件，为伺服器选择了”滑块”小部件。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig9_0KAhjvvj5M.png" alt="图9. 卡宴自定义小部件。"></p></li></ul><p>最后，图10说明了用于监测太阳能跟踪器数据的设计物联网应用程序。与太阳跟踪器系统建立连接后，传感器数据可以在其相关部件上可视化，跟踪模式（自动或手动）可以从开关按钮中选择，并通过小部件控制伺服者的角度。还可以通过修改其设置中的表示类型或单击小部件上方的图形图标以图形形式获取传感器数据。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig10_Om7yhhrJcO.png" alt="图10. 太阳能跟踪系统的IoT监控应用。"></p><h4 id="2-警报创建"><a href="#2-警报创建" class="headerlink" title="2 警报创建"></a>2 警报创建</h4><p>监控系统中最重要的标准之一是，当发生与其监控设备相关的事件时，它能够发送通知警报通知用户。为此，我们利用 Cayenne 的一个功能为我们的物联网应用程序添加警报，在那里我们可以预先编程我们的应用程序以发送通知警报（短信、电子邮件或两者兼有）或执行指定操作。例如，创建温度警报，以便在监控温度达到阈值时向用户（或收件人）发送电子邮件通知，如图 11 所示。要创建警报，请单击”添加新。”然后选择”触发”，然后设置事件及其操作，最后单击”保存”将其添加到仪表板。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig11_HcTpIiwQOI.png" alt="图11. 温度警报设置。"></p><h2 id="4-原型设计"><a href="#4-原型设计" class="headerlink" title="4 原型设计"></a>4 原型设计</h2><p>图12展示了太阳能跟踪器原型在其分离和组装状态。它由光伏面板、R 和 U-D 伺服器和 LDR 传感器组成。该面板一侧连接到 U-Dservomotor，另一侧有轴承，以确保当太阳能跟踪器围绕水平轴旋转时更好的灵活性。装配连接到 L-R 伺服器。LDR 传感器固定在空心气缸内面板的四个角落。如果面板不垂直于太阳，则至少有一个 LDR 将被周围圆柱体造成的阴影覆盖。因此，光强度会有差异。最佳方向是当光的特性在所有LDR传感器中是相等的。图13显示了基于 IoT 的太阳能跟踪系统的整个原型，很明显，硬件部分中的所有报告组件都已用于构建它。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/solar_tracker_prototype_in_its_detached_and_assembled_state_zbScjRgUaK.png" alt="图12. 太阳能跟踪器原型处于组装和分离状态"></p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/iot_based_solar_tracker_prototype__PG9L9gMmwr.png" alt="图13. 基于IOT的太阳能跟踪器原型"></p><p>有关所获结果的更多详细信息，请参阅本链接中的论文： <a href="https://link.springer.com/chapter/10.1007%2F978-3-030-64565-6_4">https://link.springer.com/chapter/10.1007%2F978-3-030-64565-6_4</a></p><h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5 代码"></a>5 代码</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/***************************************************************</span><span class="hljs-comment"> PROJECT: IoT based solar tracker system / the embedded software</span><span class="hljs-comment"> Aboubakr El Hammoumi/ aboubakr.elhammoumi@usmba.ac.ma</span><span class="hljs-comment">***************************************************************/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CAYENNE_PRINT Serial</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;CayenneMQTTEthernet.h&gt;</span>    <span class="hljs-comment">//CayenneMQTT library </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Servo.h&gt;</span>                  <span class="hljs-comment">//Servo motor library </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;DHT.h&gt;</span>                    <span class="hljs-comment">//DHT library </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DHTTYPE DHT22</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DHTPIN 2</span><span class="hljs-function">DHT <span class="hljs-title">dht</span><span class="hljs-params">(DHTPIN,DHTTYPE)</span></span>;<span class="hljs-comment">//MQTT credentials   </span><span class="hljs-keyword">char</span> username[]=<span class="hljs-string">&quot;498d2d00-afe2-11ea-883c-638d8ce4c23d&quot;</span>;<span class="hljs-keyword">char</span> password[]=<span class="hljs-string">&quot;ab4a8f92d94033c01f6e18ce1d8a84d8c304c9c4&quot;</span>;<span class="hljs-keyword">char</span> clientID[]=<span class="hljs-string">&quot;17798a40-b968-11ea-93bf-d33a96695544&quot;</span>;Servo servo_x;                   <span class="hljs-comment">//up-down servomotor  </span><span class="hljs-keyword">int</span> servoh = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> servohLimitHigh = <span class="hljs-number">170</span>;     <span class="hljs-keyword">int</span> servohLimitLow = <span class="hljs-number">10</span>;       Servo servo_z;                   <span class="hljs-comment">//left-right servomotor </span><span class="hljs-keyword">int</span> servov = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> servovLimitHigh = <span class="hljs-number">170</span>;<span class="hljs-keyword">int</span> servovLimitLow = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> topl,topr,botl,botr;<span class="hljs-keyword">int</span> threshold_value=<span class="hljs-number">10</span>;        <span class="hljs-keyword">float</span> Vout;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123; Serial.begin(<span class="hljs-number">9600</span>);  Cayenne.begin(username, password, clientID);  servo_x.attach(<span class="hljs-number">5</span>);  servo_z.attach(<span class="hljs-number">6</span>);  dht.begin();  pinMode(<span class="hljs-number">3</span>,OUTPUT);  digitalWrite(<span class="hljs-number">3</span>,LOW); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123; topr= analogRead(A2);         topl= analogRead(A3);           botl= analogRead(A4);           botr= analogRead(A5);          Vout=(analogRead(A1) * <span class="hljs-number">5.0</span>) / <span class="hljs-number">1023</span>;  Serial.println(<span class="hljs-string">&quot; Manual-mode&quot;</span>);  Cayenne.loop();    <span class="hljs-keyword">if</span> (digitalRead(<span class="hljs-number">3</span>)==HIGH)&#123;    Serial.println(<span class="hljs-string">&quot; Automatic-mode&quot;</span>);    servoh = servo_x.read();    servov = servo_z.read();    <span class="hljs-keyword">int</span> avgtop = (topr + topl) / <span class="hljs-number">2</span>;         <span class="hljs-keyword">int</span> avgbot = (botr + botl) / <span class="hljs-number">2</span>;       <span class="hljs-keyword">int</span> avgright = (topr + botr) / <span class="hljs-number">2</span>;       <span class="hljs-keyword">int</span> avgleft = (topl + botl) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> diffhori= avgtop - avgbot;          <span class="hljs-keyword">int</span> diffverti= avgleft - avgright;            <span class="hljs-comment">/*tracking according to horizontal axis*/</span>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(diffhori) &lt;= threshold_value)    &#123;     servo_x.write(servoh);            <span class="hljs-comment">//stop the servo up-down</span>    &#125;<span class="hljs-keyword">else</span> &#123;       <span class="hljs-keyword">if</span> (diffhori &gt; threshold_value)          &#123; Serial.println(<span class="hljs-string">&quot; x - 2 &quot;</span>);          servo_x.write(servoh <span class="hljs-number">-2</span>);    <span class="hljs-comment">//Clockwise rotation CW</span>          <span class="hljs-keyword">if</span> (servoh &gt; servohLimitHigh)          &#123;           servoh = servohLimitHigh;          &#125;          delay(<span class="hljs-number">10</span>);          &#125;<span class="hljs-keyword">else</span> &#123;           servo_x.write(servoh +<span class="hljs-number">2</span>);   <span class="hljs-comment">//CCW</span>           <span class="hljs-keyword">if</span> (servoh &lt; servohLimitLow)           &#123;           servoh = servohLimitLow;           &#125;           delay(<span class="hljs-number">10</span>);           &#125;      &#125;          <span class="hljs-comment">/*tracking according to vertical axis*/</span>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(diffverti) &lt;= threshold_value)    &#123;          servo_z.write(servov);       <span class="hljs-comment">//stop the servo left-right</span>    &#125;<span class="hljs-keyword">else</span>&#123;       <span class="hljs-keyword">if</span> (diffverti &gt; threshold_value)       &#123;        servo_z.write(servov <span class="hljs-number">-2</span>);  <span class="hljs-comment">//CW</span>       <span class="hljs-keyword">if</span> (servov &gt; servovLimitHigh)        &#123;        servov = servovLimitHigh;       &#125;       delay(<span class="hljs-number">10</span>);       &#125;<span class="hljs-keyword">else</span>&#123;         servo_z.write(servov +<span class="hljs-number">2</span>);  <span class="hljs-comment">//CCW</span>        <span class="hljs-keyword">if</span> (servov &lt; servovLimitLow)         &#123;        servov = servovLimitLow;        &#125;        delay(<span class="hljs-number">10</span>);        &#125;     &#125;  &#125;&#125;<span class="hljs-comment">// Cayenne Functions</span>CAYENNE_IN(<span class="hljs-number">8</span>)&#123;  <span class="hljs-keyword">int</span> value = getValue.asInt();  CAYENNE_LOG(<span class="hljs-string">&quot;Channel %d, pin %d, value %d&quot;</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, value);  digitalWrite(<span class="hljs-number">3</span>,value);&#125;CAYENNE_IN(<span class="hljs-number">7</span>)&#123; <span class="hljs-comment">//up-down servo motor</span>  <span class="hljs-keyword">if</span> (digitalRead(<span class="hljs-number">3</span>)==HIGH)&#123; <span class="hljs-comment">//Automatic_mode</span>  &#125;  <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//Manual_mode</span>  servo_x.write(getValue.asDouble() * <span class="hljs-number">180</span>);  &#125;&#125;CAYENNE_IN(<span class="hljs-number">6</span>)&#123; <span class="hljs-comment">//left-right servo motor</span>  <span class="hljs-keyword">if</span> (digitalRead(<span class="hljs-number">3</span>)==HIGH)&#123;  &#125;    <span class="hljs-keyword">else</span>&#123;  servo_z.write(getValue.asDouble() * <span class="hljs-number">180</span>);  &#125;&#125;CAYENNE_OUT(<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//Current</span>  <span class="hljs-keyword">float</span> current = Vout/<span class="hljs-number">10</span>;  Cayenne.virtualWrite(<span class="hljs-number">0</span>, current);  Serial.print(<span class="hljs-string">&quot;Current: &quot;</span>);  Serial.println(current);&#125;CAYENNE_OUT(<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//Voltage</span>  <span class="hljs-keyword">float</span> voltage = Vout * <span class="hljs-number">2</span>;  Cayenne.virtualWrite(<span class="hljs-number">1</span>, voltage);  Serial.print(<span class="hljs-string">&quot;Voltage: &quot;</span>);  Serial.println(voltage);&#125;CAYENNE_OUT(<span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//LDR Top-right</span>  Cayenne.virtualWrite(<span class="hljs-number">2</span>, topr);&#125;CAYENNE_OUT(<span class="hljs-number">3</span>)&#123; <span class="hljs-comment">//LDR Top-left</span>  Cayenne.virtualWrite(<span class="hljs-number">3</span>,topl);&#125;CAYENNE_OUT(<span class="hljs-number">4</span>)&#123; <span class="hljs-comment">//LDR Bot-left</span>  Cayenne.virtualWrite(<span class="hljs-number">4</span>,botl);&#125;CAYENNE_OUT(<span class="hljs-number">5</span>)&#123; <span class="hljs-comment">//LDR Bot-right</span>  Cayenne.virtualWrite(<span class="hljs-number">5</span>,botr);&#125;CAYENNE_OUT(<span class="hljs-number">10</span>) &#123; <span class="hljs-comment">//Power</span>  <span class="hljs-keyword">float</span> power = (Vout * <span class="hljs-number">2</span> * Vout)/<span class="hljs-number">10</span> ;  Cayenne.virtualWrite(<span class="hljs-number">10</span>, power);  Serial.print(<span class="hljs-string">&quot;Power: &quot;</span>);  Serial.println(power);&#125;CAYENNE_OUT(<span class="hljs-number">11</span>)&#123; <span class="hljs-comment">//Temperature</span>  <span class="hljs-keyword">float</span> t = dht.readTemperature();  <span class="hljs-comment">//int chk = dht.read(DHT11PIN);</span>  Cayenne.virtualWrite(<span class="hljs-number">11</span>, t, TYPE_TEMPERATURE, UNIT_CELSIUS);  Serial.print(<span class="hljs-string">&quot;temperature: &quot;</span>);  Serial.println(t);&#125;CAYENNE_OUT(<span class="hljs-number">12</span>)&#123; <span class="hljs-comment">//Huidity</span>  <span class="hljs-keyword">float</span> h = dht.readHumidity();  <span class="hljs-comment">//int chk = dht.read(DHT11PIN);</span>  Cayenne.virtualWrite(<span class="hljs-number">12</span>, h);  Serial.print(<span class="hljs-string">&quot;  humidity: &quot;</span>);  Serial.println(h);&#125;</code></pre></div><h2 id="6-发展示例"><a href="#6-发展示例" class="headerlink" title="6 发展示例"></a>6 发展示例</h2><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/img_3581_XDaDENY3ax.JPG" alt="太阳能电池板太阳跟踪器 - 手机充电器"></p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/image-20210607020629991.png" alt="巨型太阳能跟踪器"></p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Hardware/">Hardware</category>
      
      
      <category domain="https://pncalbl.github.io/tags/IoT/">IoT</category>
      
      <category domain="https://pncalbl.github.io/tags/%E5%A4%AA%E9%98%B3%E8%83%BD/">太阳能</category>
      
      
      <comments>https://pncalbl.github.io/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ElasticSearch 学习</title>
      <link>https://pncalbl.github.io/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Mon, 24 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;ElasticSearch-学习&quot;&gt;&lt;a href=&quot;#ElasticSearch-学习&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch 学习&quot;&gt;&lt;/a&gt;ElasticSearch 学习&lt;/h1&gt;&lt;h2 id=&quot;0-聊聊DougC</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="ElasticSearch-学习"><a href="#ElasticSearch-学习" class="headerlink" title="ElasticSearch 学习"></a>ElasticSearch 学习</h1><h2 id="0-聊聊DougCutting"><a href="#0-聊聊DougCutting" class="headerlink" title="0 聊聊DougCutting"></a>0 聊聊DougCutting</h2><p>为什么要讲这个人,后面要聊大数据</p><blockquote><p>  本故事内容来自公众号：新枣课堂</p></blockquote><p>1998年9月4号,google公司在美国硅谷成立.正如大家所知,它是一家搜索引擎起家的公司</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610550313.png" alt></p><p>无独有偶,一位名叫DougCutting的美国工程师,也迷上了搜索引擎.他做了一个用于文本搜索的函数库(姑且理解为软件的功能组件),命名为Lucene.</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610568104.png" alt></p><p>Lucene使用Java写的,目标是为各种中小型应用软件加入全文检索功能.因为好用而且开源(代码公开),非常受程序员们稀罕)</p><p>在这个过程中,google确实找到了不少好的办法,并且无私地分享了出来.</p><p>开源是一种精神!</p><p>2003年,google发表了一篇技术学术论文,公开介绍了自己的谷歌文件系统GFS(google File System).这是google公司为了存储海量搜素数据而设计的专用文件系统</p><p>第二年,2004年,Doug Cutting基于google的GFS论文,实现了分布式文件存储系统,并将它命名为NDFS(Nutch Distributed File System)</p><p>还是2004年,google又发表了一篇技术学术论文,介绍自己的MapReduce编程模型.这个编程模型,用于大规模数据集(大于1TB)的并行分析运算.</p><p>2005年,Doug Cutting 又基于MapReduce,在Nutch搜索引擎实现了该功能.</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610581999.png" alt></p><p>2006年,当时依然很厉害的Yahoo(雅虎)公司,招安了Doug Cutting</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610607769.png" alt></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610720399.png" alt></p><p>我们继续往下说.</p><p>还是2006年,google有发表论文了</p><p>这次,他们介绍自己的BigTable,这是一种分布式的数据存储系统,一种用来处理海量数据的非关系型数据库.</p><p>Doug Cutting 当然没有放过,在自己的hadoop系统里面,引入了BigTable,并命名为HBase.</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610829469.png" alt></p><p>好吧,反正就是紧跟Google时代步伐,你出什么,我学什么</p><p>所有,Hadoop的核心部分,基本上都有Google的影子.</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610891867.png" alt></p><p>2008年1月,Hadoop成功上位,成为Apache基金会的顶级项目.</p><p>同年2月,Yahoo宣布建成了一个拥有1W个内核的Hadoop集群,并将自己的搜索引擎产品部署在上面.</p><p>7月,Hadoop打破世界纪录,成为最快排序1TB数据的系统,用时209秒.</p><h2 id="1-什么是Elasticsearch？"><a href="#1-什么是Elasticsearch？" class="headerlink" title="1 什么是Elasticsearch？"></a>1 什么是Elasticsearch？</h2><h3 id="1-1-Lucene简介"><a href="#1-1-Lucene简介" class="headerlink" title="1.1 Lucene简介"></a>1.1 Lucene简介</h3><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/lucene_logo_green_300.png" alt="Lucene Logo"></p><ul><li>Lucene是一套用于<strong>全文检索</strong>和<strong>搜寻</strong>的<strong>开源</strong>程序库，由Apache软件基金会支持和提供</li><li>Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放源代码工具</li><li>Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品</li><li>Lucene是一套信息检索工具包! jar包!不包含搜索引擎系统!<ul><li>Lucene包含:索引结构!读写索引的工具!排序,搜索规则…工具类!等</li></ul></li><li><strong>Lucene和ElasticSearch关系</strong>:<ul><li>简单来说，ElasticSearch是基于Lucene做了一些<strong>封装</strong>和*<em>增强 *</em></li></ul></li></ul><h3 id="1-2-ElasticSearch简介"><a href="#1-2-ElasticSearch简介" class="headerlink" title="1.2 ElasticSearch简介"></a>1.2 ElasticSearch简介</h3><ul><li><p>ElasticSearch是一个<strong>实时分布式搜索和分析引擎</strong>。它让你以前所未有的速度处理大数据成为可能。</p></li><li><p>它用于<strong>全文搜索、结构化搜索、分析</strong>以及将这三者混合使用:</p><ul><li>维基百科使用Elasticsearch提供<strong>全文搜索并高亮关键字</strong> ,以及<strong>输入实时搜索(search-asyou-type)</strong>和<strong>搜索纠错(did-you-mean)</strong>等搜索建议功能。</li><li>英国卫报使用Elasticsearch结合用户日志和社交网络数据提供给他们的编辑以<strong>实时的反馈</strong>,以便及时了解公众对新发表的文章的回应。</li><li>StackOverflow结合<strong>全文搜索</strong>与<strong>地理位置查询</strong>,以及more-like-this功能来找到相关的问题和答案。</li><li>Github使用Elasticsearch检索<strong>1300亿</strong>行的代码。</li></ul></li><li><p>并且Elasticsearch不仅用于大型企业,它还让像DataDog以及Klout这样的创业公司将最初的想法变成可扩展的解决方案。</p></li><li><p>Elasticsearch可以在你的笔记本。上运行，也可以在数以百计的服务器上<strong>处理PB级别的数据</strong>。</p></li><li><p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。 无论在开源还是专有领域, Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p></li><li><p>但是, Lucene只是一个库。想要使用它,你必须使用Java来作为开发语言并将其直接集成到你的应用中,更糟糕的是, Lucene非常复杂,你需要深入了解检索的相关知识来理解它是如何工作的。</p></li><li><p>Elasticsearch也使用<strong>Java</strong>开发并使用Lucene作为其核心来实现所有索引和搜索的功能,它的目的是通过简单的<strong>RESTful API</strong>（REST风格的网络接口，是当下主流的API）来隐藏Lucene的复杂性,从而让全文搜索变得简单。</p></li></ul><h3 id="1-3-ElasticSearch的应用场景"><a href="#1-3-ElasticSearch的应用场景" class="headerlink" title="1.3 ElasticSearch的应用场景"></a>1.3 ElasticSearch的应用场景</h3><ul><li><p>维基百科,类似百度百科,<strong>全文检索</strong>,<strong>高亮</strong>,<strong>搜索推荐</strong></p></li><li><p>The Guardian (国外新闻网站) , 类似搜狐新闻,用户行为日志(点击,浏览,收藏,评论) +社交网络数据(对某某新闻的相关看法) ,数据分析,给到每篇新闻文章的作者,让他知道他的文章的公众反馈</p></li><li><p>Stack Overflow (国外的程序异常讨论论坛) , IT问题,程序的报错, 提交上去,有人会跟你讨论和回答,全文检索,搜索相关问题和答案,程序报错了,就会将报错信息粘贴到里面去,搜索有没有对应的答案</p></li><li><p>GitHub (开源代码管理)</p></li><li><p>电商网站,<strong>检索商品</strong>.</p></li><li><p>日志数据分析, logstash采集日志, ES进行复杂的数据分析, <strong>ELK技术, elasticsearch（搜索）+logstash（过滤）+kibana（可视化分析）</strong></p></li><li><p>商品价格监控网站,用户设定某商品的价格阈值,当低于该阈值的时候,发送通知消息给用户,比如说订阅牙膏的监控：如果高露洁牙膏的家庭套装低于50块钱,就通知我,我就去买</p></li><li><p>BI系统 ,商业智能, Business Intelligence.比如说有个大型商场集团, BI分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成,产出相关的数张报表, 最近3年,每年消费金额呈现100%的增长,而且用户群体85%是高级白领。</p></li><li><p>国内:<strong>站内搜索</strong>(电商，招聘，门户，等等)，<strong>IT系统搜索</strong>(OA,CRM,ERP，等等)，<strong>数据分析</strong>(ES热门的一个使用场景)</p></li></ul><p>总而言之，Elasticsearch就是提供<strong>高效</strong>、<strong>个性化检索</strong>需求的一种解决方案</p><h3 id="1-4-ELK简介"><a href="#1-4-ELK简介" class="headerlink" title="1.4 ELK简介"></a>1.4 ELK简介</h3><ul><li><p>ELK是<strong>Elasticsearch、Logstash、Kibana</strong>三大开源框架首字母大写简称。市面上也被成为Elastic Stack。</p><ul><li>其中ElasticSearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架,可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为es.</li><li>Logstash是ELK的<strong>中央数据流引擎</strong>,用于<strong>从不同目标</strong>(文件/数据存储/MQ )<strong>收集的不同格式数据</strong>,经过过滤后支持输出以到不同目的地(文件/MQ/redis/elasticsearch/kafka等)。</li><li>Kibana可以将es的<strong>数据</strong>通过友好的页面<strong>展示</strong>出来 ,提供实时分析的功能。</li></ul></li><li><p>总结一下就是：<strong>收集清洗数据–&gt;建立索引，储存–&gt;Kibana分析</strong></p></li><li><p>市面上很多开发只要提到ELK能够一致说出它是一 个日志分析架构技术栈总称,但实际上ELK不仅仅适用于日志分析,它还可以<strong>支持其它任何数据分析和收集的场景</strong>,日志分析和收集只是更具有代表性，并非唯一性。</p></li></ul><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105031.png" alt></p><h2 id="2-其他搜索引擎"><a href="#2-其他搜索引擎" class="headerlink" title="2 其他搜索引擎"></a>2 其他搜索引擎</h2><h3 id="2-1-Solr简介"><a href="#2-1-Solr简介" class="headerlink" title="2.1 Solr简介"></a>2.1 Solr简介</h3><ul><li><p>Solr是Apache下的一个顶级开源项目,采用java开发,它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言,同时实现了可配置、可扩展，并对索引、搜索性能进行了优化</p></li><li><p>Solr可以独立运行在Jetty、Tomcat等这些Servlet容器中 , Solr索引的实现方法很简单,用POST方法向Solr服务器发送一个描述Field及其内容的XML文档，Solr根据xml文档添加、删除、更新索引。</p></li><li><p>列如：搜索name==dayceng&lt;&gt;</p><ul><li>Solr 搜索只需要发送HTTP GET请求,然后对Solr返回xml、<strong>json</strong>等格式的查询结果进行解析,组织页面布局。Solr不提供构建UI的功能, Solr提供了一个管理界面,通过管理界面可以查询Solr的配置和运行情况。</li></ul></li><li><p>solr是基于lucene开发企业级搜索服务器,实际上就是封装了lucene.</p></li><li><p>Solr是一个独立的企业级搜索应用服务器,它对外提供类似于Web-service的API接口。用户可以通过http请求,向搜索引擎服务器提交一定格式的文件,生成索引;也可以通过提出查找请求,并得到返回结果。</p></li></ul><h3 id="2-2-ES与Solr对比"><a href="#2-2-ES与Solr对比" class="headerlink" title="2.2 ES与Solr对比"></a>2.2 ES与Solr对比</h3><ul><li><p>单纯地对已有的数据进行搜索，Solr更快</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105035.png" alt></p></li><li><p>当建立<strong>实时索引</strong>时，Solr会产生IO阻塞，查询性能较差，此时ES具有明显优势</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105045.png" alt></p></li><li><p>随着搜索量的增加，Solr的劣势愈发明显，ES无明显变化</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105121.png" alt></p></li><li><p><strong>总结</strong></p><ul><li>ES基本是开箱即用，非常简单。Solr安装略微复杂</li><li>Solr 利用Zookeeper进行分布式管理，而Elasticsearch 自身带有分布式协调管理功能。</li><li>Solr 支持更多格式的数据，比如JSON、XML、 CSV ，而Elasticsearch仅支持JSON文件格式。</li><li>Solr 官方提供的功能更多，而Elasticsearch本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要kibana友好支撑</li><li>Solr 查询快，但更新索引时慢(即插入删除慢) ，用于电商等查询多的应用;<ul><li>ES建立索引快(即查询慢) ，即<strong>实时性查询快</strong>，用于facebook新浪等搜索。</li><li>Solr是传统搜索应用的有力解决方案，但Elasticsearch 更适用于新兴的实时搜索应用。</li></ul></li><li>Solr比较成熟，有一个更大，更成熟的用户、开发和贡献者社区,而Elasticsearch相对开发维护者较少，更新太快,<strong>学习使用成本较高</strong></li></ul></li></ul><h2 id="3-Elasticsearch安装"><a href="#3-Elasticsearch安装" class="headerlink" title="3 Elasticsearch安装"></a>3 Elasticsearch安装</h2><p>注意：java版本至少为JDK1.8或以上</p><p>Java开发,elasticsearch的版本和我们之后对应的Java的核心jar包! 版本对应! JDK环境是正常的</p><p>这里一定要保证</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596614089583.png" alt></p><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p>下载：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>windows下解压即可使用</p><h3 id="3-2-Elasticsearch目录介绍"><a href="#3-2-Elasticsearch目录介绍" class="headerlink" title="3.2 Elasticsearch目录介绍"></a>3.2 Elasticsearch目录介绍</h3><ul><li>bin 相关启动文件</li><li>config 配置文件</li><li>log4j2.properties 日志配置文件</li><li>jvm.options java虚拟机配置文件</li><li>elasticsearch.yml ES配置文件（默认端口：9200，这里在tpot中，docker默认分配的是1111，需要再映射到9200才行）</li><li>lib 相关jar包</li><li>logs 日志</li><li>modules 功能模块</li><li>plugins 插件</li></ul><h3 id="3-3-启动"><a href="#3-3-启动" class="headerlink" title="3.3 启动"></a>3.3 启动</h3><p>双击bin下的<strong>elasticsearch.bat</strong>即可</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105122.png" alt></p><h3 id="3-4-测试访问"><a href="#3-4-测试访问" class="headerlink" title="3.4 测试访问"></a>3.4 测试访问</h3><p>访问其暴露的端口进行验证（<a href="http://127.0.0.1:9200/）">http://127.0.0.1:9200/）</a></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105123.png" alt></p><h3 id="3-5-安装可视化界面Elasticsearch-head"><a href="#3-5-安装可视化界面Elasticsearch-head" class="headerlink" title="3.5 安装可视化界面Elasticsearch-head"></a>3.5 安装可视化界面Elasticsearch-head</h3><p>1、请下载Node.js（<a href="https://nodejs.org/en/），并检查npm为较新的版本">https://nodejs.org/en/），并检查npm为较新的版本</a></p><p>2、安装npm淘宝镜像源（cnpm）</p><blockquote><p>  npm install -g cnpm <em>–registry=<a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></em></p></blockquote><p> 查看是否安装成功</p><blockquote><p>  cnpm -v</p></blockquote><p> 出现以下信息即可</p><blockquote><p>  C:\Users\XXXX&gt; cnpm -v</p><p>  <a href="mailto:cnpm@5.1.1">cnpm@5.1.1</a> (F:\Live\NODE\node_global\node_modules\cnpm\lib\parse_argv.js)<br>  <a href="mailto:npm@5.6.0">npm@5.6.0</a> (F:\Live\NODE\node_global\node_modules\cnpm\node_modules\npm\lib\npm.js)<br>  <a href="mailto:node@8.9.1">node@8.9.1</a> (F:\Live\NODE\node.exe)<br>  <a href="mailto:npminstall@3.2.1">npminstall@3.2.1</a> (F:\Live\NODE\node_global\node_modules\cnpm\node_modules\npminstall\lib\index.js)<br>  prefix=F:\Live\NODE\node_global<br>  win32 x64 10.0.16299<br>  registry=<a href="http://registry.npm.taobao.org">http://registry.npm.taobao.org</a></p></blockquote><p><strong>在ElasticSearch\elasticsearch-head-master即ES head目录下</strong></p><p> <strong>下载依赖</strong></p><blockquote><p>  cnpm install</p></blockquote><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105124.png" alt="image-20210131091020099"></p><p> <strong>运行</strong></p><blockquote><p>  npm run start</p></blockquote><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20210609005919167.png" alt></p><p> <strong>访问<a href="http://localhost:9100/">http://localhost:9100/</a></strong></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105126.png" alt="image-20210131091312021"></p><p> <strong>此时因为跨域访问（跨端口）导致集群无法连接，要通过配置elasticsearch.yml来解决</strong></p><h3 id="3-6-解决跨域问题"><a href="#3-6-解决跨域问题" class="headerlink" title="3.6 解决跨域问题"></a>3.6 解决跨域问题</h3><p>配置es，打开elasticsearch.yml文件，在最后一行加入（注意yalm语法，冒号后要加一个空格）</p><blockquote><p>  http.cors.enabled: true<br>  http.cors.allow-origin: “*”</p></blockquote><p>使用elasticsearch.bat重启es，连接成功</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105127.png" alt="image-20210131092227531"></p><p>注1：Linux下可能会因为进程问题启动失败</p><p><em>#查看elastic的进程号 并杀死</em></p><div class="code-wrapper"><pre><code class="hljs perl">ps aux | <span class="hljs-keyword">grep</span> elasticsearch <span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span> 进程号</code></pre></div><p><em>#重启 -d 后台运行</em></p><div class="code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>elasticsearch -d</code></pre></div><p>注2：Linux下eshead启动失败，提示9100端口占用</p><p><em>#查看占用端口的进程id</em></p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">lsof</span> -i:<span class="hljs-number">9100</span></code></pre></div><p><em>#杀死进行</em></p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> -<span class="hljs-number">9</span> <span class="hljs-number">4852</span></code></pre></div><h2 id="4-Kibana安装"><a href="#4-Kibana安装" class="headerlink" title="4 Kibana安装"></a>4 Kibana安装</h2><p>Kibana是一个针对Elasticsearch的开源分析及可视化平台 ，用来搜索、查看交互存储在Elasticsearch索引中的数据。 使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板( dashboard )实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。</p><p>官网：<a href="https://www.elastic.co/cn/kibana">https://www.elastic.co/cn/kibana</a></p><p>注意：<strong>使用的ES版本要与Kibana的对应</strong></p><p>下载完成解压，双击kibana.bat启动即可</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105128.png" alt="image-20210131103309389"></p><p><strong>汉化</strong></p><p>在Kibana目录下的config中修改Kibana.yml文件，最后一行加上</p><blockquote><p>  i18n.locale: “zh-CN”</p></blockquote><p>重启即可</p><h2 id="5-ES核心概念"><a href="#5-ES核心概念" class="headerlink" title="5 ES核心概念"></a>5 ES核心概念</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>Elasticsearch是面向文档的一种数据库，这意味着其不再需要行列式的表格字段约束。</p><p>ES会存储整个构造好的数据或文档，然而不仅仅是储存数据，这使得文档中每个数据可以被标识，进而可以被检索。在ES中，执行index，search，sort或过滤文档等操作都不是传统意义上的行列式的数据。</p><p>ES从根本上对数据的不同思考方式也正是他能应对复杂数据结构的全文检索的原因之一。</p><p><strong>关系型数据库与Elasticsearch的对比</strong></p><p>以下数据格式均为JSON</p><table><thead><tr><th>Relational DB</th><th>Elasticsearch</th></tr></thead><tbody><tr><td>数据库（database）</td><td>索引（index）</td></tr><tr><td>表（tables）</td><td>类型（types，新版本中逐步弃用）</td></tr><tr><td>行（rows）</td><td>文档（documents）</td></tr><tr><td>字段（columns）</td><td>字段（file）</td></tr></tbody></table><p>Elasticsearch(一般为集群)中可以包含多个索引（对应数据库) ，每个索引中可以包含多个类型(对应表) ，每个类型下又包含多个文档(对应行)，每个文档中又包含多个字段(对应列)。</p><p><strong>物理设计</strong>:<br>Elasticsearch在后台<strong>把每个索引划分成多个分片</strong>,每分分片可以在集群中的不同服务器间迁移（方便集群的搭建）</p><p>实际上只建立一个索引它自己也是一个集群，默认名称就是elasticsearch</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105129.png" alt="image-20210202093954072"></p><p><strong>逻辑设计:</strong><br>一个索引类型中，包含多个文档，如文档1 ,文档2。</p><p>当我们索引一篇文档时，可以通过这样的一个顺序找到它:</p><p> 索引–&gt;类型–&gt;文档ID</p><p>通过这个组合我们就能索引到某个具体的文档。</p><p>（注:ID不必是整数,实际上它是个字符串。）</p><h3 id="5-2-文档"><a href="#5-2-文档" class="headerlink" title="5.2 文档"></a>5.2 文档</h3><p>Elasticsearch是面向文档的,那么就意味着索引和搜索数据的<strong>最小单位是文档</strong>, Elasticsearch中,文档有几个重要属性:</p><ul><li><p>自我包含，一篇文档同时包含字段和对应的值,也就是同时包含key:value</p></li><li><p>可以是层次型的，一个文档中包含着文档，复杂的逻辑实体就是这么来的（即文档就是JSON格式的对象，可用fastjson进行自动转换自动）</p></li><li><p>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在Elasticsearch中，对于字段是非常灵活的，有时候我们可以忽略该字段，或者动态的添加一个新的字段。</p></li></ul><p>我们可以随意的新增或者忽略某个字段，但每个字段的类型非常重要。比如一个年龄字段类型，可以是字符串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型,这也是为什么在elasticsearch中，类型有时候也称为<strong>映射类型</strong></p><p>文档就是<strong>一条条打好标签的数据</strong></p><p><strong>举个例子：</strong></p><blockquote><p>  user</p><p>  1 xiaoming 22</p><p>  2 liming 19</p><p>  。。。</p></blockquote><p>这是一个表，名称为user，里面的每一行就是一个文档，文档中包含着序号、名字、年龄等信息（有点像之前要使用TFIDF算法时做的那个设备文档）</p><h3 id="5-3-类型"><a href="#5-3-类型" class="headerlink" title="5.3 类型"></a>5.3 类型</h3><p>类型是文档的<strong>逻辑容器</strong>，就像关系型数据库一样，表格是行的容器。</p><p>类型中对于字段的定义称为<strong>映射</strong>，比如name可以映射为字符串类型。</p><p>我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段。那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18 ,那么elasticsearch会认为它是整形。</p><p>但是elasticsearch也可能猜不对 ，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用</p><p>类比MySQL中，建立一个表的时候需要设定的数据类型</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105130.png" alt="image-20210202095941630"></p><h3 id="5-4-索引"><a href="#5-4-索引" class="headerlink" title="5.4 索引"></a>5.4 索引</h3><p>索引是<strong>映射类型的容器</strong>， elasticsearch中的索引是一个非常大的文档集合（即数据库）。索引存储了映射类型的字段和其他设置。 然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的。</p><p><strong>物理设计: 节点和分片如何工作</strong></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105131.png" alt="image-20210202100254208"></p><p>存在数据库的数据可以通过不同的分片放在不同的集群上</p><p>一个集群至少有一个节点，而一个节点就是一个elasricsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片( primary shard ,又称<strong>主分片</strong>)构成，每一个主分片会有一个副本( replica shard ,又称<strong>复制分片</strong>)</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105132.png" alt="image-20210202100505894"></p><p>上图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内（比如主分片P0和主分片的复制分片P1分别在节点1/3，同样的分片Px在每个至少有一个），当某个节点挂掉了，数据也不至于丢失。</p><p>实际上，一个分片是一个Lucene索引，一个包含<strong>倒排索引</strong>的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。什么是倒排索引？</p><h3 id="5-5-倒排索引"><a href="#5-5-倒排索引" class="headerlink" title="5.5 倒排索引"></a>5.5 倒排索引</h3><p>elasticsearch使用的是一种称为倒排索引的结构 ,采用<strong>Lucene倒排索引</strong>作为底层。这种结构适用于快速的全文搜索，一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。</p><p>例如，现在有两个文档，每个文档包含如下内容:</p><blockquote><p>  study every day, good good up to forever #文档1包含的内容<br>  To forever, study every day， good good up #文档2包含的内容</p></blockquote><p>为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens) ，然后创建一个包含所有不重复的词条的排序列表，然后列出每个词条出现在哪个文档:（大小写要区分，重复单词也要加入）</p><table><thead><tr><th>term</th><th>doc_1</th><th>doc_2</th></tr></thead><tbody><tr><td>Study</td><td>〇</td><td>X</td></tr><tr><td>To</td><td>X</td><td>X</td></tr><tr><td>forever</td><td>〇</td><td>〇</td></tr><tr><td>every</td><td>〇</td><td>〇</td></tr><tr><td>study</td><td>X</td><td>〇</td></tr><tr><td>day</td><td>〇</td><td>〇</td></tr><tr><td>good</td><td>〇</td><td>〇</td></tr><tr><td>up</td><td>〇</td><td>〇</td></tr><tr><td>to</td><td>〇</td><td>X</td></tr><tr><td>every</td><td>〇</td><td>〇</td></tr></tbody></table><p>现在，我们试图搜索to forever，只需要查看每个词条在对应文档是否出现即可。这里to和forever在doc1里面都有，而doc2中to没有，所以搜索结果为：doc1的<strong>权重</strong>更大，即“to forever”更可能出现在doc1</p><table><thead><tr><th>term</th><th>doc_1</th><th>doc_2</th></tr></thead><tbody><tr><td>to</td><td>〇</td><td>X</td></tr><tr><td>forever</td><td>〇</td><td>〇</td></tr><tr><td>SUM</td><td>2</td><td>1</td></tr></tbody></table><p>这里的“权重”，即为文档的<strong>score</strong>，es搜索完成会对分数进行自动统计</p><p>两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，这两个包含关键字的文档都将返回。</p><p><strong>再举一个例子</strong></p><p>再来看一个示例比如我们通过博客标签来搜索博客文章。 那么倒排索引列表就是这样的一个结构:</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105133.png" alt="image-20210202111236177"></p><p>如果要搜索含有python标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要查看标签这一栏,然后获取相关的文章ID即可。比如这里搜索“Linux”就绝对不会出现1或者2</p><p><strong>elasticsearch的索引和Lucene的索引对比</strong></p><p>在elasticsearch中，索引（数据库）这个词被频繁使用。在elasticsearch中 ，索引被分为多个分片，每份分片是一个Lucene的索引。<strong>所以一个elasticsearch索引是由多个Lucene倒排索引组成的</strong>。（因为elasticsearch使用Lucene作为底层）</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105134.png" alt="image-20210202112920334"></p><p>如无特指，说起<strong>索引都是指elasticsearch的索引</strong>。</p><h2 id="6-IK分词器"><a href="#6-IK分词器" class="headerlink" title="6 IK分词器"></a>6 IK分词器</h2><h3 id="6-1-什么是IK分词器"><a href="#6-1-什么是IK分词器" class="headerlink" title="6.1 什么是IK分词器?"></a>6.1 <strong>什么是IK分词器?</strong></h3><p> <strong>分词</strong>:即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，比如“我爱黎明”会被分为”我”,”爱”,”“黎”,”明” 。这显然是不符合要求的，所以我们需要安装中文分词器IK来解决这个问题。</p><p>IK提供了两个分词算法: ik. smart和ik_max_ word</p><p>其中ik_smart为最少切分， ik _max_word为最细粒度划分</p><h3 id="6-2-安装-IK分词器"><a href="#6-2-安装-IK分词器" class="headerlink" title="6.2 安装 IK分词器"></a>6.2 安装 IK分词器</h3><p><strong>1、下载</strong></p><blockquote><p>  <a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p></blockquote><p><strong>2、安装</strong></p><p>解压后放入es的插件目录plugins下即可</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105135.png" alt="image-20210202144827745"></p><p><strong>3、重启es加载插件</strong></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105136.png" alt="image-20210202145019120"></p><p>可使用以下命令查看插件列表</p><blockquote><p>  elasticsearch-plugin list</p></blockquote><p><strong>4、启动Kibana测试</strong></p><p>测试ik_smart（使用RESTful风格的语句发起GET请求，对我们提供的JSON数据进行分词）</p><blockquote>  <div class="code-wrapper"><pre><code class="hljs json">GET _analyze&#123;<span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span>,<span class="hljs-attr">&quot;text&quot;</span>: [<span class="hljs-string">&quot;新型冠状病毒&quot;</span>]&#125;</code></pre></div></blockquote><p>运行结果：</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105137.png" alt="image-20210202150329532"></p><p>测试ik _max _word</p><blockquote>  <div class="code-wrapper"><pre><code class="hljs json">GET _analyze&#123;<span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<span class="hljs-attr">&quot;text&quot;</span>: [<span class="hljs-string">&quot;新型冠状病毒&quot;</span>]&#125;</code></pre></div></blockquote><p>运行结果：最细粒度划分会把所有可能的组合都划分出来（划分方式由某个字典规定）</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105138.png" alt="image-20210202150645756"></p><p>问题：当遇到自造词时，拆分结果不是我们想要的</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105139.png" alt="image-20210202151449769"></p><p>这时需要把关键词加入字典</p><h3 id="6-3-配置IK分词器"><a href="#6-3-配置IK分词器" class="headerlink" title="6.3 配置IK分词器"></a>6.3 配置IK分词器</h3><p><strong>添加自定义字典</strong></p><blockquote><p>  在 elasticsearch-7.12.1\plugins\ik\config</p></blockquote><p>中可以找到配置文件<strong>IKAnalyzer.cfg.xml</strong></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105140.png" alt="image-20210202152120411"></p><p>只需要在config目录下新建一个自己的.dic字典文件并录入IKAnalyzer.cfg.xml中然后<strong>重启es</strong>即可</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105141.png" alt="image-20210202152518579"></p><p>测试能够识别自定义词语</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105142.png" alt="image-20210202153349063"></p><h2 id="7-REST风格"><a href="#7-REST风格" class="headerlink" title="7 REST风格"></a>7 REST风格</h2><h3 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 <strong>概念</strong></h3><p>一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>即<strong>通过不同的命令实现不同的操作</strong></p><h3 id="7-2-基本REST命令"><a href="#7-2-基本REST命令" class="headerlink" title="7.2 基本REST命令"></a>7.2 基本REST命令</h3><table><thead><tr><th>method</th><th>url地址</th><th>描述</th></tr></thead><tbody><tr><td>PUT</td><td>localhost:9200/索引名称/类型名称/文档id</td><td>创建文档(指定文档id )</td></tr><tr><td>POST</td><td>localhost:9200/索弓|名称/类型名称</td><td>创建文档(随机文档id )</td></tr><tr><td>POST</td><td>localhost:9200/索引名称/类型名称/文档id/_ update</td><td>修改文档</td></tr><tr><td>DELETE</td><td>localhost:9200/索引名称/类型名称/文档id</td><td>删除文档</td></tr><tr><td>GET</td><td>localhost:9200/索引名称/类型名称/文档id</td><td>查询文档（通过文档id）</td></tr><tr><td>POST</td><td>localhost:9200/索弓|名称/类型名称/_ search</td><td>查询所有数据</td></tr></tbody></table><h2 id="8-测试"><a href="#8-测试" class="headerlink" title="8 测试"></a>8 测试</h2><h3 id="8-1-关于索引的操作"><a href="#8-1-关于索引的操作" class="headerlink" title="8.1 关于索引的操作"></a>8.1 关于索引的操作</h3><h4 id="1、创建一个索引"><a href="#1、创建一个索引" class="headerlink" title="1、创建一个索引"></a><strong>1、创建一个索引</strong></h4><blockquote>  <div class="code-wrapper"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/索引名/</span>类型名（新版本逐步废弃）/文档ID&#123;请求体&#125;</code></pre></div></blockquote><div class="code-wrapper"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/test1/</span>type/<span class="hljs-number">1</span>&#123;  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">13</span>&#125;</code></pre></div><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105143.png" alt="image-20210203092727349"></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105144.png" alt="image-20210203110817742"></p><p><strong>注意：</strong></p><p> 1、创建的索引名要<strong>小写</strong></p><p> 2、es head中数据浏览不显示内容就换个浏览器试试</p><h4 id="2、更新一个索引"><a href="#2、更新一个索引" class="headerlink" title="2、更新一个索引"></a>2、更新一个索引</h4><p>修改索引依旧可以使用PUT，此时返回的版本号会增加，”result”会提示update，但如果漏了一些信息，原始信息就会丢失，故现在一般<strong>使用POST来更新索引</strong></p><div class="code-wrapper"><pre><code class="hljs awk">POST <span class="hljs-regexp">/test1/</span>type1/<span class="hljs-number">1</span>&#123; <span class="hljs-string">&quot;doc&quot;</span>:&#123;   <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span> &#125;&#125;</code></pre></div><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105145.png" alt="image-20210203115556670"></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105146.png" alt="image-20210203115639183"></p><p>没有写age，它就会保持原样（如果用PUT的话age就直接没了）</p><h4 id="3、删除一个索引"><a href="#3、删除一个索引" class="headerlink" title="3、删除一个索引"></a>3、删除一个索引</h4><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">DELETE</span> test<span class="hljs-number">1</span>（索引名或文档记录ID）</code></pre></div><h4 id="4、指定类型"><a href="#4、指定类型" class="headerlink" title="4、指定类型"></a>4、指定类型</h4><p><strong>常用的字段类型有：</strong></p><p>●字符串类型<br>text、keyword<br>●数值类型<br>long,. integer, short, byte, double, float, half float, scaled float<br>●日期类型<br>date<br>●te布尔值类型<br>boolean<br>●二进制类型<br>binary.</p><p>创建一个t2索引（或者说索引库）但不创建文档，此时称其为一个“规则”</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105147.png" alt="image-20210203111936090"></p><p>查看t2，里面没有值，后续可以往里面放数据</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105148.png" alt="image-20210203112007717"></p><p>通过GET可以查看规则信息</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105149.png" alt="image-20210203112304214"></p><p>GET请求很好用，除了规则，还可以查看索引、文档的信息</p><p><strong>注：</strong></p><p>1、新版本es中正在逐步弃用type，我们创建索引库的时候可以将原来的type换成_doc，这样es就会自动帮我们配置字段类型</p><p>如下面的新建的test3：</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105150.png" alt="image-20210203113420834"></p><p>2、查看默认配置命令 GET _cat/indices?v</p><p>可以使用这个命令查看集群健康状态等一些信息</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105151.png" alt="image-20210203114043227"></p><h3 id="8-2-关于文档的操作"><a href="#8-2-关于文档的操作" class="headerlink" title="8.2 关于文档的操作"></a>8.2 关于文档的操作</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>1、添加数据</strong></p><div class="code-wrapper"><pre><code class="hljs json">PUT /dayceng/user/1&#123;  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;DAYceng&quot;</span>,  <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-string">&quot;22&quot;</span>,  <span class="hljs-attr">&quot;desc&quot;</span>: <span class="hljs-string">&quot;如此生活三十年&quot;</span>,  <span class="hljs-attr">&quot;tags&quot;</span>: [<span class="hljs-string">&quot;穷&quot;</span>,<span class="hljs-string">&quot;阿宅&quot;</span>,<span class="hljs-string">&quot;脚本小子&quot;</span>]&#125;</code></pre></div><p><strong>2、查询（获取，GET）数据</strong></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105152.png" alt="image-20210205094004174"></p><p><strong>3、简单搜索</strong>(GET条件查询)</p><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search?q=name:条件</code></pre></div><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105153.png" alt="image-20210205095050550"></p><p>简单的条件查询可根据默认的映射规则产生基本查询结果</p><p>（这里的”_score”代表匹配度，分值越高，匹配度越高）</p><p>说明：</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105154.png" alt="image-20210205095252732"></p><p>字段name，它的类型是keyword，此时进行搜索，分词器不会对类型为keyword的name进行分词（即如果你搜“丹”是不会返回“丹霞”的结果的），如果类型是text则可以查到</p><h4 id="复杂操作（主要是搜索）"><a href="#复杂操作（主要是搜索）" class="headerlink" title="复杂操作（主要是搜索）"></a><strong>复杂操作（主要是搜索）</strong></h4><p><strong>复杂搜索select（排序、分页、模糊/精准查询、高亮）</strong></p><h5 id="1、使用请求体查询"><a href="#1、使用请求体查询" class="headerlink" title="1、使用请求体查询"></a><strong>1、使用请求体查询</strong></h5><p>一般来说，我们进行搜索不是直接写条件搜索，而是需要构建一个JSON格式的请求体，这样可以设置更多参数以实现定制化的搜索</p><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;match&quot;</span>: &#123;      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>    &#125;  &#125;&#125;</code></pre></div><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105155.png" alt="image-20210205105110638"></p><p>如果有相似关键字的多个结果，他们的分数会有不同</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105156.png" alt="image-20210205110206156"></p><p>hits是我们比较关注的一部分，其中包含：</p><p> 索引和文档的信息</p><p> 查询的结果总数</p><p> 查询出来的具体的文档</p><p> 分数：用来判断哪个结果更加符合预期</p><p>通过hits我们可以把数据的信息遍历出来，让我们想要的结果优先显示出来</p><p>后面使用java操控es，所有的方法和对象就是这里的hits、source等key</p><h5 id="2、请求体参数"><a href="#2、请求体参数" class="headerlink" title="2、请求体参数"></a>2、请求体参数</h5><p>我们通过在请求体后添加参数的方式实现一些自定义的操作</p><h6 id="筛选结果"><a href="#筛选结果" class="headerlink" title="筛选结果"></a><strong>筛选结果</strong></h6><p>只返回特定结果</p><div class="code-wrapper"><pre><code class="hljs awk">GET <span class="hljs-regexp">/dayceng/u</span>ser/_search&#123;  <span class="hljs-string">&quot;query&quot;</span>: &#123;    <span class="hljs-string">&quot;match&quot;</span>: &#123;      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>    &#125;  &#125;,   <span class="hljs-string">&quot;_source&quot;</span>:[<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;tags&quot;</span>]&#125;</code></pre></div><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105157.png" alt="image-20210205114109589"></p><h6 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h6><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;match&quot;</span>: &#123;      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>    &#125;  &#125;,  <span class="hljs-attr">&quot;sort&quot;</span>: [    &#123;      <span class="hljs-attr">&quot;age&quot;</span>: &#123;        <span class="hljs-attr">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span>      &#125;    &#125;  ]&#125;</code></pre></div><p>注意：排序只能用于数值类型，我这里的age是text类型，运行就会报错</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105158.png" alt="image-20210205115918067"></p><blockquote><p>  “Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata=true on [age] in order to load field data by uninverting the inverted index. Note that this can use significant memory.”</p></blockquote><p>把“age”换成“age.keyword”即可正常排序</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105159.png" alt="image-20210205120324780"></p><h6 id="分页"><a href="#分页" class="headerlink" title="分页"></a><strong>分页</strong></h6><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;match&quot;</span>: &#123;      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞在&quot;</span>    &#125;  &#125;,  <span class="hljs-attr">&quot;sort&quot;</span>: [    &#123;      <span class="hljs-attr">&quot;age.keyword&quot;</span>: &#123;        <span class="hljs-attr">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span>      &#125;    &#125;  ],   &quot;from&quot;: 0,---从第几个数据开始   &quot;size&quot;: 2 ---返回几个数据&#125;</code></pre></div><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105200.png" alt="image-20210206093248369"></p><h6 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a><strong>过滤</strong></h6><p>使用filter参数即可</p><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105201.png" alt="image-20210206094548128"></p><p> gt：大于</p><p> gte：大于等于</p><p> lt：小于</p><p> lte：小于等于</p><p> （以上条件可混合使用）</p><h5 id="3、布尔值查询"><a href="#3、布尔值查询" class="headerlink" title="3、布尔值查询"></a>3、布尔值查询</h5><p>使用布尔值可进行多条件查询</p><p><strong>must</strong>：设置的所有match都要匹配才会返回结果</p><p><strong>must not</strong>：返回与设置条件相反的结果</p><p><strong>should</strong>：满足条件之一即可返回结果</p><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;bool&quot;</span>: &#123;      <span class="hljs-attr">&quot;must&quot;</span>: [        &#123;          <span class="hljs-attr">&quot;match&quot;</span>: &#123;            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;DAYceng&quot;</span>          &#125;        &#125;,        &#123;          <span class="hljs-attr">&quot;match&quot;</span>: &#123;            <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">22</span>          &#125;        &#125;      ]    &#125;  &#125;&#125;</code></pre></div><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105202.png" alt="image-20210206093144473"></p><h5 id="4、精确查询"><a href="#4、精确查询" class="headerlink" title="4、精确查询"></a>4、精确查询</h5><p>term查询是直接使用倒排索引进行精确查询的</p><p><strong>term与match的比较</strong></p><p> ·term使用倒排索引直接进行精确查询</p><p> ·match则会使用分词器进行解析后再查询（先分析文档，在通过分析结果进行查询）</p><p><strong>类型text与keyword的比较</strong></p><p>text会使用分词器进行分词后再查询</p><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105203.png" alt="image-20210206102310427"></p><p>keyword不会拆分特定词语</p><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105204.png" alt="image-20210206102247047"></p><h5 id="5、高亮查询"><a href="#5、高亮查询" class="headerlink" title="5、高亮查询"></a>5、高亮查询</h5><p>使用highlight参数</p><div class="code-wrapper"><pre><code class="hljs awk">GET <span class="hljs-regexp">/dayceng/u</span>ser/_search&#123;  <span class="hljs-string">&quot;query&quot;</span>: &#123;    <span class="hljs-string">&quot;match&quot;</span>: &#123;      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>    &#125;  &#125;,  <span class="hljs-string">&quot;highlight&quot;</span>: &#123;    <span class="hljs-string">&quot;fields&quot;</span>: &#123;      <span class="hljs-string">&quot;name&quot;</span>:&#123;&#125;    &#125;  &#125;&#125;</code></pre></div><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105205.png" alt="image-20210206104615060"></p><p>在highlight中也可以自定义高亮标签</p><div class="code-wrapper"><pre><code class="hljs awk">GET <span class="hljs-regexp">/dayceng/u</span>ser/_search&#123;  <span class="hljs-string">&quot;query&quot;</span>: &#123;    <span class="hljs-string">&quot;match&quot;</span>: &#123;      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>    &#125;  &#125;,  <span class="hljs-string">&quot;highlight&quot;</span>: &#123;    <span class="hljs-string">&quot;pre_tags&quot;</span>: <span class="hljs-string">&quot;&lt;p class=key style=&#x27;color:red&#x27;&gt;&quot;</span>,     <span class="hljs-string">&quot;post_tags&quot;</span>: <span class="hljs-string">&quot;&lt;/p&gt;&quot;</span>,     <span class="hljs-string">&quot;fields&quot;</span>: &#123;      <span class="hljs-string">&quot;name&quot;</span>:&#123;&#125;    &#125;  &#125;&#125;</code></pre></div><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105206.png" alt="image-20210206105030939"></p><h2 id="9-Python-elasticsearch基本用法"><a href="#9-Python-elasticsearch基本用法" class="headerlink" title="9 Python-elasticsearch基本用法"></a>9 Python-elasticsearch基本用法</h2><p>官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html#_getting_a_document">https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html#_getting_a_document</a></p><h3 id="9-1-安装及初始化"><a href="#9-1-安装及初始化" class="headerlink" title="9.1 安装及初始化"></a>9.1 安装及初始化</h3><p>使用pip安装即可</p><div class="code-wrapper"><pre><code class="hljs shell">pip install elasticsearchpip install elasticsearch[async]#支持异步，可不安装</code></pre></div><h3 id="9-2-实例化es客户端"><a href="#9-2-实例化es客户端" class="headerlink" title="9.2 实例化es客户端"></a>9.2 <strong>实例化es客户端</strong></h3><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105207.png" alt="image-20210219115247238"></p><p>实际上这里文档中给了三种创建客户端的方式，我们选择HTTP authentication方式（看起来清晰一些，当然你也可以用别的）实例化es对象</p><div class="code-wrapper"><pre><code class="hljs python">es = Elasticsearch(    [        &#123;<span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">9200</span>&#125;,    ],    http_auth=(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;secret&quot;</span>),    timeout=<span class="hljs-number">3600</span>)</code></pre></div><p>ES提供了两种搜索的方式：　　</p><p>　 请求参数方式</p><p>　 请求体方式（带body 的那种查询，把查询的内容放入body中，会造成一定的开销，但是易于理解）</p><p>这里我们使用请求体方式进行搜索</p><p>配置一个body</p><div class="code-wrapper"><pre><code class="hljs python">body = &#123;    <span class="hljs-string">&quot;settings&quot;</span>: &#123;        <span class="hljs-string">&quot;number_of_shards&quot;</span>: <span class="hljs-number">3</span>,        <span class="hljs-string">&quot;number_of_replicas&quot;</span>: <span class="hljs-number">2</span>    &#125;,    <span class="hljs-string">&quot;mappings&quot;</span>:&#123;        <span class="hljs-comment"># &quot;_doc&quot;:&#123;</span>        <span class="hljs-string">&quot;properties&quot;</span>:&#123;            <span class="hljs-string">&quot;id&quot;</span>:&#123;                <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;integer&quot;</span>,            &#125;,            <span class="hljs-string">&quot;text&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,                <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,  <span class="hljs-comment">#指定ik分词器，适用中文分词。</span>                <span class="hljs-string">&quot;index&quot;</span>:<span class="hljs-literal">False</span>            &#125;,            <span class="hljs-string">&quot;userId&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span>,            &#125;,            <span class="hljs-string">&quot;reprinted&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,            &#125;,        &#125;</code></pre></div><p>注：可以看到，body中实际上就是之前我们使用请求体参数搜索时设置的一些东西</p><h3 id="9-3-单一操作"><a href="#9-3-单一操作" class="headerlink" title="9.3 单一操作"></a>9.3 单一操作</h3><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p><strong>create</strong></p><p>必须指定待查询的idnex、type、id和查询体body；缺一不可，否则报错</p><div class="code-wrapper"><pre><code class="hljs python">es.indices.create(index = <span class="hljs-string">&quot;testpy&quot;</span>, body = body)</code></pre></div><p><strong>index</strong>　</p><p>相比于create，index的用法就相对灵活很多；id并非是一个必选项，如果指定，则该文档的id就是指定值，若不指定，则系统会自动生成一个全局唯一的id赋给该文档。</p><div class="code-wrapper"><pre><code class="hljs python">es.index(index = <span class="hljs-string">&quot;testpy&quot;</span>, doc_type = <span class="hljs-string">&quot;_doc&quot;</span>, <span class="hljs-built_in">id</span> = <span class="hljs-number">1</span>, body = &#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;小明&quot;</span>&#125;)</code></pre></div><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>　　delete：删除指定index、type、id的文档</p><div class="code-wrapper"><pre><code class="hljs python">es.indices.delete(index = <span class="hljs-string">&#x27;test&#x27;</span>)</code></pre></div><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>　　get：获取指定index、type、id所对应的文档</p><div class="code-wrapper"><pre><code class="hljs python">es.get(index=<span class="hljs-string">&quot;testpy&quot;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>)</code></pre></div><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>　　update：跟新指定index、type、id所对应的文档</p><div class="code-wrapper"><pre><code class="hljs python">es.update(index=<span class="hljs-string">&#x27;testpy&#x27;</span>, doc_type=<span class="hljs-string">&#x27;_doc&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;2&#x27;</span>, body=&#123;待更新字段&#125;)</code></pre></div><h3 id="9-4-批量操作"><a href="#9-4-批量操作" class="headerlink" title="9.4 批量操作"></a>9.4 批量操作</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>search：查询满足条件的所有文档，没有id属性，且index，type和body均可为None。 body的语法格式必须符合DSL格式</p><div class="code-wrapper"><pre><code class="hljs python">es.search(index = <span class="hljs-string">&quot;test&quot;</span>, doc_type = <span class="hljs-string">&quot;_doc&quot;</span>, body = query)</code></pre></div><p>复合查询语句</p><div class="code-wrapper"><pre><code class="hljs python">query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;match_all&#x27;</span>: &#123;&#125;&#125;&#125;<span class="hljs-comment"># 查找所有文档</span>query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;term&#x27;</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;jack&#x27;</span>&#125;&#125;&#125;<span class="hljs-comment"># 查找名字叫做jack的所有文档</span>query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;range&#x27;</span>: &#123;<span class="hljs-string">&#x27;age&#x27;</span>: &#123;<span class="hljs-string">&#x27;gt&#x27;</span>: <span class="hljs-number">11</span>&#125;&#125;&#125;&#125;<span class="hljs-comment"># 查找年龄大于11的所有文档</span>allDoc = es.search(index=<span class="hljs-string">&#x27;indexName&#x27;</span>, doc_type=<span class="hljs-string">&#x27;typeName&#x27;</span>, body=query)</code></pre></div><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>delete_by_query</p><div class="code-wrapper"><pre><code class="hljs python">query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;match&#x27;</span>: &#123;<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;famale&#x27;</span>&#125;&#125;&#125;<span class="hljs-comment"># 删除性别为女性的所有文档</span>query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;range&#x27;</span>: &#123;<span class="hljs-string">&#x27;age&#x27;</span>: &#123;<span class="hljs-string">&#x27;lt&#x27;</span>: <span class="hljs-number">11</span>&#125;&#125;&#125;&#125;<span class="hljs-comment"># 删除年龄小于11的所有文档</span>es.delete_by_query(index=<span class="hljs-string">&#x27;indexName&#x27;</span>, body=query, doc_type=<span class="hljs-string">&#x27;typeName&#x27;</span>)</code></pre></div><h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><p>update_by_query</p><div class="code-wrapper"><pre><code class="hljs python">query = &#123;            <span class="hljs-string">&quot;script&quot;</span>: &#123;            <span class="hljs-string">&quot;lang&quot;</span>: <span class="hljs-string">&quot;painless&quot;</span>,            <span class="hljs-comment"># &quot;inline&quot;: &quot;if (ctx._source.test_code == null) &#123;ctx._source.test_code= &#x27;02&#x27;&#125;&quot;</span>            <span class="hljs-string">&quot;inline&quot;</span>: <span class="hljs-string">&quot;ctx._source.kw_sourceType= &#x27;trueTime&#x27;&quot;</span>   <span class="hljs-comment">#新增字段kw_sourceType值为trueTime</span>              &#125;            &#125;res = es.update_by_query(index=<span class="hljs-string">&quot;hot_rank&quot;</span>, doc_type=<span class="hljs-string">&quot;baidu_hot_search_rank&quot;</span>, body=query)</code></pre></div><h3 id="9-5-完整测试工程代码"><a href="#9-5-完整测试工程代码" class="headerlink" title="9.5 完整测试工程代码"></a>9.5 完整测试工程代码</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> elasticsearch <span class="hljs-keyword">import</span> Elasticsearch<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<span class="hljs-comment">#from elasticsearch import AsyncElasticsearch</span><span class="hljs-comment">#es = Elasticsearch(host=&quot;localhost&quot;, port=9200)</span>es = Elasticsearch(    [        &#123;<span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">9200</span>&#125;,    ],    http_auth=(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;secret&quot;</span>),    timeout=<span class="hljs-number">3600</span>)body = &#123;    <span class="hljs-string">&quot;settings&quot;</span>: &#123;        <span class="hljs-string">&quot;number_of_shards&quot;</span>: <span class="hljs-number">3</span>,        <span class="hljs-string">&quot;number_of_replicas&quot;</span>: <span class="hljs-number">2</span>    &#125;,    <span class="hljs-string">&quot;mappings&quot;</span>:&#123;        <span class="hljs-comment"># &quot;_doc&quot;:&#123;</span>        <span class="hljs-string">&quot;properties&quot;</span>:&#123;            <span class="hljs-string">&quot;id&quot;</span>:&#123;                <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;integer&quot;</span>,            &#125;,            <span class="hljs-string">&quot;text&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,                <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,  <span class="hljs-comment">#指定ik分词器，适用中文分词。</span>                <span class="hljs-string">&quot;index&quot;</span>:<span class="hljs-literal">False</span>            &#125;,            <span class="hljs-string">&quot;userId&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span>,            &#125;,            <span class="hljs-string">&quot;reprinted&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,            &#125;,        &#125;        <span class="hljs-comment"># &#125;</span>    &#125;&#125;<span class="hljs-comment">#创建 index</span><span class="hljs-comment">#es.indices.create(index = &quot;testpy&quot;, body = body)</span><span class="hljs-comment">#删除 index</span><span class="hljs-comment">#es.indices.delete(index = &#x27;test&#x27;)</span><span class="hljs-comment">#插入数据</span><span class="hljs-comment">#es.index(index = &quot;testpy&quot;, doc_type = &quot;_doc&quot;, id = 1, body = &#123;&quot;id&quot;:1, &quot;name&quot;:&quot;小明&quot;&#125;)</span><span class="hljs-comment">#可以不用指定id，create会自动添加id。</span><span class="hljs-comment">#es.create(index=&quot;testpy&quot;, doc_type = &quot;_doc&quot;,id = 2, body = &#123;&quot;id&quot;:2, &quot;name&quot;:&quot;小红&quot;&#125;)</span><span class="hljs-string">&#x27;&#x27;&#x27;doc = &#123;</span><span class="hljs-string">    &#x27;author&#x27;: &#x27;author_name&#x27;,</span><span class="hljs-string">    &#x27;text&#x27;: &#x27;Interensting content...&#x27;,</span><span class="hljs-string">    &#x27;timestamp&#x27;: datetime.now(),</span><span class="hljs-string">&#125;&#x27;&#x27;&#x27;</span>res = es.get(index=<span class="hljs-string">&quot;testpy&quot;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>)<span class="hljs-comment">#es.search(index = &quot;test&quot;, doc_type = &quot;_doc&quot;, body = query)</span><span class="hljs-built_in">print</span>(res[<span class="hljs-string">&#x27;_source&#x27;</span>])</code></pre></div>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Distributed/">Distributed</category>
      
      
      <category domain="https://pncalbl.github.io/tags/ElasticSearch/">ElasticSearch</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Kafka 学习</title>
      <link>https://pncalbl.github.io/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Mon, 24 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Kafka-学习&quot;&gt;&lt;a href=&quot;#Kafka-学习&quot; class=&quot;headerlink&quot; title=&quot;Kafka 学习&quot;&gt;&lt;/a&gt;Kafka 学习&lt;/h1&gt;&lt;h2 id=&quot;1-Kafka-入门&quot;&gt;&lt;a href=&quot;#1-Kafka-入门&quot; class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Kafka-学习"><a href="#Kafka-学习" class="headerlink" title="Kafka 学习"></a>Kafka 学习</h1><h2 id="1-Kafka-入门"><a href="#1-Kafka-入门" class="headerlink" title="1 Kafka 入门"></a>1 Kafka 入门</h2><h3 id="1-1-文档"><a href="#1-1-文档" class="headerlink" title="1.1 文档"></a>1.1 文档</h3><ul><li><p><a href="http://kafka.apache.org/">Kafka官网主页</a></p></li><li><p><a href="http://kafka.apache.org/documentation/">Kafka官方文档</a></p></li></ul><h3 id="1-2-什么是-Kafka"><a href="#1-2-什么是-Kafka" class="headerlink" title="1.2 什么是 Kafka"></a>1.2 什么是 Kafka</h3><p>Kafka 是一个<strong>分布式</strong>的基于<strong>发布/订阅模式</strong>的<strong>消息队列</strong>（Message Queue），主要应用于大数据实时处理领域。</p><h3 id="1-3-消息队列"><a href="#1-3-消息队列" class="headerlink" title="1.3 消息队列"></a>1.3 消息队列</h3><h4 id="传统消息队列的应用场景"><a href="#传统消息队列的应用场景" class="headerlink" title="传统消息队列的应用场景"></a>传统消息队列的应用场景</h4><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/01.png" alt></p><h4 id="使用消息队列的好处"><a href="#使用消息队列的好处" class="headerlink" title="使用消息队列的好处"></a>使用消息队列的好处</h4><ol><li><p>解耦（类似Spring的IOC）</p><p>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p></li><li><p>可恢复性</p><p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p></li><li><p>缓冲</p><p>有助于控制和优化数据流经过系统的速度， 解决生产消息和消费消息的处理速度不一致的情况。</p></li><li><p>灵活性 &amp; 峰值处理能力（削峰）</p><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p></li><li><p>异步通信</p><p>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p></li></ol><h3 id="1-4-消费模式"><a href="#1-4-消费模式" class="headerlink" title="1.4 消费模式"></a>1.4 消费模式</h3><p>消息队列的两种模式</p><h4 id="1-4-1-点对点模式"><a href="#1-4-1-点对点模式" class="headerlink" title="1.4.1 点对点模式"></a>1.4.1 点对点模式</h4><p><strong>一对一，消费者主动拉取数据，消息收到后消息清除</strong></p><p>消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费以后， queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/02.png" alt></p><h4 id="1-4-2-发布-订阅模式"><a href="#1-4-2-发布-订阅模式" class="headerlink" title="1.4.2 发布/订阅模式"></a>1.4.2 发布/订阅模式</h4><p><strong>一对多，消费者消费数据之后不会清除消息</strong></p><p>消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/03.png" alt></p><h3 id="1-5-基础架构"><a href="#1-5-基础架构" class="headerlink" title="1.5 基础架构"></a>1.5 基础架构</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/04.png" alt></p><ol><li><strong>Producer</strong> ： 消息生产者，就是向 Kafka ；</li><li><strong>Consumer</strong> ： 消息消费者，向 Kafka broker 取消息的客户端；</li><li><strong>Consumer Group （CG）</strong>： 消费者组，由多个 consumer 组成。 消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。 所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li><li><strong>Broker</strong> ：经纪人 一台 Kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker可以容纳多个 topic。</li><li><strong>Topic</strong> ： 话题，可以理解为一个队列， 生产者和消费者面向的都是一个 topic；</li><li><strong>Partition</strong>： 为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；</li><li><strong>Replica</strong>： 副本（Replication），为保证集群中的某个节点发生故障时， 该节点上的 partition 数据不丢失，且 Kafka仍然能够继续工作， Kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。</li><li><strong>Leader</strong>： 每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 leader。</li><li><strong>Follower</strong>： 每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据的同步。 leader 发生故障时，某个 Follower 会成为新的 leader。</li></ol><blockquote><p>  replica 英 [ˈreplɪkə] 美 [ˈreplɪkə] n.复制品;仿制品</p></blockquote><blockquote><p>  topic 英 [ˈtɒpɪk] 美 [ˈtɑːpɪk] n.话题;题目;标题</p></blockquote><h3 id="1-6-安装-amp-启动-amp-关闭"><a href="#1-6-安装-amp-启动-amp-关闭" class="headerlink" title="1.6 安装&amp;启动&amp;关闭"></a>1.6 安装&amp;启动&amp;关闭</h3><h4 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h4><p>本次安装学习在Windows操作系统进行。（Linux版本的差别不大，运行脚本文件后缀从<code>bat</code>改为<code>sh</code>，配置路径改用Unix风格的）</p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23quickstart">本节教程来源</a></p><h4 id="Step-1-Download-the-code"><a href="#Step-1-Download-the-code" class="headerlink" title="Step 1: Download the code"></a>Step 1: Download the code</h4><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2Fdownloads">下载代码</a>并解压</p><p>下载<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farchive.apache.org%2Fdist%2Fkafka%2F0.11.0.0%2Fkafka_2.11-0.11.0.0.tgz">kafka 0.11.0.0</a>版本，解压到<code>C:\Kafka\</code>路径下，Kafka主目录文件为<code>C:\Kafka\kafka_2.11-0.11.0.0</code>（下文用KAFKA_HOME表示）。</p><h4 id="Step-2-Start-the-server"><a href="#Step-2-Start-the-server" class="headerlink" title="Step 2: Start the server"></a>Step 2: Start the server</h4><p>Kafka 用到 ZooKeeper 功能，所以要预先运行ZooKeeper。了解更多ZooKeeper信息，可点击阅读<a href="https://my.oschina.net/jallenkwong/blog/4405741">ZooKeeper学习笔记</a>。</p><ul><li>首先，修改<code>%KAFKA_HOME%\conf\zookeeper.properties</code>中的<code>dataDir=/tmp/zookeeper</code>，改为<code>dataDir=C:\\Kafka\\data\\zookeeper</code>。</li><li>创建新目录<code>C:\\Kafka\\data\\zookeeper</code>。</li><li>启动cmd，工作目录切换到<code>%KAFKA_HOME%</code>，执行命令行：</li></ul><div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">start</span> bin\windows\zookeeper-server-<span class="hljs-built_in">start</span>.bat config\zookeeper.properties</code></pre></div><ul><li>修改<code>%KAFKA_HOME%\conf\server.properties</code>中的<code>log.dirs=/tmp/kafka-logs</code>，改为<code>log.dirs=C:\\Kafka\\data\\kafka-logs</code>。</li><li>创建新目录<code>C:\\Kafka\\data\\kafka-logs</code>。</li><li>另启动cmd，工作目录切换到<code>%KAFKA_HOME%</code>，执行命令行：</li></ul><div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">start</span> bin\windows\kafka-server-<span class="hljs-built_in">start</span>.bat config\server.properties</code></pre></div><ul><li><p>可写一脚本，一键启动</p></li><li><p>关闭服务，<code>bin\windows\kafka-server-stop.bat</code>和<code>bin\windows\zookeeper-server-stop.bat</code></p></li></ul><p>TODO:<strong>一个问题</strong>，通过<code>kafka-server-stop.bat</code>或右上角关闭按钮来关闭Kafka服务后，马上下次再启动Kafka，抛出异常，说某文件被占用，需清空<code>log.dirs</code>目录下文件，才能重启Kafka。</p><div class="code-wrapper"><pre><code class="hljs shell">[2020-07-21 21:43:26,755] ERROR There was an error in one of the threads during logs loading: java.nio.file.FileSystemException: C:\Kafka\data\kafka-logs-0\my-replicated-topic-0\00000000000000000000.timeindex: 另一个程序正在使用此文件，进程无法访问。 (kafka.log.LogManager)...</code></pre></div><p>参阅网络，这可能是在windows下的一个Bug，没有更好的解决方案，暂时写个py脚本用来对kafka的log文件进行删除。下次启动kafka，先运行这个删除脚本吧。</p><p><strong>好消息</strong>，当你成功启动kafka，然后在对应的命令行窗口用<code>Ctrl + C</code>结束Kakfa，下次不用清理kafka日志，也能正常启动。</p><h4 id="Step-3-Create-a-topic"><a href="#Step-3-Create-a-topic" class="headerlink" title="Step 3: Create a topic"></a>Step 3: Create a topic</h4><ul><li>用单一partition和单一replica创建一个名为<code>test</code>的topic:</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --create --zookeeper localhost:<span class="hljs-number">2181</span> --replication-factor <span class="hljs-number">1</span> --partitions <span class="hljs-number">1</span> --topic test</code></pre></div><ul><li>查看已创建的topic，也就刚才创建的名为<code>test</code>的topic：</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --list --zookeeper localhost:<span class="hljs-number">2181</span></code></pre></div><p>或者，你可配置你的broker去自动创建未曾发布过的topic，代替手动创建topic</p><h4 id="Step-4-Send-some-messages"><a href="#Step-4-Send-some-messages" class="headerlink" title="Step 4: Send some messages"></a>Step 4: Send some messages</h4><p>运行producer，然后输入几行文本，发至服务器：</p><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="hljs-number">9092</span> --topic test&gt;hello, kafka.&gt;what a nice day!&gt;to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div><p>请勿关闭窗口，下面步骤需要用到</p><h4 id="Step-5-Start-a-consumer"><a href="#Step-5-Start-a-consumer" class="headerlink" title="Step 5: Start a consumer"></a>Step 5: Start a consumer</h4><p>运行consumer，将Step 4中输入的几行句子，标准输出。</p><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9092</span> --topic test --from-beginninghello, kafka.what a nice day!to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div><p>若你另启cmd，执行命令行<code>bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning</code>来运行consumer，然后在<a href="https://my.oschina.net/jallenkwong/blog/4449224#">Step 4</a>中producer窗口输入一行句子，如<code>I must admit, I can&#39;t help but feel a twinge of envy.</code>，两个consumer也会同时输出<code>I must admit, I can&#39;t help but feel a twinge of envy.</code>。</p><h4 id="Step-6-Setting-up-a-multi-broker-cluster"><a href="#Step-6-Setting-up-a-multi-broker-cluster" class="headerlink" title="Step 6: Setting up a multi-broker cluster"></a>Step 6: Setting up a multi-broker cluster</h4><p>目前为止，我们仅作为一个单一broker，这不好玩。让我们弄个有三个节点的集群来玩玩。</p><ul><li>首先，在<code>%KAFKA%\config\server.properties</code>的基础上创建两个副本<code>server-1.properties</code>和<code>server-2.properties</code>。</li></ul><div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">copy</span> config\server.properties config\server-<span class="hljs-number">1</span>.properties<span class="hljs-built_in">copy</span> config\server.properties config\server-<span class="hljs-number">2</span>.properties</code></pre></div><ul><li>打开副本，编辑如下属性</li></ul><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#config/server-1.properties:</span><span class="hljs-meta">broker.id</span>=<span class="hljs-string">1</span><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://127.0.0.1:9093</span><span class="hljs-meta">log.dir</span>=<span class="hljs-string">C:\\Kafka\\data\\kafka-logs-1</span> <span class="hljs-comment">#config/server-2.properties:</span><span class="hljs-meta">broker.id</span>=<span class="hljs-string">2</span><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://127.0.0.1:9094</span><span class="hljs-meta">log.dir</span>=<span class="hljs-string">C:\\Kafka\\data\\kafka-logs-2</span></code></pre></div><p>这个<code>broker.id</code>属性是集群中每个节点的唯一永久的名称。</p><p>我们必须重写端口和日志目录，只是因为我们在同一台机器上运行它们，并且我们希望阻止brokers试图在同一个端口上注册或覆盖彼此的数据。</p><ul><li>我们已经启动了Zookeeper和我们的单个节点，所以我们只需要启动两个新节点：</li></ul><div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">start</span> bin\windows\kafka-server-<span class="hljs-built_in">start</span>.bat config\server-<span class="hljs-number">1</span>.properties<span class="hljs-built_in">start</span> bin\windows\kafka-server-<span class="hljs-built_in">start</span>.bat config\server-<span class="hljs-number">2</span>.properties</code></pre></div><ul><li>创建一个replication-factor为3的topic:</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --create --zookeeper localhost:<span class="hljs-number">2181</span> --replication-factor <span class="hljs-number">3</span> --partitions <span class="hljs-number">1</span> --topic my-replicated-topic</code></pre></div><ul><li>OK，现在我们有了一个集群，但是我们怎么知道哪个broker在做什么呢？那就运行<code>describe topics</code>命令：</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --describe --zookeeper localhost:<span class="hljs-number">2181</span> --topic my-replicated-topic<span class="hljs-function">Topic:<span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>       <span class="hljs-title">PartitionCount</span>:1        <span class="hljs-title">ReplicationFactor</span>:3</span><span class="hljs-function"><span class="hljs-title">Configs</span>:</span><span class="hljs-function"><span class="hljs-title">Topic</span>: <span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>      <span class="hljs-title">Partition</span>: 0    <span class="hljs-title">Leader</span>: 0       </span><span class="hljs-function"><span class="hljs-title">Replicas</span>: 0,1,2        <span class="hljs-title">Isr</span>: 0,1,2</span></code></pre></div><ul><li>以下是输出的说明。第一行给出所有Partition的摘要，每一行提供有关一个Partition的信息。因为这个Topic只有一个Partition，所以只有一行。<ul><li>“leader”是负责给定Partition的所有读写的节点。每个节点都可能成为Partition随机选择的leader。</li><li>“replicas”是复制此Partition日志的节点列表，无论它们是leader还是当前处于存活状态。</li><li>“isr”是一组 “in-sync” replicas。这是replicas列表的一个子集，它当前处于存活状态，并补充leader。</li></ul></li></ul><p>注意，<strong>在我的示例中，node 0是Topic唯一Partition的leader</strong>。（下面操作需要用到）</p><ul><li>让我们为我们的新Topic发布一些信息：</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="hljs-number">9092</span> --topic my-replicated-topic&gt;There&#x27;s sadness <span class="hljs-keyword">in</span> your eyes, I don&#x27;t want to say goodbye to you.&gt;Love is a big illusion, I should try to forget, but there&#x27;s something left <span class="hljs-keyword">in</span> my head.&gt;</code></pre></div><ul><li>让我们接收刚刚发布的信息吧！</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9092</span> --from-beginning --topic my-replicated-topicThere&#x27;s sadness <span class="hljs-keyword">in</span> your eyes, I don&#x27;t want to say goodbye to you.Love is a big illusion, I should try to forget, but there&#x27;s something left <span class="hljs-keyword">in</span> my head.</code></pre></div><ul><li>让我们测试一下容错性，由上文可知，Broker 0 身为 leader，因此，让我们干掉它吧：<ul><li>先找出 Broker 0 的进程pid。</li><li>杀掉 Broker 0 的进程。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs bat">wmic process where &quot;caption=&#x27;java.exe&#x27; and commandline like &#x27;<span class="hljs-variable">%server.properties%</span>&#x27;&quot; get processid,captionCaption   ProcessIdjava.exe  <span class="hljs-number">7528</span><span class="hljs-built_in">taskkill</span> /pid <span class="hljs-number">7528</span> /f成功: 已终止 PID 为 <span class="hljs-number">7528</span> 的进程。</code></pre></div><ul><li>原leader已被替换成它的flowers中的其中一个，并且 node 0 不在 in-sync replica 集合当中。</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --describe --zookeeper localhost:<span class="hljs-number">2181</span> --topic my-replicated-topic<span class="hljs-function">Topic:<span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>       <span class="hljs-title">PartitionCount</span>:1        <span class="hljs-title">ReplicationFactor</span>:3</span><span class="hljs-function"><span class="hljs-title">Configs</span>:</span><span class="hljs-function"><span class="hljs-title">Topic</span>: <span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>      <span class="hljs-title">Partition</span>: 0    <span class="hljs-title">Leader</span>: 1       <span class="hljs-title">Replicas</span>: 0,1,2 <span class="hljs-title">Isr</span>: 1,2</span></code></pre></div><ul><li>尽管原leader已逝，当原来消息依然可以接收。（注意，参数<code>--bootstrap-server localhost:9093</code>，而不是<code>--bootstrap-server localhost:9092</code>）</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9093</span> --from-beginning --topic my-replicated-topicThere&#x27;s sadness <span class="hljs-keyword">in</span> your eyes, I don&#x27;t want to say goodbye to you.Love is a big illusion, I should try to forget, but there&#x27;s something left <span class="hljs-keyword">in</span> my head.I don&#x27;t forget the way your kissing, the feeling &#x27;s so strong which is lasting <span class="hljs-keyword">for</span> so long.</code></pre></div><h4 id="server-properties一瞥"><a href="#server-properties一瞥" class="headerlink" title="server.properties一瞥"></a>server.properties一瞥</h4><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#broker 的全局唯一编号，不能重复</span><span class="hljs-meta">broker.id</span>=<span class="hljs-string">0</span><span class="hljs-comment">#删除 topic 功能使能</span><span class="hljs-meta">delete.topic.enable</span>=<span class="hljs-string">true</span><span class="hljs-comment">#处理网络请求的线程数量</span><span class="hljs-meta">num.network.threads</span>=<span class="hljs-string">3</span><span class="hljs-comment">#用来处理磁盘 IO 的现成数量</span><span class="hljs-meta">num.io.threads</span>=<span class="hljs-string">8</span><span class="hljs-comment">#发送套接字的缓冲区大小</span><span class="hljs-meta">socket.send.buffer.bytes</span>=<span class="hljs-string">102400</span><span class="hljs-comment">#接收套接字的缓冲区大小</span><span class="hljs-meta">socket.receive.buffer.bytes</span>=<span class="hljs-string">102400</span><span class="hljs-comment">#请求套接字的缓冲区大小</span><span class="hljs-meta">socket.request.max.bytes</span>=<span class="hljs-string">104857600</span><span class="hljs-comment">#kafka 运行日志存放的路径</span><span class="hljs-meta">log.dirs</span>=<span class="hljs-string">/opt/module/kafka/logs</span><span class="hljs-comment">#topic 在当前 broker 上的分区个数</span><span class="hljs-meta">num.partitions</span>=<span class="hljs-string">1</span><span class="hljs-comment">#用来恢复和清理 data 下数据的线程数量</span><span class="hljs-meta">num.recovery.threads.per.data.dir</span>=<span class="hljs-string">1</span><span class="hljs-comment">#segment 文件保留的最长时间，超时将被删除</span><span class="hljs-meta">log.retention.hours</span>=<span class="hljs-string">168</span><span class="hljs-comment">#配置连接 Zookeeper 集群地址</span><span class="hljs-meta">zookeeper.connect</span>=<span class="hljs-string">hadoop102:2181,hadoop103:2181,hadoop104:2181</span></code></pre></div><h3 id="1-7-命令行操作Topic增删查"><a href="#1-7-命令行操作Topic增删查" class="headerlink" title="1.7 命令行操作Topic增删查"></a>1.7 命令行操作Topic增删查</h3><h4 id="查看当前服务器中的所有-topic"><a href="#查看当前服务器中的所有-topic" class="headerlink" title="查看当前服务器中的所有 topic"></a>查看当前服务器中的所有 topic</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --list --zookeeper localhost:<span class="hljs-number">2181</span></code></pre></div><h4 id="创建-topic"><a href="#创建-topic" class="headerlink" title="创建 topic"></a>创建 topic</h4><div class="code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">bin\windows\kafka</span><span class="hljs-literal">-</span><span class="hljs-comment">topics</span><span class="hljs-string">.</span><span class="hljs-comment">bat</span> --<span class="hljs-comment">create</span> --<span class="hljs-comment">zookeeper</span> <span class="hljs-comment">localhost:2181</span> --<span class="hljs-comment">replication</span><span class="hljs-literal">-</span><span class="hljs-comment">factor</span> <span class="hljs-comment">3</span> --<span class="hljs-comment">partitions</span> <span class="hljs-comment">1</span> --<span class="hljs-comment">topic</span> <span class="hljs-comment">my</span><span class="hljs-literal">-</span><span class="hljs-comment">replicated</span><span class="hljs-literal">-</span><span class="hljs-comment">topic</span></code></pre></div><p>选项说明：</p><ul><li>–topic 定义 topic 名</li><li>–replication-factor 定义副本数</li><li>–partitions 定义分区数</li></ul><blockquote><p>  为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；</p><p>  a broker = a kafka server a broker can contain N topic a topic can contain N partition a broker can contain a part of a topic (a broker can contain M(N&gt;M) partition)</p></blockquote><h4 id="删除-topic"><a href="#删除-topic" class="headerlink" title="删除 topic"></a>删除 topic</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --zookeeper localhost:<span class="hljs-number">2181</span> --delete --topic my-replicated-topic</code></pre></div><p>需要 server.properties 中设置 <code>delete.topic.enable=true</code> 否则只是标记删除。</p><h4 id="查看某个-Topic-的详情"><a href="#查看某个-Topic-的详情" class="headerlink" title="查看某个 Topic 的详情"></a>查看某个 Topic 的详情</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --zookeeper localhost:<span class="hljs-number">2181</span> --describe --topic first</code></pre></div><h4 id="修改分区数"><a href="#修改分区数" class="headerlink" title="修改分区数"></a>修改分区数</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --zookeeper localhost:<span class="hljs-number">2181</span> --alter --topic first --partitions <span class="hljs-number">6</span></code></pre></div><h3 id="1-8-命令行控制台生产者消费者测试"><a href="#1-8-命令行控制台生产者消费者测试" class="headerlink" title="1.8 命令行控制台生产者消费者测试"></a>1.8 命令行控制台生产者消费者测试</h3><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="hljs-number">9092</span> --topic test&gt;hello, kafka.&gt;what a nice day!&gt;to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div><h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9092</span> --topic test --from-beginninghello, kafka.what a nice day!to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div><ul><li>–from-beginning： 会把主题中以往所有的数据都读取出来。</li></ul><h3 id="1-9-数据日志分离"><a href="#1-9-数据日志分离" class="headerlink" title="1.9 数据日志分离"></a>1.9 数据日志分离</h3><h3 id="1-10-回顾"><a href="#1-10-回顾" class="headerlink" title="1.10 回顾"></a>1.10 回顾</h3><h2 id="2-Kafka高级"><a href="#2-Kafka高级" class="headerlink" title="2 Kafka高级"></a>2 Kafka高级</h2><h3 id="2-1-工作流程"><a href="#2-1-工作流程" class="headerlink" title="2.1 工作流程"></a>2.1 工作流程</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/05.png" alt></p><ul><li><p>Kafka 中消息是以 topic 进行分类的， producer生产消息，consumer消费消息，都是面向 topic的。(从命令行操作看出)</p><div class="code-wrapper"><pre><code class="hljs shell">bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic testbin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning</code></pre></div></li><li><p>topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文件，该 log 文件中存储的就是 producer 生产的数据。（topic = N partition，partition = log）</p></li><li><p>Producer 生产的数据会被不断追加到该log 文件末端，且每条数据都有自己的 offset。 consumer组中的每个consumer， 都会实时记录自己消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。（producer -&gt; log with offset -&gt; consumer(s)）</p></li></ul><h3 id="2-2-文件存储"><a href="#2-2-文件存储" class="headerlink" title="2.2 文件存储"></a>2.2 文件存储</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/06.png" alt></p><ul><li><p>由于生产者生产的消息会不断追加到 log 文件末尾， 为防止 log 文件过大导致数据定位效率低下， Kafka 采取了<strong>分片</strong>和<strong>索引</strong>机制，将每个 partition 分为多个 segment。</p></li><li><p>每个 segment对应两个文件——“.index”文件和“.log”文件。 这些文件位于一个文件夹下， 该文件夹的命名规则为： topic 名称+分区序号。例如， first 这个 topic 有三个分区，则其对应的文件夹为 first-0,first-1,first-2。</p><div class="code-wrapper"><pre><code class="hljs shell">00000000000000000000.index00000000000000000000.log00000000000000170410.index00000000000000170410.log00000000000000239430.index00000000000000239430.log</code></pre></div></li><li><p>index 和 log 文件以当前 segment 的第一条消息的 offset 命名。下图为 index 文件和 log文件的结构示意图。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/07.png" alt></p></li><li><p><strong>“.index”文件存储大量的索引信息，“.log”文件存储大量的数据</strong>，索引文件中的元数据指向对应数据文件中 message 的物理偏移地址。</p><blockquote><p>  segment 英 [ˈseɡmənt , seɡˈment] 美 [ˈseɡmənt , seɡˈment]<br>  n.部分;份;片;段;(柑橘、柠檬等的)瓣;弓形;圆缺 v.分割;划分</p></blockquote></li></ul><h3 id="2-3-生产者分区策略"><a href="#2-3-生产者分区策略" class="headerlink" title="2.3 生产者分区策略"></a>2.3 生产者分区策略</h3><h4 id="1-分区的原因"><a href="#1-分区的原因" class="headerlink" title="1 分区的原因"></a>1 分区的原因</h4><ul><li><strong>方便在集群中扩展</strong>，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic又可以有多个 Partition 组成，因此整个集群就可以适应适合的数据了；</li><li><strong>可以提高并发</strong>，因为可以以 Partition 为单位读写了。（联想到ConcurrentHashMap在高并发环境下读写效率比HashTable的高效）</li></ul><h4 id="2-分区的原则"><a href="#2-分区的原则" class="headerlink" title="2 分区的原则"></a>2 分区的原则</h4><p>我们需要将 producer 发送的数据封装成一个 <code>ProducerRecord</code> 对象。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/08.png" alt></p><ol><li>指明 partition 的情况下，直接将指明的值直接作为 partiton 值；</li><li>没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值；</li><li>既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition值，也就是常说的 round-robin 算法。</li></ol><h3 id="2-4-生产者ISR"><a href="#2-4-生产者ISR" class="headerlink" title="2.4 生产者ISR"></a>2.4 生产者ISR</h3><p>为保证 producer 发送的数据，能可靠的发送到指定的 topic， topic 的每个 partition 收到producer 发送的数据后，都需要向 producer 发送 ack（acknowledgement 确认收到），如果producer 收到 ack， 就会进行下一轮的发送，否则重新发送数据。</p><blockquote><p>  acknowledgement 英 [əkˈnɒlɪdʒmənt] 美 [əkˈnɑːlɪdʒmənt]<br>  n.(对事实、现实、存在的)承认;感谢;谢礼;<strong>收件复函</strong></p></blockquote><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/09.png" alt></p><p><strong>何时发送ack？</strong></p><p>确保有follower与leader同步完成，leader再发送ack，这样才能保证leader挂掉之后，能在follower中选举出新的leader。</p><p><strong>多少个follower同步完成之后发送ack？</strong></p><ol><li>半数以上的follower同步完成，即可发送ack继续发送重新发送</li><li>全部的follower同步完成，才可以发送ack</li></ol><h4 id="1-副本数据同步策略"><a href="#1-副本数据同步策略" class="headerlink" title="1 副本数据同步策略"></a>1 副本数据同步策略</h4><table><thead><tr><th>序号</th><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1</td><td>半数以上完成同步， 就发送 ack</td><td>延迟低</td><td>选举新的 leader 时，容忍 n 台节点的故障，需要 2n+1 个副本。（如果集群有2n+1台机器，选举leader的时候至少需要半数以上即n+1台机器投票，那么能容忍的故障，最多就是n台机器发生故障）容错率：1/2</td></tr><tr><td>2</td><td>全部完成同步，才发送ack</td><td>选举新的 leader 时， 容忍 n 台节点的故障，需要 n+1 个副本（如果集群有n+1台机器，选举leader的时候只要有一个副本就可以了）容错率：1</td><td>延迟高</td></tr></tbody></table><p>Kafka 选择了第二种方案，原因如下：</p><ol><li>同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1 个副本，而 Kafka 的每个分区都有大量的数据， 第一种方案会造成大量数据的冗余。</li><li>虽然第二种方案的网络延迟会比较高，但网络延迟对 Kafka 的影响较小。</li></ol><h4 id="2-ISR"><a href="#2-ISR" class="headerlink" title="2 ISR"></a>2 ISR</h4><p>采用第二种方案之后，设想以下情景： leader 收到数据，所有 follower 都开始同步数据，但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去，直到它完成同步，才能发送 ack。这个问题怎么解决呢？</p><p>Leader 维护了一个动态的 <strong>in-sync replica set</strong> (ISR)，意为和 leader 保持同步的 follower 集合。当 ISR 中的 follower 完成数据的同步之后，就会给 leader 发送 ack。如果 follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由<code>replica.lag.time.max.ms</code>参数设定。 Leader 发生故障之后，就会从 ISR 中选举新的 leader。</p><blockquote><p>  <strong>replica.lag.time.max.ms</strong></p><p>  <strong>DESCRIPTION</strong>: If a follower hasn’t sent any fetch requests or hasn’t consumed up to the leaders log end offset for at least this time, the leader will remove the follower from isr</p><p>  <strong>TYPE</strong>: long</p><p>  <strong>DEFAULT</strong>: 10000</p><p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23brokerconfigs">Source</a></p></blockquote><h3 id="2-5-生产者ACK机制"><a href="#2-5-生产者ACK机制" class="headerlink" title="2.5 生产者ACK机制"></a>2.5 生产者ACK机制</h3><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等 ISR 中的 follower 全部接收成功。</p><p>所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，选择以下的配置。</p><h4 id="acks-参数配置："><a href="#acks-参数配置：" class="headerlink" title="acks 参数配置："></a><strong>acks 参数配置</strong>：</h4><ul><li>0： producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟， broker 一接收到还没有写入磁盘就已经返回，当 broker 故障时有可能<strong>丢失数据</strong>；</li><li>1： producer 等待 broker 的 ack， partition 的 leader 落盘成功后返回 ack，如果在 follower同步成功之前 leader 故障，那么将会<strong>丢失数据</strong>；</li></ul><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/10.png" alt></p><ul><li>-1（all） ： producer 等待 broker 的 ack， partition 的 leader 和 ISR 的follower 全部落盘成功后才返回 ack。但是如果在 follower 同步完成后， broker 发送 ack 之前， leader 发生故障，那么会造成<strong>数据重复</strong>。</li></ul><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/11.png" alt></p><p><strong>助记：返ACK前，0无落盘，1一落盘，-1全落盘，（落盘：消息存到本地）</strong></p><blockquote><p>  <strong>acks</strong></p><p>  <strong>DESCRIPTION</strong>:</p><p>  The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. The following settings are allowed:</p><ul><li><code>acks=0</code> If set to zero then the producer will not wait for any acknowledgment from the server at all. The record will be immediately added to the socket buffer and considered sent. No guarantee can be made that the server has received the record in this case, and the retries configuration will not take effect (as the client won’t generally know of any failures). The offset given back for each record will always be set to -1.</li><li><code>acks=1</code> This will mean the leader will write the record to its local log but will respond without awaiting full acknowledgement from all followers. In this case should the leader fail immediately after acknowledging the record but before the followers have replicated it then the record will be lost.</li><li><code>acks=all</code> This means the leader will wait for the full set of in-sync replicas to acknowledge the record. This guarantees that the record will not be lost as long as at least one in-sync replica remains alive. This is the strongest available guarantee. This is equivalent to the acks=-1 setting.</li></ul><p>  <strong>TYPE</strong>:string</p><p>  <strong>DEFAULT</strong>:1</p><p>  <strong>VALID VALUES</strong>:[all, -1, 0, 1]</p><p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23producerconfigs">Source</a></p></blockquote><h3 id="2-6-数据一致性问题"><a href="#2-6-数据一致性问题" class="headerlink" title="2.6 数据一致性问题"></a>2.6 数据一致性问题</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/12.png" alt></p><ul><li>LEO：（Log End Offset）每个副本的最后一个offset</li><li>HW：（High Watermark）高水位，指的是消费者能见到的最大的 offset， ISR 队列中最小的 LEO</li></ul><h4 id="follower-故障和-leader-故障"><a href="#follower-故障和-leader-故障" class="headerlink" title="follower 故障和 leader 故障"></a>follower 故障和 leader 故障</h4><ul><li><strong>follower 故障</strong>：follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后， follower 会读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重新加入 ISR 了。</li><li><strong>leader 故障</strong>：leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性， 其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader同步数据。</li></ul><p>注意： 这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p><h3 id="2-7-ExactlyOnce"><a href="#2-7-ExactlyOnce" class="headerlink" title="2.7 ExactlyOnce"></a>2.7 ExactlyOnce</h3><p>将服务器的 ACK 级别设置为-1（all），可以保证 Producer 到 Server 之间不会丢失数据，即 <strong>At Least Once</strong> 语义。</p><p>相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被发送一次，即 <strong>At Most Once</strong> 语义。</p><p>At Least Once 可以保证数据不丢失，但是不能保证数据不重复；相对的， At Most Once可以保证数据不重复，但是不能保证数据不丢失。 但是，对于一些非常重要的信息，比如说<strong>交易数据</strong>，下游数据消费者要求数据既不重复也不丢失，即 <strong>Exactly Once</strong> 语义。</p><blockquote><ul><li><p>At least once—Messages are <strong>never lost</strong> but may be redelivered.</p></li><li><p>At most once—Messages <strong>may be lost</strong> but are never redelivered.</p></li><li><p>Exactly once—this is what people actually want, each message is delivered once and only once.</p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23semantics">Source</a></p></li></ul></blockquote><p>在 0.11 版本以前的 Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p><p>0.11 版本的 Kafka，引入了一项重大特性：<strong>幂等性</strong>。<strong>所谓的幂等性就是指 Producer 不论向 Server 发送多少次重复数据， Server 端都只会持久化一条</strong>。幂等性结合 At Least Once 语义，就构成了 Kafka 的 Exactly Once 语义。即：</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">At</span> <span class="hljs-variable">Least</span> <span class="hljs-built_in">Once</span> <span class="hljs-operator">+</span> 幂等性 <span class="hljs-operator">=</span> <span class="hljs-variable">Exactly</span> <span class="hljs-built_in">Once</span></code></pre></div><p>要启用幂等性，只需要将 Producer 的参数中 <code>enable.idempotence</code> 设置为 true 即可。 Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 Producer 在初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而Broker 端会对<code>&lt;PID, Partition, SeqNumber&gt;</code>做缓存，当具有相同主键的消息提交时， Broker 只会持久化一条。</p><p>但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨分区跨会话的 Exactly Once。</p><blockquote><p>  <strong>enable.idempotence</strong></p><p>  DESCRIPTION:When set to ‘true’, the producer will ensure that exactly one copy of each message is written in the stream. If ‘false’, producer retries due to broker failures, etc., may write duplicates of the retried message in the stream. This is set to ‘false’ by default. Note that enabling idempotence requires <code>max.in.flight.requests.per.connection</code> to be set to 1 and <code>retries</code> cannot be zero. Additionally acks must be set to ‘all’. If these values are left at their defaults, we will override the default to be suitable. If the values are set to something incompatible with the idempotent producer, a ConfigException will be thrown.</p><p>  TYPE:boolean</p><p>  DEFAULT:false</p><p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23producerconfigs">Source</a></p></blockquote><h3 id="2-8-生产者总结"><a href="#2-8-生产者总结" class="headerlink" title="2.8 生产者总结"></a>2.8 生产者总结</h3><h3 id="2-9-消费者分区分配策略"><a href="#2-9-消费者分区分配策略" class="headerlink" title="2.9 消费者分区分配策略"></a>2.9 消费者分区分配策略</h3><h4 id="1-消费方式"><a href="#1-消费方式" class="headerlink" title="1 消费方式"></a>1 消费方式</h4><p><strong>consumer 采用 pull（拉） 模式从 broker 中读取数据</strong>。</p><p><strong>push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的</strong>。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</p><p><strong>pull 模式不足之处</strong>是，如果 kafka 没有数据，消费者可能会陷入循环中， 一直返回空数据。 针对这一点， Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有数据可供消费， consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23design_pull">Push vs. pull</a></p><h4 id="2-分区分配策略"><a href="#2-分区分配策略" class="headerlink" title="2 分区分配策略"></a>2 分区分配策略</h4><p>一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以必然会涉及到 partition 的分配问题，即确定那个 partition 由哪个 consumer 来消费。</p><p>Kafka 有两种分配策略：</p><ul><li>round-robin循环</li><li>range</li></ul><blockquote><p>  <strong>partition.assignment.strategy</strong></p><p>  Select between the “range” or “roundrobin” strategy for assigning分配 partitions to consumer streams.</p><p>  The <strong>round-robin</strong> partition assignor lays out规划 all the available partitions and all the available consumer threads. It then proceeds to do接着做 a round-robin assignment from partition to consumer thread. If the subscriptions订阅 of all consumer instances are identical完全同样的, then the partitions will be uniformly 均匀地distributed. (i.e.也就是说, the partition ownership counts will be within a delta of exactly one across all consumer threads.) Round-robin assignment is permitted only if:</p><ol><li>Every topic has the same number of streams within a consumer instance</li><li>The set of subscribed topics is identical for every consumer instance within the group.</li></ol><p>  <strong>Range</strong> partitioning works on a per-<strong>topic</strong> basis. For each topic, we lay out the available partitions in numeric order and the consumer threads in lexicographic词典式的 order. We then divide the number of partitions by the total number of consumer streams (threads) to determine the number of partitions to assign to each consumer. If it does not evenly divide, then the first few consumers will have one extra partition.</p><p>  <strong>DEFAULT</strong>:range</p><p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23oldconsumerconfigs">Source</a></p></blockquote><hr><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F86718818">Kafka再平衡机制详解</a></p><h4 id="3-Round-Robin"><a href="#3-Round-Robin" class="headerlink" title="3 Round Robin"></a>3 Round Robin</h4><p>关于Roudn Robin重分配策略，其主要采用的是一种轮询的方式分配所有的分区，该策略主要实现的步骤如下。这里我们首先假设有三个topic：t0、t1和t2，这三个topic拥有的分区数分别为1、2和3，那么总共有六个分区，这六个分区分别为：t0-0、t1-0、t1-1、t2-0、t2-1和t2-2。这里假设我们有三个consumer：C0、C1和C2，它们订阅情况为：C0订阅t0，C1订阅t0和t1，C2订阅t0、t1和t2。那么这些分区的分配步骤如下：</p><ul><li>首先将所有的partition和consumer按照字典序进行排序，所谓的字典序，就是按照其名称的字符串顺序，那么上面的六个分区和三个consumer排序之后分别为：</li></ul><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/16.png" alt></p><ul><li>然后依次以按顺序轮询的方式将这六个分区分配给三个consumer，如果当前consumer没有订阅当前分区所在的topic，则轮询的判断下一个consumer：</li><li>尝试将t0-0分配给C0，由于C0订阅了t0，因而可以分配成功；</li><li>尝试将t1-0分配给C1，由于C1订阅了t1，因而可以分配成功；</li><li>尝试将t1-1分配给C2，由于C2订阅了t1，因而可以分配成功；</li><li>尝试将t2-0分配给C0，由于C0没有订阅t2，因而会轮询下一个consumer；</li><li>尝试将t2-0分配给C1，由于C1没有订阅t2，因而会轮询下一个consumer；</li><li>尝试将t2-0分配给C2，由于C2订阅了t2，因而可以分配成功；</li><li>同理由于t2-1和t2-2所在的topic都没有被C0和C1所订阅，因而都不会分配成功，最终都会分配给C2。</li><li>按照上述的步骤将所有的分区都分配完毕之后，最终分区的订阅情况如下：</li></ul><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/17.png" alt></p><p>从上面的步骤分析可以看出，轮询的策略就是简单的将所有的partition和consumer按照字典序进行排序之后，然后依次将partition分配给各个consumer，如果当前的consumer没有订阅当前的partition，那么就会轮询下一个consumer，直至最终将所有的分区都分配完毕。但是从上面的分配结果可以看出，轮询的方式会导致每个consumer所承载的分区数量不一致，从而导致各个consumer压力不均一。</p><h4 id="4-Range"><a href="#4-Range" class="headerlink" title="4 Range"></a>4 Range</h4><p>所谓的Range重分配策略，就是首先会计算各个consumer将会承载的分区数量，然后将指定数量的分区分配给该consumer。这里我们假设有两个consumer：C0和C1，两个topic：t0和t1，这两个topic分别都有三个分区，那么总共的分区有六个：t0-0、t0-1、t0-2、t1-0、t1-1和t1-2。那么Range分配策略将会按照如下步骤进行分区的分配：</p><ul><li>需要注意的是，Range策略是按照topic依次进行分配的，比如我们以t0进行讲解，其首先会获取t0的所有分区：t0-0、t0-1和t0-2，以及所有订阅了该topic的consumer：C0和C1，并且会将这些分区和consumer按照字典序进行排序；</li><li>然后按照平均分配的方式计算每个consumer会得到多少个分区，如果没有除尽，则会将多出来的分区依次计算到前面几个consumer。比如这里是三个分区和两个consumer，那么每个consumer至少会得到1个分区，而3除以2后还余1，那么就会将多余的部分依次算到前面几个consumer，也就是这里的1会分配给第一个consumer，总结来说，那么C0将会从第0个分区开始，分配2个分区，而C1将会从第2个分区开始，分配1个分区；</li><li>同理，按照上面的步骤依次进行后面的topic的分配。</li><li>最终上面六个分区的分配情况如下：</li></ul><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/18.png" alt></p><p>可以看到，如果按照<code>Range</code>分区方式进行分配，其本质上是依次遍历每个topic，然后将这些topic的分区按照其所订阅的consumer数量进行平均的范围分配。这种方式从计算原理上就会导致排序在前面的consumer分配到更多的分区，从而导致各个consumer的压力不均衡。</p><p>TODO:我的问题：topic分多个partition，有些custom根据上述策略，分到topic的部分partition，难道不是要全部partition吗？是不是还要按照相同策略多分配多一次？</p><h3 id="2-10-消费者offset的存储"><a href="#2-10-消费者offset的存储" class="headerlink" title="2.10 消费者offset的存储"></a>2.10 消费者offset的存储</h3><p>由于 consumer 在消费过程中可能会出现断电宕机等故障， consumer 恢复后，需要从故障前的位置的继续消费，所以 <strong>consumer 需要实时记录自己消费到了哪个 offset</strong>，以便故障恢复后继续消费。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/13.png" alt></p><p><strong>Kafka 0.9 版本之前， consumer 默认将 offset 保存在 Zookeeper 中，从 0.9 版本开始，consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为__consumer_offsets</strong>。</p><ol><li>修改配置文件 consumer.properties，<code>exclude.internal.topics=false</code>。</li><li>读取 offset<ul><li>0.11.0.0 之前版本 - <code>bin/kafka-console-consumer.sh --topic __consumer_offsets --zookeeper hadoop102:2181 --formatter &quot;kafka.coordinator.GroupMetadataManager\$OffsetsMessageFormatter&quot; --consumer.config config/consumer.properties --from-beginning</code></li><li>0.11.0.0 及之后版本 - <code>bin/kafka-console-consumer.sh --topic __consumer_offsets --zookeeper hadoop102:2181 --formatter &quot;kafka.coordinator.group.GroupMetadataManager\$OffsetsMessageFormatter&quot; --consumer.config config/consumer.properties --from-beginning</code></li></ul></li></ol><p>TODO:上机实验</p><h3 id="2-11-消费者组案例"><a href="#2-11-消费者组案例" class="headerlink" title="2.11 消费者组案例"></a>2.11 消费者组案例</h3><h4 id="1-需求"><a href="#1-需求" class="headerlink" title="1 需求"></a>1 需求</h4><p>测试同一个消费者组中的消费者， <strong>同一时刻只能有一个</strong>消费者消费。</p><h4 id="2-操作步骤"><a href="#2-操作步骤" class="headerlink" title="2 操作步骤"></a>2 操作步骤</h4><p>1.修改<code>%KAFKA_HOME\config\consumer.properties%</code>文件中的<code>group.id</code>属性。</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">group.id</span>=<span class="hljs-string">shan-kou-zu</span></code></pre></div><p>2.打开两个cmd，分别启动两个消费者。（以<code>%KAFKA_HOME\config\consumer.properties%</code>作配置参数）</p><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --zookeeper <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2181</span> --topic test --consumer.config config\consumer.properties</code></pre></div><p>3.再打开一个cmd，启动一个生产者。</p><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">9092</span> --topic test</code></pre></div><p>4.在生产者窗口输入消息，观察两个消费者窗口。<strong>会发现两个消费者窗口中，只有一个才会弹出消息</strong>。</p><h3 id="2-12-高效读写-amp-ZK作用"><a href="#2-12-高效读写-amp-ZK作用" class="headerlink" title="2.12 高效读写&amp;ZK作用"></a>2.12 高效读写&amp;ZK作用</h3><h4 id="1-顺序写磁盘"><a href="#1-顺序写磁盘" class="headerlink" title="1 顺序写磁盘"></a>1 顺序写磁盘</h4><p>Kafka 的 producer 生产数据，要写入到 log 文件中，写的过程是一直追加到文件末端，为顺序写。 官网有数据表明，同样的磁盘，顺序写能到 600M/s，而随机写只有 100K/s。这与磁盘的机械机构有关，顺序写之所以快，是因为其<strong>省去了大量磁头寻址的时间</strong>。</p><h4 id="2-零复制技术"><a href="#2-零复制技术" class="headerlink" title="2 零复制技术"></a>2 零复制技术</h4><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/14.png" alt></p><ul><li>NIC network interface controller 网络接口控制器</li></ul><h4 id="3-Zookeeper-在-Kafka-中的作用"><a href="#3-Zookeeper-在-Kafka-中的作用" class="headerlink" title="3 Zookeeper 在 Kafka 中的作用"></a>3 Zookeeper 在 Kafka 中的作用</h4><p>Kafka 集群中有一个 broker 会被选举为 Controller，负责管理集群 broker 的上下线，所有 topic 的分区副本分配和 leader 选举等工作。<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23design_replicamanagment">Reference</a></p><p>Controller 的管理工作都是依赖于 Zookeeper 的。</p><p>以下为 partition 的 leader 选举过程：</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/15.png" alt></p><h3 id="2-13-Ranger分区再分析"><a href="#2-13-Ranger分区再分析" class="headerlink" title="2.13 Ranger分区再分析"></a>2.13 Ranger分区再分析</h3><h3 id="2-14-事务"><a href="#2-14-事务" class="headerlink" title="2.14 事务"></a>2.14 事务</h3><p>Kafka 从 0.11 版本开始引入了事务支持。事务可以保证 Kafka 在 Exactly Once 语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p><h4 id="1-Producer-事务"><a href="#1-Producer-事务" class="headerlink" title="1 Producer 事务"></a>1 Producer 事务</h4><p>为了实现跨分区跨会话的事务，需要引入一个全局唯一的 Transaction ID，并将 Producer 获得的PID 和Transaction ID 绑定。这样当Producer 重启后就可以通过正在进行的 TransactionID 获得原来的 PID。</p><p>为了管理 Transaction， Kafka 引入了一个新的组件 Transaction Coordinator。 Producer 就是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。 Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p><h4 id="2-Consumer-事务"><a href="#2-Consumer-事务" class="headerlink" title="2 Consumer 事务"></a>2 Consumer 事务</h4><p>上述事务机制主要是从 Producer 方面考虑，对于 Consumer 而言，事务的保证就会相对较弱，尤其时无法保证 Commit 的信息被精确消费。这是由于 Consumer 可以通过 offset 访问任意信息，而且不同的 Segment File 生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p><h3 id="2-15-API生产者流程"><a href="#2-15-API生产者流程" class="headerlink" title="2.15 API生产者流程"></a>2.15 API生产者流程</h3><p>Kafka 的 Producer 发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了两个线程——main 线程和 Sender 线程，以及一个线程共享变量——RecordAccumulator。 main 线程将消息发送给 RecordAccumulator， Sender 线程不断从 RecordAccumulator 中拉取消息发送到 Kafka broker。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/19.png" alt></p><p>相关参数：</p><ul><li><strong>batch.size</strong>： 只有数据积累到 batch.size 之后， sender 才会发送数据。</li><li><strong>linger.ms</strong>： 如果数据迟迟未达到 batch.size， sender 等待 linger.time 之后就会发送数据。</li></ul><h3 id="2-16异步发送API普通生产者"><a href="#2-16异步发送API普通生产者" class="headerlink" title="2.16异步发送API普通生产者"></a>2.16异步发送API普通生产者</h3><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1 导入依赖"></a>1 导入依赖</h4><p><a href="https://my.oschina.net/jallenkwong/blog/pom.xml">pom.xml</a></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-clients<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2 编写代码"></a>2 编写代码</h4><p>需要用到的类：</p><ul><li>KafkaProducer：需要创建一个生产者对象，用来发送数据</li><li>ProducerConfig：获取所需的一系列配置参数</li><li>ProducerRecord：每条数据都要封装成一个 ProducerRecord 对象</li></ul><p><a href="https://gitee.com/jallenkwong/LearnKafka/blob/master/src/main/java/com/lun/kafka/producer/CustomProducer.java">CustomProducer.java</a></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.Producer;<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomProducer</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Properties props = <span class="hljs-keyword">new</span> Properties();<span class="hljs-comment">// kafka 集群， broker-list</span>props.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>);<span class="hljs-comment">//可用ProducerConfig.ACKS_CONFIG 代替 &quot;acks&quot;</span><span class="hljs-comment">//props.put(ProducerConfig.ACKS_CONFIG, &quot;all&quot;);</span>props.put(<span class="hljs-string">&quot;acks&quot;</span>, <span class="hljs-string">&quot;all&quot;</span>);<span class="hljs-comment">// 重试次数</span>props.put(<span class="hljs-string">&quot;retries&quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// 批次大小</span>props.put(<span class="hljs-string">&quot;batch.size&quot;</span>, <span class="hljs-number">16384</span>);<span class="hljs-comment">// 等待时间</span>props.put(<span class="hljs-string">&quot;linger.ms&quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// RecordAccumulator 缓冲区大小</span>props.put(<span class="hljs-string">&quot;buffer.memory&quot;</span>, <span class="hljs-number">33554432</span>);props.put(<span class="hljs-string">&quot;key.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);props.put(<span class="hljs-string">&quot;value.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);Producer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> KafkaProducer&lt;&gt;(props);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;producer.send(<span class="hljs-keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;test-&quot;</span> + Integer.toString(i),<span class="hljs-string">&quot;test-&quot;</span> + Integer.toString(i)));&#125;producer.close();&#125;&#125;</code></pre></div><h3 id="2-17-回顾"><a href="#2-17-回顾" class="headerlink" title="2.17 回顾"></a>2.17 回顾</h3>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Distributed/">Distributed</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Kafka/">Kafka</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Clion搭建Gtest单元测试框架</title>
      <link>https://pncalbl.github.io/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</link>
      <guid>https://pncalbl.github.io/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</guid>
      <pubDate>Fri, 21 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Clion搭建Gtest单元测试框架&quot;&gt;&lt;a href=&quot;#Clion搭建Gtest单元测试框架&quot; class=&quot;headerlink&quot; title=&quot;Clion搭建Gtest单元测试框架&quot;&gt;&lt;/a&gt;Clion搭建Gtest单元测试框架&lt;/h1&gt;&lt;h2 id=&quot;1</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Clion搭建Gtest单元测试框架"><a href="#Clion搭建Gtest单元测试框架" class="headerlink" title="Clion搭建Gtest单元测试框架"></a>Clion搭建Gtest单元测试框架</h1><h2 id="1-下载GTest源码"><a href="#1-下载GTest源码" class="headerlink" title="1 下载GTest源码"></a>1 下载GTest源码</h2><div class="code-wrapper"><pre><code class="hljs shell">git clone https://github.com/google/googletest.git</code></pre></div><p>下载下来的google gtest源码目录结构如下，里面包含了很多东西，这里我们只是想利用gtest对自己的代码进行单元测试，因此只需要关注红框所求的文件夹即可，其他的暂时不需要关注</p><p><img src="/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/570699-20190715005207916-173277913.png" alt="img"></p><h2 id="2-导入-Gtest"><a href="#2-导入-Gtest" class="headerlink" title="2 导入 Gtest"></a>2 导入 Gtest</h2><p>使用CLion新建一下C++项目，把gtest引入到项目中，将上面googletest目录放在external下面了，这个目录随意，看个人喜好了。</p><p><img src="/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/image-20210525000900512.png" alt="image-20210525000900512"></p><h2 id="3-配置-CMakeList-txt"><a href="#3-配置-CMakeList-txt" class="headerlink" title="3 配置 CMakeList.txt"></a>3 配置 CMakeList.txt</h2><ul><li>设置<strong>GOOGLETEST_VERSION</strong>变量，这个变量，其实是在googletest-master目录下的CMakeLists.txt中设置的，在googlegtest目录下的CMakeLists.txt中使用，如果我们不在项目的CMaksLists.txt中设置这个变量，则gtest的编译会失败，这点非常重要。</li><li>添加googletest目录到项目中，这个很简单。</li><li>添加target link，这个示例中，我新了一个demotest.cpp，里面用来放置单元测试用例相关的代码，将其编译为二进制可执行文件，来对正式项目代码进行测试，因为它依赖于gtest_main，因此这里必须把它们link起来，否则，test_main的编译会失败。</li></ul><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.17</span>)    <span class="hljs-comment"># cmake最低版本号要求</span><span class="hljs-keyword">project</span>(TestProject)    <span class="hljs-comment"># 项目名</span><span class="hljs-keyword">set</span>(GOOGLETEST_VERSION <span class="hljs-number">1.10</span>.<span class="hljs-number">0</span>)  <span class="hljs-comment"># 设置 Gtest 的版本</span><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)      <span class="hljs-comment"># C++ 版本</span><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;-Wall&quot;</span>)    <span class="hljs-comment">#</span><span class="hljs-comment"># 编译google test，会在当前目录生成libtest.a静态库</span><span class="hljs-keyword">add_subdirectory</span>(        external/googletest)<span class="hljs-comment"># 添加头文件</span><span class="hljs-keyword">include_directories</span>(        <span class="hljs-keyword">include</span>        external/googletest/<span class="hljs-keyword">include</span>)<span class="hljs-comment">#需要添加googletest运行需要的pthread</span><span class="hljs-keyword">set</span>(LIBRARIES        gtest        pthread)<span class="hljs-keyword">set</span>(SOURCE_FLIES tests/demotest.cpp) <span class="hljs-comment"># 其余文件</span><span class="hljs-keyword">add_executable</span>(main src/main.cpp)   <span class="hljs-comment"># main 函数</span><span class="hljs-keyword">add_executable</span>(TestProject <span class="hljs-variable">$&#123;SOURCE_FLIES&#125;</span> external/googletest)<span class="hljs-keyword">target_link_libraries</span>(TestProject gtest_main)</code></pre></div><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><p>demotest.cpp</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gtest/gtest.h&quot;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::testing;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GTestDemo</span> :</span> <span class="hljs-keyword">public</span> Test &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">GTestDemo</span>() : <span class="hljs-built_in">Test</span>() &#123;    &#125;    ~<span class="hljs-built_in">GTestDemo</span>() <span class="hljs-keyword">override</span> = <span class="hljs-keyword">default</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;        Test::<span class="hljs-built_in">SetUp</span>();        std::cout &lt;&lt; <span class="hljs-string">&quot;I am setup&quot;</span> &lt;&lt; std::endl;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;        Test::<span class="hljs-built_in">TearDown</span>();        std::cout &lt;&lt; <span class="hljs-string">&quot;I am teardown&quot;</span> &lt;&lt; std::endl;    &#125;&#125;;<span class="hljs-built_in">TEST_F</span>(GTestDemo, tc_example_01) &#123;    std::cout &lt;&lt; <span class="hljs-string">&quot;GTestDemo&quot;</span> &lt;&lt; std::endl;&#125;</code></pre></div><p><img src="/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/image-20210525001538855.png" alt="image-20210525001538855"></p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Win/">Win</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Note/">Note</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Netty 学习</title>
      <link>https://pncalbl.github.io/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 21 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Netty-学习&quot;&gt;&lt;a href=&quot;#Netty-学习&quot; class=&quot;headerlink&quot; title=&quot;Netty 学习&quot;&gt;&lt;/a&gt;Netty 学习&lt;/h1&gt;&lt;h2 id=&quot;1-Netty-介绍和应用场景&quot;&gt;&lt;a href=&quot;#1-Netty-介绍和应用场</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Netty-学习"><a href="#Netty-学习" class="headerlink" title="Netty 学习"></a>Netty 学习</h1><h2 id="1-Netty-介绍和应用场景"><a href="#1-Netty-介绍和应用场景" class="headerlink" title="1 Netty 介绍和应用场景"></a>1 Netty 介绍和应用场景</h2><h3 id="1-1-本课程的学习要求"><a href="#1-1-本课程的学习要求" class="headerlink" title="1.1 本课程的学习要求"></a>1.1 本课程的学习要求</h3><ol><li>本课程不适用于 <code>0</code> 基础的学员。</li><li>要求已经掌握了 <code>Java</code> 编程，主要技术构成：<code>Java OOP</code> 编程、<code>Java</code> 多线程编程、<code>Java IO</code> 编程、<code>Java</code> 网络编程、常用的 <code>Java</code> 设计模式（比如观察者模式，命令模式，职责链模式）、常用的数据结构（比如链表）。</li><li>本课程的《<code>Netty</code> 核心源码剖析章节》要求学员最好有项目开发和阅读源码的经历。</li></ol><h3 id="1-2-Netty-的介绍"><a href="#1-2-Netty-的介绍" class="headerlink" title="1.2 Netty 的介绍"></a>1.2 Netty 的介绍</h3><ol><li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li><li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li><li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li><li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li><li>要透彻理解 <code>Netty</code>，需要先学习 <code>NIO</code>，这样我们才能阅读 <code>Netty</code> 的源码。</li></ol><h3 id="1-3-Netty-的应用场景"><a href="#1-3-Netty-的应用场景" class="headerlink" title="1.3 Netty 的应用场景"></a>1.3 Netty 的应用场景</h3><h4 id="1-3-1-互联网行业"><a href="#1-3-1-互联网行业" class="headerlink" title="1.3.1 互联网行业"></a>1.3.1 互联网行业</h4><ol><li><p>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <code>RPC</code> 框架必不可少，<code>Netty</code> 作为异步高性能的通信框架，往往作为基础通信组件被这些 <code>RPC</code> 框架使用。</p></li><li><p>典型的应用有：阿里分布式服务框架 <code>Dubbo</code> 的 <code>RPC</code> 框 架使用 <code>Dubbo</code> 协议进行节点间通信，<code>Dubbo</code> 协议默认使用 <code>Netty</code> 作为基础通信组件，用于实现各进程节点之间的内部通信。</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_01.png" alt></p></li></ol><h4 id="1-3-2-游戏行业"><a href="#1-3-2-游戏行业" class="headerlink" title="1.3.2 游戏行业"></a>1.3.2 游戏行业</h4><ol><li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用。</li><li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器。</li><li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信。</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_02.png" alt></p><p>​                    <img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_03.png" alt></p><h4 id="1-3-3-大数据领域"><a href="#1-3-3-大数据领域" class="headerlink" title="1.3.3 大数据领域"></a>1.3.3 大数据领域</h4><ol><li>经典的 <code>Hadoop</code> 的高性能通信和序列化组件 <code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信。</li><li>它的 <code>NettyService</code> 基于 <code>Netty</code> 框架二次封装实现。</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_04.png" alt></p><h4 id="1-3-4-其他开源项目使用到-Netty"><a href="#1-3-4-其他开源项目使用到-Netty" class="headerlink" title="1.3.4 其他开源项目使用到 Netty"></a>1.3.4 其他开源项目使用到 Netty</h4><p>网址：<a href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a></p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_05.png" alt></p><h3 id="1-4-Netty-的学习资料的参考"><a href="#1-4-Netty-的学习资料的参考" class="headerlink" title="1.4 Netty 的学习资料的参考"></a>1.4 Netty 的学习资料的参考</h3><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/59141c1dN7a93c127.jpg" alt></p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/555080b2Ne6cbf9e3.jpg" alt></p><h2 id="2-Java-BIO-编程"><a href="#2-Java-BIO-编程" class="headerlink" title="2 Java BIO 编程"></a>2 Java BIO 编程</h2><h3 id="2-1-I-O-模型"><a href="#2-1-I-O-模型" class="headerlink" title="2.1 I/O 模型"></a>2.1 I/O 模型</h3><h4 id="2-1-1-模型基本说明"><a href="#2-1-1-模型基本说明" class="headerlink" title="2.1.1 模型基本说明"></a>2.1.1 模型基本说明</h4><ol><li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li><li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li><li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_01.png" alt></p><ol start="4"><li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_02.png" alt></p><ol start="5"><li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li></ol><h3 id="2-2-BIO、NIO、AIO-使用场景分析"><a href="#2-2-BIO、NIO、AIO-使用场景分析" class="headerlink" title="2.2  BIO、NIO、AIO 使用场景分析"></a>2.2  BIO、NIO、AIO 使用场景分析</h3><ol><li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li><li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li><li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li></ol><h3 id="2-3-Java-BIO-的基本介绍"><a href="#2-3-Java-BIO-的基本介绍" class="headerlink" title="2.3 Java BIO 的基本介绍"></a>2.3 Java BIO 的基本介绍</h3><ol><li><code>Java BIO</code>就是传统的<code>Java I/O</code>编程，其相关的类和接口在<code>java.io</code>。</li><li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户端连接服务器）。</li><li><code>BIO</code>方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code>以前的唯一选择，程序简易理解。</li></ol><h3 id="2-4-Java-BIO-的工作机制"><a href="#2-4-Java-BIO-的工作机制" class="headerlink" title="2.4 Java BIO 的工作机制"></a>2.4 Java BIO 的工作机制</h3><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_03.png" alt></p><p>对<code>BIO</code>编程流程的梳理</p><ol><li>服务器端启动一个<code>ServerSocket</code>。</li><li>客户端启动<code>Socket</code>对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通信。</li><li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li><li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li></ol><h3 id="2-5-Java-BIO-应用实例"><a href="#2-5-Java-BIO-应用实例" class="headerlink" title="2.5 Java BIO 应用实例"></a>2.5 Java BIO 应用实例</h3><p>实例说明：</p><ol><li><p>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</p></li><li><p>要求使用线程池机制改善，可以连接多个客户端。</p></li><li><p>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</p></li><li><p>代码演示</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.bio;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.net.ServerSocket;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIOServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 线程池机制</span>        <span class="hljs-comment">// 思路</span>        <span class="hljs-comment">// 1. 创建一个线程池</span>        <span class="hljs-comment">// 2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span>        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        <span class="hljs-comment">// 创建 ServerSocket</span>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);        System.out.println(<span class="hljs-string">&quot;服务器启动了&quot;</span>);        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());            <span class="hljs-comment">// 监听，等待客户端连接</span>            System.out.println(<span class="hljs-string">&quot;等待连接....&quot;</span>);            <span class="hljs-keyword">final</span> Socket socket = serverSocket.accept();            System.out.println(<span class="hljs-string">&quot;连接到一个客户端&quot;</span>);            <span class="hljs-comment">// 就创建一个线程，与之通讯(单独写一个方法)</span>            newCachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 我们重写</span>                    <span class="hljs-comment">// 可以和客户端通讯</span>                    handler(socket);                &#125;            &#125;);        &#125;    &#125;    <span class="hljs-comment">// 编写一个handler方法，和客户端通讯</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Socket socket)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];            <span class="hljs-comment">// 通过socket获取输入流</span>            InputStream inputStream = socket.getInputStream();            <span class="hljs-comment">// 循环的读取客户端发送的数据</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());                System.out.println(<span class="hljs-string">&quot;read....&quot;</span>);                <span class="hljs-keyword">int</span> read = inputStream.read(bytes);                <span class="hljs-keyword">if</span> (read != -<span class="hljs-number">1</span>) &#123;                    System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));<span class="hljs-comment">// 输出客户端发送的数据</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(<span class="hljs-string">&quot;关闭和client的连接&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                socket.close();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre></div></li></ol><h3 id="2-6-Java-BIO-问题分析"><a href="#2-6-Java-BIO-问题分析" class="headerlink" title="2.6 Java BIO 问题分析"></a>2.6 Java BIO 问题分析</h3><ol><li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li></ol><h2 id="3-Java-NIO-编程"><a href="#3-Java-NIO-编程" class="headerlink" title="3 Java NIO 编程"></a>3 Java NIO 编程</h2><h3 id="3-1-Java-NIO-基本介绍"><a href="#3-1-Java-NIO-基本介绍" class="headerlink" title="3.1 Java NIO 基本介绍"></a>3.1 Java NIO 基本介绍</h3><ol><li><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong>，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li><li><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li><li><code>NIO</code> 有三大核心部分：<strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</li><li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li><li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li><li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li><li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li><li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.nio.IntBuffer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicBuffer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//举例说明 Buffer 的使用(简单说明)</span>        <span class="hljs-comment">//创建一个 Buffer，大小为 5，即可以存放 5 个 int</span>        IntBuffer intBuffer = IntBuffer.allocate(<span class="hljs-number">5</span>);        <span class="hljs-comment">//向buffer存放数据</span>        <span class="hljs-comment">//intBuffer.put(10);</span>        <span class="hljs-comment">//intBuffer.put(11);</span>        <span class="hljs-comment">//intBuffer.put(12);</span>        <span class="hljs-comment">//intBuffer.put(13);</span>        <span class="hljs-comment">//intBuffer.put(14);</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;            intBuffer.put(i * <span class="hljs-number">2</span>);        &#125;        <span class="hljs-comment">//如何从 buffer 读取数据</span>        <span class="hljs-comment">//将 buffer 转换，读写切换(!!!)</span>        intBuffer.flip();        <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;            System.out.println(intBuffer.get());        &#125;    &#125;&#125;</code></pre></div><h3 id="3-2-NIO-和-BIO-的比较"><a href="#3-2-NIO-和-BIO-的比较" class="headerlink" title="3.2 NIO 和 BIO 的比较"></a>3.2 NIO 和 BIO 的比较</h3><ol><li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li><li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li><li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li></ol><h3 id="3-3-NIO-三大核心原理示意图"><a href="#3-3-NIO-三大核心原理示意图" class="headerlink" title="3.3 NIO 三大核心原理示意图"></a>3.3 NIO 三大核心原理示意图</h3><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p><h4 id="3-3-1-Selector、Channel-和-Buffer-关系图（简单版）"><a href="#3-3-1-Selector、Channel-和-Buffer-关系图（简单版）" class="headerlink" title="3.3.1 Selector、Channel 和 Buffer 关系图（简单版）"></a>3.3.1 Selector、Channel 和 Buffer 关系图（简单版）</h4><p>关系图的说明:</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_01.png" alt="img"></p><ol><li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li><li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li><li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li><li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li><li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li><li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li><li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li></ol><h3 id="3-4-缓冲区（Buffer）"><a href="#3-4-缓冲区（Buffer）" class="headerlink" title="3.4 缓冲区（Buffer）"></a>3.4 缓冲区（Buffer）</h3><h4 id="3-4-1-基本介绍"><a href="#3-4-1-基本介绍" class="headerlink" title="3.4.1 基本介绍"></a>3.4.1 基本介绍</h4><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_02.png" alt="img"></p><h4 id="3-4-2-Buffer-类及其子类"><a href="#3-4-2-Buffer-类及其子类" class="headerlink" title="3.4.2 Buffer 类及其子类"></a>3.4.2 Buffer 类及其子类</h4><ol><li>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_03.png" alt="img"></p><ol><li><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_05.png" alt="img"></p><ol><li><code>Buffer</code> 类相关方法一览</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_06.png" alt="img"></p><h4 id="3-4-3-ByteBuffer"><a href="#3-4-3-ByteBuffer" class="headerlink" title="3.4.3 ByteBuffer"></a>3.4.3 ByteBuffer</h4><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_07.png" alt="img"></p><h3 id="3-5-通道（Channel）"><a href="#3-5-通道（Channel）" class="headerlink" title="3.5 通道（Channel）"></a>3.5 通道（Channel）</h3><h4 id="3-5-0-基本介绍"><a href="#3-5-0-基本介绍" class="headerlink" title="3.5.0 基本介绍"></a>3.5.0 基本介绍</h4><ol><li><p><code>NIO</code> 的通道类似于流，但有些区别如下：</p><ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li></ul></li><li><p><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</p></li><li><p><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></p></li><li><p>常用的 <code>Channel</code> 类有：<strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong>。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</p></li><li><p><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</p></li><li><p>图示</p></li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_08.png" alt="img"></p><h4 id="3-5-1-FileChannel-类"><a href="#3-5-1-FileChannel-类" class="headerlink" title="3.5.1 FileChannel 类"></a>3.5.1 FileChannel 类</h4><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p><ul><li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li><li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li><li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li><li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li></ul><h4 id="3-5-2-应用实例1-本地文件写数据"><a href="#3-5-2-应用实例1-本地文件写数据" class="headerlink" title="3.5.2 应用实例1 - 本地文件写数据"></a>3.5.2 应用实例1 - 本地文件写数据</h4><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li><li>文件不存在就创建</li><li>代码演示</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        String str = <span class="hljs-string">&quot;hello,尚硅谷&quot;</span>;        <span class="hljs-comment">//创建一个输出流 -&gt; channel</span>        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d:\\file01.txt&quot;</span>);        <span class="hljs-comment">//通过 fileOutputStream 获取对应的 FileChannel</span>        <span class="hljs-comment">//这个 fileChannel 真实类型是 FileChannelImpl</span>        FileChannel fileChannel = fileOutputStream.getChannel();        <span class="hljs-comment">//创建一个缓冲区 ByteBuffer</span>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        <span class="hljs-comment">//将 str 放入 byteBuffer</span>        byteBuffer.put(str.getBytes());        <span class="hljs-comment">//对 byteBuffer 进行 flip</span>        byteBuffer.flip();        <span class="hljs-comment">//将 byteBuffer 数据写入到 fileChannel</span>        fileChannel.write(byteBuffer);        fileOutputStream.close();    &#125;&#125;</code></pre></div><h4 id="3-5-3-应用实例2-本地文件读数据"><a href="#3-5-3-应用实例2-本地文件读数据" class="headerlink" title="3.5.3 应用实例2 - 本地文件读数据"></a>3.5.3 应用实例2 - 本地文件读数据</h4><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li><li>假定文件已经存在</li><li>代码演示</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建文件的输入流</span>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\file01.txt&quot;</span>);        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);                <span class="hljs-comment">//通过 fileInputStream 获取对应的 FileChannel -&gt; 实际类型 FileChannelImpl</span>        FileChannel fileChannel = fileInputStream.getChannel();                <span class="hljs-comment">//创建缓冲区</span>        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="hljs-keyword">int</span>)file.length());                <span class="hljs-comment">//将通道的数据读入到 Buffer</span>        fileChannel.read(byteBuffer);                <span class="hljs-comment">//将 byteBuffer 的字节数据转成 String</span>        System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array()));        fileInputStream.close();    &#125;&#125;</code></pre></div><h4 id="3-5-4-应用实例3-使用一个-Buffer-完成文件读取、写入"><a href="#3-5-4-应用实例3-使用一个-Buffer-完成文件读取、写入" class="headerlink" title="3.5.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入"></a>3.5.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入</h4><p>实例要求：</p><ol><li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li><li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li><li>代码演示</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_09.png" alt="img"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel03</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;1.txt&quot;</span>);        FileChannel fileChannel01 = fileInputStream.getChannel();        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;2.txt&quot;</span>);        FileChannel fileChannel02 = fileOutputStream.getChannel();        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123; <span class="hljs-comment">//循环读取</span>            <span class="hljs-comment">//这里有一个重要的操作，一定不要忘了</span>            <span class="hljs-comment">/*</span><span class="hljs-comment">            public final Buffer clear() &#123;</span><span class="hljs-comment">                position = 0;</span><span class="hljs-comment">                limit = capacity;</span><span class="hljs-comment">                mark = -1;</span><span class="hljs-comment">                return this;</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">            */</span>            byteBuffer.clear(); <span class="hljs-comment">//清空 buffer</span>            <span class="hljs-keyword">int</span> read = fileChannel01.read(byteBuffer);            System.out.println(<span class="hljs-string">&quot;read = &quot;</span> + read);            <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//表示读完</span>                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//将 buffer 中的数据写入到 fileChannel02--2.txt</span>            byteBuffer.flip();            fileChannel02.write(byteBuffer);        &#125;        <span class="hljs-comment">//关闭相关的流</span>        fileInputStream.close();        fileOutputStream.close();    &#125;&#125;</code></pre></div><h4 id="3-5-5-应用实例4-拷贝文件-transferFrom-方法"><a href="#3-5-5-应用实例4-拷贝文件-transferFrom-方法" class="headerlink" title="3.5.5 应用实例4 - 拷贝文件 transferFrom 方法"></a>3.5.5 应用实例4 - 拷贝文件 transferFrom 方法</h4><ol><li>实例要求：</li><li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li><li>拷贝一张图片</li><li>代码演示</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel04</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建相关流</span>        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\a.jpg&quot;</span>);        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d:\\a2.jpg&quot;</span>);                <span class="hljs-comment">//获取各个流对应的 FileChannel</span>        FileChannel sourceCh = fileInputStream.getChannel();        FileChannel destCh = fileOutputStream.getChannel();        <span class="hljs-comment">//使用 transferForm 完成拷贝</span>        destCh.transferFrom(sourceCh, <span class="hljs-number">0</span>, sourceCh.size());        <span class="hljs-comment">//关闭相关通道和流</span>        sourceCh.close();        destCh.close();        fileInputStream.close();        fileOutputStream.close();    &#125;&#125;</code></pre></div><h4 id="3-5-6-关于-Buffer-和-Channel-的注意事项和细节"><a href="#3-5-6-关于-Buffer-和-Channel-的注意事项和细节" class="headerlink" title="3.5.6 关于 Buffer 和 Channel 的注意事项和细节"></a>3.5.6 关于 Buffer 和 Channel 的注意事项和细节</h4><ol><li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOByteBufferPutGet</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                <span class="hljs-comment">//创建一个 Buffer</span>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);        <span class="hljs-comment">//类型化方式放入数据</span>        buffer.putInt(<span class="hljs-number">100</span>);        buffer.putLong(<span class="hljs-number">9</span>);        buffer.putChar(<span class="hljs-string">&#x27;尚&#x27;</span>);        buffer.putShort((<span class="hljs-keyword">short</span>) <span class="hljs-number">4</span>);        <span class="hljs-comment">//取出</span>        buffer.flip();                System.out.println();                System.out.println(buffer.getInt());        System.out.println(buffer.getLong());        System.out.println(buffer.getChar());        System.out.println(buffer.getShort());    &#125;&#125;</code></pre></div><ol start="2"><li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadOnlyBuffer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建一个 buffer</span>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;            buffer.put((<span class="hljs-keyword">byte</span>) i);        &#125;        <span class="hljs-comment">//读取</span>        buffer.flip();        <span class="hljs-comment">//得到一个只读的 Buffer</span>        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();        System.out.println(readOnlyBuffer.getClass());        <span class="hljs-comment">//读取</span>        <span class="hljs-keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123;            System.out.println(readOnlyBuffer.get());        &#125;        readOnlyBuffer.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">100</span>); <span class="hljs-comment">//ReadOnlyBufferException</span>    &#125;&#125;</code></pre></div><ol start="3"><li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.io.RandomAccessFile;<span class="hljs-keyword">import</span> java.nio.MappedByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MappedByteBufferTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        RandomAccessFile randomAccessFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);        <span class="hljs-comment">//获取对应的通道</span>        FileChannel channel = randomAccessFile.getChannel();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式</span><span class="hljs-comment">         * 参数 2：0：可以直接修改的起始位置</span><span class="hljs-comment">         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span><span class="hljs-comment">         * 可以直接修改的范围就是 0-5</span><span class="hljs-comment">         * 实际类型 DirectByteBuffer</span><span class="hljs-comment">         */</span>        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);        mappedByteBuffer.put(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;H&#x27;</span>);        mappedByteBuffer.put(<span class="hljs-number">3</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;9&#x27;</span>);        mappedByteBuffer.put(<span class="hljs-number">5</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;Y&#x27;</span>);<span class="hljs-comment">//IndexOutOfBoundsException</span>        randomAccessFile.close();        System.out.println(<span class="hljs-string">&quot;修改成功~~&quot;</span>);    &#125;&#125;</code></pre></div><ol start="4"><li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.net.InetSocketAddress;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]</span><span class="hljs-comment"> * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScatteringAndGatheringTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span>        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7000</span>);        <span class="hljs-comment">//绑定端口到 socket，并启动</span>        serverSocketChannel.socket().bind(inetSocketAddress);        <span class="hljs-comment">//创建 buffer 数组</span>        ByteBuffer[] byteBuffers = <span class="hljs-keyword">new</span> ByteBuffer[<span class="hljs-number">2</span>];        byteBuffers[<span class="hljs-number">0</span>] = ByteBuffer.allocate(<span class="hljs-number">5</span>);        byteBuffers[<span class="hljs-number">1</span>] = ByteBuffer.allocate(<span class="hljs-number">3</span>);        <span class="hljs-comment">//等客户端连接 (telnet)</span>        SocketChannel socketChannel = serverSocketChannel.accept();        <span class="hljs-keyword">int</span> messageLength = <span class="hljs-number">8</span>; <span class="hljs-comment">//假定从客户端接收 8 个字节</span>        <span class="hljs-comment">//循环的读取</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">int</span> byteRead = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (byteRead &lt; messageLength) &#123;                <span class="hljs-keyword">long</span> l = socketChannel.read(byteBuffers);                byteRead += l; <span class="hljs-comment">//累计读取的字节数</span>                System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead);                <span class="hljs-comment">//使用流打印,看看当前的这个 buffer 的 position 和 limit</span>                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="hljs-string">&quot;position = &quot;</span> + buffer.position() + <span class="hljs-string">&quot;, limit = &quot;</span> + buffer.limit()).forEach(System.out::println);            &#125;            <span class="hljs-comment">//将所有的 buffer 进行 flip</span>            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());            <span class="hljs-comment">//将数据读出显示到客户端</span>            <span class="hljs-keyword">long</span> byteWirte = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (byteWirte &lt; messageLength) &#123;                <span class="hljs-keyword">long</span> l = socketChannel.write(byteBuffers);<span class="hljs-comment">//</span>                byteWirte += l;            &#125;                        <span class="hljs-comment">//将所有的buffer进行clear</span>            Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123;                buffer.clear();            &#125;);                        System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead + <span class="hljs-string">&quot;, byteWrite = &quot;</span> + byteWirte + <span class="hljs-string">&quot;, messagelength = &quot;</span> + messageLength);        &#125;    &#125;&#125;</code></pre></div><h3 id="3-6-Selector（选择器）"><a href="#3-6-Selector（选择器）" class="headerlink" title="3.6 Selector（选择器）"></a>3.6 Selector（选择器）</h3><h4 id="3-6-1-基本介绍"><a href="#3-6-1-基本介绍" class="headerlink" title="3.6.1 基本介绍"></a>3.6.1 基本介绍</h4><ol><li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li><li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</li><li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li><li>避免了多线程之间的上下文切换导致的开销。</li></ol><h4 id="3-6-2-Selector-示意图和特点说明"><a href="#3-6-2-Selector-示意图和特点说明" class="headerlink" title="3.6.2 Selector 示意图和特点说明"></a>3.6.2 Selector 示意图和特点说明</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_10.png" alt="img"></p><p>说明如下：</p><ol><li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li><li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li><li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li><li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li><li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li></ol><h4 id="3-6-3-Selector-类相关方法"><a href="#3-6-3-Selector-类相关方法" class="headerlink" title="3.6.3 Selector 类相关方法"></a>3.6.3 Selector 类相关方法</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_11.png" alt="img"></p><h4 id="3-6-4-注意事项"><a href="#3-6-4-注意事项" class="headerlink" title="3.6.4 注意事项"></a>3.6.4 注意事项</h4><ol><li><p><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</p></li><li><p><code>Selector</code> 相关方法说明</p><ul><li><code>selector.select();</code> //阻塞</li><li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li><li><code>selector.wakeup();</code> //唤醒 selector</li><li><code>selector.selectNow();</code> //不阻塞，立马返还</li></ul></li></ol><h3 id="3-7-NIO-非阻塞网络编程原理分析图"><a href="#3-7-NIO-非阻塞网络编程原理分析图" class="headerlink" title="3.7 NIO 非阻塞网络编程原理分析图"></a>3.7 NIO 非阻塞网络编程原理分析图</h3><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_22.png" alt="img"></p><p>对上图的说明：</p><ol><li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li><li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li><li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li><li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li><li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li><li>可以通过得到的 <code>channel</code>，完成业务处理。</li><li>代码撑腰。。。</li></ol><h3 id="3-8-NIO-非阻塞网络编程快速入门"><a href="#3-8-NIO-非阻塞网络编程快速入门" class="headerlink" title="3.8 NIO 非阻塞网络编程快速入门"></a>3.8 NIO 非阻塞网络编程快速入门</h3><p>案例要求：</p><ol><li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li><li>看老师代码演示</li></ol><h3 id="3-9-SelectionKey"><a href="#3-9-SelectionKey" class="headerlink" title="3.9 SelectionKey"></a>3.9 SelectionKey</h3><ol><li><code>SelectionKey</code>，表示 <code>Selector</code> 和网络通道的注册关系，共四种：<ul><li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li><li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li><li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li><li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li></ul></li></ol><p>源码中：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_READ = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_WRITE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_CONNECT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_ACCEPT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;</code></pre></div><ol start="2"><li><code>SelectionKey</code> 相关方法</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_12.png" alt="img"></p><h3 id="3-10-ServerSocketChannel"><a href="#3-10-ServerSocketChannel" class="headerlink" title="3.10 ServerSocketChannel"></a>3.10 ServerSocketChannel</h3><ol><li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接</li><li>相关方法如下</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_13.png" alt="img"></p><h3 id="3-11-SocketChannel"><a href="#3-11-SocketChannel" class="headerlink" title="3.11 SocketChannel"></a>3.11 SocketChannel</h3><ol><li><code>SocketChannel</code>，网络 <code>IO</code> 通道，具体负责进行读写操作。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li><li>相关方法如下</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_14.png" alt="img"></p><h3 id="3-12-NIO-网络编程应用实例-群聊系统"><a href="#3-12-NIO-网络编程应用实例-群聊系统" class="headerlink" title="3.12 NIO 网络编程应用实例 - 群聊系统"></a>3.12 NIO 网络编程应用实例 - 群聊系统</h3><p>实例要求：</p><ol><li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li><li>示意图分析和代码</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_15.png" alt="img"></p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 服务端：</span><span class="hljs-keyword">package</span> com.atguigu.nio.groupchat;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.net.InetSocketAddress;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.Channel;<span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<span class="hljs-keyword">import</span> java.nio.channels.Selector;<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<span class="hljs-keyword">import</span> java.util.Iterator;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>&#123;    <span class="hljs-comment">//定义属性</span>    <span class="hljs-keyword">private</span> Selector selector;    <span class="hljs-keyword">private</span> ServerSocketChannel listenChannel;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;    <span class="hljs-comment">//构造器</span>    <span class="hljs-comment">//初始化工作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//得到选择器</span>            selector = Selector.open();            <span class="hljs-comment">//ServerSocketChannel</span>            listenChannel = ServerSocketChannel.open();            <span class="hljs-comment">//绑定端口</span>            listenChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(PORT));            <span class="hljs-comment">//设置非阻塞模式</span>            listenChannel.configureBlocking(<span class="hljs-keyword">false</span>);            <span class="hljs-comment">//将该 listenChannel 注册到 selector</span>            listenChannel.register(selector, SelectionKey.OP_ACCEPT);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//循环处理</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">int</span> count = selector.select();                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//有事件处理</span>                    <span class="hljs-comment">// 遍历得到 selectionKey 集合</span>                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                        <span class="hljs-comment">//取出 selectionkey</span>                        SelectionKey key = iterator.next();                        <span class="hljs-comment">//监听到 accept</span>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;                            SocketChannel sc = listenChannel.accept();                            sc.configureBlocking(<span class="hljs-keyword">false</span>);                            <span class="hljs-comment">//将该 sc 注册到 seletor</span>                            sc.register(selector, SelectionKey.OP_READ);                            <span class="hljs-comment">//提示</span>                            System.out.println(sc.getRemoteAddress() + <span class="hljs-string">&quot; 上线 &quot;</span>);                        &#125;                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<span class="hljs-comment">//通道发送read事件，即通道是可读的状态</span>                            <span class="hljs-comment">// 处理读(专门写方法..)</span>                            readData(key);                        &#125;                        <span class="hljs-comment">//当前的 key 删除，防止重复处理</span>                        iterator.remove();                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    System.out.println(<span class="hljs-string">&quot;等待....&quot;</span>);                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//发生异常处理....</span>        &#125;    &#125;    <span class="hljs-comment">//读取客户端消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readData</span><span class="hljs-params">(SelectionKey key)</span> </span>&#123;        SocketChannel channel = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//得到 channel</span>            channel = (SocketChannel) key.channel();            <span class="hljs-comment">//创建 buffer</span>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);            <span class="hljs-keyword">int</span> count = channel.read(buffer);            <span class="hljs-comment">//根据 count 的值做处理</span>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//把缓存区的数据转成字符串</span>                String msg = <span class="hljs-keyword">new</span> String(buffer.array());                <span class="hljs-comment">//输出该消息</span>                System.out.println(<span class="hljs-string">&quot;form客户端:&quot;</span> + msg);                <span class="hljs-comment">//向其它的客户端转发消息(去掉自己),专门写一个方法来处理</span>                sendInfoToOtherClients(msg, channel);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-keyword">try</span> &#123;                System.out.println(channel.getRemoteAddress() + <span class="hljs-string">&quot;离线了..&quot;</span>);                <span class="hljs-comment">//取消注册</span>                key.cancel();                <span class="hljs-comment">//关闭通道</span>                channel.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e2) &#123;                e2.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-comment">//转发消息给其它客户(通道)</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfoToOtherClients</span><span class="hljs-params">(String msg, SocketChannel self)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        System.out.println(<span class="hljs-string">&quot;服务器转发消息中...&quot;</span>);        <span class="hljs-comment">//遍历所有注册到 selector 上的 SocketChannel,并排除 self</span>        <span class="hljs-keyword">for</span> (SelectionKey key : selector.keys()) &#123;            <span class="hljs-comment">//通过 key 取出对应的 SocketChannel</span>            Channel targetChannel = key.channel();            <span class="hljs-comment">//排除自己</span>            <span class="hljs-keyword">if</span> (targetChannel <span class="hljs-keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;                <span class="hljs-comment">//转型</span>                SocketChannel dest = (SocketChannel) targetChannel;                <span class="hljs-comment">//将 msg 存储到 buffer</span>                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());                <span class="hljs-comment">//将 buffer 的数据写入通道</span>                dest.write(buffer);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建服务器对象</span>        GroupChatServer groupChatServer = <span class="hljs-keyword">new</span> GroupChatServer();        groupChatServer.listen();    &#125;&#125;<span class="hljs-comment">// 客户端：</span><span class="hljs-keyword">package</span> com.atguigu.nio.groupchat;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.net.InetSocketAddress;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<span class="hljs-keyword">import</span> java.nio.channels.Selector;<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<span class="hljs-keyword">import</span> java.util.Iterator;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>&#123;    <span class="hljs-comment">//定义相关的属性</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<span class="hljs-comment">//服务器的ip</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;<span class="hljs-comment">//服务器端口</span>    <span class="hljs-keyword">private</span> Selector selector;    <span class="hljs-keyword">private</span> SocketChannel socketChannel;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-comment">//构造器,完成初始化工作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                selector = Selector.open();        <span class="hljs-comment">//连接服务器</span>        socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(HOST, PORT));        <span class="hljs-comment">//设置非阻塞</span>        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//将 channel 注册到selector</span>        socketChannel.register(selector, SelectionKey.OP_READ);        <span class="hljs-comment">//得到 username</span>        username = socketChannel.getLocalAddress().toString().substring(<span class="hljs-number">1</span>);        System.out.println(username + <span class="hljs-string">&quot; is ok...&quot;</span>);    &#125;    <span class="hljs-comment">//向服务器发送消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfo</span><span class="hljs-params">(String info)</span> </span>&#123;        info = username + <span class="hljs-string">&quot; 说：&quot;</span> + info;        <span class="hljs-keyword">try</span> &#123;            socketChannel.write(ByteBuffer.wrap(info.getBytes()));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">//读取从服务器端回复的消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">int</span> readChannels = selector.select();            <span class="hljs-keyword">if</span> (readChannels &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有可以用的通道</span>                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                    SelectionKey key = iterator.next();                    <span class="hljs-keyword">if</span> (key.isReadable()) &#123;                        <span class="hljs-comment">//得到相关的通道</span>                        SocketChannel sc = (SocketChannel) key.channel();                        <span class="hljs-comment">//得到一个 Buffer</span>                        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);                        <span class="hljs-comment">//读取</span>                        sc.read(buffer);                        <span class="hljs-comment">//把读到的缓冲区的数据转成字符串</span>                        String msg = <span class="hljs-keyword">new</span> String(buffer.array());                        System.out.println(msg.trim());                    &#125;                &#125;                iterator.remove(); <span class="hljs-comment">//删除当前的 selectionKey,防止重复操作</span>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span>            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//启动我们客户端</span>        GroupChatClient chatClient = <span class="hljs-keyword">new</span> GroupChatClient();        <span class="hljs-comment">//启动一个线程,每个 3 秒，读取从服务器发送数据</span>        <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    chatClient.readInfo();                    <span class="hljs-keyword">try</span> &#123;                        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;.start();        <span class="hljs-comment">//发送数据给服务器端</span>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;            String s = scanner.nextLine();            chatClient.sendInfo(s);        &#125;    &#125;&#125;</code></pre></div><h3 id="3-13-NIO-与零拷贝"><a href="#3-13-NIO-与零拷贝" class="headerlink" title="3.13 NIO 与零拷贝"></a>3.13 NIO 与零拷贝</h3><h4 id="3-13-1-零拷贝基本介绍"><a href="#3-13-1-零拷贝基本介绍" class="headerlink" title="3.13.1 零拷贝基本介绍"></a>3.13.1 零拷贝基本介绍</h4><ol><li>零拷贝是网络编程的关键，很多性能优化都离不开。</li><li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li><li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li></ol><h4 id="3-13-2-传统-IO-数据读写"><a href="#3-13-2-传统-IO-数据读写" class="headerlink" title="3.13.2 传统 IO 数据读写"></a>3.13.2 传统 IO 数据读写</h4><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p><div class="code-wrapper"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(file, <span class="hljs-string">&quot;rw&quot;</span>);<span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) file.length()];raf.read(arr);Socket socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>).accept();socket.getOutputStream().write(arr);</code></pre></div><h4 id="3-13-3-传统-IO-模型"><a href="#3-13-3-传统-IO-模型" class="headerlink" title="3.13.3 传统 IO 模型"></a>3.13.3 传统 IO 模型</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_17.png" alt="img"></p><p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p><h4 id="3-13-4-mmap-优化"><a href="#3-13-4-mmap-优化" class="headerlink" title="3.13.4 mmap 优化"></a>3.13.4 mmap 优化</h4><ol><li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li><li><code>mmap</code> 示意图</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_18.png" alt="img"></p><h4 id="3-13-5-sendFile-优化"><a href="#3-13-5-sendFile-优化" class="headerlink" title="3.13.5 sendFile 优化"></a>3.13.5 sendFile 优化</h4><ol><li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li><li>示意图和小结</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_19.png" alt="img"></p><ol start="3"><li><p>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</p></li><li><p><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</p></li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_20.png" alt="img"></p><ol start="5"><li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li></ol><h4 id="3-13-6-零拷贝的再次理解"><a href="#3-13-6-零拷贝的再次理解" class="headerlink" title="3.13.6 零拷贝的再次理解"></a>3.13.6 零拷贝的再次理解</h4><ol><li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li><li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li></ol><h4 id="3-13-7-mmap-和-sendFile-的区别"><a href="#3-13-7-mmap-和-sendFile-的区别" class="headerlink" title="3.13.7 mmap 和 sendFile 的区别"></a>3.13.7 mmap 和 sendFile 的区别</h4><ol><li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li><li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li><li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li></ol><h4 id="3-13-8-NIO-零拷贝案例"><a href="#3-13-8-NIO-零拷贝案例" class="headerlink" title="3.13.8 NIO 零拷贝案例"></a>3.13.8 NIO 零拷贝案例</h4><p>案例要求：</p><ol><li>使用传统的 <code>IO</code> 方法传递一个大文件</li><li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li><li>看看两种传递方式耗时时间分别是多少</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio.zerocopy;<span class="hljs-keyword">import</span> java.net.InetSocketAddress;<span class="hljs-keyword">import</span> java.net.ServerSocket;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<span class="hljs-comment">//服务器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7001</span>);        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        ServerSocket serverSocket = serverSocketChannel.socket();        serverSocket.bind(address);        <span class="hljs-comment">//创建buffer</span>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">4096</span>);        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            SocketChannel socketChannel = serverSocketChannel.accept();            <span class="hljs-keyword">int</span> readcount = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (-<span class="hljs-number">1</span> != readcount) &#123;                <span class="hljs-keyword">try</span> &#123;                    readcount = socketChannel.read(byteBuffer);                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;                    <span class="hljs-comment">// ex.printStackTrace();</span>                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">//</span>                byteBuffer.rewind(); <span class="hljs-comment">//倒带 position = 0 mark 作废</span>            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.nio.zerocopy;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.net.InetSocketAddress;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SocketChannel socketChannel = SocketChannel.open();        socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">7001</span>));        String filename = <span class="hljs-string">&quot;protoc-3.6.1-win32.zip&quot;</span>;        <span class="hljs-comment">//得到一个文件channel</span>        FileChannel fileChannel = <span class="hljs-keyword">new</span> FileInputStream(filename).getChannel();        <span class="hljs-comment">//准备发送</span>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();        <span class="hljs-comment">//在 linux 下一个 transferTo 方法就可以完成传输</span>        <span class="hljs-comment">//在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要</span>        <span class="hljs-comment">//传输时的位置=》课后思考...</span>        <span class="hljs-comment">//transferTo 底层使用到零拷贝</span>        <span class="hljs-keyword">long</span> transferCount = fileChannel.transferTo(<span class="hljs-number">0</span>, fileChannel.size(), socketChannel);        System.out.println(<span class="hljs-string">&quot;发送的总的字节数 = &quot;</span> + transferCount + <span class="hljs-string">&quot; 耗时: &quot;</span> + (System.currentTimeMillis() - startTime));        <span class="hljs-comment">//关闭</span>        fileChannel.close();    &#125;&#125;</code></pre></div><h3 id="3-14-Java-AIO-基本介绍"><a href="#3-14-Java-AIO-基本介绍" class="headerlink" title="3.14 Java AIO 基本介绍"></a>3.14 Java AIO 基本介绍</h3><ol><li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li><li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li><li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li></ol><h3 id="3-15-BIO、NIO、AIO-对比表"><a href="#3-15-BIO、NIO、AIO-对比表" class="headerlink" title="3.15 BIO、NIO、AIO 对比表"></a>3.15 BIO、NIO、AIO 对比表</h3><table><thead><tr><th></th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>IO模型</td><td>同步阻塞</td><td>同步非阻塞（多路复用）</td><td>异步非阻塞</td></tr><tr><td>编程难度</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>可靠性</td><td>差</td><td>好</td><td>好</td></tr><tr><td>吞吐量</td><td>低</td><td>高</td><td>高</td></tr></tbody></table><p><strong>举例说明</strong></p><ol><li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li><li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li><li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li></ol><h2 id="4-Netty-概述"><a href="#4-Netty-概述" class="headerlink" title="4 Netty 概述"></a>4 Netty 概述</h2><h3 id="4-1-原生-NIO-存在的问题"><a href="#4-1-原生-NIO-存在的问题" class="headerlink" title="4.1 原生 NIO 存在的问题"></a>4.1 原生 NIO 存在的问题</h3><ol><li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li><li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li><li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。4. <code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决。</li></ol><h3 id="4-2-Netty-官网说明"><a href="#4-2-Netty-官网说明" class="headerlink" title="4.2 Netty 官网说明"></a>4.2 Netty 官网说明</h3><p>官网：<a href="https://netty.io/">https://netty.io/</a></p><p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter04_01.png" alt="img"></p><h3 id="4-3-Netty-的优点"><a href="#4-3-Netty-的优点" class="headerlink" title="4.3 Netty 的优点"></a>4.3 Netty 的优点</h3><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p><ol><li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li><li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li><li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li><li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li><li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li></ol><h3 id="4-4-Netty-版本说明"><a href="#4-4-Netty-版本说明" class="headerlink" title="4.4 Netty 版本说明"></a>4.4 Netty 版本说明</h3><ol><li><p><code>Netty</code> 版本分为 <code>Netty 3.x</code> 和 <code>Netty 4.x</code>、<code>Netty 5.x</code></p></li><li><p>因为 <code>Netty 5</code> 出现重大 <code>bug</code>，已经被官网废弃了，目前推荐使用的是 <code>Netty 4.x</code>的稳定版本</p></li><li><p>目前在官网可下载的版本 <code>Netty 3.x</code>、<code>Netty 4.0.x</code> 和 <code>Netty 4.1.x</code></p></li><li><p>在本套课程中，我们讲解 <code>Netty4.1.x</code> 版本</p></li><li><p><code>Netty</code> 下载地址：<a href="https://bintray.com/netty/downloads/netty/">https://bintray.com/netty/downloads/netty/</a></p></li><li><p>maven</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.netty/netty-all --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.42.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li></ol><h2 id="5-Netty-高性能架构设计"><a href="#5-Netty-高性能架构设计" class="headerlink" title="5  Netty 高性能架构设计"></a>5  Netty 高性能架构设计</h2><h3 id="5-1-线程模型基本介绍"><a href="#5-1-线程模型基本介绍" class="headerlink" title="5.1 线程模型基本介绍"></a>5.1 线程模型基本介绍</h3><ol><li>不同的线程模式，对程序的性能有很大影响，为了搞清 <code>Netty</code> 线程模式，我们来系统的讲解下各个线程模式，最后看看 <code>Netty</code> 线程模型有什么优越性。</li><li>目前存在的线程模型有：传统阻塞 <code>I/O</code> 服务模型 <code>Reactor</code> 模式</li><li>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现单 <code>Reactor</code> 单线程；单 <code>Reactor</code>多线程；主从 <code>Reactor</code>多线程</li><li><code>Netty</code> 线程模式（<code>Netty</code> 主要基于主从 <code>Reactor</code> 多线程模型做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>）</li></ol><h3 id="5-2-传统阻塞-I-O-服务模型"><a href="#5-2-传统阻塞-I-O-服务模型" class="headerlink" title="5.2 传统阻塞 I/O 服务模型"></a>5.2 传统阻塞 I/O 服务模型</h3><h4 id="5-2-1-工作原理图"><a href="#5-2-1-工作原理图" class="headerlink" title="5.2.1 工作原理图"></a>5.2.1 工作原理图</h4><ol><li>黄色的框表示对象，蓝色的框表示线程</li><li>白色的框表示方法（<code>API</code>）</li></ol><h4 id="5-2-2-模型特点"><a href="#5-2-2-模型特点" class="headerlink" title="5.2.2 模型特点"></a>5.2.2 模型特点</h4><ol><li>采用阻塞 <code>IO</code> 模式获取输入的数据</li><li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li></ol><h4 id="5-2-3-问题分析"><a href="#5-2-3-问题分析" class="headerlink" title="5.2.3 问题分析"></a>5.2.3 问题分析</h4><ol><li>当并发数很大，就会创建大量的线程，占用很大系统资源</li><li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 <code>read</code> 操作，造成线程资源浪费</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_01.png" alt="img"></p><h3 id="5-3-Reactor-模式"><a href="#5-3-Reactor-模式" class="headerlink" title="5.3 Reactor 模式"></a>5.3 Reactor 模式</h3><h4 id="5-3-1-针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案："><a href="#5-3-1-针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案：" class="headerlink" title="5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案："></a>5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</h4><ol><li>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理 <code>Reactor</code> 对应的叫法：<ol><li>反应器模式</li><li>分发者模式（Dispatcher）</li><li>通知者模式（notifier）</li></ol></li><li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_02.png" alt="img"></p><h4 id="5-3-2-I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图"><a href="#5-3-2-I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图" class="headerlink" title="5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图"></a>5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_03.png" alt="img"></p><p>对上图说明：</p><ol><li><code>Reactor</code> 模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li><li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 <code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式</li><li><code>Reactor</code> 模式使用 <code>IO</code> 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li></ol><h4 id="5-3-3-Reactor-模式中核心组成"><a href="#5-3-3-Reactor-模式中核心组成" class="headerlink" title="5.3.3 Reactor 模式中核心组成"></a>5.3.3 Reactor 模式中核心组成</h4><ol><li><code>Reactor</code>：<code>Reactor</code> 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 <code>IO</code> 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li><li><code>Handlers</code>：处理程序执行 <code>I/O</code> 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code> 通过调度适当的处理程序来响应 <code>I/O</code> 事件，处理程序执行非阻塞操作。</li></ol><h4 id="5-3-4-Reactor-模式分类"><a href="#5-3-4-Reactor-模式分类" class="headerlink" title="5.3.4 Reactor 模式分类"></a>5.3.4 Reactor 模式分类</h4><p>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现</p><ol><li>单 <code>Reactor</code> 单线程</li><li>单 <code>Reactor</code> 多线程</li><li>主从 <code>Reactor</code> 多线程</li></ol><h3 id="5-4-单-Reactor-单线程"><a href="#5-4-单-Reactor-单线程" class="headerlink" title="5.4 单 Reactor 单线程"></a>5.4 单 Reactor 单线程</h3><p>原理图，并使用 <code>NIO</code> 群聊系统验证</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_04.png" alt="img"></p><h4 id="5-4-1-方案说明"><a href="#5-4-1-方案说明" class="headerlink" title="5.4.1 方案说明"></a>5.4.1 方案说明</h4><ol><li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 <code>API</code>，可以实现应用程序通过一个阻塞对象监听多路连接请求</li><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li><li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li><li><code>Handler</code> 会完成 <code>Read</code> → 业务处理 → <code>Send</code> 的完整业务流程</li></ol><p>结合实例：服务器端用一个线程通过多路复用搞定所有的 <code>IO</code> 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 <code>NIO</code> 案例就属于这种模型。</p><h4 id="5-4-2-方案优缺点分析"><a href="#5-4-2-方案优缺点分析" class="headerlink" title="5.4.2 方案优缺点分析"></a>5.4.2 方案优缺点分析</h4><ol><li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li><li>缺点：性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li><li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li><li>使用场景：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code> 在业务处理的时间复杂度 <code>O(1)</code> 的情况</li></ol><h3 id="5-5-单-Reactor-多线程"><a href="#5-5-单-Reactor-多线程" class="headerlink" title="5.5 单 Reactor 多线程"></a>5.5 单 Reactor 多线程</h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_05.png" alt="img"></p><h4 id="5-5-1-原理图"><a href="#5-5-1-原理图" class="headerlink" title="5.5.1 原理图"></a>5.5.1 原理图</h4><h4 id="5-5-2-对上图的小结"><a href="#5-5-2-对上图的小结" class="headerlink" title="5.5.2 对上图的小结"></a>5.5.2 对上图的小结</h4><ol><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后，通过 <code>Dispatch</code> 进行分发</li><li>如果建立连接请求，则右 <code>Acceptor</code> 通过 <code>accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理</li><li><code>handler</code> 只负责响应事件，不做具体的业务处理，通过 <code>read</code> 读取数据后，会分发给后面的 <code>worker</code> 线程池的某个线程处理业务</li><li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给 <code>handler</code></li><li><code>handler</code> 收到响应后，通过 <code>send</code> 将结果返回给 <code>client</code></li></ol><h4 id="5-5-3-方案优缺点分析"><a href="#5-5-3-方案优缺点分析" class="headerlink" title="5.5.3 方案优缺点分析"></a>5.5.3 方案优缺点分析</h4><ol><li>优点：可以充分的利用多核 <code>cpu</code> 的处理能力</li><li>缺点：多线程数据共享和访问比较复杂，<code>Reactor</code> 处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</li></ol><h3 id="5-6-主从-Reactor-多线程"><a href="#5-6-主从-Reactor-多线程" class="headerlink" title="5.6 主从 Reactor 多线程"></a>5.6 主从 Reactor 多线程</h3><h4 id="5-6-1-工作原理图"><a href="#5-6-1-工作原理图" class="headerlink" title="5.6.1 工作原理图"></a>5.6.1 工作原理图</h4><p>针对单 <code>Reactor</code> 多线程模型中，<code>Reactor</code> 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 <code>Reactor</code> 在多线程中运行</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_06.png" alt="img"></p><h4 id="5-6-2-上图的方案说明"><a href="#5-6-2-上图的方案说明" class="headerlink" title="5.6.2 上图的方案说明"></a>5.6.2 上图的方案说明</h4><ol><li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件</li><li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code></li><li><code>subreactor</code> 将连接加入到连接队列进行监听，并创建 <code>handler</code> 进行各种事件处理</li><li>当有新事件发生时，<code>subreactor</code> 就会调用对应的 <code>handler</code> 处理</li><li><code>handler</code> 通过 <code>read</code> 读取数据，分发给后面的 <code>worker</code> 线程处理</li><li><code>worker</code> 线程池分配独立的 <code>worker</code> 线程进行业务处理，并返回结果</li><li><code>handler</code> 收到响应的结果后，再通过 <code>send</code> 将结果返回给 <code>client</code></li><li><code>Reactor</code> 主线程可以对应多个 <code>Reactor</code> 子线程，即 <code>MainRecator</code> 可以关联多个 <code>SubReactor</code></li></ol><h4 id="5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解："><a href="#5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解：" class="headerlink" title="5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解："></a>5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解：</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_07.png" alt="img"></p><h4 id="5-6-4-方案优缺点说明"><a href="#5-6-4-方案优缺点说明" class="headerlink" title="5.6.4 方案优缺点说明"></a>5.6.4 方案优缺点说明</h4><ol><li>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li><li>优点：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据。</li><li>缺点：编程复杂度较高</li><li>结合实例：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li></ol><h3 id="5-7-Reactor-模式小结"><a href="#5-7-Reactor-模式小结" class="headerlink" title="5.7 Reactor 模式小结"></a>5.7 Reactor 模式小结</h3><h4 id="5-7-1-3-种模式用生活案例来理解"><a href="#5-7-1-3-种模式用生活案例来理解" class="headerlink" title="5.7.1 3 种模式用生活案例来理解"></a>5.7.1 3 种模式用生活案例来理解</h4><ol><li>单 <code>Reactor</code> 单线程，前台接待员和服务员是同一个人，全程为顾客服务</li><li>单 <code>Reactor</code> 多线程，<code>1</code> 个前台接待员，多个服务员，接待员只负责接待</li><li>主从 <code>Reactor</code> 多线程，多个前台接待员，多个服务生</li></ol><h4 id="5-7-2-Reactor-模式具有如下的优点"><a href="#5-7-2-Reactor-模式具有如下的优点" class="headerlink" title="5.7.2 Reactor 模式具有如下的优点"></a>5.7.2 Reactor 模式具有如下的优点</h4><ol><li>响应快，不必为单个同步时间所阻塞，虽然 <code>Reactor</code> 本身依然是同步的</li><li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li><li>扩展性好，可以方便的通过增加 <code>Reactor</code> 实例个数来充分利用 <code>CPU</code> 资源</li><li>复用性好，<code>Reactor</code> 模型本身与具体事件处理逻辑无关，具有很高的复用性</li></ol><h3 id="5-8-Netty-模型"><a href="#5-8-Netty-模型" class="headerlink" title="5.8 Netty 模型"></a>5.8 Netty 模型</h3><h4 id="5-8-1-工作原理示意图-简单版"><a href="#5-8-1-工作原理示意图-简单版" class="headerlink" title="5.8.1 工作原理示意图 - 简单版"></a>5.8.1 工作原理示意图 - 简单版</h4><p>Netty主要基于<code>主从 Reactors</code> 多线程模型（如图）做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 `Reactor</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_08.png" alt="img"></p><h4 id="5-8-2-对上图说明"><a href="#5-8-2-对上图说明" class="headerlink" title="5.8.2 对上图说明"></a>5.8.2 对上图说明</h4><ol><li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code></li><li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护</li><li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 <code>handler</code>），注意 <code>handler</code> 已经加入到通道</li></ol><h4 id="5-8-3-工作原理示意图-进阶版"><a href="#5-8-3-工作原理示意图-进阶版" class="headerlink" title="5.8.3 工作原理示意图 - 进阶版"></a>5.8.3 工作原理示意图 - 进阶版</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_09.png" alt="img"></p><h4 id="5-8-4-工作原理示意图-详细版"><a href="#5-8-4-工作原理示意图-详细版" class="headerlink" title="5.8.4 工作原理示意图 - 详细版"></a>5.8.4 工作原理示意图 - 详细版</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_10.png" alt="img"></p><h4 id="5-8-5-对上图的说明小结"><a href="#5-8-5-对上图的说明小结" class="headerlink" title="5.8.5 对上图的说明小结"></a>5.8.5 对上图的说明小结</h4><ol><li><p><code>Netty</code> 抽象出两组线程池 <code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</p></li><li><p><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code></p></li><li><p><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code></p></li><li><p><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</p></li><li><p><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code></p></li><li><p>每个 循环执行的步骤有 <code>BossNioEventLoop``3</code></p><ul><li>轮询 <code>accept</code> 事件</li><li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>worker</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li><li>处理任务队列的任务，即 <code>runAllTasks</code></li></ul></li><li><p>每个 循环执行的步骤<code>Worker``NIOEventLoo</code></p><ul><li>轮询 <code>read</code>，<code>write</code> 事件</li><li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li><li>处理任务队列的任务，即 <code>runAllTasks</code></li></ul></li><li><p>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器</p></li></ol><h4 id="5-8-6-Netty-快速入门实例-TCP-服务"><a href="#5-8-6-Netty-快速入门实例-TCP-服务" class="headerlink" title="5.8.6 Netty 快速入门实例 - TCP 服务"></a>5.8.6 Netty 快速入门实例 - TCP 服务</h4><p>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</p><ol><li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，客户端能发送消息给服务器”hello,服务器~”</li><li>服务器可以回复消息给客户端”hello,客户端~”</li><li>目的：对 <code>Netty</code> 线程模型有一个初步认识，便于理解 <code>Netty</code> 模型理论</li><li>看老师代码演示 5.1 编写服务端 5.2 编写客户端 5.3 对 <code>netty</code> 程序进行分析，看看 <code>netty</code> 模型特点 说明：创建 <code>Maven</code> 项目，并引入 <code>Netty</code> 包</li><li>代码如下</li></ol><div class="code-wrapper"><pre><code class="hljs java">NettyServer.java<span class="hljs-keyword">package</span> com.atguigu.netty.simple;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFutureListener;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-comment">//创建BossGroup 和 WorkerGroup</span>        <span class="hljs-comment">//说明</span>        <span class="hljs-comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span>        <span class="hljs-comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span>        <span class="hljs-comment">//3. 两个都是无限循环</span>        <span class="hljs-comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span>        <span class="hljs-comment">//   默认实际 cpu核数 * 2</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8</span>                <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建服务器端的启动对象，配置参数</span>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            <span class="hljs-comment">//使用链式编程来进行设置</span>            bootstrap.group(bossGroup, workerGroup) <span class="hljs-comment">//设置两个线程组</span>                    .channel(NioServerSocketChannel.class) <span class="hljs-comment">//使用NioSocketChannel 作为服务器的通道实现</span>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>) <span class="hljs-comment">// 设置线程队列得到连接个数</span>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>) <span class="hljs-comment">//设置保持活动连接状态</span>            <span class="hljs-comment">//          .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="hljs-comment">//创建一个通道初始化对象(匿名对象)</span>                        <span class="hljs-comment">//给pipeline 设置处理器</span>                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            System.out.println(<span class="hljs-string">&quot;客户socketchannel hashcode=&quot;</span> + ch.hashCode()); <span class="hljs-comment">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());                        &#125;                    &#125;); <span class="hljs-comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span>            System.out.println(<span class="hljs-string">&quot;.....服务器 is ready...&quot;</span>);            <span class="hljs-comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span>            <span class="hljs-comment">//启动服务器(并绑定端口)</span>            ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();            <span class="hljs-comment">//给cf 注册监听器，监控我们关心的事件</span>            cf.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;                        System.out.println(<span class="hljs-string">&quot;监听端口 6668 成功&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> &#123;                        System.out.println(<span class="hljs-string">&quot;监听端口 6668 失败&quot;</span>);                    &#125;                &#125;            &#125;);            <span class="hljs-comment">//对关闭通道进行监听</span>            cf.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;NettyServerHandler.java<span class="hljs-keyword">package</span> com.atguigu.netty.simple;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.Channel;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 说明</span><span class="hljs-comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span><span class="hljs-comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span><span class="hljs-comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">&quot;服务器读取线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; channle =&quot;</span> + ctx.channel());        System.out.println(<span class="hljs-string">&quot;server ctx =&quot;</span> + ctx);        System.out.println(<span class="hljs-string">&quot;看看channel 和 pipeline的关系&quot;</span>);        Channel channel = ctx.channel();        ChannelPipeline pipeline = ctx.pipeline(); <span class="hljs-comment">//本质是一个双向链接, 出站入站</span>                <span class="hljs-comment">//将 msg 转成一个 ByteBuf</span>        <span class="hljs-comment">//ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span>        ByteBuf buf = (ByteBuf) msg;        System.out.println(<span class="hljs-string">&quot;客户端发送消息是:&quot;</span> + buf.toString(CharsetUtil.UTF_8));        System.out.println(<span class="hljs-string">&quot;客户端地址:&quot;</span> + channel.remoteAddress());    &#125;    <span class="hljs-comment">//数据读取完毕</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//writeAndFlush 是 write + flush</span>        <span class="hljs-comment">//将数据写入到缓存，并刷新</span>        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));    &#125;        <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.close();    &#125;&#125;NettyClient.java<span class="hljs-keyword">package</span> com.atguigu.netty.simple;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//客户端需要一个事件循环组</span>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//创建客户端启动对象</span>            <span class="hljs-comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            <span class="hljs-comment">//设置相关参数</span>            bootstrap.group(group) <span class="hljs-comment">//设置线程组</span>                    .channel(NioSocketChannel.class) <span class="hljs-comment">// 设置客户端通道的实现类(反射)</span>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler()); <span class="hljs-comment">//加入自己的处理器</span>                        &#125;                    &#125;);                        System.out.println(<span class="hljs-string">&quot;客户端 ok..&quot;</span>);            <span class="hljs-comment">//启动客户端去连接服务器端</span>            <span class="hljs-comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6668</span>).sync();            <span class="hljs-comment">//给关闭通道进行监听</span>            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully();        &#125;    &#125;&#125;NettyClientHandler.java<span class="hljs-keyword">package</span> com.atguigu.netty.simple;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;        <span class="hljs-comment">//当通道就绪就会触发该方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;client &quot;</span> + ctx);        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, server: (&gt;^ω^&lt;)喵&quot;</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">//当通道有读取事件时，会触发</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf buf = (ByteBuf) msg;        System.out.println(<span class="hljs-string">&quot;服务器回复的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));        System.out.println(<span class="hljs-string">&quot;服务器的地址： &quot;</span> + ctx.channel().remoteAddress());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><h4 id="5-8-7-任务队列中的-Task-有-3-种典型使用场景"><a href="#5-8-7-任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="5.8.7 任务队列中的 Task 有 3 种典型使用场景"></a>5.8.7 任务队列中的 Task 有 3 种典型使用场景</h4><ol><li>用户程序自定义的普通任务【举例说明】</li><li>用户自定义定时任务</li><li>非当前 <code>Reactor</code> 线程调用 <code>Channel</code> 的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的 <code>Channel</code> 引用，然后调用 <code>Write</code> 类方法向该用户推送消息，就会进入到这种场景。最终的 <code>Write</code> 会提交到任务队列中后被异步消费</li><li>代码演示</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.simple;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 说明</span><span class="hljs-comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span><span class="hljs-comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span><span class="hljs-comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的</span>        <span class="hljs-comment">// NIOEventLoop 的 taskQueue中,</span>        <span class="hljs-comment">// 解决方案1 用户程序自定义的普通任务</span>        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;</span>, CharsetUtil.UTF_8));                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());                &#125;            &#125;        &#125;);        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵3&quot;</span>, CharsetUtil.UTF_8));                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());                &#125;            &#125;        &#125;);        <span class="hljs-comment">//解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中</span>        ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵4&quot;</span>, CharsetUtil.UTF_8));                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());                &#125;            &#125;        &#125;, <span class="hljs-number">5</span>, TimeUnit.SECONDS);        System.out.println(<span class="hljs-string">&quot;go on ...&quot;</span>);<span class="hljs-comment">//        System.out.println(&quot;服务器读取线程 &quot; + Thread.currentThread().getName() + &quot; channle =&quot; + ctx.channel());</span><span class="hljs-comment">//        System.out.println(&quot;server ctx =&quot; + ctx);</span><span class="hljs-comment">//        System.out.println(&quot;看看channel 和 pipeline的关系&quot;);</span><span class="hljs-comment">//        Channel channel = ctx.channel();</span><span class="hljs-comment">//        ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站</span><span class="hljs-comment">//        </span><span class="hljs-comment">//        //将 msg 转成一个 ByteBuf</span><span class="hljs-comment">//        //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span><span class="hljs-comment">//        ByteBuf buf = (ByteBuf) msg;</span><span class="hljs-comment">//        System.out.println(&quot;客户端发送消息是:&quot; + buf.toString(CharsetUtil.UTF_8));</span><span class="hljs-comment">//        System.out.println(&quot;客户端地址:&quot; + channel.remoteAddress());</span>    &#125;    <span class="hljs-comment">//数据读取完毕</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//writeAndFlush 是 write + flush</span>        <span class="hljs-comment">//将数据写入到缓存，并刷新</span>        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.close();    &#125;&#125;</code></pre></div><h4 id="5-8-8-方案再说明"><a href="#5-8-8-方案再说明" class="headerlink" title="5.8.8 方案再说明"></a>5.8.8 方案再说明</h4><ol><li><code>Netty</code> 抽象出两组线程池，<code>BossGroup</code> 专门负责接收客户端连接，<code>WorkerGroup</code> 专门负责网络读写操作。</li><li><code>NioEventLoop</code> 表示一个不断循环执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code>网络通道。</li><li><code>NioEventLoop</code> 内部采用串行化设计，从消息的 <strong>读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</strong>，始终由 <code>IO</code> 线程 <code>NioEventLoop</code> 负责<code>NioEventLoopGroup</code>下包含多个 <code>NioEventLoop</code></li></ol><ul><li>每个 <code>NioEventLoop</code> 中包含有一个 <code>Selector</code>，一个 <code>taskQueue</code></li><li>每个 <code>NioEventLoop</code> 的 <code>Selector</code> 上可以注册监听多个 <code>NioChannel</code></li><li>每个 <code>NioChannel</code> 只会绑定在唯一的 <code>NioEventLoop</code> 上</li><li>每个 <code>NioChannel</code> 都绑定有一个自己的 <code>ChannelPipeline</code></li></ul><h3 id="5-9-异步模型"><a href="#5-9-异步模型" class="headerlink" title="5.9 异步模型"></a>5.9 异步模型</h3><h4 id="5-9-1-基本介绍"><a href="#5-9-1-基本介绍" class="headerlink" title="5.9.1 基本介绍"></a>5.9.1 基本介绍</h4><ol><li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li><li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind、Write、Connect</code> 等操作会简单的返回一个 <code>ChannelFuture</code>。</li><li>调用者并不能立刻获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机制获得 <code>IO</code> 操作结果。</li><li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code> 返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code> 去监控方法 <code>fun</code> 的处理过程（即：<code>Future-Listener</code> 机制）</li></ol><h4 id="5-9-2-Future-说明"><a href="#5-9-2-Future-说明" class="headerlink" title="5.9.2 Future 说明"></a>5.9.2 Future 说明</h4><ol><li>表示异步的执行结果,可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</li><li><code>ChannelFuture</code> 是一个接口：<code>public interface ChannelFuture extends Future&lt;Void&gt;</code> 我们可以添加监听器，当监听的事件发生时，就会通知到监听器。案例说明</li></ol><h4 id="5-9-3-工作原理示意图"><a href="#5-9-3-工作原理示意图" class="headerlink" title="5.9.3 工作原理示意图"></a>5.9.3 工作原理示意图</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_11.png" alt="img"></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_12.png" alt="img"></p><p>说明：</p><ol><li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用 <code>future</code> 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。</li><li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。</li></ol><h4 id="5-9-4-Future-Listener-机制"><a href="#5-9-4-Future-Listener-机制" class="headerlink" title="5.9.4 Future-Listener 机制"></a>5.9.4 Future-Listener 机制</h4><ol><li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li><li>常见有如下操作<ul><li>通过 <code>isDone</code> 方法来判断当前操作是否完成；</li><li>通过 <code>isSuccess</code> 方法来判断已完成的当前操作是否成功；</li><li>通过 <code>getCause</code> 方法来获取已完成的当前操作失败的原因；</li><li>通过 <code>isCancelled</code> 方法来判断已完成的当前操作是否被取消；</li><li>通过 <code>addListener</code> 方法来注册监听器，当操作已完成（<code>isDone</code>方法返回完成），将会通知指定的监听器；如果 <code>Future</code> 对象已完成，则通知指定的监听器</li></ul></li></ol><p>举例说明 演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//绑定一个端口并且同步,生成了一个ChannelFuture对象</span><span class="hljs-comment">//启动服务器(并绑定端口)</span>ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();<span class="hljs-comment">//给cf 注册监听器，监控我们关心的事件</span>cf.addListener((ChannelFutureListener) future -&gt; &#123;    <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;        System.out.println(<span class="hljs-string">&quot;监听端口 6668 成功&quot;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        System.out.println(<span class="hljs-string">&quot;监听端口 6668 失败&quot;</span>);    &#125;&#125;);</code></pre></div><h3 id="5-10-快速入门实例-HTTP服务"><a href="#5-10-快速入门实例-HTTP服务" class="headerlink" title="5.10 快速入门实例 - HTTP服务"></a>5.10 快速入门实例 - HTTP服务</h3><ol><li>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</li><li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，浏览器发出请求 <code>http://localhost:6668/</code></li><li>服务器可以回复消息给客户端”Hello!我是服务器5”,并对特定请求资源进行过滤。</li><li>目的：<code>Netty</code> 可以做 <code>Http</code> 服务开发，并且理解 <code>Handler</code> 实例和客户端及其请求的关系。</li><li>看老师代码演示</li></ol><div class="code-wrapper"><pre><code class="hljs java">TestServer.java<span class="hljs-keyword">package</span> com.atguigu.netty.http;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServer</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="hljs-keyword">new</span> TestServerInitializer());            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">6668</span>).sync();            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;TestServerInitializer.java<span class="hljs-keyword">package</span> com.atguigu.netty.http;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//向管道加入处理器</span>        <span class="hljs-comment">//得到管道</span>        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-comment">//加入一个netty 提供的httpServerCodec codec =&gt;[coder - decoder]</span>        <span class="hljs-comment">//HttpServerCodec 说明</span>        <span class="hljs-comment">//1. HttpServerCodec 是netty 提供的处理http的 编-解码器</span>        pipeline.addLast(<span class="hljs-string">&quot;MyHttpServerCodec&quot;</span>, <span class="hljs-keyword">new</span> HttpServerCodec());        <span class="hljs-comment">//2. 增加一个自定义的handler</span>        pipeline.addLast(<span class="hljs-string">&quot;MyTestHttpServerHandler&quot;</span>, <span class="hljs-keyword">new</span> TestHttpServerHandler());        System.out.println(<span class="hljs-string">&quot;ok~~~~&quot;</span>);    &#125;&#125;TestHttpServerHandler.java<span class="hljs-keyword">package</span> com.atguigu.netty.http;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.*;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">import</span> java.net.URI;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 说明</span><span class="hljs-comment"> * 1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter</span><span class="hljs-comment"> * 2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHttpServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">HttpObject</span>&gt; </span>&#123;    <span class="hljs-comment">//channelRead0 读取客户端数据</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;对应的channel=&quot;</span> + ctx.channel() + <span class="hljs-string">&quot; pipeline=&quot;</span> + ctx                .pipeline() + <span class="hljs-string">&quot; 通过pipeline获取channel&quot;</span> + ctx.pipeline().channel());        System.out.println(<span class="hljs-string">&quot;当前ctx的handler=&quot;</span> + ctx.handler());        <span class="hljs-comment">//判断 msg 是不是 httprequest请求</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> HttpRequest) &#123;            System.out.println(<span class="hljs-string">&quot;ctx 类型=&quot;</span> + ctx.getClass());            System.out.println(<span class="hljs-string">&quot;pipeline hashcode&quot;</span> + ctx.pipeline().hashCode() + <span class="hljs-string">&quot; TestHttpServerHandler hash=&quot;</span> + <span class="hljs-keyword">this</span>.hashCode());            System.out.println(<span class="hljs-string">&quot;msg 类型=&quot;</span> + msg.getClass());            System.out.println(<span class="hljs-string">&quot;客户端地址&quot;</span> + ctx.channel().remoteAddress());            <span class="hljs-comment">//获取到</span>            HttpRequest httpRequest = (HttpRequest) msg;            <span class="hljs-comment">//获取uri, 过滤指定的资源</span>            URI uri = <span class="hljs-keyword">new</span> URI(httpRequest.uri());            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;                System.out.println(<span class="hljs-string">&quot;请求了 favicon.ico, 不做响应&quot;</span>);                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">//回复信息给浏览器 [http协议]</span>            ByteBuf content = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 我是服务器&quot;</span>, CharsetUtil.UTF_8);            <span class="hljs-comment">//构造一个http的相应，即 httpresponse</span>            FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="hljs-string">&quot;text/plain&quot;</span>);            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());            <span class="hljs-comment">//将构建好 response返回</span>            ctx.writeAndFlush(response);        &#125;    &#125;&#125;</code></pre></div><h2 id="6-Netty-核心模块组件"><a href="#6-Netty-核心模块组件" class="headerlink" title="6 Netty 核心模块组件"></a>6 Netty 核心模块组件</h2><h3 id="6-1-Bootstrap、ServerBootstrap"><a href="#6-1-Bootstrap、ServerBootstrap" class="headerlink" title="6.1 Bootstrap、ServerBootstrap"></a>6.1 Bootstrap、ServerBootstrap</h3><ol><li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li><li>常见的方法有<ul><li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li><li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li><li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li><li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li><li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li><li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li><li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li><li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li></ul></li></ol><h3 id="6-2-Future、ChannelFuture"><a href="#6-2-Future、ChannelFuture" class="headerlink" title="6.2 Future、ChannelFuture"></a>6.2 Future、ChannelFuture</h3><p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p><p>常见的方法有</p><ul><li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li><li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li></ul><h3 id="6-3-Channel"><a href="#6-3-Channel" class="headerlink" title="6.3 Channel"></a>6.3 Channel</h3><ol><li><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</p></li><li><p>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</p></li><li><p>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</p></li><li><p><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</p></li><li><p>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</p></li><li><p>支持关联 <code>I/O</code> 操作与对应的处理程序</p></li><li><p>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code>类型与之对应，常用的<code>Channel</code>类型：</p><ul><li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li><li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li><li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li><li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li><li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li></ul></li></ol><h3 id="6-4-Selector"><a href="#6-4-Selector" class="headerlink" title="6.4 Selector"></a>6.4 Selector</h3><ol><li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li><li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li></ol><h3 id="6-5-ChannelHandler-及其实现类"><a href="#6-5-ChannelHandler-及其实现类" class="headerlink" title="6.5 ChannelHandler 及其实现类"></a>6.5 ChannelHandler 及其实现类</h3><ol><li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li><li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li><li><code>ChannelHandler</code> 及其实现类一览图（后）</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_01.png" alt="img"></p><ol><li>我们经常需要自定义一个 <code>Handler</code> 类去继承 <code>ChannelInboundHandlerAdapter</code>，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_02.png" alt="img"></p><h3 id="6-6-Pipeline-和-ChannelPipelin"><a href="#6-6-Pipeline-和-ChannelPipelin" class="headerlink" title="6.6 Pipeline 和 ChannelPipelin"></a>6.6 Pipeline 和 ChannelPipelin</h3><p><code>ChannelPipeline</code> 是一个重点：</p><ol><li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li><li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li><li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_03.png" alt="img"></p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_04.png" alt="img"></p><ol><li>常用方法 <code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li></ol><h3 id="6-7-ChannelHandlerContext"><a href="#6-7-ChannelHandlerContext" class="headerlink" title="6.7 ChannelHandlerContext"></a>6.7 ChannelHandlerContext</h3><ol><li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li><li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</li><li>常用方法<ul><li><code>ChannelFuture close()</code>，关闭通道</li><li><code>ChannelOutboundInvoker flush()</code>，刷新</li><li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到</li><li><code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</li></ul></li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_05.png" alt="img"></p><h3 id="6-8-ChannelOption"><a href="#6-8-ChannelOption" class="headerlink" title="6.8 ChannelOption"></a>6.8 ChannelOption</h3><ol><li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li><li><code>ChannelOption</code> 参数如下：</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_06.png" alt="img"></p><h3 id="6-9-EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#6-9-EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="6.9 EventLoopGroup 和其实现类 NioEventLoopGroup"></a>6.9 EventLoopGroup 和其实现类 NioEventLoopGroup</h3><ol><li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，<code>Netty</code> 为了更好的利用多核 <code>CPU</code> 资源，一般会有多个 <code>EventLoop</code> 同时工作，每个 <code>EventLoop</code> 维护着一个 <code>Selector</code> 实例。</li><li><code>EventLoopGroup</code> 提供 <code>next</code> 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code> 来处理任务。在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</li><li>通常一个服务端口即一个 <code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和一个 <code>EventLoop</code> 线程。<code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_07.png" alt="img"></p><ol><li>常用方法 <code>public NioEventLoopGroup()</code>，构造方法 <code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li></ol><h3 id="6-10-Unpooled-类"><a href="#6-10-Unpooled-类" class="headerlink" title="6.10 Unpooled 类"></a>6.10 Unpooled 类</h3><ol><li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li><li>常用方法如下所示</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_08.png" alt="img"></p><ol><li>举例说明 <code>Unpooled</code> 获取 <code>Netty</code> 的数据容器 <code>ByteBuf</code> 的基本使用【案例演示】</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_09.png" alt="img"></p><p>案例 1</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.buf;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyByteBuf01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                <span class="hljs-comment">//创建一个ByteBuf</span>        <span class="hljs-comment">//说明</span>        <span class="hljs-comment">//1. 创建 对象，该对象包含一个数组arr , 是一个byte[10]</span>        <span class="hljs-comment">//2. 在netty 的buffer中，不需要使用flip 进行反转</span>        <span class="hljs-comment">//   底层维护了 readerindex 和 writerIndex</span>        <span class="hljs-comment">//3. 通过 readerindex 和  writerIndex 和  capacity， 将buffer分成三个区域</span>        <span class="hljs-comment">// 0---readerindex 已经读取的区域</span>        <span class="hljs-comment">// readerindex---writerIndex ， 可读的区域</span>        <span class="hljs-comment">// writerIndex -- capacity, 可写的区域</span>        ByteBuf buffer = Unpooled.buffer(<span class="hljs-number">10</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            buffer.writeByte(i);        &#125;        System.out.println(<span class="hljs-string">&quot;capacity=&quot;</span> + buffer.capacity());<span class="hljs-comment">//10</span>        <span class="hljs-comment">//输出</span><span class="hljs-comment">//        for(int i = 0; i&lt;buffer.capacity(); i++) &#123;</span><span class="hljs-comment">//            System.out.println(buffer.getByte(i));</span><span class="hljs-comment">//        &#125;</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.capacity(); i++) &#123;            System.out.println(buffer.readByte());        &#125;        System.out.println(<span class="hljs-string">&quot;执行完毕&quot;</span>);    &#125;&#125;</code></pre></div><p>案例 2</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.buf;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyByteBuf02</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建ByteBuf</span>        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello,world!&quot;</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));        <span class="hljs-comment">//使用相关的方法</span>        <span class="hljs-keyword">if</span> (byteBuf.hasArray()) &#123; <span class="hljs-comment">// true</span>            <span class="hljs-keyword">byte</span>[] content = byteBuf.array();            <span class="hljs-comment">//将 content 转成字符串</span>            System.out.println(<span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));            System.out.println(<span class="hljs-string">&quot;byteBuf=&quot;</span> + byteBuf);            System.out.println(byteBuf.arrayOffset()); <span class="hljs-comment">// 0</span>            System.out.println(byteBuf.readerIndex()); <span class="hljs-comment">// 0</span>            System.out.println(byteBuf.writerIndex()); <span class="hljs-comment">// 12</span>            System.out.println(byteBuf.capacity()); <span class="hljs-comment">// 36</span>            <span class="hljs-comment">//System.out.println(byteBuf.readByte()); //</span>            System.out.println(byteBuf.getByte(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 104</span>            <span class="hljs-keyword">int</span> len = byteBuf.readableBytes(); <span class="hljs-comment">//可读的字节数  12</span>            System.out.println(<span class="hljs-string">&quot;len=&quot;</span> + len);            <span class="hljs-comment">//使用for取出各个字节</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;                System.out.println((<span class="hljs-keyword">char</span>) byteBuf.getByte(i));            &#125;            <span class="hljs-comment">//按照某个范围读取</span>            System.out.println(byteBuf.getCharSequence(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));            System.out.println(byteBuf.getCharSequence(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));        &#125;    &#125;&#125;</code></pre></div><h3 id="6-11-Netty-应用实例-群聊系统"><a href="#6-11-Netty-应用实例-群聊系统" class="headerlink" title="6.11 Netty 应用实例-群聊系统"></a>6.11 Netty 应用实例-群聊系统</h3><p>实例要求：</p><ol><li>编写一个 <code>Netty</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>Netty</code> 非阻塞网络编程机制</li><li>看老师代码演示</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_10.png" alt="img"></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.*;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port; <span class="hljs-comment">//监听端口</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-comment">//编写run方法，处理客户端的请求</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建两个线程组</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//获取到pipeline</span>                            ChannelPipeline pipeline = ch.pipeline();                            <span class="hljs-comment">//向pipeline加入解码器</span>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> StringDecoder());                            <span class="hljs-comment">//向pipeline加入编码器</span>                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> StringEncoder());                            <span class="hljs-comment">//加入自己的业务处理handler</span>                            pipeline.addLast(<span class="hljs-keyword">new</span> GroupChatServerHandler());                        &#125;                    &#125;);            System.out.println(<span class="hljs-string">&quot;netty 服务器启动&quot;</span>);            ChannelFuture channelFuture = b.bind(port).sync();            <span class="hljs-comment">//监听关闭</span>            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">new</span> GroupChatServer(<span class="hljs-number">7000</span>).run();    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<span class="hljs-keyword">import</span> io.netty.channel.Channel;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.channel.group.ChannelGroup;<span class="hljs-keyword">import</span> io.netty.channel.group.DefaultChannelGroup;<span class="hljs-keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-comment">//public static List&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;();</span>    <span class="hljs-comment">//使用一个hashmap 管理</span>    <span class="hljs-comment">//public static Map&lt;String, Channel&gt; channels = new HashMap&lt;String,Channel&gt;();</span>    <span class="hljs-comment">//定义一个channle 组，管理所有的channel</span>    <span class="hljs-comment">//GlobalEventExecutor.INSTANCE) 是全局的事件执行器，是一个单例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ChannelGroup channelGroup = <span class="hljs-keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);    <span class="hljs-comment">//handlerAdded 表示连接建立，一旦连接，第一个被执行</span>    <span class="hljs-comment">//将当前channel 加入到  channelGroup</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Channel channel = ctx.channel();        <span class="hljs-comment">//将该客户加入聊天的信息推送给其它在线的客户端</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">        该方法会将 channelGroup 中所有的channel 遍历，并发送 消息，</span><span class="hljs-comment">        我们不需要自己遍历</span><span class="hljs-comment">         */</span>        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 加入聊天&quot;</span> + sdf.format(<span class="hljs-keyword">new</span> java.util.Date()) + <span class="hljs-string">&quot; \n&quot;</span>);        channelGroup.add(channel);    &#125;    <span class="hljs-comment">//断开连接, 将xx客户离开信息推送给当前在线的客户</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Channel channel = ctx.channel();        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 离开了\n&quot;</span>);        System.out.println(<span class="hljs-string">&quot;channelGroup size&quot;</span> + channelGroup.size());    &#125;    <span class="hljs-comment">//表示channel 处于活动状态, 提示 xx上线</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 上线了~&quot;</span>);    &#125;    <span class="hljs-comment">//表示channel 处于不活动状态, 提示 xx离线了</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 离线了~&quot;</span>);    &#125;    <span class="hljs-comment">//读取数据</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取到当前channel</span>        Channel channel = ctx.channel();        <span class="hljs-comment">//这时我们遍历channelGroup, 根据不同的情况，回送不同的消息</span>        channelGroup.forEach(ch -&gt; &#123;            <span class="hljs-keyword">if</span> (channel != ch) &#123; <span class="hljs-comment">//不是当前的channel,转发消息</span>                ch.writeAndFlush(<span class="hljs-string">&quot;[客户]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 发送了消息&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//回显自己发送的消息给自己</span>                ch.writeAndFlush(<span class="hljs-string">&quot;[自己]发送了消息&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);            &#125;        &#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//关闭通道</span>        ctx.close();    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.*;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>&#123;        <span class="hljs-comment">//属性</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.host = host;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;                        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap()                    .group(group)                    .channel(NioSocketChannel.class)                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//得到pipeline</span>                            ChannelPipeline pipeline = ch.pipeline();                            <span class="hljs-comment">//加入相关handler</span>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> StringDecoder());                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> StringEncoder());                            <span class="hljs-comment">//加入自定义的handler</span>                            pipeline.addLast(<span class="hljs-keyword">new</span> GroupChatClientHandler());                        &#125;                    &#125;);            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();            <span class="hljs-comment">//得到channel</span>            Channel channel = channelFuture.channel();            System.out.println(<span class="hljs-string">&quot;-------&quot;</span> + channel.localAddress() + <span class="hljs-string">&quot;--------&quot;</span>);            <span class="hljs-comment">//客户端需要输入信息，创建一个扫描器</span>            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);            <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;                String msg = scanner.nextLine();                <span class="hljs-comment">//通过channel 发送到服务器端</span>                channel.writeAndFlush(msg + <span class="hljs-string">&quot;\r\n&quot;</span>);            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">new</span> GroupChatClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>).run();    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(msg.trim());    &#125;&#125;</code></pre></div><h3 id="6-12-Netty-心跳检测机制案例"><a href="#6-12-Netty-心跳检测机制案例" class="headerlink" title="6.12 Netty 心跳检测机制案例"></a>6.12 Netty 心跳检测机制案例</h3><p>实例要求：</p><ol><li>编写一个 <code>Netty</code> 心跳检测机制案例,当服务器超过 <code>3</code> 秒没有读时，就提示读空闲</li><li>当服务器超过 <code>5</code> 秒没有写操作时，就提示写空闲</li><li>实现当服务器超过 <code>7</code> 秒没有读或者写操作时，就提示读写空闲</li><li>代码如下：</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.heartbeat;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;<span class="hljs-keyword">import</span> io.netty.handler.timeout.IdleStateHandler;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-comment">//创建两个线程组</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup);            serverBootstrap.channel(NioServerSocketChannel.class);            serverBootstrap.handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO));            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ChannelPipeline pipeline = ch.pipeline();                    <span class="hljs-comment">//加入一个netty 提供 IdleStateHandler</span>                    <span class="hljs-comment">/*</span><span class="hljs-comment">                    说明</span><span class="hljs-comment">                    1. IdleStateHandler 是netty 提供的处理空闲状态的处理器</span><span class="hljs-comment">                    2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span><span class="hljs-comment">                    3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span><span class="hljs-comment">                    4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span><span class="hljs-comment"></span><span class="hljs-comment">                    5. 文档说明</span><span class="hljs-comment">                    triggers an &#123;@link IdleStateEvent&#125; when a &#123;@link Channel&#125; has not performed</span><span class="hljs-comment"> * read, write, or both operation for a while.</span><span class="hljs-comment"> *                  6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个handler去处理</span><span class="hljs-comment"> *                  通过调用(触发)下一个handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)</span><span class="hljs-comment">                     */</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">7000</span>, <span class="hljs-number">7000</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS));                    <span class="hljs-comment">//加入一个对空闲检测进一步处理的handler(自定义)</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> MyServerHandler());                &#125;            &#125;);            <span class="hljs-comment">//启动服务器</span>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.heartbeat;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.handler.timeout.IdleStateEvent;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evt 事件</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;            <span class="hljs-comment">//将  evt 向下转型 IdleStateEvent</span>            IdleStateEvent event = (IdleStateEvent) evt;            String eventType = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">switch</span> (event.state()) &#123;                <span class="hljs-keyword">case</span> READER_IDLE:                    eventType = <span class="hljs-string">&quot;读空闲&quot;</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> WRITER_IDLE:                    eventType = <span class="hljs-string">&quot;写空闲&quot;</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> ALL_IDLE:                    eventType = <span class="hljs-string">&quot;读写空闲&quot;</span>;                    <span class="hljs-keyword">break</span>;            &#125;            System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot;--超时时间--&quot;</span> + eventType);            System.out.println(<span class="hljs-string">&quot;服务器做相应处理..&quot;</span>);            <span class="hljs-comment">//如果发生空闲，我们关闭通道</span>            <span class="hljs-comment">// ctx.channel().close();</span>        &#125;    &#125;&#125;</code></pre></div><h3 id="6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接"><a href="#6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接" class="headerlink" title="6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接"></a>6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接</h3><p>实例要求：</p><ol><li><code>Http</code> 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。</li><li>要求：实现基于 <code>WebSocket</code> 的长连接的全双工的交互</li><li>改变 <code>Http</code> 协议多次请求的约束，实现长连接了，服务器可以发送消息给浏览器</li><li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li><li>运行界面</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_11.png" alt="img"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.websocket;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;<span class="hljs-keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建两个线程组</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup);            serverBootstrap.channel(NioServerSocketChannel.class);            serverBootstrap.handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO));            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ChannelPipeline pipeline = ch.pipeline();                    <span class="hljs-comment">//因为基于http协议，使用http的编码和解码器</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> HttpServerCodec());                    <span class="hljs-comment">//是以块方式写，添加ChunkedWriteHandler处理器</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler());                    <span class="hljs-comment">/*</span><span class="hljs-comment">                    说明</span><span class="hljs-comment">                    1. http数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span><span class="hljs-comment">                    2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span><span class="hljs-comment">                     */</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">8192</span>));                    <span class="hljs-comment">/*</span><span class="hljs-comment">                    说明</span><span class="hljs-comment">                    1. 对应websocket ，它的数据是以 帧(frame) 形式传递</span><span class="hljs-comment">                    2. 可以看到WebSocketFrame 下面有六个子类</span><span class="hljs-comment">                    3. 浏览器请求时 ws://localhost:7000/hello 表示请求的uri</span><span class="hljs-comment">                    4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws协议 , 保持长连接</span><span class="hljs-comment">                    5. 是通过一个 状态码 101</span><span class="hljs-comment">                     */</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">&quot;/hello2&quot;</span>));                    <span class="hljs-comment">//自定义的handler ，处理业务逻辑</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> MyTextWebSocketFrameHandler());                &#125;            &#125;);            <span class="hljs-comment">//启动服务器</span>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.websocket;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;<span class="hljs-keyword">import</span> java.time.LocalDateTime;<span class="hljs-comment">//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTextWebSocketFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;服务器收到消息 &quot;</span> + msg.text());        <span class="hljs-comment">//回复消息</span>        ctx.channel().writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">&quot;服务器时间&quot;</span> + LocalDateTime.now() + <span class="hljs-string">&quot; &quot;</span> + msg.text()));    &#125;    <span class="hljs-comment">//当web客户端连接后， 触发方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span>        System.out.println(<span class="hljs-string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());        System.out.println(<span class="hljs-string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asShortText());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;异常发生 &quot;</span> + cause.getMessage());        ctx.close(); <span class="hljs-comment">//关闭连接</span>    &#125;&#125;</code></pre></div><p>hello.html</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">var</span> socket;</span><span class="javascript">    <span class="hljs-comment">//判断当前浏览器是否支持websocket</span></span><span class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.WebSocket) &#123;</span><span class="javascript">        <span class="hljs-comment">//go on</span></span><span class="javascript">        socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://localhost:7000/hello2&quot;</span>);</span><span class="javascript">        <span class="hljs-comment">//相当于channelRead, ev 收到服务器端回送的消息</span></span><span class="javascript">        socket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span><span class="javascript">            rt.value = rt.value + <span class="hljs-string">&quot;\n&quot;</span> + ev.data;</span>        &#125;<span class="javascript">        <span class="hljs-comment">//相当于连接开启(感知到连接开启)</span></span><span class="javascript">        socket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span><span class="javascript">            rt.value = <span class="hljs-string">&quot;连接开启了..&quot;</span></span>        &#125;<span class="javascript">        <span class="hljs-comment">//相当于连接关闭(感知到连接关闭)</span></span><span class="javascript">        socket.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span><span class="javascript">            rt.value = rt.value + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;连接关闭了..&quot;</span></span>        &#125;<span class="javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="javascript">        alert(<span class="hljs-string">&quot;当前浏览器不支持websocket&quot;</span>)</span>    &#125;<span class="javascript">    <span class="hljs-comment">//发送消息到服务器</span></span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params">message</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.socket) &#123; <span class="hljs-comment">//先判断socket是否创建好</span></span><span class="javascript">            <span class="hljs-keyword">return</span>;</span>        &#125;        if (socket.readyState === WebSocket.OPEN) &#123;<span class="javascript">            <span class="hljs-comment">//通过socket 发送消息</span></span>            socket.send(message)<span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="javascript">            alert(<span class="hljs-string">&quot;连接没有开启&quot;</span>);</span>        &#125;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return false&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;发生消息&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send(this.form.message.value)&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;responseText&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;responseText&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;清空内容&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="7-Google-Protobuf"><a href="#7-Google-Protobuf" class="headerlink" title="7 Google Protobuf"></a>7 Google Protobuf</h2><h3 id="7-1-编码和解码的基本介绍"><a href="#7-1-编码和解码的基本介绍" class="headerlink" title="7.1 编码和解码的基本介绍"></a>7.1 编码和解码的基本介绍</h3><ol><li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码[示意图]</li><li><code>codec</code>（编解码器）的组成部分有两个：<code>decoder</code>（解码器）和 <code>encoder</code>（编码器）。<code>encoder</code> 负责把业务数据转换成字节码数据，<code>decoder</code> 负责把字节码数据转换成业务数据</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_01.png" alt="img"></p><h3 id="7-2-Netty-本身的编码解码的机制和问题分析"><a href="#7-2-Netty-本身的编码解码的机制和问题分析" class="headerlink" title="7.2 Netty 本身的编码解码的机制和问题分析"></a>7.2 Netty 本身的编码解码的机制和问题分析</h3><ol><li><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)</li><li><code>Netty</code> 提供的编码器 <code>StringEncoder</code>，对字符串数据进行编码 <code>ObjectEncoder</code>，对Java对象进行编码…</li><li><code>Netty</code> 提供的解码器 <code>StringDecoder</code>,对字符串数据进行解码 <code>ObjectDecoder</code>，对 <code>Java</code> 对象进行解码…</li><li><code>Netty</code> 本身自带的 <code>ObjectDecoder</code> 和 <code>ObjectEncoder</code> 可以用来实现 <code>POJO</code> 对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，存在如下问题<ul><li>无法跨语言</li><li>序列化后的体积太大，是二进制编码的5倍多。</li><li>序列化性能太低</li></ul></li><li>=&gt;引出新的解决方案[<code>Google</code> 的 <code>Protobuf</code>]</li></ol><h3 id="7-3-Protobuf"><a href="#7-3-Protobuf" class="headerlink" title="7.3 Protobuf"></a>7.3 Protobuf</h3><ol><li><code>Protobuf</code> 基本介绍和使用示意图</li><li><code>Protobuf</code> 是 <code>Google</code> 发布的开源项目，全称 <code>Google Protocol Buffers</code>，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 <code>RPC</code> [远程过程调用 <code>remote procedure call</code> ]数据交换格式。目前很多公司 <code>http + json tcp + protobuf</code></li><li>参考文档：<a href="https://developers.google.com/protocol-buffers/docs/proto">https://developers.google.com/protocol-buffers/docs/proto</a> 语言指南</li><li><code>Protobuf</code> 是以 <code>message</code> 的方式来管理数据的.</li><li>支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的]（支持目前绝大多数语言，例如 <code>C++</code>、<code>C#</code>、<code>Java</code>、<code>python</code> 等）</li><li>高性能，高可靠性</li><li>使用 <code>protobuf</code> 编译器能自动生成代码，<code>Protobuf</code> 是将类的定义使用 <code>.proto</code> 文件进行描述。说明，在 <code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.ptoto</code> 编写插件.可以让语法高亮。</li><li>然后通过 <code>protoc.exe</code> 编译器根据 <code>.proto</code> 自动生成 <code>.java</code> 文件</li><li><code>protobuf</code> 使用示意图</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_02.png" alt="img"></p><h3 id="7-4-Protobuf-快速入门实例"><a href="#7-4-Protobuf-快速入门实例" class="headerlink" title="7.4 Protobuf 快速入门实例"></a>7.4 Protobuf 快速入门实例</h3><p>编写程序，使用 <code>Protobuf</code> 完成如下功能</p><ol><li>客户端可以发送一个 <code>StudentPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li><li>服务端能接收 <code>StudentPoJo</code> 对象，并显示信息(通过 <code>Protobuf</code> 解码)</li><li>具体看老师演示步骤</li></ol><div class="code-wrapper"><pre><code class="hljs java">Student.protosyntax = <span class="hljs-string">&quot;proto3&quot;</span>; <span class="hljs-comment">//版本</span>option java_outer_classname = <span class="hljs-string">&quot;StudentPOJO&quot;</span>;<span class="hljs-comment">//生成的外部类名，同时也是文件名</span><span class="hljs-comment">//protobuf 使用message 管理数据</span>message Student &#123; <span class="hljs-comment">//会在 StudentPOJO 外部类生成一个内部类 Student， 他是真正发送的POJO对象</span>    int32 id = <span class="hljs-number">1</span>; <span class="hljs-comment">// Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span>    string name = <span class="hljs-number">2</span>;&#125;编译protoc.exe--java_out=.Student.proto将生成的 StudentPOJO 放入到项目使用</code></pre></div><h3 id="7-5-Protobuf-快速入门实例-2"><a href="#7-5-Protobuf-快速入门实例-2" class="headerlink" title="7.5 Protobuf 快速入门实例 2"></a>7.5 Protobuf 快速入门实例 2</h3><ol><li>编写程序，使用 <code>Protobuf</code> 完成如下功能</li><li>客户端可以随机发送 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li><li>服务端能接收 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象(需要判断是哪种类型)，并显示信息(通过 <code>Protobuf</code> 解码)</li><li>具体看老师演示步骤</li></ol><div class="code-wrapper"><pre><code class="hljs java">Student.protosyntax = <span class="hljs-string">&quot;proto3&quot;</span>;option optimize_for = SPEED; <span class="hljs-comment">// 加快解析</span>option java_package=<span class="hljs-string">&quot;com.atguigu.netty.codec2&quot;</span>;   <span class="hljs-comment">//指定生成到哪个包下</span>option java_outer_classname=<span class="hljs-string">&quot;MyDataInfo&quot;</span>; <span class="hljs-comment">// 外部类名, 文件名</span><span class="hljs-comment">//protobuf 可以使用message 管理其他的message</span>message MyMessage &#123;    <span class="hljs-comment">//定义一个枚举类型</span>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DataType</span> </span>&#123;        StudentType = <span class="hljs-number">0</span>; <span class="hljs-comment">//在proto3 要求enum的编号从0开始</span>        WorkerType = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//用data_type 来标识传的是哪一个枚举类型</span>    DataType data_type = <span class="hljs-number">1</span>;    <span class="hljs-comment">//表示每次枚举类型最多只能出现其中的一个, 节省空间</span>    oneof dataBody &#123;        Student student = <span class="hljs-number">2</span>;        Worker worker = <span class="hljs-number">3</span>;    &#125;&#125;message Student &#123;    int32 id = <span class="hljs-number">1</span>;<span class="hljs-comment">//Student类的属性</span>    string name = <span class="hljs-number">2</span>; <span class="hljs-comment">//</span>&#125;message Worker &#123;    string name=<span class="hljs-number">1</span>;    int32 age=<span class="hljs-number">2</span>;&#125;</code></pre></div><h2 id="8-Netty-编解码器和-Handler-调用机制"><a href="#8-Netty-编解码器和-Handler-调用机制" class="headerlink" title="8 Netty 编解码器和 Handler 调用机制"></a>8 Netty 编解码器和 Handler 调用机制</h2><h3 id="8-1-基本说明"><a href="#8-1-基本说明" class="headerlink" title="8.1 基本说明"></a>8.1 基本说明</h3><ol><li><code>Netty</code> 的组件设计：<code>Netty</code> 的主要组件有 <code>Channel</code>、<code>EventLoop</code>、<code>ChannelFuture</code>、<code>ChannelHandler</code>、<code>ChannelPipe</code> 等</li><li><code>ChannelHandler</code> 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 <code>ChannelInboundHandler</code> 接口（或 <code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从 <code>ChannelInboundHandler</code> 冲刷数据。业务逻辑通常写在一个或者多个 <code>ChannelInboundHandler</code> 中。<code>ChannelOutboundHandler</code> 原理一样，只不过它是用来处理出站数据的</li><li><code>ChannelPipeline</code> 提供了 <code>ChannelHandler</code> 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 <code>pipeline</code> 中的一系列 <code>ChannelOutboundHandler</code>，并被这些 <code>Handler</code> 处理，反之则称为入站的</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_01.png" alt="img"></p><h3 id="8-2编码解码器"><a href="#8-2编码解码器" class="headerlink" title="8.2编码解码器"></a>8.2编码解码器</h3><ol><li>当 <code>Netty</code> 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 <code>java</code> 对象）；如果是出站消息，它会被编码成字节。</li><li><code>Netty</code> 提供一系列实用的编解码器，他们都实现了 <code>ChannelInboundHadnler</code> 或者 <code>ChannelOutboundHandler</code> 接口。在这些类中，<code>channelRead</code> 方法已经被重写了。以入站为例，对于每个从入站 <code>Channel</code> 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 <code>decode()</code> 方法进行解码，并将已经解码的字节转发给 <code>ChannelPipeline</code> 中的下一个 <code>ChannelInboundHandler</code>。</li></ol><h3 id="8-3-解码器-ByteToMessageDecoder"><a href="#8-3-解码器-ByteToMessageDecoder" class="headerlink" title="8.3 解码器 - ByteToMessageDecoder"></a>8.3 解码器 - ByteToMessageDecoder</h3><ol><li>关系继承图</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_02.png" alt="img"></p><ol><li>由于不可能知道远程节点是否会一次性发送一个完整的信息，<code>tcp</code> 有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理.</li><li>一个关于 <code>ByteToMessageDecoder</code> 实例分析</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_03.png" alt="img"></p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_04.png" alt="img"></p><h3 id="8-4-Netty-的-handler-链的调用机制"><a href="#8-4-Netty-的-handler-链的调用机制" class="headerlink" title="8.4 Netty 的 handler 链的调用机制"></a>8.4 Netty 的 handler 链的调用机制</h3><p>实例要求:</p><ol><li>使用自定义的编码器和解码器来说明 <code>Netty</code> 的 <code>handler</code> 调用机制 客户端发送 <code>long</code> -&gt; 服务器 服务端发送 <code>long</code> -&gt; 客户端</li><li>案例演示</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_05.png" alt="img"></p><ol><li>结论<ul><li>不论解码器 <code>handler</code> 还是编码器 <code>handler</code> 即接收的消息类型必须与待处理的消息类型一致，否则该 <code>handler</code> 不会被执行</li><li>在解码器进行数据解码时，需要判断缓存区（<code>ByteBuf</code>）的数据是否足够，否则接收到的结果会期望结果可能不一致</li></ul></li></ol><h3 id="8-5-解码器-ReplayingDecoder"><a href="#8-5-解码器-ReplayingDecoder" class="headerlink" title="8.5 解码器 - ReplayingDecoder"></a>8.5 解码器 - ReplayingDecoder</h3><ol><li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></li><li><code>ReplayingDecoder</code> 扩展了 <code>ByteToMessageDecoder</code> 类，使用这个类，我们不必调用 <code>readableBytes()</code> 方法。参数 <code>S</code> 指定了用户状态管理的类型，其中 <code>Void</code> 代表不需要状态管理</li><li>应用实例：使用 <code>ReplayingDecoder</code> 编写解码器，对前面的案例进行简化[案例演示]</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyByteToLongDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyByteToLongDecoder2 被调用&quot;</span>);        <span class="hljs-comment">//在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断</span>        out.add(in.readLong());    &#125;&#125;</code></pre></div><ol start="4"><li><code>ReplayingDecoder</code>使用方便，但它也有一些局限性：<ul><li>并不是所有的 <code>ByteBuf</code> 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>。</li><li><code>ReplayingDecoder</code> 在某些情况下可能稍慢于 <code>ByteToMessageDecoder</code>，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li></ul></li></ol><h3 id="8-6-其它编解码器"><a href="#8-6-其它编解码器" class="headerlink" title="8.6 其它编解码器"></a>8.6 其它编解码器</h3><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_06.png" alt="img"></p><h4 id="8-6-1-其它解码器"><a href="#8-6-1-其它解码器" class="headerlink" title="8.6.1 其它解码器"></a>8.6.1 其它解码器</h4><ol><li><code>LineBasedFrameDecoder</code>：这个类在 <code>Netty</code> 内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</li><li><code>DelimiterBasedFrameDecoder</code>：使用自定义的特殊字符作为消息的分隔符。</li><li><code>HttpObjectDecoder</code>：一个 <code>HTTP</code> 数据的解码器</li><li><code>LengthFieldBasedFrameDecoder</code>：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li></ol><h4 id="8-6-2-其它编码器"><a href="#8-6-2-其它编码器" class="headerlink" title="8.6.2 其它编码器"></a>8.6.2 其它编码器</h4><h3 id="8-7-Log4j-整合到-Netty"><a href="#8-7-Log4j-整合到-Netty" class="headerlink" title="8.7 Log4j 整合到 Netty"></a>8.7 Log4j 整合到 Netty</h3><ol><li>在 <code>Maven</code> 中添加对 <code>Log4j</code> 的依赖在 <code>pom.xml</code></li></ol><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ol><li>配置 <code>Log4j</code>，在 <code>resources/log4j.properties</code></li></ol><div class="code-wrapper"><pre><code class="hljs xml">log4j.rootLogger=DEBUG,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%p]%C&#123;1&#125;-%m%n</code></pre></div><ol><li>演示整合</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_07.png" alt="img"></p><h2 id="9-TCP-粘包和拆包及解决方案"><a href="#9-TCP-粘包和拆包及解决方案" class="headerlink" title="9 TCP 粘包和拆包及解决方案"></a>9 TCP 粘包和拆包及解决方案</h2><h3 id="9-1-TCP-粘包和拆包基本介绍"><a href="#9-1-TCP-粘包和拆包基本介绍" class="headerlink" title="9.1 TCP 粘包和拆包基本介绍"></a>9.1 TCP 粘包和拆包基本介绍</h3><ol><li><code>TCP</code> 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 <code>socket</code>，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（<code>Nagle</code> 算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的</li><li>由于 <code>TCP</code> 无消息保护边界,需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题,看一张图</li><li>示意图 <code>TCP</code> 粘包、拆包图解</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter09_01.png" alt="img"></p><p>对图的说明: 假设客户端分别发送了两个数据包 <code>D1</code> 和 <code>D2</code> 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p><ol><li>服务端分两次读取到了两个独立的数据包，分别是 <code>D1</code> 和 <code>D2</code>，没有粘包和拆包</li><li>服务端一次接受到了两个数据包，<code>D1</code> 和 <code>D2</code> 粘合在一起，称之为 <code>TCP</code> 粘包</li><li>服务端分两次读取到了数据包，第一次读取到了完整的 <code>D1</code> 包和 <code>D2</code> 包的部分内容，第二次读取到了 <code>D2</code> 包的剩余内容，这称之为 <code>TCP</code> 拆包</li><li>服务端分两次读取到了数据包，第一次读取到了 <code>D1</code> 包的部分内容 <code>D1_1</code>，第二次读取到了 <code>D1</code> 包的剩余部分内容 <code>D1_2</code> 和完整的 <code>D2</code> 包。</li></ol><h3 id="9-2-TCP-粘包和拆包现象实例"><a href="#9-2-TCP-粘包和拆包现象实例" class="headerlink" title="9.2 TCP 粘包和拆包现象实例"></a>9.2 TCP 粘包和拆包现象实例</h3><p>在编写 <code>Netty</code> 程序时，如果没有做处理，就会发生粘包和拆包的问题</p><p>看一个具体的实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 核心代码</span>MyClientHandler.java<span class="hljs-keyword">package</span> com.atguigu.netty.tcp;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//使用客户端发送10条数据 hello,server 编号</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;            ByteBuf buffer = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello,server &quot;</span> + i, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));            ctx.writeAndFlush(buffer);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[msg.readableBytes()];        msg.readBytes(buffer);        String message = <span class="hljs-keyword">new</span> String(buffer, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));        System.out.println(<span class="hljs-string">&quot;客户端接收到消息=&quot;</span> + message);        System.out.println(<span class="hljs-string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;MyServerHandler.java<span class="hljs-keyword">package</span> com.atguigu.netty.tcp;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-keyword">import</span> java.util.UUID;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//cause.printStackTrace();</span>        ctx.close();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[msg.readableBytes()];        msg.readBytes(buffer);        <span class="hljs-comment">//将buffer转成字符串</span>        String message = <span class="hljs-keyword">new</span> String(buffer, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));        System.out.println(<span class="hljs-string">&quot;服务器接收到数据 &quot;</span> + message);        System.out.println(<span class="hljs-string">&quot;服务器接收到消息量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));        <span class="hljs-comment">//服务器回送数据给客户端, 回送一个随机id ,</span>        ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="hljs-string">&quot; &quot;</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));        ctx.writeAndFlush(responseByteBuf);    &#125;&#125;</code></pre></div><h3 id="9-3-TCP-粘包和拆包解决方案"><a href="#9-3-TCP-粘包和拆包解决方案" class="headerlink" title="9.3 TCP 粘包和拆包解决方案"></a>9.3 TCP 粘包和拆包解决方案</h3><ol><li>使用自定义协议+编解码器来解决</li><li>关键就是要解决服务器端每次读取数据长度的问题，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 <code>TCP</code> 粘包、拆包。</li></ol><h3 id="9-4-看一个具体的实例"><a href="#9-4-看一个具体的实例" class="headerlink" title="9.4 看一个具体的实例"></a>9.4 看一个具体的实例</h3><ol><li>要求客户端发送 <code>5</code> 个 <code>Message</code> 对象，客户端每次发送一个 <code>Message</code> 对象</li><li>服务器端每次接收一个 <code>Message</code>，分 <code>5</code> 次进行解码，每读取到一个 <code>Message</code>，会回复一个 <code>Message</code> 对象给客户端。</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter09_02.png" alt="img"></p><ol><li>代码演示，全部代码核心</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 核心</span><span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<span class="hljs-comment">//协议包</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProtocol</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> len; <span class="hljs-comment">//关键</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] content;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">this</span>.len = len;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getContent() &#123;        <span class="hljs-keyword">return</span> content;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] content)</span> </span>&#123;        <span class="hljs-keyword">this</span>.content = content;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//使用客户端发送10条数据 &quot;今天天气冷，吃火锅&quot; 编号</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            String mes = <span class="hljs-string">&quot;今天天气冷，吃火锅&quot;</span>;            <span class="hljs-keyword">byte</span>[] content = mes.getBytes(Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));            <span class="hljs-keyword">int</span> length = mes.getBytes(Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)).length;            <span class="hljs-comment">//创建协议包对象</span>            MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();            messageProtocol.setLen(length);            messageProtocol.setContent(content);            ctx.writeAndFlush(messageProtocol);        &#125;    &#125;    <span class="hljs-comment">//    @Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> len = msg.getLen();        <span class="hljs-keyword">byte</span>[] content = msg.getContent();        System.out.println(<span class="hljs-string">&quot;客户端接收到消息如下&quot;</span>);        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + len);        System.out.println(<span class="hljs-string">&quot;内容=&quot;</span> + <span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));        System.out.println(<span class="hljs-string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;异常消息=&quot;</span> + cause.getMessage());        ctx.close();    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyMessageEncoder encode 方法被调用&quot;</span>);        out.writeInt(msg.getLen());        out.writeBytes(msg.getContent());    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyMessageDecoder decode 被调用&quot;</span>);        <span class="hljs-comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span>        <span class="hljs-keyword">int</span> length = in.readInt();        <span class="hljs-keyword">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];        in.readBytes(content);        <span class="hljs-comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span>        MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();        messageProtocol.setLen(length);        messageProtocol.setContent(content);        out.add(messageProtocol);    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-keyword">import</span> java.util.UUID;<span class="hljs-comment">//处理业务的handler</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//cause.printStackTrace();</span>        ctx.close();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//接收到数据，并处理</span>        <span class="hljs-keyword">int</span> len = msg.getLen();        <span class="hljs-keyword">byte</span>[] content = msg.getContent();        System.out.println();        System.out.println();        System.out.println();        System.out.println(<span class="hljs-string">&quot;服务器接收到信息如下&quot;</span>);        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + len);        System.out.println(<span class="hljs-string">&quot;内容=&quot;</span> + <span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));        System.out.println(<span class="hljs-string">&quot;服务器接收到消息包数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));        <span class="hljs-comment">//回复消息</span>        String responseContent = UUID.randomUUID().toString();        <span class="hljs-keyword">int</span> responseLen = responseContent.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>).length;        <span class="hljs-keyword">byte</span>[] responseContent2 = responseContent.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);        <span class="hljs-comment">//构建一个协议包</span>        MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();        messageProtocol.setLen(responseLen);        messageProtocol.setContent(responseContent2);        ctx.writeAndFlush(messageProtocol);    &#125;&#125;</code></pre></div><h2 id="10-Netty-核心源码剖析"><a href="#10-Netty-核心源码剖析" class="headerlink" title="10 Netty 核心源码剖析"></a>10 Netty 核心源码剖析</h2><h3 id="10-1-基本说明"><a href="#10-1-基本说明" class="headerlink" title="10.1 基本说明"></a>10.1 基本说明</h3><ol><li>只有看过 <code>Netty</code> 源码，才能说是真的掌握了 <code>Netty</code> 框架。</li><li>在 <code>io.netty.example</code> 包下，有很多 <code>Netty</code> 源码案例，可以用来分析。</li><li>源码分析章节是针对有 <code>Java</code> 项目经验，并且玩过框架源码的人员讲的，否则你听起来会有相当的难度。</li></ol><h3 id="10-2-Netty-启动过程源码剖析"><a href="#10-2-Netty-启动过程源码剖析" class="headerlink" title="10.2 Netty 启动过程源码剖析"></a>10.2 Netty 启动过程源码剖析</h3><h4 id="10-2-1-源码剖析目的"><a href="#10-2-1-源码剖析目的" class="headerlink" title="10.2.1 源码剖析目的"></a>10.2.1 源码剖析目的</h4><p>用源码分析的方式走一下 <code>Netty</code>（服务器）的启动过程，更好的理解 <code>Netty</code> 的整体设计和运行机制。</p><h4 id="10-2-2-源码剖析"><a href="#10-2-2-源码剖析" class="headerlink" title="10.2.2 源码剖析"></a>10.2.2 源码剖析</h4><p>说明：</p><ol><li>源码需要剖析到 <code>Netty</code> 调用 <code>doBind</code> 方法，追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>。</li><li>并且要 <code>Debug</code> 程序到 <code>NioEventLoop</code> 类的 <code>run</code> 代码，无限循环，在服务器端运行。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_01.png" alt="img"></p><h4 id="10-2-3-源码剖析过程"><a href="#10-2-3-源码剖析过程" class="headerlink" title="10.2.3 源码剖析过程"></a>10.2.3 源码剖析过程</h4><p><strong>1. <code>demo</code> 源码的基本理解</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 服务器启动类源码</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * Copyright 2012 The Netty Project</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * The Netty Project licenses this file to you under the Apache License,</span><span class="hljs-comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span><span class="hljs-comment"> * with the License. You may obtain a copy of the License at:</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span><span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span><span class="hljs-comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span><span class="hljs-comment"> * License for the specific language governing permissions and limitations</span><span class="hljs-comment"> * under the License.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> atguigu.netty.example.echo2;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;<span class="hljs-keyword">import</span> io.netty.handler.ssl.SslContext;<span class="hljs-keyword">import</span> io.netty.handler.ssl.SslContextBuilder;<span class="hljs-keyword">import</span> io.netty.handler.ssl.util.SelfSignedCertificate;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Echoes back any received data from a client.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> SSL = System.getProperty(<span class="hljs-string">&quot;ssl&quot;</span>) != <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>));    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// Configure SSL.</span>        <span class="hljs-keyword">final</span> SslContext sslCtx;        <span class="hljs-keyword">if</span> (SSL) &#123;            SelfSignedCertificate ssc = <span class="hljs-keyword">new</span> SelfSignedCertificate();            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();        &#125; <span class="hljs-keyword">else</span> &#123;            sslCtx = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// Configure the server.</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)                    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            ChannelPipeline p = ch.pipeline();                            <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;                                p.addLast(sslCtx.newHandler(ch.alloc()));                            &#125;                            <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>                            p.addLast(<span class="hljs-keyword">new</span> EchoServerHandler());                        &#125;                    &#125;);            <span class="hljs-comment">// Start the server.</span>            ChannelFuture f = b.bind(PORT).sync();            <span class="hljs-comment">// Wait until the server socket is closed.</span>            f.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// Shut down all event loops to terminate all threads.</span>            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;</code></pre></div><p>说明：</p><ol><li>先看启动类：<code>main</code> 方法中，首先创建了关于 SSL 的配置类。</li><li>重点分析下创建了两个 <code>EventLoopGroup</code> 对象：</li></ol><div class="code-wrapper"><pre><code class="hljs java">EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();</code></pre></div><p>(1) 这两个对象是整个 <code>Netty</code> 的核心对象，可以说，整个 <code>Netty</code> 的运作都依赖于他们。<code>bossGroup</code> 用于接受 <code>TCP</code> 请求，他会将请求交给 <code>workerGroup</code>，<code>workerGroup</code> 会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作。</p><p>(2) <code>EventLoopGroup</code> 是事件循环组（线程组）含有多个 <code>EventLoop</code>，可以注册 <code>channel</code>，用于在事件循环中去进行选择（和选择器相关）。【debug看】</p><p>(3) <code>new NioEventLoopGroup(1);</code> 这个 <code>1</code> 表示 <code>bossGroup</code> 事件组有 <code>1</code> 个线程你可以指定，如果 <code>new NioEventLoopGroup()</code> 会含有默认个线程 <code>cpu核数 * 2</code>，即可以充分的利用多核的优势，【可以dubug一把】</p><div class="code-wrapper"><pre><code class="hljs java">DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));</code></pre></div><p>会创建 <code>EventExecutor</code> 数组 <code>children = new EventExecutor[nThreads];</code> // <code>debug</code> 一下每个元素的类型就是 <code>NIOEventLoop</code>，<code>NIOEventLoop</code> 实现了 <code>EventLoop</code> 接口和 <code>Executor</code> 接口 <code>try</code> 块中创建了一个 <code>ServerBootstrap</code> 对象，他是一个引导类，用于启动服务器和引导整个程序的初始化（看下源码 <code>allowseasybootstrapof&#123;@linkServerChannel&#125;</code>）。它和 <code>ServerChannel</code> 关联，而 <code>ServerChannel</code> 继承了 <code>Channel</code>，有一些方法 <code>remoteAddress</code> 等[可以Debug下]随后，变量 <code>b</code> 调用了 <code>group</code> 方法将两个 <code>group</code> 放入了自己的字段中，用于后期引导使用【<code>debug</code> 下 <code>group</code> 方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *Set the &#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125; for the parent (acceptor) and the child (client) . These</span><span class="hljs-comment"> *&#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125;&#x27;s are used to handle all the events and IO for &#123;<span class="hljs-doctag">@link</span> ServerChannel&#125; and </span><span class="hljs-comment"> *&#123;<span class="hljs-doctag">@link</span> Channel&#125;&#x27;s.</span><span class="hljs-comment"> */</span></code></pre></div><p>】。</p><p>(4) 然后添加了一个 <code>channel</code>，其中参数一个 <code>Class</code> 对象，引导类将通过这个 <code>Class</code> 对象反射创建 <code>ChannelFactory</code>。然后添加了一些 <code>TCP</code> 的参数。【说明：<code>Channel</code> 的创建在 <code>bind</code> 方法，可以 <code>Debug</code> 下 <code>bind</code>，会找到 <code>channel = channelFactory.newChannel();</code> 】</p><p>(5) 再添加了一个服务器专属的日志处理器 <code>handler</code> 。</p><p>(6) 再添加一个 <code>SocketChannel</code>（不是 <code>ServerSocketChannel</code>）的 <code>handler</code>。</p><p>(7) 然后绑定端口并阻塞至连接成功。</p><p>(8) 最后 <code>main</code> 线程阻塞等待关闭。</p><p>(9) <code>finally</code> 块中的代码将在服务器关闭时优雅关闭所有资源。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Copyright 2012 The Netty Project</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * The Netty Project licenses this file to you under the Apache License,</span><span class="hljs-comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span><span class="hljs-comment"> * with the License. You may obtain a copy of the License at:</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span><span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span><span class="hljs-comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span><span class="hljs-comment"> * License for the specific language governing permissions and limitations</span><span class="hljs-comment"> * under the License.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> atguigu.netty.example.echo2;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandler.Sharable;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Handler implementation for the echo server.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Sharable</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;        ctx.write(msg);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;        ctx.flush();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;        <span class="hljs-comment">// Close the connection when an exception is raised.</span>        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><p>说明:</p><ol><li>这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端。</li><li>大致讲解了我们的 <code>demo</code> 源码的作用。后面的 <code>debug</code> 的时候会详细。</li></ol><p><strong>2. 分析 EventLoopGroup 的过程</strong></p><p>2.1 构造器方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;     <span class="hljs-keyword">this</span>(nThreads, (Executor) <span class="hljs-keyword">null</span>);&#125;</code></pre></div><p>2.2 上面的 <code>this(nThreads, (Executor) null);</code> 调用构造器（通过 <code>alt + d</code> 看即可）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor)</span> </span>&#123;    <span class="hljs-keyword">this</span>(nThreads, executor, SelectorProvider.provider());&#125;</code></pre></div><p>2.3 上面的 <code>this(nThreads, executor, SelectorProvider.provider());</code> 调用下面构造器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider)</span> </span>&#123;    <span class="hljs-keyword">this</span>(nThreads, executor, selectorProvider,DefaultSelectStrategyFactory.INSTANCE);&#125;</code></pre></div><p>2.4 上面的 <code>this()...</code> 调用构造器（<code>alt + d</code>）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider,<span class="hljs-keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;    <span class="hljs-keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());&#125;</code></pre></div><p>2.5 上面的 <code>super()..</code> 的方法是父类：<code>MultithreadEventLoopGroup</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, Object...args)</span> </span>&#123;    <span class="hljs-keyword">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);&#125;</code></pre></div><p>2.6 追踪到源码抽象类 <code>MultithreadEventExecutorGroup</code> 的构造器方法 <code>MultithreadEventExecutorGroup</code> 才是 <code>NioEventLoopGroup</code> 真正的构造方法，这里可以看成是一个模板方法，使用了设计模式的模板模式（可看我录制视频），所以，我们就需要好好分析 <code>MultithreadEventExecutorGroup</code> 方法了</p><p>2.7 分析 <code>MultithreadEventExecutorGroup</code></p><p>参数说明：</p><ul><li><code>@param nThreads</code> 使用的线程数，默认为 <code>core * 2</code>【可以追踪源码】</li><li><code>@param executor</code> 执行器:如果传入 <code>null</code>, 则采用 <code>Netty</code> 默认的线程工厂和默认的执行器 <code>ThreadPerTaskExecutor</code></li><li><code>@param chooserFactory</code> 单例 <code>new DefaultEventExecutorChooserFactory()</code></li><li><code>@param args args</code> 在创建执行器的时候传入固定参数</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor,</span></span><span class="hljs-function"><span class="hljs-params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;    <span class="hljs-keyword">if</span> (nThreads &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));    &#125;    <span class="hljs-keyword">if</span> (executor == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果传入的执行器是空的则采用默认的线程工厂和默认的执行器</span>        executor = <span class="hljs-keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());    &#125;    <span class="hljs-comment">// 创建指定线程数的执行器数组</span>    children = <span class="hljs-keyword">new</span> EventExecutor[nThreads];    <span class="hljs-comment">// 初始化线程数组</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;        <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 创建 new NioEventLoop</span>            children[i] = newChild(executor, args);            success = <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 如果创建失败，优雅关闭</span>            <span class="hljs-keyword">if</span> (!success) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;                    children[j].shutdownGracefully();                &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;                    EventExecutor e = children[j];                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);                        &#125;                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;                        <span class="hljs-comment">// Let the caller handle the interruption.</span>                        Thread.currentThread().interrupt();                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;            &#125;        &#125;    &#125;    chooser = chooserFactory.newChooser(children);    <span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> FutureListener&lt;Object&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;                terminationFuture.setSuccess(<span class="hljs-keyword">null</span>);            &#125;        &#125;    &#125;;        <span class="hljs-comment">// 为每一个单例线程池添加一个关闭监听器</span>    <span class="hljs-keyword">for</span> (EventExecutor e: children) &#123;        e.terminationFuture().addListener(terminationListener);    &#125;    Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);    <span class="hljs-comment">//将所有的单例线程池添加到一个 HashSet 中。</span>    Collections.addAll(childrenSet, children);    readonlyChildren = Collections.unmodifiableSet(childrenSet);&#125;</code></pre></div><p>说明：</p><ol><li>如果 <code>executor</code> 是 <code>null</code>，创建一个默认的 <code>ThreadPerTaskExecutor</code>，使用 <code>Netty</code> 默认的线程工厂。</li><li>根据传入的线程数（<code>CPU * 2</code>）创建一个线程池（单例线程池）数组。</li><li>循环填充数组中的元素。如果异常，则关闭所有的单例线程池。</li><li>根据线程选择工厂创建一个线程选择器。</li><li>为每一个单例线程池添加一个关闭监听器。</li><li>将所有的单例线程池添加到一个 <code>HashSet</code> 中。</li></ol><p><strong>3. ServerBootstrap 创建和构造过程</strong></p><p>3.1 <code>ServerBootstrap</code> 是个空构造，但是有默认的成员变量</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="hljs-keyword">new</span> LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();<span class="hljs-comment">// config 对象，会在后面起很大作用</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerBootstrapConfig config = <span class="hljs-keyword">new</span> ServerBootstrapConfig(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> EventLoopGroup childGroup;<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ChannelHandler childHandler;</code></pre></div><p>3.2 分析一下 <code>ServerBootstrap</code> 基本使用情况</p><div class="code-wrapper"><pre><code class="hljs java">ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();b.group(bossGroup, workerGroup)        .channel(NioServerSocketChannel.class)        .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)        .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))        .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                ChannelPipeline p = ch.pipeline();                <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;                    p.addLast(sslCtx.newHandler(ch.alloc()));                &#125;                <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>                p.addLast(<span class="hljs-keyword">new</span> EchoServerHandler());            &#125;        &#125;);</code></pre></div><p>说明:</p><ol><li>链式调用：<code>group</code> 方法，将 <code>boss</code> 和 <code>worker</code> 传入，<code>boss</code> 赋值给 <code>parentGroup</code> 属性, <code>worker</code> 赋值给 <code>childGroup</code> 属性。</li><li><code>channel</code> 方法传入 <code>NioServerSocketChannelclass</code> 对象。会根据这个 <code>class</code> 创建 <code>channel</code> 对象。</li><li><code>option</code> 方法传入 <code>TCP</code> 参数，放在一个 <code>LinkedHashMap</code> 中。</li><li><code>handler</code> 方法传入一个 <code>handler</code> 中，这个 <code>hanlder</code> 只专属于 <code>ServerSocketChannel</code> 而不是 <code>SocketChannel</code>。</li><li><code>childHandler</code> 传入一个 <code>hanlder</code>，这个 <code>handler</code> 将会在每个客户端连接的时候调用。供 <code>SocketChannel</code> 使用。</li></ol><p><strong>4. 绑定端口的分析</strong></p><p>4.1 服务器就是在这个 <code>bind</code> 方法里启动完成的 4.2 <code>bind</code> 方法代码,追踪到创建了一个端口对象，并做了一些空判断，核心代码 <code>doBind</code>，我们看看</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;    validate();    <span class="hljs-keyword">if</span> (localAddress == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;localAddress&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> doBind(localAddress);&#125;</code></pre></div><p>4.3 <code>doBind</code> 源码剖析，核心是两个方法 <code>initAndRegister</code> 和 <code>doBind0</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> </span>&#123;    <span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();    <span class="hljs-keyword">final</span> Channel channel = regFuture.channel();    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> regFuture;    &#125;    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span>        ChannelPromise promise = channel.newPromise();        <span class="hljs-comment">//============================================</span>        <span class="hljs-comment">//说明:执行doBind0方法，完成对端口的绑定</span>        <span class="hljs-comment">//============================================</span>        doBind0(regFuture, channel, localAddress, promise);        <span class="hljs-keyword">return</span> promise;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span>        <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);        regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                Throwable cause = future.cause();                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span>                    promise.setFailure(cause);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span>                    promise.registered();                    doBind0(regFuture, channel, localAddress, promise);                &#125;            &#125;        &#125;);        <span class="hljs-keyword">return</span> promise;    &#125;&#125;</code></pre></div><p>4.4 分析说明 <code>initAndRegister</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">initAndRegister</span><span class="hljs-params">()</span> </span>&#123;    Channel channel = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        channel = channelFactory.newChannel();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 说明：channelFactory.newChannel() 方法的作用通过 ServerBootstrap 的通道工厂反射创建一个 NioServerSocketChannel,具体追踪源码可以得到下面结论</span><span class="hljs-comment">         * (1)通过 NIO 的 SelectorProvider 的 openServerSocketChannel 方法得到 JDK 的 channel。目的是让 Netty 包装 JDK 的 channel。</span><span class="hljs-comment">         * (2)创建了一个唯一的 ChannelId，创建了一个 NioMessageUnsafe，用于操作消息，创建了一个 DefaultChannelPipeline 管道，是个双向链表结构，用于过滤所有的进出的消息。</span><span class="hljs-comment">         * (3)创建了一个 NioServerSocketChannelConfig 对象，用于对外展示一些配置。 </span><span class="hljs-comment">         </span><span class="hljs-comment">         * channel = channelFactory.newChannel();//NioServerSocketChannel</span><span class="hljs-comment"></span><span class="hljs-comment">         * 说明：init 初始化这个 NioServerSocketChannel，具体追踪源码可以得到如下结论</span><span class="hljs-comment">         * (1) init 方法，这是个抽象方法 (AbstractBootstrap类的），由ServerBootstrap实现（可以追一下源码//setChannelOptions(channel,options,logger);）。</span><span class="hljs-comment">         * (2)设置 NioServerSocketChannel 的 TCP 属性。</span><span class="hljs-comment">         * (3)由于 LinkedHashMap 是非线程安全的，使用同步进行处理。</span><span class="hljs-comment">         * (4)对 NioServerSocketChannel 的 ChannelPipeline 添加 ChannelInitializer 处理器。</span><span class="hljs-comment">         * (5)可以看出，init 的方法的核心作用在和 ChannelPipeline 相关。</span><span class="hljs-comment">         * (6)从 NioServerSocketChannel 的初始化过程中，我们知道，pipeline 是一个双向链表，并且，他本身就初始化了 head 和 tail，这里调用了他的 addLast 方法，也就是将整个 handler 插入到 tail 的前面，因为 tail 永远会在后面，需要做一些系统的固定工作。</span><span class="hljs-comment">         */</span>        init(channel);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;            channel.unsafe().closeForcibly();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);    &#125;    ChannelFuture regFuture = config().group().register(channel);    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;            channel.close();        &#125; <span class="hljs-keyword">else</span> &#123;            channel.unsafe().closeForcibly();        &#125;    &#125;    <span class="hljs-keyword">return</span> regFuture;&#125;</code></pre></div><p>说明：</p><ol><li>基本说明：<code>initAndRegister()</code> 初始化 <code>NioServerSocketChannel</code> 通道并注册各个 <code>handler</code>，返回一个 <code>future</code>。</li><li>通过 <code>ServerBootstrap</code> 的通道工厂反射创建一个 <code>NioServerSocketChannel</code>。</li><li><code>init</code> 初始化这个 <code>NioServerSocketChannel</code>。</li><li><code>config().group().register(channel)</code> 通过 <code>ServerBootstrap</code> 的 <code>bossGroup</code> 注册 <code>NioServerSocketChannel</code>。</li><li>最后，返回这个异步执行的占位符即 <code>regFuture</code>。</li></ol><p>4.5 <code>init</code> 方法会调用 <code>addLast</code>，现在进入到 <code>addLast</code> 方法内查看</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;        checkMultiplicity(handler);        newCtx = newContext(group, filterName(name, handler), handler);        addLast0(newCtx);        <span class="hljs-keyword">if</span> (!registered) &#123;            newCtx.setAddPending();            callHandlerCallbackLater(newCtx, <span class="hljs-keyword">true</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        EventExecutor executor = newCtx.executor();        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;            callHandlerAddedInEventLoop(newCtx, executor);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;    &#125;    callHandlerAdded0(newCtx);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre></div><p>说明：</p><ol><li><code>addLast</code> 方法，在 <code>DefaultChannelPipeline</code> 类中</li><li><code>addLast</code> 方法这就是 <code>pipeline</code> 方法的核心</li><li>检查该 <code>handler</code> 是否符合标准。</li><li>创建一个 <code>AbstractChannelHandlerContext</code> 对象，这里说一下，<code>ChannelHandlerContext</code> 对象是 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的关联，每当有 <code>ChannelHandler</code> 添加到 <code>Pipeline</code> 中时，都会创建 <code>Context</code>。<code>Context</code> 的主要功能是管理他所关联的 <code>Handler</code> 和同一个 <code>Pipeline</code> 中的其他 <code>Handler</code> 之间的交互。</li><li>将 <code>Context</code> 添加到链表中。也就是追加到 <code>tail</code> 节点的前面。</li><li>最后，同步或者异步或者晚点异步的调用 <code>callHandlerAdded0</code> 方法</li></ol><p>4.6 前面说了 <code>dobind</code> 方法有 <code>2</code> 个重要的步骤，<code>initAndRegister</code> 说完，接下来看 <code>doBind0</code> 方法，代码如下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> ChannelFuture regFuture, <span class="hljs-keyword">final</span> Channel channel,</span></span><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;    <span class="hljs-comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span>    <span class="hljs-comment">// the pipeline in its channelRegistered() implementation.</span>    channel.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (regFuture.isSuccess()) &#123;                <span class="hljs-comment">//bind方法这里下断点，这里下断点，来玩!!</span>                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);            &#125; <span class="hljs-keyword">else</span> &#123;                promise.setFailure(regFuture.cause());            &#125;        &#125;    &#125;);&#125;</code></pre></div><p>说明：</p><ol><li>该方法的参数为 <code>initAndRegister</code> 的 <code>future</code>，<code>NioServerSocketChannel</code>，端口地址，<code>NioServerSocketChannel</code> 的 <code>promise</code></li><li>这里就可以根据前面下的断点，一直 <code>debug</code>：</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 将调用 LoggingHandler 的 invokeBind 方法,最后会追到</span><span class="hljs-comment">// DefaultChannelPipeline 类的 bind</span><span class="hljs-comment">// 然后进入到 unsafe.bind 方法 debug，注意要追踪到</span><span class="hljs-comment">// unsafe.bind，要 debug 第二圈的时候，才能看到。</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span> <span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    unsafe.bind(localAddress,promise);&#125;<span class="hljs-comment">// 继续追踪 AbstractChannel 的 </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span> <span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;    <span class="hljs-comment">//....</span>    <span class="hljs-keyword">try</span>&#123;        <span class="hljs-comment">//!!!! 小红旗可以看到，这里最终的方法就是 doBind 方法，执行成功后，执行通道的 fireChannelActive 方法，告诉所有的 handler，已经成功绑定。</span>        doBind(localAddress);<span class="hljs-comment">//</span>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        safeSetFailure(promise, t);        closeIfClosed();        <span class="hljs-keyword">return</span>;    &#125;&#125;</code></pre></div><ol><li>最终 <code>doBind</code> 就会追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>，说明 <code>Netty</code> 底层使用的是 <code>NIO</code></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span> <span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;        javaChannel().bind(localAddress, config.getBacklog());    &#125; <span class="hljs-keyword">else</span> &#123;        javaChannel().socket().bind(localAddress, config.getBacklog());    &#125;&#125;</code></pre></div><ol><li>回到 <code>bind</code> 方法（<code>alt + v</code>），最后一步：<code>safeSetSuccess(promise)</code>，告诉 <code>promise</code> 任务成功了。其可以执行监听器的方法了。到此整个启动过程已经结束了，ok 了</li><li>继续 <code>atl + v</code> 服务器就回进入到（<code>NioEventLoop</code> 类）一个循环代码，进行监听</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(;;) &#123;        <span class="hljs-keyword">try</span>&#123;        &#125;    &#125;&#125;</code></pre></div><h4 id="10-2-4-Netty-启动过程梳理"><a href="#10-2-4-Netty-启动过程梳理" class="headerlink" title="10.2.4 Netty 启动过程梳理"></a>10.2.4 Netty 启动过程梳理</h4><ol><li>创建 <code>2</code> 个 <code>EventLoopGroup</code> 线程池数组。数组默认大小 <code>CPU * 2</code>，方便 <code>chooser</code> 选择线程池时提高性能</li><li><code>BootStrap</code> 将 <code>boss</code> 设置为 <code>group</code> 属性，将 <code>worker</code> 设置为 <code>childer</code> 属性</li><li>通过 <code>bind</code> 方法启动，内部重要方法为 <code>initAndRegister</code> 和 <code>dobind</code> 方法</li><li><code>initAndRegister</code> 方法会反射创建 <code>NioServerSocketChannel</code> 及其相关的 <code>NIO</code> 的对象，<code>pipeline</code>，<code>unsafe</code>，同时也为 <code>pipeline</code> 初始了 <code>head</code> 节点和 <code>tail</code> 节点。</li><li>在 <code>register0</code> 方法成功以后调用在 <code>dobind</code> 方法中调用 <code>doBind0</code> 方法，该方法会调用 <code>NioServerSocketChannel</code> 的 <code>doBind</code> 方法对 <code>JDK</code> 的 <code>channel</code> 和端口进行绑定，完成 <code>Netty</code> 服务器的所有启动，并开始监听连接事件。</li></ol><h3 id="10-3-Netty-接受请求过程源码剖析"><a href="#10-3-Netty-接受请求过程源码剖析" class="headerlink" title="10.3 Netty 接受请求过程源码剖析"></a>10.3 Netty 接受请求过程源码剖析</h3><h4 id="10-3-1-源码剖析目的"><a href="#10-3-1-源码剖析目的" class="headerlink" title="10.3.1 源码剖析目的"></a>10.3.1 源码剖析目的</h4><ol><li>服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，下面源码分析 <code>Netty</code> 在启动之后是如何接受客户端请求的</li><li>在 <code>io.netty.example</code> 包下</li></ol><h4 id="10-3-2-源码剖析"><a href="#10-3-2-源码剖析" class="headerlink" title="10.3.2 源码剖析"></a>10.3.2 源码剖析</h4><p>说明：</p><ol><li>从之前服务器启动的源码中，我们得知，服务器最终注册了一个 <code>Accept</code> 事件等待客户端的连接。我们也知道，<code>NioServerSocketChannel</code> 将自己注册到了 <code>boss</code> 单例线程池（<code>reactor</code> 线程）上，也就是 <code>EventLoop</code>。</li><li>先简单说下 <code>EventLoop</code> 的逻辑(后面我们详细讲解 <code>EventLoop</code>)</li></ol><p><code>EventLoop</code> 的作用是一个死循环，而这个循环中做 3 件事情：</p><ol><li><p>有条件的等待 <code>NIO</code> 事件。</p></li><li><p>处理 <code>NIO</code> 事件。</p></li><li><p>处理消息队列中的任务。</p></li><li><p>仍用前面的项目来分析：进入到 <code>NioEventLoop</code> 源码中后，在 <code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法开始调试最终我们要分析到 <code>AbstractNioChannel</code> 的 <code>doBeginRead</code> 方法，当到这个方法时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</p><p>源码分析过程</p></li><li><p>断点位置 <code>NioEventLoop</code> 的如下方法 <code>processSelectedKey</code></p></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;    unsafe.read();<span class="hljs-comment">//断点位置</span>&#125;</code></pre></div><ol><li>执行浏览器 <code>http://localhost:8007/</code> ，客户端发出请求</li><li>从的断点我们可以看到，<code>readyOps</code> 是 <code>16</code>，也就是 <code>Accept</code> 事件。说明浏览器的请求已经进来了。</li><li>这个 <code>unsafe</code> 是 <code>boss</code> 线程中 <code>NioServerSocketChannel</code> 的 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 对象。我们进入到 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 的 <code>read</code> 方法中</li><li><code>read</code> 方法代码并分析:</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    asserteventLoop().inEventLoop();    <span class="hljs-keyword">final</span> ChannelConfig config = config();    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();    allocHandle.reset(config);    booleanclosed = <span class="hljs-keyword">false</span>;    Throwable exception = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-keyword">int</span> localRead = doReadMessages(readBuf);                <span class="hljs-keyword">if</span> (localRead == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (localRead &lt; <span class="hljs-number">0</span>) &#123;                    closed = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;                                allocHandle.incMessagesRead(localRead);            &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            exception = t;        &#125;                <span class="hljs-keyword">int</span> size = readBuf.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            readPending = <span class="hljs-keyword">false</span>;            pipeline.fireChannelRead(readBuf.get(i));        &#125;        readBuf.clear();        allocHandle.readComplete();        pipeline.fireChannelReadComplete();                <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;            closed = closeOnReadError(exception);            pipeline.fireExceptionCaught(exception);        &#125;                <span class="hljs-keyword">if</span> (closed) &#123;            inputShutdown = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span>(isOpen()) &#123;                close(voidPromise());            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">//Check if there is a readPending which was not processed yet.</span>        <span class="hljs-comment">//This could be for two reasons:</span>        <span class="hljs-comment">//* The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span>        <span class="hljs-comment">//* The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span>        <span class="hljs-comment">//</span>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;            removeReadOp();        &#125;    &#125;&#125;</code></pre></div><p>说明： 1)检查该 <code>eventloop</code> 线程是否是当前线程。<code>asserteventLoop().inEventLoop()</code></p><p>2)执行 <code>doReadMessages</code> 方法，并传入一个 <code>readBuf</code> 变量，这个变量是一个 <code>List</code>，也就是容器。</p><p>3)循环容器，执行 <code>pipeline.fireChannelRead(readBuf.get(i));</code></p><p>4)<code>doReadMessages</code> 是读取 <code>boss</code> 线程中的 <code>NioServerSocketChannel</code> 接受到的请求。并把这些请求放进容器，一会我们 <code>debug</code> 下 <code>doReadMessages</code> 方法。</p><p>5)循环遍历容器中的所有请求，调用 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法，用于处理这些接受的请求或者其他事件，在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p><ol><li>追踪一下 <code>doReadMessages</code> 方法，就可以看得更清晰</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span> <span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    SocketChannel ch = SocketUtils.accept(javaChannel());    buf.add(newNioSocketChannel(<span class="hljs-keyword">this</span>, ch));    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><p>说明： 1)通过工具类，调用 <code>NioServerSocketChannel</code> 内部封装的 <code>serverSocketChannel</code> 的 <code>accept</code> 方法，这是 <code>NIO</code> 做法。</p><p>2)获取到一个 <code>JDK</code> 的 <code>SocketChannel</code>，然后，使用 <code>NioSocketChannel</code> 进行封装。最后添加到容器中</p><p>3)这样容器 <code>buf</code> 中就有了 <code>NioSocketChannel</code> 【如果有兴趣可以追一下 <code>NioSocketChannel</code> 是如何创建的，我就不追了】</p><ol><li>回到 <code>read</code> 方法，继续分析循环执行 <code>pipeline.fireChannelRead</code> 方法</li></ol><p>1)前面分析 <code>doReadMessages</code> 方法的作用是通过 <code>ServerSocket</code> 的 <code>accept</code> 方法获取到 <code>TCP</code> 连接，然后封装成 <code>Netty</code> 的 <code>NioSocketChannel</code> 对象。最后添加到容器中</p><p>2)在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p><p>3)经过 <code>dubug</code>（多次），可以看到会反复执行多个 <code>handler</code> 的 <code>ChannelRead</code>，我们知道，<code>pipeline</code> 里面又 <code>4</code> 个 <code>handler</code>，分别是 <code>Head</code>，<code>LoggingHandler</code>，<code>ServerBootstrapAcceptor</code>，<code>Tail</code>。</p><p>4)我们重点看看 <code>ServerBootstrapAcceptor</code>。<code>debug</code> 之后，断点会进入到 <code>ServerBootstrapAcceptor</code> 中来。我们来看看 <code>ServerBootstrapAcceptor</code> 的 <code>channelRead</code> 方法（要多次 <code>debug</code> 才可以）</p><p>5)<code>channelRead</code> 方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span> <span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;    <span class="hljs-keyword">final</span> Channelchild = (Channel)msg;    child.pipeline().addLast(childHandler);    setChannelOptions(child, childOptions, logger);    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e : childAttrs) &#123;        child.attr((AttributeKey&lt;Object&gt;)e.getKey()).set(e.getValue());    &#125;    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//将客户端连接注册到 worker 线程池</span>        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuturefuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;                    forceClose(child, future.cause());                &#125;            &#125;        &#125;);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        forceClose(child, t);    &#125;&#125;</code></pre></div><p>说明： 1)<code>msg</code> 强转成 <code>Channel</code>，实际上就是 <code>NioSocketChannel</code>。</p><p>2)添加 <code>NioSocketChannel</code> 的 <code>pipeline</code> 的 <code>handler</code>，就是我们 <code>main</code> 方法里面设置的 <code>childHandler</code> 方法里的。</p><p>3)设置 <code>NioSocketChannel</code> 的各种属性。</p><p>4)将该 <code>NioSocketChannel</code> 注册到 <code>childGroup</code> 中的一个 <code>EventLoop</code> 上，并添加一个监听器。</p><p>5)这个 <code>childGroup</code> 就是我们 <code>main</code> 方法创建的数组 <code>workerGroup</code>。</p><ol><li>进入 <code>register</code> 方法查看(步步追踪会到)</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span> <span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;        register0(promise);    &#125; <span class="hljs-keyword">else</span> &#123;        eventLoop.execute(<span class="hljs-keyword">new</span> Runnable()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                register0(promise);<span class="hljs-comment">//进入到这里</span>            &#125;        &#125;);    &#125;&#125;<span class="hljs-comment">// 继续进入到下面方法，执行管道中可能存在的任务,这里我们就不追了</span></code></pre></div><ol><li>最终会调用 <code>doBeginRead</code> 方法，也就是 <code>AbstractNioChannel</code> 类的方法</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//Channel.read() or ChannelHandlerContext.read() was called</span>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<span class="hljs-comment">//断点</span>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;        <span class="hljs-keyword">return</span>;    &#125;    readPending = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();    <span class="hljs-keyword">if</span> ((interestOps&amp;readInterestOp) == <span class="hljs-number">0</span>) &#123;        selectionKey.interestOps(interestOps | readInterestOp);    &#125;&#125;</code></pre></div><ol><li>这个地方调试时，请把前面的断点都去掉，然后启动服务器就会停止在 <code>doBeginRead</code>（需要先放过该断点，然后浏览器请求，才能看到效果）</li><li>执行到这里时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</li></ol><h4 id="10-3-3-Netty-接受请求过程梳理"><a href="#10-3-3-Netty-接受请求过程梳理" class="headerlink" title="10.3.3 Netty 接受请求过程梳理"></a>10.3.3 Netty 接受请求过程梳理</h4><p>总体流程：接受连接 –&gt; 创建一个新的 <code>NioSocketChannel</code> –&gt; 注册到一个 <code>workerEventLoop</code> 上 –&gt; 注册 <code>selecotRead</code> 事件。</p><ol><li>服务器轮询 <code>Accept</code> 事件，获取事件后调用 <code>unsafe</code> 的 <code>read</code> 方法，这个 <code>unsafe</code> 是 <code>ServerSocket</code> 的内部类，该方法内部由 <code>2</code> 部分组成</li><li><code>doReadMessages</code> 用于创建 <code>NioSocketChannel</code> 对象，该对象包装 <code>JDK</code> 的 <code>NioChannel</code> 客户端。该方法会像创建 <code>ServerSocketChanel</code> 类似创建相关的 <code>pipeline</code>，<code>unsafe</code>，<code>config</code></li><li>随后执行执行 <code>pipeline.fireChannelRead</code> 方法，并将自己绑定到一个 <code>chooser</code> 选择器选择的 <code>workerGroup</code> 中的一个 <code>EventLoop</code>。并且注册一个 <code>0</code>，表示注册成功，但并没有注册读（1）事件</li></ol><h3 id="10-4-Pipeline-Handler-HandlerContext-创建源码剖析"><a href="#10-4-Pipeline-Handler-HandlerContext-创建源码剖析" class="headerlink" title="10.4 Pipeline Handler HandlerContext 创建源码剖析"></a>10.4 Pipeline Handler HandlerContext 创建源码剖析</h3><h4 id="10-4-1-源码剖析目的"><a href="#10-4-1-源码剖析目的" class="headerlink" title="10.4.1 源码剖析目的"></a>10.4.1 源码剖析目的</h4><p><code>Netty</code> 中的 <code>ChannelPipeline</code>、<code>ChannelHandler</code> 和 <code>ChannelHandlerContext</code> 是非常核心的组件，我们从源码来分析 <code>Netty</code> 是如何设计这三个核心组件的，并分析是如何创建和协调工作的.</p><h4 id="10-4-2-源码剖析说明"><a href="#10-4-2-源码剖析说明" class="headerlink" title="10.4.2 源码剖析说明"></a>10.4.2 源码剖析说明</h4><p>说明 分析过程中，有很多的图形，所以我们准备了一个文档，在文档的基础上来做源码剖析</p><h4 id="10-4-3-源码剖析"><a href="#10-4-3-源码剖析" class="headerlink" title="10.4.3 源码剖析"></a>10.4.3 源码剖析</h4><ol><li>ChannelPipeline | ChannelHandler | ChannelHandlerContext介绍</li><li>1 三者关系</li></ol><p>1)每当 <code>ServerSocket</code> 创建一个新的连接，就会创建一个 <code>Socket</code>，对应的就是目标客户端。</p><p>2)每一个新创建的 <code>Socket</code> 都将会分配一个全新的 <code>ChannelPipeline</code>（以下简称 <code>pipeline</code>）</p><p>3)每一个 <code>ChannelPipeline</code> 内部都含有多个 <code>ChannelHandlerContext</code>（以下简称 <code>Context</code>）</p><p>4)他们一起组成了双向链表，这些 <code>Context</code> 用于包装我们调用 <code>addLast</code> 方法时添加的 <code>ChannelHandler</code>（以下简称 <code>handler</code>）</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_02.png" alt="img"></p><p>1)上图中：<code>ChannelSocket</code> 和 <code>ChannelPipeline</code> 是一对一的关联关系，而 <code>pipeline</code> 内部的多个 <code>Context</code> 形成了链表，<code>Context</code> 只是对 <code>Handler</code> 的封装。 2)当一个请求进来的时候，会进入 <code>Socket</code> 对应的 <code>pipeline</code>，并经过 <code>pipeline</code> 所有的 <code>handler</code>，对，就是设计模式中的过滤器模式。</p><p>1.2 ChannelPipeline 作用及设计</p><p>1)<code>pipeline</code> 的接口设计</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_03.png" alt="img"></p><p>部分源码</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_04.png" alt="img"></p><p>可以看到该接口继承了 <code>inBound</code>，<code>outBound</code>，<code>Iterable</code> 接口，表示他可以调用数据出站的方法和入站的方法，同时也能遍历内部的链表，看看他的几个代表性的方法，基本上都是针对 <code>handler</code> 链表的插入，追加，删除，替换操作，类似是一个 <code>LinkedList</code>。同时，也能返回 <code>channel</code>（也就是 <code>socket</code>）</p><p>1)在 <code>pipeline</code> 的接口文档上，提供了一幅图</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_05.png" alt="img"></p><p>对上图的解释说明： *这是一个 <code>handler</code> 的 <code>list</code>，<code>handler</code> 用于处理或拦截入站事件和出站事件，<code>pipeline</code> 实现了过滤器的高级形式，以便用户控制事件如何处理以及 <code>handler</code> 在 <code>pipeline</code> 中如何交互。</p><p>*上图描述了一个典型的 <code>handler</code> 在 <code>pipeline</code> 中处理 <code>I/O</code> 事件的方式，<code>IO</code> 事件由 <code>inboundHandler</code> 或者 <code>outBoundHandler</code> 处理，并通过调用 <code>ChannelHandlerContext.fireChannelRead</code> 方法转发给其最近的处理程序。</p><p>*入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的 <code>I/O</code> 线程生成入站数据。入站数据通常从如 <code>SocketChannel.read(ByteBuffer)</code> 获取。</p><p>*通常一个 <code>pipeline</code> 有多个 <code>handler</code>，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序协议解码器-将二进制数据转换为 <code>Java</code> 对象。协议编码器-将 <code>Java</code> 对象转换为二进制数据。业务逻辑处理程序-执行实际业务逻辑（例如数据库访问）</p><p>*你的业务程序不能将线程阻塞，会影响 <code>IO</code> 的速度，进而影响整个 <code>Netty</code> 程序的性能。如果你的业务程序很快，就可以放在 <code>IO</code> 线程中，反之，你需要异步执行。或者在添加 <code>handler</code> 的时候添加一个线程池，例如：</p><p>// 下面这个任务执行的时候，将不会阻塞 <code>IO</code> 线程，执行的线程来自 <code>group</code> 线程池</p><div class="code-wrapper"><pre><code class="hljs reasonml">pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">group</span>, <span class="hljs-string">&quot;handler&quot;</span>, <span class="hljs-params">new</span> MyBusinessLogicHandler()</span>);</code></pre></div><p>1.3 <code>ChannelHandler</code> 作用及设计</p><p>1)源码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelHandler</span> </span>&#123;    <span class="hljs-comment">//当把 ChannelHandler 添加到 pipeline 时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-comment">//当从 pipeline 中移除时调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-comment">//当处理过程中在 pipeline 发生异常时调用</span>    <span class="hljs-meta">@Deprecated</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><p>2)<code>ChannelHandler</code> 的作用就是处理 <code>IO</code> 事件或拦截 <code>IO</code> 事件，并将其转发给下一个处理程序 <code>ChannelHandler</code>。<code>Handler</code> 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，<code>Netty</code> 定义了两个子接口继承 <code>ChannelHandler</code></p><p>2)<code>ChannelInboundHandler</code> 入站事件接口</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_06.png" alt="img"></p><p>*<code>channelActive</code> 用于当 <code>Channel</code> 处于活动状态时被调用；</p><p>*<code>channelRead</code> 当从 <code>Channel</code> 读取数据时被调用等等方法。</p><p>*程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，<code>Netty</code> 会回调对应的方法。</p><p>3)`ChannelOutboundHandler 出站事件接口</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_07.png" alt="img"></p><p>*<code>bind</code> 方法，当请求将 <code>Channel</code> 绑定到本地地址时调用</p><p>*<code>close</code> 方法，当请求关闭 <code>Channel</code> 时调用等等</p><p>*出站操作都是一些连接和写出数据类似的方法。</p><p>4)<code>ChannelDuplexHandler</code> 处理出站和入站事件</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_08.png" alt="img"></p><p>*<code>ChannelDuplexHandler</code> 间接实现了入站接口并直接实现了出站接口。</p><p>*是一个通用的能够同时处理入站事件和出站事件的类。</p><p>1.4 <code>ChannelHandlerContext</code> 作用及设计</p><p>1)<code>ChannelHandlerContext</code> <code>UML</code> 图</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_09.png" alt="img"></p><p><code>ChannelHandlerContext</code> 继承了出站方法调用接口和入站方法调用接口</p><p>1)<code>ChannelOutboundInvoker</code> 和 <code>ChannelInboundInvoker</code> 部分源码</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_10.png" alt="img"></p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_11.png" alt="img"></p><p>*这两个 <code>invoker</code> 就是针对入站或出站方法来的，就是在入站或出站 <code>handler</code> 的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的</p><p>2)<code>ChannelHandlerContext</code> 部分源码</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_12.png" alt="img"></p><p>*<code>ChannelHandlerContext</code> 不仅仅时继承了他们两个的方法，同时也定义了一些自己的方法</p><p>*这些方法能够获取 <code>Context</code> 上下文环境中对应的比如 <code>channel</code>，<code>executor</code>，<code>handler</code>，<code>pipeline</code>，内存分配器，关联的 <code>handler</code> 是否被删除。</p><p>*<code>Context</code> 就是包装了 <code>handler</code> 相关的一切，以方便 <code>Context</code> 可以在 <code>pipeline</code> 方便的操作 <code>handler</code></p><p>2.ChannelPipeline | ChannelHandler | ChannelHandlerContext</p><p>创建过程分为 <code>3</code> 个步骤来看创建的过程：</p><p>*任何一个 <code>ChannelSocket</code> 创建的同时都会创建一个 <code>pipeline</code>。</p><p>*当用户或系统内部调用 <code>pipeline</code> 的 <code>add</code></p><p>*** 方法添加 <code>handler</code> 时，都会创建一个包装这 <code>handler</code> 的 <code>Context</code>。</p><p>*这些 <code>Context</code> 在 <code>pipeline</code> 中组成了双向链表。</p><p>2.1 <code>Socket</code> 创建的时候创建 <code>pipeline</code> 在 <code>SocketChannel</code> 的抽象父类 <code>AbstractChannel</code> 的构造方法中</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractChannel</span><span class="hljs-params">(Channel parent)</span> </span>&#123;    <span class="hljs-keyword">this</span>.parent=parent;<span class="hljs-comment">//断点测试</span>    id = newId();    unsafe = <span class="hljs-keyword">new</span> Unsafe();    pipeline = <span class="hljs-keyword">new</span> ChannelPipeline();&#125;</code></pre></div><p><code>Debug</code> 一下，可以看到代码会执行到这里，然后继续追踪到</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">DefaultChannelPipeline</span><span class="hljs-params">(Channel channel)</span> </span>&#123;    <span class="hljs-keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="hljs-string">&quot;channel&quot;</span>);    succeededFuture = <span class="hljs-keyword">new</span> SucceededChannelFuture(channel, <span class="hljs-keyword">null</span>);    voidPromise = <span class="hljs-keyword">new</span> VoidChannelPromise(channel, <span class="hljs-keyword">true</span>);    tail = <span class="hljs-keyword">new</span> TailContext(<span class="hljs-keyword">this</span>);    head = <span class="hljs-keyword">new</span> HeadContext(<span class="hljs-keyword">this</span>);    head.next = tail;    tail.prev = head;&#125;</code></pre></div><p>说明：</p><p>1）将 <code>channel</code> 赋值给 <code>channel</code> 字段，用于 <code>pipeline</code> 操作 <code>channel</code>。</p><p>2）创建一个 <code>future</code> 和 <code>promise</code>，用于异步回调使用。</p><p>3）创建一个 <code>inbound</code> 的 <code>tailContext</code>，创建一个既是 <code>inbound</code> 类型又是 <code>outbound</code> 类型的 <code>headContext</code>。</p><p>4）最后，将两个 <code>Context</code> 互相连接，形成双向链表。</p><p>5）<code>tailContext</code> 和 <code>HeadContext</code> 非常的重要，所有 <code>pipeline</code> 中的事件都会流经他们，</p><p>2.2 在 add<strong>添加处理器的时候创建Context</strong>看下 <code>DefaultChannelPipeline</code> 的 <code>addLast</code> 方法如何创建的 <code>Context</code>，代码如下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;    <span class="hljs-keyword">if</span> (handlers == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//断点</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;handlers&quot;</span>);    &#125;    <span class="hljs-keyword">for</span> (ChannelHandler h : handlers) &#123;        <span class="hljs-keyword">if</span> (h == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        addLast(executor, <span class="hljs-keyword">null</span>, h);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre></div><p>继续 Debug</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;        checkMultiplicity(handler);        newCtx = newContext(group, filterName(name, handler), handler);        addLast0(newCtx);        <span class="hljs-comment">//If the registered is false it means that the channel was not registered on an eventloop yet.</span>        <span class="hljs-comment">//In this case we add the context to the pipeline and add a task that will call</span>        <span class="hljs-comment">//ChannelHandler.handlerAdded(...) once the channel is registered.</span>        <span class="hljs-keyword">if</span> (!registered) &#123;            newCtx.setAddPending();            callHandlerCallbackLater(newCtx, <span class="hljs-keyword">true</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        EventExecutor executor = newCtx.executor();        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;            newCtx.setAddPending();            executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>&#123;                    callHandlerAdded0(newCtx);                &#125;            &#125;);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;    &#125;    callHandlerAdded0(newCtx);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre></div><p>说明 1)<code>pipeline</code> 添加 <code>handler</code>，参数是线程池，<code>name</code> 是 <code>null</code>，<code>handler</code> 是我们或者系统传入的 <code>handler</code>。<code>Netty</code> 为了防止多个线程导致安全问题，同步了这段代码，步骤如下：</p><p>2)检查这个 <code>handler</code> 实例是否是共享的，如果不是，并且已经被别的 <code>pipeline</code> 使用了，则抛出异常。</p><p>3)调用 <code>new Context(group, filterName(name, handler), handler)</code> 方法，创建一个 <code>Context</code>。从这里可以看出来了，每次添加一个 <code>handler</code> 都会创建一个关联 <code>Context</code>。</p><p>4)调用 <code>addLast</code> 方法，将 <code>Context</code> 追加到链表中。</p><p>5)如果这个通道还没有注册到 <code>selecor</code> 上，就将这个 <code>Context</code> 添加到这个 <code>pipeline</code> 的待办任务中。当注册好了以后，就会调用 <code>callHandlerAdded0</code> 方法（默认是什么都不做，用户可以实现这个方法）。</p><p>6)到这里，针对三对象创建过程，了解的差不多了，和最初说的一样，每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。<code>tail</code> 是入站 <code>inbound</code> 类型的 <code>handler</code>，<code>head</code> 既是 <code>inbound</code> 也是 <code>outbound</code> 类型的 <code>handler</code>。在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。到此就 <code>OK</code> 了。</p><h4 id="10-4-4-Pipeline-Handler-HandlerContext-创建过程梳理"><a href="#10-4-4-Pipeline-Handler-HandlerContext-创建过程梳理" class="headerlink" title="10.4.4 Pipeline Handler HandlerContext 创建过程梳理"></a>10.4.4 Pipeline Handler HandlerContext 创建过程梳理</h4><ol><li>每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。</li><li>在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。</li><li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表</li><li>入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始</li></ol><h3 id="10-5-ChannelPipeline-调度-handler-的源码剖析"><a href="#10-5-ChannelPipeline-调度-handler-的源码剖析" class="headerlink" title="10.5 ChannelPipeline 调度 handler 的源码剖析"></a>10.5 ChannelPipeline 调度 handler 的源码剖析</h3><h4 id="10-5-1-源码剖析目的"><a href="#10-5-1-源码剖析目的" class="headerlink" title="10.5.1 源码剖析目的"></a>10.5.1 源码剖析目的</h4><ol><li>当一个请求进来的时候，<code>ChannelPipeline</code> 是如何调用内部的这些 <code>handler</code> 的呢？我们一起来分析下。</li><li>首先，当一个请求进来的时候，会第一个调用 <code>pipeline</code> 的相关方法，如果是入站事件，这些方法由 <code>fire</code> 开头，表示开始管道的流动。让后面的 <code>handler</code> 继续处理</li></ol><h4 id="10-5-2-源码剖析"><a href="#10-5-2-源码剖析" class="headerlink" title="10.5.2 源码剖析"></a>10.5.2 源码剖析</h4><p>当浏览器输入 <code>http://localhost:8007</code> 。可以看到会执行 <code>handler</code> 在 <code>Debug</code> 时，可以将断点下在 <code>DefaultChannelPipeline</code> 类的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelActive</span><span class="hljs-params">()</span> </span>&#123;    AbstractChannelHandlerContext.invokeChannelActive(head);<span class="hljs-comment">//断点</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre></div><p>源码分析</p><ol><li><code>DefaultChannelPipeline</code> 是如何实现这些 <code>fire</code> 方法的 3.1 <code>DefaultChannelPipeline</code> 源码</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultChannelPipeline</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelPipeline</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelActive</span><span class="hljs-params">()</span> </span>&#123;        AbstractChannelHandlerContext.invokeChannelActive(head);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-title">ChannelPipelinefireChannelInactive</span><span class="hljs-params">()</span> </span>&#123;        AbstractChannelHandlerContext.invokeChannelInactive(head);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireExceptionCaught</span><span class="hljs-params">(Throwable cause)</span> </span>&#123;        AbstractChannelHandlerContext.invokeExceptionCaught(head, cause);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireUserEventTriggered</span><span class="hljs-params">(Object event)</span> </span>&#123;        AbstractChannelHandlerContext.invokeUserEventTriggered(head, event);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelRead</span><span class="hljs-params">(Objectmsg)</span> </span>&#123;        AbstractChannelHandlerContext.invokeChannelRead(head, msg);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelReadComplete</span><span class="hljs-params">()</span> </span>&#123;        AbstractChannelHandlerContext.invokeChannelReadComplete(head);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelWritabilityChanged</span><span class="hljs-params">()</span> </span>&#123;        AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;</code></pre></div><p>说明： 可以看出来，这些方法都是 <code>inbound</code> 的方法，也就是入站事件，调用静态方法传入的也是 <code>inbound</code> 的类型 <code>head</code> <code>handler</code>。这些静态方法则会调用 <code>head</code> 的 <code>ChannelInboundInvoker</code> 接口的方法，再然后调用 <code>handler</code> 的真正方法</p><p>3.2再看下 <code>piepline</code> 的 <code>outbound</code> 的 <code>fire</code> 方法实现源码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultChannelPipeline</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelPipeline</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.bind(localAddress);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.connect(remoteAddress);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, localAddress);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> tail.disconnect();    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.close();    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">deregister</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.deregister();    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;        tail.flush();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.bind(localAddress, promise);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, promise);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, localAddress, promise);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.disconnect(promise);    &#125;&#125;</code></pre></div><p>说明：</p><p>1)这些都是出站的实现，但是调用的是 <code>outbound</code> 类型的 <code>tailhandler</code> 来进行处理，因为这些都是 <code>outbound</code> 事件。</p><p>2)出站是 <code>tail</code> 开始，入站从 <code>head</code> 开始。因为出站是从内部向外面写，从 <code>tail</code> 开始，能够让前面的 <code>handler</code> 进行处理，防止 <code>handler</code> 被遗漏，比如编码。反之，入站当然是从 <code>head</code> 往内部输入，让后面的 <code>handler</code> 能够处理这些输入的数据。比如解码。因此虽然 <code>head</code> 也实现了 <code>outbound</code> 接口，但不是从 head 开始执行出站任务</p><p>4.关于如何调度，用一张图来表示:</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_13.png" alt="img"></p><p>说明： 1)<code>pipeline</code> 首先会调用 <code>Context</code> 的静态方法 <code>fireXXX</code>，并传入 <code>Context</code></p><p>2)然后，静态方法调用 <code>Context</code> 的 <code>invoker</code> 方法，而 <code>invoker</code> 方法内部会调用该 <code>Context</code> 所包含的 <code>Handler</code> 的真正的 <code>XXX</code> 方法，调用结束后，如果还需要继续向后传递，就调用 <code>Context</code> 的 <code>fireXXX2</code> 方法，循环往复。</p><h4 id="10-5-3-ChannelPipeline-调度-handler-梳理"><a href="#10-5-3-ChannelPipeline-调度-handler-梳理" class="headerlink" title="10.5.3 ChannelPipeline 调度 handler 梳理"></a>10.5.3 ChannelPipeline 调度 handler 梳理</h4><ol><li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表，入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始。</li><li>而节点中间的传递通过 <code>Abstract ChannelHandlerContext</code> 类内部的 <code>fire</code> 系列方法，找到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对 <code>handler</code> 的调度</li></ol><h3 id="10-6-Netty-心跳-heartbeat-服务源码剖析"><a href="#10-6-Netty-心跳-heartbeat-服务源码剖析" class="headerlink" title="10.6 Netty 心跳(heartbeat)服务源码剖析"></a>10.6 Netty 心跳(heartbeat)服务源码剖析</h3><h4 id="10-6-1-源码剖析目的"><a href="#10-6-1-源码剖析目的" class="headerlink" title="10.6.1 源码剖析目的"></a>10.6.1 源码剖析目的</h4><p><code>Netty</code> 作为一个网络框架，提供了诸多功能，比如编码解码等，<code>Netty</code> 还提供了非常重要的一个服务 – 心跳机制 <code>heartbeat</code>。通过心跳检查对方是否有效，这是 <code>RPC</code> 框架中是必不可少的功能。下面我们分析一下 <code>Netty</code> 内部心跳服务源码实现。</p><h4 id="10-6-2-源码剖析"><a href="#10-6-2-源码剖析" class="headerlink" title="10.6.2 源码剖析"></a>10.6.2 源码剖析</h4><p><code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性，重点分析 <code>IdleStateHandler</code>。</p><p>如图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_14.png" alt="img"></p><p>源码剖析：</p><p>5.<code>Netty</code> 提供的心跳介绍</p><p>1)<code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性。</p><p>2)如图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_15.png" alt="img"></p><p>3)<code>ReadTimeout</code> 事件和 <code>WriteTimeout</code> 事件都会自动关闭连接，而且，属于异常处理，所以，这里只是介绍以下，我们重点看 <code>IdleStateHandler</code>。</p><p>6.<code>IdleStateHandler</code> 分析</p><p>6.1 <code>4</code> 个属性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> observeOutput; <span class="hljs-comment">//是否考虑出站时较慢的情况。默认值是 false</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> readerIdleTimeNanos; <span class="hljs-comment">//读事件空闲时间，0 则禁用事件</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> writerIdleTimeNanos;<span class="hljs-comment">//写事件空闲时间，0 则禁用事件</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> allIdleTimeNanos;<span class="hljs-comment">//读或写空闲时间，0 则禁用事件</span></code></pre></div><p>6.2<code>handlerAdded</code> 方法</p><p>当该 <code>handler</code> 被添加到 <code>pipeline</code> 中时，则调用 <code>initialize</code> 方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;    <span class="hljs-comment">//Avoid the case where destroy() is called before scheduling timeouts.</span>    <span class="hljs-comment">//See:https://github.com/netty/netty/issues/143</span>    <span class="hljs-keyword">switch</span>(state) &#123;        case1:        case2:            <span class="hljs-keyword">return</span>;    &#125;        state=<span class="hljs-number">1</span>;    initOutputChanged(ctx);        lastReadTime = lastWriteTime = ticksInNanos();        <span class="hljs-keyword">if</span>(readerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列中</span>        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> ReaderIdleTimeoutTask(ctx), readerIdleTimeNanos, TimeUnit.NANOSECONDS);    &#125;        <span class="hljs-keyword">if</span>(writerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> WriterIdleTimeoutTask(ctx), writerIdleTimeNanos, TimeUnit.NANOSECONDS);    &#125;        <span class="hljs-keyword">if</span>(allIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> AllIdleTimeoutTask(ctx), allIdleTimeNanos, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre></div><p>只要给定的参数大于 <code>0</code>，就创建一个定时任务，每个事件都创建。同时，将 <code>state</code> 状态设置为 <code>1</code>，防止重复初始化。调用 <code>initOutputChanged</code> 方法，初始化“监控出站数据属性”。</p><p>6.3该类内部的 <code>3</code> 个定时任务类</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_16.png" alt="img"></p><p>1)这 <code>3</code> 个定时任务分别对应读，写，读或者写事件。共有一个父类（<code>AbstractIdleTask</code>）。这个父类提供了一个模板方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractIdleTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelHandlerContext ctx;        AbstractIdleTask(ChannelHandlerContext ctx) &#123;        <span class="hljs-keyword">this</span>.ctx = ctx;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(!ctx.channel().isOpen()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        run(ctx);    &#125;        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>;&#125;</code></pre></div><p>说明：当通道关闭了，就不执行任务了。反之，执行子类的 <code>run</code> 方法</p><p>7.读事件的 <code>run</code> 方法（即 <code>ReaderIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>1)代码及其说明</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;    <span class="hljs-keyword">long</span> nextDelay = readerIdleTimeNanos;    <span class="hljs-keyword">if</span>(!reading) &#123;        nextDelay -= ticksInNanos() - lastReadTime;    &#125;        <span class="hljs-keyword">if</span>(nextDelay &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//Reader is idle-set a new timeout and notify the callback.</span>        <span class="hljs-comment">//用于取消任务 promise</span>        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);        <span class="hljs-keyword">boolean</span> first = firstReaderIdleEvent;        firstReaderIdleEvent = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//再次提交任务</span>            IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.READER_IDLE, first);            <span class="hljs-comment">//触发用户 handler use</span>            channelIdle(ctx, event);        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            ctx.fireExceptionCaught(t);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//Read occurred before the timeout - set a new timeout with shorter delay.</span>        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre></div><p>说明：</p><p>1)得到用户设置的超时时间。</p><p>2)如果读取操作结束了（执行了 <code>channelReadComplete</code> 方法设置），就用当前时间减去给定时间和最后一次读（执操作的时间行了 <code>channelReadComplete</code> 方法设置），如果小于 <code>0</code>，就触发事件。反之，继续放入队列。间隔时间是新的计算时间。</p><p>3)触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个 <code>promise</code> 对象，用于做取消操作。然后，设置 <code>first</code> 属性为<code>false</code>，表示，下一次读取不再是第一次了，这个属性在 <code>channelRead</code> 方法会被改成 <code>true</code>。</p><p>4)创建一个 <code>IdleStateEvent</code> 类型的写事件对象，将此对象传递给用户的 <code>UserEventTriggered</code> 方法。完成触发事件的操作。</p><p>5)总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发 <code>UserEventTriggered</code> 方法。//前面介绍 <code>IdleStateHandler</code> 说过,可以看一下</p><p>8.写事件的 <code>run</code> 方法（即 <code>WriterIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>1)<code>run</code> 代码和分析</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;    <span class="hljs-keyword">long</span> lastWriteTime = IdleStateHandler.<span class="hljs-keyword">this</span>.lastWriteTime;    <span class="hljs-keyword">long</span> nextDelay = writerIdleTimeNanos - (ticksInNanos()-lastWriteTime);    <span class="hljs-keyword">if</span> (nextDelay &lt;=<span class="hljs-number">0</span> ) &#123;        <span class="hljs-comment">//Writer is idle - set a new timeout and notify the callback.</span>        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, writerIdleTimeNanos, TimeUnit.NANOSECONDS);        <span class="hljs-keyword">boolean</span> first = firstWriterIdleEvent;        firstWriterIdleEvent = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(hasOutputChanged(ctx, first)) &#123;                <span class="hljs-keyword">return</span>;            &#125;                        IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.WRITER_IDLE, first);            channelIdle(ctx, event);        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            ctx.fireExceptionCaught(t);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//Write occurred before the timeout - set a new timeout with shorter delay.</span>        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre></div><p>说明：写任务的 <code>run</code> 代码逻辑基本和读任务的逻辑一样，唯一不同的就是有一个针对出站较慢数据的判断 <code>hasOutputChanged</code></p><p>9.所有事件的 <code>run</code> 方法（即 <code>AllIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>代码分析</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;    <span class="hljs-keyword">long</span> nextDelay = allIdleTimeNanos;    <span class="hljs-keyword">if</span>(!reading) &#123;        nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);    &#125;        <span class="hljs-keyword">if</span>(nextDelay &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//Both reader and writer are idle - set a new timeout and</span>        <span class="hljs-comment">//notify the callback.</span>        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, allIdleTimeNanos, TimeUnit.NANOSECONDS);        <span class="hljs-keyword">boolean</span> first = firstAllIdleEvent;        firstAllIdleEvent = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(hasOutputChanged(ctx, first)) &#123;                <span class="hljs-keyword">return</span>;            &#125;                        IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.ALL_IDLE, first);            channelIdle(ctx, event);        &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;            ctx.fireExceptionCaught(t);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//Either read or write occurred before the timeout - set a new</span>        <span class="hljs-comment">//timeout with shorter delay.</span>        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre></div><p>说明：</p><p>1)表示这个监控着所有的事件。当读写事件发生时，都会记录。代码逻辑和写事件的的基本一致：</p><p>2)需要大家注意的地方是</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">long</span> nextDelay = allIdleTimeNanos;<span class="hljs-keyword">if</span>(!reading) &#123;    <span class="hljs-comment">//当前时间减去最后一次写或读的时间，若大于 0，说明超时了</span>    nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);&#125;</code></pre></div><p>3)这里的时间计算是取读写事件中的最大值来的。然后像写事件一样，判断是否发生了写的慢的情况。</p><p>10.小结 <code>Netty</code> 的心跳机制</p><p>1)<code>IdleStateHandler</code> 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 <code>handler</code> 的 <code>userEventTriggered</code> 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接。</p><p>2)<code>IdleStateHandler</code> 的实现基于 <code>EventLoop</code> 的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。</p><p>3)内部有 <code>3</code> 个定时任务，分别对应读事件，写事件，读写事件。通常用户监听读写事件就足够了。</p><p>4)同时，<code>IdleStateHandler</code> 内部也考虑了一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间。<code>Netty</code> 通过构造方法中的 <code>observeOutput</code> 属性来决定是否对出站缓冲区的情况进行判断。</p><p>5)如果出站缓慢，<code>Netty</code> 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，可能造成 <code>OOM</code>，<code>OOM</code> 比空闲的问题更大。</p><p>6)所以，当你的应用出现了内存溢出，<code>OOM</code> 之类，并且写空闲极少发生（使用了 <code>observeOutput</code> 为 <code>true</code>），那么就需要注意是不是数据出站速度过慢。</p><p>7)还有一个注意的地方：就是 <code>ReadTimeoutHandler</code>，它继承自 <code>IdleStateHandler</code>，当触发读空闲事件的时候，就触发 <code>ctx</code>. <code>fireExceptionCaught</code> 方法，并传入一个 <code>ReadTimeoutException</code>，然后关闭 <code>Socket</code>。</p><p>8)而 <code>WriteTimeoutHandler</code> 的实现不是基于 <code>IdleStateHandler</code> 的，他的原理是，当调用 <code>write</code> 方法的时候，会创建一个定时任务，任务内容是根据传入的 <code>promise</code> 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 <code>promise</code> 的 <code>isDone</code> 方法返回 <code>false</code>，表明还没有写完，说明超时了，则抛出异常。当 <code>write</code> 方法完成后，会打断定时任务。</p><h3 id="10-7-Netty-核心组件-EventLoop-源码剖析"><a href="#10-7-Netty-核心组件-EventLoop-源码剖析" class="headerlink" title="10.7 Netty 核心组件 EventLoop 源码剖析]"></a>10.7 Netty 核心组件 EventLoop 源码剖析]</h3><h4 id="10-7-1-源码剖析目的"><a href="#10-7-1-源码剖析目的" class="headerlink" title="10.7.1 源码剖析目的"></a>10.7.1 源码剖析目的</h4><p><code>Echo</code> 第一行代码就是：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1)</code>; 下面分析其最核心的组件 <code>EventLoop</code>。</p><h4 id="10-7-2-源码剖析"><a href="#10-7-2-源码剖析" class="headerlink" title="10.7.2 源码剖析"></a>10.7.2 源码剖析</h4><p>源码剖析</p><p>1.<code>EventLoop</code>介绍 1.1首先看看 <code>NioEventLoop</code> 的继承图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_17.png" alt="img"></p><p>说明重点： 1)<code>ScheduledExecutorService</code> 接口表示是一个定时任务接口，<code>EventLoop</code> 可以接受定时任务。</p><p>2)<code>EventLoop</code> 接口：<code>Netty</code> 接口文档说明该接口作用：一旦 <code>Channel</code> 注册了，就处理该 <code>Channel</code> 对应的所有 <code>I/O</code> 操作。</p><p>3)<code>SingleThreadEventExecutor</code> 表示这是一个单个线程的线程池</p><p>4)<code>EventLoop</code> 是一个单例的线程池，里面含有一个死循环的线程不断的做着 <code>3</code> 件事情：监听端口，处理端口事件，处理队列事件。每个 <code>EventLoop</code> 都可以绑定多个 <code>Channel</code>，而每个 <code>Channel</code> 始终只能由一个 <code>EventLoop</code> 来处理</p><ol><li><code>NioEventLoop</code> 的使用 - <code>execute</code> 方法</li></ol><p>2.1 <code>execute</code> 源码剖析</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_18.png" alt="img"></p><p>在 <code>EventLoop</code> 的使用，一般就是 <code>eventloop.execute(task);</code> 看下 <code>execute</code> 方法的实现(在 <code>SingleThreadEventExecutor</code> 类中)</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;    <span class="hljs-keyword">if</span>(task == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);    &#125;    <span class="hljs-keyword">boolean</span> inEventLoop = inEventLoop();    <span class="hljs-keyword">if</span>(inEventLoop) &#123;        addTask(task);    &#125; <span class="hljs-keyword">else</span> &#123;        startThread();        addTask(task);        <span class="hljs-keyword">if</span>(isShutdown() &amp;&amp; removeTask(task)) &#123;            reject();        &#125;    &#125;        <span class="hljs-keyword">if</span>(!addTaskWakesUp&amp;&amp;wakesUpForTask(task)) &#123;        wakeup(inEventLoop);    &#125;&#125;</code></pre></div><p>说明: 1)首先判断该 <code>EventLoop</code> 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。</p><p>2)如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。</p><p>3)如果 <code>addTaskWakesUp</code> 是 <code>false</code>，并且任务不是 <code>NonWakeupRunnable</code> 类型的，就尝试唤醒 <code>selector</code>。这个时候，阻塞在 <code>selecor</code>的线程就会立即返回</p><p>4)可以下断点来追踪</p><p>2.2我们 <code>debugaddTask</code> 和 <code>offerTask</code> 方法源码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(Runnable task)</span> </span>&#123;    <span class="hljs-keyword">if</span>(task == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);    &#125;        <span class="hljs-keyword">if</span>(!offerTask(task)) &#123;        reject(task);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerTask</span><span class="hljs-params">(Runnable task)</span> </span>&#123;    <span class="hljs-keyword">if</span>(isShutdown()) &#123;        reject();    &#125;    <span class="hljs-keyword">return</span> taskQueue.offer(task);&#125;</code></pre></div><p>3.<code>NioEventLoop</code> 的父类 <code>SingleThreadEventExecutor</code> 的 <code>startThread</code> 方法 3.1当执行 <code>execute</code> 方法的时候，如果当前线程不是 <code>EventLoop</code> 所属线程，则尝试启动线程，也就是 <code>startThread</code> 方法，dubug 代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startThread</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span>(state == ST_NOT_STARTED) &#123;        <span class="hljs-keyword">if</span>(STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;            <span class="hljs-keyword">try</span>&#123;                doStartThread();            &#125; <span class="hljs-keyword">catch</span>(Throwable cause) &#123;                STATE_UPDATER.set(<span class="hljs-keyword">this</span>, ST_NOT_STARTED);                PlatformDependent.throwException(cause);            &#125;        &#125;    &#125;&#125;</code></pre></div><p>说明:该方法首先判断是否启动过了，保证 <code>EventLoop</code> 只有一个线程，如果没有启动过，则尝试使用 <code>Cas</code> 将 <code>state</code> 状态改为 <code>ST_STARTED</code>，也就是已启动。然后调用 <code>doStartThread</code> 方法。如果失败，则进行回滚</p><p>看下 <code>doStartThread</code> 方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStartThread</span><span class="hljs-params">()</span> </span>&#123;    executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;            updateLastExecutionTime();            <span class="hljs-keyword">try</span>&#123;                SingleThreadEventExecutor.<span class="hljs-keyword">this</span>.run();                success=<span class="hljs-keyword">true</span>;            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">for</span>( ; ; ) &#123;                    intoldState = state;                    <span class="hljs-keyword">if</span>(oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.<span class="hljs-keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">for</span>( ; ; ) &#123;                        <span class="hljs-keyword">if</span>(confirmShutdown()) &#123;                            <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-keyword">try</span> &#123;                        cleanup();                    &#125; <span class="hljs-keyword">finally</span> &#123;                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class="hljs-keyword">this</span>,ST_TERMINATED);                        threadLock.release();                        terminationFuture.setSuccess(<span class="hljs-keyword">null</span>);                    &#125;                &#125;            &#125;        &#125;    &#125;);&#125;</code></pre></div><p>说明： 1)首先调用 <code>executor</code> 的 <code>execute</code> 方法，这个 <code>executor</code> 就是在创建 <code>EventLoopGroup</code> 的时候创建的 <code>ThreadPerTaskExecutor</code> 类。该 <code>execute</code> 方法会将 <code>Runnable</code> 包装成 <code>Netty</code> 的 <code>FastThreadLocalThread</code>。</p><p>2)任务中，首先判断线程中断状态，然后设置最后一次的执行时间。</p><p>3)执行当前 <code>NioEventLoop</code> 的 <code>run</code> 方法，注意：这个方法是个死循环，是整个 <code>EventLoop</code> 的核心</p><p>4)在 <code>finally</code> 块中，使用 <code>CAS</code> 不断修改 <code>state</code> 状态，改成 <code>ST_SHUTTING_DOWN</code>。也就是当线程 <code>Loop</code> 结束的时候。关闭线程。最后还要死循环确认是否关闭，否则不会 <code>break</code>。然后，执行 <code>cleanup</code> 操作，更新状态为</p><p>5)<code>ST_TERMINATED</code>，并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。并回调 <code>terminationFuture</code> 方法。</p><p>6)其实最核心的就是 <code>EventLoop</code> 自身的 <code>run</code> 方法。再继续深入 <code>run</code> 方法</p><p>4.<code>EventLoop</code> 中的 <code>Loop</code> 是靠 <code>run</code> 实现的，我们分析下 <code>run</code> 方法(该方法在 <code>NioEventLoop</code>)</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>( ; ; ) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">switch</span>(selectStrategy.calculateStrategy(selectNowSupplier,hasTasks())) &#123;                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:                    <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:                    select(wakenUp.getAndSet(<span class="hljs-keyword">false</span>));                    <span class="hljs-keyword">if</span>(wakenUp.get()) &#123;                        selector.wakeup();                    &#125;                    <span class="hljs-keyword">default</span>:            &#125;                        cancelledKeys = <span class="hljs-number">0</span>;            needsToSelectAgain = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;            <span class="hljs-keyword">if</span>(ioRatio == <span class="hljs-number">100</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    processSelectedKeys();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">//Ensure we always run tasks.</span>                    runAllTasks();                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();                <span class="hljs-keyword">try</span> &#123;                    processSelectedKeys();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">//Ensure we always runtasks.</span>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;            handleLoopException(t);        &#125;        <span class="hljs-comment">//Always handle shutdown even if the loop processing threw an exception.</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(isShuttingDown()) &#123;                closeAll();                <span class="hljs-keyword">if</span>(confirmShutdown()) &#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            handleLoopException(t);        &#125;    &#125;&#125;</code></pre></div><p>说明: 1)从上面的步骤可以看出，整个 <code>run</code> 方法做了 <code>3</code> 件事情： <code>select</code> 获取感兴趣的事件。 <code>processSelectedKeys</code> 处理事件。 <code>runAllTasks</code> 执行队列中的任务。</p><p>2)上面的三个方法，我们就追一下 <code>select</code> 方法(体现非阻塞)核心 <code>select</code> 方法解析</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> oldWakenUp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    Selector selector = <span class="hljs-keyword">this</span>.selector;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">long</span> currentTimeNanos = System.nanoTime();        <span class="hljs-keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);        <span class="hljs-keyword">for</span>( ; ; ) &#123;            <span class="hljs-keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="hljs-number">500000L</span>)/<span class="hljs-number">1000000L</span>;            <span class="hljs-keyword">if</span>(timeoutMillis &lt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span>(selectCnt == <span class="hljs-number">0</span>) &#123;                    selector.selectNow();                    selectCnt=<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//If a task was submitted when wakenUp value was true, the task didn&#x27;t get a chance to call</span>            <span class="hljs-comment">//Selector#wakeup. So we need to check task queue again before executing select operation.</span>            <span class="hljs-comment">//If wedon&#x27;t, the task might be pended until select operation was timedout.</span>            <span class="hljs-comment">//It might be pended until idle timeout if IdleStateHandler existed inpipeline.</span>            <span class="hljs-keyword">if</span>(hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;                selector.selectNow();                selectCnt = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;                        <span class="hljs-keyword">int</span> selectedKeys = selector.select(timeoutMillis);<span class="hljs-comment">//否则阻塞给定时间，默认一秒</span>            selectCnt++;            <span class="hljs-comment">//如果 1 秒后返回，有返回值||select被用户唤醒||任务队列有任务||有定时任务即将被执行；则跳出循环</span>            <span class="hljs-keyword">if</span>(selectedKeys != <span class="hljs-number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;                <span class="hljs-comment">//-Selected something,</span>                <span class="hljs-comment">//-waken up by user,or</span>                <span class="hljs-comment">//-the task queue has apending task.</span>                <span class="hljs-comment">//-a scheduled task is ready for processing</span>                <span class="hljs-keyword">break</span>;            &#125;                        <span class="hljs-keyword">if</span>(Thread.interrupted()) &#123;                <span class="hljs-comment">//Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span>                <span class="hljs-comment">//As this is most likely a bug in the handler of the user or it&#x27;s client library we will</span>                <span class="hljs-comment">//also log it.</span>                <span class="hljs-comment">//</span>                <span class="hljs-comment">//See https://github.com/netty/netty/issues/2426</span>                <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;                    logger.debug(<span class="hljs-string">&quot;Selector.select() returned prematurely because &quot;</span> + <span class="hljs-string">&quot; Thread.currentThread().interrupt() was called. Use &quot;</span> + <span class="hljs-string">&quot; NioEventLoop.shutdownGracefully() to shutdowntheNioEventLoop.&quot;</span>);                &#125;                selectCnt = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">long</span> time = System.nanoTime();            <span class="hljs-keyword">if</span>(time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;                <span class="hljs-comment">//timeoutMillis elapsed without any thing selected.</span>                selectCnt =<span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;                <span class="hljs-comment">//The selector returned prematurely many times in a row.</span>                <span class="hljs-comment">//Rebuild the selector to work around the problem.</span>                logger.warn(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>, selectCnt, selector);                rebuildSelector();                selector = <span class="hljs-keyword">this</span>.selector;                <span class="hljs-comment">//Select again to populate selectedKeys.</span>                selector.selectNow();                selectCnt = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;                        currentTimeNanos = time;        &#125;                <span class="hljs-keyword">if</span>(selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;            <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;                logger.debug(<span class="hljs-string">&quot;Selector.select()returned prematurely &#123;&#125; times in a row for Selector&#123;&#125;.&quot;</span>, selectCnt - <span class="hljs-number">1</span>, selector);            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;        <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;            logger.debug(CancelledKeyException.class.getSimpleName() + <span class="hljs-string">&quot;raisedbyaSelector &#123;&#125; - JDKbug?&quot;</span>, selector, e);        &#125;        <span class="hljs-comment">//Harmless exception - log anyway</span>    &#125;&#125;</code></pre></div><p>说明：调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selector</code>，防止 <code>selector</code> 阻塞时间过长</p><p>5.<code>EventLoop</code> 作为 <code>Netty</code> 的核心的运行机制小结</p><p>1)每次执行 <code>execute</code> 方法都是向队列中添加任务。当第一次添加时就启动线程，执行 <code>run</code> 方法，而 <code>run</code> 方法是整个 <code>EventLoop</code> 的核心，就像 <code>EventLoop</code> 的名字一样，<code>LoopLoop</code>，不停的 <code>Loop</code>，<code>Loop</code> 做什么呢？做 <code>3</code> 件事情。</p><p>调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selecor</code>，防止 <code>selector</code> 阻塞时间过长。</p><p>当 <code>selector</code> 返回的时候，回调用 <code>processSelectedKeys</code> 方法对 <code>selectKey</code> 进行处理。</p><p>当 <code>processSelectedKeys</code> 方法执行结束后，则按照 <code>ioRatio</code> 的比例执行 <code>runAllTasks</code> 方法，默认是 <code>IO</code> 任务时间和非 <code>IO</code> 任务时间是相同的，你也可以根据你的应用特点进行调优。比如非 <code>IO</code> 任务比较多，那么你就将</p><p><code>ioRatio</code> 调小一点，这样非 <code>IO</code> 任务就能执行的长一点。防止队列积攒过多的任务。</p><h3 id="10-8-handler-中加入线程池和-Context-中添加线程池的源码剖析"><a href="#10-8-handler-中加入线程池和-Context-中添加线程池的源码剖析" class="headerlink" title="10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析"></a>10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析</h3><h4 id="10-8-1-源码剖析目的"><a href="#10-8-1-源码剖析目的" class="headerlink" title="10.8.1 源码剖析目的"></a>10.8.1 源码剖析目的</h4><ol><li>在 <code>Netty</code> 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 <code>Netty</code> 对 <code>Socket</code> 的处理速度。</li><li>而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有 <code>2</code> 种方式，而且这 <code>2</code> 种方式实现的区别也蛮大的。</li><li>处理耗时业务的第一种方式 – <code>handler</code> 中加入线程池</li><li>处理耗时业务的第二种方式 – <code>Context</code> 中添加线程池</li><li>我们就来分析下两种方式</li></ol><h4 id="10-8-2-源码剖析"><a href="#10-8-2-源码剖析" class="headerlink" title="10.8.2 源码剖析"></a>10.8.2 源码剖析</h4><p>说明 演示两种方式的实现，以及从源码来追踪两种方式执行流程</p><ol><li>处理耗时业务的第一种方式 – handler种加入线程池</li><li>1对前面的 <code>Netty</code> <code>demo</code>源码进行修改，在 <code>EchoServerHandler</code> 的 <code>channelRead</code> 方法进行异步</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventExecutorGroup group = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<span class="hljs-number">16</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException, InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> Object msgCop = msg;        <span class="hljs-keyword">final</span> ChannelHandlerContext cxtCop = ctx;        group.submit(<span class="hljs-keyword">new</span> Callable&lt;Object&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                ByteBuf buf = (ByteBuf)msgCop;                <span class="hljs-keyword">byte</span>[] req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buf.readableBytes()];                buf.readBytes(req);                String body = <span class="hljs-keyword">new</span> String(req, <span class="hljs-string">&quot;UTF-8&quot;</span>);                Thread.sleep(<span class="hljs-number">10</span> * <span class="hljs-number">1000</span>);                System.err.println(body + <span class="hljs-string">&quot; &quot;</span> + Thread.currentThread().getName());                String reqString = <span class="hljs-string">&quot;Helloiamserver~~~&quot;</span>;                ByteBuf resp = Unpooled.copiedBuffer(reqString.getBytes());                cxtCop.writeAndFlush(resp);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125;);        System.out.println(<span class="hljs-string">&quot;goon..&quot;</span>);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;        ctx.flush();    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;        <span class="hljs-comment">// Close the connection when an exception is raised.</span>        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><p>说明： 1)在 <code>channelRead</code> 方法，模拟了一个耗时 <code>10</code> 秒的操作，这里，我们将这个任务提交到了一个自定义的业务线程池中，这样，就不会阻塞 <code>Netty</code> 的 <code>IO</code> 线程。</p><p>11.2这样处理之后，整个程序的逻辑如图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_19.png" alt="img"></p><p>说明：</p><p>1)解释一下上图，当 <code>IO</code> 线程轮询到一个 <code>socket</code> 事件，然后，<code>IO</code> 线程开始处理，当走到耗时 <code>handler</code> 的时候，将耗时任务交给业务线程池。</p><p>2)当耗时任务执行完毕再执行 <code>pipeline write</code> 方法的时候，(代码中使用的是 <code>context</code> 的 <code>write</code> 方法，上图画的是执行 <code>pipeline</code> 方法，是一个意思)会将任务这个任务交给 <code>IO</code> 线程</p><p>11.3 <code>write</code> 方法的源码(在 <code>AbstractChannelHandlerContext</code> 类)</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Object msg, <span class="hljs-keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;    AbstractChannelHandlerContext next = findContextOutbound();    <span class="hljs-keyword">final</span> Object m = pipeline.touch(msg, next);    EventExecutor executor = next.executor();    <span class="hljs-keyword">if</span>(executor.inEventLoop()) &#123;        <span class="hljs-keyword">if</span>(flush) &#123;            next.invokeWriteAndFlush(m, promise);        &#125; <span class="hljs-keyword">else</span> &#123;            next.invokeWrite(m, promise);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        AbstractWriteTask task;        <span class="hljs-keyword">if</span>(flush) &#123;            task = WriteAndFlushTask.newInstance(next, m, promise);        &#125; <span class="hljs-keyword">else</span> &#123;            task = WriteTask.newInstance(next, m, promise);        &#125;        safeExecute(executor, task, promise, m);    &#125;&#125;</code></pre></div><p>说明:</p><p>1)当判定下个 <code>outbound</code> 的 <code>executor</code> 线程不是当前线程的时候，会将当前的工作封装成 <code>task</code>，然后放入 <code>mpsc</code> 队列中，等待 <code>IO</code> 任务执行完毕后执行队列中的任务。</p><p>2)这里可以 Debug 来验证(提醒：Debug 时，服务器端 Debug, 客户端 <code>Run</code> 的方式)，当我们使用了 <code>group.submit(new Callable&lt;Object&gt; ()&#123;&#125;</code> 在 <code>handler</code> 中加入线程池，就会进入到 <code>safeExecute(executor, task, promise, m);</code> 如果去掉这段代码，而使用普通方式来执行耗时的业务，那么就不会进入到 <code>safeExecute(executor, task, promise, m);</code>（说明：普通方式执行耗时代码，看我准备好的案例即可）</p><p>12.处理耗时业务的第二种方式 -<code>Context</code> 中添加线程池 1.1在添加 <code>pipeline</code> 中的 <code>handler</code> 时候，添加一个线程池</p><p>//属性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventExecutorGroup group = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<span class="hljs-number">16</span>);ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();                b.group(bossGroup, workerGroup)                 .channel(NioServerSocketChannel.class)                 .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)                 .handler(newLoggingHandler(LogLevel.INFO))                 .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                     <span class="hljs-meta">@Override</span>                     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                         ChannelPipeline p = ch.pipeline();                         <span class="hljs-keyword">if</span>(sslCtx != <span class="hljs-keyword">null</span>) &#123;                             p.addLast(sslCtx.newHandler(ch.alloc()));                         &#125;                         <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>                         <span class="hljs-comment">//p.addLast(new EchoServerHandler());</span>                         p.addLast(group, <span class="hljs-keyword">new</span> EchoServerHandler());                    &#125;                &#125;);</code></pre></div><p>说明：</p><p>1)<code>handler</code> 中的代码就使用普通的方式来处理耗时业务。</p><p>2)当我们在调用 <code>addLast</code> 方法添加线程池后，<code>handler</code> 将优先使用这个线程池，如果不添加，将使用 <code>IO</code> 线程</p><p>3)当走到 <code>AbstractChannelHandlerContext</code> 的 <code>invokeChannelRead</code> 方法的时候，<code>executor.inEventLoop()</code> 是不会通过的，因为当前线程是 <code>IO</code> 线程 <code>Context</code>（也就是 <code>Handler</code>）的 <code>executor</code> 是业务线程，所以会异步执行，debug 下源码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;    <span class="hljs-keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);    EventExecutor executor = next.executor();    <span class="hljs-keyword">if</span>(executor.inEventLoop()) &#123;        next.invokeChannelRead(m);    &#125; <span class="hljs-keyword">else</span> &#123;        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-comment">//执行run</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                next.invokeChannelRead(m);            &#125;        &#125;);    &#125;&#125;</code></pre></div><p>4)验证时，我们如果去掉 <code>p.addLast(group,newEchoServerHandler());</code> 改成 <code>p.addLastnewEchoServerHandler());</code> 你会发现代码不会进行异步执行。</p><p>5)后面的整个流程就变成和第一个方式一样了</p><p>13.两种方式的比较</p><p>1)第一种方式在 <code>handler</code> 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 <code>mpscTask</code> 中。如果 <code>IO</code> 时间很短，<code>task</code> 很多，可能一个循环下来，都没时间执行整个 <code>task</code>，导致响应时间达不到指标。</p><p>2)第二种方式是 <code>Netty</code> 标准方式(即加入到队列)，但是，这么做会将整个 <code>handler</code> 都交给业务线程池。不论耗时不耗时，都加入到队列里，不够灵活。</p><p>3)各有优劣，从灵活性考虑，第一种较好。</p><h2 id="11-用-Netty-自己实现-Dubbo-RPC"><a href="#11-用-Netty-自己实现-Dubbo-RPC" class="headerlink" title="11 用 Netty 自己实现 Dubbo RPC"></a>11 用 Netty 自己实现 Dubbo RPC</h2><h3 id="11-1-RPC-基本介绍"><a href="#11-1-RPC-基本介绍" class="headerlink" title="11.1 RPC 基本介绍"></a>11.1 RPC 基本介绍</h3><ol><li><code>RPC（Remote Procedure Call）</code>—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li><li>两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图)</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_01.png" alt="img"></p><ol><li>常见的 <code>RPC</code> 框架有：比较知名的如阿里的 <code>Dubbo</code>、<code>Google</code> 的 <code>gRPC</code>、<code>Go</code> 语言的 <code>rpcx</code>、<code>Apache</code> 的 <code>thrift</code>，<code>Spring</code> 旗下的 <code>SpringCloud</code>。</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_02.png" alt="img"></p><h3 id="11-2-RPC-调用流程图"><a href="#11-2-RPC-调用流程图" class="headerlink" title="11.2 RPC 调用流程图"></a>11.2 RPC 调用流程图<img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_03.png" alt="img"></h3><h3 id="11-3-PRC-调用流程说明"><a href="#11-3-PRC-调用流程说明" class="headerlink" title="11.3 PRC 调用流程说明"></a>11.3 PRC 调用流程说明</h3><ol><li>服务消费方（<code>client</code>）以本地调用方式调用服务</li><li><code>client stub</code> 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体</li><li><code>client stub</code> 将消息进行编码并发送到服务端</li><li><code>server stub</code> 收到消息后进行解码</li><li><code>server stub</code> 根据解码结果调用本地的服务</li><li>本地服务执行并将结果返回给 <code>server stub</code></li><li><code>server stub</code> 将返回导入结果进行编码并发送至消费方</li><li><code>client stub</code> 接收到消息并进行解码</li><li>服务消费方（<code>client</code>）得到结果</li></ol><p>小结：<code>RPC</code> 的目标就是将 <code>2 - 8</code> 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用</p><h3 id="11-4-自己实现-Dubbo-RPC（基于-Netty）"><a href="#11-4-自己实现-Dubbo-RPC（基于-Netty）" class="headerlink" title="11.4 自己实现 Dubbo RPC（基于 Netty）"></a>11.4 自己实现 Dubbo RPC（基于 Netty）</h3><h4 id="11-4-1-需求说明"><a href="#11-4-1-需求说明" class="headerlink" title="11.4.1 需求说明"></a>11.4.1 需求说明</h4><ol><li><code>Dubbo</code> 底层使用了 <code>Netty</code> 作为网络通讯框架，要求用 <code>Netty</code> 实现一个简单的 <code>RPC</code> 框架</li><li>模仿 <code>Dubbo</code>，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 <code>Netty 4.1.20</code></li></ol><h4 id="11-4-2-设计说明"><a href="#11-4-2-设计说明" class="headerlink" title="11.4.2 设计说明"></a>11.4.2 设计说明</h4><ol><li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。</li><li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。</li><li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 <code>Netty</code> 请求提供者返回数据</li><li>开发的分析图</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_04.png" alt="img"></p><h4 id="11-4-3-代码实现"><a href="#11-4-3-代码实现" class="headerlink" title="11.4.3 代码实现"></a>11.4.3 代码实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.publicinterface;<span class="hljs-comment">//这个是接口，是服务提供方和 服务消费方都需要</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">hello</span><span class="hljs-params">(String mes)</span></span>;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.provider;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-comment">//当有消费方调用该方法时， 就返回一个结果</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String mes)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;收到客户端消息=&quot;</span> + mes);        <span class="hljs-comment">//根据mes 返回不同的结果</span>        <span class="hljs-keyword">if</span> (mes != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好客户端, 我已经收到你的消息 [&quot;</span> + mes + <span class="hljs-string">&quot;] 第&quot;</span> + (++count) + <span class="hljs-string">&quot; 次&quot;</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好客户端, 我已经收到你的消息 &quot;</span>;        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.provider;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyServer;<span class="hljs-comment">//ServerBootstrap 会启动一个服务提供者，就是 NettyServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerBootstrap</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//代码代填..</span>        NettyServer.startServer(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>);    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer</span><span class="hljs-params">(String hostName, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        startServer0(hostName, port);    &#125;    <span class="hljs-comment">//编写一个方法，完成对NettyServer的初始化和启动</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer0</span><span class="hljs-params">(String hostname, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                                      <span class="hljs-meta">@Override</span>                                      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                          ChannelPipeline pipeline = ch.pipeline();                                          pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());                                          pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());                                          pipeline.addLast(<span class="hljs-keyword">new</span> NettyServerHandler()); <span class="hljs-comment">//业务处理器</span>                                      &#125;                                  &#125;                    );            ChannelFuture channelFuture = serverBootstrap.bind(hostname, port).sync();            System.out.println(<span class="hljs-string">&quot;服务提供方开始提供服务~~&quot;</span>);            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.customer.ClientBootstrap;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.provider.HelloServiceImpl;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-comment">//服务器这边handler比较简单</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取客户端发送的消息，并调用服务</span>        System.out.println(<span class="hljs-string">&quot;msg=&quot;</span> + msg);        <span class="hljs-comment">//客户端在调用服务器的api 时，我们需要定义一个协议</span>        <span class="hljs-comment">//比如我们要求 每次发消息是都必须以某个字符串开头 &quot;HelloService#hello#你好&quot;</span>        <span class="hljs-keyword">if</span> (msg.toString().startsWith(ClientBootstrap.providerName)) &#123;            String result = <span class="hljs-keyword">new</span> HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(<span class="hljs-string">&quot;#&quot;</span>) + <span class="hljs-number">1</span>));            ctx.writeAndFlush(result);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.close();    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> java.util.concurrent.Callable;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;    <span class="hljs-keyword">private</span> ChannelHandlerContext context;<span class="hljs-comment">//上下文</span>    <span class="hljs-keyword">private</span> String result; <span class="hljs-comment">//返回的结果</span>    <span class="hljs-keyword">private</span> String para; <span class="hljs-comment">//客户端调用方法时，传入的参数</span>        <span class="hljs-comment">//与服务器的连接创建后，就会被调用, 这个方法是第一个被调用(1)</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot; channelActive 被调用  &quot;</span>);        context = ctx; <span class="hljs-comment">//因为我们在其它方法会使用到 ctx</span>    &#125;    <span class="hljs-comment">//收到服务器的数据后，调用方法 (4)</span>    <span class="hljs-comment">//</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot; channelRead 被调用  &quot;</span>);        result = msg.toString();        notify(); <span class="hljs-comment">//唤醒等待的线程</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.close();    &#125;    <span class="hljs-comment">//被代理对象调用, 发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果 (3)-》5</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot; call1 被调用  &quot;</span>);        context.writeAndFlush(para);        <span class="hljs-comment">//进行wait</span>        wait(); <span class="hljs-comment">//等待channelRead 方法获取到服务器的结果后，唤醒</span>        System.out.println(<span class="hljs-string">&quot; call2 被调用  &quot;</span>);        <span class="hljs-keyword">return</span> result; <span class="hljs-comment">//服务方返回的结果</span>    &#125;    <span class="hljs-comment">//(2)</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPara</span><span class="hljs-params">(String para)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; setPara  &quot;</span>);        <span class="hljs-keyword">this</span>.para = para;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<span class="hljs-keyword">import</span> java.util.concurrent.Executor;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;    <span class="hljs-comment">//创建线程池</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> NettyClientHandler client;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-comment">//编写方法使用代理模式，获取一个代理对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; serivceClass, <span class="hljs-keyword">final</span> String providerName)</span> </span>&#123;        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),                <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;serivceClass&#125;, (proxy, method, args) -&gt; &#123;                    System.out.println(<span class="hljs-string">&quot;(proxy, method, args) 进入....&quot;</span> + (++count) + <span class="hljs-string">&quot; 次&quot;</span>);                    <span class="hljs-comment">//&#123;&#125;  部分的代码，客户端每调用一次 hello, 就会进入到该代码</span>                    <span class="hljs-keyword">if</span> (client == <span class="hljs-keyword">null</span>) &#123;                        initClient();                    &#125;                    <span class="hljs-comment">//设置要发给服务器端的信息</span>                    <span class="hljs-comment">//providerName 协议头 args[0] 就是客户端调用api hello(???), 参数</span>                    client.setPara(providerName + args[<span class="hljs-number">0</span>]);                    <span class="hljs-comment">//</span>                    <span class="hljs-keyword">return</span> executor.submit(client).get();                &#125;);    &#125;    <span class="hljs-comment">//初始化客户端</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initClient</span><span class="hljs-params">()</span> </span>&#123;        client = <span class="hljs-keyword">new</span> NettyClientHandler();        <span class="hljs-comment">//创建EventLoopGroup</span>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)                .channel(NioSocketChannel.class)                .option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)                .handler(                        <span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                ChannelPipeline pipeline = ch.pipeline();                                pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());                                pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());                                pipeline.addLast(client);                            &#125;                        &#125;                );        <span class="hljs-keyword">try</span> &#123;            bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>).sync();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.customer;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyClient;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientBootstrap</span> </span>&#123;        <span class="hljs-comment">//这里定义协议头</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String providerName = <span class="hljs-string">&quot;HelloService#hello#&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建一个消费者</span>        NettyClient customer = <span class="hljs-keyword">new</span> NettyClient();        <span class="hljs-comment">//创建代理对象</span>        HelloService service = (HelloService) customer.getBean(HelloService.class, providerName);        <span class="hljs-keyword">for</span> (; ; ) &#123;            Thread.sleep(<span class="hljs-number">2</span> * <span class="hljs-number">1000</span>);            <span class="hljs-comment">//通过代理对象调用服务提供者的方法(服务)</span>            String res = service.hello(<span class="hljs-string">&quot;你好 dubbo~&quot;</span>);            System.out.println(<span class="hljs-string">&quot;调用的结果 res= &quot;</span> + res);        &#125;    &#125;&#125;</code></pre></div>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Java/">Java</category>
      
      <category domain="https://pncalbl.github.io/categories/Java/Network/">Network</category>
      
      
      <category domain="https://pncalbl.github.io/tags/network/">network</category>
      
      <category domain="https://pncalbl.github.io/tags/framework/">framework</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Win10 搭建 PyTorch 环境</title>
      <link>https://pncalbl.github.io/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/</link>
      <guid>https://pncalbl.github.io/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/</guid>
      <pubDate>Wed, 19 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Win10-搭建-PyTorch-环境&quot;&gt;&lt;a href=&quot;#Win10-搭建-PyTorch-环境&quot; class=&quot;headerlink&quot; title=&quot;Win10 搭建 PyTorch 环境&quot;&gt;&lt;/a&gt;Win10 搭建 PyTorch 环境&lt;/h1&gt;&lt;h2 i</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Win10-搭建-PyTorch-环境"><a href="#Win10-搭建-PyTorch-环境" class="headerlink" title="Win10 搭建 PyTorch 环境"></a>Win10 搭建 PyTorch 环境</h1><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0 说明"></a>0 说明</h2><p>为了进行深度学习，需要电脑上安装相应的软件，pytorch 就是其中一种。至于 pytorch 是什么的科普，建议去网上搜索。</p><p>而为了安装好 pytorch，需要安装众多软件，网上一搜一大把流程。但事实上随着技术的更新，很多流程都会变得过时，就像我现在这篇，因此我也特意标注了时间。</p><p>本流程的目的是：在 win 10 上安装 pytorch 且能调用 GPU（你需要英伟达的显卡）。</p><p>本流程涉及的程序有：conda，CUDA，cuDNN，pytorch。注意一定要按流程来，如果跳过了 cuDNN 安装 pytorch，是不会成功调用 GPU 的。</p><h2 id="1-Miniconda3"><a href="#1-Miniconda3" class="headerlink" title="1 Miniconda3"></a>1 Miniconda3</h2><p>清华源镜像已经没有维护 miniconda，所以我们使用北外源。</p><ul><li><p><strong>下载地址</strong></p><p><a href="https://mirrors.bfsu.edu.cn/anaconda/miniconda/">Index of /anaconda/miniconda</a></p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521111325301.png" alt="image-20210521111325301"></p></li><li><p><strong>配置环境变量</strong></p><p>一般来说，安装程序会自动把四个 path 变量，写入系统变量的path变量中，但是会写入第一行，我们可以手动下移位置。</p><ul><li><p>打开 cmd（win+R，输入 cmd 后回车），输入 conda info，如果正确无误的话，会显示 conda 的信息。</p></li><li><p>为了 conda 的下载速度，需要添加国内的北外源，输入：</p><div class="code-wrapper"><pre><code class="hljs shell">conda config --set show_channel_urls yes</code></pre></div><p>创建配置文件 .condarc，该文件位于：C:\Users\你的用户名\ 下。</p><p>用文本编辑器打开它，然后复制以下内容完全覆盖已有内容：</p><div class="code-wrapper"><pre><code class="hljs shell">channels:  - defaultsshow_channel_urls: truedefault_channels:  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/main  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/r  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.bfsu.edu.cn/anaconda/cloud  msys2: https://mirrors.bfsu.edu.cn/anaconda/cloud  bioconda: https://mirrors.bfsu.edu.cn/anaconda/cloud  menpo: https://mirrors.bfsu.edu.cn/anaconda/cloud  pytorch: https://mirrors.bfsu.edu.cn/anaconda/cloud  simpleitk: https://mirrors.bfsu.edu.cn/anaconda/cloud</code></pre></div></li></ul></li><li><p><strong>生成并进入环境</strong></p><ul><li><p>使用命令创建环境：</p><div class="code-wrapper"><pre><code class="hljs shell">conda create --name py37 python=3.7</code></pre></div></li><li><p>即创建了名为 py37 的环境，你可以自定义名字，python 设定用的版本。</p><p>随后进入环境</p><div class="code-wrapper"><pre><code class="hljs shell">conda activate py37</code></pre></div></li><li><p><strong>避坑：操作需要在 cmd 里做，而不是 powershell，不知道原理，但会报错。</strong></p><p>如果在 powershell 里运行的话，会报错：</p><div class="code-wrapper"><pre><code class="hljs powershell">CommandNotFoundError: Your shell has not been properly configured to use <span class="hljs-string">&#x27;conda activate&#x27;</span>.</code></pre></div><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/v2-e641b91a6a360410b575d83c3030daf4_1440w.jpg" alt="img"></p></li></ul></li><li><p><strong>安装 ipython</strong></p><ul><li><p>ipython 的操作比 python 用起来舒服多了，具体介绍搜索网上</p><div class="code-wrapper"><pre><code class="hljs shell">conda install ipython</code></pre></div></li><li><p>之后输入 ipython 进入 python。</p></li></ul></li></ul><h2 id="2-CUDA"><a href="#2-CUDA" class="headerlink" title="2 CUDA"></a>2 CUDA</h2><ul><li><p>下载</p><p>链接：<a href="https://developer.nvidia.com/cuda-10.2-download-archive">https://developer.nvidia.com/cuda-downloads</a></p><p>依次选择：Windows -&gt; x86_64 -&gt; 10 -&gt; exe(local)，点击 Download。下载的为适合PyTorch的 <em>cuda_10.2.89_441.22_win10.exe</em></p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521112724889.png" alt="image-20210521112724889"></p><p><strong>避坑：复制下载链接后用迅雷下载，比直接下载快数倍。</strong></p></li><li><p>安装</p><ul><li><p>注意，不要修改安装路径，因为改了没有用，安装程序还是会安装在 C盘下的 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA</p></li><li><p>必须手动添加环境变量。一般来说，CUDA_PATH，安装程序会自动写入。</p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521113202277.png" alt="image-20210521113202277"></p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521113121745.png" alt="image-20210521113121745"></p></li></ul></li></ul><ul><li><p><strong>测试</strong></p><ul><li><p>如果安装成功，在 cmd 里输入：</p><div class="code-wrapper"><pre><code class="hljs shell">nvcc -V</code></pre></div><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521113321717.png" alt="image-20210521113321717"></p></li></ul></li></ul><h2 id="3-cuDNN"><a href="#3-cuDNN" class="headerlink" title="3 cuDNN"></a>3 cuDNN</h2><ul><li><p><strong>下载</strong></p><p><strong>避坑：建议在翻墙的情况下操作，注册时的验证码是谷歌的。</strong></p><p>你需要注册账号后才能继续。现在可以<strong>微信登录</strong>，方便了不少。</p><p>链接：<a href="/compute/machine-learning/cudnn/secure/8.0.2.39/10.2_20200724/cudnn-10.2-windows10-x64-v8.0.2.39.zip">https://developer.nvidia.com</a></p></li><li><p><strong>安装</strong></p><p>说是安装，其实是复制文件。</p><p>下载后是一个压缩文件夹，解压文件夹，将里面的 3 个文件夹：bin，include，lib 里面的内容分别放入 CUDA 安装位置的对应文件夹。</p><p>CUDA 安装的位置在：</p><p>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0</p><p>不会出现覆盖的警告，因为是新增的文件。</p></li></ul><h2 id="4-PyTorch"><a href="#4-PyTorch" class="headerlink" title="4 PyTorch"></a>4 PyTorch</h2><ul><li><p><strong>1. 下载与安装</strong></p><p><strong>避坑：务必在完成以上步骤后才进行。</strong></p><p>网址：<a href="https://link.zhihu.com/?target=https%3A//pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a>，根据实际情况选择。</p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114119171.png" alt="image-20210521114119171"></p><p>得到下载安装的命令：</p><div class="code-wrapper"><pre><code class="hljs shell">conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch</code></pre></div><p>使用 cmd 进入了我们之前设置的环境 py37 后，输入以上命令，开始安装 pytorch，如下图：</p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/v2-58b3d7c11020aca95ab177253cf5d1b0_1440w.jpg" alt="img"></p><p><strong>避坑：很多教程里说，去掉 -c pytorch 后，可以加速下载。可以加速没错，但下载的东西却不是我们要的 gpu 版本，而是 cpu 版本，这也是很多人照着教程做，最终都无法使用 gpu 的，却百思不得其解。</strong></p></li><li><p><strong>2. 测试</strong></p><ul><li><p>等待安装完成后，输入 ipython 进入 python，输入：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchtorch.cuda.is_available()</code></pre></div><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/v2-6acee085f9449a931afaee3cdd36336a_1440w.jpg" alt="img"></p></li><li><p>显示 True 即表明启用了 pytorch 的 gpu，到此安装结束。</p></li><li><p>如果 torch.cuda.isavailable() 是 False，你可能需要看看前面哪个步骤不对。</p></li></ul></li></ul><h2 id="5-Pycharm"><a href="#5-Pycharm" class="headerlink" title="5 Pycharm"></a>5 Pycharm</h2><ul><li><p>创建一个项目 PyTorchTest</p></li><li><p>打开设置 Ctrl + Alt + s</p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114808829.png" alt="image-20210521114808829"></p></li><li><p>引入 py37 </p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114859777.png" alt="image-20210521114859777"></p></li><li><p>切换环境为 py37</p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114957218.png" alt="image-20210521114957218"></p></li><li><p>重启 Pycharm</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Win/">Win</category>
      
      
      <category domain="https://pncalbl.github.io/tags/PyTorch/">PyTorch</category>
      
      <category domain="https://pncalbl.github.io/tags/Win10/">Win10</category>
      
      <category domain="https://pncalbl.github.io/tags/Deep-learning/">Deep learning</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Liunx 一般配置与命令</title>
      <link>https://pncalbl.github.io/2021/05/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <guid>https://pncalbl.github.io/2021/05/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Sun, 09 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-Liunx-常用命令&quot;&gt;&lt;a href=&quot;#1-Liunx-常用命令&quot; class=&quot;headerlink&quot; title=&quot;1 Liunx 常用命令&quot;&gt;&lt;/a&gt;1 Liunx 常用命令&lt;/h1&gt;&lt;h2 id=&quot;1-命令行&quot;&gt;&lt;a href=&quot;#1-命令行&quot; c</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-Liunx-常用命令"><a href="#1-Liunx-常用命令" class="headerlink" title="1 Liunx 常用命令"></a>1 Liunx 常用命令</h1><h2 id="1-命令行"><a href="#1-命令行" class="headerlink" title="1 命令行"></a>1 命令行</h2><table><thead><tr><th>描述</th><th>命令</th></tr></thead><tbody><tr><td>编辑环境变量</td><td>vim /etc/profile</td></tr><tr><td>生效环境变量</td><td>source /etc/profile</td></tr><tr><td>检查目标服务的端口监听状态</td><td>netstat -ntlp | grep 3306</td></tr><tr><td>启动目标服务</td><td>systemctl start service</td></tr><tr><td>检查目标服务的状态</td><td>systemctl status service</td></tr><tr><td>停止目标服务</td><td>systemctl stop service</td></tr><tr><td>查看安装包</td><td>rpm -qa | grep Git</td></tr><tr><td>添加用户组 docker</td><td>sudo groupadd docker</td></tr><tr><td>将登陆用户加入到 docker 用户组中</td><td>sudo gpasswd -a $USER docker</td></tr><tr><td>更新用户组</td><td>newgrp docker</td></tr><tr><td>关闭防火墙</td><td>systemctl stop firewalld.service</td></tr><tr><td>永久关闭防火墙</td><td>systemctl disable firewalld.service</td></tr><tr><td>设置主机名</td><td>hostnamectl set-hostname pncalbl-pc</td></tr></tbody></table><h2 id="2-Vim"><a href="#2-Vim" class="headerlink" title="2 Vim"></a>2 Vim</h2><table><thead><tr><th>描述</th><th>命令模式</th><th>底线命令模式</th></tr></thead><tbody><tr><td>移到最第一行</td><td>gg</td><td>:0或:1</td></tr><tr><td>移到最后一行</td><td>shift+g</td><td>:$</td></tr><tr><td>搜索字符串</td><td>查看下一个  按下 n<br>转到上一个  按下 N</td><td>:/字符串</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="3-Deepin-终端命令"><a href="#3-Deepin-终端命令" class="headerlink" title="3 Deepin 终端命令"></a>3 Deepin 终端命令</h2><table><thead><tr><th>描述</th><th>命令</th></tr></thead><tbody><tr><td>在终端使用默认文件管理器打开当前路径</td><td>xdg-open .</td></tr><tr><td>在终端使用默认文本编辑器打开当前路径</td><td>deepin-editor</td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="2-设置快捷键"><a href="#2-设置快捷键" class="headerlink" title="2 设置快捷键"></a>2 设置快捷键</h1><ol><li>进入设置 / <code>settings</code></li><li>进入 <code>Keyboard</code></li><li>点击 添加按钮 <code>+</code></li><li>定义名称 <code>Open Terminal</code></li><li>输入命令 <code>/usr/bin/gnome-terminal</code></li></ol><h1 id="3-更换-yum-源"><a href="#3-更换-yum-源" class="headerlink" title="3 更换 yum 源"></a>3 更换 yum 源</h1><h2 id="1-下载wget的rpm包"><a href="#1-下载wget的rpm包" class="headerlink" title="1.下载wget的rpm包"></a>1.下载wget的rpm包</h2><p>首先去<a href="http://mirrors.163.com/centos/7/os/x86_64/Packages/找到wget的rpm包，复制链接，使用curl命令下载">http://mirrors.163.com/centos/7/os/x86_64/Packages/找到wget的rpm包，复制链接，使用curl命令下载</a></p><p><img src="/2021/05/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1089423-20191203231224175-577731216.png" alt="img"></p><p> 使用curl下载（注意相关的包版本可能已经变，请以最新的下载地址为准)）</p><div class="code-wrapper"><pre><code class="hljs shell">curl http://mirrors.163.com/centos/7/os/x86_64/Packages/wget-1.14-18.el7_6.1.x86_64.rpm</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">rpm -ivh wget-1.14-18.el7_6.1.x86_64.rpm</code></pre></div><h2 id="2-安装yum"><a href="#2-安装yum" class="headerlink" title="2.安装yum"></a>2.安装yum</h2><p> 1.删除原有的yum</p><div class="code-wrapper"><pre><code class="hljs shell">rpm -aq|grep yum|xargs rpm -e --nodeps</code></pre></div><p> 2.下载yum,注意自己的LINUX系统版本，是什么版本就进相关版本目录去下载。但小版本的目录就不用进了。如版本是6.5，就只需进6 目录，版本是 7.2，只需进7目录</p><div class="code-wrapper"><pre><code class="hljs shell">1 yum-*.rpm2 yum-metadata-parser-*.rpm3 yum-plugin-fastestmirror-*.rpm4 python-iniparse-*.rpm</code></pre></div><p>3.使用wget下载(注意相关的包版本可能已经变，请以最新的下载地址为准)</p><div class="code-wrapper"><pre><code class="hljs shell">wget https://mirrors.163.com/centos/7/os/x86_64/Packages/yum-3.4.3-168.el7.centos.noarch.rpmwget https://mirrors.163.com/centos/7/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpmwget https://mirrors.163.com/centos/7/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpmwget https://mirrors.163.com/centos/7/os/x86_64/Packages/python-iniparse-0.4-9.el7.noarch.rpm</code></pre></div><p>4.下载后安转yum依赖的包</p><div class="code-wrapper"><pre><code class="hljs shell">rpm -ivh python-iniparse-*.rpmrpm -ivh yum-*.rpm  yum-metadata-parser-*.rpm  yum-plugin-fastestmirror-*.rpm</code></pre></div><h2 id="3-修改yum源"><a href="#3-修改yum源" class="headerlink" title="3.修改yum源"></a>3.修改yum源</h2><p> 1.进入到系统yum源的目录下：</p><div class="code-wrapper"><pre><code class="hljs shell">cd /etc/yum.repos.d</code></pre></div><p> 2.下载yum源</p><div class="code-wrapper"><pre><code class="hljs shell">wget http://mirrors.163.com/.help/CentOS7-Base-163.repo</code></pre></div><p> 3.修改源文件名（注意需要把之前的删掉，或者改为.bak文件）</p><div class="code-wrapper"><pre><code class="hljs shell">mv CentOS7-Base-163.repo CentOS-Base.repo</code></pre></div><p>4.运行makecache 生成缓存 使配置生效</p><div class="code-wrapper"><pre><code class="hljs shell">yum makecache</code></pre></div><p>5.验证yum源</p><div class="code-wrapper"><pre><code class="hljs shell">yum repolist查看是否有163的标识 有则证明配置国内163镜像源成功</code></pre></div><p>7.运行yum clean all（等同于 yum cleanheaders ; yum cleanpackages）;</p><div class="code-wrapper"><pre><code class="hljs shell">yum clean allyum 会把下载的软件包和header存储在cache中，而不自动删除。如果觉得占用磁盘空间，可以使用yum clean指令进行清除，更精确 的用法是yum clean headers清除header，yum clean packages清除下载的rpm包，yum clean all一全部清除。</code></pre></div><p>8.更新YUM文件 全部更新软件包</p><div class="code-wrapper"><pre><code class="hljs shell">yum  update</code></pre></div><p>10.yum常用操作</p><div class="code-wrapper"><pre><code class="hljs shell">yum install XXXyum remove XXXyum listyum list installed</code></pre></div><h1 id="4-美化界面"><a href="#4-美化界面" class="headerlink" title="4 美化界面"></a>4 美化界面</h1><ol><li><p>先安装 gnome-tweak-tool</p><div class="code-wrapper"><pre><code class="hljs shell">yum install gnome-tweak-tool</code></pre></div></li><li><p>主题：<a href="mailto:git@gitzab.com">git@gitzab.com</a>:Anduin/GNOME-OSX-II-Theme.git </p><p>解压 GNOME-OSX-II-Theme-master.zip 到 /home/pncalbl/.themes </p><p>在 tweak 中切换主题 GNOME-OSX-II-Theme</p></li><li><p>图标：<a href="mailto:git@github.com">git@github.com</a>:keeferrourke/la-capitaine-icon-theme.git </p><p>解压 la-capitaine-icon-theme-master.zip 到 /home/pncalbl/.icons</p><p>在 tweak 中切换主题 图标</p></li><li><p>启动器：<a href="mailto:git@github.com">git@github.com</a>:micheleg/dash-to-dock.git</p></li></ol><h1 id="5-生成密钥"><a href="#5-生成密钥" class="headerlink" title="5 生成密钥"></a>5 生成密钥</h1><ol><li>生成秘钥</li></ol><div class="code-wrapper"><pre><code class="hljs shell">//换成你自己的邮箱ssh-keygen -t rsa -C &quot;pncalbl@qq.com&quot;//一直next并记住生成的地址Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa):Created directory &#x27;/root/.ssh&#x27;.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.</code></pre></div><ol><li>进入.ssh 目录提出key</li></ol><div class="code-wrapper"><pre><code class="hljs shell">[root@localhost ~]# cd .ssh[root@localhost .ssh]# lsid_rsa  id_rsa.pub//把显示的内容复制到GitHub的SSHkey配置即可[root@localhost .ssh]# cat id_rsa.pub</code></pre></div><ol><li>测试</li></ol><div class="code-wrapper"><pre><code class="hljs shell">[root@localhost .ssh]# ssh -T git@github.comThe authenticity of host &#x27;github.com (192.30.255.113)&#x27; can&#x27;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yPlease type &#x27;yes&#x27; or &#x27;no&#x27;: yesWarning: Permanently added &#x27;github.com,192.30.255.113&#x27; (RSA) to the list of known hosts.Hi megoc! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</code></pre></div><h1 id="6-重载-VMware-tools"><a href="#6-重载-VMware-tools" class="headerlink" title="6 重载 VMware tools"></a>6 重载 VMware tools</h1><p>以下命令都在 root 权限下进行</p><ol><li>卸载   <code>yum remove open-vm-tools</code></li><li>使用 VM 安装 <code>VMware Tools</code></li><li>从光盘复制出 VMwareTools-10.3.21-14772444.tar.gz</li><li>解压缩 tar -zxvf  VMwareTools-10.3.21-14772444.tar.gz -C ./</li><li>执行  <code>./vmware-install.pl</code></li><li><code>第一步输入: y</code>, 剩下的按回车默认即可</li></ol><h1 id="7-运行-java-程序"><a href="#7-运行-java-程序" class="headerlink" title="7 运行 java 程序"></a>7 运行 java 程序</h1><p>在 <code>Linux</code>系统下运行 <code>java</code>程序</p><p><code>Hello.java</code></p><p>完整目录为 ：<code>/home/username/project/java/com/pnca/c17/Hello.java</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.c17;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);&#125;&#125;</code></pre></div><p>如果带有包名，必须存在对应的目录，并把对应的 <code>.java</code> 文件存放到对应的包中。</p><h2 id="编译-javac"><a href="#编译-javac" class="headerlink" title="编译 javac"></a>编译 javac</h2><div class="code-wrapper"><pre><code class="hljs shell">javac -encoding utf-8 -cp com/pnca/c17/Hello.java</code></pre></div><h2 id="运行-java"><a href="#运行-java" class="headerlink" title="运行 java"></a>运行 java</h2><div class="code-wrapper"><pre><code class="hljs shell">java  -classpath . com.pnca.c17.Hello</code></pre></div><p><code>.</code> 指的是当前目录，即为 /home/username/project/java</p><p>如果有包名，则必须使用类的全限定名即：com.pnca.c17.Hello</p><h1 id="8-Linux-配置-vpn"><a href="#8-Linux-配置-vpn" class="headerlink" title="8 Linux 配置 vpn"></a>8 Linux 配置 vpn</h1><p><a href="https://xugaoxiang.com/2020/10/17/qv2ray/#ubuntu平台使用">Qv2ray基本使用 - 迷途小书童的Note迷途小书童的Note (xugaoxiang.com)</a></p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Linux/">Linux</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Linux/">Linux</category>
      
      <category domain="https://pncalbl.github.io/tags/%E5%91%BD%E4%BB%A4/">命令</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>分析开源项目</title>
      <link>https://pncalbl.github.io/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</link>
      <guid>https://pncalbl.github.io/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</guid>
      <pubDate>Sat, 08 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;分析开源项目-EL-ADMIN&quot;&gt;&lt;a href=&quot;#分析开源项目-EL-ADMIN&quot; class=&quot;headerlink&quot; title=&quot;分析开源项目 (EL-ADMIN)&quot;&gt;&lt;/a&gt;分析开源项目 (EL-ADMIN)&lt;/h1&gt;&lt;h2 id=&quot;1-观察开源项目&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="分析开源项目-EL-ADMIN"><a href="#分析开源项目-EL-ADMIN" class="headerlink" title="分析开源项目 (EL-ADMIN)"></a>分析开源项目 (EL-ADMIN)</h1><h2 id="1-观察开源项目"><a href="#1-观察开源项目" class="headerlink" title="1 观察开源项目"></a>1 观察开源项目</h2><ul><li>后端</li></ul><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210509215359473.png" alt="image-20210509215359473"></p><ul><li>前端</li></ul><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210509215706676.png" alt="image-20210509215706676"></p><h2 id="2-开源项目下载"><a href="#2-开源项目下载" class="headerlink" title="2 开源项目下载"></a>2 开源项目下载</h2><p>下载完毕 ==&gt; 解压 ==&gt; 不要着急运行</p><p><strong>观察</strong></p><ul><li>用了那些技术 (Spring Boot 2.1.0 、 Spring Boot Jpa、 JWT、Spring Security、Redis、Vue、Element-UI)</li><li>是否有数据库 (MySQL)</li><li>你的环境是否匹配 (java， maven，npm，nodejs，redis)</li></ul><p>通过了，然后想办法运行</p><h2 id="3-跑起来是第一步"><a href="#3-跑起来是第一步" class="headerlink" title="3 跑起来是第一步"></a>3 跑起来是第一步</h2><ol><li><p>安装数据库，执行SQL（注意：有没有建库语句）</p></li><li><p>前端需要跑起来(npm 版本最好 6.x.xx)</p></li><li><p>后端项目导入</p></li><li><p>启动后端项目</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210509231414116.png" alt="image-20210509231414116"></p><p>只要发现了 Swagger, 那么跑起来的第一步就是先进入 Swagger-ui 界面! 因为这里面都是接口! </p><p>进而查看配置文件! 默认端口….</p><p>前端就是安装依赖, 启动测试, 看接口是否正常</p></li></ol><h2 id="4-前后端分离项目的固定套路"><a href="#4-前后端分离项目的固定套路" class="headerlink" title="4 前后端分离项目的固定套路"></a>4 前后端分离项目的固定套路</h2><ol><li><p>从前端开始分析。打开控制台，点一个接口，分析一波调用关系！</p></li><li><p>前后端端口调用不一致 8013 - - 8000，怎么操作的</p><ul><li><p>封装了接口请求    ajax    axios    request</p></li><li><p>找到配置</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510005019305.png" alt="image-20210510005019305"></p></li><li><p>前后端 分离项目：找到接口的调用关系</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510005313002.png" alt="image-20210510005313002"></p></li><li><p>SpringBoot提供服务！前端调用接口获取数据！Vue负责渲染页面！</p></li><li><p>前端项目固定套路</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510005527489.png" alt="image-20210510005527489"></p></li><li><p>通过抓取前端的请求，找到后端对应的接口</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510014254626.png" alt="image-20210510014254626"></p></li><li><p>后端分析</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510014559981.png" alt="image-20210510014559981"></p></li><li><p>Controller — Service — Dao/Mapper</p></li><li><p>现在从前到后就可以分析了！但是如何渲染到视图上？看前端</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510014916833.png" alt="image-20210510014916833"></p></li><li><p>Vue 标准套路</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510015129858.png" alt="image-20210510015129858"></p></li></ul></li></ol><h2 id="5-如何找到一个好的开源项目"><a href="#5-如何找到一个好的开源项目" class="headerlink" title="5 如何找到一个好的开源项目"></a>5 如何找到一个好的开源项目</h2><ol><li>按分类</li><li>看收藏</li><li>看具有价值</li></ol>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Win/">Win</category>
      
      
      <category domain="https://pncalbl.github.io/tags/%E5%BC%80%E6%BA%90/">开源</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MybatisPlus 学习</title>
      <link>https://pncalbl.github.io/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 07 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;MybatisPlus-学习&quot;&gt;&lt;a href=&quot;#MybatisPlus-学习&quot; class=&quot;headerlink&quot; title=&quot;MybatisPlus 学习&quot;&gt;&lt;/a&gt;MybatisPlus 学习&lt;/h1&gt;&lt;h2 id=&quot;1-特性&quot;&gt;&lt;a href=&quot;#1</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="MybatisPlus-学习"><a href="#MybatisPlus-学习" class="headerlink" title="MybatisPlus 学习"></a>MybatisPlus 学习</h1><h2 id="1-特性"><a href="#1-特性" class="headerlink" title="1 特性"></a>1 特性</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑。</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2 快速入门"></a>2 快速入门</h2><p>地址: <a href="https://baomidou.com/guide/quick-start.html#初始化工程">快速开始 | MyBatis-Plus (baomidou.com)</a></p><p>使用第三方插件</p><ul><li>导入依赖</li><li>研究依赖如何配置</li><li>代码如何编写</li><li>提高扩展技术能力</li></ul><blockquote><p>  步骤</p></blockquote><ol><li><p>创建数据库 <code>mybatis_plus</code></p></li><li><p>创建user表</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-keyword">user</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>(id <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;主键ID&#x27;</span>,<span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,age <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;年龄&#x27;</span>,email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;邮箱&#x27;</span>,<span class="hljs-keyword">PRIMARY KEY</span> (id));# 插入数据<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (id, <span class="hljs-type">name</span>, age, email) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Jone&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;test1@baomidou.com&#x27;</span>),(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;test2@baomidou.com&#x27;</span>),(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&#x27;test3@baomidou.com&#x27;</span>),(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Sandy&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;test4@baomidou.com&#x27;</span>),(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;Billie&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;test5@baomidou.com&#x27;</span>);</code></pre></div></li><li><p>编写项目, 使用springBoot初始化!</p></li><li><p>导入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>说明: 我们使用mybatis-plus可以节省我们大量的代码, 尽量不要同时导入 mybatis 和 mybatis-plus, 可能会产生版本差异!</p></li><li><p>连接数据库</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis_plus?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=GMT</span></code></pre></div></li><li><p>pojo dao-service-controller</p><ul><li><p>pojo</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<span class="hljs-keyword">private</span> Long id;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> Integer age;<span class="hljs-keyword">private</span> String email;&#125;</code></pre></div></li><li><p>mapper</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 在对应的Mapper上面继承基本的类 BaseMapper</span><span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<span class="hljs-comment">//所有的CRUD操作都已经编写完成</span>&#125;</code></pre></div></li><li><p>启动类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 扫描我们的 mapper 文件夹</span><span class="hljs-meta">@MapperScan(&quot;com.pnca.mapper&quot;)</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusApplication</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SpringApplication.run(MybatisPlusApplication.class, args);   &#125;&#125;</code></pre></div></li><li><p>test</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusApplicationTests</span> </span>&#123;   <span class="hljs-comment">//    继承了 BaseMapper, 所有的方法都来自于父类</span>   <span class="hljs-comment">// 我们也可以编写自己的扩展方法</span>   <span class="hljs-meta">@Resource</span>   <span class="hljs-keyword">private</span> UserMapper userMapper;   <span class="hljs-meta">@Test</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">// 参数是一个 queryWrapper, 条件构造器</span>      List&lt;User&gt; users = userMapper.selectList(<span class="hljs-keyword">null</span>);      users.forEach(System.out::println);   &#125;&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210508023409052-1620412451084.png" alt="image-20210508023409052"></p></li></ul></li></ol><h2 id="3-配置日志"><a href="#3-配置日志" class="headerlink" title="3 配置日志"></a>3 配置日志</h2><p>我们所有的sqld现在都是不可见的，我们希望知道它是怎么执行的，所以我们必须要看日志！</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># 配置日志 (系统自带的，控制台输出)</span><span class="hljs-attr">mybatis-plus:</span>  <span class="hljs-attr">configuration:</span>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span></code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210511230039334.png" alt="image-20210511230039334"></p><p>配置完毕日志之后，后面的学习就需要注意这个自动生成的SQL，你们就会喜欢上MyBatis-Plus !</p><h2 id="4-CRUD"><a href="#4-CRUD" class="headerlink" title="4 CRUD"></a>4 CRUD</h2><h3 id="4-1-插入操作"><a href="#4-1-插入操作" class="headerlink" title="4.1 插入操作"></a>4.1 插入操作</h3><blockquote><p>  Insert 插入</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;User user = <span class="hljs-keyword">new</span> User();user.setName(<span class="hljs-string">&quot;Daniel&quot;</span>);user.setAge(<span class="hljs-number">3</span>);user.setEmail(<span class="hljs-string">&quot;daniel@alibaba.com&quot;</span>);<span class="hljs-keyword">int</span> result = userMapper.insert(user);   <span class="hljs-comment">//帮我们自动生成id</span>System.out.println(result); <span class="hljs-comment">// 受影响的行数</span>System.out.println(user);   <span class="hljs-comment">// 发现: id自动回填</span>&#125;</code></pre></div><blockquote><p>  数据库插入的id默认值为：全局的唯一id</p></blockquote><h3 id="4-2-主键生成策略"><a href="#4-2-主键生成策略" class="headerlink" title="4.2 主键生成策略"></a>4.2 主键生成策略</h3><blockquote><p>  默认 ID_WORKER 全局唯一id</p></blockquote><p>分布式系统唯一id生成：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p><p><strong>雪花算法：</strong></p><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！</p><blockquote><p>  主键自增</p></blockquote><p>我们需要配置主键自增：</p><ol><li><p>实体类字段上 <code>@TableId(type = IdType.AUTO)</code></p></li><li><p>数据库字段上一定是自增的</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210511231840472.png" alt="image-20210511231840472"></p></li><li><p>再次测试即可</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210511232040319.png" alt="image-20210511232040319"></p></li></ol><blockquote><p>  其余的源码解释</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">IdType</span> </span>&#123;    AUTO(<span class="hljs-number">0</span>), <span class="hljs-comment">// 数据库id自增</span>    NONE(<span class="hljs-number">1</span>), <span class="hljs-comment">// 未设置主键</span>    INPUT(<span class="hljs-number">2</span>), <span class="hljs-comment">// 手动输入，自己写id</span>    ID_WORKER(<span class="hljs-number">3</span>), <span class="hljs-comment">// 默认的全局唯一id</span>    UUID(<span class="hljs-number">4</span>), <span class="hljs-comment">// 全局唯一id uuid</span>    ID_WORKER_STR(<span class="hljs-number">5</span>); <span class="hljs-comment">// ID_WORKER 字符串表示法</span>&#125;</code></pre></div><h3 id="4-3-更新操作"><a href="#4-3-更新操作" class="headerlink" title="4.3 更新操作"></a>4.3 更新操作</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试更新</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span></span>&#123;    User user = <span class="hljs-keyword">new</span> User();    <span class="hljs-comment">// 通过条件自动拼接动态sql</span>    user.setId(<span class="hljs-number">6L</span>);    user.setName(<span class="hljs-string">&quot;关注我的微信公众号&quot;</span>);    user.setAge(<span class="hljs-number">18</span>);    <span class="hljs-comment">// 注意： updateById 但是参数是一个 对象</span>    <span class="hljs-keyword">int</span> i = userMapper.updateById(user);    System.out.println(i);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210512000742878.png" alt="image-20210512000742878"></p><p>所有的sql都是自动帮你动态配置的！</p><h3 id="4-4-自动填充"><a href="#4-4-自动填充" class="headerlink" title="4.4 自动填充"></a>4.4 自动填充</h3><p>创建时间、修改时间！这些个操作一般都是自动化完成的，我们不希望手动更新！</p><p><strong>阿里巴巴开发手册：</strong>所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需要自动化！</p><blockquote><p>  方式一：数据库级别（工作中不允许修改数据库）</p></blockquote><ol><li>在表中新增字段 create_time,update_time</li></ol><ol start="2"><li><p>再次测试插入方法，我们需要先把实体类同步</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Date createTime;<span class="hljs-keyword">private</span> Date updateTime;</code></pre></div></li></ol><ol start="3"><li>再次查看更新结果即可</li></ol><blockquote><p>  方式二：代码级别</p></blockquote><ol><li><p>删除数据库中的默认值、更新操作</p></li><li><p>实体类的字段属性上需要增加注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//字段添加填充内容</span><span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><span class="hljs-keyword">private</span> LocalDateTime createTime;<span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><span class="hljs-keyword">private</span> LocalDateTime updateTime;</code></pre></div></li><li><p>编写处理器来处理这个注解即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Log4j2</span><span class="hljs-meta">@Component</span>  <span class="hljs-comment">// 一定不要忘记把处理器加到IOC容器中</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MetaObjectHandler</span> </span>&#123;<span class="hljs-comment">// 插入时的填充策略</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;log.info(<span class="hljs-string">&quot;start insert fill.........&quot;</span>);<span class="hljs-keyword">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;createTime&quot;</span>, LocalDateTime::now, LocalDateTime.class); <span class="hljs-comment">// 起始版本 3.3.3(推荐)</span><span class="hljs-keyword">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime::now, LocalDateTime.class);&#125;<span class="hljs-comment">// 更新时的填充策略</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;log.info(<span class="hljs-string">&quot;start update fill.........&quot;</span>);<span class="hljs-keyword">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime::now, LocalDateTime.class); <span class="hljs-comment">// 起始版本 3.3.3(推荐)</span>&#125;&#125;</code></pre></div></li></ol><h3 id="4-5-乐观锁"><a href="#4-5-乐观锁" class="headerlink" title="4.5 乐观锁"></a>4.5 乐观锁</h3><p>在面试过程中，我们经常会被问到乐观锁，悲观锁。</p><ul><li>乐观锁：顾名思义，它总是认为不会出现问题，无论干什么都不去上锁！如果出现了问题，再次更新值测试！</li></ul><ul><li>悲观锁：顾名思义，它总是认为总是出现问题，无论干什么都上锁！再去操作！</li></ul><p>乐观锁实现方式：</p><ul><li><p>取出记录时，获取当前version</p></li><li><p>更新时，带上这个version</p></li><li><p>执行更新时， set version = newVersion where version = oldVersion</p></li><li><p>如果version不对，就更新失败</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210516214644902.png" alt="image-20210516214644902"></p></li><li><p>测试一下MyBatisPlus的插件：</p><ul><li><p>增加 version 字段</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210516214935863.png" alt="image-20210516214935863"></p></li><li><p>我们给实体类增加相应的字段</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Version</span>    <span class="hljs-comment">// 乐观锁 Version 注解</span><span class="hljs-keyword">private</span> Integer version;</code></pre></div></li><li><p>注册组件, 编写配置类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 扫描我们的 mapper 文件夹</span><span class="hljs-meta">@MapperScan(&quot;com.pnca.mapper&quot;)</span><span class="hljs-meta">@EnableTransactionManagement</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 新版</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title">mybatisPlusInterceptor</span><span class="hljs-params">()</span> </span>&#123;MybatisPlusInterceptor mybatisPlusInterceptor = <span class="hljs-keyword">new</span> MybatisPlusInterceptor();mybatisPlusInterceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> OptimisticLockerInnerInterceptor());<span class="hljs-keyword">return</span> mybatisPlusInterceptor;&#125;&#125;</code></pre></div></li></ul></li></ul><h3 id="4-6-查询操作"><a href="#4-6-查询操作" class="headerlink" title="4.6 查询操作"></a>4.6 查询操作</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试查询</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectById</span><span class="hljs-params">()</span> </span>&#123;    User user = userMapper.selectById(<span class="hljs-number">1L</span>);    System.out.println(<span class="hljs-string">&quot;查询的用户为: &quot;</span> + user);&#125;<span class="hljs-comment">// 批量查询</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectByBatchId</span><span class="hljs-params">()</span> </span>&#123;    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));    users.forEach(System.out::println);&#125;<span class="hljs-comment">// 条件查询, 使用map</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectByMap</span><span class="hljs-params">()</span> </span>&#123;    HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">// 自定义查询</span>    map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>);    map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">28</span>);    List&lt;User&gt; users = userMapper.selectByMap(map);    users.forEach(System.out::println);&#125;</code></pre></div><h3 id="4-7-分页查询"><a href="#4-7-分页查询" class="headerlink" title="4.7 分页查询"></a>4.7 分页查询</h3><p>分页网站频繁使用</p><ol><li>原始使用limit进行分页</li><li>pageHelper第三方插件</li><li>MybatisPlus内置了分页插件</li></ol><blockquote><p>  如何使用？</p></blockquote><ol><li><p>配置拦截器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 分页插件</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title">paginationInterceptor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PaginationInterceptor();&#125;</code></pre></div></li><li><p>直接使用Page对象即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试分页查询</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPage</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 参数一: 当前页</span>    <span class="hljs-comment">// 参数二： 页面大小</span>    <span class="hljs-comment">// 使用了分页插件之后，所有的分页操作变得简单了</span>    Page&lt;User&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);    userMapper.selectPage(page, <span class="hljs-keyword">null</span>);    page.getRecords().forEach(System.out::println);    System.out.println(page.getTotal());&#125;</code></pre></div></li></ol><h3 id="4-8-删除操作"><a href="#4-8-删除操作" class="headerlink" title="4.8 删除操作"></a>4.8 删除操作</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试删除</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testdelete</span><span class="hljs-params">()</span></span>&#123;    userMapper.deleteById(<span class="hljs-number">6L</span>);&#125;<span class="hljs-comment">// 测试批量删除</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testdeleteBatchId</span><span class="hljs-params">()</span></span>&#123;    userMapper.deleteBatchIds(Arrays.asList(<span class="hljs-number">1287326823914405893L</span>,<span class="hljs-number">1287326823914405894L</span>));&#125;<span class="hljs-comment">//通过map删除</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteByMap</span><span class="hljs-params">()</span></span>&#123;    HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;KUANG&quot;</span>);    userMapper.deleteByMap(map);&#125;</code></pre></div><p>我们在工作中会遇到一些问题：逻辑删除！</p><h3 id="4-9-逻辑删除"><a href="#4-9-逻辑删除" class="headerlink" title="4.9 逻辑删除"></a>4.9 逻辑删除</h3><blockquote><p>  物理删除：从数据库中直接移除</p><p>  逻辑删除：在数据库中没有被移除，而是通过一个变量让他生效！deleted=0 –&gt; deleted=1</p></blockquote><p>管理员可以查看被删除的记录！防止数据的丢失！类似于回收站！</p><p><strong>测试：</strong></p><ol><li><p>在数据库表中增加一个deleted字段</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210518235020299.png" alt="image-20210518235020299"></p></li><li><p>实体类中增加属性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@TableLogic</span> <span class="hljs-comment">// 逻辑删除</span><span class="hljs-keyword">private</span> Integer deleted;</code></pre></div></li><li><p>配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 逻辑删除组件</span><span class="hljs-comment">// 高版本不用配置,直接注解即可</span><span class="hljs-function"><span class="hljs-keyword">public</span> ISqlInjector <span class="hljs-title">sqlInjector</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogicSqlInjector();&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">global-config:</span>  <span class="hljs-attr">db-config:</span>    <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span>    <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span></code></pre></div></li><li><p>测试删除</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210519000137360.png" alt="image-20210519000137360"></p></li><li><p>测试查询</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210519000241200.png" alt="image-20210519000241200"></p></li></ol><blockquote><p>  以上所有的CRUD操作及其扩展操作，我们必须精通掌握！会大大提高工作效率！</p></blockquote><h2 id="5-性能分析插件"><a href="#5-性能分析插件" class="headerlink" title="5 性能分析插件"></a>5 性能分析插件</h2><p>我们在平时的开发中，会遇到一些慢sql。解决方案：测试，druid监控…</p><p><strong>作用：性能分析拦截器，用于输出每条SQL语句及其执行时间</strong></p><p>MyBatisPlus也提供性能分析插件，如果超过这个时间就停止运行！</p><ol><li><p>导入插件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// SQL执行效率插件</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> PerformanceInterceptor <span class="hljs-title">performanceInterceptor</span><span class="hljs-params">()</span></span>&#123;    PerformanceInterceptor performanceInterceptor = <span class="hljs-keyword">new</span> PerformanceInterceptor();    performanceInterceptor.setMaxTime(<span class="hljs-number">100</span>); <span class="hljs-comment">//ms 设置sql执行的最大时间，如果超过了则不执行</span>    performanceInterceptor.setFormat(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 是否格式化</span>    <span class="hljs-keyword">return</span> performanceInterceptor;&#125;</code></pre></div><p>记住，要在SpringBoot中配置环境为dev或者test环境！</p></li><li><p>测试使用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试查询</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectById</span><span class="hljs-params">()</span></span>&#123;    User user = userMapper.selectById(<span class="hljs-number">3</span>);    System.out.println(user);&#125;</code></pre></div></li><li><p><strong>注意</strong>：此插件在 3.2.0 版本被移除，推荐使用第三方扩展，执行 SQL 分析打印。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/p6spy/p6spy --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>p6spy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>p6spy<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522160038875.png" alt="image-20210522160038875"></p></li></ol><h2 id="6-条件构造器"><a href="#6-条件构造器" class="headerlink" title="6 条件构造器"></a>6 条件构造器</h2><p>十分重要：wrapper</p><p>我们写一些复杂的sql就可以使用它来代替！</p><ul><li><p>测试1</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 查询 name 不为空的用户, 并且邮箱不为空的用户, 年龄大于等于12</span>QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();wrapper.isNotNull(<span class="hljs-string">&quot;name&quot;</span>).isNotNull(<span class="hljs-string">&quot;email&quot;</span>).ge(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">12</span>);<span class="hljs-comment">// 参数是一个 queryWrapper, 条件构造器</span>List&lt;User&gt; users = userMapper.selectList(wrapper);users.forEach(System.out::println);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522162040245.png" alt="image-20210522162040245"></p></li><li><p>测试2</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testEqName</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// 查询名字为 pncalbl</span>   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();   wrapper.eq(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;pncalbl&quot;</span>);   <span class="hljs-comment">// 参数是一个 queryWrapper, 条件构造器</span>   User user = userMapper.selectOne(wrapper);   System.out.println(user);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522162009883.png" alt="image-20210522162009883"></p></li><li><p>测试3</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCount</span><span class="hljs-params">()</span> </span>&#123;   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();   wrapper.between(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 区间</span>   userMapper.selectCount(wrapper);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522162331965.png" alt="image-20210522162331965"></p></li><li><p>测试4</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testLike</span><span class="hljs-params">()</span> </span>&#123;   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();   <span class="hljs-comment">// 左和右 %e%，例如 t%</span>   wrapper.notLike(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;pncalbl&quot;</span>)         .likeRight(<span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>);   List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);   maps.forEach(System.out::println);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522163022658.png" alt="image-20210522163022658"></p></li><li><p>测试5</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSelectObjects</span><span class="hljs-params">()</span> </span>&#123;   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();   <span class="hljs-comment">// id 在子查询中查出来</span>   wrapper.inSql(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;select id from user where id &lt; 3&quot;</span>);   List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);   objects.forEach(System.out::println);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522163345953.png" alt="image-20210522163345953"></p></li><li><p>测试6</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testOrder</span><span class="hljs-params">()</span> </span>&#123;   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();   <span class="hljs-comment">// 通过 id 进行排序</span>   wrapper.orderByDesc(<span class="hljs-string">&quot;id&quot;</span>);   List&lt;User&gt; users = userMapper.selectList(wrapper);   users.forEach(System.out::println);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522163715836.png" alt="image-20210522163715836"></p></li></ul><h2 id="7-代码生成器"><a href="#7-代码生成器" class="headerlink" title="7 代码生成器"></a>7 代码生成器</h2><p>dao、pojo、service、controller都给我自己去编写完成！</p><p>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p><blockquote><p>  特别说明:</p><p>  自定义模板有哪些可用参数？<a href="https://github.com/baomidou/generator/blob/develop/mybatis-plus-generator/src/main/java/com/baomidou/mybatisplus/generator/engine/AbstractTemplateEngine.java">Github (opens new window)</a>AbstractTemplateEngine 类中方法 getObjectMap 返回 objectMap 的所有值都可用。</p></blockquote><h3 id="演示效果图："><a href="#演示效果图：" class="headerlink" title="演示效果图："></a>演示效果图：</h3><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/generator.gif" alt="relationship"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeGenerator</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * &lt;p&gt;</span><span class="hljs-comment">     * 读取控制台内容</span><span class="hljs-comment">     * &lt;/p&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">scanner</span><span class="hljs-params">(String tip)</span> </span>&#123;        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);        StringBuilder help = <span class="hljs-keyword">new</span> StringBuilder();        help.append(<span class="hljs-string">&quot;请输入&quot;</span> + tip + <span class="hljs-string">&quot;：&quot;</span>);        System.out.println(help.toString());        <span class="hljs-keyword">if</span> (scanner.hasNext()) &#123;            String ipt = scanner.next();            <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;                <span class="hljs-keyword">return</span> ipt;            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MybatisPlusException(<span class="hljs-string">&quot;请输入正确的&quot;</span> + tip + <span class="hljs-string">&quot;！&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 代码生成器</span>        AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();        <span class="hljs-comment">// 全局配置</span>        GlobalConfig gc = <span class="hljs-keyword">new</span> GlobalConfig();        String projectPath = System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>);        gc.setOutputDir(projectPath + <span class="hljs-string">&quot;/src/main/java&quot;</span>);        gc.setAuthor(<span class="hljs-string">&quot;jobob&quot;</span>);        gc.setOpen(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">// gc.setSwagger2(true); 实体属性 Swagger2 注解</span>        mpg.setGlobalConfig(gc);        <span class="hljs-comment">// 数据源配置</span>        DataSourceConfig dsc = <span class="hljs-keyword">new</span> DataSourceConfig();        dsc.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/ant?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);        <span class="hljs-comment">// dsc.setSchemaName(&quot;public&quot;);</span>        dsc.setDriverName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);        dsc.setUsername(<span class="hljs-string">&quot;root&quot;</span>);        dsc.setPassword(<span class="hljs-string">&quot;密码&quot;</span>);        mpg.setDataSource(dsc);        <span class="hljs-comment">// 包配置</span>        PackageConfig pc = <span class="hljs-keyword">new</span> PackageConfig();        pc.setModuleName(scanner(<span class="hljs-string">&quot;模块名&quot;</span>));        pc.setParent(<span class="hljs-string">&quot;com.baomidou.ant&quot;</span>);        mpg.setPackageInfo(pc);        <span class="hljs-comment">// 自定义配置</span>        InjectionConfig cfg = <span class="hljs-keyword">new</span> InjectionConfig() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">// to do nothing</span>            &#125;        &#125;;        <span class="hljs-comment">// 如果模板引擎是 freemarker</span>        String templatePath = <span class="hljs-string">&quot;/templates/mapper.xml.ftl&quot;</span>;        <span class="hljs-comment">// 如果模板引擎是 velocity</span>        <span class="hljs-comment">// String templatePath = &quot;/templates/mapper.xml.vm&quot;;</span>        <span class="hljs-comment">// 自定义输出配置</span>        List&lt;FileOutConfig&gt; focList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 自定义配置会被优先输出</span>        focList.add(<span class="hljs-keyword">new</span> FileOutConfig(templatePath) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">outputFile</span><span class="hljs-params">(TableInfo tableInfo)</span> </span>&#123;                <span class="hljs-comment">// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span>                <span class="hljs-keyword">return</span> projectPath + <span class="hljs-string">&quot;/src/main/resources/mapper/&quot;</span> + pc.getModuleName()                        + <span class="hljs-string">&quot;/&quot;</span> + tableInfo.getEntityName() + <span class="hljs-string">&quot;Mapper&quot;</span> + StringPool.DOT_XML;            &#125;        &#125;);        <span class="hljs-comment">/*</span><span class="hljs-comment">        cfg.setFileCreate(new IFileCreate() &#123;</span><span class="hljs-comment">            @Override</span><span class="hljs-comment">            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) &#123;</span><span class="hljs-comment">                // 判断自定义文件夹是否需要创建</span><span class="hljs-comment">                checkDir(&quot;调用默认方法创建的目录，自定义目录用&quot;);</span><span class="hljs-comment">                if (fileType == FileType.MAPPER) &#123;</span><span class="hljs-comment">                    // 已经生成 mapper 文件判断存在，不想重新生成返回 false</span><span class="hljs-comment">                    return !new File(filePath).exists();</span><span class="hljs-comment">                &#125;</span><span class="hljs-comment">                // 允许生成模板文件</span><span class="hljs-comment">                return true;</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">        &#125;);</span><span class="hljs-comment">        */</span>        cfg.setFileOutConfigList(focList);        mpg.setCfg(cfg);        <span class="hljs-comment">// 配置模板</span>        TemplateConfig templateConfig = <span class="hljs-keyword">new</span> TemplateConfig();        <span class="hljs-comment">// 配置自定义输出模板</span>        <span class="hljs-comment">//指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别</span>        <span class="hljs-comment">// templateConfig.setEntity(&quot;templates/entity2.java&quot;);</span>        <span class="hljs-comment">// templateConfig.setService();</span>        <span class="hljs-comment">// templateConfig.setController();</span>        templateConfig.setXml(<span class="hljs-keyword">null</span>);        mpg.setTemplate(templateConfig);        <span class="hljs-comment">// 策略配置</span>        StrategyConfig strategy = <span class="hljs-keyword">new</span> StrategyConfig();        strategy.setNaming(NamingStrategy.underline_to_camel);        strategy.setColumnNaming(NamingStrategy.underline_to_camel);        strategy.setSuperEntityClass(<span class="hljs-string">&quot;你自己的父类实体,没有就不用设置!&quot;</span>);        strategy.setEntityLombokModel(<span class="hljs-keyword">true</span>);        strategy.setRestControllerStyle(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">// 公共父类</span>        strategy.setSuperControllerClass(<span class="hljs-string">&quot;你自己的父类控制器,没有就不用设置!&quot;</span>);        <span class="hljs-comment">// 写于父类中的公共字段</span>        strategy.setSuperEntityColumns(<span class="hljs-string">&quot;id&quot;</span>);        strategy.setInclude(scanner(<span class="hljs-string">&quot;表名，多个英文逗号分割&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>));        strategy.setControllerMappingHyphenStyle(<span class="hljs-keyword">true</span>);        strategy.setTablePrefix(pc.getModuleName() + <span class="hljs-string">&quot;_&quot;</span>);        mpg.setStrategy(strategy);        mpg.setTemplateEngine(<span class="hljs-keyword">new</span> FreemarkerTemplateEngine());        mpg.execute();    &#125;&#125;</code></pre></div><h3 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h3><h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1 添加依赖"></a>1 添加依赖</h4><p>MyBatis-Plus 从 <code>3.0.3</code> 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖：</p><ul><li><p>添加 代码生成器 依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>添加 模板引擎 依赖，MyBatis-Plus 支持 Velocity（默认）、Freemarker、Beetl，用户可以选择自己熟悉的模板引擎，如果都不满足您的要求，可以采用自定义模板引擎。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity-engine-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>注意！如果您选择了非默认引擎，需要在 AutoGenerator 中 设置模板引擎。</p><div class="code-wrapper"><pre><code class="hljs java">AutoGenerator generator = <span class="hljs-keyword">new</span> AutoGenerator();<span class="hljs-comment">// set freemarker engine</span>generator.setTemplateEngine(<span class="hljs-keyword">new</span> FreemarkerTemplateEngine());<span class="hljs-comment">// set beetl engine</span>generator.setTemplateEngine(<span class="hljs-keyword">new</span> BeetlTemplateEngine());<span class="hljs-comment">// set custom engine (reference class is your custom engine class)</span>generator.setTemplateEngine(<span class="hljs-keyword">new</span> CustomTemplateEngine());<span class="hljs-comment">// other config</span>...</code></pre></div></li></ul><h4 id="2-编写配置"><a href="#2-编写配置" class="headerlink" title="2 编写配置"></a>2 编写配置</h4><p>MyBatis-Plus 的代码生成器提供了大量的自定义参数供用户选择，能够满足绝大部分人的使用需求。</p><ul><li><p>配置 GlobalConfig</p><div class="code-wrapper"><pre><code class="hljs java">GlobalConfig globalConfig = <span class="hljs-keyword">new</span> GlobalConfig();globalConfig.setOutputDir(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;/src/main/java&quot;</span>);globalConfig.setAuthor(<span class="hljs-string">&quot;jobob&quot;</span>);globalConfig.setOpen(<span class="hljs-keyword">false</span>);</code></pre></div></li><li><p>配置 DataSourceConfig</p><div class="code-wrapper"><pre><code class="hljs java">DataSourceConfig dataSourceConfig = <span class="hljs-keyword">new</span> DataSourceConfig();dataSourceConfig.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/ant?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);dataSourceConfig.setDriverName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);dataSourceConfig.setUsername(<span class="hljs-string">&quot;root&quot;</span>);dataSourceConfig.setPassword(<span class="hljs-string">&quot;password&quot;</span>);</code></pre></div></li></ul><h4 id="3-自定义模板引擎"><a href="#3-自定义模板引擎" class="headerlink" title="3 自定义模板引擎"></a>3 自定义模板引擎</h4><p>请继承类 com.baomidou.mybatisplus.generator.engine.AbstractTemplateEngine</p><ul><li><p>自定义代码模板</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//指定自定义模板路径, 位置：/resources/templates/entity2.java.ftl(或者是.vm)</span><span class="hljs-comment">//注意不要带上.ftl(或者是.vm), 会根据使用的模板引擎自动识别</span>TemplateConfig templateConfig = <span class="hljs-keyword">new</span> TemplateConfig()    .setEntity(<span class="hljs-string">&quot;templates/entity2.java&quot;</span>);AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();<span class="hljs-comment">//配置自定义模板</span>mpg.setTemplate(templateConfig);</code></pre></div></li><li><p>自定义属性注入</p><div class="code-wrapper"><pre><code class="hljs java">InjectionConfig injectionConfig = <span class="hljs-keyword">new</span> InjectionConfig() &#123;    <span class="hljs-comment">//自定义属性注入:abc</span>    <span class="hljs-comment">//在.ftl(或者是.vm)模板中，通过$&#123;cfg.abc&#125;获取属性</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-keyword">this</span>.getConfig().getGlobalConfig().getAuthor() + <span class="hljs-string">&quot;-mp&quot;</span>);        <span class="hljs-keyword">this</span>.setMap(map);    &#125;&#125;;AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();<span class="hljs-comment">//配置自定义属性注入</span>mpg.setCfg(injectionConfig);</code></pre></div></li><li><p>字段其他信息查询注入</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/custom-fields.png" alt="relationship"></p></li></ul><div class="code-wrapper"><pre><code><pre><code class="hljs java"><span class="hljs-keyword">new</span> DataSourceConfig().setDbQuery(<span class="hljs-keyword">new</span> MySqlQuery() &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 重写父类预留查询自定义字段&lt;br&gt;</span><span class="hljs-comment">     * 这里查询的 SQL 对应父类 tableFieldsSql 的查询字段，默认不能满足你的需求请重写它&lt;br&gt;</span><span class="hljs-comment">     * 模板中调用：  table.fields 获取所有字段信息，</span><span class="hljs-comment">     * 然后循环字段获取 field.customMap 从 MAP 中获取注入字段如下  NULL 或者 PRIVILEGES</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String[] fieldCustom() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;NULL&quot;</span>, <span class="hljs-string">&quot;PRIVILEGES&quot;</span>&#125;;    &#125;&#125;)</code></pre></div></code></pre>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Java/">Java</category>
      
      <category domain="https://pncalbl.github.io/categories/Java/Mybatis/">Mybatis</category>
      
      
      
      <comments>https://pncalbl.github.io/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Redis 学习</title>
      <link>https://pncalbl.github.io/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 07 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Redis-学习&quot;&gt;&lt;a href=&quot;#Redis-学习&quot; class=&quot;headerlink&quot; title=&quot;Redis 学习&quot;&gt;&lt;/a&gt;Redis 学习&lt;/h1&gt;&lt;h2 id=&quot;1-Nosql-概述&quot;&gt;&lt;a href=&quot;#1-Nosql-概述&quot; class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Redis-学习"><a href="#Redis-学习" class="headerlink" title="Redis 学习"></a>Redis 学习</h1><h2 id="1-Nosql-概述"><a href="#1-Nosql-概述" class="headerlink" title="1  Nosql 概述"></a>1  Nosql 概述</h2><h3 id="1-1-为什么要使用-Nosql"><a href="#1-1-为什么要使用-Nosql" class="headerlink" title="1.1 为什么要使用 Nosql"></a>1.1 为什么要使用 Nosql</h3><blockquote><p>  1、单机Mysql时代</p></blockquote><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020082010365930.png" alt></p><p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题</p><ol><li>数据量增加到一定程度，单机数据库就放不下了</li><li>数据的索引（B+ Tree）,一个机器内存也存放不下</li><li>访问量变大后（读写混合），一台服务器承受不住。</li></ol><blockquote><p>  2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）</p></blockquote><p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103713734.png" alt></p><p>优化过程经历了以下几个过程：</p><p>优化数据库的数据结构和索引(难度大)</p><p>文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</p><p>MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</p><blockquote><p>  3、分库分表 + 水平拆分 + Mysql集群</p></blockquote><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103739584.png" alt></p><blockquote><p>  4、如今最近的年代</p></blockquote><p>如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。</p><h3 id="1-2-什么是-Nosql"><a href="#1-2-什么是-Nosql" class="headerlink" title="1.2 什么是 Nosql"></a>1.2 什么是 Nosql</h3><p><strong>NoSQL = Not Only SQL（不仅仅是SQL）</strong></p><p>Not Only Structured Query Language</p><p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p><p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p><p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p><h3 id="1-3-Nosql-特点"><a href="#1-3-Nosql-特点" class="headerlink" title="1.3 Nosql 特点"></a>1.3 Nosql 特点</h3><ol><li><p>方便扩展（数据之间没有关系，很好扩展！）</p></li><li><p>大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p></li><li><p>数据类型是多样型的！（不需要事先设计数据库，随取随用）</p></li><li><p>传统的 RDBMS 和 NoSQL</p><div class="code-wrapper"><pre><code class="hljs asciidoc">传统的 RDBMS(关系型数据库)<span class="hljs-bullet">- </span>结构化组织<span class="hljs-bullet">- </span>SQL<span class="hljs-bullet">- </span>数据和关系都存在单独的表中 row col<span class="hljs-bullet">- </span>操作，数据定义语言<span class="hljs-bullet">- </span>严格的一致性<span class="hljs-bullet">- </span>基础的事务<span class="hljs-bullet">- </span>...</code></pre></div><div class="code-wrapper"><pre><code class="hljs asciidoc">Nosql<span class="hljs-bullet">- </span>不仅仅是数据<span class="hljs-bullet">- </span>没有固定的查询语言<span class="hljs-bullet">- </span>键值对存储，列存储，文档存储，图形数据库（社交关系）<span class="hljs-bullet">- </span>最终一致性<span class="hljs-bullet">- </span>CAP定理和BASE<span class="hljs-bullet">- </span>高性能，高可用，高扩展<span class="hljs-bullet">- </span>...</code></pre></div></li></ol><blockquote><p>  了解：3V + 3高</p></blockquote><p>大数据时代的3V ：主要是<strong>描述问题</strong>的</p><ol><li>海量Velume</li><li>多样Variety</li><li>实时Velocity</li></ol><p>大数据时代的3高 ： 主要是<strong>对程序的要求</strong></p><ol><li>高并发</li><li>高可扩</li><li>高性能</li></ol><p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p><h3 id="1-4-阿里巴巴演进分析"><a href="#1-4-阿里巴巴演进分析" class="headerlink" title="1.4 阿里巴巴演进分析"></a>1.4 阿里巴巴演进分析</h3><p>推荐阅读：阿里云的这群疯子<a href="https://yq.aliyun.com/articles/653511">https://yq.aliyun.com/articles/653511</a></p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103829446.png" alt></p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103851613.png" alt></p><div class="code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 商品信息</span><span class="hljs-bullet">-</span> 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。<span class="hljs-section"># 商品描述、评论(文字居多)</span><span class="hljs-bullet">-</span> 文档型数据库：MongoDB<span class="hljs-section"># 图片</span><span class="hljs-bullet">-</span> 分布式文件系统 FastDFS<span class="hljs-bullet">-</span> 淘宝：TFS<span class="hljs-bullet">-</span> Google: GFS<span class="hljs-bullet">-</span> Hadoop: HDFS<span class="hljs-bullet">-</span> 阿里云: oss<span class="hljs-section"># 商品关键字 用于搜索</span><span class="hljs-bullet">-</span> 搜索引擎：solr,elasticsearch<span class="hljs-bullet">-</span> 阿里：Isearch 多隆<span class="hljs-section"># 商品热门的波段信息</span><span class="hljs-bullet">-</span> 内存数据库：Redis，Memcache<span class="hljs-section"># 商品交易，外部支付接口</span><span class="hljs-bullet">-</span> 第三方应用</code></pre></div><h3 id="1-5-Nosql-的四大分类"><a href="#1-5-Nosql-的四大分类" class="headerlink" title="1.5 Nosql 的四大分类"></a>1.5 Nosql 的四大分类</h3><blockquote><p>  <strong>KV键值对</strong></p></blockquote><ul><li>新浪：<strong>Redis</strong></li><li>美团：Redis + Tair</li><li>阿里、百度：Redis + Memcache</li></ul><blockquote><p>  <strong>文档型数据库（bson数据格式）：</strong></p></blockquote><ul><li><strong>MongoDB</strong>(掌握)<ul><li>基于分布式文件存储的数据库。C++编写，用于处理大量文档。</li><li>MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。</li></ul></li><li>ConthDB</li></ul><blockquote><p>  <strong>列存储数据库</strong></p></blockquote><ul><li><strong>HBase</strong>(大数据必学)</li><li>分布式文件系统</li></ul><blockquote><p>  <strong>图关系数据库</strong></p></blockquote><p>用于广告推荐，社交网络</p><ul><li><strong>Neo4j</strong>、InfoGrid</li></ul><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210512004919811.png" alt></p><h2 id="2-redis-入门"><a href="#2-redis-入门" class="headerlink" title="2 redis 入门"></a>2 redis 入门</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1  概述"></a>1  概述</h3><ul><li><p>Redis是什么？</p><ul><li><p>Redis（Remote Dictionary Server )，即远程字典服务。</p></li><li><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p></li><li><p>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p></li></ul></li><li><p>Redis能该干什么？</p><ul><li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li><li>高效率、用于高速缓冲</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器(eg：浏览量)</li></ul></li><li><p>特性</p><ul><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li></ul></li></ul><h3 id="1-2-环境搭建"><a href="#1-2-环境搭建" class="headerlink" title="1.2 环境搭建"></a>1.2 环境搭建</h3><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>推荐使用Linux服务器学习。</p><p>windows版本的Redis已经停更很久了</p><h3 id="1-3-windows-安装"><a href="#1-3-windows-安装" class="headerlink" title="1.3 windows 安装"></a>1.3 windows 安装</h3><p><a href="https://github.com/dmajkic/redis">https://github.com/dmajkic/redis</a></p><ul><li><p>解压安装包</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103922318.png" alt></p></li><li><p>开启redis-server.exe</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103950934.png" alt></p></li><li><p>启动redis-cli.exe测试</p></li></ul><h3 id="1-4-Linux-安装"><a href="#1-4-Linux-安装" class="headerlink" title="1.4 Linux 安装"></a>1.4 Linux 安装</h3><ul><li><p>下载安装包！<code>redis-5.0.8.tar.gz</code></p></li><li><p>解压Redis的安装包！程序一般放在 <code>/usr/local/redis</code> 目录下</p></li><li><p>基本环境安装</p><div class="code-wrapper"><pre><code class="hljs shell">yum install gcc-c++<span class="hljs-meta">#</span><span class="bash"> 然后进入redis目录下执行</span>make<span class="hljs-meta">#</span><span class="bash"> 然后执行</span>make install</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104048327.png" alt></p></li><li><p>将 REDIS 安装为系统服务并后台启动</p><div class="code-wrapper"><pre><code class="hljs shell">[root@localhost redis-5.0.8]# cd utils/ [root@localhost utils]# ./install_server.sh</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214319345.png" alt></p></li><li><p>查看REDIS服务启动情况</p><div class="code-wrapper"><pre><code class="hljs shell">systemctl status redis_6379.service</code></pre></div></li></ul><h3 id="1-5-测试性能"><a href="#1-5-测试性能" class="headerlink" title="1.5 测试性能"></a>1.5 测试性能</h3><ul><li><p>启动REDIS客户端并测试</p><div class="code-wrapper"><pre><code class="hljs shell">redis-cli</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214531489.png" alt></p></li><li><p>设置允许远程连接</p><div class="code-wrapper"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>redis/<span class="hljs-number">6379</span>.conf</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214552849-1621086353677.png" alt></p><div class="code-wrapper"><pre><code class="hljs shell">systemctl restart redis_6379.service</code></pre></div></li><li><p>设置访问密码</p><div class="code-wrapper"><pre><code class="hljs shell">vim /etc/redis/6379.conf</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214651751.png" alt></p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214712651.png" alt></p></li><li><p>redis-benchmark：Redis官方提供的性能测试工具，参数选项如下：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214125892.png" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试：100个并发连接 100000请求</span>redis-benchmark -h localhost -p 6379 -c 100 -n 100000</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104343472.png" alt></p></li></ul><h3 id="1-6-基础知识"><a href="#1-6-基础知识" class="headerlink" title="1.6 基础知识"></a>1.6 基础知识</h3><ul><li><p>redis默认有16个数据库</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104357466.png" alt></p><p>默认使用的第0个;</p><p>16个数据库为：DB 0~DB 15<br>默认使用DB 0 ，可以使用<code>select n</code>切换到DB n，<code>dbsize</code>可以查看当前数据库的大小，与key数量相关。</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; config get databases # 命令行查看数据库数量databases1) &quot;databases&quot;2) &quot;16&quot;127.0.0.1:6379&gt; select 8 # 切换数据库 DB 8OK127.0.0.1:6379[8]&gt; dbsize # 查看数据库大小(integer) 0<span class="hljs-meta">#</span><span class="bash"> 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。</span>127.0.0.1:6379&gt; set name sakura OK127.0.0.1:6379&gt; SELECT 8OK127.0.0.1:6379[8]&gt; get name # db8中并不能获取db0中的键值对。(nil)127.0.0.1:6379[8]&gt; DBSIZE(integer) 0127.0.0.1:6379[8]&gt; SELECT 0OK127.0.0.1:6379&gt; keys *1) &quot;counter:__rand_int__&quot;2) &quot;mylist&quot;3) &quot;name&quot;4) &quot;key:__rand_int__&quot;5) &quot;myset:__rand_int__&quot;127.0.0.1:6379&gt; DBSIZE # size和key个数相关(integer) 5</code></pre></div><p><code>keys *</code> ：查看当前数据库中所有的key。</p><p><code>flushdb</code>：清空当前数据库中的键值对。</p><p><code>flushall</code>：清空所有数据库的键值对。</p></li><li><p><strong>Redis是单线程的，Redis是基于内存操作的。</strong></p><ul><li>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</li><li>那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+</li></ul></li><li><p><strong>Redis为什么单线程还这么快</strong></p><ul><li>误区1：高性能的服务器一定是多线程的？</li><li>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</li><li>核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</li></ul></li></ul><h2 id="3-五大数据类型"><a href="#3-五大数据类型" class="headerlink" title="3 五大数据类型"></a>3 五大数据类型</h2><p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p><h3 id="3-1-Redis-key"><a href="#3-1-Redis-key" class="headerlink" title="3.1 Redis-key"></a>3.1 Redis-key</h3><p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p><p>下面学习的命令：</p><ul><li><p><code>exists key</code>：判断键是否存在</p></li><li><p><code>del key</code>：删除键值对</p></li><li><p><code>move key db</code>：将键值对移动到指定数据库</p></li><li><p><code>expire key second</code>：设置键值对的过期时间</p></li><li><p><code>type key</code>：查看value的数据类型</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; keys * # 查看当前数据库所有key(empty list or set)127.0.0.1:6379&gt; set name qinjiang # set keyOK127.0.0.1:6379&gt; set age 20OK127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; move age 1 # 将键值对移动到指定数据库(integer) 1127.0.0.1:6379&gt; EXISTS age # 判断键是否存在(integer) 0 # 不存在127.0.0.1:6379&gt; EXISTS name(integer) 1 # 存在127.0.0.1:6379&gt; SELECT 1OK127.0.0.1:6379[1]&gt; keys *1) &quot;age&quot;127.0.0.1:6379[1]&gt; del age # 删除键值对(integer) 1 # 删除个数127.0.0.1:6379&gt; set age 20OK127.0.0.1:6379&gt; EXPIRE age 15 # 设置键值对的过期时间(integer) 1 # 设置成功 开始计数127.0.0.1:6379&gt; ttl age # 查看key的过期剩余时间(integer) 13127.0.0.1:6379&gt; ttl age(integer) 11127.0.0.1:6379&gt; ttl age(integer) 9127.0.0.1:6379&gt; ttl age(integer) -2 # -2 表示key过期，-1表示key未设置过期时间127.0.0.1:6379&gt; get age # 过期的key 会被自动delete(nil)127.0.0.1:6379&gt; keys *&quot;name&quot;127.0.0.1:6379&gt; type name # 查看value的数据类型string</code></pre></div></li><li><p>关于TTL命令</p></li><li><p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p><ul><li>当前key没有设置过期时间，所以会返回-1.</li><li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li><li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li></ul></li><li><p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p><ul><li><code>RENAME key newkey</code>修改 key 的名称</li><li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li></ul></li></ul><h3 id="3-2-String"><a href="#3-2-String" class="headerlink" title="3.2 String"></a>3.2 String</h3><p>普通的set、get直接略过。</p><p>常用命令及其示例：</p><p><code>APPEND key value</code>: 向指定的key的value后追加字符串</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg &quot; world&quot; (integer) 11 127.0.0.1:6379&gt; get msg “hello world”</code></pre></div><p><code>DECR/INCR key</code>: 将指定key的value数值进行+1/-1(仅对于数字)</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20</code></pre></div><p><code>INCRBY/DECRBY key n</code>: 按指定的步长对数值进行加减</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; INCRBY age 5(integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15</code></pre></div><p><code>INCRBYFLOAT key n</code>: 为数值加上浮点型数值</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</code></pre></div><p><code>STRLEN key</code>: 获取key保存值的字符串长度</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11</code></pre></div><p><code>GETRANGE key start end</code>: 按起止位置获取字符串（闭区间，起止位置都取）</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”</code></pre></div><p><code>SETRANGE key offset value</code>:用指定的value 替换key中 offset开始的值</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set msg helloOK127.0.0.1:6379&gt; setrange msg 2 hello(integer) 7127.0.0.1:6379&gt; get msg&quot;hehello&quot;127.0.0.1:6379&gt; set msg2 worldOK127.0.0.1:6379&gt; setrange msg2 2 ww(integer) 5127.0.0.1:6379&gt; get msg2&quot;wowwd&quot;</code></pre></div><p><code>GETSET key value</code>: 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; GETSET msg test “hello world”</code></pre></div><p><code>SETNX key value</code>: 仅当key不存在时进行set</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1</code></pre></div><p><code>SETEX key seconds value</code>: set 键值对并设置过期时间</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)</code></pre></div><p><code>MSET key1 value1 [key2 value2..]</code>: 批量set键值对</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK</code></pre></div><p><code>MSETNX key1 value1 [key2 value2..]</code>: 批量设置键值对，仅当参数中所有的key都不存在时执行</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0</code></pre></div><p><code>MGET key1 [key2..]</code>: 批量获取多个key保存的值</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</code></pre></div><p><code>PSETEX key milliseconds value</code>: 和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间</p><p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p><ul><li>计数器</li><li>统计多单位的数量：uid:123666：follow 0</li><li>粉丝数</li><li>对象存储缓存</li></ul><h3 id="3-3-List"><a href="#3-3-List" class="headerlink" title="3.3 List"></a>3.3 List</h3><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p><p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104440398.png" alt></p><p>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p><ul><li><code>LPUSH/RPUSH key value1[value2..]</code>从左边/右边向列表中PUSH值(一个或者多个)。</li><li><code>LRANGE key start end</code> 获取list 起止元素== （索引从左往右 递增）==</li><li><code>LPUSHX/RPUSHX key value</code> 向已存在的列名中push值（一个或者多个）</li><li><code>LINSERT key BEFORE|AFTER pivot value</code> 在指定列表元素的前/后 插入value</li><li><code>LLEN key</code> 查看列表长度</li><li><code>LINDEX key index</code> 通过索引获取列表元素</li><li><code>LSET key index value</code> 通过索引为元素设值</li><li><code>LPOP/RPOP key</code> 从最左边/最右边移除值 并返回</li><li><code>RPOPLPUSH source destination</code> 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</li><li><code>LTRIM key start end</code> 通过下标截取指定范围内的列表</li><li><code>LREM key count value</code> List中是允许value重复的 count &gt; 0：从头部开始搜索 然后删除指定的value 至多删除count个 count &lt; 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。</li><li><code>BLPOP/BRPOP key1[key2] timout</code> 移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li><li><code>BRPOPLPUSH source destination timeout</code> 和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">---------------------------LPUSH---RPUSH---LRANGE--------------------------------127.0.0.1:6379&gt; LPUSH mylist k1 # LPUSH mylist=&gt;&#123;1&#125;(integer) 1127.0.0.1:6379&gt; LPUSH mylist k2 # LPUSH mylist=&gt;&#123;2,1&#125;(integer) 2127.0.0.1:6379&gt; RPUSH mylist k3 # RPUSH mylist=&gt;&#123;2,1,3&#125;(integer) 3127.0.0.1:6379&gt; get mylist # 普通的get是无法获取list值的(error) WRONGTYPE Operation against a key holding the wrong kind of value127.0.0.1:6379&gt; LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素&quot;k2&quot;&quot;k1&quot;&quot;k3&quot;127.0.0.1:6379&gt; LRANGE mylist 0 2&quot;k2&quot;&quot;k1&quot;&quot;k3&quot;127.0.0.1:6379&gt; LRANGE mylist 0 1&quot;k2&quot;&quot;k1&quot;127.0.0.1:6379&gt; LRANGE mylist 0 -1 # 获取全部元素&quot;k2&quot;&quot;k1&quot;&quot;k3&quot;---------------------------LPUSHX---RPUSHX-----------------------------------127.0.0.1:6379&gt; LPUSHX list v1 # list不存在 LPUSHX失败(integer) 0127.0.0.1:6379&gt; LPUSHX list v1 v2(integer) 0127.0.0.1:6379&gt; LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5(integer) 5127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k5&quot;&quot;k4&quot;&quot;k2&quot;&quot;k1&quot;&quot;k3&quot;---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1(integer) 6127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k5&quot;&quot;k4&quot;&quot;k2&quot;&quot;ins_key1&quot;&quot;k1&quot;&quot;k3&quot;127.0.0.1:6379&gt; LLEN mylist # 查看mylist的长度(integer) 6127.0.0.1:6379&gt; LINDEX mylist 3 # 获取下标为3的元素&quot;ins_key1&quot;127.0.0.1:6379&gt; LINDEX mylist 0&quot;k5&quot;127.0.0.1:6379&gt; LSET mylist 3 k6 # 将下标3的元素 set值为k6OK127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k5&quot;&quot;k4&quot;&quot;k2&quot;&quot;k6&quot;&quot;k1&quot;&quot;k3&quot;---------------------------LPOP--RPOP--------------------------127.0.0.1:6379&gt; LPOP mylist # 左侧(头部)弹出&quot;k5&quot;127.0.0.1:6379&gt; RPOP mylist # 右侧(尾部)弹出&quot;k3&quot;---------------------------RPOPLPUSH--------------------------127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k4&quot;&quot;k2&quot;&quot;k6&quot;&quot;k1&quot;127.0.0.1:6379&gt; RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部&quot;k1&quot;127.0.0.1:6379&gt; LRANGE newlist 0 -1&quot;k1&quot;127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k4&quot;&quot;k2&quot;&quot;k6&quot;---------------------------LTRIM--------------------------127.0.0.1:6379&gt; LTRIM mylist 0 1 # 截取mylist中的 0~1部分OK127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k4&quot;&quot;k2&quot;初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2---------------------------LREM--------------------------127.0.0.1:6379&gt; LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2(integer) 3删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2127.0.0.1:6379&gt; LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2(integer) 2删除后：mylist: k2,k2,k2,k4,k2,k2---------------------------BLPOP--BRPOP--------------------------mylist: k2,k2,k2,k4,k2,k2newlist: k1127.0.0.1:6379&gt; BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选&quot;newlist&quot; # 弹出&quot;k1&quot;127.0.0.1:6379&gt; BLPOP newlist mylist 30&quot;mylist&quot; # 由于newlist空了 从mylist中弹出&quot;k2&quot;127.0.0.1:6379&gt; BLPOP newlist 30(30.10s) # 超时了127.0.0.1:6379&gt; BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。&quot;newlist&quot;&quot;test&quot;(12.54s)</code></pre></div><p><strong>小结</strong></p><ul><li>list实际上是一个链表，before Node after , left, right 都可以插入值</li><li>如果key不存在，则创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li></ul><p>应用：</p><p>消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）</p><h3 id="3-3-Set"><a href="#3-3-Set" class="headerlink" title="3.3 Set"></a>3.3 Set</h3><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><ul><li><code>SADD key member1[member2..]</code> 向集合中无序增加一个/多个成员</li><li><code>SCARD key</code> 获取集合的成员数</li><li><code>SMEMBERS key</code> 返回集合中所有的成员</li><li><code>SISMEMBER key member</code> 查询member元素是否是集合的成员,结果是无序的</li><li><code>SRANDMEMBER key [count]</code> 随机返回集合中count个成员，count缺省值为1</li><li><code>SPOP key [count]</code> 随机移除并返回集合中count个成员，count缺省值为1</li><li><code>SMOVE source destination member</code> 将source集合的成员member移动到destination集合</li><li><code>SREM key member1[member2..]</code> 移除集合中一个/多个成员</li><li><code>SDIFF key1[key2..]</code> 返回所有集合的差集 key1- key2 - …</li><li><code>SDIFFSTORE destination key1[key2..]</code> 在SDIFF的基础上，将结果保存到集合中<strong>(覆盖)</strong>。不能保存到其他类型key噢！</li><li><code>SINTER key1 [key2..]</code> 返回所有集合的交集</li><li><code>SINTERSTORE destination key1[key2..]</code> 在SINTER的基础上，存储结果到集合中。覆盖</li><li><code>SUNION key1 [key2..]</code> 返回所有集合的并集</li><li><code>SUNIONSTORE destination key1 [key2..]</code> 在SUNION的基础上，存储结果到及和张。覆盖</li><li><code>SSCAN KEY [MATCH pattern] [COUNT count]</code> 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4(integer) 4127.0.0.1:6379&gt; SCARD myset # 获取集合的成员数目(integer) 4127.0.0.1:6379&gt; smembers myset # 获取集合中所有成员&quot;m4&quot;&quot;m3&quot;&quot;m2&quot;&quot;m1&quot;127.0.0.1:6379&gt; SISMEMBER myset m5 # 查询m5是否是myset的成员(integer) 0 # 不是，返回0127.0.0.1:6379&gt; SISMEMBER myset m2(integer) 1 # 是，返回1127.0.0.1:6379&gt; SISMEMBER myset m3(integer) 1---------------------SRANDMEMBER--SPOP----------------------------------127.0.0.1:6379&gt; SRANDMEMBER myset 3 # 随机返回3个成员&quot;m2&quot;&quot;m3&quot;&quot;m4&quot;127.0.0.1:6379&gt; SRANDMEMBER myset # 随机返回1个成员&quot;m3&quot;127.0.0.1:6379&gt; SPOP myset 2 # 随机移除并返回2个成员&quot;m1&quot;&quot;m4&quot;将set还原到&#123;m1,m2,m3,m4&#125;---------------------SMOVE--SREM----------------------------------------127.0.0.1:6379&gt; SMOVE myset newset m3 # 将myset中m3成员移动到newset集合(integer) 1127.0.0.1:6379&gt; SMEMBERS myset&quot;m4&quot;&quot;m2&quot;&quot;m1&quot;127.0.0.1:6379&gt; SMEMBERS newset&quot;m3&quot;127.0.0.1:6379&gt; SREM newset m3 # 从newset中移除m3元素(integer) 1127.0.0.1:6379&gt; SMEMBERS newset(empty list or set)下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算setx=&gt;&#123;m1,m2,m4,m6&#125;, sety=&gt;&#123;m2,m5,m6&#125;, setz=&gt;&#123;m1,m3,m6&#125;-----------------------------SDIFF------------------------------------127.0.0.1:6379&gt; SDIFF setx sety setz # 等价于setx-sety-setz&quot;m4&quot;127.0.0.1:6379&gt; SDIFF setx sety # setx - sety&quot;m4&quot;&quot;m1&quot;127.0.0.1:6379&gt; SDIFF sety setx # sety - setx&quot;m5&quot;-------------------------SINTER---------------------------------------共同关注（交集）127.0.0.1:6379&gt; SINTER setx sety setz # 求 setx、sety、setx的交集&quot;m6&quot;127.0.0.1:6379&gt; SINTER setx sety # 求setx sety的交集&quot;m2&quot;&quot;m6&quot;-------------------------SUNION---------------------------------------127.0.0.1:6379&gt; SUNION setx sety setz # setx sety setz的并集&quot;m4&quot;&quot;m6&quot;&quot;m3&quot;&quot;m2&quot;&quot;m1&quot;&quot;m5&quot;127.0.0.1:6379&gt; SUNION setx sety # setx sety 并集&quot;m4&quot;&quot;m6&quot;&quot;m2&quot;&quot;m1&quot;&quot;m5&quot;</code></pre></div><h3 id="3-4-Hash"><a href="#3-4-Hash" class="headerlink" title="3.4 Hash"></a>3.4 Hash</h3><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p><ul><li><code>HSET key field value</code> 将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</li><li><code>HMSET key field1 value1 [field2 value2..]</code> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</li><li><code>HSETNX key field value</code> 只有在字段 field 不存在时，设置哈希表字段的值。</li><li><code>HEXISTS key field</code> 查看哈希表 key 中，指定的字段是否存在。</li><li><code>HGET key field value</code> 获取存储在哈希表中指定字段的值</li><li><code>HMGET key field1 [field2..]</code> 获取所有给定字段的值</li><li><code>HGETALL key</code> 获取在哈希表key 的所有字段和值</li><li><code>HKEYS key</code> 获取哈希表key中所有的字段</li><li><code>HLEN key</code> 获取哈希表中字段的数量</li><li><code>HVALS key</code> 获取哈希表中所有值</li><li><code>HDEL key field1 [field2..]</code> 删除哈希表key中一个/多个field字段</li><li><code>HINCRBY key field n</code> 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</li><li><code>HINCRBYFLOAT key field n</code> 为哈希表 key 中的指定字段的浮点数值加上增量 n。</li><li><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code> 迭代哈希表中的键值对。</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">------------------------HSET--HMSET--HSETNX----------------127.0.0.1:6379&gt; HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura(integer) 1127.0.0.1:6379&gt; HSET studentx name gyc # 重复设置field进行覆盖，并返回0(integer) 0127.0.0.1:6379&gt; HSET studentx age 20 # 设置studentx的age为20(integer) 1127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886OK127.0.0.1:6379&gt; HSETNX studentx name gyc # HSETNX 设置已存在的field(integer) 0 # 失败127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com(integer) 1 # 成功----------------------HEXISTS--------------------------------127.0.0.1:6379&gt; HEXISTS studentx name # name字段在studentx中是否存在(integer) 1 # 存在127.0.0.1:6379&gt; HEXISTS studentx addr(integer) 0 # 不存在-------------------HGET--HMGET--HGETALL-----------127.0.0.1:6379&gt; HGET studentx name # 获取studentx中name字段的value&quot;gyc&quot;127.0.0.1:6379&gt; HMGET studentx name age tel # 获取studentx中name、age、tel字段的value&quot;gyc&quot;&quot;20&quot;&quot;15623667886&quot;127.0.0.1:6379&gt; HGETALL studentx # 获取studentx中所有的field及其value&quot;name&quot;&quot;gyc&quot;&quot;age&quot;&quot;20&quot;&quot;sex&quot;&quot;1&quot;&quot;tel&quot;&quot;15623667886&quot;&quot;email&quot;&quot;12345@qq.com&quot;--------------------HKEYS--HLEN--HVALS--------------127.0.0.1:6379&gt; HKEYS studentx # 查看studentx中所有的field&quot;name&quot;&quot;age&quot;&quot;sex&quot;&quot;tel&quot;&quot;email&quot;127.0.0.1:6379&gt; HLEN studentx # 查看studentx中的字段数量(integer) 5127.0.0.1:6379&gt; HVALS studentx # 查看studentx中所有的value&quot;gyc&quot;&quot;20&quot;&quot;1&quot;&quot;15623667886&quot;&quot;12345@qq.com&quot;-------------------------HDEL--------------------------127.0.0.1:6379&gt; HDEL studentx sex tel # 删除studentx 中的sex、tel字段(integer) 2127.0.0.1:6379&gt; HKEYS studentx&quot;name&quot;&quot;age&quot;&quot;email&quot;-------------HINCRBY--HINCRBYFLOAT------------------------127.0.0.1:6379&gt; HINCRBY studentx age 1 # studentx的age字段数值+1(integer) 21127.0.0.1:6379&gt; HINCRBY studentx name 1 # 非整数字型字段不可用(error) ERR hash value is not an integer127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6&quot;90.8&quot;</code></pre></div><p> Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！</p><h3 id="3-5-Zset-有序集合"><a href="#3-5-Zset-有序集合" class="headerlink" title="3.5 Zset(有序集合)"></a>3.5 Zset(有序集合)</h3><p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>score相同：按字典顺序排序</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><ul><li><code>ZADD key score member1 [score2 member2]</code> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</li><li><code>ZCARD key</code> 获取有序集合的成员数</li><li><code>ZCOUNT key min max</code> 计算在有序集合中指定区间score的成员数</li><li><code>ZINCRBY key n member</code> 有序集合中对指定成员的分数加上增量 n</li><li><code>ZSCORE key member</code> 返回有序集中，成员的分数值</li><li><code>ZRANK key member</code> 返回有序集合中指定成员的索引</li><li><code>ZRANGE key start end</code> 通过索引区间返回有序集合成指定区间内的成员</li><li><code>ZRANGEBYLEX key min max</code> 通过字典区间返回有序集合的成员</li><li><code>ZRANGEBYSCORE key min max</code> 通过分数返回有序集合指定区间内的成员 <strong>-inf 和 +inf</strong>分别表示最小最大值，只支持开区间() </li><li><code>ZLEXCOUNT key min max</code> 在有序集合中计算指定字典区间内成员数量</li><li><code>ZREM key member1 [member2..]</code> 移除有序集合中一个/多个成员</li><li><code>ZREMRANGEBYLEX key min max</code> 移除有序集合中给定的字典区间的所有成员</li><li><code>ZREMRANGEBYRANK key start stop</code> 移除有序集合中给定的排名区间的所有成员</li><li><code>ZREMRANGEBYSCORE key min max</code> 移除有序集合中给定的分数区间的所有成员</li><li><code>ZREVRANGE key start end</code> 返回有序集中指定区间内的成员，通过索引，分数从高到底</li><li><code>ZREVRANGEBYSCORRE key max min</code> 返回有序集中指定分数区间内的成员，分数从高到低排序</li><li><code>ZREVRANGEBYLEX key max min</code> 返回有序集中指定字典区间内的成员，按字典顺序倒序</li><li><code>ZREVRANK key member</code> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</li><li><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</li><li><code>ZUNIONSTORE destination numkeys key1 [key2..]</code> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</li><li><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code> 迭代有序集合中的元素（包括元素成员和元素分值）</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">-------------------ZADD--ZCARD--ZCOUNT--------------127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2..(integer) 2127.0.0.1:6379&gt; ZCARD myzset # 获取有序集合的成员数(integer) 2127.0.0.1:6379&gt; ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量(integer) 1127.0.0.1:6379&gt; ZCOUNT myzset 0 2(integer) 2----------------ZINCRBY--ZSCORE--------------------------127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 # 将成员m2的score +5&quot;7&quot;127.0.0.1:6379&gt; ZSCORE myzset m1 # 获取成员m1的score&quot;1&quot;127.0.0.1:6379&gt; ZSCORE myzset m2&quot;7&quot;--------------ZRANK--ZRANGE-----------------------------------127.0.0.1:6379&gt; ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加(integer) 0127.0.0.1:6379&gt; ZRANK myzset m2(integer) 2127.0.0.1:6379&gt; ZRANGE myzset 0 1 # 获取索引在 0~1的成员&quot;m1&quot;&quot;m3&quot;127.0.0.1:6379&gt; ZRANGE myzset 0 -1 # 获取全部成员&quot;m1&quot;&quot;m3&quot;&quot;m2&quot;testset=&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0------------------ZRANGEBYLEX---------------------------------127.0.0.1:6379&gt; ZRANGEBYLEX testset - + # 返回所有成员&quot;abc&quot;&quot;add&quot;&quot;amaze&quot;&quot;apple&quot;&quot;back&quot;&quot;java&quot;&quot;redis&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录&quot;abc&quot;&quot;add&quot;&quot;amaze&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录&quot;apple&quot;&quot;back&quot;&quot;java&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员&quot;abc&quot;&quot;add&quot;&quot;amaze&quot;&quot;apple&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员&quot;apple&quot;&quot;back&quot;&quot;java&quot;-----------------------ZRANGEBYSCORE---------------------127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员&quot;m1&quot;&quot;m3&quot;&quot;m2&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 5&quot;m1&quot;&quot;m3&quot;--------------------ZLEXCOUNT-----------------------------127.0.0.1:6379&gt; ZLEXCOUNT testset - +(integer) 7127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java(integer) 3------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------127.0.0.1:6379&gt; ZREM testset abc # 移除成员abc(integer) 1127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员(integer) 3127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员(integer) 2127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员(integer) 2testset=&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0myzset=&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3&quot;m9&quot;&quot;m7&quot;&quot;m4&quot;&quot;m3&quot;127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4&quot;m4&quot;&quot;m3&quot;&quot;m2&quot;127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员&quot;m4&quot;&quot;m3&quot;&quot;m2&quot;127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add # 按字典倒序 返回集合中(add,java]字典区间的成员&quot;java&quot;&quot;back&quot;&quot;apple&quot;&quot;amaze&quot;-------------------------ZREVRANK------------------------------127.0.0.1:6379&gt; ZREVRANK myzset m7 # 按score递减顺序，返回成员m7索引(integer) 1127.0.0.1:6379&gt; ZREVRANK myzset m2(integer) 4mathscore=&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩enscore=&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore # 将mathscore enscore进行合并 结果存放到sumscore(integer) 3127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores # 合并后的score是之前集合中所有score的和&quot;xm&quot;&quot;160&quot;&quot;xg&quot;&quot;177&quot;&quot;xh&quot;&quot;188&quot;127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN # 取两个集合的成员score最小值作为结果的(integer) 3127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores&quot;xm&quot;&quot;70&quot;&quot;xg&quot;&quot;87&quot;&quot;xh&quot;&quot;93&quot;</code></pre></div><p>应用案例：</p><ol><li>set排序 存储班级成绩表 工资表排序！</li><li>普通消息，1.重要消息 2.带权重进行判断</li><li>排行榜应用实现，取Top N测试</li></ol><h2 id="4-三种特殊的数据类型"><a href="#4-三种特殊的数据类型" class="headerlink" title="4 三种特殊的数据类型"></a>4 三种特殊的数据类型</h2><h3 id="4-1-Geospatial-地理位置"><a href="#4-1-Geospatial-地理位置" class="headerlink" title="4.1 Geospatial(地理位置)"></a>4.1 Geospatial(地理位置)</h3><p>使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用</p><ul><li><code>geoadd key longitud(经度) latitude(纬度) member [..]</code> 将具体经纬度的坐标存入一个有序集合</li><li><code>geopos key member [member..]</code> 获取集合中的一个/多个成员坐标</li><li><code>geodist key member1 member2 [unit]</code> 返回两个给定位置之间的距离。默认以米作为单位。</li><li><code>georadius key longitude latitude radius m|km|mi|ft [WITHCOORD][WITHDIST] [WITHHASH] [COUNT count]</code> 以给定的经纬度为中心， 返回集合包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</li><li><code>GEORADIUSBYMEMBER key member radius...</code> 功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</li><li><code>geohash key member1 [member2..]</code> 返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</li></ul><h4 id="有效经纬度"><a href="#有效经纬度" class="headerlink" title="有效经纬度"></a>有效经纬度</h4><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul><p><strong>指定单位的参数 unit 必须是以下单位的其中一个：</strong></p><ul><li>m 表示单位为米。</li></ul><ul><li>km 表示单位为千米。</li></ul><ul><li>mi 表示单位为英里。</li></ul><ul><li>ft 表示单位为英尺。</li></ul><h4 id="关于GEORADIUS的参数"><a href="#关于GEORADIUS的参数" class="headerlink" title="关于GEORADIUS的参数"></a>关于GEORADIUS的参数</h4><ul><li>通过georadius就可以完成 附近的人功能</li></ul><ul><li>withcoord:带上坐标</li></ul><ul><li>withdist:带上距离，单位与半径单位相同</li></ul><ul><li>COUNT n : 只显示前n个(按距离递增排序)</li></ul><div class="code-wrapper"><pre><code class="hljs shell">----------------georadius---------------------127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员1) 1) &quot;hangzhou&quot;   2) &quot;29.4151&quot;   3) 1) &quot;120.20000249147415&quot;      2) &quot;30.199999888333501&quot;2) 1) &quot;shanghai&quot;   2) &quot;205.3611&quot;   3) 1) &quot;121.40000134706497&quot;      2) &quot;31.400000253193539&quot;------------geohash---------------------------127.0.0.1:6379&gt; geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示&quot;wmrjwbr5250&quot;&quot;wtw6ds0y300&quot;</code></pre></div><h3 id="4-2-Hyperloglog-基数统计"><a href="#4-2-Hyperloglog-基数统计" class="headerlink" title="4.2 Hyperloglog(基数统计)"></a>4.2 Hyperloglog(基数统计)</h3><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>其底层使用string数据类型。</p><h4 id="什么是基数？"><a href="#什么是基数？" class="headerlink" title="什么是基数？"></a>什么是基数？</h4><p>数据集中不重复的元素的个数。</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p><p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。</p><ul><li><code>PFADD key element1 [elememt2..]</code> 添加指定元素到 HyperLogLog中</li><li><code>PFCOUNT key [key]</code> 返回给定 HyperLogLog 的基数估算值。</li><li><code>PFMERGE destkey sourcekey [sourcekey..]</code> 将多个 HyperLogLog 合并为一个 HyperLogLog</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">----------PFADD--PFCOUNT---------------------127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k # 添加元素(integer) 1127.0.0.1:6379&gt; type myelemx # hyperloglog底层使用Stringstring127.0.0.1:6379&gt; PFCOUNT myelemx # 估算myelemx的基数(integer) 11127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s(integer) 1127.0.0.1:6379&gt; PFCOUNT myelemy(integer) 11----------------PFMERGE-----------------------127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemzOK127.0.0.1:6379&gt; PFCOUNT myelemz # 估算基数(integer) 17</code></pre></div><h3 id="4-3-BitMaps-位图"><a href="#4-3-BitMaps-位图" class="headerlink" title="4.3 BitMaps(位图)"></a>4.3 BitMaps(位图)</h3><p>使用位存储，信息状态只有 0 和 1</p><p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p><p>应用场景: 签到统计、状态统计</p><ul><li><code>setbit key offset value</code> 为指定key的offset位设置值</li><li><code>getbit key offset</code> 获取offset位的值</li><li><code>bitcount key [start end]</code> 统计字符串被设置为1的bit数，也可以指定统计范围按字节</li><li><code>bitop operration destkey key[key..]</code> 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</li><li><code>BITPOS key bit [start] [end]</code> 返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">------------setbit--getbit--------------127.0.0.1:6379&gt; setbit sign 0 1 # 设置sign的第0位为 1 (integer) 0127.0.0.1:6379&gt; setbit sign 2 1 # 设置sign的第2位为 1  不设置默认 是0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 1(integer) 0127.0.0.1:6379&gt; type signstring127.0.0.1:6379&gt; getbit sign 2 # 获取第2位的数值(integer) 1127.0.0.1:6379&gt; getbit sign 3(integer) 1127.0.0.1:6379&gt; getbit sign 4 # 未设置默认是0(integer) 0-----------bitcount----------------------------127.0.0.1:6379&gt; BITCOUNT sign # 统计sign中为1的位数(integer) 4</code></pre></div><h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5 事务"></a>5 事务</h2><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p><div class="code-wrapper"><pre><code class="hljs shell">Redis事务本质：一组命令的集合。----------------- 队列 set set set 执行 -------------------事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。一次性顺序性排他性Redis事务没有隔离级别的概念Redis单条命令是保证原子性的，但是事务不保证原子性！</code></pre></div><p>Redis事务操作过程</p><ul><li>开启事务（multi）</li><li>命令入队</li><li>执行事务（exec）</li></ul><p>所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p><h3 id="5-1-正常执行"><a href="#5-1-正常执行" class="headerlink" title="5.1 正常执行"></a>5.1 正常执行</h3><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379&gt; set k1 v1 # 命令入队QUEUED127.0.0.1:6379&gt; set k2 v2 # ..QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; keys *QUEUED127.0.0.1:6379&gt; exec # 事务执行1) OK2) OK3) &quot;v1&quot;4) OK5) 1) &quot;k3&quot;   2) &quot;k2&quot;   3) &quot;k1&quot;</code></pre></div><h3 id="5-2-取消事务-discurd"><a href="#5-2-取消事务-discurd" class="headerlink" title="5.2 取消事务(discurd)"></a>5.2 取消事务(discurd)</h3><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; DISCARD # 放弃事务OK127.0.0.1:6379&gt; EXEC (error) ERR EXEC without MULTI # 当前未开启事务127.0.0.1:6379&gt; get k1 # 被放弃事务中命令并未执行(nil)</code></pre></div><h3 id="5-3-事务错误"><a href="#5-3-事务错误" class="headerlink" title="5.3 事务错误"></a>5.3 事务错误</h3><blockquote><p>  代码语法错误（编译时异常）所有的命令都不执行</p></blockquote><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; error k1 # 这是一条语法错误命令(error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; EXEC(error) EXECABORT Transaction discarded because of previous errors. # 执行报错127.0.0.1:6379&gt; get k1 (nil) # 其他命令并没有被执行</code></pre></div><blockquote><p>  代码逻辑错误 (运行时异常) *<em>其他命令可以正常执行 *</em> &gt;&gt;&gt; 所以不保证事务原子性</p></blockquote><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; INCR k1 # 这条命令逻辑错误（对字符串进行增量）QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; exec1) OK2) OK3) (error) ERR value is not an integer or out of range # 运行时报错4) &quot;v2&quot; # 其他命令正常执行虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</code></pre></div><h3 id="5-4-监控"><a href="#5-4-监控" class="headerlink" title="5.4 监控"></a>5.4 监控</h3><p>悲观锁：</p><ul><li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li></ul><p>乐观锁：</p><ul><li>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><p>使用watch key监控指定数据，相当于乐观锁加锁。</p><blockquote><p>  正常执行</p></blockquote><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set money 100 # 设置余额:100OK127.0.0.1:6379&gt; set use 0 # 支出使用:0OK127.0.0.1:6379&gt; watch money # 监视money (上锁)OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; DECRBY money 20QUEUED127.0.0.1:6379&gt; INCRBY use 20QUEUED127.0.0.1:6379&gt; exec # 监视值没有被中途修改，事务正常执行1) (integer) 802) (integer) 20</code></pre></div><p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）</p><p>我们启动另外一个客户端模拟插队线程。</p><p>线程1：</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; watch money # money上锁OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; DECRBY money 20QUEUED127.0.0.1:6379&gt; INCRBY use 20QUEUED127.0.0.1:6379&gt;     # 此时事务并没有执行</code></pre></div><p>模拟线程插队，线程2：</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; INCRBY money 500 # 修改了线程一中监视的money(integer) 600</code></pre></div><p>回到线程1，执行事务：</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败(nil) # 没有结果，说明事务执行失败127.0.0.1:6379&gt; get money # 线程2 修改生效&quot;600&quot;127.0.0.1:6379&gt; get use # 线程1事务执行失败，数值没有被修改&quot;0&quot;</code></pre></div><p>解锁获取最新值，然后再加锁进行事务。</p><p>unwatch进行解锁。</p><p>注意：每次提交执行exec后都会自动释放锁，不管是否成功</p><h2 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6 Jedis"></a>6 Jedis</h2><p>使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。</p><p>1.导入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入jredis的包--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--fastjson--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.70<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2.编码测试</p><blockquote><p>  连接数据库<br>  操作命令<br>  断开连接</p></blockquote><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPing</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.xx.xxx&quot;</span>, <span class="hljs-number">6379</span>);        jedis.auth(<span class="hljs-string">&quot;p&quot;</span>);        String response = jedis.ping();        System.out.println(response); <span class="hljs-comment">// PONG</span>    &#125;&#125;</code></pre></div><p>输出PONG</p><h3 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h3><p>string、list、set、hash、zset</p><p>所有的api命令，就是我们对应的上面学习的指令，一个都没有变化！</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTX</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);        jedis.flushDB();        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();        jsonObject.put(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);        jsonObject.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;kuangshen&quot;</span>);        <span class="hljs-comment">// 开启事务</span>        Transaction multi = jedis.multi();        String result = jsonObject.toJSONString();        <span class="hljs-comment">// jedis.watch(result)</span>        <span class="hljs-keyword">try</span> &#123;            multi.set(<span class="hljs-string">&quot;user1&quot;</span>,result);            multi.set(<span class="hljs-string">&quot;user2&quot;</span>,result);            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span> ; <span class="hljs-comment">// 代码抛出异常事务，执行失败！</span>            multi.exec(); <span class="hljs-comment">// 执行事务！</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            multi.discard(); <span class="hljs-comment">// 放弃事务</span>            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(jedis.get(<span class="hljs-string">&quot;user1&quot;</span>));            System.out.println(jedis.get(<span class="hljs-string">&quot;user2&quot;</span>));            jedis.close(); <span class="hljs-comment">// 关闭连接</span>        &#125;    &#125;&#125;</code></pre></div><h2 id="7-SpringBoot整合"><a href="#7-SpringBoot整合" class="headerlink" title="7 SpringBoot整合"></a>7 SpringBoot整合</h2><p>SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！</p><p>SpringData 也是和 SpringBoot 齐名的项目！</p><p>说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?</p><p>jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式</p><p>lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式</p><p>源码分析：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span> <span class="hljs-comment">// 我们可以自己定义一个redisTemplate来替换这个默认的！</span><span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;<span class="hljs-comment">// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！</span><span class="hljs-comment">// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt;</span>    RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();    template.setConnectionFactory(redisConnectionFactory);    <span class="hljs-keyword">return</span> template;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">// 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！</span><span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;    StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();    template.setConnectionFactory(redisConnectionFactory);    <span class="hljs-keyword">return</span> template;&#125;</code></pre></div><h3 id="整合测试"><a href="#整合测试" class="headerlink" title="整合测试"></a>整合测试</h3><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1 导入依赖"></a>1 导入依赖</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。</p><p>jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式</p><p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p><p>我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214531573.png" alt></p><p>那么就一定还存在一个RedisProperties类<img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214607475.png" alt></p><p>@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的</p><p>然后再看Lettuce：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214618179.png" alt></p><p>完美生效。</p><p>现在我们回到RedisAutoConfiguratio</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321462777.png" alt></p><p>只有两个简单的Bean</p><ul><li>RedisTemplate</li><li>StringRedisTemplate</li></ul><p>当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。</p><p>在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的</p><p>说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214638238.png" alt></p><p>这是一些基本的配置属性。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214649380.png" alt></p><p>还有一些连接池相关的配置。注意使用时一定使用<strong>Lettuce</strong>的连接池。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214700372.png" alt></p><h4 id="2-编写配置文件"><a href="#2-编写配置文件" class="headerlink" title="2 编写配置文件"></a>2 编写配置文件</h4><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 配置redis</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">39.99.xxx.xx</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span></code></pre></div><h4 id="3-使用RedisTemplate"><a href="#3-使用RedisTemplate" class="headerlink" title="3 使用RedisTemplate"></a>3 使用RedisTemplate</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis02SpringbootApplicationTests</span> </span>&#123;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span>    <span class="hljs-comment">// opsForValue 操作字符串 类似String</span>    <span class="hljs-comment">// opsForList 操作List 类似List</span>    <span class="hljs-comment">// opsForSet</span>    <span class="hljs-comment">// opsForHash</span>    <span class="hljs-comment">// opsForZSet</span>    <span class="hljs-comment">// opsForGeo</span>    <span class="hljs-comment">// opsForHyperLog</span>    <span class="hljs-comment">// 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD</span>    <span class="hljs-comment">// 获取连接对象</span>    <span class="hljs-comment">//RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span>    <span class="hljs-comment">//connection.flushDb();</span>    <span class="hljs-comment">//connection.flushAll();</span>    redisTemplate.opsForValue().set(&amp;quot;mykey&amp;quot;,&amp;quot;kuangshen&amp;quot;);    System.out.println(redisTemplate.opsForValue().get(&amp;quot;mykey&amp;quot;));&#125;&#125;</code></pre></div><h4 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4 测试结果"></a>4 测试结果</h4><p>此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出。这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。</p><p>RedisTemplate内部的序列化配置是这样的</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214746506.png" alt></p><p>默认的序列化器是采用JDK序列化器</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B0.jpg" alt></p><p>后续我们定制RedisTemplate就可以对其进行修改。</p><p>RedisSerializer提供了多种序列化方案：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214818682.png" alt></p><p>我们来编写一个自己的 RedisTemplete</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.config;<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<span class="hljs-comment">// 这是我给大家写好的一个固定模板，大家在企业中，拿去就可以直接使用！</span><span class="hljs-comment">// 自己定义了一个 RedisTemplate</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<span class="hljs-comment">// 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span>RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;String,Object&gt;();template.setConnectionFactory(factory);<span class="hljs-comment">// Json序列化配置</span>Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span>Jackson2JsonRedisSerializer(Object.class);ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);jackson2JsonRedisSerializer.setObjectMapper(om);<span class="hljs-comment">// String 的序列化</span>StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<span class="hljs-comment">// key采用String的序列化方式</span>template.setKeySerializer(stringRedisSerializer);<span class="hljs-comment">// hash的key也采用String的序列化方式</span>template.setHashKeySerializer(stringRedisSerializer);<span class="hljs-comment">// value序列化方式采用jackson</span>template.setValueSerializer(jackson2JsonRedisSerializer);<span class="hljs-comment">// hash的value序列化方式采用jackson</span>template.setHashValueSerializer(jackson2JsonRedisSerializer);template.afterPropertiesSet();<span class="hljs-keyword">return</span> template;&#125;&#125;</code></pre></div><p>所有的redis操作，其实对于java开发人员来说，十分的简单，更重要是要去理解redis的思想和每一种数据结构的用处和作用场景！</p><h2 id="8-Redis-conf"><a href="#8-Redis-conf" class="headerlink" title="8 Redis.conf"></a>8 Redis.conf</h2><ul><li><p>容量单位不区分大小写，G和GB有区别</p></li><li><p>可以使用 include 组合多个配置问题</p></li></ul><h3 id="8-1-网络配置"><a href="#8-1-网络配置" class="headerlink" title="8.1 网络配置"></a>8.1 网络配置</h3><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214912813.png" alt></p><h3 id="8-2-日志"><a href="#8-2-日志" class="headerlink" title="8.2 日志"></a>8.2 日志</h3><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># 日志</span><span class="hljs-comment"># Specify the server verbosity level.</span><span class="hljs-comment"># This can be one of:</span><span class="hljs-comment"># debug (a lot of information, useful for development/testing)</span><span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><span class="hljs-comment"># notice (moderately verbose, what you want in production probably) 生产环境</span><span class="hljs-comment"># warning (only very important / critical messages are logged)</span>loglevel noticelogfile &quot;&quot; # 日志的文件位置名databases 16 # 数据库的数量，默认是 16 个数据库always-show-logo yes # 是否总是显示LOGO</code></pre></div><p>日志输出级别</p><ul><li>debug</li><li>verbose</li><li>notice</li><li>waring</li></ul><h3 id="8-3-持久化规则"><a href="#8-3-持久化规则" class="headerlink" title="8.3 持久化规则"></a>8.3 持久化规则</h3><p>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof redis 是内存数据库，如果没有持久化，那么数据断电及失！</p><p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p><p>持久化方式：</p><ul><li>RDB</li><li>AOF</li></ul><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span>save 900 1<span class="hljs-comment"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span>save 300 10<span class="hljs-comment"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</span>save 60 10000<span class="hljs-comment"># 我们之后学习持久化，会自己定义这个测试！</span>stop-writes-on-bgsave-error yes # 持久化如果出错，是否还需要继续工作！rdbcompression yes # 是否压缩 rdb 文件，需要消耗一些cpu资源！rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验！dir ./ # rdb 文件保存的目录！</code></pre></div><h3 id="8-4-SECURITY-安全"><a href="#8-4-SECURITY-安全" class="headerlink" title="8.4 SECURITY 安全"></a>8.4 SECURITY 安全</h3><p>可以在这里设置redis的密码，默认是没有密码！</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; config get requirepass # 获取redis的密码1) &quot;requirepass&quot;2) &quot;&quot;127.0.0.1:6379&gt; config set requirepass &quot;123456&quot; # 设置redis的密码OK127.0.0.1:6379&gt; config get requirepass # 发现所有的命令都没有权限了(error) NOAUTH Authentication required.127.0.0.1:6379&gt; ping(error) NOAUTH Authentication required.127.0.0.1:6379&gt; auth 123456 # 使用密码进行登录！OK127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;123456&quot;</code></pre></div><h3 id="8-6-限制-CLIENTS（客户端连接相关）"><a href="#8-6-限制-CLIENTS（客户端连接相关）" class="headerlink" title="8.6 限制 CLIENTS（客户端连接相关）"></a>8.6 限制 CLIENTS（客户端连接相关）</h3><div class="code-wrapper"><pre><code class="hljs ini">maxclients 10000 # 设置能连接上redis的最大客户端的数量maxmemory &lt;bytes&gt; # redis 配置最大的内存容量maxmemory-policy noeviction # 内存到达上限之后的处理策略1、volatile-lru：只对设置了过期时间的key进行LRU（默认值）2、allkeys-lru ： 删除lru算法的key3、volatile-random：随机删除即将过期key4、allkeys-random：随机删除5、volatile-ttl ： 删除即将过期的6、noeviction ： 永不过期，返回错误</code></pre></div><h3 id="8-7-APPEND-ONLY-模式-aof配置"><a href="#8-7-APPEND-ONLY-模式-aof配置" class="headerlink" title="8.7 APPEND ONLY 模式 aof配置"></a>8.7 APPEND ONLY 模式 aof配置</h3><div class="code-wrapper"><pre><code class="hljs ini">appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字<span class="hljs-comment"># appendfsync always # 每次修改都会 sync。消耗性能</span>appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！<span class="hljs-comment"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，</span></code></pre></div><h2 id="9-Redis持久化——RDB"><a href="#9-Redis持久化——RDB" class="headerlink" title="9 Redis持久化——RDB"></a>9 Redis持久化——RDB</h2><p>面试和工作，持久化都是重点！<br>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p><h3 id="9-1-什么是RDB（Redis-DataBase）"><a href="#9-1-什么是RDB（Redis-DataBase）" class="headerlink" title="9.1 什么是RDB（Redis DataBase）"></a>9.1 什么是RDB（Redis DataBase）</h3><blockquote><p>  在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；<br>  默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p></blockquote><ul><li>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</li><li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。</li><li>这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！ 有时候在生产环境我们会将这个文件进行备份！</li><li>rdb保存的文件是dump.rdb 都是在我们的配置文件中快照中进行配置的！</li></ul><h3 id="9-2-工作原理"><a href="#9-2-工作原理" class="headerlink" title="9.2 工作原理"></a>9.2 工作原理</h3><p>在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作；</p><ol><li>Redis 调用forks。同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p><h3 id="9-3-触发机制"><a href="#9-3-触发机制" class="headerlink" title="9.3 触发机制"></a>9.3 触发机制</h3><ol><li>save的规则满足的情况下，会自动触发rdb原则</li><li>执行flushall命令，也会触发我们的rdb原则</li><li>退出redis，也会自动产生rdb文件</li></ol><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 save 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p><blockquote><p>  由于 save 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求。</p></blockquote><p>示意图</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215150892.jpg" alt></p><h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><p>flushall 命令也会触发持久化 ；</p><p>触发持久化规则<br>满足配置条件中的触发条件 ；</p><blockquote><p>  可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</p></blockquote><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215205970.png" alt></p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215220858.jpg" alt></p><h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p>bgsave 是异步进行，进行持久化的时候，redis 还可以将继续响应客户端请求 ；</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321523151.jpg" alt></p><p>bgsave和save对比</p><table><thead><tr><th align="left">命令</th><th align="left">save</th><th align="left">bgsave</th></tr></thead><tbody><tr><td align="left">IO类型</td><td align="left">同步</td><td align="left">异步</td></tr><tr><td align="left">阻塞</td><td align="left">是</td><td align="left">是（阻塞发生在fock()，通常非常快）</td></tr><tr><td align="left">复杂度</td><td align="left">O(n)</td><td align="left">O(n)</td></tr><tr><td align="left">优点</td><td align="left">不会消耗额外的内存</td><td align="left">不阻塞客户端命令</td></tr><tr><td align="left">缺点</td><td align="left">阻塞客户端命令</td><td align="left">需要fock子进程，消耗内存</td></tr></tbody></table><h4 id="如果恢复rdb文件！"><a href="#如果恢复rdb文件！" class="headerlink" title="如果恢复rdb文件！"></a>如果恢复rdb文件！</h4><ol><li>只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！</li><li>查看需要存在的位置</li></ol><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; config get dir<span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;dir&quot;</span><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;/usr/local/bin&quot;</span> # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</code></pre></div><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p>  优点：</p></blockquote><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><blockquote><p>  缺点：</p></blockquote><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li><li>fork进程的时候，会占用一定的内容空间。</li></ol><h2 id="10-Redis持久化——AOF"><a href="#10-Redis持久化——AOF" class="headerlink" title="10 Redis持久化——AOF"></a>10 Redis持久化——AOF</h2><p>Append Only File</p><p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍[<img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B005.jpg" alt></p><p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h3 id="10-1-什么是AOF"><a href="#10-1-什么是AOF" class="headerlink" title="10.1 什么是AOF"></a>10.1 什么是AOF</h3><p> 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>appendonly no yes则表示启用AOF</p><p>默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</p><p>如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件</p><p>redis给我们提供了一个工具redis-check-aof –fix</p><div class="code-wrapper"><pre><code class="hljs ini">appendonly yes  # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用appendfilename &quot;appendonly.aof&quot;appendfsync always # 每次修改都会sync 消耗性能appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快</code></pre></div><h3 id="10-2-优缺点"><a href="#10-2-优缺点" class="headerlink" title="10.2 优缺点"></a>10.2 优缺点</h3><p><strong>优点</strong></p><ol><li>每一次修改都会同步，文件的完整性会更加好</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><p><strong>缺点</strong></p><ol><li>相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h3 id="10-3-扩展"><a href="#10-3-扩展" class="headerlink" title="10.3 扩展"></a>10.3 扩展</h3><ol><li>RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li><li>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</li><li>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</li><li>同时开启两种持久化方式<ul><li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li><li>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</li></ul></li><li>性能建议<ul><li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。</li><li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li><li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li></ul></li></ol><h3 id="10-4-如何选择使用哪种持久化方式？"><a href="#10-4-如何选择使用哪种持久化方式？" class="headerlink" title="10.4 如何选择使用哪种持久化方式？"></a>10.4 如何选择使用哪种持久化方式？</h3><ul><li><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p></li><li><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p></li><li><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p></li></ul><h2 id="11-Redis发布订阅"><a href="#11-Redis发布订阅" class="headerlink" title="11 Redis发布订阅"></a>11 Redis发布订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、 微博、关注系统！ Redis 客户端可以订阅任意数量的频道。 订阅/发布消息图： 第一个：消息发送者， 第二个：频道 第三个：消息订阅者！</p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215523258.png" alt></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321553483.png" alt></p><h3 id="11-1-命令"><a href="#11-1-命令" class="headerlink" title="11. 1 命令"></a>11. 1 命令</h3><ul><li><code>PSUBSCRIBE pattern [pattern..]</code> 订阅一个或多个符合给定模式的频道。</li><li><code>PUNSUBSCRIBE pattern [pattern..]</code> 退订一个或多个符合给定模式的频道。</li><li><code>PUBSUB subcommand [argument[argument]]</code> 查看订阅与发布系统状态。</li><li><code>PUBLISH channel message</code> 向指定频道发布消息</li><li><code>SUBSCRIBE channel [channel..]</code> 订阅给定的一个或多个频道。</li><li><code>UNSUBSCRIBE channel [channel..]</code> 退订一个或多个频道</li></ul><p><strong>代码示例</strong></p><div class="code-wrapper"><pre><code class="hljs shell">------------订阅端----------------------127.0.0.1:6379&gt; SUBSCRIBE pncalbl # 订阅sakura频道Reading messages... (press Ctrl-C to quit) # 等待接收消息1) &quot;subscribe&quot; # 订阅成功的消息2) &quot;sakura&quot;3) (integer) 11) &quot;message&quot; # 接收到来自sakura频道的消息 &quot;hello world&quot;2) &quot;sakura&quot;3) &quot;hello world&quot;1) &quot;message&quot; # 接收到来自sakura频道的消息 &quot;hello i am sakura&quot;2) &quot;sakura&quot;3) &quot;hello i am sakura&quot;--------------消息发布端-------------------127.0.0.1:6379&gt; PUBLISH pncalbl &quot;hello world&quot; # 发布消息到sakura频道(integer) 1127.0.0.1:6379&gt; PUBLISH pncalbl &quot;hello i am pncalbl&quot; # 发布消息(integer) 1-----------------查看活跃的频道------------127.0.0.1:6379&gt; PUBSUB channels&quot;sakura&quot;</code></pre></div><h3 id="11-2-原理"><a href="#11-2-原理" class="headerlink" title="11.2 原理"></a>11.2 原理</h3><p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，借此加深对 Redis 的理解。</p><p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321554964.png" alt></p><p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p><h3 id="11-2-缺点"><a href="#11-2-缺点" class="headerlink" title="11.2 缺点"></a>11.2 缺点</h3><ol><li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li><li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</li></ol><h3 id="11-3-应用"><a href="#11-3-应用" class="headerlink" title="11.3 应用"></a>11.3 应用</h3><ol><li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li><li>多人在线聊天室。</li></ol><p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p><h2 id="12-Redis主从复制"><a href="#12-Redis主从复制" class="headerlink" title="12 Redis主从复制"></a>12 Redis主从复制</h2><h3 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h3><ul><li><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p></li><li><p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p></li></ul><h3 id="12-2-作用"><a href="#12-2-作用" class="headerlink" title="12.2 作用"></a>12.2 作用</h3><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li><li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li><li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li></ol><h3 id="12-3-为什么使用集群"><a href="#12-3-为什么使用集群" class="headerlink" title="12.3 为什么使用集群"></a>12.3 为什么使用集群</h3><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p><ol><li><p>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</p></li><li><p>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。</p></li></ol><p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p><p>对于这种场景，我们可以使如下这种架构：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B007.jpg" alt></p><p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！</p><p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</p><p><strong>总结</strong></p><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限。</li></ol><h3 id="12-4-环境配置"><a href="#12-4-环境配置" class="headerlink" title="12.4 环境配置"></a>12.4 环境配置</h3><p>只配置从库，不用配置主库！</p><div class="code-wrapper"><pre><code class="hljs ini">127.0.0.1:6379&gt; info replication<span class="hljs-comment"># Replication</span>role:master # 角色connected_slaves:0 # 从机数量master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcffmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0</code></pre></div><p>复制3个配置文件，然后修改对应的信息</p><ol><li>端口</li><li>pid名字</li><li>log文件名</li><li>dump.rdb名字</li></ol><p>启动单机多服务集群：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215610163.png" alt></p><h4 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h4><p>默认情况下，每台Redis服务器都是主节点；我们一般情况下只用配置从机就好了！</p><p>认老大！一主（79）二从（80，81）</p><p>使用SLAVEOF host port就可以为从机配置主机了。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215637483.png" alt></p><p><strong>说明</strong></p><ul><li><code>SLAVEOF host 6379</code> 找谁当自己的老大！</li><li><code>role:slave</code> # 当前角色是从机</li><li><code>master_host:127.0.0.1</code> # 可以的看到主机的信息</li><li>如果主机有密码，需要设置主机密码</li></ul><p>然后主机上也能看到从机的状态：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215645778.png" alt></p><p><strong>说明</strong></p><ul><li><code>connected_slaves:1</code> # 多了从机的配置</li><li><code>slave0:ip=127.0.0.1,port=6380,state=online,offset=42,lag=1</code> # 多了从机的配置</li></ul><p>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！</p><h3 id="12-5-使用规则"><a href="#12-5-使用规则" class="headerlink" title="12.5 使用规则"></a>12.5 使用规则</h3><ol><li><p>从机只能读，不能写，主机可读可写但是多用于写。</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6381&gt; set name sakura # 从机6381写入失败(error) READONLY You can&#x27;t write against a read only replica.127.0.0.1:6380&gt; set name sakura # 从机6380写入失败(error) READONLY You can&#x27;t write against a read only replica.127.0.0.1:6379&gt; set name sakuraOK127.0.0.1:6379&gt; get name&quot;sakura&quot;</code></pre></div></li><li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p></li><li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p></li><li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p><ul><li>从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机</li><li>使用哨兵模式（自动选举）</li></ul></li><li><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p></li><li><p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么就重新连接！</p></li></ol><h3 id="12-6-复制原理"><a href="#12-6-复制原理" class="headerlink" title="12.6 复制原理"></a>12.6 复制原理</h3><p>Slave 启动成功连接到 master 后会发送一个sync同步命令</p><p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><p><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p><p><strong>增量复制</strong>：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p><p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！</p><h2 id="13-哨兵模式"><a href="#13-哨兵模式" class="headerlink" title="13 哨兵模式"></a>13 哨兵模式</h2><p>（自动选举老大的模式）</p><h3 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h3><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。<strong>能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</strong></p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B008.jpg" alt></p><p>哨兵的作用：</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了<strong>多哨兵模式</strong>。</p><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p><h3 id="13-2-测试"><a href="#13-2-测试" class="headerlink" title="13.2 测试"></a>13.2 测试</h3><ol><li><p>配置哨兵配置文件 sentinel.conf</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># sentinel monitor 被监控的名称 host port 1</span>sentinel monitor myredis 127.0.0.1 6379 1</code></pre></div><p>后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！</p></li><li><p>启动哨兵！</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215752444.png" alt></p></li><li><p>此时哨兵监视着我们的主机6379，当我们断开主机后：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215806972.png" alt></p></li></ol><h3 id="13-3-哨兵模式优缺点"><a href="#13-3-哨兵模式优缺点" class="headerlink" title="13.3 哨兵模式优缺点"></a>13.3 哨兵模式优缺点</h3><p>优点：</p><ol><li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li><li>主从可以切换，故障可以转移，系统的可用性更好</li><li>哨兵模式是主从模式的升级，手动到自动，更加健壮 缺点：</li><li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li></ol><h3 id="13-4-哨兵模式的全部配置"><a href="#13-4-哨兵模式的全部配置" class="headerlink" title="13.4 哨兵模式的全部配置"></a>13.4 哨兵模式的全部配置</h3><p>完整的哨兵模式配置文件 sentinel.conf</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># Example sentinel.conf</span>哨兵sentinel实例运行的端口 默认26379port 26379哨兵sentinel的工作目录dir /tmp哨兵sentinel监控的redis主节点的 ip portmaster-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;sentinel monitor mymaster 127.0.0.1 6379 1当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass mymaster MySUPER--secret-0123passw0rd指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;sentinel down-after-milliseconds mymaster 30000这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;sentinel parallel-syncs mymaster 1故障转移的超时时间 failover-timeout 可以用在以下这些方面：1. 同一个sentinel对同一个master两次failover之间的间隔时间。2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。3.当想要取消一个正在进行的failover所需要的时间。4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了默认三分钟sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;sentinel failover-timeout mymaster 180000SCRIPTS EXECUTION配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。对于脚本的运行结果有以下规则：若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。通知脚本sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;sentinel notification-script mymaster /var/redis/notify.sh客户端重新配置主节点参数脚本当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。以下参数将会在调用脚本时传给脚本:&lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;目前&lt;state&gt;总是“failover”,&lt;role&gt;是“leader”或者“observer”中的一个。参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的这个脚本应该是通用的，能被多次调用，不是针对性的。sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</code></pre></div><h2 id="14-缓存穿透与雪崩"><a href="#14-缓存穿透与雪崩" class="headerlink" title="14 缓存穿透与雪崩"></a>14 缓存穿透与雪崩</h2><h3 id="14-1-缓存穿透（即查询不到）"><a href="#14-1-缓存穿透（即查询不到）" class="headerlink" title="14.1 缓存穿透（即查询不到）"></a>14.1 缓存穿透（即查询不到）</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h4><p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p><h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2 解决方案"></a>2 解决方案</h4><h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215824722.jpg" alt></p><h5 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a><strong>缓存空对象</strong></h5><p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215836317.jpg" alt></p><p>这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p><p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h3 id="14-2-缓存击穿（即量太大，缓存过期）"><a href="#14-2-缓存击穿（即量太大，缓存过期）" class="headerlink" title="14.2 缓存击穿（即量太大，缓存过期）"></a>14.2 缓存击穿（即量太大，缓存过期）</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1 概念"></a>1 概念</h4><ul><li><p>相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p></li><li><p>比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p></li></ul><h4 id="2-解决方案-1"><a href="#2-解决方案-1" class="headerlink" title="2 解决方案"></a>2 解决方案</h4><ol><li><p>设置热点数据永不过期</p><p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p></li><li><p>加互斥锁(分布式锁)</p><p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p></li></ol><h3 id="14-3-缓存雪崩"><a href="#14-3-缓存雪崩" class="headerlink" title="14.3 缓存雪崩"></a>14.3 缓存雪崩</h3><h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1 概念"></a>1 概念</h4><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！</p><p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215850428.jpeg" alt></p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p><h4 id="2-解决方案-2"><a href="#2-解决方案-2" class="headerlink" title="2 解决方案"></a>2 解决方案</h4><blockquote><p>  redis高可用</p></blockquote><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p><blockquote><p>  限流降级</p></blockquote><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><blockquote><p>  数据预热</p></blockquote><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/DB/">DB</category>
      
      
      
      <comments>https://pncalbl.github.io/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MongoDB 学习</title>
      <link>https://pncalbl.github.io/2021/05/01/MongoDB%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/01/MongoDB%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 30 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;MongoDB-学习&quot;&gt;&lt;a href=&quot;#MongoDB-学习&quot; class=&quot;headerlink&quot; title=&quot;MongoDB 学习&quot;&gt;&lt;/a&gt;MongoDB 学习&lt;/h1&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="MongoDB-学习"><a href="#MongoDB-学习" class="headerlink" title="MongoDB 学习"></a>MongoDB 学习</h1>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/DB/">DB</category>
      
      
      <category domain="https://pncalbl.github.io/tags/MongoDB/">MongoDB</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/01/MongoDB%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WSL和VM不兼容</title>
      <link>https://pncalbl.github.io/2021/05/01/WSL%E5%92%8CVM/</link>
      <guid>https://pncalbl.github.io/2021/05/01/WSL%E5%92%8CVM/</guid>
      <pubDate>Fri, 30 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭&quot;&gt;&lt;a href=&quot;#WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭&quot; class=&quot;headerlink&quot; title=&quot;WSL依赖于hyper-v必须开启，而VMw</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭"><a href="#WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭" class="headerlink" title="WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭"></a>WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭</h3><ul><li>CMD管理员模式启动，输入</li></ul><div class="code-wrapper"><pre><code class="hljs arduino">bcdedit /set hypervisorlaunchtype <span class="hljs-keyword">auto</span></code></pre></div><ul><li>开启，则可以使用WSL</li></ul><ul><li>CMD管理员模式启动，输入</li></ul><div class="code-wrapper"><pre><code class="hljs cmake">bcdedit /<span class="hljs-keyword">set</span> hypervisorlaunchtype <span class="hljs-keyword">off</span></code></pre></div><ul><li>关闭，则可以使用VMware</li></ul><p>注意：不管是开还是关都需要重启电脑</p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Linux/">Linux</category>
      
      
      <category domain="https://pncalbl.github.io/tags/WSL/">WSL</category>
      
      <category domain="https://pncalbl.github.io/tags/VM/">VM</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/01/WSL%E5%92%8CVM/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Dubbo 学习</title>
      <link>https://pncalbl.github.io/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 30 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Dubbo-学习&quot;&gt;&lt;a href=&quot;#Dubbo-学习&quot; class=&quot;headerlink&quot; title=&quot;Dubbo 学习&quot;&gt;&lt;/a&gt;Dubbo 学习&lt;/h1&gt;&lt;h2 id=&quot;1-分布式简要说明&quot;&gt;&lt;a href=&quot;#1-分布式简要说明&quot; class=&quot;he</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Dubbo-学习"><a href="#Dubbo-学习" class="headerlink" title="Dubbo 学习"></a>Dubbo 学习</h1><h2 id="1-分布式简要说明"><a href="#1-分布式简要说明" class="headerlink" title="1 分布式简要说明"></a>1 分布式简要说明</h2><h3 id="1-1-什么是分布式？"><a href="#1-1-什么是分布式？" class="headerlink" title="1.1 什么是分布式？"></a>1.1 什么是分布式？</h3><ul><li><p>Dubbo是用于分布式系统的框架所以我们要先了解什么是分布式<br>分布式系统是若干独立 计算机的集合，这些计算机对于用户来说就像单个相关系统。</p></li><li><p>老式系统(单一应用架构)就是把一个系统，统一放到一个服务器当中然后每一个服务器上放一个系统，如果说要更新代码的话，每一个服务器上的系统都要重新去部署十分的麻烦。</p></li></ul><ul><li>而分布式系统就是将一个完整的系统拆分成多个不同的服务，然后在将每一个服务单独的放到一个服务器当中。(三个臭皮匠赛过诸葛亮)</li></ul><h3 id="1-2-RPC-简介"><a href="#1-2-RPC-简介" class="headerlink" title="1.2 RPC 简介"></a>1.2 RPC 简介</h3><ul><li><p><strong>分布式应用架构(远程过程调用)</strong>：当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</p></li><li><p>什么叫RPC</p><ul><li>RPC [ Remote Procedure Call]是指远程过程调用，是一种进程问通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间(通常是共享网络的另一台机器上)的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</li><li>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</li></ul></li><li><p><strong>RPC工作原理</strong></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/2020061015260046.png" alt="img"></p><ol><li>Client像调用本地服务似的调用远程服务；</li><li>Client stub接收到调用后，将方法、参数序列化</li><li>客户端通过sockets将消息发送到服务端</li><li>Server stub 收到消息后进行解码（将消息对象反序列化）</li><li>Server stub 根据解码结果调用本地的服务</li><li>本地服务执行(对于服务端来说是本地执行)并将结果返回给Server stub</li><li>Server stub将返回结果打包成消息（将结果消息对象序列化）</li><li>服务端通过sockets将消息发送到客户端</li><li>Client stub接收到结果消息，并进行解码（将结果消息发序列化）</li><li>客户端得到最终结果。</li></ol></li><li><p><strong>RPC 调用分以下两种：</strong></p><ul><li><strong>同步调用</strong>：客户方等待调用执行完成并返回结果。</li><li><strong>异步调用</strong>：客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。</li></ul></li><li><p><strong>RPC步骤解析</strong></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610174636250.png" alt="在这里插入图片描述"></p></li><li><p><strong>SOA</strong><br><strong>流动计算架构</strong>：在分布式应用架构的基础上增加了一个<strong>调度、治理中心</strong>基于访问压力实时管理集群容量、提高集群的利用率，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键 <strong>(不浪费计算机资源)</strong></p></li></ul><h2 id="2-Dubbo核心概念"><a href="#2-Dubbo核心概念" class="headerlink" title="2 Dubbo核心概念"></a>2 Dubbo核心概念</h2><p>Dubbo官网: <a href="http://dubbo.apache.org/en-us/index.html">http://dubbo.apache.org/en-us/index.html</a></p><p>Dubbo 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，服务自动注册和发现。分布式系统是将一个系统拆分为多个不同的服务。</p><h2 id="3-Dubbo特性一览"><a href="#3-Dubbo特性一览" class="headerlink" title="3 Dubbo特性一览"></a>3 Dubbo特性一览</h2><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610170234620.png" alt="img"></p><h3 id="Dubbo设计架构"><a href="#Dubbo设计架构" class="headerlink" title="Dubbo设计架构"></a>Dubbo设计架构</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610170317960.png" alt="在这里插入图片描述"></p><p>该图来自Dubbo官网，描述了服务注册中心、服务提供方、服务消费方、服务监控中心之间的调用关系。</p><ul><li><strong>服务提供者</strong>（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</li><li><strong>服务消费者</strong>（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li><strong>注册中心</strong>（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li><strong>监控中心</strong>（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><h2 id="4-Dubbo的特性解析"><a href="#4-Dubbo的特性解析" class="headerlink" title="4 Dubbo的特性解析"></a>4 Dubbo的特性解析</h2><ul><li><p>服务注册中心</p><ul><li>相比Hessian类RPC框架，Dubbo有自己的服务中心， 写好的服务可以注册到服务中心， 客户端从服务中心寻找服务，然后再到相应的服务提供者机器获取服务。通过服务中心可以实现集群、负载均衡、高可用(容错) 等重要功能。</li><li>服务中心一般使用zookeeper实现，也有redis和其他一些方式。以使用zookeeper作为服务中心为例，服务提供者启动后会在zookeeper的/dubbo节点下创建提供的服务节点，包含服务提供者ip、port等信息。服务提供者关闭时会从zookeeper中移除对应的服务。</li><li>服务使用者会从注册中心zookeeper中寻找服务，同一个服务可能会有多个提供者，Dubbo会帮我们找到合适的服务提供者，也就是针对服务提供者的负载均衡。</li></ul></li><li><p>负载均衡</p><p>当同一个服务有多个提供者在提供服务时，客户端如何正确的选择提供者实 现负载均衡呢？dubbo也给我们提供了几种方案：</p><ul><li>random 随机选提供者，并可以给提供者设置权重</li><li>roundrobin 轮询选择提供者</li><li>leastactive 最少活跃调用数，相同活跃数的随机，活跃数：指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li><li>consistenthash 一致性hash，相同参数的请求发到同一台机器上。</li></ul></li><li><p>简化测试，允许直连提供者<br>在开发阶段为了方便测试，通常系统客户端能指定调用某个服务提供者，那么可以在引用服务时加一个url参数去指定服务提供者。 配置如下</p><div class="code-wrapper"><pre><code class="hljs dubbo">&lt;dubbo:reference id&#x3D;&quot;xxxService&quot;interface&#x3D;&quot;com.alibaba.xxx.XxxService&quot;url&#x3D;&quot;dubbo:&#x2F;&#x2F;localhost:20890&quot;&#x2F;&gt;</code></pre></div></li><li><p>服务版本，服务分组<br>在Dubbo配置文件中可以通过制定版本实现连接制定提供者，也就是通过服务版本可以控制服务的不兼容升级；当同一个服务有多种实现时，可以使用服务分组进行区分。</p></li></ul><h2 id="5-Dubbo-Zookeeper"><a href="#5-Dubbo-Zookeeper" class="headerlink" title="5 Dubbo + Zookeeper"></a>5 Dubbo + Zookeeper</h2><h3 id="5-1-搭建zookeeper注册中心环境"><a href="#5-1-搭建zookeeper注册中心环境" class="headerlink" title="5.1 搭建zookeeper注册中心环境"></a>5.1 搭建zookeeper注册中心环境</h3><p>Dubbo官方文档: <a href="http://dubbo.apache.org/en-us/docs/user/quick-start.html">http://dubbo.apache.org/en-us/docs/user/quick-start.html</a><br>在zookeeper官网下载zookeeper<br><a href="http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/">http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/</a></p><ul><li>在bin文件下，启动zkServer.cmd会有报错，处理需要在condif文件中将zoo_sample.cfg文件复制一份，将名字改为zoo.cfg。<br>在zookeeper的文件夹下创建data文件夹，打开zoo.cfg，修改datadir，将dataDir数据保存为我们自定义的文件中(此步骤可省略)</li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610173149263.png" alt="img"></p><ul><li>配置完毕后，我们再次在conf下启动zkServer.cmd，这次可以成功启动</li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610173356318.png" alt="img"></p><ul><li>继续运行zkCli.cmd，可以连接到zookeeper的服务器。</li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610173644649.png" alt="img"></p><ul><li>此时，我们zookeeper的注册中心及环境以及搭建完毕。</li></ul><h3 id="5-2-zookeeper监控中心的配置"><a href="#5-2-zookeeper监控中心的配置" class="headerlink" title="5.2 zookeeper监控中心的配置"></a>5.2 zookeeper监控中心的配置</h3><ul><li><p>下载dubbo-admin</p><p>dubbo-admin下载地址 ：<a href="https://github.com/apache/dubbo-admin/tree/master">https://github.com/apache/dubbo-admin/tree/master</a></p></li><li><p>解压后进入目录修改指定zookeeper地址<br>进入如下地址：dubbo-admin-master\dubbo-admin\src\main\resources\application.properties”<br>将zookeeper的监控中心的地址配置为本地端口</p><div class="code-wrapper"><pre><code class="hljs dubbo">#注册中心的地址dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181</code></pre></div><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610175513207.png" alt="在这里插入图片描述"></p></li><li><p>配置完毕后，我们在dubo-zookeeper\dubbo-admin-master\dubbo-admin文件夹下cmd打包测试下。</p><div class="code-wrapper"><pre><code class="hljs dubbo">mvn clean package</code></pre></div><p>在target文件中打包完成的jar包</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610175909584.png" alt="img"></p></li></ul><ul><li><p>cmd命令 <code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</code>运行打包好的jar包<br>启动成功后，可以看到一个7001的端口</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610180201513-1620378376190.png" alt="在这里插入图片描述"></p></li><li><p>此时我们的zookeeper的服务都为启动状态，在浏览器中访问 localhost:7001，访问到注册中心，输入账号密码root。</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610180358177.png" alt="img"></p></li></ul><blockquote><p>  此时，我们zookeeper监控中心的配置完成。注意，要访问到监控中心，一定要启动zookeeper注册中心的启动类</p></blockquote><h2 id="6-Dubbo环境搭建，创建提供者、消费者项目"><a href="#6-Dubbo环境搭建，创建提供者、消费者项目" class="headerlink" title="6 Dubbo环境搭建，创建提供者、消费者项目"></a>6 Dubbo环境搭建，创建提供者、消费者项目</h2><p>基于以下图实现服务 提供者、消费者</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610195718980.png" alt="在这里插入图片描述"></p><h3 id="6-1-Dubbo服务提供者和消费者接口搭建"><a href="#6-1-Dubbo服务提供者和消费者接口搭建" class="headerlink" title="6.1 Dubbo服务提供者和消费者接口搭建"></a>6.1 Dubbo服务提供者和消费者接口搭建</h3><p><strong>创建Maven项目=&gt; <code>user-service-provider</code> 服务提供者</strong></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509014131477.png" alt="image-20210509014131477"></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509014149815.png" alt="image-20210509014149815"></p><ul><li><p><strong>UserAddress</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAddress</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String userAddress; <span class="hljs-comment">//用户地址</span>    <span class="hljs-keyword">private</span> String userId; <span class="hljs-comment">//用户id</span>    <span class="hljs-keyword">private</span> String consignee; <span class="hljs-comment">//收货人</span>    <span class="hljs-keyword">private</span> String phoneNum; <span class="hljs-comment">//电话号码</span>    <span class="hljs-keyword">private</span> String isDefault; <span class="hljs-comment">//是否为默认地址    Y-是     N-否</span>    <span class="hljs-comment">//get     set </span>    <span class="hljs-comment">//有参构造  无参构造</span>  &#125;</code></pre></div></li><li><p><strong>UserService</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//用户服务</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 按照用户id返回所有的收货地址</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> userId</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span></span>;&#125;</code></pre></div></li><li><p><strong>UserServiceImpl</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span> </span>&#123;UserAddress address1 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;河南省郑州巩义市宋陵大厦2F&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;安然&quot;</span>, <span class="hljs-string">&quot;150360313x&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>);UserAddress address2 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;北京市昌平区沙河镇沙阳路&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;情话&quot;</span>, <span class="hljs-string">&quot;1766666395x&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>);<span class="hljs-keyword">return</span> Arrays.asList(address1,address2);&#125;&#125;</code></pre></div></li></ul><p><strong>创建Maven项目=&gt; <code>order-service-consumer</code> 服务消费者(订单服务)</strong></p><ul><li><p><strong>OrderService</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化订单</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userID</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span></span>;&#125;</code></pre></div></li><li><p><strong>OrderServiceImpl</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span> </span>&#123;        <span class="hljs-comment">//查询用户的收货地址</span>    &#125;&#125;</code></pre></div></li></ul><p><strong>因服务消费者要拿到提供者的方法</strong></p><p>将服务提供者中的实体类及 UserService 复制到当前消费者同级文件中。</p><ul><li><p><strong>OrderServiceImpl</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-keyword">public</span> UserService userService;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span> </span>&#123;        <span class="hljs-comment">//查询用户的收货地址</span>        List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList(userID);        System.out.println(userAddressList);    &#125;&#125;</code></pre></div></li></ul><p>此时我们调用 userservice 肯定是要报错的。这种面向接口的方式，我们这里只是调到了接口，而接口实际是在另外一个项目中，如果我们两个项目工程都创建共同的实体类，太过于麻烦了，我们可以将服务接口，服务模型等单独放在一个项目中，更为方便调用。</p><p><strong>创建Maven项目=&gt; gmail-interface 用于存放共同的服务接口</strong></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200611154037439.png" alt="在这里插入图片描述"></p><p>将 提供者 和 消费者 项目中的所有实体类复制到当前相关的文件包下，删除原有的实体类包及service包，也就是将实体类及service放在了当前公共的项目中。</p><p>把服务提供者和消费者项目中引入以下依赖，引入后项目不在报错.</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lemon.gmail<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmail-interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="6-2-服务提供者配置及测试"><a href="#6-2-服务提供者配置及测试" class="headerlink" title="6.2 服务提供者配置及测试"></a>6.2 服务提供者配置及测试</h3><p>在 <code>user-service-provider</code> 服务提供者项目中引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--注册中心是 zookeeper，引入zookeeper客户端--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>在<code>resource</code>文件中创建<code>provider.xml</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user-service-provider&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- 2、指定注册中心的位置 --&gt;</span><span class="hljs-comment">&lt;!-- &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;zookeeper&quot;</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20882&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--4、暴露服务 让别人调用 ref指向服务的真正实现对象--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.lemon.gmail.service.UserService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span>    <span class="hljs-comment">&lt;!--服务的实现--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userServiceImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.lemon.gmail.service.impl.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>编写一个<code>ProviderApplication</code>启动类程序，运行测试配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        ClassPathXmlApplicationContext applicationContext= <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;provider.xml&quot;</span>);        applicationContext.start();        System.inread();    &#125;&#125;</code></pre></div><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509015143656.png" alt="image-20210509015143656"></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509015205821.png" alt="image-20210509015205821"></p><h3 id="6-3-服务消费者配置及测试"><a href="#6-3-服务消费者配置及测试" class="headerlink" title="6.3 服务消费者配置及测试"></a>6.3 服务消费者配置及测试</h3><p>在 <code>order-service-consumer</code> 服务消费者项目中引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--注册中心是 zookeeper，引入zookeeper客户端--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>创建<code>consumer.xml</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.pnca.gmall&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order-service-consumer&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.pnca.gmall.service.UserService&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>把当前<code>OrderServiceImpl</code>实现类中加上注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> UserService userService;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span> </span>&#123;        <span class="hljs-comment">//查询用户的收货地址</span>        List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList(userID);                <span class="hljs-comment">//为了直观的看到得到的数据，以下内容也可不写</span>        System.out.println(<span class="hljs-string">&quot;当前接收到的userId=&gt; &quot;</span>+userID);        System.out.println(<span class="hljs-string">&quot;**********&quot;</span>);        System.out.println(<span class="hljs-string">&quot;查询到的所有地址为：&quot;</span>);        <span class="hljs-keyword">for</span> (UserAddress userAddress : userAddressList) &#123;            <span class="hljs-comment">//打印远程服务地址的信息</span>            System.out.println(userAddress.getUserAddress());        &#125;            &#125;&#125;</code></pre></div><p>编写一个<code>ConsumerApplication</code>启动类程序，运行测试配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ClassPathXmlApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;consumer.xml&quot;</span>);        OrderService orderService = applicationContext.getBean(OrderService.class);        <span class="hljs-comment">//调用方法查询出数据</span>        orderService.initOrder(<span class="hljs-string">&quot;1&quot;</span>);        System.out.println(<span class="hljs-string">&quot;调用完成...&quot;</span>);    System.in.read();    &#125;&#125;</code></pre></div><p>注意：消费者的运行测试需要先启动提供者。<br>启动服务提供者、消费者。及zookeeper的和dubbo-admin，查看监控信息。<br>localhost:7001</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512202425183.png" alt="image-20210512202425183"></p><h2 id="7-dubbo-monitor-simple-简易监控中心"><a href="#7-dubbo-monitor-simple-简易监控中心" class="headerlink" title="7 dubbo-monitor-simple 简易监控中心"></a>7 dubbo-monitor-simple 简易监控中心</h2><ul><li><p>进入dubbo-monitor-simple文件，执行cmd命令，mvn package打包成jar包</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612083732691.png" alt="在这里插入图片描述"></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200612084630745.png" alt="在这里插入图片描述"></p><ul><li><p>将 <code>dubbo-monitor-simple-2.0.0-assembly.tar.gz</code> 压缩包解压至当前文件夹，解压后config文件查看properties的配置是否是本地的zookeeper。</p></li><li><p>打开解压后的 <code>assembly.bin</code> 文件，<code>start.bat</code> 启动<code>dubbo-monitor-simple监控中心</code></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512203200864.png" alt="image-20210512203200864"></p><p>在浏览器 <code>localhost:8080</code> ，可以看到一个监控中心。<br>在服务提供者和消费者的xml中配置以下内容，再次启动服务提供和消费者启动类。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo-monitor-simple监控中心发现的配置--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:monitor</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;registry&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:monitor</span>&gt;</span><span class="hljs-comment">&lt;!--&lt;dubbo:monitor address=&quot;127.0.0.1:7070&quot;&gt;&lt;/dubbo:monitor&gt;--&gt;</span></code></pre></div><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512203449002.png" alt="image-20210512203449002"></p></li></ul><h2 id="8-Dubbo-与-springboot-整合"><a href="#8-Dubbo-与-springboot-整合" class="headerlink" title="8 Dubbo 与 springboot 整合"></a>8 Dubbo 与 springboot 整合</h2><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612152443622.png" alt="在这里插入图片描述"></p><h3 id="8-1-boot-user-service-provider-服务提供者"><a href="#8-1-boot-user-service-provider-服务提供者" class="headerlink" title="8.1 boot-user-service-provider 服务提供者"></a>8.1 boot-user-service-provider 服务提供者</h3><ul><li><p><strong>创建 springboot 项目 <code>boot-user-service-provider</code></strong> 服务提供者</p></li><li><p>导入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca.gmall<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmall_interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>把 <code>user-service-provider</code> 中的 service 拿到此项目中。注意，以此方法为返回的需要更改 interface 包中的 void为 List<UserAddress></UserAddress></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>    <span class="hljs-comment">// dubbo暴露服务</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">&quot;UserServiceImpl..3.....&quot;</span>);UserAddress address1 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;北京市昌平区宏福科技园综合楼3层&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;李老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>);UserAddress address2 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;深圳市宝安区西部硅谷大厦B座3层（深圳分校）&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;王老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>);<span class="hljs-keyword">return</span> Arrays.asList(address1, address2);&#125;&#125;</code></pre></div></li><li><p>配置 <code>application.properties</code></p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">boot_user_service_provider</span><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">127.0.0.1:2181</span><span class="hljs-meta">dubbo.registry.protocol</span>=<span class="hljs-string">zookeeper</span><span class="hljs-meta">dubbo.protocol.name</span>=<span class="hljs-string">dubbo</span><span class="hljs-meta">dubbo.protocol.port</span>=<span class="hljs-string">20880</span><span class="hljs-comment">#连接监控中心</span><span class="hljs-meta">dubbo.monitor.protocol</span>=<span class="hljs-string">registry</span></code></pre></div></li><li><p>BootUserServiceProviderApplication启动类配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableDubbo</span>    <span class="hljs-comment">//开启基于注解的dubbo功能</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootUserServiceProviderApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(BootUserServiceProviderApplication.class, args);&#125;&#125;</code></pre></div></li><li><p>启动注册中心，启动当前服务提供者，可以在浏览器看到一个服务提供者。</p></li></ul><h3 id="8-2-boot-order-service-consumer-服务消费者"><a href="#8-2-boot-order-service-consumer-服务消费者" class="headerlink" title="8.2 boot-order-service-consumer 服务消费者"></a>8.2 boot-order-service-consumer 服务消费者</h3><ul><li><p><strong>创建springboot项目 <code>boot-order-service-consumer</code></strong> 服务消费者</p></li><li><p>导入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca.gmall<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmall_interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>把 <code>order-service-consumer</code> 中的 service 拿到此项目中。注意，以此方法为返回的需要更改 interface 包中的 void 为 List<UserAddress></UserAddress></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;<span class="hljs-comment">// @Autowired</span><span class="hljs-meta">@Reference</span>UserService userService;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">initOrder</span><span class="hljs-params">(String userId)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">&quot;用户id：&quot;</span> + userId);<span class="hljs-comment">//1、查询用户的收货地址</span>List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId);<span class="hljs-keyword">for</span> (UserAddress userAddress : addressList) &#123;System.out.println(userAddress);&#125;<span class="hljs-keyword">return</span> addressList;&#125;&#125;</code></pre></div></li><li><p>创建 OrderController 控制器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;<span class="hljs-meta">@Autowired</span>OrderService orderService;<span class="hljs-meta">@ResponseBody</span><span class="hljs-meta">@RequestMapping(&quot;/initOrder&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">initOrder</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;uid&quot;)</span> String userId)</span> </span>&#123;<span class="hljs-keyword">return</span> orderService.initOrder(userId);&#125;&#125;</code></pre></div></li><li><p>配置 <code>application.properties</code></p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">boot_order_service_consumer</span><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">zookeeper://127.0.0.1:2181</span><span class="hljs-meta">dubbo.registry.protocol</span>=<span class="hljs-string">zookeeper</span><span class="hljs-comment">#连接监控中心</span><span class="hljs-meta">dubbo.monitor.protocol</span>=<span class="hljs-string">registry</span></code></pre></div></li><li><p>BootOrderServiceConsumerApplication启动类配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableDubbo</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootOrderServiceConsumerApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(BootOrderServiceConsumerApplication.class, args);&#125;&#125;</code></pre></div></li><li><p>配置完毕，此时启动zookeeper注册中心及监控。<br>启动springboot配置的服务提供者和消费者<br>在浏览器输入 localhost:7001 查看结果</p></li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512215907361.png" alt="image-20210512215907361"></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512215927876.png" alt="image-20210512215927876"></p><p>duboo的springboot整合配置完成。</p><h2 id="9-Dubbo-配置"><a href="#9-Dubbo-配置" class="headerlink" title="9 Dubbo 配置"></a>9 Dubbo 配置</h2><p>dubbo配置官网参考：<a href="http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html">http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html</a></p><h3 id="9-1-配置原则"><a href="#9-1-配置原则" class="headerlink" title="9.1 配置原则"></a>9.1 配置原则</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612152343133.png" alt="在这里插入图片描述"></p><ul><li>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</li><li>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</li><li>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</li></ul><h3 id="9-2-启动时检查"><a href="#9-2-启动时检查" class="headerlink" title="9.2 启动时检查"></a>9.2 启动时检查</h3><ul><li>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=“true”。</li></ul><ul><li>可以通过 check=“false” 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</li></ul><ul><li><p>另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=“false”，总是会返回引用，当服务恢复时，能自动连上。</p></li><li><p>以<code>order-service-consumer</code>消费者为例，在consumer.xml中添加配置</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置当前消费者的统一规则,当前所有的服务都不启动时检查--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:consumer</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:consumer</span>&gt;</span></code></pre></div></li><li><p>添加后，即使服务提供者不启动，启动当前的消费者，也不会出现错误。</p></li></ul><h3 id="9-3-全局超时配置"><a href="#9-3-全局超时配置" class="headerlink" title="9.3 全局超时配置"></a>9.3 全局超时配置</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--全局超时配置--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:provider</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span> /&gt;</span>指定接口以及特定方法超时配置<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:provider</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.foo.BarService&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;2000&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sayHello&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;3000&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:provider</span>&gt;</span></code></pre></div><p><strong>配置原则</strong></p><p>dubbo推荐在Provider上尽量多配置Consumer端属性</p><div class="code-wrapper"><pre><code class="hljs plain">1、作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等2、在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</code></pre></div><p>配置的覆盖规则：</p><ul><li><p>方法级配置别优于接口级别，即小Scope优先</p></li><li><p>Consumer端配置 优于 Provider配置 优于 全局配置，</p></li><li><p>最后是Dubbo Hard Code的配置值（见配置文档）</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612160853853.png" alt="在这里插入图片描述"></p><p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html">http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html</a><br>在服务提供者中复制多个impl。起不同的名字</p></li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612163440781.png" alt="在这里插入图片描述"></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612163456305.png" alt="在这里插入图片描述"></p><p>配置多个文件的路径及信息。<br>服务消费者调用时，可自由配置版本</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612163603598.png" alt="在这里插入图片描述"></p><h3 id="9-4-dubbo与springboot整合的三种方式"><a href="#9-4-dubbo与springboot整合的三种方式" class="headerlink" title="9.4 dubbo与springboot整合的三种方式"></a>9.4 dubbo与springboot整合的三种方式</h3><ul><li><p>将服务提供者注册到注册中心(如何暴露服务)</p><ul><li>导入Dubbo的依赖 和 zookeeper 客户端</li></ul></li><li><p>让服务消费者去注册中心订阅服务提供者的服务地址<br>Springboot与Dubbo整合的三种方式</p><ol><li><p>导入dubbo-starter。在application.properties配置属性，使用@Service【暴露服务】，使用@Reference【引用服务】</p></li><li><p>保留Dubbo 相关的xml配置文件</p><p> 导入dubbo-starter，使用@ImportResource导入Dubbo的xml配置文件</p></li><li><p>使用 注解API的方式</p><p>将每一个组件手动配置到容器中,让dubbo来扫描其他的组件</p></li></ol></li></ul><h2 id="10-高可用"><a href="#10-高可用" class="headerlink" title="10 高可用"></a>10 高可用</h2><p>zookeeper宕机与dubbo直连<br>现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。<br>原因：</p><p>健壮性</p><ul><li>监控中心宕掉不影响使用，只是丢失部分采样数据</li><li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li><li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li><li>高可用：通过设计，减少系统不能提供服务的时间；</li></ul><h3 id="集群下dubbo负载均衡配置"><a href="#集群下dubbo负载均衡配置" class="headerlink" title="集群下dubbo负载均衡配置"></a>集群下dubbo负载均衡配置</h3><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p><p><strong>负载均衡策略如下</strong></p><ul><li><p><strong>Random LoadBalance 基于权重的随机负载均衡机制</strong></p><p>随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p></li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612180908789.png" alt="在这里插入图片描述"></p><ul><li><p><strong>RoundRobin LoadBalance 基于权重的轮询负载均衡机制</strong></p><p>轮循，按公约后的权重设置轮循比率。 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612180928170.png" alt="在这里插入图片描述"></p></li></ul><ul><li><p><strong>LeastActive LoadBalance最少活跃数负载均衡机制</strong></p><p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612180951468.png" alt="在这里插入图片描述"></p></li></ul><ul><li><p><strong>ConsistentHash LoadBalance一致性hash 负载均衡机制</strong></p><ul><li>一致性 Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li><li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a> </li><li>缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=”hash.arguments” value=”0,1” /&gt; 缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=”hash.nodes” value=”320” /&gt;</li></ul></li></ul><div class="code-wrapper"><pre><code>![在这里插入图片描述](Dubbo学习/20200612181007825.png)</code></pre></div><h2 id="11-整合-hystrix-，服务熔断与降级处理"><a href="#11-整合-hystrix-，服务熔断与降级处理" class="headerlink" title="11 整合 hystrix ，服务熔断与降级处理"></a>11 整合 hystrix ，服务熔断与降级处理</h2><h3 id="11-1-服务降级"><a href="#11-1-服务降级" class="headerlink" title="11.1 服务降级"></a>11.1 服务降级</h3><p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</strong><br>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。<br>向注册中心写入动态配置覆盖规则：</p><div class="code-wrapper"><pre><code class="hljs java">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="hljs-string">&quot;zookeeper://10.20.153.10:2181&quot;</span>));registry.register(URL.valueOf(<span class="hljs-string">&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;</span>));</code></pre></div><p>其中：<br>mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时，对调用方的影响。<br>还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时，对调用方的影响。</p><h3 id="11-2-集群容错"><a href="#11-2-集群容错" class="headerlink" title="11.2 集群容错"></a>11.2 集群容错</h3><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><ul><li><p><strong>集群容错模式</strong></p><ul><li><p><strong>Failover Cluster</strong><br>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。</p><p>重试次数配置如下：<br>&lt;dubbo:service retries=“2” /&gt;<br>或<br>&lt;dubbo:reference retries=“2” /&gt;<br>或<br>dubbo:reference<br>&lt;dubbo:method name=“findFoo” retries=“2” /&gt;<br></p></li><li><p><strong>Failfast Cluster</strong><br>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p></li><li><p><strong>Failsafe Cluster</strong><br>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p></li><li><p><strong>Failback Cluster</strong><br>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p></li><li><p><strong>Forking Cluster</strong><br>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</p></li><li><p><strong>Broadcast Cluster</strong><br>广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p></li></ul></li><li><p><strong>集群模式配置</strong><br>按照以下示例在服务提供方和消费方配置集群模式<br>&lt;dubbo:service cluster=“failsafe” /&gt;<br>或<br>&lt;dubbo:reference cluster=“failsafe” /&gt;</p></li></ul><h3 id="11-3-整合hystrix"><a href="#11-3-整合hystrix" class="headerlink" title="11.3 整合hystrix"></a>11.3 整合hystrix</h3><p>服务熔断错处理配置参考=&gt; <a href="https://www.cnblogs.com/xc-xinxue/p/12459861.html">https://www.cnblogs.com/xc-xinxue/p/12459861.html</a></p><p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能</p><ul><li><p><strong>配置spring-cloud-starter-netflix-hystrix</strong></p></li><li><p>spring boot官方提供了对<strong>hystrix</strong>的集成，直接在pom.xml里加入依赖：</p><div class="code-wrapper"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>然后在Application类上增加<strong>@EnableHystrix</strong>来启用hystrix starter：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableHystrix</span> <span class="hljs-comment">//开启服务容错功能</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderApplication</span> </span>&#123;...启动方法&#125;</code></pre></div></li><li><p><strong>配置Provider端</strong></p><p>在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>    <span class="hljs-comment">// dubbo暴露服务</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<span class="hljs-meta">@HystrixCommand</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">&quot;UserServiceImpl..3.....&quot;</span>);UserAddress address1 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;北京市昌平区宏福科技园综合楼3层&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;李老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>);UserAddress address2 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;深圳市宝安区西部硅谷大厦B座3层（深圳分校）&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;王老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>);<span class="hljs-keyword">if</span> (Math.random() &gt; <span class="hljs-number">0.5</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();&#125;<span class="hljs-keyword">return</span> Arrays.asList(address1, address2);&#125;&#125;</code></pre></div></li><li><p><strong>配置Consumer端</strong><br>对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod = “reliable”的调用里。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Reference(version = &quot;1.0.0&quot;)</span>    <span class="hljs-keyword">private</span> HelloService demoService;    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;reliable&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doSayHello</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> demoService.sayHello(name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reliable</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hystrix fallback value&quot;</span>;    &#125;</code></pre></div></li><li><p>测试</p><ul><li><p>失败<img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210523011440767.png" alt="image-20210523011440767"></p></li><li><p>成功</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210523011523532.png" alt="image-20210523011523532"></p></li></ul></li></ul><h2 id="12-RPC-和-netty-原理分析"><a href="#12-RPC-和-netty-原理分析" class="headerlink" title="12 RPC 和 netty 原理分析"></a>12 RPC 和 netty 原理分析</h2><h3 id="12-1-RPC-原理"><a href="#12-1-RPC-原理" class="headerlink" title="12.1 RPC 原理"></a>12.1 RPC 原理</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613170846919.png" alt="在这里插入图片描述"></p><p>一次完整的RPC调用流程（同步调用，异步另说）如下：</p><ol><li><strong>服务消费方（client）调用以本地调用方式调用服务；</strong></li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li><strong>服务消费方得到最终结果。</strong></li></ol><p>dubbo只用了两步1和8，中间的过程是透明的看不到的。RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p><h3 id="12-2-netty-通信原理"><a href="#12-2-netty-通信原理" class="headerlink" title="12.2 netty 通信原理"></a>12.2 netty 通信原理</h3><p>Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p><p><strong>BIO：(Blocking IO)</strong></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171108394.png" alt="在这里插入图片描述"></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171138127.png" alt="在这里插入图片描述"></p><p>Selector 一般称 为选择器 ，也可以翻译为 多路复用器，<br>Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）</p><p><strong>Netty基本原理：</strong><br>netty基本原理，可参考<a href="https://www.sohu.com/a/272879207_463994">https://www.sohu.com/a/272879207_463994</a></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171217369.png" alt="在这里插入图片描述"></p><h2 id="12-3-dubbo-原理"><a href="#12-3-dubbo-原理" class="headerlink" title="12.3 dubbo 原理"></a>12.3 dubbo 原理</h2><h3 id="1-dubbo原理-框架设计"><a href="#1-dubbo原理-框架设计" class="headerlink" title="1. dubbo原理 - 框架设计"></a>1. dubbo原理 - 框架设计</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171327533.png" alt="在这里插入图片描述"></p><ul><li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li><li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li><li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li><li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li><li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li><li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li><li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li><li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li><li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li></ul><h3 id="2-dubbo原理-启动解析、加载配置信息"><a href="#2-dubbo原理-启动解析、加载配置信息" class="headerlink" title="2.dubbo原理 - 启动解析、加载配置信息"></a>2.dubbo原理 - 启动解析、加载配置信息</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171545504.png" alt="在这里插入图片描述"></p><h3 id="3-dubbo原理-服务暴露"><a href="#3-dubbo原理-服务暴露" class="headerlink" title="3.dubbo原理 - 服务暴露"></a>3.dubbo原理 - 服务暴露</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171614614.png" alt="在这里插入图片描述"></p><h3 id="4-dubbo原理-服务引用"><a href="#4-dubbo原理-服务引用" class="headerlink" title="4.dubbo原理 - 服务引用"></a>4.dubbo原理 - 服务引用</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171741579.png" alt="在这里插入图片描述"></p><h3 id="5-dubbo原理-服务调用"><a href="#5-dubbo原理-服务调用" class="headerlink" title="5.dubbo原理 - 服务调用"></a>5.dubbo原理 - 服务调用</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171806762.png" alt="在这里插入图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Distributed/">Distributed</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Dubbo/">Dubbo</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker 学习</title>
      <link>https://pncalbl.github.io/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 30 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Docker-学习&quot;&gt;&lt;a href=&quot;#Docker-学习&quot; class=&quot;headerlink&quot; title=&quot;Docker 学习&quot;&gt;&lt;/a&gt;Docker 学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  弱小和无知不是生存的障碍，傲慢才是。&lt;/p&gt;
&lt;/bl</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Docker-学习"><a href="#Docker-学习" class="headerlink" title="Docker 学习"></a>Docker 学习</h1><blockquote><p>  弱小和无知不是生存的障碍，傲慢才是。</p></blockquote><h2 id="1-Docker-概述"><a href="#1-Docker-概述" class="headerlink" title="1 Docker 概述"></a>1 Docker 概述</h2><h3 id="1-1-Docker-为什么出现"><a href="#1-1-Docker-为什么出现" class="headerlink" title="1.1 Docker 为什么出现?"></a>1.1 Docker 为什么出现?</h3><p>一款产品： 开发–上线 两套环境！应用环境，应用配置！</p><p>开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？</p><p>环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。</p><p>发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！</p><p>之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。</p><p>开发环境Windows，最后发布到Linux！</p><p>传统：开发jar，运维来做！</p><p>现在：开发打包部署上线，一套流程做完！</p><p>安卓流程：java — apk —发布（应用商店）一 张三使用apk一安装即可用！</p><p>docker流程： java-jar（环境） — 打包项目帯上环境（镜像） — ( Docker仓库：商店）—–</p><p>Docker给以上的问题，提出了解决方案!</p><p>Docker的思想就来自于集装箱！</p><p>JRE – 多个应用(端口冲突) – 原来都是交叉的！<br>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p><p>Docker通过隔离机制，可以将服务器利用到极致！</p><p>本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！</p><h3 id="1-2-Docker-历史"><a href="#1-2-Docker-历史" class="headerlink" title="1.2 Docker 历史"></a>1.2 Docker 历史</h3><p>2010年，几个的年轻人，就在美国成立了一家公司 dotcloud</p><p>做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！</p><p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p><p>他们将自己的技术（容器化技术）命名就是 Docker<br>Docker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！</p><blockquote><p>  开源</p></blockquote><p>2013年，Docker开源！</p><p>越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！</p><p>2014年4月9日，Docker1.0发布！</p><p>docker为什么这么火？十分的轻巧！</p><p>在容器技术出来之前，我们都是使用虚拟机技术！</p><p>虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！</p><p>虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！</p><div class="code-wrapper"><pre><code class="hljs dockerfile">VMware : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟docker: 隔离，镜像（最核心的环境 <span class="hljs-number">4</span>m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！</code></pre></div><p>Docker基于Go语言开发的！开源项目！</p><p>docker官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a> Docker的文档是超级详细的！</p><p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>比较Docker和虚拟机技术的不同：</p><p>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</p><p>容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</p><p>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响</p><p>应用更快速的交付和部署</p><p>传统：一对帮助文档，安装程序。</p><p>Docker：打包镜像发布测试一键运行。</p><p>更便捷的升级和扩缩容</p><p>使用了 Docker之后，我们部署应用就和搭积木一样<br>项目打包为一个镜像，扩展服务器A！服务器B</p><p>更简单的系统运维<br>在容器化之后，我们的开发，测试环境都是高度一致的</p><p>更高效的计算资源利用</p><p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</p><h2 id="2-Docker-安装"><a href="#2-Docker-安装" class="headerlink" title="2 Docker 安装"></a>2 Docker 安装</h2><h3 id="2-1-Docker-的基本组成"><a href="#2-1-Docker-的基本组成" class="headerlink" title="2.1 Docker 的基本组成"></a>2.1 Docker 的基本组成</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDE5NTgwNTQwMC5wbmc" alt="image-20200514195805400"></p><ul><li><p>镜像（image)：</p><p>docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像 ==&gt; run ==&gt; 容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p></li><li><p>容器(container)：</p><p>Docker 利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.<br>启动，停止，删除，基本命令<br>目前就可以把这个容器理解为就是一个简易的 Linux系统。</p></li><li><p>仓库(repository)：</p><p>仓库就是存放镜像的地方！<br>仓库分为公有仓库和私有仓库。(很类似git)<br>Docker Hub是国外的。<br>阿里云…都有容器服务器(配置镜像加速!)</p></li></ul><h3 id="2-2-安装-Docker"><a href="#2-2-安装-Docker" class="headerlink" title="2.2 安装 Docker"></a>2.2 安装 Docker</h3><blockquote><p>  环境准备</p></blockquote><ol><li>Linux要求内核3.0以上</li><li>CentOS 7</li></ol><div class="code-wrapper"><pre><code class="hljs xml">[root@iZwz9chr22v1g8swsrgdagZ ~]# uname -r3.10.0-1127.19.1.el7.x86_64[root@iZwz9chr22v1g8swsrgdagZ ~]# cat /etc/os-release NAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</code></pre></div><blockquote><p>  安装</p></blockquote><p>帮助文档：<a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a><br>卸载与安装</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.卸载旧版本</span>yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine<span class="hljs-meta">#</span><span class="bash"> 2.需要的安装包</span>yum install -y yum-utils<span class="hljs-meta">#</span><span class="bash"> 3.设置镜像的仓库</span>yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo<span class="hljs-meta">#</span><span class="bash">上述方法默认是从国外的，不推荐</span><span class="hljs-meta">#</span><span class="bash">推荐使用国内的</span>yum-config-manager \    --add-repo \    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo    <span class="hljs-meta">#</span><span class="bash">更新yum软件包索引</span>yum makecache fast<span class="hljs-meta">#</span><span class="bash"> 4.安装docker相关的 docker-ce 社区版 而ee是企业版</span>yum install docker-ce docker-ce-cli containerd.io # 这里我们使用社区版即可 安装最新版sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io-&lt;VERSION_STRING&gt; # 安装固定版本sudo yum install docker-ce-18.09.1 docker-ce-cli-18.09.1 containerd.io-18.09.1 # 安装固定版本<span class="hljs-meta">#</span><span class="bash"> 5.设置开机启动并启动docker</span>systemctl enable docker &amp;&amp; systemctl start dockery<span class="hljs-meta">#</span><span class="bash"> 6. 使用docker version查看是否按照成功</span>docker version</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195237759.png" alt="image-20210509195237759"></p><div class="code-wrapper"><pre><code class="hljs xml"># 7. 测试docker run hello-world# 8.不要忘记配置阿里云镜像加速</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195535948.png" alt="image-20210509195535948"></p><div class="code-wrapper"><pre><code class="hljs xml">#8.查看已经下载的镜像(从这里可以查看已有镜像的id)docker images</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195629675.png" alt="image-20210509195629675"></p><blockquote><p>  卸载docker</p></blockquote><div class="code-wrapper"><pre><code class="hljs xml">#1. 卸载依赖yum remove docker-ce docker-ce-cli containerd.io#2. 删除资源rm -rf /var/lib/docker# /var/lib/docker 是docker的默认工作路径！</code></pre></div><h3 id="2-3-阿里云镜像加速"><a href="#2-3-阿里云镜像加速" class="headerlink" title="2.3 阿里云镜像加速"></a>2.3 阿里云镜像加速</h3><ol><li><p>登录阿里云找到容器服务</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509212735155.png" alt="image-20210509212735155"></p></li><li><p>找到镜像加速器</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509212755335.png" alt="image-20210509212755335"></p></li><li><p>配置使用</p><div class="code-wrapper"><pre><code class="hljs xml">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://kdx6iqr6.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre></div></li></ol><h3 id="2-4-回顾HelloWorld流程"><a href="#2-4-回顾HelloWorld流程" class="headerlink" title="2.4 回顾HelloWorld流程"></a>2.4 回顾HelloWorld流程</h3><ul><li><p>docker run 流程图</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjYzNzI0Ni5wbmc" alt="image-20200515102637246"></p></li><li><p>底层原理</p><p>Docker<strong>是怎么工作的</strong>？</p><p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</p><p>Docker-Server接收到Docker-Client的指令，就会执行这个命令！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjk0OTU1OC5wbmc" alt="image-20200515102949558"></p></li><li><p>为什么Docker比Vm快</p><p>1、docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>2、docker利用的是宿主机的内核,而不需要Guest OS。</p><div class="code-wrapper"><pre><code class="hljs xml">GuestOS： VM（虚拟机）里的的系统（OS）HostOS：物理机里的系统（OS）</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwNDExNzMyOS5wbmc" alt="image-20200515104117329"></p><p>因此,当新建一个 容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。因而避免引导、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了这个复杂的过程,因此新建一个docker容器只需要几秒钟。</p></li></ul><h2 id="3-Docker-命令"><a href="#3-Docker-命令" class="headerlink" title="3 Docker 命令"></a>3 Docker 命令</h2><h3 id="3-1-帮助命令"><a href="#3-1-帮助命令" class="headerlink" title="3.1 帮助命令"></a>3.1 帮助命令</h3><div class="code-wrapper"><pre><code class="hljs dockerfile">docker version    <span class="hljs-comment">#显示docker的版本信息。</span>docker info       <span class="hljs-comment">#显示docker的系统信息，包括镜像和容器的数量</span>docker 命令 --help <span class="hljs-comment">#帮助命令</span></code></pre></div><p>帮助文档的地址：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p><h3 id="3-2-镜像命令"><a href="#3-2-镜像命令" class="headerlink" title="3.2 镜像命令"></a>3.2 镜像命令</h3><div class="code-wrapper"><pre><code class="hljs dockerfile">docker images <span class="hljs-comment">#查看所有本地主机上的镜像 可以使用docker image ls代替</span>docker search <span class="hljs-comment">#搜索镜像</span>docker pull <span class="hljs-comment">#下载镜像 docker image pull</span>docker rmi <span class="hljs-comment">#删除镜像 docker image rm</span></code></pre></div><ul><li><p>docker images查看所有本地的主机上的镜像</p><div class="code-wrapper"><pre><code class="hljs clean">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker imagesREPOSITORY            TAG                 IMAGE ID            CREATED           SIZEhello-world           latest              bf756fb1ae65        <span class="hljs-number">4</span> months ago     <span class="hljs-number">13.3</span>kBmysql                 <span class="hljs-number">5.7</span>                 b84d68d0a7db        <span class="hljs-number">6</span> days ago       <span class="hljs-number">448</span>MB# 解释#REPOSITORY# 镜像的仓库源#TAG# 镜像的标签(版本)---lastest 表示最新版本#IMAGE ID# 镜像的id#CREATED# 镜像的创建时间#SIZE# 镜像的大小# 可选项Options:  -a, --all         Show all images (default hides intermediate images) #列出所有镜像  -q, --quiet       Only show numeric IDs # 只显示镜像的id  [root@iz2zeak7sgj6i7hrb2g862z ~]# docker images -a  #列出所有镜像详细信息[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images -aq #列出所有镜像的idd5f28a0bb0d0f19c56ce92a8<span class="hljs-number">1</span>b6b1fe7261e<span class="hljs-number">1</span>b6b1fe7261e</code></pre></div></li><li><p>docker search 搜索镜像</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210512223558303.png" alt="image-20210512223558303"></p><div class="code-wrapper"><pre><code class="hljs dockerfile">[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker search mysql</span><span class="hljs-comment"># --filter=STARS=3000 #过滤，搜索出来的镜像收藏STARS数量大于3000的</span>Options:  -f, --filter filter   Filter output based on conditions provided      --format string   Pretty-print search using a Go template      --limit int       Max number of search results (default <span class="hljs-number">25</span>)      --no-trunc        Don<span class="hljs-string">&#x27;t truncate output</span><span class="hljs-string">      </span><span class="hljs-string">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker search mysql --filter=STARS=3000</span><span class="hljs-string">NAME        DESCRIPTION         STARS            OFFICIAL        AUTOMATED</span><span class="hljs-string">mysql       MySQL IS ...        9520             [OK]                </span><span class="hljs-string">mariadb     MariaDB IS ...      3456             [OK]   </span></code></pre></div></li><li><p>docker pull 下载镜像</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 下载镜像 docker pull 镜像名[:tag]</span>[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker pull tomcat:8</span><span class="hljs-number">8</span>: Pulling <span class="hljs-keyword">from</span> library/tomcat <span class="hljs-comment">#如果不写tag，默认就是latest</span><span class="hljs-number">90</span>fe46dd8199: Already exists   <span class="hljs-comment">#分层下载： docker image 的核心 联合文件系统</span><span class="hljs-number">35</span>a4f1977689: Already exists bbc37f14aded: Already exists <span class="hljs-number">74</span>e27dc593d4: Already exists <span class="hljs-number">93</span>a01fbfad7f: Already exists <span class="hljs-number">1478</span>df405869: Pull complete <span class="hljs-number">64</span>f0dd11682b: Pull complete <span class="hljs-number">68</span>ff4e050d11: Pull complete f576086003cf: Pull complete <span class="hljs-number">3</span>b72593ce10e: Pull complete Digest: sha256:<span class="hljs-number">0</span>c6234e7ec9d10ab32c06423ab829b32e3183ba5bf2620ee66de866df <span class="hljs-comment"># 签名防伪</span>Status: Downloaded newer image for tomcat:<span class="hljs-number">8</span>docker.io/library/tomcat:<span class="hljs-number">8</span> <span class="hljs-comment">#真实地址</span><span class="hljs-comment">#等价于</span>docker pull tomcat:<span class="hljs-number">8</span>docker pull docker.io/library/tomcat:<span class="hljs-number">8</span></code></pre></div></li><li><p>docker rmi 删除镜像</p><div class="code-wrapper"><pre><code class="hljs dockerfile">docker rmi -f 镜像id <span class="hljs-comment">#删除指定id的镜像</span>[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker rmi -f f19c56ce92a8</span>docker rmi -f $(docker images -aq) <span class="hljs-comment">#删除全部的镜像</span>[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker stop $(docker ps -a -q)</span></code></pre></div></li></ul><h3 id="3-3-容器命令"><a href="#3-3-容器命令" class="headerlink" title="3.3 容器命令"></a>3.3 容器命令</h3><ul><li><p>镜像下载</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment">#docker中下载centos</span>docker pull centos</code></pre></div><div class="code-wrapper"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> 镜像id <span class="hljs-comment">#新建容器并启动</span></span>docker ps 列出所有运行的容器 docker container listdocker rm 容器id <span class="hljs-comment">#删除指定容器</span>docker start 容器id<span class="hljs-comment">#启动容器</span>docker restart 容器id<span class="hljs-comment">#重启容器</span>docker stop 容器id<span class="hljs-comment">#停止当前正在运行的容器</span>docker kill 容器id<span class="hljs-comment">#强制停止当前容器</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs dockerfile">[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker container list  #h和docker ps相同</span></code></pre></div></li><li><p>新建容器并启动</p><div class="code-wrapper"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> [可选参数] image | docker container run [可选参数] image </span><span class="hljs-comment">#参书说明</span>--name=<span class="hljs-string">&quot;Name&quot;</span><span class="hljs-comment">#容器名字 tomcat01 tomcat02 用来区分容器</span>-d<span class="hljs-comment">#后台方式运行</span>-it <span class="hljs-comment">#使用交互方式运行，进入容器查看内容</span>-p<span class="hljs-comment">#指定容器的端口 -p 8080(宿主机):8080(容器)</span>-p ip:主机端口:容器端口-p 主机端口:容器端口(常用)-p 容器端口容器端口-P(大写) 随机指定端口<span class="hljs-comment"># 测试、启动并进入容器</span>[root@iz2zeak7sgj6i7hrb2g[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker run -it centos /bin/bash</span>[root@<span class="hljs-number">241</span>b5abce65e /]<span class="hljs-comment"># ls</span>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  <span class="hljs-keyword">run</span><span class="bash">  sbin  srv  sys  tmp  usr  var</span>[root@<span class="hljs-number">241</span>b5abce65e /]<span class="hljs-comment"># exit #从容器退回主机</span>exit</code></pre></div></li><li><p>列出所有运行的容器</p><div class="code-wrapper"><pre><code class="hljs dockerfile">docker ps 命令  <span class="hljs-comment">#列出当前正在运行的容器</span>  -a, --all      <span class="hljs-comment">#列出当前正在运行的容器 + 带出历史运行过的容器</span>  -n=?, --last int   <span class="hljs-comment">#列出最近创建的?个容器 ?为1则只列出最近创建的一个容器,为2则列出2个</span>  -q, --quiet        <span class="hljs-comment">#只列出容器的编号</span></code></pre></div></li><li><p>退出容器</p><div class="code-wrapper"><pre><code class="hljs dockerfile">exit <span class="hljs-comment">#容器直接退出</span>ctrl +P +Q  <span class="hljs-comment">#容器不停止退出 ---注意：这个很有用的操作</span></code></pre></div></li><li><p>删除容器</p><div class="code-wrapper"><pre><code class="hljs dockerfile">docker rm 容器id   <span class="hljs-comment">#删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -rf</span>docker rm -f $(docker ps -aq)   <span class="hljs-comment">#删除所有的容器</span>docker ps -a -q|xargs docker rm  <span class="hljs-comment">#删除所有的容器</span></code></pre></div></li><li><p>启动和停止容器的操作</p><div class="code-wrapper"><pre><code class="hljs dockerfile">docker start 容器id<span class="hljs-comment">#启动容器</span>docker restart 容器id<span class="hljs-comment">#重启容器</span>docker stop 容器id<span class="hljs-comment">#停止当前正在运行的容器</span>docker kill 容器id<span class="hljs-comment">#强制停止当前容器</span></code></pre></div></li></ul><h3 id="3-4-常用其他命令"><a href="#3-4-常用其他命令" class="headerlink" title="3.4 常用其他命令"></a>3.4 常用其他命令</h3><ul><li><p><strong>后台启动命令</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令 docker run -d 镜像名</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d centosa8f922c255859622ac45ce3a535b7a0e8253329be4756ed6e32265d2dd2fac6c[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps    CONTAINER ID      IMAGE       COMMAND    CREATED     STATUS   PORTS    NAMES<span class="hljs-meta">#</span><span class="bash"> 问题docker ps. 发现centos 停止了</span><span class="hljs-meta">#</span><span class="bash"> 常见的坑，docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止</span><span class="hljs-meta">#</span><span class="bash"> nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span></code></pre></div></li><li><p><strong>查看日志</strong></p><div class="code-wrapper"><pre><code class="hljs shell">docker logs --helpOptions:      --details        Show extra details provided to logs *  -f, --follow         Follow log output      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)*      --tail string    Number of lines to show from the end of the logs (default &quot;all&quot;)*  -t, --timestamps     Show timestamps      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)➜  ~ docker run -d centos /bin/sh -c &quot;while true;do echo 6666;sleep 1;done&quot; #模拟日志      <span class="hljs-meta">#</span><span class="bash">显示日志</span>-tf#显示日志信息（一直更新）--tail number #需要显示日志条数docker logs -t --tail n 容器id #查看n行日志docker logs -ft 容器id #跟着日志</code></pre></div></li><li><p><strong>查看容器中进程信息ps</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令 docker top 容器id</span></code></pre></div></li><li><p><strong>查看镜像的元数据</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令</span>docker inspect 容器id<span class="hljs-meta">#</span><span class="bash">测试</span>➜  ~ docker inspect 55321bcae33d[    &#123;        &quot;Id&quot;: &quot;55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066&quot;,        &quot;Created&quot;: &quot;2020-05-15T05:22:05.515909071Z&quot;,        &quot;Path&quot;: &quot;/bin/sh&quot;,        &quot;Args&quot;: [            &quot;-c&quot;,            &quot;while true;do echo 6666;sleep 1;done&quot;        ],        &quot;State&quot;: &#123;            &quot;Status&quot;: &quot;running&quot;,            &quot;Running&quot;: true,            &quot;Paused&quot;: false,            &quot;Restarting&quot;: false,            &quot;OOMKilled&quot;: false,            &quot;Dead&quot;: false,            &quot;Pid&quot;: 22973,            &quot;ExitCode&quot;: 0,            &quot;Error&quot;: &quot;&quot;,            &quot;StartedAt&quot;: &quot;2020-05-15T05:22:06.165904633Z&quot;,            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;        &#125;,        &quot;Image&quot;: &quot;sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee&quot;,        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/resolv.conf&quot;,        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/hostname&quot;,        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/hosts&quot;,........</code></pre></div></li><li><p><strong>进入当前正在运行的容器</strong></p><p>我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</p><ul><li><p>docker exec -it 容器id bashshell</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">测试</span>➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES55321bcae33d centos “/bin/sh -c &#x27;while t…” 10 minutes ago Up 10 minutes bold_bella7215824a4db centos “/bin/sh -c &#x27;while t…” 13 minutes ago Up 13 minutes zen_kepler55a31b3f8613 centos “/bin/bash” 15 minutes ago Up 15 minutes lucid_clarke➜ ~ docker exec -it 55321bcae33d /bin/bash[root@55321bcae33d /]#</code></pre></div></li><li><p>方法2</p><div class="code-wrapper"><pre><code class="hljs shell">docker attach 容器id<span class="hljs-meta">#</span><span class="bash">测试</span>docker attach 55321bcae33d 正在执行当前的代码...区别<span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> <span class="hljs-comment">#进入当前容器后开启一个新的终端，可以在里面操作。（常用）</span></span><span class="hljs-meta">#</span><span class="bash">docker attach <span class="hljs-comment"># 进入容器正在执行的终端</span></span></code></pre></div></li></ul></li><li><p><strong>从容器内拷贝到主机上</strong></p><div class="code-wrapper"><pre><code class="hljs shell">docker cp 容器id:容器内路径  主机目的路径[root@iz2zeak7sgj6i7hrb2g862z ~]# docker psCONTAINER ID     IMAGE    COMMAND     CREATED         STATUS       PORTS      NAMES56a5583b25b4     centos   &quot;/bin/bash&quot; 7seconds ago    Up 6 seconds      <span class="hljs-meta">#</span><span class="bash">1. 进入docker容器内部</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 56a5583b25b4 /bin/bash[root@55321bcae33d /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span class="hljs-meta">#</span><span class="bash">新建一个文件</span>[root@55321bcae33d /]# echo &quot;hello&quot; &gt; java.java[root@55321bcae33d /]# cat hello.java hello[root@55321bcae33d /]# exitexit<span class="hljs-meta">#</span><span class="bash">hello.java拷贝到home文件加下</span>[root@iz2zeak7sgj6i7hrb2g862z /]# docker cp 56a5583b25b4:/hello.java /home [root@iz2zeak7sgj6i7hrb2g862z /]# cd /home[root@iz2zeak7sgj6i7hrb2g862z home]# ls -l#可以看见java.java存在total 8-rw-r--r-- 1 root root    0 May 19 22:09 haust.java-rw-r--r-- 1 root root    6 May 22 11:12 java.javadrwx------ 3 www  www  4096 May  8 12:14 www</code></pre></div></li></ul><p>学习方式：将我的所有笔记敲一遍，自己记录笔记！</p><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDIxNDMxMzk2Mi5wbmc" alt="image-20200514214313962"></p><h3 id="3-6-命令大全"><a href="#3-6-命令大全" class="headerlink" title="3.6 命令大全"></a>3.6 <strong>命令大全</strong></h3><div class="code-wrapper"><pre><code class="hljs shell">attach      Attach local standard input, output, and error streams to a running container<span class="hljs-meta">#</span><span class="bash">当前shell下 attach连接指定运行的镜像</span>build       Build an image from a Dockerfile # 通过Dockerfile定制镜像commit      Create a new image from a container&#x27;s changes #提交当前容器为新的镜像cp          Copy files/folders between a container and the local filesystem #拷贝文件create      Create a new container #创建一个新的容器diff        Inspect changes to files or directories on a container&#x27;s filesystem #查看docker容器的变化events      Get real time events from the server # 从服务获取容器实时时间exec        Run a command in a running container # 在运行中的容器上运行命令export      Export a container&#x27;s filesystem as a tar archive #导出容器文件系统作为一个tar归档文件[对应import]history     Show the history of an image # 展示一个镜像形成历史images      List images #列出系统当前的镜像import      Import the contents from a tarball to create a filesystem image #从tar包中导入内容创建一个文件系统镜像info        Display system-wide information # 显示全系统信息inspect     Return low-level information on Docker objects #查看容器详细信息kill        Kill one or more running containers # kill指定docker容器load        Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载一个镜像[对应save]login       Log in to a Docker registry #logout      Log out from a Docker registrylogs        Fetch the logs of a containerpause       Pause all processes within one or more containersport        List port mappings or a specific mapping for the containerps          List containerspull        Pull an image or a repository from a registrypush        Push an image or a repository to a registryrename      Rename a containerrestart     Restart one or more containersrm          Remove one or more containersrmi         Remove one or more imagesrun         Run a command in a new containersave        Save one or more images to a tar archive (streamed to STDOUT by default)search      Search the Docker Hub for imagesstart       Start one or more stopped containersstats       Display a live stream of container(s) resource usage statisticsstop        Stop one or more running containerstag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGEtop         Display the running processes of a containerunpause     Unpause all processes within one or more containersupdate      Update configuration of one or more containersversion     Show the Docker version informationwait        Block until one or more containers stop, then print their exit codes</code></pre></div><h2 id="4-Docker-服务安装"><a href="#4-Docker-服务安装" class="headerlink" title="4 Docker 服务安装"></a>4 Docker 服务安装</h2><h3 id="4-1-安装-Nginx"><a href="#4-1-安装-Nginx" class="headerlink" title="4.1 安装 Nginx"></a>4.1 安装 Nginx</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">1. 搜索镜像 search 建议大家去docker搜索，可以看到帮助文档</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker search nginx<span class="hljs-meta">#</span><span class="bash">2. 拉取下载镜像 pull</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull nginx<span class="hljs-meta">#</span><span class="bash">3. 查看是否下载成功镜像</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images<span class="hljs-meta">#</span><span class="bash">3. 运行测试</span><span class="hljs-meta">#</span><span class="bash"> -d 后台运行</span><span class="hljs-meta">#</span><span class="bash"> --name 给容器命名</span><span class="hljs-meta">#</span><span class="bash"> -p 宿主机端口：容器内部端口</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name nginx01 -p 3344:80 nginxaa664b0c8ed98f532453ce1c599be823bcc1f3c9209e5078615af416ccb454c2<span class="hljs-meta">#</span><span class="bash">4. 查看正在启动的镜像</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES75943663c116        nginx               &quot;nginx -g &#x27;daemon of…&quot;   41 seconds ago      Up 40 seconds       0.0.0.0:82-&gt;80/tcp   nginx00<span class="hljs-meta">#</span><span class="bash">5. 进入容器</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it nginx01 /bin/bash #进入root@aa664b0c8ed9:/# whereis nginx#找到nginx位置nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginxroot@aa664b0c8ed9:/# cd /etc/nginx/root@aa664b0c8ed9:/etc/nginx# lsconf.dfastcgi_paramskoi-utf  koi-win  mime.types  modules  nginx.conf  scgi_paramsuwsgi_params  win-utf<span class="hljs-meta">#</span><span class="bash">6. 退出容器</span>root@aa664b0c8ed9:/etc/nginx# exitexit<span class="hljs-meta">#</span><span class="bash">7. 停止容器</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMESaa664b0c8ed9        nginx               &quot;nginx -g &#x27;daemon of…&quot;   10 minutes ago      Up 10 minutes       0.0.0.0:3344-&gt;80/tcp   nginx01[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop aa664b0c8ed9</code></pre></div><p><strong>宿主机端口</strong> 和 <strong>容器内部端口</strong> 以及端口暴露：</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDIxNTkxNTY1MC5wbmc" alt="img"></p><p><strong>问题：</strong>我们每次改动nginx配置文件，都需要进入容器内部？十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器外部修改文件名，容器内部就可以自动修改？-v 数据卷 技术！</p><h3 id="4-3-安装-Tomcat"><a href="#4-3-安装-Tomcat" class="headerlink" title="4.3 安装 Tomcat"></a>4.3 安装 Tomcat</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载 tomcat9.0</span><span class="hljs-meta">#</span><span class="bash"> 之前的启动都是后台，停止了容器，容器还是可以查到， docker run -it --rm 镜像名 一般是用来测试，用完就删除</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -it --rm tomcat:9.0--rm       Automatically remove the container when it exits 用完即删<span class="hljs-meta">#</span><span class="bash">下载 最新版</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull tomcat<span class="hljs-meta">#</span><span class="bash">查看下载的镜像</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images<span class="hljs-meta">#</span><span class="bash">以后台方式，暴露端口方式，启动运行</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 --name tomcat01 tomcat<span class="hljs-meta">#</span><span class="bash">测试访问有没有问题</span>curl localhost:8080<span class="hljs-meta">#</span><span class="bash">根据容器id进入tomcat容器</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 645596565d3f /bin/bashroot@645596565d3f:/usr/local/tomcat# <span class="hljs-meta">#</span><span class="bash">查看tomcat容器内部内容：</span>root@645596565d3f:/usr/local/tomcat# ls -ltotal 152-rw-r--r-- 1 root root 18982 May  5 20:40 BUILDING.txt-rw-r--r-- 1 root root  5409 May  5 20:40 CONTRIBUTING.md-rw-r--r-- 1 root root 57092 May  5 20:40 LICENSE-rw-r--r-- 1 root root  2333 May  5 20:40 NOTICE-rw-r--r-- 1 root root  3255 May  5 20:40 README.md-rw-r--r-- 1 root root  6898 May  5 20:40 RELEASE-NOTES-rw-r--r-- 1 root root 16262 May  5 20:40 RUNNING.txtdrwxr-xr-x 2 root root  4096 May 16 12:05 bindrwxr-xr-x 1 root root  4096 May 21 11:04 confdrwxr-xr-x 2 root root  4096 May 16 12:05 libdrwxrwxrwx 1 root root  4096 May 21 11:04 logsdrwxr-xr-x 2 root root  4096 May 16 12:05 native-jni-libdrwxrwxrwx 2 root root  4096 May 16 12:05 tempdrwxr-xr-x 2 root root  4096 May 16 12:05 webappsdrwxr-xr-x 7 root root  4096 May  5 20:37 webapps.distdrwxrwxrwx 2 root root  4096 May  5 20:36 workroot@645596565d3f:/usr/local/tomcat# <span class="hljs-meta">#</span><span class="bash">进入webapps目录</span>root@645596565d3f:/usr/local/tomcat# cd webappsroot@645596565d3f:/usr/local/tomcat/webapps# lsroot@645596565d3f:/usr/local/tomcat/webapps# <span class="hljs-meta">#</span><span class="bash"> 发现问题：1、linux命令少了。 2.webapps目录为空</span> <span class="hljs-meta">#</span><span class="bash"> 原因：阿里云镜像的原因，阿里云默认是最小的镜像，所以不必要的都剔除掉</span><span class="hljs-meta">#</span><span class="bash"> 保证最小可运行的环境！</span><span class="hljs-meta">#</span><span class="bash"> 解决方案：</span><span class="hljs-meta">#</span><span class="bash"> 将webapps.dist下的文件都拷贝到webapps下即可</span>root@645596565d3f:/usr/local/tomcat# ls 找到webapps.distBUILDING.txt LICENSE  README.md RUNNING.txt  conf  logs  temp     webapps.distCONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin   lib   native-jni-lib  webapps  workroot@645596565d3f:/usr/local/tomcat# cd webapps.dist/ # 进入webapps.dist root@645596565d3f:/usr/local/tomcat/webapps.dist# ls # 查看内容ROOT  docs  examples  host-manager  managerroot@645596565d3f:/usr/local/tomcat/webapps.dist# cd ..root@645596565d3f:/usr/local/tomcat# cp -r webapps.dist/* webapps # 拷贝webapps.dist 内容给webappsroot@645596565d3f:/usr/local/tomcat# cd webapps #进入webappsroot@645596565d3f:/usr/local/tomcat/webapps# ls #查看拷贝结果ROOT  docs  examples  host-manager  manager</code></pre></div><p>这样docker部署tomcat就可以访问了</p><p><strong>问题</strong>:我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？要是可以在容器外部提供一个映射路径，比如webapps，我们在外部放置项目，就自动同步内部就好了！</p><h3 id="4-3-部署elasticsearch-kibana"><a href="#4-3-部署elasticsearch-kibana" class="headerlink" title="4.3 部署elasticsearch+kibana"></a>4.3 部署elasticsearch+kibana</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> es 暴露的端口很多！</span><span class="hljs-meta">#</span><span class="bash"> es 十分耗内存</span><span class="hljs-meta">#</span><span class="bash"> es 的数据一般需要放置到安全目录！挂载</span><span class="hljs-meta">#</span><span class="bash"> --net somenetwork ? 网络配置</span><span class="hljs-meta">#</span><span class="bash"> 启动elasticsearch</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2<span class="hljs-meta">#</span><span class="bash"> 测试一下es是否成功启动</span>➜  ~ curl localhost:9200&#123;  &quot;name&quot; : &quot;d73ad2f22dd3&quot;,  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,  &quot;cluster_uuid&quot; : &quot;atFKgANxS8CzgIyCB8PGxA&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;7.6.2&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;docker&quot;,    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.4.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;<span class="hljs-meta">#</span><span class="bash">测试成功就关掉elasticSearch，防止耗内存</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop d834ce2bd306d834ce2bd306[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stats  # 查看docker容器使用内存情况<span class="hljs-meta">#</span><span class="bash"> 限制最大内存</span>docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;Xms2m -Xmx512m&quot; elasticsearch:7.6.2</code></pre></div><h3 id="4-4-Portainer-可视化面板安装"><a href="#4-4-Portainer-可视化面板安装" class="headerlink" title="4.4 Portainer 可视化面板安装"></a>4.4 Portainer 可视化面板安装</h3><ul><li><p>portainer(先用这个)</p><div class="code-wrapper"><pre><code class="hljs shell">docker run -d -p 8080:9000 \--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre></div></li><li><p>Rancher(CI/CD再用)<br><strong>什么是portainer？</strong></p><p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装命令</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:9000 \<span class="hljs-meta">&gt;</span><span class="bash"> --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="hljs-literal">true</span> portainer/portainer</span>Unable to find image &#x27;portainer/portainer:latest&#x27; locallylatest: Pulling from portainer/portainerd1e017099d17: Pull complete a7dca5b5a9e8: Pull complete Digest: sha256:4ae7f14330b56ffc8728e63d355bc4bc7381417fa45ba0597e5dd32682901080Status: Downloaded newer image for portainer/portainer:latest81753869c4fd438cec0e31659cbed0d112ad22bbcfcb9605483b126ee8ff306d</code></pre></div><p>测试访问： 外网：8080 ：<a href="http://123.56.247.59:8080/">http://123.56.247.59:8080/</a></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE1NTAwNjA3OS5wbmc" alt></p><p>进入之后的面板</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210526004802841.png" alt></p></li></ul><h2 id="5-Docker-镜像讲解"><a href="#5-Docker-镜像讲解" class="headerlink" title="5 Docker 镜像讲解"></a>5 Docker 镜像讲解</h2><h3 id="5-1-镜像原理之联合文件系统"><a href="#5-1-镜像原理之联合文件系统" class="headerlink" title="5.1  镜像原理之联合文件系统"></a>5.1  镜像原理之联合文件系统</h3><h4 id="5-1-1-镜像是什么"><a href="#5-1-1-镜像是什么" class="headerlink" title="5.1.1 镜像是什么"></a>5.1.1 镜像是什么</h4><ul><li><p>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p></li><li><p>所有应用，直接打包docker镜像，就可以直接跑起来！</p></li></ul><h4 id="5-1-2-如何得到镜像"><a href="#5-1-2-如何得到镜像" class="headerlink" title="5.1.2 如何得到镜像"></a>5.1.2 如何得到镜像</h4><ul><li>从远程仓库下载</li><li>别人拷贝给你</li><li>自己制作一个镜像 DockerFile</li></ul><h3 id="5-2-Docker镜像加载原理"><a href="#5-2-Docker镜像加载原理" class="headerlink" title="5.2 Docker镜像加载原理"></a>5.2 Docker镜像加载原理</h3><blockquote><p>  UnionFs （联合文件系统）</p></blockquote><ul><li>UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像</li><li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</li></ul><blockquote><p>  Docker镜像加载原理</p></blockquote><ul><li>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</li><li>boots(boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。</li><li>rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。</li></ul><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzA0OTk1OS5wbmc" alt></p><ul><li>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</li></ul><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzE0MDU1OS5wbmc" alt></p><ul><li>对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs.</li></ul><ul><li>虚拟机是分钟级别，容器是秒级！</li></ul><h3 id="5-3-分层理解"><a href="#5-3-分层理解" class="headerlink" title="5.3 分层理解"></a>5.3 分层理解</h3><blockquote><p>  分层的镜像</p></blockquote><ul><li><p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzgzOTE4MC5wbmc" alt="img"></p></li></ul><p>思考：为什么Docker镜像要采用这种分层的结构呢？</p><ul><li>最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</li></ul><ul><li><p>查看镜像分层的方式可以通过docker image inspect 命令。</p><div class="code-wrapper"><pre><code class="hljs shell">➜  / docker image inspect redis          [    &#123;        &quot;Id&quot;: &quot;sha256:f9b9909726890b00d2098081642edf32e5211b7ab53563929a47f250bcdc1d7c&quot;,        &quot;RepoTags&quot;: [            &quot;redis:latest&quot;        ],        &quot;RepoDigests&quot;: [            &quot;redis@sha256:399a9b17b8522e24fbe2fd3b42474d4bb668d3994153c4b5d38c3dafd5903e32&quot;        ],        &quot;Parent&quot;: &quot;&quot;,        &quot;Comment&quot;: &quot;&quot;,        &quot;Created&quot;: &quot;2020-05-02T01:40:19.112130797Z&quot;,        &quot;Container&quot;: &quot;d30c0bcea88561bc5139821227d2199bb027eeba9083f90c701891b4affce3bc&quot;,        &quot;ContainerConfig&quot;: &#123;            &quot;Hostname&quot;: &quot;d30c0bcea885&quot;,            &quot;Domainname&quot;: &quot;&quot;,            &quot;User&quot;: &quot;&quot;,            &quot;AttachStdin&quot;: false,            &quot;AttachStdout&quot;: false,            &quot;AttachStderr&quot;: false,            &quot;ExposedPorts&quot;: &#123;                &quot;6379/tcp&quot;: &#123;&#125;            &#125;,            &quot;Tty&quot;: false,            &quot;OpenStdin&quot;: false,            &quot;StdinOnce&quot;: false,            &quot;Env&quot;: [                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,                &quot;GOSU_VERSION=1.12&quot;,                &quot;REDIS_VERSION=6.0.1&quot;,                ] .......</code></pre></div></li><li><p><strong>理解：</strong></p><ul><li><p>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p></li><li><p>举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，<br>就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含3个镜像层，如下图所示</p></li><li><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合.</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTIzNDI3NC5wbmc" alt></p></li><li><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NDk1ODkzMi5wbmc" alt></p></li><li><p>上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件</p></li><li><p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTE0ODAwMi5wbmc" alt></p></li><li><p>在这种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中</p></li><li><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统</p></li><li><p>Linux上可用的存储引擎有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的<br>件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。</p></li><li><p>Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW 。</p></li><li><p>下图展示了与系统显示相同的三层镜像。所有镜像层堆并合井，对外提供统一的视图。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTU1NzgwNy5wbmc" alt></p></li></ul></li></ul><blockquote><p>  特点</p></blockquote><ul><li><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！</p></li><li><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MTUwNTg5Ny5wbmc" alt></p></li></ul><blockquote><p>  commit镜像</p></blockquote><div class="code-wrapper"><pre><code class="hljs routeros">docker commit 提交容器成为一个新的副本<span class="hljs-comment"># 命令和git原理类似</span>docker commit <span class="hljs-attribute">-m</span>=<span class="hljs-string">&quot;描述信息&quot;</span> <span class="hljs-attribute">-a</span>=<span class="hljs-string">&quot;作者&quot;</span> 容器id 目标镜像名:[版本TAG]</code></pre></div><p>实战测试</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、启动一个默认的tomcat</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 tomcatde57d0ace5716d27d0e3a7341503d07ed4695ffc266aef78e0a855b270c4064e<span class="hljs-meta">#</span><span class="bash"> 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！</span><span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> -it 容器id /bin/bash</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it de57d0ace571 /bin/bashroot@de57d0ace571:/usr/local/tomcat# <span class="hljs-meta">#</span><span class="bash"> 3、从webapps.dist拷贝文件进去webapp</span>root@de57d0ace571:/usr/local/tomcat# cp -r webapps.dist/* webappsroot@de57d0ace571:/usr/local/tomcat# cd webappsroot@de57d0ace571:/usr/local/tomcat/webapps# lsROOT  docs  examples  host-manager  manager<span class="hljs-meta">#</span><span class="bash"> 4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，而不需要每次都重新拷贝webapps.dist下的文件到webapps了，这就是我们自己的一个修改的镜像。</span>docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]docker commit -a=&quot;pncalbl&quot; -m=&quot;add webapps app&quot; 6c5381bbe865 tomcat02:1.0[root@iz2zeak7sgj6i7hrb2g862z ~]# docker commit -a=&quot;csp提交的&quot; -m=&quot;add webapps app&quot; de57d0ace571 tomcat02.1.0sha256:d5f28a0bb0d0b6522fdcb56f100d11298377b2b7c51b9a9e621379b01cf1487e[root@iz2zeak7sgj6i7hrb2g862z ~]# docker imagesREPOSITORY            TAG                 IMAGE ID            CREATED             SIZEtomcat02.1.0          latest              d5f28a0bb0d0        14 seconds ago      652MBtomcat                latest              1b6b1fe7261e        5 days ago          647MBnginx                 latest              9beeba249f3e        5 days ago          127MBmysql                 5.7                 b84d68d0a7db        5 days ago          448MBelasticsearch         7.6.2               f29a1ee41030        8 weeks ago         791MBportainer/portainer   latest              2869fc110bf7        2 months ago        78.6MBcentos                latest              470671670cac        4 months ago        237MBhello-world           latest              bf756fb1ae65        4 months ago        13.3kB</code></pre></div><h2 id="5-容器数据卷"><a href="#5-容器数据卷" class="headerlink" title="5 容器数据卷"></a>5 容器数据卷</h2><h3 id="5-1-什么是容器数据卷"><a href="#5-1-什么是容器数据卷" class="headerlink" title="5.1 什么是容器数据卷"></a>5.1 什么是容器数据卷</h3><p>将应用和环境打包成一个镜像！</p><p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p><p>MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！</p><p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p><p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEwNTI1ODQ1Ni5wbmc" alt></p><p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p><h3 id="5-2-使用数据卷"><a href="#5-2-使用数据卷" class="headerlink" title="5.2 使用数据卷"></a>5.2 使用数据卷</h3><blockquote><p>  方式一 ：直接使用命令挂载 -v</p></blockquote><div class="code-wrapper"><pre><code class="hljs shell">-v, --volume list                    Bind mount a volumedocker run -it -v 主机目录:容器内目录  -p 主机端口:容器内端口<span class="hljs-meta">#</span><span class="bash"> /home/ceshi：主机home目录下的ceshi文件夹  映射：centos容器中的/home</span>[root@iz2zeak7 home]# docker run -it -v /home/ceshi:/home centos /bin/bash<span class="hljs-meta">#</span><span class="bash">这时候主机的/home/ceshi文件夹就和容器的/home文件夹关联了,二者可以实现文件或数据同步了</span><span class="hljs-meta">#</span><span class="bash">通过 docker inspect 容器id 查看</span>[root@iz2zeak7sgj6i7hrb2g862z home]# docker inspect 6064c490c371</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601210704586.png" alt></p><p>测试文件的同步</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601210829068.png" alt="image-20210601210829068"></p><p>再来测试！</p><p>1、停止容器</p><p>2、宿主机修改文件</p><p>3、启动容器</p><p>4、容器内的数据依旧是同步的</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMDg1MDQzMS5wbmc" alt></p><p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p><h3 id="5-3-实战：安装MySQL"><a href="#5-3-实战：安装MySQL" class="headerlink" title="5.3 实战：安装MySQL"></a>5.3 实战：安装MySQL</h3><p><strong>思考：MySQL的数据持久化的问题</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 获取mysql镜像</span>[root@iz2zeak7sgj6i7hrb2g862z home]# docker pull mysql:5.7<span class="hljs-meta">#</span><span class="bash"> 运行容器,需要做数据挂载 <span class="hljs-comment">#安装启动mysql，需要配置密码的，这是要注意点！</span></span><span class="hljs-meta">#</span><span class="bash"> 参考官网hub</span> docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag<span class="hljs-meta">#</span><span class="bash">启动我们得</span>-d 后台运行-p 端口映射-v 卷挂载-e 环境配置-- name 容器名字docker run -p 3306:3306 --name docker-mysql-v /usr/local/workspace/docker/mysql/conf:/etc/mysql-v /usr/local/workspace/docker/mysql/data:/var/lib/mysql-e MYSQL_ROOT_PASSWORD=12345678 -d mysql:5.6<span class="hljs-meta">#</span><span class="bash"> 启动成功之后，我们在本地使用sqlyog来测试一下</span><span class="hljs-meta">#</span><span class="bash"> sqlyog-连接到服务器的3306--和容器内的3306映射</span> <span class="hljs-meta">#</span><span class="bash"> 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！</span></code></pre></div><p><strong>测试连接</strong>：注意3310端口要在阿里云服务器的安全组中打开，否则无法连接。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601212226538.png" alt></p><p>当我们在本地用Navicat新建名称为test的数据库时候，容器容器也会创建</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601212456348.png" alt="image-20210601212456348"></p><p>假设我们将包含mysql的容器删除时，</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMjUzMjk1MC5wbmc" alt></p><p>发现，<strong>我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能</strong>。</p><h3 id="5-4-具名和匿名挂载"><a href="#5-4-具名和匿名挂载" class="headerlink" title="5.4 具名和匿名挂载"></a>5.4 具名和匿名挂载</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 匿名挂载</span>-v 容器内路径!<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx01 -v /etc/nginx nginx</span><span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span><span class="hljs-meta">$</span><span class="bash"> docker volume ls</span>    DRIVER              VOLUME NAME # 容器内的卷名(匿名卷挂载)local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c         <span class="hljs-meta">#</span><span class="bash"> 这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路径！</span><span class="hljs-meta">#</span><span class="bash"> 具名挂载 -P:表示随机映射端口</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span>9663cfcb1e5a9a1548867481bfddab9fd7824a6dc4c778bf438a040fe891f0ee<span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span><span class="hljs-meta">$</span><span class="bash"> docker volume ls</span>                  DRIVER              VOLUME NAMElocal               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802clocal               juming-nginx #多了一个名字<span class="hljs-meta">#</span><span class="bash"> 通过 -v 卷名：查看容器内路径</span><span class="hljs-meta">#</span><span class="bash"> 查看一下这个卷</span><span class="hljs-meta">$</span><span class="bash"> docker volume inspect juming-nginx</span>[    &#123;        &quot;CreatedAt&quot;: &quot;2020-05-23T13:55:34+08:00&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: null,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;, #默认目录        &quot;Name&quot;: &quot;juming-nginx&quot;,        &quot;Options&quot;: null,        &quot;Scope&quot;: &quot;local&quot;    &#125;]</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMzU0NTc0Ni5wbmc" alt></p><p>所有的docker容器内的卷，没有指定目录的情况下都是在<strong>/var/lib/docker/volumes/自定义的卷名/_data</strong>下，<strong>如果指定了目录，docker volume ls 是查看不到的</strong>。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExNDIzMTQzNS5wbmc" alt></p><p><strong>区分三种挂载方式</strong></p><div class="code-wrapper"><pre><code class="hljs haml"># 三种挂载： 匿名挂载、具名挂载、指定路径挂载-<span class="ruby">v 容器内路径<span class="hljs-comment">#匿名挂载</span></span><span class="ruby">-v 卷名：容器内路径  <span class="hljs-comment">#具名挂载</span></span><span class="ruby">-v /宿主机路径：容器内路径 <span class="hljs-comment">#指定路径挂载 docker volume ls 是查看不到的</span></span></code></pre></div><p>拓展：</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过 -v 容器内路径： ro rw 改变读写权限</span>ro #readonly 只读rw #readwrite 可读可写<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span><span class="hljs-meta">#</span><span class="bash"> ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</span></code></pre></div><h2 id="6-DockerFile"><a href="#6-DockerFile" class="headerlink" title="6 DockerFile"></a>6 DockerFile</h2><h3 id="6-1-初始Dockerfile"><a href="#6-1-初始Dockerfile" class="headerlink" title="6.1 初始Dockerfile"></a>6.1 初始Dockerfile</h3><p><strong>Dockerfile 就是用来构建docker镜像的构建文件</strong>！命令脚本！先体验一下！</p><p>通过这个<strong>脚本可以生成镜像</strong>，镜像是一层一层的，脚本是一个个的命令，每个命令都是一层！</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建一个dockerfile文件，名字可以随便 建议Dockerfile</span><span class="hljs-meta">#</span><span class="bash"> 文件中的内容： 指令(大写) + 参数</span><span class="hljs-meta">$</span><span class="bash"> vim dockerfile1</span>    FROM centos # 当前这个镜像是以centos为基础的    VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] # 挂载卷的卷目录列表(多个目录)    CMD echo &quot;-----end-----&quot;# 输出一下用于测试    CMD /bin/bash# 默认走bash控制台<span class="hljs-meta">#</span><span class="bash"> 这里的每个命令，就是镜像的一层！</span><span class="hljs-meta">#</span><span class="bash"> 构建出这个镜像</span> -f dockerfile1 # f代表file，指这个当前文件的地址(这里是当前目录下的dockerfile1)-t caoshipeng/centos # t就代表target，指目标目录(注意caoshipeng镜像名前不能加斜杠‘/’). # 表示生成在当前目录下<span class="hljs-meta">$</span><span class="bash"> docker build -f dockerfile1 -t caoshipeng/centos .</span>Sending build context to Docker daemon   2.56kBStep 1/4 : FROM centoslatest: Pulling from library/centos8a29a15cefae: Already exists Digest: sha256:fe8d824220415eed5477b63addf40fb06c3b049404242b31982106ac204f6700Status: Downloaded newer image for centos:latest<span class="hljs-meta"> ---&gt;</span><span class="bash"> 470671670cac</span>Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] # 卷名列表<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> c18eefc2c233</span>Removing intermediate container c18eefc2c233<span class="hljs-meta"> ---&gt;</span><span class="bash"> 623ae1d40fb8</span>Step 3/4 : CMD echo &quot;-----end-----&quot;# 输出 脚本命令<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 70e403669f3c</span>Removing intermediate container 70e403669f3c<span class="hljs-meta"> ---&gt;</span><span class="bash"> 0eba1989c4e6</span>Step 4/4 : CMD /bin/bash<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 4342feb3a05b</span>Removing intermediate container 4342feb3a05b<span class="hljs-meta"> ---&gt;</span><span class="bash"> f4a6b0d4d948</span>Successfully built f4a6b0d4d948Successfully tagged caoshipeng/centos:latest<span class="hljs-meta">#</span><span class="bash"> 查看自己构建的镜像</span><span class="hljs-meta">$</span><span class="bash"> docker images</span>REPOSITORY          TAG          IMAGE ID            CREATED              SIZEcaoshipeng/centos   latest       f4a6b0d4d948        About a minute ago   237MB</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203148651.png" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203222615.png" alt></p><p><strong>启动自己写的容器镜像</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -it f4a6b0d4d948 /bin/bash<span class="hljs-comment"># 运行自己写的镜像</span></span><span class="hljs-meta">$</span><span class="bash"> ls -l <span class="hljs-comment"># 查看目录</span></span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTQ1OTAyNi5wbmc" alt></p><p>这个卷和外部一定有一个同步的目录</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTUzMTYyNi5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker inspect 容器id</span><span class="hljs-meta">$</span><span class="bash"> docker inspect ca3b45913df5</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTYzMDI5NS5wbmc" alt></p><p>测试一下刚才的文件是否同步出去了！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203814945.png" alt></p><p>这种方式使用的十分多，因为我们通常会构建自己的镜像！</p><p>假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名：容器内路径！</p><h3 id="6-2-数据卷容器"><a href="#6-2-数据卷容器" class="headerlink" title="6.2 数据卷容器"></a>6.2 数据卷容器</h3><h4 id="1-多个MySQL同步数据"><a href="#1-多个MySQL同步数据" class="headerlink" title="1 多个MySQL同步数据"></a>1 多个MySQL同步数据</h4><p>命名的容器挂载数据卷！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154518325.png" alt></p><div class="code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># 测试 启动3个容器，通过刚才自己写的镜像启动</span><span class="hljs-comment"># 创建docker01：因为我本机是最新版，故这里用latest，狂神老师用的是1.0如下图</span>$ docker run -it --name docker01 pnca/centos:latest<span class="hljs-comment"># 查看容器docekr01内容</span>$ lsbin  home   lost+foundopt   run   sys  vardev  lib    media<span class="hljs-keyword">proc</span><span class="hljs-title">  sbin</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> volume01</span><span class="hljs-title">etc</span> <span class="hljs-title"> lib64</span> <span class="hljs-title"> mnt</span><span class="hljs-title">root</span> <span class="hljs-title"> srv</span> <span class="hljs-title">  usr</span> <span class="hljs-title"> volume02</span><span class="hljs-title"></span><span class="hljs-title">#</span> 不关闭该容器退出CTRL +<span class="hljs-title"> Q</span> +<span class="hljs-title"> P</span>  # 创建docker02: 并且让docker02 继承<span class="hljs-title"> docker01</span><span class="hljs-title">$</span> docker<span class="hljs-title"> run</span> -it --name<span class="hljs-title"> docker02</span> --volumes-from<span class="hljs-title"> docker01</span> pnca/centos:latest# 查看容器docker02内容$<span class="hljs-title"> ls</span><span class="hljs-title">bin</span> <span class="hljs-title"> home</span> <span class="hljs-title">  lost+found</span>opt<span class="hljs-title">   run</span> <span class="hljs-title">  sys</span> <span class="hljs-title"> var</span><span class="hljs-title">dev</span> <span class="hljs-title"> lib</span> <span class="hljs-title">   media</span><span class="hljs-keyword">proc</span><span class="hljs-title">  sbin</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> volume01</span><span class="hljs-title">etc</span> <span class="hljs-title"> lib64</span> <span class="hljs-title"> mnt</span><span class="hljs-title">root</span> <span class="hljs-title"> srv</span> <span class="hljs-title">  usr</span> <span class="hljs-title"> volume02</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMzAyMDA1MC5wbmc" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154539606.png" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 再新建一个docker03同样继承docker01</span><span class="hljs-meta">$</span><span class="bash"> docker run -it --name docker03 --volumes-from docker01 caoshipeng/centos:latest</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> volume01<span class="hljs-comment">#进入volume01 查看是否也同步docker01的数据</span></span><span class="hljs-meta">$</span><span class="bash"> ls</span> docker01.txt<span class="hljs-meta">#</span><span class="bash"> 测试：可以删除docker01，查看一下docker02和docker03是否可以访问这个文件</span><span class="hljs-meta">#</span><span class="bash"> 测试发现：数据依旧保留在docker02和docker03中没有被删除</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMzM1NTAzNC5wbmc" alt></p><h4 id="2-多个mysql实现数据共享"><a href="#2-多个mysql实现数据共享" class="headerlink" title="2 多个mysql实现数据共享"></a>2 多个mysql实现数据共享</h4><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01  mysql:5.7</span><span class="hljs-meta">#</span><span class="bash"> 这个时候，可以实现两个容器数据同步！</span></code></pre></div><p>结论：</p><p><strong>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止</strong>。</p><p><strong>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的</strong>！</p><h3 id="6-3-DockerFile-具体使用"><a href="#6-3-DockerFile-具体使用" class="headerlink" title="6.3 DockerFile 具体使用"></a>6.3 DockerFile 具体使用</h3><h4 id="1-DockerFile介绍"><a href="#1-DockerFile介绍" class="headerlink" title="1 DockerFile介绍"></a>1 DockerFile介绍</h4><p>dockerfile是用来构建docker镜像的文件！命令参数脚本！</p><p>构建步骤：</p><ol><li>编写一个dockerfile文件</li><li>docker build 构建称为一个镜像</li><li>docker run运行镜像</li><li>docker push发布镜像（DockerHub 、阿里云仓库)</li></ol><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205738956.png" alt></p><p>点击后跳到一个Dockerfile</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205655544.png" alt></p><p>很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！</p><p>官方既然可以制作镜像，那我们也可以！</p><h4 id="2-DockerFile-构建过程"><a href="#2-DockerFile-构建过程" class="headerlink" title="2 DockerFile 构建过程"></a>2 DockerFile 构建过程</h4><p><strong>基础知识</strong>：</p><ol><li>每个保留关键字(指令）都是必须是大写字母</li><li>执行从上到下顺序</li><li>#表示注释</li><li>每一个指令都会创建提交一个新的镜像层，并提交！</li></ol><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEzMTc1Njk5Ny5wbmc" alt></p><ul><li>Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</li></ul><ul><li>Docker镜像逐渐成企业交付的标准，必须要掌握！</li></ul><ul><li>DockerFile：构建文件，定义了一切的步骤，源代码</li></ul><ul><li>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。</li></ul><ul><li>Docker容器：容器就是镜像运行起来提供服务。</li></ul><h4 id="3-DockerFile的指令"><a href="#3-DockerFile的指令" class="headerlink" title="3 DockerFile的指令"></a>3 DockerFile的指令</h4><div class="code-wrapper"><pre><code class="hljs shell">FROM# from:基础镜像，一切从这里开始构建MAINTAINER# maintainer:镜像是谁写的， 姓名+邮箱RUN# run:镜像构建的时候需要运行的命令ADD# add:步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录WORKDIR# workdir:镜像的工作目录VOLUME# volume:挂载的目录EXPOSE# expose:保留端口配置CMD# cmd:指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代ENTRYPOINT# entrypoint:指定这个容器启动的时候要运行的命令，可以追加命令ONBUILD# onbuild:当构建一个被继承DockerFile这个时候就会运行onbuild的指令，触发指令COPY# copy:类似ADD，将我们文件拷贝到镜像中ENV# env:构建的时候设置环境变量！</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154609624.png" alt></p><h4 id="4-实战测试"><a href="#4-实战测试" class="headerlink" title="4 实战测试"></a>4 实战测试</h4><p>scratch镜像</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> scratch<span class="hljs-keyword">ADD</span><span class="bash"> centos-7-x86_64-docker.tar.xz /</span><span class="hljs-keyword">LABEL</span><span class="bash"> \</span><span class="bash">    org.label-schema.schema-version=<span class="hljs-string">&quot;1.0&quot;</span> \</span><span class="bash">    org.label-schema.name=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \</span><span class="bash">    org.label-schema.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \</span><span class="bash">    org.label-schema.license=<span class="hljs-string">&quot;GPLv2&quot;</span> \</span><span class="bash">    org.label-schema.build-date=<span class="hljs-string">&quot;20201113&quot;</span> \</span><span class="bash">    org.opencontainers.image.title=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \</span><span class="bash">    org.opencontainers.image.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \</span><span class="bash">    org.opencontainers.image.licenses=<span class="hljs-string">&quot;GPL-2.0-only&quot;</span> \</span><span class="bash">    org.opencontainers.image.created=<span class="hljs-string">&quot;2020-11-13 00:00:00+00:00&quot;</span></span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>]</span></code></pre></div><p><strong>Docker Hub 中 99%的镜像都是从这个基础镜像过来的 FROM scratch</strong>，然后配置需要的软件和配置来进行构建。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205655544.png" alt></p><p>创建一个自己的centos</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1./home下新建dockerfile目录</span><span class="hljs-meta">$</span><span class="bash"> mkdir dockerfile</span><span class="hljs-meta">#</span><span class="bash"> 2. dockerfile目录下新建mydockerfile-centos文件</span><span class="hljs-meta">$</span><span class="bash"> vim mydockerfile-centos</span><span class="hljs-meta">#</span><span class="bash"> 3.编写Dockerfile配置文件</span>FROM centos# 基础镜像是官方原生的centosMAINTAINER pncalbl&lt;pncalbl@qq.com&gt; # 作者ENV MYPATH /usr/local# 配置环境变量的目录 WORKDIR $MYPATH# 将工作目录设置为 MYPATHRUN yum -y install vim# 给官方原生的centos 增加 vim指令RUN yum -y install net-tools# 给官方原生的centos 增加 ifconfig命令EXPOSE 80# 暴露端口号为80CMD echo $MYPATH# 输出下 MYPATH 路径CMD echo &quot;-----end----&quot;CMD /bin/bash# 启动后进入 /bin/bash<span class="hljs-meta">#</span><span class="bash"> 4.通过这个文件构建镜像</span><span class="hljs-meta">#</span><span class="bash"> 命令： docker build -f 文件路径 -t 镜像名:[tag] .</span><span class="hljs-meta">$</span><span class="bash"> docker build -f mydockerfile-centos -t mycentos:0.1 .</span><span class="hljs-meta">#</span><span class="bash"> 5.出现下图后则构建成功</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MDgzMTQ2NC5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker images</span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEmycentos            0.1                 cbf5110a646d        2 minutes ago       311MB<span class="hljs-meta">#</span><span class="bash"> 6.测试运行</span><span class="hljs-meta">$</span><span class="bash"> docker run -it mycentos:0.1 <span class="hljs-comment"># 注意带上版本号，否则每次都回去找最新版latest</span></span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">pwd</span></span>/usr/local# 与Dockerfile文件中 WORKDIR 设置的 MYPATH 一致<span class="hljs-meta">$</span><span class="bash"> vim<span class="hljs-comment"># vim 指令可以使用</span></span><span class="hljs-meta">$</span><span class="bash"> ifconfig     <span class="hljs-comment"># ifconfig 指令可以使用</span></span><span class="hljs-meta">#</span><span class="bash"> docker <span class="hljs-built_in">history</span> 镜像id 查看镜像构建历史步骤</span><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">history</span> 镜像id</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MTYyOTU4My5wbmc" alt></p><p>我们可以列出本地进行的变更历史</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MTg0MDcwNi5wbmc" alt></p><p>我们平时拿到一个镜像，可以用 “docker history 镜像id” 研究一下是什么做的</p><h4 id="5-CMD-和-ENTRYPOINT区别"><a href="#5-CMD-和-ENTRYPOINT区别" class="headerlink" title="5 CMD 和 ENTRYPOINT区别"></a>5 CMD 和 ENTRYPOINT区别</h4><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"><span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span></span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"><span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，可以追加命令</span></span></code></pre></div><p><strong>测试cmd</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编写dockerfile文件</span><span class="hljs-meta">$</span><span class="bash"> vim dockerfile-test-cmd</span>FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]# 启动后执行 ls -a 命令<span class="hljs-meta">#</span><span class="bash"> 构建镜像</span><span class="hljs-meta">$</span><span class="bash"> docker build  -f dockerfile-test-cmd -t cmd-test:0.1 .</span><span class="hljs-meta">#</span><span class="bash"> 运行镜像</span><span class="hljs-meta">$</span><span class="bash"> docker run cmd-test:0.1<span class="hljs-comment"># 由结果可得，运行后就执行了 ls -a 命令</span></span>....dockerenvbindevetchome<span class="hljs-meta">#</span><span class="bash"> 想追加一个命令  -l 成为ls -dockersal：展示列表详细数据</span><span class="hljs-meta">$</span><span class="bash"> docker run cmd-tesclet:0.1 -l</span>docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused &quot;exec: \&quot;-l\&quot;:executable file not found in $PATH&quot;: unknown.ERRO[0000] error waiting for container: context canceled <span class="hljs-meta">#</span><span class="bash"> cmd的情况下 -l 替换了CMD[<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-l&quot;</span>] 而 -l  不是命令所以报错</span></code></pre></div><p><strong>测试ENTRYPOINT</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编写dockerfile文件</span><span class="hljs-meta">$</span><span class="bash"> vim dockerfile-test-entrypoint</span>FROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]<span class="hljs-meta">#</span><span class="bash"> 构建镜像</span><span class="hljs-meta">$</span><span class="bash"> docker build  -f dockerfile-test-entrypoint -t entrypoint-test:0.1 .</span><span class="hljs-meta">#</span><span class="bash"> 运行镜像</span><span class="hljs-meta">$</span><span class="bash"> docker run entrypoint-test:0.1</span>....dockerenvbindevetchomeliblib64lost+found ...<span class="hljs-meta">#</span><span class="bash"> 我们的命令，是直接拼接在我们得ENTRYPOINT命令后面的</span><span class="hljs-meta">$</span><span class="bash"> docker run entrypoint-test:0.1 -l</span>total 56cleadrwxr-xr-x   1 root root 4096 May 16 06:32 .drwxr-xr-x   1 root root 4096 May 16 06:32 ..-rwxr-xr-x   1 root root    0 May 16 06:32 .dockerenvlrwxrwxrwx   1 root root    7 May 11  2019 bin -&gt; usr/bindrwxr-xr-x   5 root root  340 May 16 06:32 devdrwxr-xr-x   1 root root 4096 May 16 06:32 etcdrwxr-xr-x   2 root root 4096 May 11  2019 homelrwxrwxrwx   1 root root    7 May 11  2019 lib -&gt; usr/liblrwxrwxrwx   1 root root    9 May 11  2019 lib64 -&gt; usr/lib64 ....</code></pre></div><p>Dockerfile中很多命令都十分的相似，我们需要了解它们的区别，我们最好的学习就是对比他们然后测试效果！</p><h4 id="6-实战：Tomcat镜像"><a href="#6-实战：Tomcat镜像" class="headerlink" title="6 实战：Tomcat镜像"></a>6 实战：Tomcat镜像</h4><h5 id="6-1-准备镜像文件"><a href="#6-1-准备镜像文件" class="headerlink" title="6.1 准备镜像文件"></a>6.1 准备镜像文件</h5><div class="code-wrapper"><pre><code class="hljs mipsasm">准备tomcat 和 <span class="hljs-keyword">jdk </span>到当前目录，编写好README</code></pre></div><h5 id="6-2-编写-dokerfile"><a href="#6-2-编写-dokerfile" class="headerlink" title="6.2 编写 dokerfile"></a>6.2 编写 dokerfile</h5><div class="code-wrapper"><pre><code class="hljs dockerfile">$ vim dockerfile<span class="hljs-keyword">FROM</span> centos <span class="hljs-comment"># 基础镜像centos</span><span class="hljs-keyword">MAINTAINER</span> pncalbl&lt;pncalbl@qq.com&gt;<span class="hljs-comment"># 作者</span><span class="hljs-keyword">COPY</span><span class="bash"> README /usr/<span class="hljs-built_in">local</span>/README <span class="hljs-comment"># 复制README文件</span></span><span class="hljs-keyword">ADD</span><span class="bash"> jdk-8u231-linux-x64.tar.gz /usr/<span class="hljs-built_in">local</span>/ <span class="hljs-comment"># 添加jdk，ADD 命令会自动解压</span></span><span class="hljs-keyword">ADD</span><span class="bash"> apache-tomcat-9.0.35.tar.gz /usr/<span class="hljs-built_in">local</span>/ <span class="hljs-comment"># 添加tomcat，ADD 命令会自动解压</span></span><span class="hljs-keyword">RUN</span><span class="bash"> yum -y install vim<span class="hljs-comment"># 安装 vim 命令</span></span><span class="hljs-keyword">ENV</span> MYPATH /usr/local <span class="hljs-comment"># 环境变量设置 工作目录</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> <span class="hljs-variable">$MYPATH</span></span><span class="hljs-keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="hljs-number">8.0</span>_231 <span class="hljs-comment"># 环境变量： JAVA_HOME环境变量</span><span class="hljs-keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<span class="hljs-keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">35</span> <span class="hljs-comment"># 环境变量： tomcat环境变量</span><span class="hljs-keyword">ENV</span> CATALINA_BASH /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">35</span><span class="hljs-comment"># 设置环境变量 分隔符是：</span><span class="hljs-keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin <span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 设置暴露的端口</span><span class="hljs-keyword">CMD</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/<span class="hljs-built_in">local</span>/apache-tomcat-9.0.35/logs/catalina.out <span class="hljs-comment"># 设置默认命令</span></span></code></pre></div><h5 id="6-3-构建镜像"><a href="#6-3-构建镜像" class="headerlink" title="6.3 构建镜像"></a>6.3 构建镜像</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 因为dockerfile命名使用默认命名 因此不用使用-f 指定文件</span><span class="hljs-meta">$</span><span class="bash"> docker build -t mytomcat:0.1 .</span></code></pre></div><h5 id="6-4-run镜像"><a href="#6-4-run镜像" class="headerlink" title="6.4 run镜像"></a>6.4 run镜像</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> -d:后台运行 -p:暴露端口 --name:别名 -v:绑定路径</span> <span class="hljs-meta">$</span><span class="bash"> docker run -d -p 8080:8080 --name tomcat01</span> -v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test -v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.35/logs</code></pre></div><h5 id="6-5-访问测试"><a href="#6-5-访问测试" class="headerlink" title="6.5 访问测试"></a>6.5 访问测试</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it 自定义容器的id /bin/bash</span><span class="hljs-meta">$</span><span class="bash"> cul localhost:8080</span></code></pre></div><h5 id="6-6-发布项目"><a href="#6-6-发布项目" class="headerlink" title="6.6 发布项目"></a>6.6 发布项目</h5><p>(由于做了卷挂载，我们直接在本地编写项目就可以发布了！)</p><p>发现：项目部署成功，可以直接访问！</p><p>我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！</p><h4 id="7-发布自己的镜像"><a href="#7-发布自己的镜像" class="headerlink" title="7 发布自己的镜像"></a>7 发布自己的镜像</h4><p><strong>发布到 Docker Hub</strong></p><ol><li><p>地址 <a href="https://hub.docker.com/">https://hub.docker.com/</a></p></li><li><p>确定这个账号可以登录</p></li><li><p>登录</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker login --<span class="hljs-built_in">help</span></span>Usage:  docker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options:  -p, --password string   Password      --password-stdin    Take the password from stdin  -u, --username string   Username<span class="hljs-meta">$</span><span class="bash"> docker login -u 你的用户名 -p 你的密码</span></code></pre></div></li><li><p>提交 push镜像</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE2NDQzNDA0Mi5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 会发现push不上去，因为如果没有前缀的话默认是push到 官方的library</span><span class="hljs-meta">#</span><span class="bash"> 解决方法：</span><span class="hljs-meta">#</span><span class="bash"> 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了</span><span class="hljs-meta">$</span><span class="bash"> docker build -t kuangshen/mytomcat:0.1 .</span><span class="hljs-meta">#</span><span class="bash"> 第二种 使用docker tag <span class="hljs-comment">#然后再次push</span></span><span class="hljs-meta">$</span><span class="bash"> docker tag jid kuangshen/mytomcat:1.0 <span class="hljs-comment">#然后再次push</span></span><span class="hljs-meta">$</span><span class="bash"> docker push kuangshen/mytomcat:1.0</span></code></pre></div><p><strong>发布到 阿里云镜像服务上</strong></p><p>看官网 很详细<a href="https://cr.console.aliyun.com/repository/">https://cr.console.aliyun.com/repository/</a></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo docker login --username=zchengx registry.cn-shenzhen.aliyuncs.com</span><span class="hljs-meta">$</span><span class="bash"> sudo docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像版本号]</span><span class="hljs-meta">#</span><span class="bash"> 修改id 和 版本</span>sudo docker tag a5ef1f32aaae registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:1.0<span class="hljs-meta">#</span><span class="bash"> 修改版本</span><span class="hljs-meta">$</span><span class="bash"> sudo docker push registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像版本号]</span></code></pre></div></li></ol><h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8 小结"></a>8 小结</h4><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MTE1NTY2Ny5wbmc" alt></p><h2 id="7-Docker-网络原理"><a href="#7-Docker-网络原理" class="headerlink" title="7 Docker 网络原理"></a>7 Docker 网络原理</h2><h3 id="7-1-理解Docker-0"><a href="#7-1-理解Docker-0" class="headerlink" title="7.1 理解Docker 0"></a>7.1 理解Docker 0</h3><p>学习之前<strong>清空下前面的docker 镜像、容器</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除全部容器</span><span class="hljs-meta">$</span><span class="bash"> docker rm -f $(docker ps -aq)</span><span class="hljs-meta">#</span><span class="bash"> 删除全部镜像</span><span class="hljs-meta">$</span><span class="bash"> docker rmi -f $(docker images -aq)</span></code></pre></div><blockquote><p>  测试</p></blockquote><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTIyMzIzNjc3Mi5wbmc" alt></p><h4 id="1-三个网络"><a href="#1-三个网络" class="headerlink" title="1 三个网络"></a>1 三个网络</h4><blockquote><p>  问题： docker 是如果处理容器网络访问的？</p></blockquote><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MjA0MTk4NS5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试  运行一个tomcat</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span><span class="hljs-meta">#</span><span class="bash"> 查看容器内部网络地址</span><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it 容器id ip addr</span><span class="hljs-meta">#</span><span class="bash"> 发现容器启动的时候会得到一个 eth0@if91 ip地址，docker分配！</span><span class="hljs-meta">$</span><span class="bash"> ip addr</span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever261: eth0@if91: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0       valid_lft forever preferred_lft forever       <span class="hljs-meta">#</span><span class="bash"> 思考？ linux能不能ping通容器内部！ 可以 容器内部可以ping通外界吗？ 可以！</span><span class="hljs-meta">$</span><span class="bash"> ping 172.18.0.2</span>PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.069 ms64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.074 ms</code></pre></div><blockquote><p>  原理</p></blockquote><ol><li><p>我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个docker0桥接模式，使用的技术是veth-pair技术！</p><p><a href="https://www.cnblogs.com/bakari/p/10613710.html">https://www.cnblogs.com/bakari/p/10613710.html</a></p><p>再次测试 ip addr</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTIyNDAzNjg4My5wbmc" alt></p></li><li><p>再启动一个容器测试，发现又多了一对网络</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MzI1OTQ1OC5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 我们发现这个容器带来网卡，都是一对对的</span><span class="hljs-meta">#</span><span class="bash"> veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连</span><span class="hljs-meta">#</span><span class="bash"> 正因为有这个特性 veth-pair 充当一个桥梁，连接各种虚拟网络设备的</span><span class="hljs-meta">#</span><span class="bash"> OpenStac, Docker容器之间的连接，OVS的连接，都是使用evth-pair技术</span></code></pre></div></li><li><p>我们来测试下tomcat01和tomcat02是否可以ping通</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 获取tomcat01的ip 172.17.0.2</span><span class="hljs-meta">$</span><span class="bash"> docker-tomcat docker <span class="hljs-built_in">exec</span> -it tomcat01 ip addr</span>  550: eth0@if551: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever       <span class="hljs-meta">#</span><span class="bash"> 让tomcat02 ping tomcat01</span>       <span class="hljs-meta">$</span><span class="bash"> docker-tomcat docker <span class="hljs-built_in">exec</span> -it tomcat02 ping 172.17.0.2</span>PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.098 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.071 ms<span class="hljs-meta">#</span><span class="bash"> 结论：容器和容器之间是可以互相ping通</span></code></pre></div></li></ol><h4 id="2-网络模型图"><a href="#2-网络模型图" class="headerlink" title="2 网络模型图"></a>2 网络模型图</h4><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NDI0ODYyNi5wbmc" alt></p><p>结论：tomcat01和tomcat02公用一个路由器，docker0。</p><p>所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip。</p><blockquote><p>  小结</p></blockquote><p>Docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥 docker0</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NDcwMTA2My5wbmc" alt></p><p>Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件）</p><p>只要容器删除，对应的网桥一对就没了！</p><p><strong>思考一个场景：我们编写了一个微服务，database url=ip: 项目不重启，数据ip换了，我们希望可以处理这个问题，可以通过名字来进行访问容器</strong>？</p><h3 id="7-2-容器互联-–link"><a href="#7-2-容器互联-–link" class="headerlink" title="7.2  容器互联 –link"></a>7.2  容器互联 –link</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it tomcat02 ping tomca01   <span class="hljs-comment"># ping不通</span></span>ping: tomca01: Name or service not known<span class="hljs-meta">#</span><span class="bash"> 运行一个tomcat03 --link tomcat02</span> <span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat03 --link tomcat02 tomcat</span>5f9331566980a9e92bc54681caaac14e9fc993f14ad13d98534026c08c0a9aef<span class="hljs-meta">#</span><span class="bash"> 3连接2</span><span class="hljs-meta">#</span><span class="bash"> 用tomcat03 ping tomcat02 可以ping通</span><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it tomcat03 ping tomcat02</span>PING tomcat02 (172.17.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.115 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.080 ms<span class="hljs-meta">#</span><span class="bash"> 2连接3</span><span class="hljs-meta">#</span><span class="bash"> 用tomcat02 ping tomcat03 ping不通</span></code></pre></div><p><strong>探究：</strong></p><p>docker network inspect 网络id 网段相同</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NTkwNDU1MS5wbmc" alt></p><p>docker inspect tomcat03</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE4MDMwODUzMC5wbmc" alt></p><p>查看tomcat03里面的/etc/hosts发现有tomcat02的配置</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE4MDYyOTAxMi5wbmc" alt></p><p>–link 本质就是在hosts配置中添加映射</p><p>现在使用Docker已经不建议使用–link了！</p><p>自定义网络，不适用docker0！</p><p>docker0问题：不支持容器名连接访问！</p><h3 id="7-3-自定义网络"><a href="#7-3-自定义网络" class="headerlink" title="7.3 自定义网络"></a>7.3 自定义网络</h3><div class="code-wrapper"><pre><code class="hljs shell">docker networkconnect     -- Connect a container to a networkcreate      -- Creates a new network with a name specified by thedisconnect  -- Disconnects a container from a networkinspect     -- Displays detailed information on a networkls          -- Lists all the networks created by the userprune       -- Remove all unused networksrm          -- Deletes one or more networks</code></pre></div><blockquote><p>  查看所有的docker网络</p></blockquote><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MDMxNjA3My5wbmc" alt></p><p><strong>网络模式</strong></p><p>bridge ：桥接 docker（默认，自己创建也是用bridge模式）</p><p>none ：不配置网络，一般不用</p><p>host ：和所主机共享网络</p><p>container ：容器网络连通（用得少！局限很大）</p><p>测试</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 我们直接启动的命令 --net bridge,而这个就是我们得docker0</span><span class="hljs-meta">#</span><span class="bash"> bridge就是docker0</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span>等价于 =&gt; docker run -d -P --name tomcat01 --net bridge tomcat<span class="hljs-meta">#</span><span class="bash"> docker0，特点：默认，域名不能访问。 --link可以打通连接，但是很麻烦！</span><span class="hljs-meta">#</span><span class="bash"> 我们可以 自定义一个网络</span><span class="hljs-meta">$</span><span class="bash"> docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTEzOTk0NC5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker network inspect mynet</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTQwNzA2NS5wbmc" alt></p><p>启动两个tomcat,再次查看网络情况</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTg0NDI0MC5wbmc" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MjAwNzM3MS5wbmc" alt></p><p>在自定义的网络下，服务可以互相ping通，不用使用 –link</p><p>我们自定义的网络docker当我们维护好了对应的关系，推荐我们平时这样使用网络！</p><p>好处：</p><ul><li><p>redis -不同的集群使用不同的网络，保证集群是安全和健康的</p></li><li><p>mysql-不同的集群使用不同的网络，保证集群是安全和健康的</p></li></ul><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MjUwNDM2Ny5wbmc" alt></p><h3 id="7-4-网络连通"><a href="#7-4-网络连通" class="headerlink" title="7.4 网络连通"></a>7.4 网络连通</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzI0MzE0Ni5wbmc" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzI1OTE4NS5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试两个不同的网络连通  再启动两个tomcat 使用默认网络，即docker0</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat02 tomcat</span><span class="hljs-meta">#</span><span class="bash"> 此时ping不通</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzU1NDkzMS5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 要将tomcat01 连通 tomcat—net-01 ，连通就是将 tomcat01加到 mynet网络</span><span class="hljs-meta">#</span><span class="bash"> 一个容器两个ip（tomcat01）</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5Mzg0ODMzNy5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 01连通 ，加入后此时，已经可以tomcat01 和 tomcat-01-net ping通了</span><span class="hljs-meta">#</span><span class="bash"> 02是依旧不通的</span></code></pre></div><p>结论：假设要跨网络操作别人，就需要使用docker network connect 连通！</p><h2 id="8-实战：部署Redis集群"><a href="#8-实战：部署Redis集群" class="headerlink" title="8 实战：部署Redis集群"></a>8 实战：部署Redis集群</h2><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5NDQxOTQ3MS5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建网卡</span>docker network create redis --subnet 172.38.0.0/16<span class="hljs-meta">#</span><span class="bash"> 通过脚本创建六个redis配置</span>for port in $(seq 1 6);\do \mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;&gt; /mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdone<span class="hljs-meta">#</span><span class="bash"> 通过脚本运行六个redis</span>for port in $(seq 1 6);\docker run -p 637$&#123;port&#125;:6379 -p 1667$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \-v /mydata/redis/node-$&#123;port&#125;/data:/data \-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span class="hljs-meta">#</span><span class="bash"> 单个启动</span>docker run -p 6376:6379 -p 16376:16379 --name redis-6 \    -v /mydata/redis/node-6/data:/data \    -v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \    -d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf    <span class="hljs-meta">#</span><span class="bash"> 配置集群</span>docker exec -it redis-1 /bin/sh #redis默认没有bashredis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379  --cluster-replicas 1</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjIwMjkwMjI0MS5wbmc" alt></p><p>docker搭建redis集群完成！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjIwMzMyMzk3MS5wbmc" alt></p><p>我们使用docker之后，所有的技术都会慢慢变得简单起来！</p><h2 id="9-IDEA整合Docker"><a href="#9-IDEA整合Docker" class="headerlink" title="9 IDEA整合Docker"></a>9 IDEA整合Docker</h2><ol><li><p>构建SpringBoot项目</p></li><li><p>打包运行</p><div class="code-wrapper"><pre><code class="hljs shell">mvn package</code></pre></div></li><li><p>编写dockerfile</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><span class="hljs-keyword">COPY</span><span class="bash"> *.jar /app.jar</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;--server.port=8080&quot;</span>]</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;app.jar&quot;</span>]</span></code></pre></div></li><li><p>构建镜像</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.复制jar和DockerFIle到服务器</span><span class="hljs-meta">#</span><span class="bash"> 2.构建镜像</span><span class="hljs-meta">$</span><span class="bash"> docker build -t xxxxx:xx  .</span></code></pre></div></li><li><p>发布运行</p><p>以后我们使用了Docker之后，给别人交付就是一个镜像即可！</p></li></ol><h2 id="10-Docker-compose"><a href="#10-Docker-compose" class="headerlink" title="10 Docker compose"></a>10 Docker compose</h2><h3 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173610891.png" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173621230.png" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/2020120517363870.png" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173652461.png" alt></p><h3 id="10-2-安装"><a href="#10-2-安装" class="headerlink" title="10.2 安装"></a>10.2 安装</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173738412.png" alt></p><ul><li><p>下载</p><div class="code-wrapper"><pre><code class="hljs shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></pre></div></li><li><p>授权</p><div class="code-wrapper"><pre><code class="hljs shell">sudo chmod +x /usr/local/bin/docker-compose</code></pre></div></li><li><p>查看版本</p><div class="code-wrapper"><pre><code class="hljs shell">docker-compose version</code></pre></div></li></ul><h3 id="10-3-体验"><a href="#10-3-体验" class="headerlink" title="10.3 体验"></a>10.3 体验</h3><p>官方文档：<a href="https://docs.docker.com/compose/gettingstarted/">https://docs.docker.com/compose/gettingstarted/</a></p><ol><li><p>创建文件夹 composetest</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir composetest</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> composetest</span></code></pre></div></li><li><p>创建 app.py</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim app.py</span>import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)def get_hit_count():    retries = 5    while True:        try:            return cache.incr(&#x27;hits&#x27;)        except redis.exceptions.ConnectionError as exc:            if retries == 0:                raise exc            retries -= 1            time.sleep(0.5)@app.route(&#x27;/&#x27;)def hello():    count = get_hit_count()    return &#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;.format(count)</code></pre></div></li><li><p>创建 requirements.txt</p><div class="code-wrapper"><pre><code class="hljs txt">$ vim requirements.txtflaskredis</code></pre></div></li><li><p>创建 Dockerfile</p><div class="code-wrapper"><pre><code class="hljs dockerfile">$ vim Dockerfile<span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>-alpine<span class="hljs-keyword">RUN</span><span class="bash"> sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories </span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /code</span><span class="hljs-keyword">ENV</span> FLASK_APP=app.py<span class="hljs-keyword">ENV</span> FLASK_RUN_HOST=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><span class="hljs-keyword">RUN</span><span class="bash"> apk add --no-cache gcc musl-dev linux-headers</span><span class="hljs-keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span><span class="hljs-keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span><span class="hljs-keyword">COPY</span><span class="bash"> . .</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;flask&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span></code></pre></div></li><li><p>创建 docker-compose.yml</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim docker-compose.yml</span>version: &quot;3.8&quot;services:  web:    build: .    ports:      - &quot;5000:5000&quot;  redis:    image: &quot;redis:alpine&quot;</code></pre></div></li><li><p>启动</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker-compose build</span><span class="hljs-meta">$</span><span class="bash"> docker-compose up</span></code></pre></div></li><li><p>停止</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161110869.png" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161121213.png" alt></p></li><li><p>小结</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161135882.png" alt></p></li></ol><h3 id="10-4-yaml-规则"><a href="#10-4-yaml-规则" class="headerlink" title="10.4 yaml 规则"></a>10.4 yaml 规则</h3><p><strong>docker-compose.yaml 核心！</strong><br>官方文档：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><h3 id="10-5-开源项目-博客"><a href="#10-5-开源项目-博客" class="headerlink" title="10.5 开源项目 - 博客"></a>10.5 开源项目 - 博客</h3><h2 id="11-Docker-Swarm"><a href="#11-Docker-Swarm" class="headerlink" title="11 Docker Swarm"></a>11 Docker Swarm</h2><h3 id="11-1-什么是Docker-Swarm"><a href="#11-1-什么是Docker-Swarm" class="headerlink" title="11.1 什么是Docker Swarm"></a>11.1 什么是Docker Swarm</h3><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181018165124850-1417419249.png" alt="img"></p><ul><li><p>Swarm是Docker公司推出的用来管理docker集群的平台，几乎全部用GO语言来完成的开发的，代码开源在<a href="https://github.com/docker/swarm，">https://github.com/docker/swarm，</a> 它是将一群Docker宿主机变成一个单一的虚拟主机，Swarm使用标准的Docker API接口作为其前端的访问入口，换言之，各种形式的Docker</p></li><li><p>Client(compose,docker-py等)均可以直接与Swarm通信，甚至Docker本身都可以很容易的与Swarm集成，这大大方便了用户将原本基于单节点的系统移植到Swarm上，同时Swarm内置了对Docker网络插件的支持，用户也很容易的部署跨主机的容器集群服务。</p></li><li><p>Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。</p></li><li><p>从 Docker 1.12.0 版本开始，Docker Swarm 已经包含在 Docker 引擎中（docker swarm），并且已经内置了服务发现工具，我们就不需要像之前一样，再配置 Etcd 或者 Consul 来进行服务发现配置了。</p></li><li><p>Swarm deamon只是一个调度器(Scheduler)加路由器(router),Swarm自己不运行容器，它只是接受Docker客户端发来的请求，调度适合的节点来运行容器，这就意味着，即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，放Swarm重新恢复运行之后，他会收集重建集群信息。</p></li></ul><h3 id="11-2-Docker-Swarm-基本结构图"><a href="#11-2-Docker-Swarm-基本结构图" class="headerlink" title="11.2 Docker Swarm 基本结构图"></a>11.2 Docker Swarm 基本结构图</h3><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181018163339198-1499005562.png" alt="img"></p><p>在结构图可以看出 Docker Client使用Swarm对 集群(Cluster)进行调度使用。</p><p>上图可以看出，Swarm是典型的master-slave结构，通过发现服务来选举manager。manager是中心管理节点，各个node上运行agent接受manager的统一管理，集群会自动通过Raft协议分布式选举出manager节点，无需额外的发现服务支持，避免了单点的瓶颈问题，同时也内置了DNS的负载均衡和对外部负载均衡机制的集成支持</p><h3 id="11-3-Swarm的几个关键概念"><a href="#11-3-Swarm的几个关键概念" class="headerlink" title="11.3 Swarm的几个关键概念"></a>11.3 Swarm的几个关键概念</h3><h4 id="1-Swarm"><a href="#1-Swarm" class="headerlink" title="1 Swarm"></a>1 Swarm</h4><p>集群的管理和编排是使用嵌入docker引擎的SwarmKit，可以在docker初始化时启动swarm模式或者加入已存在的swarm</p><h4 id="2-Node"><a href="#2-Node" class="headerlink" title="2 Node"></a>2 Node</h4><ul><li>一个节点是docker引擎集群的一个实例。您还可以将其视为Docker节点。您可以在单个物理计算机或云服务器上运行一个或多个节点，但生产群集部署通常包括分布在多个物理和云计算机上的Docker节点。</li><li>要将应用程序部署到swarm，请将服务定义提交给 管理器节点。管理器节点将称为任务的工作单元分派 给工作节点。</li><li>Manager节点还执行维护所需群集状态所需的编排和集群管理功能。Manager节点选择单个领导者来执行编排任务。</li><li>工作节点接收并执行从管理器节点分派的任务。默认情况下，管理器节点还将服务作为工作节点运行，但您可以将它们配置为仅运行管理器任务并且是仅管理器节点。代理程序在每个工作程序节点上运行，并报告分配给它的任务。工作节点向管理器节点通知其分配的任务的当前状态，以便管理器可以维持每个工作者的期望状态。</li></ul><h4 id="3-Service"><a href="#3-Service" class="headerlink" title="3 Service"></a>3 Service</h4><p>一个服务是任务的定义，管理机或工作节点上执行。它是群体系统的中心结构，是用户与群体交互的主要根源。创建服务时，你需要指定要使用的容器镜像。</p><h4 id="4-Task"><a href="#4-Task" class="headerlink" title="4 Task"></a>4 Task</h4><p>任务是在docekr容器中执行的命令，Manager节点根据指定数量的任务副本分配任务给worker节点</p><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>docker swarm：集群管理，子命令有init, join, leave, update。（docker swarm –help查看帮助）<br>docker service：服务创建，子命令有create, inspect, update, remove, tasks。（docker service–help查看帮助）<br>docker node：节点管理，子命令有accept, promote, demote, inspect, update, tasks, ls, rm。（docker node –help查看帮助）</p><p>node是加入到swarm集群中的一个docker引擎实体，可以在一台物理机上运行多个node，node分为：<br>manager nodes，也就是管理节点<br>worker nodes，也就是工作节点</p><ul><li>manager node管理节点：执行集群的管理功能，维护集群的状态，选举一个leader节点去执行调度任务。</li><li>worker node工作节点：接收和执行任务。参与容器集群负载调度，仅用于承载task。</li><li>service服务：一个服务是工作节点上执行任务的定义。创建一个服务，指定了容器所使用的镜像和容器运行的命令。<ul><li>service是运行在worker nodes上的task的描述，service的描述包括使用哪个docker 镜像，以及在使用该镜像的容器中执行什么命令。</li></ul></li><li>task任务：一个任务包含了一个容器及其运行的命令。task是service的执行实体，task启动docker容器并在容器中执行任务。</li></ul><h3 id="11-4-Swarm的工作模式"><a href="#11-4-Swarm的工作模式" class="headerlink" title="11.4 Swarm的工作模式"></a>11.4 Swarm的工作模式</h3><ol><li>Node</li></ol><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220250190-271703054.png" alt="img"></p><ol start="2"><li>Service</li></ol><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220303428-146351236.png" alt="img"></p><ol start="3"><li>任务与调度</li></ol><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220312417-120406041.png" alt="img"></p><ol start="4"><li>服务副本与全局服务</li></ol><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220320789-1157117261.png" alt="img"></p><h3 id="11-5-Swarm的调度策略"><a href="#11-5-Swarm的调度策略" class="headerlink" title="11.5 Swarm的调度策略"></a>11.5 Swarm的调度策略</h3><p>Swarm在调度(scheduler)节点（leader节点）运行容器的时候，会根据指定的策略来计算最适合运行容器的节点，目前支持的策略有：spread, binpack, random.</p><ul><li><p>Random<br>顾名思义，就是随机选择一个Node来运行容器，一般用作调试用，spread和binpack策略会根据各个节点的可用的CPU, RAM以及正在运<br>行的容器的数量来计算应该运行容器的节点。</p></li><li><p>Spread<br>在同等条件下，Spread策略会选择运行容器最少的那台节点来运行新的容器，binpack策略会选择运行容器最集中的那台机器来运行新的节点。<br>使用Spread策略会使得容器会均衡的分布在集群中的各个节点上运行，一旦一个节点挂掉了只会损失少部分的容器。</p></li><li><p>Binpack<br>Binpack策略最大化的避免容器碎片化，就是说binpack策略尽可能的把还未使用的节点留给需要更大空间的容器运行，尽可能的把容器运行在<br>一个节点上面。</p></li></ul><h3 id="11-6-Swarm-Cluster模式特性"><a href="#11-6-Swarm-Cluster模式特性" class="headerlink" title="11.6 Swarm Cluster模式特性"></a>11.6 Swarm Cluster模式特性</h3><h4 id="1-批量创建服务"><a href="#1-批量创建服务" class="headerlink" title="1 批量创建服务"></a>1 批量创建服务</h4><p>建立容器之前先创建一个overlay的网络，用来保证在不同主机上的容器网络互通的网络模式</p><h4 id="2-强大的集群的容错性"><a href="#2-强大的集群的容错性" class="headerlink" title="2 强大的集群的容错性"></a>2 强大的集群的容错性</h4><p>当容器副本中的其中某一个或某几个节点宕机后，cluster会根据自己的服务注册发现机制，以及之前设定的值–replicas n，<br>在集群中剩余的空闲节点上，重新拉起容器副本。整个副本迁移的过程无需人工干预，迁移后原本的集群的load balance依旧好使！<br>不难看出，docker service其实不仅仅是批量启动服务这么简单，而是在集群中定义了一种状态。Cluster会持续检测服务的健康状态<br>并维护集群的高可用性。</p><h4 id="3-服务节点的可扩展性"><a href="#3-服务节点的可扩展性" class="headerlink" title="3 服务节点的可扩展性"></a>3 服务节点的可扩展性</h4><p>Swarm Cluster不光只是提供了优秀的高可用性，同时也提供了节点弹性扩展或缩减的功能。当容器组想动态扩展时，只需通过scale<br>参数即可复制出新的副本出来。</p><ul><li><p>仔细观察的话，可以发现所有扩展出来的容器副本都run在原先的节点下面，如果有需求想在每台节点上都run一个相同的副本，方法<br>其实很简单，只需要在命令中将”–replicas n”更换成”–mode=global”即可！</p></li><li><p>复制服务（–replicas n）<br>将一系列复制任务分发至各节点当中，具体取决于您所需要的设置状态，例如“–replicas 3”。</p></li><li><p>全局服务（–mode=global）<br>适用于集群内全部可用节点上的服务任务，例如“–mode global”。如果大家在 Swarm 集群中设有 7 台 Docker 节点，则全部节点之上都将存在对应容器。</p></li></ul><h4 id="4-调度机制"><a href="#4-调度机制" class="headerlink" title="4 调度机制"></a>4 调度机制</h4><p>所谓的调度其主要功能是cluster的server端去选择在哪个服务器节点上创建并启动一个容器实例的动作。它是由一个装箱算法和过滤器<br>组合而成。每次通过过滤器（constraint）启动容器的时候，swarm cluster 都会调用调度机制筛选出匹配约束条件的服务器，并在这上面运行容器。</p><h4 id="5-Swarm-cluster的创建过程包含以下三个步骤"><a href="#5-Swarm-cluster的创建过程包含以下三个步骤" class="headerlink" title="5 Swarm cluster的创建过程包含以下三个步骤-"></a>5 Swarm cluster的创建过程包含以下三个步骤-</h4><ul><li>发现Docker集群中的各个节点，收集节点状态、角色信息，并监视节点状态的变化</li><li>初始化内部调度（scheduler）模块</li><li>创建并启动API监听服务模块</li></ul><p>一旦创建好这个cluster，就可以用命令docker service批量对集群内的容器进行操作，非常方便！</p><p>在启动容器后，docker 会根据当前每个swarm节点的负载判断，在负载最优的节点运行这个task任务，用”docker service ls” 和”docker service ps + taskID”<br>可以看到任务运行在哪个节点上。容器启动后，有时需要等待一段时间才能完成容器创建。</p><h2 id="11-CI-CD-Jenkins"><a href="#11-CI-CD-Jenkins" class="headerlink" title="11 CI\CD Jenkins"></a>11 CI\CD Jenkins</h2>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Distributed/">Distributed</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Docker/">Docker</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Liunx 配置静态IP</title>
      <link>https://pncalbl.github.io/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/</link>
      <guid>https://pncalbl.github.io/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/</guid>
      <pubDate>Thu, 29 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Liunx-配置静态IP-基于CentOS-7&quot;&gt;&lt;a href=&quot;#Liunx-配置静态IP-基于CentOS-7&quot; class=&quot;headerlink&quot; title=&quot;Liunx 配置静态IP (基于CentOS  7)&quot;&gt;&lt;/a&gt;Liunx 配置静态IP (</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Liunx-配置静态IP-基于CentOS-7"><a href="#Liunx-配置静态IP-基于CentOS-7" class="headerlink" title="Liunx 配置静态IP (基于CentOS  7)"></a>Liunx 配置静态IP (基于CentOS  7)</h1><blockquote><p>  只要Vmware的虚拟网络编辑器配置好, 其他liunx系统配置基本一样, 只是有些命令不同而已</p></blockquote><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1 原理"></a>1 原理</h2><ul><li>先看看虚拟机和主机连接的条件：</li></ul><ul><li>需要主机的Vmware8的ip、Vmware8网关ip、虚拟机(centOs)网卡eth0的ip在同一网段下，如图（都是192.168.145.x）：</li></ul><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/20201201012406421.png" alt="img"></p><p>图片来自网络, 侵权请联系<a href="pncalbl@qq.com">author</a>删除</p><ul><li>一般地，如果虚拟机与主机通信走的是虚线，访问外网则走的实线，其控制程序在虚拟机网关设备中实现</li></ul><ul><li>但是，一般由于工作环境的变化，导致网络的改变，有时候会导致虚拟机网段改变，从而与主机连不通，在CentOs下使用ifconfig发现ens33 ip不再192.168.145这个段上，这时，重置eth0的ip即可，方法：ifconfig ens33 192.168.145.xxx</li></ul><h2 id="2-修改虚拟机网络编辑器"><a href="#2-修改虚拟机网络编辑器" class="headerlink" title="2 修改虚拟机网络编辑器"></a>2 修改虚拟机网络编辑器</h2><ul><li><p>点击 编辑-&gt;虚拟机网络编辑器</p><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430180711181.png" alt="image-20210430180711181"></p><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430181747517.png" alt="image-20210430181747517"></p></li></ul><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430181845286.png" alt="image-20210430181845286"></p><ul><li><p>如果子网不对, 可以还原默认设置</p><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430182036414.png" alt="image-20210430182036414"></p></li></ul><h2 id="3-更改网络适配器"><a href="#3-更改网络适配器" class="headerlink" title="3 更改网络适配器"></a>3 更改网络适配器</h2><blockquote><p>  VMware Virtual Ethernet Adapter for VMnet8 (NAT)</p></blockquote><ul><li><p>点击IPv4</p><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430190450485.png" alt="image-20210430190450485"></p></li><li><p>修改</p><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430190551654.png" alt="image-20210430190551654"></p></li></ul><h2 id="4-修改ens33"><a href="#4-修改ens33" class="headerlink" title="4 修改ens33"></a>4 修改ens33</h2><ul><li><p>进入 网卡配置</p><ul><li><p>centOS</p><div class="code-wrapper"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>sysconfig<span class="hljs-regexp">/network-scripts/i</span>fcfg-ens33</code></pre></div></li><li><p>ubunto</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">gedit</span> /etc/netplan/<span class="hljs-number">01</span>-network-manager-<span class="hljs-literal">all</span>.yaml</code></pre></div></li></ul></li><li><p>修改参数</p><ul><li><p>centOS</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">HWADDR</span>=<span class="hljs-number">00</span>:<span class="hljs-number">0</span>C:<span class="hljs-number">29</span>:<span class="hljs-number">0</span>D:<span class="hljs-number">73</span>:CF<span class="hljs-attr">TYPE</span>=Ethernet<span class="hljs-attr">PROXY_METHOD</span>=none<span class="hljs-attr">BROWSER_ONLY</span>=<span class="hljs-literal">no</span><span class="hljs-attr">BOOTPROTO</span>=static<span class="hljs-comment"># 静态IP</span><span class="hljs-attr">DEFROUTE</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><span class="hljs-attr">IPV6_ADDR_GEN_MODE</span>=stable-privacy<span class="hljs-attr">NAME</span>=ens33<span class="hljs-attr">UUID</span>=<span class="hljs-number">13000</span>fee-<span class="hljs-number">503</span>a-<span class="hljs-number">350</span>c-<span class="hljs-number">9462</span>-d70dd1ede195<span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span><span class="hljs-comment">#开机启用本配置</span><span class="hljs-attr">AUTOCONNECT_PRIORITY</span>=-<span class="hljs-number">999</span><span class="hljs-attr">IPADDR</span>=ipv4<span class="hljs-comment">#ipv4</span><span class="hljs-attr">PREFIX</span>=<span class="hljs-number">24</span><span class="hljs-attr">GATEWAY</span>=网关 <span class="hljs-comment">#网关</span><span class="hljs-attr">DNS1</span>=<span class="hljs-number">119.29</span>.<span class="hljs-number">29.29</span><span class="hljs-comment"># 域名解析</span></code></pre></div></li><li><p>ubunto</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span>  <span class="hljs-attr">ethernets:</span>          <span class="hljs-attr">ens33:</span>                  <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span>                  <span class="hljs-attr">dhcp6:</span> <span class="hljs-literal">no</span>                  <span class="hljs-attr">addresses:</span> [<span class="hljs-string">ipv4</span>]                  <span class="hljs-attr">gateway4:</span> <span class="hljs-string">网关</span>                  <span class="hljs-attr">nameservers:</span>                          <span class="hljs-attr">addresses:</span> [<span class="hljs-number">119.29</span><span class="hljs-number">.29</span><span class="hljs-number">.29</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>]</code></pre></div></li></ul></li><li><p>重启网络服务</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">service network restart</span></code></pre></div></li><li><p>查看ip</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span></code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre><code class="hljs autoit"><span class="hljs-built_in">ping</span> www.baidu.com</code></pre></div></li></ul>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Linux/">Linux</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Linux/">Linux</category>
      
      <category domain="https://pncalbl.github.io/tags/%E9%9D%99%E6%80%81IP/">静态IP</category>
      
      
      <comments>https://pncalbl.github.io/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
