<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>pncalbl</title>
    <link>https://pncalbl.github.io/</link>
    
    <image>
      <url>https://www.gravatar.com/avatar/a8fa4407c843fcd53fbcbe238a6dd153</url>
      <title>pncalbl</title>
      <link>https://pncalbl.github.io/</link>
    </image>
    
    <atom:link href="https://pncalbl.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 26 Jul 2021 01:26:23 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>K8s 学习</title>
      <link>https://pncalbl.github.io/2021/07/22/K8s%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/07/22/K8s%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Wed, 21 Jul 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;第1章-Kubernetes简介&quot;&gt;&lt;a href=&quot;#第1章-Kubernetes简介&quot; class=&quot;headerlink&quot; title=&quot;第1章 Kubernetes简介&quot;&gt;&lt;/a&gt;第1章 Kubernetes简介&lt;/h1&gt;&lt;h2 id=&quot;1-来源&quot;&gt;&lt;a </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="第1章-Kubernetes简介"><a href="#第1章-Kubernetes简介" class="headerlink" title="第1章 Kubernetes简介"></a>第1章 Kubernetes简介</h1><h2 id="1-来源"><a href="#1-来源" class="headerlink" title="1 来源"></a>1 来源</h2><p>bilibili尚硅谷K8s视频：<a href="https://www.bilibili.com/video/BV1GT4y1A756">https://www.bilibili.com/video/BV1GT4y1A756</a></p><p>中文官网：<a href="https://kubernetes.io/zh">https://kubernetes.io/zh</a></p><p>中文社区：<a href="https://www.kubernetes.org.cn/">https://www.kubernetes.org.cn/</a></p><h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2 介绍"></a>2 介绍</h2><p>K8s主要讲的就是Kubernetes，首先Kubernetes首字母为K，末尾为s，中间一共有8个字母，所以简称K8s</p><h2 id="3-前置知识"><a href="#3-前置知识" class="headerlink" title="3 前置知识"></a>3 前置知识</h2><ul><li>Linux操作系统</li><li>Docker</li></ul><h2 id="4-课程简介"><a href="#4-课程简介" class="headerlink" title="4 课程简介"></a>4 课程简介</h2><ul><li><p>K8s概念和架构</p></li><li><p>从零搭建K8s集群</p><ul><li>基于客户端工具kubeadm搭建（简单，最多半小时）</li><li>基于二进制包方式（能看到内部的架构）</li></ul></li><li><p>K8s核心概念</p><ul><li>Pod：K8s管理的最小单位级，是所有业务类型的基础</li><li>Controller：控制器，有状态，无状态，一次任务，定时任务，守护进程</li><li>Service Ingress：对外暴露端口</li><li>RBAC：安全机制，权限模型</li><li>Helm：下载机制</li><li>持久化存储</li></ul></li><li><p>搭建集群监控平台系统</p></li><li><p>从零搭建高可用K8s集群</p></li><li><p>在集群环境部署项目</p></li></ul><h2 id="5-K8s概念和特性"><a href="#5-K8s概念和特性" class="headerlink" title="5 K8s概念和特性"></a>5 K8s概念和特性</h2><h3 id="5-1-部署发展历程"><a href="#5-1-部署发展历程" class="headerlink" title="5.1 部署发展历程"></a>5.1 部署发展历程</h3><p>我们的项目部署也在经历下面的这样一个历程</p><blockquote><p>传统部署 -&gt; 虚拟化部署时代 -&gt; 容器部署时代</p></blockquote><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122104102715.png" alt="image-20201122104102715"></p><ul><li><strong>传统部署时代</strong>：早期，组织在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。例如，如果在物理服务器上运行多个应用程序，则可能会出现-一个应用程序占用大部分资源的情况，结果可能导致其他应用程序的性能下降。–种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展，并且组织维护许多物理服务器的成本很高。</li><li><strong>虚拟化部署时代</strong>：作为解决方案，引入了虚拟化功能，它允许您在单个物理服务器的CPU.上运行多个虚拟机（VM）。虚拟化功能允许应用程序在VM之间隔离，并提供安全级别，因为一一个应用程序的信息不能被另一应用程序自由地访问。因为虚拟化可以轻松地添加或更新应用程序、降低硬件成本等等，所以虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性。每个VM是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</li><li><strong>容器部署时代</strong>：容器类似于VM，但是它们具有轻量级的隔离属性，可以在应用程序之间共享操作系统<br>（OS），因此，容器被认为是轻量级的。容器与VM类似，具有自己的文件系统、CPU、内存、进程空间等。由于它们与基础架构分离，因此可以跨云和OS分发进行移植。</li></ul><p>容器因具有许多优势而变得流行起来。下面列出了容器的一些好处：</p><ul><li>敏捷应用程序的创建和部署：与使用VM镜像相比，提高了容器镜像创建的简便性和效率。</li><li>持续开发、集成和部署：通过简单的回滚（由于镜像不可变性），提供可靠且频繁的容器镜像构建和部署。</li><li>关注开发与运维的分离：在构建/时而不是在部署时创建应用程序容器镜像，将应用程序与基础架构分离。</li><li>可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li><li>跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。</li><li>云和操作系统分发的可移植性：可在Ubuntu、RHEL、RHEL、CoreOS、本地、Google Kubernetes Engine和其它任何其它地方运行。</li><li>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行OS到使用逻辑资源在OS上运行应用程序。</li><li>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分，并且可以动态部署和管理-而不是在一台大型单机上器体运行。</li><li>资源隔离：可预测的应用程序性能。</li></ul><h3 id="5-2-K8s概述"><a href="#5-2-K8s概述" class="headerlink" title="5.2 K8s概述"></a>5.2 K8s概述</h3><p>kubernetes，简称K8s，是用8 代替8 个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes 提供了应用部署，规划，更新，维护的一种机制。</p><p>传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新/回滚等操作，当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。</p><p>新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的。</p><blockquote><p>总结：</p><ul><li>K8s是谷歌在2014年发布的容器化集群管理系统</li><li>使用k8s进行容器化应用部署</li><li>使用k8s利于应用扩展</li><li>k8s目标实施让部署容器化应用更加简洁和高效</li></ul></blockquote><h3 id="5-3-K8s概述"><a href="#5-3-K8s概述" class="headerlink" title="5.3 K8s概述"></a>5.3 K8s概述</h3><p>Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes 能够进行应用的自动化部署和扩缩容。在Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。</p><p>Kubernetes 积累了作为Google 生产环境运行工作负载15 年的经验，并吸收了来自于社区的最佳想法和实践。</p><h3 id="5-4-K8s功能"><a href="#5-4-K8s功能" class="headerlink" title="5.4 K8s功能"></a>5.4 K8s功能</h3><h4 id="1-自动装箱"><a href="#1-自动装箱" class="headerlink" title="1 自动装箱"></a>1 自动装箱</h4><p>基于容器对应用运行环境的资源配置要求自动部署应用容器</p><h4 id="2-自我修复-自愈能力"><a href="#2-自我修复-自愈能力" class="headerlink" title="2 自我修复(自愈能力)"></a>2 自我修复(自愈能力)</h4><p>当容器失败时，会对容器进行重启</p><p>当所部署的Node节点有问题时，会对容器进行重新部署和重新调度</p><p>当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928101336750.png" alt="image-20200928101336750"></p><p>如果某个服务器上的应用不响应了，Kubernetes会自动在其它的地方创建一个</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122112241092.png" alt="image-20201122112241092"></p><h4 id="3-水平扩展"><a href="#3-水平扩展" class="headerlink" title="3 水平扩展"></a>3 水平扩展</h4><p>通过简单的命令、用户UI 界面或基于CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁</p><blockquote><p>当我们有大量的请求来临时，我们可以增加副本数量，从而达到水平扩展的效果</p></blockquote><p>当黄色应用过度忙碌，会来扩展一个应用</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122112301750.png" alt="image-20201122112301750"></p><h4 id="4-服务发现"><a href="#4-服务发现" class="headerlink" title="4 服务发现"></a>4 服务发现</h4><p>用户不需使用额外的服务发现机制，就能够基于Kubernetes 自身能力实现服务发现和负载均衡</p><blockquote><p>对外提供统一的入口，让它来做节点的调度和负载均衡， 相当于微服务里面的网关？</p></blockquote><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928101711968.png" alt="image-20200928101711968"></p><h4 id="5-滚动更新"><a href="#5-滚动更新" class="headerlink" title="5 滚动更新"></a>5 滚动更新</h4><p>可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新</p><blockquote><p>添加应用的时候，不是加进去就马上可以进行使用，而是需要判断这个添加进去的应用是否能够正常使用</p></blockquote><h4 id="6-版本回退"><a href="#6-版本回退" class="headerlink" title="6 版本回退"></a>6 版本回退</h4><p>可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</p><blockquote><p>类似于Git中的回滚</p></blockquote><h4 id="7-密钥和配置管理"><a href="#7-密钥和配置管理" class="headerlink" title="7 密钥和配置管理"></a>7 密钥和配置管理</h4><p>在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。</p><h4 id="8-存储编排"><a href="#8-存储编排" class="headerlink" title="8 存储编排"></a>8 存储编排</h4><p>自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要</p><p>存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务</p><h4 id="9-批处理"><a href="#9-批处理" class="headerlink" title="9 批处理"></a>9 批处理</h4><p>提供一次性任务，定时任务；满足批量数据处理和分析的场景</p><h2 id="6-K8s架构组件"><a href="#6-K8s架构组件" class="headerlink" title="6 K8s架构组件"></a>6 K8s架构组件</h2><h3 id="6-1-完整架构图"><a href="#6-1-完整架构图" class="headerlink" title="6.1 完整架构图"></a>6.1 完整架构图</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928103059652.png" alt="image-20200928103059652"></p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20200928110124821.png" alt="image-20200928110124821"></p><h3 id="6-2-架构细节"><a href="#6-2-架构细节" class="headerlink" title="6.2 架构细节"></a>6.2 架构细节</h3><p>K8s架构主要包含两部分：Master（主控节点）和 node（工作节点）</p><p>master节点架构图</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122113057343.png" alt="image-20201122113057343"></p><p>Node节点架构图</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122155629990.png" alt="image-20201122155629990"></p><p>k8s 集群控制节点，对集群进行调度管理，接受集群外用户去集群操作请求；</p><ul><li><p><strong>master</strong>：主控节点</p><ul><li>API Server：集群统一入口，以restful风格进行操作，同时交给etcd存储<ul><li>提供认证、授权、访问控制、API注册和发现等机制</li></ul></li><li>scheduler：节点的调度，选择node节点应用部署</li><li>controller-manager：处理集群中常规后台任务，一个资源对应一个控制器</li><li>etcd：存储系统，用于保存集群中的相关数据</li></ul></li><li><p><strong>Work node</strong>：工作节点</p><ul><li>Kubelet：master派到node节点代表，管理本机容器<ul><li>一个集群中每个节点上运行的代理，它保证容器都运行在Pod中</li><li>负责维护容器的生命周期，同时也负责Volume(CSI) 和 网络(CNI)的管理</li></ul></li><li>kube-proxy：提供网络代理，负载均衡等操作</li></ul></li><li><p>容器运行环境【<strong>Container Runtime</strong>】</p><ul><li>容器运行环境是负责运行容器的软件</li><li>Kubernetes支持多个容器运行环境：Docker、containerd、cri-o、rktlet以及任何实现Kubernetes CRI (容器运行环境接口) 的软件。</li></ul></li><li><p>fluentd：是一个守护进程，它有助于提升 集群层面日志</p></li></ul><h2 id="7-K8s核心概念"><a href="#7-K8s核心概念" class="headerlink" title="7 K8s核心概念"></a>7 K8s核心概念</h2><h3 id="7-1-Pod"><a href="#7-1-Pod" class="headerlink" title="7.1 Pod"></a>7.1 Pod</h3><ul><li>Pod是K8s中最小的单元</li><li>一组容器的集合</li><li>共享网络【一个Pod中的所有容器共享同一网络】</li><li>生命周期是短暂的（服务器重启后，就找不到了）</li></ul><h3 id="7-2-Volume"><a href="#7-2-Volume" class="headerlink" title="7.2 Volume"></a>7.2 Volume</h3><ul><li>声明在Pod容器中可访问的文件目录</li><li>可以被挂载到Pod中一个或多个容器指定路径下</li><li>支持多种后端存储抽象【本地存储、分布式存储、云存储】</li></ul><h3 id="7-3-Controller"><a href="#7-3-Controller" class="headerlink" title="7.3 Controller"></a>7.3 Controller</h3><ul><li>确保预期的pod副本数量【ReplicaSet】</li><li>无状态应用部署【Depoltment】<ul><li>无状态就是指，不需要依赖于网络或者ip</li></ul></li><li>有状态应用部署【StatefulSet】<ul><li>有状态需要特定的条件</li></ul></li><li>确保所有的node运行同一个pod 【DaemonSet】</li><li>一次性任务和定时任务【Job和CronJob】</li></ul><h3 id="7-4-Deployment"><a href="#7-4-Deployment" class="headerlink" title="7.4 Deployment"></a>7.4 Deployment</h3><ul><li>定义一组Pod副本数目，版本等</li><li>通过控制器【Controller】维持Pod数目【自动回复失败的Pod】</li><li>通过控制器以指定的策略控制版本【滚动升级、回滚等】</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122161601349.png" alt="image-20201122161601349"></p><h3 id="7-5-Service"><a href="#7-5-Service" class="headerlink" title="7.5 Service"></a>7.5 Service</h3><ul><li>定义一组pod的访问规则</li><li>Pod的负载均衡，提供一个或多个Pod的稳定访问地址</li><li>支持多种方式【ClusterIP、NodePort、LoadBalancer】</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122161132055.png" alt="image-20201122161132055"></p><p>可以用来组合pod，同时对外提供服务</p><h3 id="7-6-Label"><a href="#7-6-Label" class="headerlink" title="7.6 Label"></a>7.6 Label</h3><p>label：标签，用于对象资源查询，筛选</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122161713638.png" alt="image-20201122161713638"></p><h3 id="7-7-Namespace"><a href="#7-7-Namespace" class="headerlink" title="7.7 Namespace"></a>7.7 Namespace</h3><p>命名空间，逻辑隔离</p><ul><li>一个集群内部的逻辑隔离机制【鉴权、资源】</li><li>每个资源都属于一个namespace</li><li>同一个namespace所有资源不能重复</li><li>不同namespace可以资源名重复</li></ul><h3 id="7-8-API"><a href="#7-8-API" class="headerlink" title="7.8 API"></a>7.8 API</h3><p>我们通过Kubernetes的API来操作整个集群</p><p>同时我们可以通过 kubectl 、ui、curl 最终发送 http + json/yaml 方式的请求给API Server，然后控制整个K8s集群，K8s中所有的资源对象都可以采用 yaml 或 json 格式的文件定义或描述</p><p>如下：使用yaml部署一个nginx的pod</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122162612448.png" alt="image-20201122162612448"></p><h2 id="8-完整流程"><a href="#8-完整流程" class="headerlink" title="8 完整流程"></a>8 完整流程</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/1_Kubernetes%E7%AE%80%E4%BB%8B/images/image-20201122163512535.png" alt="image-20201122163512535"></p><ul><li>通过Kubectl提交一个创建RC（Replication Controller）的请求，该请求通过APlserver写入etcd</li><li>此时Controller Manager通过API Server的监听资源变化的接口监听到此RC事件</li><li>分析之后，发现当前集群中还没有它所对应的Pod实例</li><li>于是根据RC里的Pod模板定义一个生成Pod对象，通过APIServer写入etcd</li><li>此事件被Scheduler发现，它立即执行执行一个复杂的调度流程，为这个新的Pod选定一个落户的Node，然后通过API Server讲这一结果写入etcd中</li><li>目标Node上运行的Kubelet进程通过APiserver监测到这个”新生的Pod，并按照它的定义，启动该Pod并任劳任怨地负责它的下半生，直到Pod的生命结束</li><li>随后，我们通过Kubectl提交一个新的映射到该Pod的Service的创建请求</li><li>ControllerManager通过Label标签查询到关联的Pod实例，然后生成Service的Endpoints信息，并通过APIServer写入到etod中，</li><li>接下来，所有Node上运行的Proxy进程通过APIServer查询并监听Service对象与其对应的Endponts信息，建立一个软件方式的负载均衡器来实现Service访问到后端Pod的流量转发功能</li></ul><h1 id="第2章-搭建K8S集群"><a href="#第2章-搭建K8S集群" class="headerlink" title="第2章 搭建K8S集群"></a>第2章 搭建K8S集群</h1><h2 id="1-搭建k8s环境平台规划"><a href="#1-搭建k8s环境平台规划" class="headerlink" title="1 搭建k8s环境平台规划"></a>1 搭建k8s环境平台规划</h2><h3 id="单master集群"><a href="#单master集群" class="headerlink" title="单master集群"></a>单master集群</h3><p>单个master节点，然后管理多个node节点</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/2_%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/images/image-20200928110456495.png" alt="image-20200928110456495"></p><h3 id="多master集群"><a href="#多master集群" class="headerlink" title="多master集群"></a>多master集群</h3><p>多个master节点，管理多个node节点，同时中间多了一个负载均衡的过程</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/2_%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/images/image-20200928110543829.png" alt="image-20200928110543829"></p><h2 id="2-服务器硬件配置要求"><a href="#2-服务器硬件配置要求" class="headerlink" title="2 服务器硬件配置要求"></a>2 服务器硬件配置要求</h2><h3 id="2-1-测试环境"><a href="#2-1-测试环境" class="headerlink" title="2.1 测试环境"></a>2.1 测试环境</h3><p>master：2核  4G  20G</p><p>node：   4核  8G  40G</p><h3 id="2-2-生产环境"><a href="#2-2-生产环境" class="headerlink" title="2.2 生产环境"></a>2.2 生产环境</h3><p>master：8核  16G  100G</p><p>node：   16核  64G  200G</p><p>目前生产部署Kubernetes集群主要有两种方式</p><h3 id="2-3-kubeadm"><a href="#2-3-kubeadm" class="headerlink" title="2.3 kubeadm"></a>2.3 kubeadm</h3><p>kubeadm是一个K8S部署工具，提供kubeadm init 和 kubeadm join，用于快速部署Kubernetes集群</p><p>官网地址：<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">点我传送</a></p><h3 id="2-4-二进制包"><a href="#2-4-二进制包" class="headerlink" title="2.4 二进制包"></a>2.4 二进制包</h3><p>从github下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。</p><p>Kubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p><h2 id="3-Kubeadm部署集群"><a href="#3-Kubeadm部署集群" class="headerlink" title="3 Kubeadm部署集群"></a>3 Kubeadm部署集群</h2><p>kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：</p><ul><li>创建一个Master 节点kubeadm init</li><li>将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;</li></ul><h2 id="4-安装要求"><a href="#4-安装要求" class="headerlink" title="4 安装要求"></a>4 安装要求</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件</p><ul><li>一台或多台机器，操作系统为Centos7.X</li><li>硬件配置：2GB或更多GAM，2个CPU或更多CPU，硬盘30G</li><li>集群中所有机器之间网络互通</li><li>可以访问外网，需要拉取镜像</li><li>禁止swap分区</li></ul><h1 id="第3章-使用kubeadm方式搭建K8S集群"><a href="#第3章-使用kubeadm方式搭建K8S集群" class="headerlink" title="第3章 使用kubeadm方式搭建K8S集群"></a>第3章 使用kubeadm方式搭建K8S集群</h1><p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。</p><p>这个工具能通过两条指令完成一个kubernetes集群的部署：</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建一个 Master 节点</span>kubeadm init<span class="hljs-meta">#</span><span class="bash"> 将一个 Node 节点加入到当前集群中</span>kubeadm join &lt;Master节点的IP和端口 &gt;</code></pre></div><h2 id="1-Kubeadm方式搭建K8S集群"><a href="#1-Kubeadm方式搭建K8S集群" class="headerlink" title="1 Kubeadm方式搭建K8S集群"></a>1 Kubeadm方式搭建K8S集群</h2><p>使用kubeadm方式搭建K8s集群主要分为以下几步</p><ul><li>准备三台虚拟机，同时安装操作系统CentOS 7.x</li><li>对三个安装之后的操作系统进行初始化操作</li><li>在三个节点安装 docker kubelet kubeadm kubectl</li><li>在master节点执行kubeadm init命令初始化</li><li>在node节点上执行 kubeadm join命令，把node节点添加到当前集群</li><li>配置CNI网络插件，用于节点之间的连通【失败了可以多试几次】</li><li>通过拉取一个nginx进行测试，能否进行外网测试</li></ul><h2 id="2-安装要求"><a href="#2-安装要求" class="headerlink" title="2 安装要求"></a>2 安装要求</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件：</p><ul><li>一台或多台机器，操作系统 CentOS7.x-86_x64</li><li>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多【注意master需要两核】</li><li>可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像并导入节点</li><li>禁止swap分区</li></ul><h2 id="3-准备环境"><a href="#3-准备环境" class="headerlink" title="3 准备环境"></a>3 准备环境</h2><table><thead><tr><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>master</td><td>192.168.177.130</td></tr><tr><td>node1</td><td>192.168.177.131</td></tr><tr><td>node2</td><td>192.168.177.132</td></tr></tbody></table><p>然后开始在每台机器上执行下面的命令</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭防火墙</span>systemctl stop firewalldsystemctl <span class="hljs-built_in">disable</span> firewalld<span class="hljs-comment"># 关闭selinux</span><span class="hljs-comment"># 永久关闭</span>sed -i <span class="hljs-string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  <span class="hljs-comment"># 临时关闭</span>setenforce 0  <span class="hljs-comment"># 关闭swap</span><span class="hljs-comment"># 临时</span>swapoff -a <span class="hljs-comment"># 永久关闭</span>sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab<span class="hljs-comment"># 根据规划设置主机名【master节点上操作】</span>hostnamectl set-hostname k8smaster<span class="hljs-comment"># 根据规划设置主机名【node1节点操作】</span>hostnamectl set-hostname k8snode1<span class="hljs-comment"># 根据规划设置主机名【node2节点操作】</span>hostnamectl set-hostname k8snode2<span class="hljs-comment"># 在master添加hosts</span>cat &gt;&gt; /etc/hosts &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">192.168.177.130 k8smaster</span><span class="hljs-string">192.168.177.131 k8snode1</span><span class="hljs-string">192.168.177.132 k8snode2</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 将桥接的IPv4流量传递到iptables的链</span>cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 生效</span>sysctl --system  <span class="hljs-comment"># 时间同步</span>yum install ntpdate -yntpdate time.windows.com</code></pre></div><h2 id="4-安装Docker-kubeadm-kubelet"><a href="#4-安装Docker-kubeadm-kubelet" class="headerlink" title="4 安装Docker/kubeadm/kubelet"></a>4 安装Docker/kubeadm/kubelet</h2><p>所有节点安装Docker/kubeadm/kubelet ，Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker</p><h3 id="4-1-安装Docker"><a href="#4-1-安装Docker" class="headerlink" title="4.1 安装Docker"></a>4.1 安装Docker</h3><p>首先配置一下Docker的阿里yum源</p><div class="code-wrapper"><pre><code class="hljs bash">cat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;<span class="hljs-string">EOF</span><span class="hljs-string">[docker-ce-edge]</span><span class="hljs-string">name=Docker CE Edge - \$basearch</span><span class="hljs-string">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\$basearch/edge</span><span class="hljs-string">enabled=1</span><span class="hljs-string">gpgcheck=1</span><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><span class="hljs-string">EOF</span></code></pre></div><p>然后yum方式安装docker</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># yum安装</span>yum -y install docker-ce<span class="hljs-comment"># 查看docker版本</span>docker --version  <span class="hljs-comment"># 启动docker</span>systemctl <span class="hljs-built_in">enable</span> dockersystemctl start docker</code></pre></div><p>配置docker的镜像源</p><div class="code-wrapper"><pre><code class="hljs bash">cat &gt;&gt; /etc/docker/daemon.json &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">&#123;</span><span class="hljs-string">  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]</span><span class="hljs-string">&#125;</span><span class="hljs-string">EOF</span></code></pre></div><p>然后重启docker</p><div class="code-wrapper"><pre><code class="hljs bash">systemctl restart docker</code></pre></div><h3 id="4-2-添加kubernetes软件源"><a href="#4-2-添加kubernetes软件源" class="headerlink" title="4.2 添加kubernetes软件源"></a>4.2 添加kubernetes软件源</h3><p>然后我们还需要配置一下yum的k8s软件源</p><div class="code-wrapper"><pre><code class="hljs bash">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">[kubernetes]</span><span class="hljs-string">name=Kubernetes</span><span class="hljs-string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><span class="hljs-string">enabled=1</span><span class="hljs-string">gpgcheck=0</span><span class="hljs-string">repo_gpgcheck=0</span><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><span class="hljs-string">EOF</span></code></pre></div><h3 id="4-3-安装kubeadm，kubelet和kubectl"><a href="#4-3-安装kubeadm，kubelet和kubectl" class="headerlink" title="4.3 安装kubeadm，kubelet和kubectl"></a>4.3 安装kubeadm，kubelet和kubectl</h3><p>由于版本更新频繁，这里指定版本号部署：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装kubelet、kubeadm、kubectl，同时指定版本</span>yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0<span class="hljs-comment"># 设置开机启动</span>systemctl <span class="hljs-built_in">enable</span> kubelet</code></pre></div><h2 id="5-部署Kubernetes-Master【master节点】"><a href="#5-部署Kubernetes-Master【master节点】" class="headerlink" title="5 部署Kubernetes Master【master节点】"></a>5 部署Kubernetes Master【master节点】</h2><p>在   192.168.177.130  执行，也就是master节点</p><div class="code-wrapper"><pre><code class="hljs bash">kubeadm init --apiserver-advertise-address=192.168.177.130 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</code></pre></div><p>由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址，【执行上述命令会比较慢，因为后台其实已经在拉取镜像了】，我们 docker images 命令即可查看已经拉取的镜像</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20200929094302491.png" alt="image-20200929094302491"></p><p>当我们出现下面的情况时，表示kubernetes的镜像已经安装成功</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20200929094620145.png" alt="image-20200929094620145"></p><p>使用kubectl工具 【master节点操作】</p><div class="code-wrapper"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kubesudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/configsudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</code></pre></div><p>执行完成后，我们使用下面命令，查看我们正在运行的节点</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get nodes</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20200929094933142.png" alt="image-20200929094933142"></p><p>能够看到，目前有一个master节点已经运行了，但是还处于未准备状态</p><p>下面我们还需要在Node节点执行其它的命令，将node1和node2加入到我们的master节点上</p><h2 id="6-加入Kubernetes-Node【Slave节点】"><a href="#6-加入Kubernetes-Node【Slave节点】" class="headerlink" title="6 加入Kubernetes Node【Slave节点】"></a>6 加入Kubernetes Node【Slave节点】</h2><p>下面我们需要到 node1 和 node2服务器，执行下面的代码向集群添加新节点</p><p>执行在kubeadm init输出的kubeadm join命令：</p><blockquote><p>注意，以下的命令是在master初始化完成后，每个人的都不一样！！！需要复制自己生成的</p></blockquote><div class="code-wrapper"><pre><code class="hljs bash">kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf \    --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</code></pre></div><p>默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：</p><div class="code-wrapper"><pre><code class="hljs gauss">kubeadm <span class="hljs-built_in">token</span> <span class="hljs-keyword">create</span> --<span class="hljs-keyword">print</span>-join-command</code></pre></div><p>当我们把两个节点都加入进来后，我们就可以去Master节点 执行下面命令查看情况</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get node</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113165358663.png" alt="image-20201113165358663"></p><h2 id="7-部署CNI网络插件"><a href="#7-部署CNI网络插件" class="headerlink" title="7 部署CNI网络插件"></a>7 部署CNI网络插件</h2><p>上面的状态还是NotReady，下面我们需要网络插件，来进行联网访问</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 下载网络插件配置</span>wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre></div><p>默认镜像地址无法访问，sed命令修改为docker hub镜像仓库。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 添加</span>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<span class="hljs-comment">##①首先下载v0.13.1-rc2-amd64 镜像</span><span class="hljs-comment">##参考博客：https://www.cnblogs.com/pyxuexi/p/14288591.html</span><span class="hljs-comment">##② 导入镜像，命令，，特别提示，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，重要的事情说3遍。不然抱错。如果没有操作，报错后，需要删除节点，重置，在导入镜像，重新加入才行。本地就是这样操作成功的！</span>docker load &lt; flanneld-v0.13.1-rc2-amd64.docker<span class="hljs-comment">#####下载本地，替换将image: quay.io/coreos/flannel:v0.13.1-rc2 替换为 image: quay.io/coreos/flannel:v0.13.1-rc2-amd64</span><span class="hljs-comment"># 查看状态 【kube-system是k8s中的最小单元】</span>kubectl get pods -n kube-system</code></pre></div><p>运行后的结果</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113165929510.png" alt="image-20201113165929510"></p><p>运行完成后，我们查看状态可以发现，已经变成了Ready状态了</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113194557147.png" alt="image-20201113194557147"></p><p>如果上述操作完成后，还存在某个节点处于NotReady状态，可以在Master将该节点删除</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># master节点将该节点删除</span><span class="hljs-comment">##20210223 yan 查阅资料添加###kubectl drain k8snode1 --delete-local-data --force --ignore-daemonsets</span>kubectl delete node k8snode1 <span class="hljs-comment"># 然后到k8snode1节点进行重置</span> kubeadm reset<span class="hljs-comment"># 重置完后在加入</span>kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf     --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500</code></pre></div><h2 id="8-测试kubernetes集群"><a href="#8-测试kubernetes集群" class="headerlink" title="8 测试kubernetes集群"></a>8 测试kubernetes集群</h2><p>我们都知道K8S是容器化技术，它可以联网去下载镜像，用容器的方式进行启动</p><p>在Kubernetes集群中创建一个pod，验证是否正常运行：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 下载nginx 【会联网拉取nginx镜像】</span>kubectl create deployment nginx --image=nginx<span class="hljs-comment"># 查看状态</span>kubectl get pod</code></pre></div><p>如果我们出现Running状态的时候，表示已经成功运行了</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113203537028.png" alt="image-20201113203537028"></p><p>下面我们就需要将端口暴露出去，让其它外界能够访问</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 暴露端口</span>kubectl expose deployment nginx --port=80 --<span class="hljs-built_in">type</span>=NodePort<span class="hljs-comment"># 查看一下对外的端口</span>kubectl get pod,svc</code></pre></div><p>能够看到，我们已经成功暴露了 80端口  到 30529上</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113203840915.png" alt="image-20201113203840915"></p><p>我们到我们的宿主机浏览器上，访问如下地址</p><div class="code-wrapper"><pre><code class="hljs bash">http://192.168.177.130:30529/</code></pre></div><p>发现我们的nginx已经成功启动了</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113204056851.png" alt="image-20201113204056851"></p><p>到这里为止，我们就搭建了一个单master的k8s集群</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/3_%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113204158884.png" alt="image-20201113204158884"></p><h2 id="9-错误汇总"><a href="#9-错误汇总" class="headerlink" title="9 错误汇总"></a>9 错误汇总</h2><h3 id="9-1-错误一"><a href="#9-1-错误一" class="headerlink" title="9.1 错误一"></a>9.1 错误一</h3><p>在执行Kubernetes  init方法的时候，出现这个问题</p><div class="code-wrapper"><pre><code class="hljs bash">error execution phase preflight: [preflight] Some fatal errors occurred:[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2</code></pre></div><p>是因为VMware设置的核数为1，而K8S需要的最低核数应该是2，调整核数重启系统即可</p><h3 id="9-2-错误二"><a href="#9-2-错误二" class="headerlink" title="9.2 错误二"></a>9.2 错误二</h3><p>我们在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><div class="code-wrapper"><pre><code class="hljs bash">error execution phase preflight: [preflight] Some fatal errors occurred:[ERROR Swap]: running with swap on is not supported. Please <span class="hljs-built_in">disable</span> swap</code></pre></div><p>错误原因是我们需要关闭swap</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭swap</span><span class="hljs-comment"># 临时</span>swapoff -a <span class="hljs-comment"># 临时</span>sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</code></pre></div><h3 id="9-3-错误三"><a href="#9-3-错误三" class="headerlink" title="9.3 错误三"></a>9.3 错误三</h3><p>在给node1节点使用 kubernetes join命令的时候，出现以下错误</p><div class="code-wrapper"><pre><code class="hljs bash">The HTTP call equal to <span class="hljs-string">&#x27;curl -sSL http://localhost:10248/healthz&#x27;</span> failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused</code></pre></div><p>解决方法，首先需要到 master 节点，创建一个文件</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建文件夹</span>mkdir /etc/systemd/system/kubelet.service.d<span class="hljs-comment"># 创建文件</span>vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf<span class="hljs-comment"># 添加如下内容</span>Environment=<span class="hljs-string">&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --fail-swap-on=false&quot;</span><span class="hljs-comment"># 重置</span>kubeadm reset</code></pre></div><p>然后删除刚刚创建的配置目录</p><div class="code-wrapper"><pre><code class="hljs bash">rm -rf <span class="hljs-variable">$HOME</span>/.kube</code></pre></div><p>然后 在master重新初始化</p><div class="code-wrapper"><pre><code class="hljs bash">kubeadm init --apiserver-advertise-address=202.193.57.11 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16</code></pre></div><p>初始完成后，我们再到 node1节点，执行 kubeadm join命令，加入到master</p><div class="code-wrapper"><pre><code class="hljs bash">kubeadm join 202.193.57.11:6443 --token c7a7ou.z00fzlb01d76r37s \    --discovery-token-ca-cert-hash sha256:9c3f3cc3f726c6ff8bdff14e46b1a856e3b8a4cbbe30cab185f6c5ee453aeea5</code></pre></div><p>添加完成后，我们使用下面命令，查看节点是否成功添加</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get nodes</code></pre></div><h3 id="9-4-错误四"><a href="#9-4-错误四" class="headerlink" title="9.4 错误四"></a>9.4 错误四</h3><p>我们再执行查看节点的时候，  kubectl get nodes 会出现问题</p><div class="code-wrapper"><pre><code class="hljs bash">Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of <span class="hljs-string">&quot;crypto/rsa: verification error&quot;</span> <span class="hljs-keyword">while</span> trying to verify candidate authority certificate <span class="hljs-string">&quot;kubernetes&quot;</span>)</code></pre></div><p>这是因为我们之前创建的配置文件还存在，也就是这些配置</p><div class="code-wrapper"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kubesudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/configsudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</code></pre></div><p>我们需要做的就是把配置文件删除，然后重新执行一下</p><div class="code-wrapper"><pre><code class="hljs bash">rm -rf <span class="hljs-variable">$HOME</span>/.kube</code></pre></div><p>然后再次创建一下即可</p><div class="code-wrapper"><pre><code class="hljs bash">mkdir -p <span class="hljs-variable">$HOME</span>/.kubesudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/configsudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</code></pre></div><p>这个问题主要是因为我们在执行 kubeadm reset 的时候，没有把 $HOME/.kube 给移除掉，再次创建时就会出现问题了</p><h3 id="9-5-错误五"><a href="#9-5-错误五" class="headerlink" title="9.5 错误五"></a>9.5 错误五</h3><p>安装的时候，出现以下错误</p><div class="code-wrapper"><pre><code class="hljs bash">Another app is currently holding the yum lock; waiting <span class="hljs-keyword">for</span> it to <span class="hljs-built_in">exit</span>...</code></pre></div><p>是因为yum上锁占用，解决方法</p><div class="code-wrapper"><pre><code class="hljs bash">yum -y install docker-ce</code></pre></div><h3 id="9-6-错误六"><a href="#9-6-错误六" class="headerlink" title="9.6 错误六"></a>9.6 错误六</h3><p>在使用下面命令，添加node节点到集群上的时候</p><div class="code-wrapper"><pre><code class="hljs bash">kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb  --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</code></pre></div><p>然后出现了这个错误</p><div class="code-wrapper"><pre><code class="hljs bash">[root@k8smaster ~]<span class="hljs-comment"># kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb     --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5</span>W1117 06:55:11.220907   11230 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not <span class="hljs-built_in">set</span>.[preflight] Running pre-flight checks[WARNING IsDockerSystemdCheck]: detected <span class="hljs-string">&quot;cgroupfs&quot;</span> as the Docker cgroup driver. The recommended driver is <span class="hljs-string">&quot;systemd&quot;</span>. Please follow the guide at https://kubernetes.io/docs/setup/cri/error execution phase preflight: [preflight] Some fatal errors occurred:[ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not <span class="hljs-built_in">set</span> to 1[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`To see the stack trace of this error execute with --v=5 or higher</code></pre></div><p>出于安全考虑，Linux系统<strong>默认是禁止数据包转发</strong>的。所谓<strong>转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包</strong>。这通常就是路由器所要实现的功能。也就是说  <strong>/proc/sys/net/ipv4/ip_forward</strong> 文件的值不支持转发</p><ul><li>0：禁止</li><li>1：转发</li></ul><p>所以我们需要将值修改成1即可</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> “1” &gt; /proc/sys/net/ipv4/ip_forward</code></pre></div><p>修改完成后，重新执行命令即可</p><h1 id="第4章-使用二进制方式搭建K8S集群"><a href="#第4章-使用二进制方式搭建K8S集群" class="headerlink" title="第4章 使用二进制方式搭建K8S集群"></a>第4章 使用二进制方式搭建K8S集群</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h2><p>在开始之前，部署Kubernetes集群机器需要满足以下几个条件</p><ul><li>一台或多台机器，操作系统CentOS 7.x</li><li>硬件配置：2GB ，2个CPU，硬盘30GB</li><li>集群中所有机器之间网络互通</li><li>可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像导入节点</li><li>禁止swap分区</li></ul><h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2 步骤"></a>2 步骤</h2><ul><li>创建多台虚拟机，安装Linux系统</li><li>操作系统的初始化</li><li>为etcd 和 apiserver 自签证书</li><li>部署etcd集群</li><li>部署master组件【安装docker、kube-apiserver、kube-controller-manager、kube-scheduler、etcd】</li><li>部署node组件【安装kubelet、kube-proxy、docker、etcd】</li><li>部署集群网络</li></ul><h2 id="3-准备虚拟机"><a href="#3-准备虚拟机" class="headerlink" title="3 准备虚拟机"></a>3 准备虚拟机</h2><p>首先我们准备了两台虚拟机，来进行安装测试</p><table><thead><tr><th>主机名</th><th>ip</th></tr></thead><tbody><tr><td>k8s_2_master</td><td>192.168.177.140</td></tr><tr><td>k8s_2_node</td><td>192.168.177.141</td></tr></tbody></table><h2 id="4-操作系统的初始化"><a href="#4-操作系统的初始化" class="headerlink" title="4 操作系统的初始化"></a>4 操作系统的初始化</h2><p>然后我们需要进行一些系列的初始化操作</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭防火墙</span>systemctl stop firewalldsystemctl <span class="hljs-built_in">disable</span> firewalld<span class="hljs-comment"># 关闭selinux</span><span class="hljs-comment"># 永久关闭</span>sed -i <span class="hljs-string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  <span class="hljs-comment"># 临时关闭</span>setenforce 0  <span class="hljs-comment"># 关闭swap</span><span class="hljs-comment"># 临时</span>swapoff -a <span class="hljs-comment"># 永久关闭</span>sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab<span class="hljs-comment"># 根据规划设置主机名【master节点上操作】</span>hostnamectl set-hostname k8s_2_master<span class="hljs-comment"># 根据规划设置主机名【node1节点操作】</span>hostnamectl set-hostname k8s_2_node1<span class="hljs-comment"># 在master添加hosts</span>cat &gt;&gt; /etc/hosts &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">192.168.177.140 k8s_2_master</span><span class="hljs-string">192.168.177.141 k8s_2_node1</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 将桥接的IPv4流量传递到iptables的链</span>cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 生效</span>sysctl --system  <span class="hljs-comment"># 时间同步</span>yum install ntpdate -yntpdate time.windows.com</code></pre></div><h2 id="5-部署Etcd集群"><a href="#5-部署Etcd集群" class="headerlink" title="5 部署Etcd集群"></a>5 部署Etcd集群</h2><p>Etcd是一个分布式键值存储系统，Kubernetes使用Etcd进行数据存储，所以先准备一个Etcd数据库，为了解决Etcd单点故障，应采用集群方式部署，这里使用3台组建集群，可容忍一台机器故障，当然也可以使用5台组件集群，可以容忍2台机器故障</p><h3 id="自签证书"><a href="#自签证书" class="headerlink" title="自签证书"></a>自签证书</h3><p>提到证书，我们想到的就是下面这个情况</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113213116353.png" alt="image-20201113213116353"></p><p>这个https证书，其实就是服务器颁发给网站的，代表这是一个安全可信任的网站。</p><p>而在我们K8S集群的内部，其实也是有证书的，如果不带证书，那么访问就会受限</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113213353267.png" alt="image-20201113213353267"></p><p>同时在集群内部 和 外部的访问，我们也需要签发证书</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113213416013.png" alt="image-20201113213416013"></p><p>如果我们使用二进制的方式，那么就需要自己手动签发证书。</p><p>自签证书：我们可以想象成在一家公司上班，然后会颁发一个门禁卡，同时一般门禁卡有两种，一个是内部员工的门禁卡，和外部访客门禁卡。这两种门禁卡的权限可能不同，员工的门禁卡可以进入公司的任何地方，而访客的门禁卡是受限的，这个门禁卡其实就是自签证书</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/4_%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/images/image-20201113214234194.png" alt="image-20201113214234194"></p><h3 id="准备cfssl证书生成工具"><a href="#准备cfssl证书生成工具" class="headerlink" title="准备cfssl证书生成工具"></a>准备cfssl证书生成工具</h3><p>cfssl是一个开源的证书管理工具，使用json文件生成证书，相比openssl 更方便使用。找任意一台服务器操作，这里用Master节点。</p><div class="code-wrapper"><pre><code class="hljs bash">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64mv cfssl_linux-amd64 /usr/<span class="hljs-built_in">local</span>/bin/cfsslmv cfssljson_linux-amd64 /usr/<span class="hljs-built_in">local</span>/bin/cfssljsonmv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</code></pre></div><h1 id="第5章-Kubeadm和二进制方式对比"><a href="#第5章-Kubeadm和二进制方式对比" class="headerlink" title="第5章 Kubeadm和二进制方式对比"></a>第5章 Kubeadm和二进制方式对比</h1><h2 id="1-Kubeadm方式搭建K8S集群-1"><a href="#1-Kubeadm方式搭建K8S集群-1" class="headerlink" title="1 Kubeadm方式搭建K8S集群"></a>1 Kubeadm方式搭建K8S集群</h2><ul><li><p>安装虚拟机，在虚拟机安装Linux操作系统【3台虚拟机】</p></li><li><p>对操作系统初始化操作</p></li><li><p>所有节点安装Docker、kubeadm、kubelet、kubectl【包含master和slave节点】</p><ul><li>安装docker、使用yum，不指定版本默认安装最新的docker版本</li><li>修改docker仓库地址，yum源地址，改为阿里云地址</li><li>安装kubeadm，kubelet 和 kubectl<ul><li>k8s已经发布最新的1.19版本，可以指定版本安装，不指定安装最新版本</li><li><code>yum install -y kubelet kubeadm kubectl</code></li></ul></li></ul></li><li><p>在master节点执行初始化命令操作</p><ul><li><code>kubeadm init</code></li><li>默认拉取镜像地址 K8s.gcr.io国内地址，需要使用国内地址</li></ul></li><li><p>安装网络插件(CNI)</p><ul><li><code>kubectl apply -f kube-flannel.yml</code></li><li></li></ul></li><li><p>在所有的node节点上，使用join命令，把node添加到master节点上</p></li><li><p>测试kubernetes集群</p></li></ul><h2 id="2-二进制方式搭建K8S集群"><a href="#2-二进制方式搭建K8S集群" class="headerlink" title="2 二进制方式搭建K8S集群"></a>2 二进制方式搭建K8S集群</h2><ul><li>安装虚拟机和操作系统，对操作系统进行初始化操作</li><li>生成cfssl 自签证书<ul><li><code>ca-key.pem</code>、<code>ca.pem</code></li><li><code>server-key.pem</code>、<code>server.pem</code></li></ul></li><li>部署Etcd集群<ul><li>部署的本质，就是把etcd集群交给 systemd 管理</li><li>把生成的证书复制过来，启动，设置开机启动</li></ul></li><li>为apiserver自签证书，生成过程和etcd类似</li><li>部署master组件，主要包含以下组件<ul><li>apiserver</li><li>controller-manager</li><li>scheduler</li><li>交给systemd管理，并设置开机启动</li><li>如果要安装最新的1.19版本，下载二进制文件进行安装</li></ul></li><li>部署node组件<ul><li>docker</li><li>kubelet</li><li>kube-proxy【需要批准kubelet证书申请加入集群】</li><li>交给systemd管理组件- 组件启动，设置开机启动</li></ul></li><li>批准kubelet证书申请 并加入集群</li><li>部署CNI网络插件</li><li>测试Kubernets集群【安装nginx测试】</li></ul><h1 id="第6章-Kubernetes集群管理工具kubectl"><a href="#第6章-Kubernetes集群管理工具kubectl" class="headerlink" title="第6章 Kubernetes集群管理工具kubectl"></a>第6章 Kubernetes集群管理工具kubectl</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>kubectl是Kubernetes集群的命令行工具，通过kubectl能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署</p><h2 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2 命令格式"></a>2 命令格式</h2><p>命令格式如下</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl [<span class="hljs-built_in">command</span>] [<span class="hljs-built_in">type</span>] [name] [flags]</code></pre></div><p>参数</p><ul><li>command：指定要对资源执行的操作，例如create、get、describe、delete</li><li>type：指定资源类型，资源类型是大小写敏感的，开发者能够以单数 、复数 和 缩略的形式</li></ul><p>例如：</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pod pod1kubectl get pods pod1kubectl get po pod1</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/6_Kubernetes%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7kubectl/images/image-20201114095544185.png" alt="image-20201114095544185"></p><ul><li>name：指定资源的名称，名称也是大小写敏感的，如果省略名称，则会显示所有的资源，例如</li></ul><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods</code></pre></div><ul><li>flags：指定可选的参数，例如，可用 -s 或者 -server参数指定Kubernetes API server的地址和端口</li></ul><h2 id="3-常见命令"><a href="#3-常见命令" class="headerlink" title="3 常见命令"></a>3 常见命令</h2><h3 id="3-1-kubectl-help-获取更多信息"><a href="#3-1-kubectl-help-获取更多信息" class="headerlink" title="3.1 kubectl help 获取更多信息"></a>3.1 kubectl help 获取更多信息</h3><p>通过 help命令，能够获取帮助信息</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 获取kubectl的命令</span>kubectl --<span class="hljs-built_in">help</span><span class="hljs-comment"># 获取某个命令的介绍和使用</span>kubectl get --<span class="hljs-built_in">help</span></code></pre></div><h3 id="3-2-基础命令"><a href="#3-2-基础命令" class="headerlink" title="3.2 基础命令"></a>3.2 基础命令</h3><p>常见的基础命令</p><table><thead><tr><th align="center">命令</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">create</td><td align="center">通过文件名或标准输入创建资源</td></tr><tr><td align="center">expose</td><td align="center">将一个资源公开为一个新的Service</td></tr><tr><td align="center">run</td><td align="center">在集群中运行一个特定的镜像</td></tr><tr><td align="center">set</td><td align="center">在对象上设置特定的功能</td></tr><tr><td align="center">get</td><td align="center">显示一个或多个资源</td></tr><tr><td align="center">explain</td><td align="center">文档参考资料</td></tr><tr><td align="center">edit</td><td align="center">使用默认的编辑器编辑一个资源</td></tr><tr><td align="center">delete</td><td align="center">通过文件名，标准输入，资源名称或标签来删除资源</td></tr></tbody></table><h3 id="3-3-部署命令"><a href="#3-3-部署命令" class="headerlink" title="3.3 部署命令"></a>3.3 部署命令</h3><table><thead><tr><th align="center">命令</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">rollout</td><td align="center">管理资源的发布</td></tr><tr><td align="center">rolling-update</td><td align="center">对给定的复制控制器滚动更新</td></tr><tr><td align="center">scale</td><td align="center">扩容或缩容Pod数量，Deployment、ReplicaSet、RC或Job</td></tr><tr><td align="center">autoscale</td><td align="center">创建一个自动选择扩容或缩容并设置Pod数量</td></tr></tbody></table><h3 id="3-4-集群管理命令"><a href="#3-4-集群管理命令" class="headerlink" title="3.4 集群管理命令"></a>3.4 集群管理命令</h3><table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>certificate</td><td>修改证书资源</td></tr><tr><td>cluster-info</td><td>显示集群信息</td></tr><tr><td>top</td><td>显示资源(CPU/M)</td></tr><tr><td>cordon</td><td>标记节点不可调度</td></tr><tr><td>uncordon</td><td>标记节点可被调度</td></tr><tr><td>drain</td><td>驱逐节点上的应用，准备下线维护</td></tr><tr><td>taint</td><td>修改节点taint标记</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="3-5-故障和调试命令"><a href="#3-5-故障和调试命令" class="headerlink" title="3.5 故障和调试命令"></a>3.5 故障和调试命令</h3><table><thead><tr><th align="center">命令</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">describe</td><td align="center">显示特定资源或资源组的详细信息</td></tr><tr><td align="center">logs</td><td align="center">在一个Pod中打印一个容器日志，如果Pod只有一个容器，容器名称是可选的</td></tr><tr><td align="center">attach</td><td align="center">附加到一个运行的容器</td></tr><tr><td align="center">exec</td><td align="center">执行命令到容器</td></tr><tr><td align="center">port-forward</td><td align="center">转发一个或多个</td></tr><tr><td align="center">proxy</td><td align="center">运行一个proxy到Kubernetes API Server</td></tr><tr><td align="center">cp</td><td align="center">拷贝文件或目录到容器中</td></tr><tr><td align="center">auth</td><td align="center">检查授权</td></tr></tbody></table><h3 id="3-6-其它命令"><a href="#3-6-其它命令" class="headerlink" title="3.6 其它命令"></a>3.6 其它命令</h3><table><thead><tr><th align="center">命令</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">apply</td><td align="center">通过文件名或标准输入对资源应用配置</td></tr><tr><td align="center">patch</td><td align="center">使用补丁修改、更新资源的字段</td></tr><tr><td align="center">replace</td><td align="center">通过文件名或标准输入替换一个资源</td></tr><tr><td align="center">convert</td><td align="center">不同的API版本之间转换配置文件</td></tr><tr><td align="center">label</td><td align="center">更新资源上的标签</td></tr><tr><td align="center">annotate</td><td align="center">更新资源上的注释</td></tr><tr><td align="center">completion</td><td align="center">用于实现kubectl工具自动补全</td></tr><tr><td align="center">api-versions</td><td align="center">打印受支持的API版本</td></tr><tr><td align="center">config</td><td align="center">修改kubeconfig文件（用于访问API，比如配置认证信息）</td></tr><tr><td align="center">help</td><td align="center">所有命令帮助</td></tr><tr><td align="center">plugin</td><td align="center">运行一个命令行插件</td></tr><tr><td align="center">version</td><td align="center">打印客户端和服务版本信息</td></tr></tbody></table><h3 id="3-7-目前使用的命令"><a href="#3-7-目前使用的命令" class="headerlink" title="3.7 目前使用的命令"></a>3.7 目前使用的命令</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个nginx镜像</span>kubectl create deployment nginx --image=nginx<span class="hljs-comment"># 对外暴露端口</span>kubectl expose deployment nginx --port=80 --<span class="hljs-built_in">type</span>=NodePort<span class="hljs-comment"># 查看资源</span>kubectl get pod, svc</code></pre></div><h1 id="第7章-Kubernetes集群YAML文件详解"><a href="#第7章-Kubernetes集群YAML文件详解" class="headerlink" title="第7章 Kubernetes集群YAML文件详解"></a>第7章 Kubernetes集群YAML文件详解</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h2><p>k8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，也就是可以把需要对资源对象操作编辑到YAML 格式文件中，我们把这种文件叫做资源清单文件，通过kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。一般在我们开发的时候，都是通过配置YAML文件来部署集群的。</p><p>YAML文件：就是资源清单文件，用于资源编排</p><h2 id="2-YAML文件介绍"><a href="#2-YAML文件介绍" class="headerlink" title="2 YAML文件介绍"></a>2 YAML文件介绍</h2><h3 id="2-1-YAML概述"><a href="#2-1-YAML概述" class="headerlink" title="2.1 YAML概述"></a>2.1 YAML概述</h3><p>YAML ：仍是一种标记语言。为了强调这种语言以数据做为中心，而不是以标记语言为重点。</p><p>YAML 是一个可读性高，用来表达数据序列的格式。</p><h3 id="2-2-YAML-基本语法"><a href="#2-2-YAML-基本语法" class="headerlink" title="2.2 YAML 基本语法"></a>2.2 YAML 基本语法</h3><ul><li>使用空格做为缩进</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li>低版本缩进时不允许使用Tab 键，只允许使用空格</li><li>使用#标识注释，从这个字符一直到行尾，都会被解释器忽略</li><li>使用 — 表示新的yaml文件开始</li></ul><h3 id="2-3-YAML-支持的数据结构"><a href="#2-3-YAML-支持的数据结构" class="headerlink" title="2.3 YAML 支持的数据结构"></a>2.3 YAML 支持的数据结构</h3><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>键值对的集合，又称为映射(mapping) / 哈希（hashes） / 字典（dictionary）</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 对象类型：对象的一组键值对，使用冒号结构表示</span><span class="hljs-attr">name:</span> <span class="hljs-string">Tom</span><span class="hljs-attr">age:</span> <span class="hljs-number">18</span><span class="hljs-comment"># yaml 也允许另一种写法，将所有键值对写成一个行内对象</span><span class="hljs-attr">hash:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">Tom</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">18</span>&#125;</code></pre></div><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 数组类型：一组连词线开头的行，构成一个数组</span>People- Tom- Jack<span class="hljs-comment"># 数组也可以采用行内表示法</span>People: [Tom, Jack]</code></pre></div><h2 id="3-YAML文件组成部分"><a href="#3-YAML文件组成部分" class="headerlink" title="3 YAML文件组成部分"></a>3 YAML文件组成部分</h2><p>主要分为了两部分，一个是控制器的定义和被控制的对象</p><h3 id="3-1-控制器的定义"><a href="#3-1-控制器的定义" class="headerlink" title="3.1 控制器的定义"></a>3.1 控制器的定义</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114110444032.png" alt="image-20201114110444032"></p><h3 id="3-2-被控制的对象"><a href="#3-2-被控制的对象" class="headerlink" title="3.2 被控制的对象"></a>3.2 被控制的对象</h3><p>包含一些 镜像，版本、端口等</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114110600165.png" alt="image-20201114110600165"></p><h3 id="3-3-属性说明"><a href="#3-3-属性说明" class="headerlink" title="3.3 属性说明"></a>3.3 属性说明</h3><p>在一个YAML文件的控制器定义中，有很多属性名称</p><table><thead><tr><th align="center">属性名称</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">apiVersion</td><td align="center">API版本</td></tr><tr><td align="center">kind</td><td align="center">资源类型</td></tr><tr><td align="center">metadata</td><td align="center">资源元数据</td></tr><tr><td align="center">spec</td><td align="center">资源规格</td></tr><tr><td align="center">replicas</td><td align="center">副本数量</td></tr><tr><td align="center">selector</td><td align="center">标签选择器</td></tr><tr><td align="center">template</td><td align="center">Pod模板</td></tr><tr><td align="center">metadata</td><td align="center">Pod元数据</td></tr><tr><td align="center">spec</td><td align="center">Pod规格</td></tr><tr><td align="center">containers</td><td align="center">容器配置</td></tr></tbody></table><h2 id="4-如何快速编写YAML文件"><a href="#4-如何快速编写YAML文件" class="headerlink" title="4 如何快速编写YAML文件"></a>4 如何快速编写YAML文件</h2><p>一般来说，我们很少自己手写YAML文件，因为这里面涉及到了很多内容，我们一般都会借助工具来创建</p><h3 id="使用kubectl-create命令"><a href="#使用kubectl-create命令" class="headerlink" title="使用kubectl create命令"></a>使用kubectl create命令</h3><p>这种方式一般用于资源没有部署的时候，我们可以直接创建一个YAML配置文件</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 尝试运行,并不会真正的创建镜像</span>kubectl create deployment web --image=nginx -o yaml --dry-run</code></pre></div><p>或者我们可以输出到一个文件中</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl create deployment web --image=nginx -o yaml --dry-run &gt; hello.yaml</code></pre></div><p>然后我们就在文件中直接修改即可</p><h3 id="使用kubectl-get命令导出yaml文件"><a href="#使用kubectl-get命令导出yaml文件" class="headerlink" title="使用kubectl get命令导出yaml文件"></a>使用kubectl get命令导出yaml文件</h3><p>可以首先查看一个目前已经部署的镜像</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get deploy</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114113115649.png" alt="image-20201114113115649"></p><p>然后我们导出 nginx的配置</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 注意 --export在新版本中已经被去除了</span>kubectl get deploy nginx -o=yaml --<span class="hljs-built_in">export</span> &gt; nginx.yaml</code></pre></div><p>然后会生成一个 <code>nginx.yaml</code> 的配置文件</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/7_Kubernetes%E9%9B%86%E7%BE%A4YAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/images/image-20201114184538797.png" alt="image-20201114184538797"></p><h1 id="第8章-Kubernetes核心技术Pod"><a href="#第8章-Kubernetes核心技术Pod" class="headerlink" title="第8章 Kubernetes核心技术Pod"></a>第8章 Kubernetes核心技术Pod</h1><h2 id="1-Pod概述"><a href="#1-Pod概述" class="headerlink" title="1 Pod概述"></a>1 Pod概述</h2><p>Pod是K8S系统中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最小资源对象模型，也是在K8S上运行容器化应用的资源对象，其它的资源对象都是用来支撑或者扩展Pod对象功能的，比如控制器对象是用来管控Pod对象的，Service或者Ingress资源对象是用来暴露Pod引用对象的，PersistentVolume资源对象是用来为Pod提供存储等等，K8S不会直接处理容器，而是Pod，Pod是由一个或多个container组成。</p><p>Pod是Kubernetes的最重要概念，每一个Pod都有一个特殊的被称为 “根容器”的Pause容器。Pause容器对应的镜像属于Kubernetes平台的一部分，除了Pause容器，每个Pod还包含一个或多个紧密相关的用户业务容器。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114185528215.png" alt="image-20201114185528215"></p><h3 id="Pod基本概念"><a href="#Pod基本概念" class="headerlink" title="Pod基本概念"></a>Pod基本概念</h3><ul><li>最小部署的单元</li><li>Pod里面是由一个或多个容器组成【一组容器的集合】</li><li>一个pod中的容器是共享网络命名空间</li><li>Pod是短暂的</li><li>每个Pod包含一个或多个紧密相关的用户业务容器</li></ul><h3 id="Pod存在的意义"><a href="#Pod存在的意义" class="headerlink" title="Pod存在的意义"></a>Pod存在的意义</h3><ul><li>创建容器使用docker，一个docker对应一个容器，一个容器运行一个应用进程</li><li>Pod是多进程设计，运用多个应用程序，也就是一个Pod里面有多个容器，而一个容器里面运行一个应用程序</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114190018948.png" alt="image-20201114190018948"></p><ul><li>Pod的存在是为了亲密性应用<ul><li>两个应用之间进行交互</li><li>网络之间的调用【通过127.0.0.1 或 socket】</li><li>两个应用之间需要频繁调用</li></ul></li></ul><p>Pod是在K8S集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。同时Pod对多容器的支持是K8S中最基础的设计理念。在生产环境中，通常是由不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。</p><p>Pod是K8S集群中所有业务类型的基础，可以把Pod看作运行在K8S集群上的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前K8S的业务主要可以分为以下几种</p><ul><li>长期伺服型：long-running</li><li>批处理型：batch</li><li>节点后台支撑型：node-daemon</li><li>有状态应用型：stateful application</li></ul><p>上述的几种类型，分别对应的小机器人控制器为：Deployment、Job、DaemonSet 和 StatefulSet  (后面将介绍控制器)</p><h2 id="2-Pod实现机制"><a href="#2-Pod实现机制" class="headerlink" title="2 Pod实现机制"></a>2 Pod实现机制</h2><p>主要有以下两大机制</p><ul><li>共享网络</li><li>共享存储</li></ul><h3 id="共享网络"><a href="#共享网络" class="headerlink" title="共享网络"></a>共享网络</h3><p>容器本身之间相互隔离的，一般是通过 <strong>namespace</strong> 和 <strong>group</strong> 进行隔离，那么Pod里面的容器如何实现通信？</p><ul><li>首先需要满足前提条件，也就是容器都在同一个<strong>namespace</strong>之间</li></ul><p>关于Pod实现原理，首先会在Pod会创建一个根容器： <code>pause容器</code>，然后我们在创建业务容器 【nginx，redis 等】，在我们创建业务容器的时候，会把它添加到 <code>info容器</code> 中</p><p>而在 <code>info容器</code> 中会独立出  ip地址，mac地址，port 等信息，然后实现网络的共享</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114190913859.png" alt="image-20201114190913859"></p><p>完整步骤如下</p><ul><li>通过 Pause 容器，把其它业务容器加入到Pause容器里，让所有业务容器在同一个名称空间中，可以实现网络共享</li></ul><h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>Pod持久化数据，专门存储到某个地方中</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114193124160.png" alt="image-20201114193124160"></p><p>使用 Volumn数据卷进行共享存储，案例如下所示</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114193341993.png" alt="image-20201114193341993"></p><h2 id="3-Pod镜像拉取策略"><a href="#3-Pod镜像拉取策略" class="headerlink" title="3 Pod镜像拉取策略"></a>3 Pod镜像拉取策略</h2><p>我们以具体实例来说，拉取策略就是 <code>imagePullPolicy</code></p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114193605230.png" alt="image-20201114193605230"></p><p>拉取策略主要分为了以下几种</p><ul><li>IfNotPresent：默认值，镜像在宿主机上不存在才拉取</li><li>Always：每次创建Pod都会重新拉取一次镜像</li><li>Never：Pod永远不会主动拉取这个镜像</li></ul><h2 id="4-Pod资源限制"><a href="#4-Pod资源限制" class="headerlink" title="4 Pod资源限制"></a>4 Pod资源限制</h2><p>也就是我们Pod在进行调度的时候，可以对调度的资源进行限制，例如我们限制 Pod调度是使用的资源是 2C4G，那么在调度对应的node节点时，只会占用对应的资源，对于不满足资源的节点，将不会进行调度</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194057920.png" alt="image-20201114194057920"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们在下面的地方进行资源的限制</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194245517.png" alt="image-20201114194245517"></p><p>这里分了两个部分</p><ul><li>request：表示调度所需的资源</li><li>limits：表示最大所占用的资源</li></ul><h2 id="5-Pod重启机制"><a href="#5-Pod重启机制" class="headerlink" title="5 Pod重启机制"></a>5 Pod重启机制</h2><p>因为Pod中包含了很多个容器，假设某个容器出现问题了，那么就会触发Pod重启机制</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194722125.png" alt="image-20201114194722125"></p><p>重启策略主要分为以下三种</p><ul><li>Always：当容器终止退出后，总是重启容器，默认策略 【nginx等，需要不断提供服务】</li><li>OnFailure：当容器异常退出（退出状态码非0）时，才重启容器。</li><li>Never：当容器终止退出，从不重启容器 【批量任务】</li></ul><h2 id="6-Pod健康检查"><a href="#6-Pod健康检查" class="headerlink" title="6 Pod健康检查"></a>6 Pod健康检查</h2><p>通过容器检查，原来我们使用下面的命令来检查</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pod</code></pre></div><p>但是有的时候，程序可能出现了 <strong>Java</strong> 堆内存溢出，程序还在运行，但是不能对外提供服务了，这个时候就不能通过 容器检查来判断服务是否可用了</p><p>这个时候就可以使用应用层面的检查</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 存活检查，如果检查失败，将杀死容器，根据Pod的restartPolicy【重启策略】来操作</span>livenessProbe<span class="hljs-comment"># 就绪检查，如果检查失败，Kubernetes会把Pod从Service endpoints中剔除</span>readinessProbe</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114195807564.png" alt="image-20201114195807564"></p><p>Probe支持以下三种检查方式</p><ul><li>http Get：发送HTTP请求，返回200 - 400 范围状态码为成功</li><li>exec：执行Shell命令返回状态码是0为成功</li><li>tcpSocket：发起TCP Socket建立成功</li></ul><h2 id="7-Pod调度策略"><a href="#7-Pod调度策略" class="headerlink" title="7 Pod调度策略"></a>7 Pod调度策略</h2><h3 id="创建Pod流程"><a href="#创建Pod流程" class="headerlink" title="创建Pod流程"></a>创建Pod流程</h3><ul><li>首先创建一个pod，然后创建一个API Server 和 Etcd【把创建出来的信息存储在etcd中】</li><li>然后创建 Scheduler，监控API Server是否有新的Pod，如果有的话，会通过调度算法，把pod调度某个node上</li><li>在node节点，会通过 <code>kubelet -- apiserver</code> 读取etcd 拿到分配在当前node节点上的pod，然后通过docker创建容器</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114201611308.png" alt="image-20201114201611308"></p><h3 id="影响Pod调度的属性"><a href="#影响Pod调度的属性" class="headerlink" title="影响Pod调度的属性"></a>影响Pod调度的属性</h3><p>Pod资源限制对Pod的调度会有影响</p><h4 id="根据request找到足够node节点进行调度"><a href="#根据request找到足够node节点进行调度" class="headerlink" title="根据request找到足够node节点进行调度"></a>根据request找到足够node节点进行调度</h4><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114194245517.png" alt="image-20201114194245517"></p><h4 id="节点选择器标签影响Pod调度"><a href="#节点选择器标签影响Pod调度" class="headerlink" title="节点选择器标签影响Pod调度"></a>节点选择器标签影响Pod调度</h4><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114202456151.png" alt="image-20201114202456151"></p><p>关于节点选择器，其实就是有两个环境，然后环境之间所用的资源配置不同</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114202643905.png" alt="image-20201114202643905"></p><p>我们可以通过以下命令，给我们的节点新增标签，然后节点选择器就会进行调度了</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl label node node1 env_role=prod</code></pre></div><h4 id="节点亲和性"><a href="#节点亲和性" class="headerlink" title="节点亲和性"></a>节点亲和性</h4><p>节点亲和性 <strong>nodeAffinity</strong> 和 之前nodeSelector 基本一样的，根据节点上标签约束来决定Pod调度到哪些节点上</p><ul><li>硬亲和性：约束条件必须满足</li><li>软亲和性：尝试满足，不保证</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114203433939.png" alt="image-20201114203433939"></p><p>支持常用操作符：in、NotIn、Exists、Gt、Lt、DoesNotExists</p><p>反亲和性：就是和亲和性刚刚相反，如 NotIn、DoesNotExists等</p><h2 id="8-污点和污点容忍"><a href="#8-污点和污点容忍" class="headerlink" title="8 污点和污点容忍"></a>8 污点和污点容忍</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><p>nodeSelector 和 NodeAffinity，都是Prod调度到某些节点上，属于Pod的属性，是在调度的时候实现的。</p><p>Taint 污点：节点不做普通分配调度，是节点属性</p><h3 id="8-2-场景"><a href="#8-2-场景" class="headerlink" title="8.2 场景"></a>8.2 场景</h3><ul><li>专用节点【限制ip】</li><li>配置特定硬件的节点【固态硬盘】</li><li>基于Taint驱逐【在node1不放，在node2放】</li></ul><h3 id="8-3-查看污点情况"><a href="#8-3-查看污点情况" class="headerlink" title="8.3 查看污点情况"></a>8.3 查看污点情况</h3><div class="code-wrapper"><pre><code class="hljs bash">kubectl describe node k8smaster | grep Taint</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114204124819.png" alt="image-20201114204124819"></p><p>污点值有三个</p><ul><li>NoSchedule：一定不被调度</li><li>PreferNoSchedule：尽量不被调度【也有被调度的几率】</li><li>NoExecute：不会调度，并且还会驱逐Node已有Pod</li></ul><h3 id="8-4-未节点添加污点"><a href="#8-4-未节点添加污点" class="headerlink" title="8.4 未节点添加污点"></a>8.4 未节点添加污点</h3><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node [node] key=value:污点的三个值</code></pre></div><p>举例：</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role=yes:NoSchedule</code></pre></div><h3 id="8-5-删除污点"><a href="#8-5-删除污点" class="headerlink" title="8.5 删除污点"></a>8.5 删除污点</h3><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role:NoSchedule-</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114210022883.png" alt="image-20201114210022883"></p><h3 id="8-6-演示"><a href="#8-6-演示" class="headerlink" title="8.6 演示"></a>8.6 演示</h3><p>我们现在创建多个Pod，查看最后分配到Node上的情况</p><p>首先我们创建一个 nginx 的pod</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl create deployment web --image=nginx</code></pre></div><p>然后使用命令查看</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods -o wide</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114204917548.png" alt="image-20201114204917548"></p><p>我们可以非常明显的看到，这个Pod已经被分配到 k8snode1 节点上了</p><p>下面我们把pod复制5份，在查看情况pod情况</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl scale deployment web --replicas=5</code></pre></div><p>我们可以发现，因为master节点存在污点的情况，所以节点都被分配到了 node1 和 node2节点上</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114205135282.png" alt="image-20201114205135282"></p><p>我们可以使用下面命令，把刚刚我们创建的pod都删除</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl delete deployment web</code></pre></div><p>现在给了更好的演示污点的用法，我们现在给 node1节点打上污点</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role=yes:NoSchedule</code></pre></div><p>然后我们查看污点是否成功添加</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl describe node k8snode1 | grep Taint</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114205516154.png" alt="image-20201114205516154"></p><p>然后我们在创建一个 pod</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建nginx pod</span>kubectl create deployment web --image=nginx<span class="hljs-comment"># 复制五次</span>kubectl scale deployment web --replicas=5</code></pre></div><p>然后我们在进行查看</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods -o wide</code></pre></div><p>我们能够看到现在所有的pod都被分配到了 k8snode2上，因为刚刚我们给node1节点设置了污点</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114205654867.png" alt="image-20201114205654867"></p><p>最后我们可以删除刚刚添加的污点</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl taint node k8snode1 env_role:NoSchedule-</code></pre></div><h3 id="8-7-污点容忍"><a href="#8-7-污点容忍" class="headerlink" title="8.7 污点容忍"></a>8.7 污点容忍</h3><p>污点容忍就是某个节点可能被调度，也可能不被调度</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/8_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/images/image-20201114210146123.png" alt="image-20201114210146123"></p><h1 id="第9章-Kubernetes核心技术-Controller"><a href="#第9章-Kubernetes核心技术-Controller" class="headerlink" title="第9章 Kubernetes核心技术-Controller"></a>第9章 Kubernetes核心技术-Controller</h1><h2 id="1-内容"><a href="#1-内容" class="headerlink" title="1 内容"></a>1 内容</h2><ul><li>什么是Controller</li><li>Pod和Controller的关系</li><li>Deployment控制器应用场景</li><li>yaml文件字段说明</li><li>Deployment控制器部署应用</li><li>升级回滚</li><li>弹性伸缩</li></ul><h2 id="2-什么是Controller"><a href="#2-什么是Controller" class="headerlink" title="2 什么是Controller"></a>2 什么是Controller</h2><p>Controller是在集群上管理和运行容器的对象，Controller是实际存在的，Pod是虚拟机的</p><h2 id="3-Pod和Controller的关系"><a href="#3-Pod和Controller的关系" class="headerlink" title="3 Pod和Controller的关系"></a>3 Pod和Controller的关系</h2><p>Pod是通过Controller实现应用的运维，比如弹性伸缩，滚动升级等</p><p>Pod 和 Controller之间是通过label标签来建立关系，同时Controller又被称为控制器工作负载</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116092431237.png" alt="image-20201116092431237"></p><h2 id="4-Deployment控制器应用"><a href="#4-Deployment控制器应用" class="headerlink" title="4 Deployment控制器应用"></a>4 Deployment控制器应用</h2><ul><li>Deployment控制器可以部署无状态应用</li><li>管理Pod和ReplicaSet</li><li>部署，滚动升级等功能</li><li>应用场景：web服务，微服务</li></ul><p>Deployment表示用户对K8S集群的一次更新操作。Deployment是一个比RS( Replica Set, RS) 应用模型更广的 API 对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧RS中的副本数减少到0的复合操作。</p><p>这样一个复合操作用一个RS是不好描述的，所以用一个更通用的Deployment来描述。以K8S的发展方向，未来对所有长期伺服型的业务的管理，都会通过Deployment来管理。</p><h2 id="5-Deployment部署应用"><a href="#5-Deployment部署应用" class="headerlink" title="5 Deployment部署应用"></a>5 Deployment部署应用</h2><p>之前我们也使用Deployment部署过应用，如下代码所示</p><div class="code-wrapper"><pre><code class="hljs bash">kubectrl create deployment web --image=nginx</code></pre></div><p>但是上述代码不是很好的进行复用，因为每次我们都需要重新输入代码，所以我们都是通过YAML进行配置</p><p>但是我们可以尝试使用上面的代码创建一个镜像【只是尝试，不会创建】</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl create deployment web --image=nginx --dry-run -o yaml &gt; nginx.yaml</code></pre></div><p>然后输出一个yaml配置文件 <code>nginx.yml</code> ，配置文件如下所示</p><div class="code-wrapper"><pre><code class="hljs bash">apiVersion: apps/v1kind: Deploymentmetadata:  creationTimestamp: null  labels:    app: web  name: webspec:  replicas: 1  selector:    matchLabels:      app: web  strategy: &#123;&#125;  template:    metadata:      creationTimestamp: null      labels:        app: web    spec:      containers:      - image: nginx        name: nginx        resources: &#123;&#125;status: &#123;&#125;</code></pre></div><p>我们看到的 selector 和 label 就是我们Pod 和 Controller之间建立关系的桥梁</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116093638951.png" alt="image-20201116093638951"></p><h3 id="使用YAML创建Pod"><a href="#使用YAML创建Pod" class="headerlink" title="使用YAML创建Pod"></a>使用YAML创建Pod</h3><p>通过刚刚的代码，我们已经生成了YAML文件，下面我们就可以使用该配置文件快速创建Pod镜像了</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl apply -f nginx.yaml</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116094046007.png" alt="image-20201116094046007"></p><p>但是因为这个方式创建的，我们只能在集群内部进行访问，所以我们还需要对外暴露端口</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl expose deployment web --port=80 --<span class="hljs-built_in">type</span>=NodePort --target-port=80 --name=web1</code></pre></div><p>关于上述命令，有几个参数</p><ul><li>–port：就是我们内部的端口号</li><li>–target-port：就是暴露外面访问的端口号</li><li>–name：名称</li><li>–type：类型</li></ul><p>同理，我们一样可以导出对应的配置文件</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl expose deployment web --port=80 --<span class="hljs-built_in">type</span>=NodePort --target-port=80 --name=web1 -o yaml &gt; web1.yaml</code></pre></div><p>得到的web1.yaml如下所示</p><div class="code-wrapper"><pre><code class="hljs bash">apiVersion: v1kind: Servicemetadata:  creationTimestamp: <span class="hljs-string">&quot;2020-11-16T02:26:53Z&quot;</span>  labels:    app: web  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:metadata:        f:labels:          .: &#123;&#125;          f:app: &#123;&#125;      f:spec:        f:externalTrafficPolicy: &#123;&#125;        f:ports:          .: &#123;&#125;          k:&#123;<span class="hljs-string">&quot;port&quot;</span>:80,<span class="hljs-string">&quot;protocol&quot;</span>:<span class="hljs-string">&quot;TCP&quot;</span>&#125;:            .: &#123;&#125;            f:port: &#123;&#125;            f:protocol: &#123;&#125;            f:targetPort: &#123;&#125;        f:selector:          .: &#123;&#125;          f:app: &#123;&#125;        f:sessionAffinity: &#123;&#125;        f:<span class="hljs-built_in">type</span>: &#123;&#125;    manager: kubectl    operation: Update    time: <span class="hljs-string">&quot;2020-11-16T02:26:53Z&quot;</span>  name: web2  namespace: default  resourceVersion: <span class="hljs-string">&quot;113693&quot;</span>  selfLink: /api/v1/namespaces/default/services/web2  uid: d570437d-a6b4-4456-8dfb-950f09534516spec:  clusterIP: 10.104.174.145  externalTrafficPolicy: Cluster  ports:  - nodePort: 32639    port: 80    protocol: TCP    targetPort: 80  selector:    app: web  sessionAffinity: None  <span class="hljs-built_in">type</span>: NodePortstatus:  loadBalancer: &#123;&#125;</code></pre></div><p>然后我们可以通过下面的命令来查看对外暴露的服务</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl get pods,svc</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116104021357.png" alt="image-20201116104021357"></p><p>然后我们访问对应的url，即可看到 nginx了 <code>http://192.168.177.130:32639/</code></p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116104131968.png" alt="image-20201116104131968"></p><h2 id="6-升级回滚和弹性伸缩"><a href="#6-升级回滚和弹性伸缩" class="headerlink" title="6 升级回滚和弹性伸缩"></a>6 升级回滚和弹性伸缩</h2><ul><li>升级：  假设从版本为1.14 升级到 1.15 ，这就叫应用的升级【升级可以保证服务不中断】</li><li>回滚：从版本1.15 变成 1.14，这就叫应用的回滚</li><li>弹性伸缩：我们根据不同的业务场景，来改变Pod的数量对外提供服务，这就是弹性伸缩</li></ul><h3 id="应用升级和回滚"><a href="#应用升级和回滚" class="headerlink" title="应用升级和回滚"></a>应用升级和回滚</h3><p>首先我们先创建一个 1.14版本的Pod</p><div class="code-wrapper"><pre><code class="hljs bash">apiVersion: apps/v1kind: Deploymentmetadata:  creationTimestamp: null  labels:    app: web  name: webspec:  replicas: 1  selector:    matchLabels:      app: web  strategy: &#123;&#125;  template:    metadata:      creationTimestamp: null      labels:        app: web    spec:      containers:      - image: nginx:1.14        name: nginx        resources: &#123;&#125;status: &#123;&#125;</code></pre></div><p>我们先指定版本为1.14，然后开始创建我们的Pod</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl apply -f nginx.yaml</code></pre></div><p>同时，我们使用docker images命令，就能看到我们成功拉取到了一个 1.14版本的镜像</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116105710966.png" alt="image-20201116105710966"></p><p>我们使用下面的命令，可以将nginx从 1.14 升级到 1.15</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">set</span> image deployment web nginx=nginx:1.15</code></pre></div><p>在我们执行完命令后，能看到升级的过程</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116105847069.png" alt="image-20201116105847069"></p><ul><li>首先是开始的nginx 1.14版本的Pod在运行，然后 1.15版本的在创建</li><li>然后在1.15版本创建完成后，就会暂停1.14版本</li><li>最后把1.14版本的Pod移除，完成我们的升级</li></ul><p>我们在下载 1.15版本，容器就处于ContainerCreating状态，然后下载完成后，就用 1.15版本去替换1.14版本了，这么做的好处就是：升级可以保证服务不中断</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116111614085.png" alt="image-20201116111614085"></p><p>我们到我们的node2节点上，查看我们的 docker images;</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116111315000.png" alt="image-20201116111315000"></p><p>能够看到，我们已经成功拉取到了 1.15版本的nginx了</p><h4 id="查看升级状态"><a href="#查看升级状态" class="headerlink" title="查看升级状态"></a>查看升级状态</h4><p>下面可以，查看升级状态</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout status deployment web</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116112139645.png" alt="image-20201116112139645"></p><h4 id="查看历史版本"><a href="#查看历史版本" class="headerlink" title="查看历史版本"></a>查看历史版本</h4><p>我们还可以查看历史版本</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout <span class="hljs-built_in">history</span> deployment web</code></pre></div><h4 id="应用回滚"><a href="#应用回滚" class="headerlink" title="应用回滚"></a>应用回滚</h4><p>我们可以使用下面命令，完成回滚操作，也就是回滚到上一个版本</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout undo deployment web</code></pre></div><p>然后我们就可以查看状态</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout status deployment web</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201116112524601.png" alt="image-20201116112524601"></p><p>同时我们还可以回滚到指定版本</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl rollout undo deployment web --to-revision=2</code></pre></div><h3 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h3><p>弹性伸缩，也就是我们通过命令一下创建多个副本</p><div class="code-wrapper"><pre><code class="hljs bash">kubectl scale deployment web --replicas=10</code></pre></div><p>能够清晰看到，我们一下创建了10个副本</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/K8S/9_Kubernetes%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/images/image-20201117092841865.png" alt="image-20201117092841865"></p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Distributed/">Distributed</category>
      
      
      <category domain="https://pncalbl.github.io/tags/k8s/">k8s</category>
      
      
      <comments>https://pncalbl.github.io/2021/07/22/K8s%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM 学习</title>
      <link>https://pncalbl.github.io/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Mon, 19 Jul 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;第一部分-内存与垃圾回收&quot;&gt;&lt;a href=&quot;#第一部分-内存与垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;第一部分 内存与垃圾回收&quot;&gt;&lt;/a&gt;第一部分 内存与垃圾回收&lt;/h1&gt;&lt;h1 id=&quot;第1章-JVM与Java体系结构&quot;&gt;&lt;a href</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="第一部分-内存与垃圾回收"><a href="#第一部分-内存与垃圾回收" class="headerlink" title="第一部分 内存与垃圾回收"></a>第一部分 内存与垃圾回收</h1><h1 id="第1章-JVM与Java体系结构"><a href="#第1章-JVM与Java体系结构" class="headerlink" title="第1章 JVM与Java体系结构"></a>第1章 JVM与Java体系结构</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？</p><p>运行着的线上系统突然卡死，系统无法访问，甚至直接OOMM！</p><ul><li>想解决线上JVM GC问题，但却无从下手。</li><li>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了</li><li>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704111417472.png" alt="image-20200704111417472"></p><p>大部分Java开发人员，除会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</p><p>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</p><p>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704112119729.png" alt="image-20200704112119729"></p><h2 id="2-架构师每天都在思考什么？"><a href="#2-架构师每天都在思考什么？" class="headerlink" title="2 架构师每天都在思考什么？"></a>2 架构师每天都在思考什么？</h2><ul><li>应该如何让我的系统更快？</li><li>如何避免系统出现瓶颈？</li></ul><p>知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？</p><ul><li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li><li>根据业务场景和需求，决定技术方向，做技术选型</li><li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li><li>解决各类潜在系统风险，核心功能的架构与代码编写</li><li>分析系统瓶颈，解决各种疑难杂症，性能调优等</li></ul><h2 id="3-为什么要学习JVM"><a href="#3-为什么要学习JVM" class="headerlink" title="3 为什么要学习JVM"></a>3 为什么要学习JVM</h2><ul><li><p>面试的需要（BATJ、TMD，PKQ等面试都爱问）</p></li><li><p>中高级程序员必备技能</p><ul><li>项目管理、调优的需求</li></ul></li><li><p>追求极客的精神</p><ul><li>比如：垃圾回收算法、JIT（及时编译器）、底层原理</li></ul></li></ul><h2 id="4-Java-vs-C"><a href="#4-Java-vs-C" class="headerlink" title="4 Java vs C++"></a>4 Java vs C++</h2><p>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704112700211.png" alt="image-20200704112700211"></p><p>C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。</p><h2 id="5-推荐书籍"><a href="#5-推荐书籍" class="headerlink" title="5 推荐书籍"></a>5 推荐书籍</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704145340513.png" alt="image-20200704145340513"></p><h2 id="6-Java生态圈"><a href="#6-Java生态圈" class="headerlink" title="6 Java生态圈"></a>6 Java生态圈</h2><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p><ul><li><p>作为一个平台，Java虚拟机扮演着举足轻重的作用</p><ul><li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li></ul></li><li><p>作为灯种文化，Java几乎成为了“开源”的代名词。</p><ul><li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li><li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li></ul></li><li><p>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</p></li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704151731216.png" alt="image-20200704151731216"></p><p>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704152052489.png" alt="image-20200704152052489"></p><p>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</p><p>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p><h2 id="7-字节码"><a href="#7-字节码" class="headerlink" title="7 字节码"></a>7 字节码</h2><p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</p><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p><p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</p><h2 id="8-多语言混合编程"><a href="#8-多语言混合编程" class="headerlink" title="8 多语言混合编程"></a>8 多语言混合编程</h2><p>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p><p>试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</p><p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</p><h2 id="9-Java发展的重大事件"><a href="#9-Java发展的重大事件" class="headerlink" title="9 Java发展的重大事件"></a>9 Java发展的重大事件</h2><ul><li><p>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java</p></li><li><p>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</p></li><li><p>1996年1月23日sun Microsystems发布了JDK 1.0。</p></li><li><p>1998年，JDK1.2版本发布。同时，sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</p></li><li><p>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</p></li><li><p>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</p></li><li><p>2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</p></li><li><p>2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</p></li><li><p>2006年，JDK6发布。同年，Java开源并建立了openJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。</p></li><li><p>2007年，Java平台迎来了新伙伴Clojure。</p></li><li><p>2008年，oracle收购了BEA，得到了JRockit虚拟机。</p></li><li><p>2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。</p></li><li><p>2010年，oracle收购了sun，获得Java商标和最真价值的HotSpot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit</p></li><li><p>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</p></li><li><p>2017年，JDK9发布。将G1设置为默认Gc，替代CMS</p></li><li><p>同年，IBM的J9开源，形成了现在的open J9社区</p></li><li><p>2018年，Android的Java侵权案判决，Google赔偿oracle计88亿美元</p></li><li><p>同年，oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</p></li><li><p>同年，JDK11发布，LTS版本的JDK，发布革命性的zGc，调整JDK授权许可</p></li><li><p>2019年，JDK12发布，加入RedHat领导开发的shenandoah GC</p></li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704182035810.png" alt="image-20200704182035810"></p><p>在JDK11之前，oracleJDK中还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，我们可以认为openJDK和oracleJDK代码实质上已经完全一致的程度。</p><h2 id="10-虚拟机与Java虚拟机"><a href="#10-虚拟机与Java虚拟机" class="headerlink" title="10 虚拟机与Java虚拟机"></a>10 虚拟机与Java虚拟机</h2><h3 id="10-1-虚拟机"><a href="#10-1-虚拟机" class="headerlink" title="10.1 虚拟机"></a>10.1 虚拟机</h3><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li>大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。</li><li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li></ul><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p><h3 id="10-2-Java虚拟机"><a href="#10-2-Java虚拟机" class="headerlink" title="10.2 Java虚拟机"></a>10.2 Java虚拟机</h3><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p><p>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p><p>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</p><p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p>特点：</p><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><h2 id="11-JVM的位置"><a href="#11-JVM的位置" class="headerlink" title="11 JVM的位置"></a>11 JVM的位置</h2><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704183048061.png" alt="image-20200704183048061"></p><p>Java的体系结构</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704183236169.png" alt="image-20200704183236169"></p><h2 id="12-JVM整体结构"><a href="#12-JVM整体结构" class="headerlink" title="12 JVM整体结构"></a>12 JVM整体结构</h2><ul><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704183436495.png" alt="image-20200704183436495"></p><p>执行引擎包含三部分：解释器，及时编译器，垃圾回收器</p><h2 id="13-Java代码执行流程"><a href="#13-Java代码执行流程" class="headerlink" title="13 Java代码执行流程"></a>13 Java代码执行流程</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/1_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/images/image-20200704210429535.png" alt="image-20200704210429535"></p><p>只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了</p><h2 id="14-JVM的架构模型"><a href="#14-JVM的架构模型" class="headerlink" title="14 JVM的架构模型"></a>14 JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p><p>基于栈式架构的特点</p><ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配。</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul><p>基于寄存器架构的特点</p><ul><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作。</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p><p>基于栈的计算流程（以Java虚拟机为例）：</p><div class="code-wrapper"><pre><code class="hljs bash">iconst_2 //常量2入栈istore_1iconst_3 // 常量3入栈istore_2iload_1iload_2iadd //常量2/3出栈，执行相加istore_0 // 结果5入栈</code></pre></div><p>而基于寄存器的计算流程</p><div class="code-wrapper"><pre><code class="hljs bash">mov eax,2 //将eax寄存器的值设为1add eax,3 //使eax寄存器的值加3</code></pre></div><h3 id="字节码反编译"><a href="#字节码反编译" class="headerlink" title="字节码反编译"></a>字节码反编译</h3><p>我们编写一个简单的代码，然后查看一下字节码的反编译后的结果</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> pncalbl</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/7/20 21:31</span><span class="hljs-comment"> * <span class="hljs-doctag">@e</span>-mail pncalbl@qq.com</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackStruTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;    &#125;&#125;</code></pre></div><p>然后我们找到编译后的 class文件，使用下列命令进行反编译</p><div class="code-wrapper"><pre><code class="hljs bash">javap -v StackStruTest.class</code></pre></div><p>得到的文件为:</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">public</span> static void main(java.lang.String[]);  <span class="hljs-attribute">descriptor</span>: ([Ljava/lang/String;)V  <span class="hljs-attribute">flags</span>: ACC_PUBLIC, ACC_STATIC  <span class="hljs-attribute">Code</span>:    <span class="hljs-attribute">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span>       <span class="hljs-attribute">0</span>: iconst_<span class="hljs-number">2</span>       <span class="hljs-attribute">1</span>: istore_<span class="hljs-number">1</span>       <span class="hljs-attribute">2</span>: iconst_<span class="hljs-number">3</span>       <span class="hljs-attribute">3</span>: istore_<span class="hljs-number">2</span>       <span class="hljs-attribute">4</span>: iload_<span class="hljs-number">1</span>       <span class="hljs-attribute">5</span>: iload_<span class="hljs-number">2</span>       <span class="hljs-attribute">6</span>: iadd       <span class="hljs-attribute">7</span>: istore_<span class="hljs-number">3</span>       <span class="hljs-attribute">8</span>: return    <span class="hljs-attribute">LineNumberTable</span>:      <span class="hljs-attribute">line</span> <span class="hljs-number">9</span>: <span class="hljs-number">0</span>      <span class="hljs-attribute">line</span> <span class="hljs-number">10</span>: <span class="hljs-number">2</span>      <span class="hljs-attribute">line</span> <span class="hljs-number">11</span>: <span class="hljs-number">4</span>      <span class="hljs-attribute">line</span> <span class="hljs-number">12</span>: <span class="hljs-number">8</span>    <span class="hljs-attribute">LocalVariableTable</span>:      <span class="hljs-attribute">Start</span>  Length  Slot  Name   Signature          <span class="hljs-attribute">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args  <span class="hljs-meta"> [Ljava/lang/String;</span><span class="hljs-meta">          2       7     1     i   I</span><span class="hljs-meta">          4       5     2     j   I</span><span class="hljs-meta">          8       1     3     k   I</span></code></pre></div><h2 id="15-总结"><a href="#15-总结" class="headerlink" title="15 总结"></a>15 总结</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>跨平台性</li><li>指令集小</li><li>指令多</li><li>执行性能比寄存器差</li></ul><h2 id="16-JVM生命周期"><a href="#16-JVM生命周期" class="headerlink" title="16 JVM生命周期"></a>16 JVM生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li></ul><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下的几种情况：</p><ul><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常或错误而异常终止</p></li><li><p>由于操作系统用现错误而导致Java虚拟机进程终止</p></li><li><p>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</p></li><li><p>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</p></li></ul><h2 id="17-JVM发展历程"><a href="#17-JVM发展历程" class="headerlink" title="17 JVM发展历程"></a>17 JVM发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul><li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</li><li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在hotspot内置了此虚拟机。</li></ul><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><p>为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。<br>Exact Memory Management：准确式内存管理</p><ul><li>也可以叫Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型。|</li></ul><p>具备现代高性能虚拟机的维形</p><ul><li>热点探测（寻找出热点代码进行缓存）</li><li>编译器与解释器混合工作模式</li></ul><p>只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p><h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><p>HotSpot历史</p><ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。</li><li>JDK1.3时，HotSpot VM成为默认虚拟机</li></ul><p>目前Hotspot占有绝对的市场地位，称霸武林。</p><ul><li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li><li>Sun/oracle JDK和openJDK的默认虚拟机</li><li>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念）</li></ul><p>从服务器、桌面到移动端、嵌入式都有应用。</p><p>名称中的HotSpot指的就是它的热点代码探测技术。</p><ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul><h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><p>专注于服务器端应用</p><ul><li>它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li></ul><p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</p><ul><li>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li></ul><p>优势：全面的Java运行时解决方案组合</p><ul><li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li><li>MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul><p>2008年，JRockit被oracle收购。</p><p>oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p><h3 id="IBM的J9"><a href="#IBM的J9" class="headerlink" title="IBM的J9"></a>IBM的J9</h3><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p><p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p><p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</p><p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9</p><p>OpenJDK   -&gt; 是JDK开源了，包括了虚拟机</p><h3 id="KVM和CDC-CLDC-Hotspot"><a href="#KVM和CDC-CLDC-Hotspot" class="headerlink" title="KVM和CDC / CLDC  Hotspot"></a>KVM和CDC / CLDC  Hotspot</h3><p>oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。</p><p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li>智能控制器、传感器</li><li>老人手机、经济欠发达地区的功能手机</li></ul><p>所有的虚拟机的原则：一次编译，到处运行。</p><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><p>前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azu1VW和BEALiquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机I</p><ul><li>高性能Java虚拟机中的战斗机。</li></ul><p>Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。</p><p>每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</p><p>2010年，AzulSystems公司开始从硬件转向软件，发布了自己的zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</p><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><p>高性能Java虚拟机中的战斗机。</p><p>BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition），</p><p>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</p><p>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</p><h3 id="Apache-Marmony"><a href="#Apache-Marmony" class="headerlink" title="Apache Marmony"></a>Apache Marmony</h3><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p><p>它是IElf和Inte1联合开发的开源JVM，受到同样开源的openJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p><p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p><h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p><p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p><p>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXPSP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。</p><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p><p>基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。</p><p>基于openJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p><ul><li>创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且Gc不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。</li><li>GCIH中的对象还能够在多个Java虚拟机进程中实现共享</li><li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li><li>PMU hardware的Java profiling tool和诊断协助功能</li><li>针对大数据场景的ZenGc </li></ul><p>taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</p><p>目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。</p><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p><p>Dalvik y只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范</p><p>不能直接执行Java的Class文件</p><p>基于寄存器架构，不是jvm的栈架构。</p><p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p><ul><li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li></ul><p>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</p><h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><p>2018年4月，oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p><p>GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”<br>的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p><p>如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle HotSpot VM为默认虚拟机。</p><h1 id="第2章-类加载子系统"><a href="#第2章-类加载子系统" class="headerlink" title="第2章 类加载子系统"></a>第2章 类加载子系统</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705080719531.png" alt="image-20200705080719531"></p><p>完整图如下</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705080911284.png" alt="image-20200705080911284"></p><p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p><ul><li>类加载器</li><li>执行引擎</li></ul><h2 id="2-类加载器子系统作用"><a href="#2-类加载器子系统作用" class="headerlink" title="2 类加载器子系统作用"></a>2 类加载器子系统作用</h2><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705081813409.png" alt="image-20200705081813409"></p><ul><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li><li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705081913538.png" alt="image-20200705081913538"></p><h2 id="3-类的加载过程"><a href="#3-类的加载过程" class="headerlink" title="3 类的加载过程"></a>3 类的加载过程</h2><p>例如下面的一段简单的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloLoader</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;我已经被加载啦&quot;</span>);    &#125;&#125;</code></pre></div><p>它的加载过程是怎么样的呢?</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705082255746.png" alt="image-20200705082255746"></p><p>完整的流程图如下所示</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705082601441.png" alt="image-20200705082601441"></p><h2 id="4-加载阶段"><a href="#4-加载阶段" class="headerlink" title="4 加载阶段"></a>4 加载阶段</h2><p>通过一个类的全限定名获取定义此类的二进制字节流</p><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><h3 id="4-1-加载class文件的方式"><a href="#4-1-加载class文件的方式" class="headerlink" title="4.1 加载class文件的方式"></a>4.1 加载class文件的方式</h3><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h3 id="4-2-链接阶段"><a href="#4-2-链接阶段" class="headerlink" title="4.2 链接阶段"></a>4.2 链接阶段</h3><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p><blockquote><p>工具：Binary Viewer查看</p></blockquote><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705084038680.png" alt="image-20200705084038680"></p><p>如果出现不合法的字节码文件，那么将会验证不通过</p><p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705090237078.png" alt="image-20200705090237078"></p><p>安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705090328171.png" alt="image-20200705090328171"></p><h3 id="4-3-准备-Prepare"><a href="#4-3-准备-Prepare" class="headerlink" title="4.3 准备 Prepare"></a>4.3 准备 Prepare</h3><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloApp</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(a);    &#125;&#125;</code></pre></div><p>上面的变量a在准备阶段会赋初始值，但不是1，而是0。</p><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p><p>例如下面这段代码</p><h3 id="4-4-解析-Resolve"><a href="#4-4-解析-Resolve" class="headerlink" title="4.4 解析 Resolve"></a>4.4 解析 Resolve</h3><p>将常量池内的符号引用转换为直接引用的过程。</p><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p><h3 id="4-5-初始化阶段"><a href="#4-5-初始化阶段" class="headerlink" title="4.5 初始化阶段"></a>4.5 初始化阶段</h3><p>初始化阶段就是执行类构造器法<clinit>（）的过程。</clinit></p><p>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p><ul><li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li></ul><p>构造器方法中指令按语句在源文件中出现的顺序执行。</p><p><clinit>（）不同于类的构造器。（关联：构造器是虚拟机视角下的<init>（））若该类具有父类，JVM会保证子类的<clinit>（）执行前，父类的<clinit>（）已经执行完毕。</clinit></clinit></init></clinit></p><ul><li>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassInitTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> &#123;        num = <span class="hljs-number">2</span>;        number = <span class="hljs-number">20</span>;        System.out.println(num);        System.out.println(number);  <span class="hljs-comment">//报错，非法的前向引用</span>    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(ClassInitTest.num); <span class="hljs-comment">// 2</span>        System.out.println(ClassInitTest.number); <span class="hljs-comment">// 10</span>    &#125;&#125;</code></pre></div><p>关于涉及到父类时候的变量赋值过程</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClinitTest1</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">1</span>;        <span class="hljs-keyword">static</span> &#123;            A = <span class="hljs-number">2</span>;        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = A;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(Son.b);    &#125;&#125;</code></pre></div><p>我们输出结果为 2，也就是说首先加载ClinitTest1的时候，会找到main方法，然后执行Son的初始化，但是Son继承了Father，因此还需要执行Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被复制成2，最后返回</p><div class="code-wrapper"><pre><code class="hljs bash">iconst_1putstatic <span class="hljs-comment">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span>iconst_2putstatic <span class="hljs-comment">#2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><span class="hljs-built_in">return</span></code></pre></div><p>虚拟机必须保证一个类的<clinit>（）方法在多线程下被同步加锁。</clinit></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadThreadTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 线程t1开始&quot;</span>);            <span class="hljs-keyword">new</span> DeadThread();        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 线程t2开始&quot;</span>);            <span class="hljs-keyword">new</span> DeadThread();        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadThread</span> </span>&#123;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 初始化当前类&quot;</span>);            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>上面的代码，输出结果为</p><div class="code-wrapper"><pre><code class="hljs mipsasm">线程<span class="hljs-built_in">t1</span>开始线程<span class="hljs-built_in">t2</span>开始线程<span class="hljs-built_in">t2</span> 初始化当前类</code></pre></div><p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p><h2 id="5-类加载器的分类"><a href="#5-类加载器的分类" class="headerlink" title="5 类加载器的分类"></a>5 类加载器的分类</h2><p>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705094149223.png" alt="image-20200705094149223"></p><p>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。</p><p>我们通过一个类，获取它不同的加载器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 获取系统类加载器</span>        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);        <span class="hljs-comment">// 获取其上层的：扩展类加载器</span>        ClassLoader extClassLoader = systemClassLoader.getParent();        System.out.println(extClassLoader);        <span class="hljs-comment">// 试图获取 根加载器</span>        ClassLoader bootstrapClassLoader = extClassLoader.getParent();        System.out.println(bootstrapClassLoader);        <span class="hljs-comment">// 获取自定义加载器</span>        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();        System.out.println(classLoader);                <span class="hljs-comment">// 获取String类型的加载器</span>        ClassLoader classLoader1 = String.class.getClassLoader();        System.out.println(classLoader1);    &#125;&#125;</code></pre></div><p>得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">sun</span>.misc.Launcher$AppClassLoader@<span class="hljs-number">18</span>b<span class="hljs-number">4</span>aac<span class="hljs-number">2</span><span class="hljs-attribute">sun</span>.misc.Launcher$ExtClassLoader@<span class="hljs-number">1540</span>e<span class="hljs-number">19</span>d<span class="hljs-attribute">null</span><span class="hljs-attribute">sun</span>.misc.Launcher$AppClassLoader@<span class="hljs-number">18</span>b<span class="hljs-number">4</span>aac<span class="hljs-number">2</span><span class="hljs-attribute">null</span></code></pre></div><h3 id="5-1-虚拟机自带的加载器"><a href="#5-1-虚拟机自带的加载器" class="headerlink" title="5.1 虚拟机自带的加载器"></a>5.1 虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h3 id="5-2-扩展类加载器（Extension-ClassLoader）"><a href="#5-2-扩展类加载器（Extension-ClassLoader）" class="headerlink" title="5.2 扩展类加载器（Extension ClassLoader）"></a>5.2 扩展类加载器（Extension ClassLoader）</h3><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h3 id="5-3-应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#5-3-应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="5.3 应用程序类加载器（系统类加载器，AppClassLoader）"></a>5.3 应用程序类加载器（系统类加载器，AppClassLoader）</h3><ul><li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul><h3 id="5-4-用户自定义类加载器"><a href="#5-4-用户自定义类加载器" class="headerlink" title="5.4 用户自定义类加载器"></a>5.4 用户自定义类加载器</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。<br>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>用户自定义类加载器实现步骤：</p><ul><li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul><h3 id="5-5-查看根加载器所能加载的目录"><a href="#5-5-查看根加载器所能加载的目录" class="headerlink" title="5.5 查看根加载器所能加载的目录"></a>5.5 查看根加载器所能加载的目录</h3><p>刚刚我们通过概念了解到了，根加载器只能够加载 java /lib目录下的class，我们通过下面代码验证一下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderTest1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;*********启动类加载器************&quot;</span>);        <span class="hljs-comment">// 获取BootstrapClassLoader 能够加载的API的路径</span>        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();        <span class="hljs-keyword">for</span> (URL url : urls) &#123;            System.out.println(url.toExternalForm());        &#125;        <span class="hljs-comment">// 从上面路径中，随意选择一个类，来看看他的类加载器是什么：得到的是null，说明是  根加载器</span>        ClassLoader classLoader = Provider.class.getClassLoader();    &#125;&#125;</code></pre></div><p>得到的结果</p><div class="code-wrapper"><pre><code class="hljs gradle">*********启动类加载器************<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/resources.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/rt.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/sunrsasign.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jsse.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jce.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/charsets.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>lib/jfr.jar<span class="hljs-keyword">file</span>:<span class="hljs-regexp">/E:/</span>Software<span class="hljs-regexp">/JDK1.8/</span>Java<span class="hljs-regexp">/jre/</span>classes<span class="hljs-keyword">null</span></code></pre></div><h3 id="5-6-关于ClassLoader"><a href="#5-6-关于ClassLoader" class="headerlink" title="5.6 关于ClassLoader"></a>5.6 关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705103516138.png" alt="image-20200705103516138"></p><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705103636003.png" alt="image-20200705103636003"></p><p>获取ClassLoader的途径</p><ul><li>获取当前ClassLoader：clazz.getClassLoader()</li><li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li><li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li><li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li></ul><h2 id="6-双亲委派机制"><a href="#6-双亲委派机制" class="headerlink" title="6 双亲委派机制"></a>6 双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><h3 id="6-1-工作原理"><a href="#6-1-工作原理" class="headerlink" title="6.1 工作原理"></a>6.1 工作原理</h3><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705105151258.png" alt="image-20200705105151258"></p><h3 id="6-2-双亲委派机制举例"><a href="#6-2-双亲委派机制举例" class="headerlink" title="6.2 双亲委派机制举例"></a>6.2 双亲委派机制举例</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/images/image-20200705105810107.png" alt="image-20200705105810107"></p><h3 id="6-3-沙箱安全机制"><a href="#6-3-沙箱安全机制" class="headerlink" title="6.3 沙箱安全机制"></a>6.3 沙箱安全机制</h3><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><h3 id="6-4-双亲委派机制的优势"><a href="#6-4-双亲委派机制的优势" class="headerlink" title="6.4 双亲委派机制的优势"></a>6.4 双亲委派机制的优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul><h2 id="7-其它"><a href="#7-其它" class="headerlink" title="7 其它"></a>7 其它</h2><h3 id="如何判断两个class对象是否相同"><a href="#如何判断两个class对象是否相同" class="headerlink" title="如何判断两个class对象是否相同"></a>如何判断两个class对象是否相同</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul><p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：王动使用和被动使用。<br>主动使用，又分为七种情况：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法I</li><li>反射（比如：Class.forName（”com.atguigu.Test”））</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：</li><li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p><h1 id="第3章-运行时数据区概述及线程"><a href="#第3章-运行时数据区概述及线程" class="headerlink" title="第3章  运行时数据区概述及线程"></a>第3章  运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/images/image-20200705111640511.png" alt="image-20200705111640511"></p><p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/images/image-20200705111843003.png" alt="image-20200705111843003"></p><p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/images/image-20200705112036630.png" alt="image-20200705112036630"></p><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p><blockquote><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></blockquote><p>运行时数据区的完整图</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/images/image-20200705112416101.png" alt="image-20200705112416101"></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p>!<img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/images/image-20200705112601211.png" alt="image-20200705112601211"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p><h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|<br>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><h1 id="第4章-程序计数器"><a href="#第4章-程序计数器" class="headerlink" title="第4章 程序计数器"></a>第4章 程序计数器</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705155551919.png" alt="image-20200705155551919"></p><p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p><p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705155728557.png" alt="image-20200705155728557"></p><h2 id="3-代码演示"><a href="#3-代码演示" class="headerlink" title="3 代码演示"></a>3 代码演示</h2><p>我们首先写一个简单的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCRegisterTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">20</span>;        <span class="hljs-keyword">int</span> k = i + j;    &#125;&#125;</code></pre></div><p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p><div class="code-wrapper"><pre><code class="hljs bash">0: bipush        102: istore_13: bipush        205: istore_26: iload_17: iload_28: iadd9: istore_310: <span class="hljs-built_in">return</span></code></pre></div><p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了 </p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161007423.png" alt="image-20200705161007423"></p><h2 id="4-使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#4-使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="4 使用PC寄存器存储字节码指令地址有什么用呢？"></a>4 使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161409533.png" alt="image-20200705161409533"></p><h2 id="5-PC寄存器为什么被设定为私有的？"><a href="#5-PC寄存器为什么被设定为私有的？" class="headerlink" title="5 PC寄存器为什么被设定为私有的？"></a>5 PC寄存器为什么被设定为私有的？</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161812542.png" alt="image-20200705161812542"></p><h2 id="6-CPU时间片"><a href="#6-CPU时间片" class="headerlink" title="6 CPU时间片"></a>6 CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/images/image-20200705161849557.png" alt="image-20200705161849557"></p><h1 id="第5章-虚拟机栈"><a href="#第5章-虚拟机栈" class="headerlink" title="第5章 虚拟机栈"></a>第5章 虚拟机栈</h1><h2 id="1-虚拟机栈概述"><a href="#1-虚拟机栈概述" class="headerlink" title="1 虚拟机栈概述"></a>1 虚拟机栈概述</h2><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。<br>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java战（stack）？为什么？</p><p>首先栈是运行时的单位，而堆是存储的单位</p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705163928652.png" alt="image-20200705163928652"></p><h3 id="1-1-Java虚拟机栈是什么"><a href="#1-1-Java虚拟机栈是什么" class="headerlink" title="1.1 Java虚拟机栈是什么"></a>1.1 Java虚拟机栈是什么</h3><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><blockquote><p>是线程私有的</p></blockquote><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705164722033.png" alt="image-20200705164722033"></p><h3 id="1-2-生命周期"><a href="#1-2-生命周期" class="headerlink" title="1.2 生命周期"></a>1.2 生命周期</h3><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p><h3 id="1-3-作用"><a href="#1-3-作用" class="headerlink" title="1.3 作用"></a>1.3 作用</h3><p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><blockquote><p>局部变量，它是相比于成员变量来说的（或属性）</p><p>基本数据类型变量 VS  引用类型变量（类、数组、接口）</p></blockquote><h3 id="1-4-栈的特点"><a href="#1-4-栈的特点" class="headerlink" title="1.4 栈的特点"></a>1.4 栈的特点</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705165025382.png" alt="image-20200705165025382"></p><h3 id="1-5-开发中遇到哪些异常？"><a href="#1-5-开发中遇到哪些异常？" class="headerlink" title="1.5 开发中遇到哪些异常？"></a>1.5 开发中遇到哪些异常？</h3><p>栈中可能出现的异常</p><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</p><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 outofMemoryError 异常。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackErrorTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(count++);        main(args);    &#125;&#125;</code></pre></div><p>当栈深度达到9872的时候，就出现栈内存空间不足</p><h3 id="1-6-设置栈内存大小"><a href="#1-6-设置栈内存大小" class="headerlink" title="1.6 设置栈内存大小"></a>1.6 设置栈内存大小</h3><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><div class="code-wrapper"><pre><code class="hljs shell">-Xss1m-Xss1k</code></pre></div><h2 id="2-栈的存储单位"><a href="#2-栈的存储单位" class="headerlink" title="2 栈的存储单位"></a>2 栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h3 id="2-1-栈中存储什么？"><a href="#2-1-栈中存储什么？" class="headerlink" title="2.1 栈中存储什么？"></a>2.1 栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。在这个线程上正在执行的每个方法都各自对应一个栈颜（Stack Frame）。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><blockquote><p>OOP的基本概念：类和对象</p><p>类中基本结构：field（属性、字段、域）、method</p></blockquote><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705203142545.png" alt="image-20200705203142545"></p><p>下面写一个简单的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackFrameTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        method01();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;方法1的开始&quot;</span>);        <span class="hljs-keyword">int</span> i = method02();        System.out.println(<span class="hljs-string">&quot;方法1的结束&quot;</span>);        <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method02</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;方法2的开始&quot;</span>);        <span class="hljs-keyword">int</span> i = method03();;        System.out.println(<span class="hljs-string">&quot;方法2的结束&quot;</span>);        <span class="hljs-keyword">return</span> i;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method03</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;方法3的开始&quot;</span>);        <span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>;        System.out.println(<span class="hljs-string">&quot;方法3的结束&quot;</span>);        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre></div><p>输出结果为</p><div class="code-wrapper"><pre><code class="hljs bash">方法1的开始方法2的开始方法3的开始方法3的结束方法2的结束方法1的结束</code></pre></div><p>满足栈先进后出的概念，通过Idea的 DEBUG，能够看到栈信息</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705203916023.png" alt="image-20200705203916023"></p><h3 id="2-2-栈运行原理"><a href="#2-2-栈运行原理" class="headerlink" title="2.2 栈运行原理"></a>2.2 栈运行原理</h3><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h3 id="2-3-栈帧的内部结构"><a href="#2-3-栈帧的内部结构" class="headerlink" title="2.3 栈帧的内部结构"></a>2.3 栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack）（或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705204836977.png" alt="image-20200705204836977"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705205443993.png" alt="image-20200705205443993"></p><h2 id="3-局部变量表"><a href="#3-局部变量表" class="headerlink" title="3 局部变量表"></a>3 局部变量表</h2><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p><p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p><h3 id="3-1-关于Slot的理解"><a href="#3-1-关于Slot的理解" class="headerlink" title="3.1 关于Slot的理解"></a>3.1 关于Slot的理解</h3><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p><p>局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p><p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。</p><blockquote><p>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。<br>1ong和double则占据两个slot。</p></blockquote><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）</p><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705212454445.png" alt="image-20200705212454445"></p><h3 id="3-2-Slot的重复利用"><a href="#3-2-Slot的重复利用" class="headerlink" title="3.2 Slot的重复利用"></a>3.2 Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200705213106749.png" alt="image-20200705213106749"></p><h3 id="3-3-静态变量与局部变量的对比"><a href="#3-3-静态变量与局部变量的对比" class="headerlink" title="3.3 静态变量与局部变量的对比"></a>3.3 静态变量与局部变量的对比</h3><p>变量的分类：</p><ul><li>按数据类型分：基本数据类型、引用数据类型</li><li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量<ul><li>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块</li><li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li><li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li></ul></li></ul><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h2 id="4-操作数栈"><a href="#4-操作数栈" class="headerlink" title="4 操作数栈"></a>4 操作数栈</h2><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>操作数栈：Operand Stack</p><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 <strong>操作数栈</strong>，也可以称之为 <strong>表达式栈</strong>（Expression Stack）</p><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706090618332.png" alt="image-20200706090618332"></p><p>代码举例</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706090833697.png" alt="image-20200706090833697"></p><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。.</p><blockquote><p>这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的</p></blockquote><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</p><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p><p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p><h3 id="4-2-代码追踪"><a href="#4-2-代码追踪" class="headerlink" title="4.2 代码追踪"></a>4.2 代码追踪</h3><p>我们给定代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAddOperation</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">byte</span> i = <span class="hljs-number">15</span>;    <span class="hljs-keyword">int</span> j = <span class="hljs-number">8</span>;    <span class="hljs-keyword">int</span> k = i + j;&#125;</code></pre></div><p>使用javap 命令反编译class文件： javap -v 类名.class</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706092610730.png" alt="image-20200706092610730"></p><blockquote><p>byte、short、char、boolean 内部都是使用int型来进行保存的</p><p>从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和  8进行入栈操作</p><p>同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作</p></blockquote><p>执行流程如下所示：</p><p>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入栈。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093131621.png" alt="image-20200706093131621"></p><p>执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093251302.png" alt="image-20200706093251302"></p><blockquote><p>为什么局部变量表不是从0开始的呢？</p><p>其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了~</p></blockquote><p>然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093646406.png" alt="image-20200706093646406"></p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093751711.png" alt="image-20200706093751711"></p><p>然后从局部变量表中，依次将数据放在操作数栈中</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093859191.png" alt="image-20200706093859191"></p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706093921573.png" alt="image-20200706093921573"></p><p>然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706094046782.png" alt="image-20200706094046782"></p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706094109629.png" alt="image-20200706094109629"></p><p>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</p><p>i++和++i的区别</p><h2 id="5-栈顶缓存技术"><a href="#5-栈顶缓存技术" class="headerlink" title="5 栈顶缓存技术"></a>5 栈顶缓存技术</h2><p>栈顶缓存技术：Top Of Stack Cashing</p><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p><blockquote><p>寄存器：指令更少，执行速度快</p></blockquote><h2 id="6-动态链接"><a href="#6-动态链接" class="headerlink" title="6 动态链接"></a>6 动态链接</h2><p>动态链接：Dynamic Linking</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706100311886.png" alt="image-20200706100311886"></p><blockquote><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p></blockquote><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</p><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706101251847.png" alt="image-20200706101251847"></p><blockquote><p>为什么需要运行时常量池？</p><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></blockquote><h2 id="7-方法调用：解析与分配"><a href="#7-方法调用：解析与分配" class="headerlink" title="7 方法调用：解析与分配"></a>7 方法调用：解析与分配</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h3 id="7-1-链接"><a href="#7-1-链接" class="headerlink" title="7.1 链接"></a>7.1 链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期被确定，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h3 id="7-2-绑定机制"><a href="#7-2-绑定机制" class="headerlink" title="7.2 绑定机制"></a>7.2 绑定机制</h3><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h4 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h4><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><h4 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h4><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><h3 id="早晚期绑定的发展历史"><a href="#早晚期绑定的发展历史" class="headerlink" title="早晚期绑定的发展历史"></a>早晚期绑定的发展历史</h3><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><h3 id="7-3-虚方法和非虚方法"><a href="#7-3-虚方法和非虚方法" class="headerlink" title="7.3 虚方法和非虚方法"></a>7.3 虚方法和非虚方法</h3><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><blockquote><p>子类对象的多态的使用前提</p><ul><li>类的继承关系</li><li>方法的重写</li></ul></blockquote><p>虚拟机中提供了以下几条方法调用指令：</p><h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本</init></li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul><h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</p><h3 id="7-4-invokedynamic指令"><a href="#7-4-invokedynamic指令" class="headerlink" title="7.4 invokedynamic指令"></a>7.4 invokedynamic指令</h3><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现动态类型语言】支持而做的一种改进。</p><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p><h3 id="7-5-动态类型语言和静态类型语言"><a href="#7-5-动态类型语言和静态类型语言" class="headerlink" title="7.5 动态类型语言和静态类型语言"></a>7.5 动态类型语言和静态类型语言</h3><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p><blockquote><p>Java：String info = “mogu blog”;     (Java是静态类型语言的，会先编译就进行类型检查)</p><p>JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查）</p></blockquote><h3 id="7-6-方法重写的本质"><a href="#7-6-方法重写的本质" class="headerlink" title="7.6 方法重写的本质"></a>7.6 方法重写的本质</h3><h4 id="Java-语言中方法重写的本质："><a href="#Java-语言中方法重写的本质：" class="headerlink" title="Java 语言中方法重写的本质："></a>Java 语言中方法重写的本质：</h4><ul><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.1ang.I1legalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。</li></ul><h4 id="IllegalAccessError介绍"><a href="#IllegalAccessError介绍" class="headerlink" title="IllegalAccessError介绍"></a>IllegalAccessError介绍</h4><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h3 id="7-7-方法的调用：虚方法表"><a href="#7-7-方法的调用：虚方法表" class="headerlink" title="7.7 方法的调用：虚方法表"></a>7.7 方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表<br>（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表是什么时候被创建的呢？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706144954070.png" alt="image-20200706144954070"></p><p>如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。</p><h2 id="8-方法返回地址"><a href="#8-方法返回地址" class="headerlink" title="8 方法返回地址"></a>8 方法返回地址</h2><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li><p>正常执行完成</p></li><li><p>出现未处理的异常，非正常退出</p></li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p><ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/images/image-20200706154554604.png" alt="image-20200706154554604"></p><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p><h2 id="9-一些附加信息"><a href="#9-一些附加信息" class="headerlink" title="9 一些附加信息"></a>9 一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="10-栈的相关面试题"><a href="#10-栈的相关面试题" class="headerlink" title="10 栈的相关面试题"></a>10 栈的相关面试题</h2><ul><li>举例栈溢出的情况？（StackOverflowError）<ul><li>通过 -Xss设置栈的大小</li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出</li></ul></li><li>分配的栈内存越大越好么？<ul><li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li>垃圾回收是否涉及到虚拟机栈？<ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>具体问题具体分析</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 面试题</span><span class="hljs-comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span><span class="hljs-comment"> * 何为线程安全？</span><span class="hljs-comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span><span class="hljs-comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuilderTest</span> </span>&#123;    <span class="hljs-comment">// s1的声明方式是线程安全的</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 线程内部创建的，属于局部变量</span>        StringBuilder s1 = <span class="hljs-keyword">new</span> StringBuilder();        s1.append(<span class="hljs-string">&quot;a&quot;</span>);        s1.append(<span class="hljs-string">&quot;b&quot;</span>);    &#125;    <span class="hljs-comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title">method04</span><span class="hljs-params">()</span> </span>&#123;        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-keyword">return</span> stringBuilder;    &#125;    <span class="hljs-comment">// stringBuilder 是线程不安全的，操作的是共享数据</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method02</span><span class="hljs-params">(StringBuilder stringBuilder)</span> </span>&#123;        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 同时并发的执行，会出现线程不安全的问题</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method03</span><span class="hljs-params">()</span> </span>&#123;        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);            stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();        method02(stringBuilder);    &#125;    <span class="hljs-comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">method05</span><span class="hljs-params">()</span> </span>&#123;        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();        stringBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);        stringBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-keyword">return</span> stringBuilder.toString();    &#125;&#125;</code></pre></div><p>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p><p>运行时数据区，是否存在Error和GC？</p><table><thead><tr><th>运行时数据区</th><th>是否存在Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>否</td></tr><tr><td>虚拟机栈</td><td>是</td><td>否</td></tr><tr><td>本地方法栈</td><td>是</td><td>否</td></tr><tr><td>方法区</td><td>是（OOM）</td><td>是</td></tr><tr><td>堆</td><td>是</td><td>是</td></tr></tbody></table><h1 id="第6章-本地方法接口"><a href="#第6章-本地方法接口" class="headerlink" title="第6章 本地方法接口"></a>第6章 本地方法接口</h1><h2 id="1-什么是本地方法"><a href="#1-什么是本地方法" class="headerlink" title="1 什么是本地方法"></a>1 什么是本地方法</h2><p>简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。</p><p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/6_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/images/image-20200706164139252.png" alt="image-20200706164139252"></p><p>代码举例说明Native方法是如何编写的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IhaveNatives</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Native1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Native2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Native3</span><span class="hljs-params">(Object o)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Natives</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ary)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><blockquote><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p></blockquote><h2 id="2-为什么使用Native-Method？"><a href="#2-为什么使用Native-Method？" class="headerlink" title="2 为什么使用Native Method？"></a>2 为什么使用Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h3 id="2-1-与Java环境的交互"><a href="#2-1-与Java环境的交互" class="headerlink" title="2.1 与Java环境的交互"></a>2.1 与Java环境的交互</h3><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="2-2-与操作系统的交互"><a href="#2-2-与操作系统的交互" class="headerlink" title="2.2 与操作系统的交互"></a>2.2 与操作系统的交互</h3><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><h3 id="2-3-Sun’s-Java"><a href="#2-3-Sun’s-Java" class="headerlink" title="2.3 Sun’s Java"></a>2.3 Sun’s Java</h3><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p><h2 id="3-现状"><a href="#3-现状" class="headerlink" title="3 现状"></a>3 现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h1 id="第7章-本地方法栈"><a href="#第7章-本地方法栈" class="headerlink" title="第7章 本地方法栈"></a>第7章 本地方法栈</h1><p>Java虚拟机栈于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul><p>本地方法是使用C语言实现的。</p><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/7_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/images/image-20200706174708418.png" alt="image-20200706174708418"></p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p><p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p><h1 id="第8章-堆"><a href="#第8章-堆" class="headerlink" title="第8章 堆"></a>第8章 堆</h1><h2 id="1-堆的核心概念"><a href="#1-堆的核心概念" class="headerlink" title="1 堆的核心概念"></a>1 堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706195127740.png" alt="image-20200706195127740"></p><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p><ul><li>堆内存的大小是可以调节的。</li></ul><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p><blockquote><p>-Xms10m：最小堆内存</p><p>-Xmx10m：最大堆内存</p></blockquote><p>下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706200739392.png" alt="image-20200706200739392"></p><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><p>我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p><ul><li>因为还有一些对象是在栈上分配的</li></ul><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706201904057.png" alt="image-20200706201904057"></p><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>Young Generation Space 新生区  Young/New   又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space永久区   Perm</li></ul><p>Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间</p><ul><li>Young Generation Space新生区  Young/New  又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区  Old/Tenure</li><li>Meta Space  元空间   Meta</li></ul><p>约定：新生区 -&gt; 新生代 -&gt; 年轻代   、  养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706203419496.png" alt="image-20200706203419496"></p><p>堆空间内部结构，JDK1.8之前从永久代  替换成 元空间</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706203835403.png" alt="image-20200706203835403"></p><h2 id="2-设置堆内存大小与OOM"><a href="#2-设置堆内存大小与OOM" class="headerlink" title="2 设置堆内存大小与OOM"></a>2 设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p><ul><li>“-Xms”用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li><li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。</p><p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p><p>默认情况下</p><ul><li><p>初始内存大小：物理电脑内存大小/64</p></li><li><p>最大内存大小：物理电脑内存大小/4</p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span><span class="hljs-comment"> *  -X：是jvm运行参数</span><span class="hljs-comment"> *  ms：memory start</span><span class="hljs-comment"> * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSpaceInitial</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 返回Java虚拟机中的堆内存总量</span>        <span class="hljs-keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;        <span class="hljs-comment">// 返回Java虚拟机试图使用的最大堆内存</span>        <span class="hljs-keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;        System.out.println(<span class="hljs-string">&quot;-Xms:&quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);        System.out.println(<span class="hljs-string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);    &#125;&#125;</code></pre></div><p>输出结果</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms:245M</span><span class="hljs-deletion">-Xmx:3614M</span></code></pre></div><p>如何查看堆内存的内存分配情况</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps </span> -&gt;  <span class="hljs-keyword">jstat </span>-gc 进程id</code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706205756045.png" alt="image-20200706205756045"></p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+PrintGCDetails</span></code></pre></div><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706205821919.png" alt="image-20200706205821919"></p><h3 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706205947535.png" alt="image-20200706205947535"></p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706210000461.png" alt="image-20200706210000461"></p><p>我们简单的写一个OOM例子</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;            list.add(<span class="hljs-number">999999999</span>);        &#125;    &#125;&#125;</code></pre></div><p>然后设置启动参数</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx:10m</span></code></pre></div><p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200706211652779.png" alt="image-20200706211652779"></p><h2 id="3-年轻代与老年代"><a href="#3-年轻代与老年代" class="headerlink" title="3 年轻代与老年代"></a>3 年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速<ul><li>生命周期短的，及时回收即可</li></ul></li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707075847954.png" alt="image-20200707075847954"></p><p>下面这参数开发中一般不会调：</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707080154039.png" alt="image-20200707080154039"></p><ul><li>Eden：From：to -&gt;  8:1:1</li><li>新生代：老年代  - &gt;  1 : 2</li></ul><p>配置新生代与老年代在堆结构的占比。</p><ul><li><p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p></li><li><p>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p></li></ul><blockquote><p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p></blockquote><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p><p>可以使用选项”-Xmn”设置新生代最大内存大小</p><p>这个参数一般使用默认值就可以了。</p></blockquote><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707084208115.png" alt="image-20200707084208115"></p><h2 id="4-图解对象分配过程"><a href="#4-图解对象分配过程" class="headerlink" title="4 图解对象分配过程"></a>4 图解对象分配过程</h2><h3 id="4-1-概念-1"><a href="#4-1-概念-1" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ul><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><p>可以设置参数：-Xx:MaxTenuringThreshold= N进行设置</p><h3 id="4-2-图解过程"><a href="#4-2-图解过程" class="headerlink" title="4.2 图解过程"></a>4.2 图解过程</h3><p>我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707084714886.png" alt="image-20200707084714886"></p><p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707085232646.png" alt="image-20200707085232646"></p><p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象  晋升到 老年代中</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707085737207.png" alt="image-20200707085737207"></p><h3 id="4-3-思考：幸存区区满了后？"><a href="#4-3-思考：幸存区区满了后？" class="headerlink" title="4.3 思考：幸存区区满了后？"></a>4.3 思考：幸存区区满了后？</h3><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p><p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p><blockquote><p>举例：以当兵为例，正常人的晋升可能是 ：  新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p><p>但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -&gt; 排长</p></blockquote><h3 id="4-4-对象分配的特殊情况"><a href="#4-4-对象分配的特殊情况" class="headerlink" title="4.4 对象分配的特殊情况"></a>4.4 对象分配的特殊情况</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707091058346.png" alt="image-20200707091058346"></p><h3 id="4-5-代码演示对象分配过程"><a href="#4-5-代码演示对象分配过程" class="headerlink" title="4.5 代码演示对象分配过程"></a>4.5 代码演示对象分配过程</h3><p>我们不断的创建大对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapInstanceTest</span> </span>&#123;    <span class="hljs-keyword">byte</span> [] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">200</span>)];    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        ArrayList&lt;HeapInstanceTest&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            list.add(<span class="hljs-keyword">new</span> HeapInstanceTest());            Thread.sleep(<span class="hljs-number">10</span>);        &#125;    &#125;&#125;</code></pre></div><p>然后设置JVM参数</p><div class="code-wrapper"><pre><code class="hljs bash">-Xms600m -Xmx600m</code></pre></div><p>然后cmd输入下面命令，打开VisualVM图形化界面</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">jvisualvm</span></code></pre></div><p>然后通过执行上面代码，通过VisualGC进行动态化查看</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.gif" alt="垃圾回收"></p><p>最终，在老年代和新生代都满了，就出现OOM</p><div class="code-wrapper"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.java.chapter08.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:<span class="hljs-number">13</span>)at com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:<span class="hljs-number">17</span>)</code></pre></div><h3 id="4-6-常用的调优工具"><a href="#4-6-常用的调优工具" class="headerlink" title="4.6 常用的调优工具"></a>4.6 常用的调优工具</h3><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控  推荐~）</li><li>Jprofiler（推荐~）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ul><h3 id="4-7-总结"><a href="#4-7-总结" class="headerlink" title="4.7 总结"></a>4.7 总结</h3><ul><li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li><li>新生代采用复制算法的目的：是为了减少内碎片</li></ul><h2 id="5-Minor-GC，MajorGC、Full-GC"><a href="#5-Minor-GC，MajorGC、Full-GC" class="headerlink" title="5 Minor GC，MajorGC、Full GC"></a>5 Minor GC，MajorGC、Full GC</h2><ul><li>Minor GC：新生代的GC</li><li>Major GC：老年代的GC</li><li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li></ul><blockquote><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p><p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p></blockquote><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li><li>老年代收集（MajorGC/OldGC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和FullGC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p>整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。</p><h3 id="5-1-Minor-GC"><a href="#5-1-Minor-GC" class="headerlink" title="5.1 Minor GC"></a>5.1 Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><blockquote><p>STW：stop the word</p></blockquote><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707095606813.png" alt="image-20200707095606813"></p><h3 id="5-2-Major-GC"><a href="#5-2-Major-GC" class="headerlink" title="5.2 Major GC"></a>5.2 Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p><p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li></ul><p>Major GC的速度一般会比MinorGc慢10倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p><h3 id="5-3-Full-GC"><a href="#5-3-Full-GC" class="headerlink" title="5.3 Full GC"></a>5.3 Full GC</h3><p>触发FullGC执行的情况有如下五种：</p><ul><li>调用System.gc（）时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p><h3 id="5-4-GC-举例"><a href="#5-4-GC-举例" class="headerlink" title="5.4 GC 举例"></a>5.4 GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">try</span> &#123;            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            String a = <span class="hljs-string">&quot;mogu blog&quot;</span>;            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;                list.add(a);                a = a + a;                i++;            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;            e.getStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>设置JVM启动参数</p><div class="code-wrapper"><pre><code class="hljs bash">-Xms10m -Xmx10m -XX:+PrintGCDetails</code></pre></div><p>打印出的日志</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2038</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">500</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">2038</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">797</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.3532002</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.36</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2108</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">480</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">2405</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">1565</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0014069</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Ergonomics</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">2288</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">6845</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">9133</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058675</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0002857</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5263</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5281</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">5263</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3482</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058564</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Heap</span> <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">60</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">2048</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd0f138</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">5263</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span>  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">73</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffb23cf0</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3514</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4498</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span>  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">388</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">390</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span>    <span class="hljs-variable">Exception</span> <span class="hljs-variable">in</span> <span class="hljs-variable">thread</span> <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">OutOfMemoryError</span><span class="hljs-operator">:</span> <span class="hljs-variable">Java</span> <span class="hljs-variable">heap</span> <span class="hljs-variable">space</span><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">util</span><span class="hljs-operator">.</span><span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">copyOfRange</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">3664</span><span class="hljs-punctuation">)</span><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-built_in">String</span><span class="hljs-operator">.&lt;</span><span class="hljs-variable">init</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">String</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">207</span><span class="hljs-punctuation">)</span><span class="hljs-variable">at</span> <span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">StringBuilder</span><span class="hljs-operator">.</span><span class="hljs-variable">toString</span><span class="hljs-punctuation">(</span><span class="hljs-variable">StringBuilder</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">407</span><span class="hljs-punctuation">)</span><span class="hljs-variable">at</span> <span class="hljs-variable">com</span><span class="hljs-operator">.</span><span class="hljs-variable">atguigu</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">chapter08</span><span class="hljs-operator">.</span><span class="hljs-variable">GCTest</span><span class="hljs-operator">.</span><span class="hljs-variable">main</span><span class="hljs-punctuation">(</span><span class="hljs-variable">GCTest</span><span class="hljs-operator">.</span><span class="hljs-variable">java</span><span class="hljs-operator">:</span><span class="hljs-number">20</span><span class="hljs-punctuation">)</span></code></pre></div><p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p><h2 id="6-堆空间分代思想"><a href="#6-堆空间分代思想" class="headerlink" title="6 堆空间分代思想"></a>6 堆空间分代思想</h2><p> 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><blockquote><p>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p></blockquote><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707101511025.png" alt="image-20200707101511025"></p><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707101543871.png" alt="image-20200707101543871"></p><h2 id="7-内存分配策略"><a href="#7-内存分配策略" class="headerlink" title="7 内存分配策略"></a>7 内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden<ul><li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li></ul></li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li></ul></li></ul><p>空间分配担保： -Xx:HandlePromotionFailure</p><ul><li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li></ul><h2 id="8-为对象分配内存：TLAB"><a href="#8-为对象分配内存：TLAB" class="headerlink" title="8 为对象分配内存：TLAB"></a>8 为对象分配内存：TLAB</h2><h3 id="8-1-问题：堆空间都是共享的么？"><a href="#8-1-问题：堆空间都是共享的么？" class="headerlink" title="8.1 问题：堆空间都是共享的么？"></a>8.1 问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p><h3 id="8-2-为什么有TLAB？"><a href="#8-2-为什么有TLAB？" class="headerlink" title="8.2 为什么有TLAB？"></a>8.2 为什么有TLAB？</h3><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><h3 id="8-3-什么是TLAB"><a href="#8-3-什么是TLAB" class="headerlink" title="8.3 什么是TLAB"></a>8.3 什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707103547712.png" alt="image-20200707103547712"></p><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><h3 id="8-4-TLAB分配过程"><a href="#8-4-TLAB分配过程" class="headerlink" title="8.4 TLAB分配过程"></a>8.4 TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707104253530.png" alt="image-20200707104253530"></p><h2 id="9-小结：堆空间的参数设置"><a href="#9-小结：堆空间的参数设置" class="headerlink" title="9 小结：堆空间的参数设置"></a>9 小结：堆空间的参数设置</h2><ul><li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p></li><li><p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p></li><li><p>-Xms：初始堆空间内存（默认为物理内存的1/64）</p></li><li><p>-Xmx：最大堆空间内存（默认为物理内存的1/4）</p></li><li><p>-Xmn：设置新生代的大小。（初始值及最大值）</p></li><li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p></li><li><p>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</p></li><li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p></li><li><p>-XX：+PrintGCDetails：输出详细的GC处理日志</p><ul><li>打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc</li></ul></li><li><p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p></li></ul><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul><li>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则改为进行一次FullGC。</li><li>如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。</li></ul></li></ul><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p><h2 id="10-堆是分配对象的唯一选择么？"><a href="#10-堆是分配对象的唯一选择么？" class="headerlink" title="10 堆是分配对象的唯一选择么？"></a>10 堆是分配对象的唯一选择么？</h2><h3 id="10-1-逃逸分析"><a href="#10-1-逃逸分析" class="headerlink" title="10.1 逃逸分析"></a>10.1 逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><h4 id="1-逃逸分析举例"><a href="#1-逃逸分析举例" class="headerlink" title="1 逃逸分析举例"></a>1 逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">my_method</span><span class="hljs-params">()</span> </span>&#123;    V v = <span class="hljs-keyword">new</span> V();    <span class="hljs-comment">// use v</span>    <span class="hljs-comment">// ....</span>    v = <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>针对下面的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();    sb.append(s1);    sb.append(s2);    <span class="hljs-keyword">return</span> sb;&#125;</code></pre></div><p>如果想要StringBuffer sb不发生逃逸，可以这样写</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();    sb.append(s1);    sb.append(s2);    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre></div><p>完整的逃逸分析代码举例</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 逃逸分析</span><span class="hljs-comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EscapeAnalysis</span> </span>&#123;    <span class="hljs-keyword">public</span> EscapeAnalysis obj;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> EscapeAnalysis <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> obj == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> EscapeAnalysis():obj;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 为成员属性赋值，发生逃逸</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setObj</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.obj = <span class="hljs-keyword">new</span> EscapeAnalysis();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useEscapeAnalysis</span><span class="hljs-params">()</span> </span>&#123;        EscapeAnalysis e = <span class="hljs-keyword">new</span> EscapeAnalysis();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 引用成员变量的值，发生逃逸</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useEscapeAnalysis2</span><span class="hljs-params">()</span> </span>&#123;        EscapeAnalysis e = getInstance();        <span class="hljs-comment">// getInstance().XXX  发生逃逸</span>    &#125;&#125;</code></pre></div><h4 id="2-参数设置"><a href="#2-参数设置" class="headerlink" title="2 参数设置"></a>2 参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li><li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul><h4 id="3-结论"><a href="#3-结论" class="headerlink" title="3 结论"></a>3 结论</h4><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h3 id="10-2-栈上分配"><a href="#10-2-栈上分配" class="headerlink" title="10.2 栈上分配"></a>10.2 栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>常见的栈上分配的场景</p><blockquote><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p></blockquote><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 栈上分配</span><span class="hljs-comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String age;    <span class="hljs-keyword">private</span> String gender;    <span class="hljs-keyword">private</span> String phone;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackAllocation</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;            alloc();        &#125;        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);        <span class="hljs-comment">// 为了方便查看堆内存中对象个数，线程sleep</span>        Thread.sleep(<span class="hljs-number">10000000</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 未发生逃逸</span>        User user = <span class="hljs-keyword">new</span> User();     &#125;&#125;</code></pre></div><p>设置JVM参数，表示未开启逃逸分析</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></code></pre></div><p>运行结果，同时还触发了GC操作</p><div class="code-wrapper"><pre><code class="hljs plain">花费的时间为：664 ms</code></pre></div><p>然后查看内存的情况，发现有大量的User存储在堆中</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707203038615.png" alt="image-20200707203038615"></p><p>我们在开启逃逸分析</p><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span></code></pre></div><p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p><div class="code-wrapper"><pre><code class="hljs plain">花费的时间为：5 ms</code></pre></div><p>在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707203441718.png" alt="image-20200707203441718"></p><h3 id="10-3-同步省略"><a href="#10-3-同步省略" class="headerlink" title="10.3 同步省略"></a>10.3 同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p><p>例如下面的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;    Object hellis = <span class="hljs-keyword">new</span> Object();    <span class="hljs-keyword">synchronized</span>(hellis) &#123;        System.out.println(hellis);    &#125;&#125;</code></pre></div><p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;    Object hellis = <span class="hljs-keyword">new</span> Object();System.out.println(hellis);&#125;</code></pre></div><p>我们将其转换成字节码</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8_%E5%A0%86/images/image-20200707205634266.png" alt="image-20200707205634266"></p><h3 id="10-4-分离对象和标量替换"><a href="#10-4-分离对象和标量替换" class="headerlink" title="10.4 分离对象和标量替换"></a>10.4 分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;    alloc();&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;    Point point = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);    System.out.println(<span class="hljs-string">&quot;point.x&quot;</span> + point.x + <span class="hljs-string">&quot;;point.y&quot;</span> + point.y);&#125;</code></pre></div><p>以上代码，经过标量替换后，就会变成</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>;    System.out.println(<span class="hljs-string">&quot;point.x = &quot;</span> + x + <span class="hljs-string">&quot;; point.y=&quot;</span> + y);&#125;</code></pre></div><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p><h3 id="10-5-代码优化之标量替换"><a href="#10-5-代码优化之标量替换" class="headerlink" title="10.5 代码优化之标量替换"></a>10.5 代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><div class="code-wrapper"><pre><code class="hljs bash">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></pre></div><p>这里设置参数如下：</p><ul><li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li><li>参数-Xmx10m：指定了堆空间最大为10MB</li><li>参数-XX:+PrintGC：将打印Gc日志</li><li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h3 id="10-6-逃逸分析的不足"><a href="#10-6-逃逸分析的不足" class="headerlink" title="10.6 逃逸分析的不足"></a>10.6 逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。<br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p><h2 id="11-小结"><a href="#11-小结" class="headerlink" title="11 小结"></a>11 小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p><p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p><h1 id="第9章-方法区"><a href="#第9章-方法区" class="headerlink" title="第9章 方法区"></a>第9章 方法区</h1><h2 id="9-1-前言"><a href="#9-1-前言" class="headerlink" title="9.1 前言"></a>9.1 前言</h2><p>这次所讲述的是运行时数据区的最后一个部分</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708093918121.png" alt="image-20200708093918121"></p><p>从线程共享与否的角度来看</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708093918121.png" alt="image-20200708093918121"></p><p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p><h2 id="9-2-栈、堆、方法区的交互关系"><a href="#9-2-栈、堆、方法区的交互关系" class="headerlink" title="9.2 栈、堆、方法区的交互关系"></a>9.2 栈、堆、方法区的交互关系</h2><p>下面就涉及了对象的访问定位</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708094747667.png" alt="image-20200708094747667"></p><ul><li>Person：存放在元空间，也可以说方法区</li><li>person：存放在Java栈的局部变量表中</li><li>new Person()：存放在Java堆中</li></ul><h2 id="9-3-方法区的理解"><a href="#9-3-方法区的理解" class="headerlink" title="9.3 方法区的理解"></a>9.3 方法区的理解</h2><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，方法区看作是一块独立于Java堆的内存空间。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708095853544.png" alt="image-20200708095853544"></p><p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><ul><li>JDK 1.8后，元空间存放在堆外内存中</li></ul><p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。            </p><blockquote><p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）</p></blockquote><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708102919149.png" alt="image-20200708102919149"></p><p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708103055914.png" alt="image-20200708103055914"></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p><h2 id="9-4-设置方法区大小与OOM"><a href="#9-4-设置方法区大小与OOM" class="headerlink" title="9.4 设置方法区大小与OOM"></a>9.4 设置方法区大小与OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 </p><h3 id="1-jdk7及以前"><a href="#1-jdk7及以前" class="headerlink" title="1 jdk7及以前"></a>1 jdk7及以前</h3><ul><li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708111756800.png" alt="image-20200708111756800"></p><h3 id="2-JDK8以后"><a href="#2-JDK8以后" class="headerlink" title="2 JDK8以后"></a>2 JDK8以后</h3><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p><p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，FullGC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到FullGC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p><h3 id="3-如何解决这些OOM"><a href="#3-如何解决这些OOM" class="headerlink" title="3 如何解决这些OOM"></a>3 如何解决这些OOM</h3><ul><li><p>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</p><ul><li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li></ul></li><li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p></li><li><p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p></li></ul><h2 id="9-5-方法区的内部结构"><a href="#9-5-方法区的内部结构" class="headerlink" title="9.5  方法区的内部结构"></a>9.5  方法区的内部结构</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708161728320.png" alt="image-20200708161728320"></p><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708161856504.png" alt="image-20200708161856504"></p><h3 id="1-类型信息"><a href="#1-类型信息" class="headerlink" title="1 类型信息"></a>1 类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h3 id="2-域信息"><a href="#2-域信息" class="headerlink" title="2 域信息"></a>2 域信息</h3><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p><h3 id="3-方法（Method）信息"><a href="#3-方法（Method）信息" class="headerlink" title="3 方法（Method）信息"></a>3 方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><blockquote><p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p></blockquote><h3 id="4-non-final的类变量"><a href="#4-non-final的类变量" class="headerlink" title="4 non-final的类变量"></a>4 non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * non-final的类变量</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Order order = <span class="hljs-keyword">new</span> Order();        order.hello();        System.out.println(order.count);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">2</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);    &#125;&#125;</code></pre></div><p>如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p><h3 id="5-全局常量"><a href="#5-全局常量" class="headerlink" title="5 全局常量"></a>5 全局常量</h3><p>全局常量就是使用 static final 进行修饰</p><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 </p><h3 id="6-运行时常量池-VS-常量池"><a href="#6-运行时常量池-VS-常量池" class="headerlink" title="6 运行时常量池 VS 常量池"></a>6 运行时常量池 VS 常量池</h3><p>运行时常量池，就是运行时常量池</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708171151384.png" alt="image-20200708171151384"></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li></ul><h3 id="7-常量池"><a href="#7-常量池" class="headerlink" title="7 常量池"></a>7 常量池</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708172357052.png" alt="image-20200708172357052"></p><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p><h4 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。</p><p>比如：如下的代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleClass</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);    &#125;&#125;</code></pre></div><p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p><h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h4><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p>例如下面这段代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaTest2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;        Object obj = <span class="hljs-keyword">new</span> Object();    &#125;&#125;</code></pre></div><p>将会被翻译成如下字节码</p><div class="code-wrapper"><pre><code class="hljs bash">new <span class="hljs-comment">#2  </span>dupinvokespecial</code></pre></div><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><h3 id="8-运行时常量池"><a href="#8-运行时常量池" class="headerlink" title="8 运行时常量池"></a>8 运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p><p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</p><p>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</p><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p><h2 id="9-6-方法区使用举例"><a href="#9-6-方法区使用举例" class="headerlink" title="9.6 方法区使用举例"></a>9.6 方法区使用举例</h2><p>如下代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodAreaDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;        <span class="hljs-keyword">int</span> x = <span class="hljs-number">500</span>;        <span class="hljs-keyword">int</span> y = <span class="hljs-number">100</span>;        <span class="hljs-keyword">int</span> a = x / y;        <span class="hljs-keyword">int</span> b = <span class="hljs-number">50</span>;        System.out.println(a+b);    &#125;&#125;</code></pre></div><p>字节码执行过程展示</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708204750374.png" alt="image-20200708204750374"></p><p>首先现将操作数500放入到操作数栈中</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708204953552.png" alt="image-20200708204953552"></p><p>然后存储到局部变量表中</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205029376.png" alt="image-20200708205029376"></p><p>然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205221737.png" alt="image-20200708205221737"></p><p>将500 和 100 进行一个除法运算，在把结果入栈</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205413721.png" alt="image-20200708205413721"></p><p>在最后就是输出流，需要调用运行时常量池的常量</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205708057.png" alt="image-20200708205708057"></p><p>最后调用invokevirtual（虚方法调用），然后返回</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708205909176.png" alt="image-20200708205909176"></p><p>返回时</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708210540696.png" alt="image-20200708210540696"></p><p>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p><h2 id="9-7-方法区的演进细节"><a href="#9-7-方法区的演进细节" class="headerlink" title="9.7 方法区的演进细节"></a>9.7 方法区的演进细节</h2><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p><p>Hotspot中方法区的变化：</p><table><thead><tr><th>JDK1.6及以前</th><th>有永久代，静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p>JDK6的时候</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708211541300.png" alt="image-20200708211541300"></p><p>JDK7的时候</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708211609911.png" alt="image-20200708211609911"></p><p>JDK8的时候，元空间大小只受物理内存影响</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708211637952.png" alt="image-20200708211637952"></p><h3 id="1-为什么永久代要被元空间替代？"><a href="#1-为什么永久代要被元空间替代？" class="headerlink" title="1 为什么永久代要被元空间替代？"></a>1 为什么永久代要被元空间替代？</h3><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p><ul><li>为永久代设置空间大小是很难确定的。</li></ul><p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工<br>程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。<br>因此，默认情况下，元空间的大小仅受本地内存限制。</p><ul><li>对永久代进行调优是很困难的。<ul><li>主要是为了降低Full GC</li></ul></li></ul><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。<br>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p><h3 id="2-StringTable为什么要调整位置"><a href="#2-StringTable为什么要调整位置" class="headerlink" title="2 StringTable为什么要调整位置"></a>2 StringTable为什么要调整位置</h3><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而ful1gc是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h3 id="3-静态变量存放在那里？"><a href="#3-静态变量存放在那里？" class="headerlink" title="3 静态变量存放在那里？"></a>3 静态变量存放在那里？</h3><p>静态引用对应的对象实体始终都存在堆空间</p><p>可以使用 jhsdb.ext，需要在jdk9的时候才引入的</p><p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708215025527.png" alt="image-20200708215025527"></p><p>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。</p><p>接着，找到了一个引用该staticobj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708215218078.png" alt="image-20200708215218078"></p><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点</p><h2 id="9-8-方法区的垃圾回收"><a href="#9-8-方法区的垃圾回收" class="headerlink" title="9.8 方法区的垃圾回收"></a>9.8 方法区的垃圾回收</h2><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h2 id="9-9-总结"><a href="#9-9-总结" class="headerlink" title="9.9 总结"></a>9.9 总结</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9_%E6%96%B9%E6%B3%95%E5%8C%BA/images/image-20200708220303243.png" alt="image-20200708220303243"></p><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p>百度<br>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p><p>蚂蚁金服：<br>Java8的内存分代改进<br>JVM内存分哪几个区，每个区的作用是什么？<br>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？<br>二面：Eden和survior的比例分配</p><p>小米：<br>jvm内存分区，为什么要有新生代和老年代</p><p>字节跳动：<br>二面：Java的内存分区<br>二面：讲讲vm运行时数据库区<br>什么时候对象会进入老年代？</p><p>京东：<br>JVM的内存结构，Eden和Survivor比例。<br>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p><p>天猫：<br>一面：Jvm内存模型以及分区，需要详细到每个区放什么。<br>一面：JVM的内存模型，Java8做了什么改</p><p>拼多多：<br>JVM内存分哪几个区，每个区的作用是什么？</p><p>美团：<br>java内存分配<br>jvm的永久代中会发生垃圾回收吗？<br>一面：jvm内存分区，为什么要有新生代和老年代？</p><h1 id="第10章-对象实例化内存布局与访问定位"><a href="#第10章-对象实例化内存布局与访问定位" class="headerlink" title="第10章 对象实例化内存布局与访问定位"></a>第10章 对象实例化内存布局与访问定位</h1><h2 id="1-对象实例化"><a href="#1-对象实例化" class="headerlink" title="1 对象实例化"></a>1 对象实例化</h2><h3 id="1-1-面试题"><a href="#1-1-面试题" class="headerlink" title="1.1 面试题"></a>1.1 面试题</h3><ul><li>对象在JVM中是怎么存储的？</li><li>对象头信息里面有哪些东西？</li><li>Java对象头有什么？</li></ul><p>从对象创建的方式 和 步骤开始说</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709095356247.png" alt="image-20200709095356247"></p><h3 id="1-2-对象创建方式"><a href="#1-2-对象创建方式" class="headerlink" title="1.2 对象创建方式"></a>1.2 对象创建方式</h3><ul><li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li><li>使用序列化：序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ul><h3 id="1-3-创建对象的步骤"><a href="#1-3-创建对象的步骤" class="headerlink" title="1.3 创建对象的步骤"></a>1.3 创建对象的步骤</h3><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p><h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li><p>如果内存规整：指针碰撞</p></li><li><p>如果内存不规整</p><ul><li>虚拟表需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4 id="处理并发问题"><a href="#处理并发问题" class="headerlink" title="处理并发问题"></a>处理并发问题</h4><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul><li>在Eden区给每个线程分配一块区域</li></ul></li></ul><h3 id="1-4-初始化分配到的内存"><a href="#1-4-初始化分配到的内存" class="headerlink" title="1.4 初始化分配到的内存"></a>1.4 初始化分配到的内存</h3><p>给对象属性赋值的操作</p><ul><li><p>属性的默认初始化</p></li><li><p>显示初始化</p></li><li><p>代码块中的初始化</p></li><li><p>构造器初始化</p></li><li><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p></li></ul><h3 id="1-5-设置对象的对象头"><a href="#1-5-设置对象的对象头" class="headerlink" title="1.5 设置对象的对象头"></a>1.5 设置对象的对象头</h3><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h3 id="1-6-执行init方法进行初始化"><a href="#1-6-执行init方法进行初始化" class="headerlink" title="1.6 执行init方法进行初始化"></a>1.6 执行init方法进行初始化</h3><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><h3 id="1-7-对象实例化的过程"><a href="#1-7-对象实例化的过程" class="headerlink" title="1.7 对象实例化的过程"></a>1.7 对象实例化的过程</h3><ul><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ul><h2 id="1-8-对象内存布局"><a href="#1-8-对象内存布局" class="headerlink" title="1.8 对象内存布局"></a>1.8 对象内存布局</h2><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709151033237.png" alt="image-20200709151033237"></p><h3 id="1-9-对象头"><a href="#1-9-对象头" class="headerlink" title="1.9 对象头"></a>1.9 对象头</h3><p>对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针</p><blockquote><p>如果是数组，还需要记录数组的长度</p></blockquote><h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>翩向时间戳</li></ul><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</p><h3 id="1-10-实例数据（Instance-Data）"><a href="#1-10-实例数据（Instance-Data）" class="headerlink" title="1.10 实例数据（Instance Data）"></a>1.10 实例数据（Instance Data）</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><h3 id="1-11-小结"><a href="#1-11-小结" class="headerlink" title="1.11 小结"></a>1.11 小结</h3><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709152801713.png" alt="image-20200709152801713"></p><h2 id="2-对象的访问定位"><a href="#2-对象的访问定位" class="headerlink" title="2 对象的访问定位"></a>2 对象的访问定位</h2><h3 id="2-1-图示"><a href="#2-1-图示" class="headerlink" title="2.1 图示"></a>2.1 图示</h3><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709164149920.png" alt="image-20200709164149920"></p><h3 id="2-2-对象访问的两种方式"><a href="#2-2-对象访问的两种方式" class="headerlink" title="2.2 对象访问的两种方式"></a>2.2 对象访问的两种方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709164342002.png" alt="image-20200709164342002"></p><p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p><h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10_%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/images/image-20200709164350466.png" alt="image-20200709164350466"></p><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p><h1 id="第11章-直接内存-Direct-Memory"><a href="#第11章-直接内存-Direct-Memory" class="headerlink" title="第11章 直接内存 Direct Memory"></a>第11章 直接内存 Direct Memory</h1><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p><p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul><p>使用下列代码，直接分配本地内存空间</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> BUFFER = <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; <span class="hljs-comment">// 1GB</span>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</code></pre></div><h2 id="非直接缓存区和缓存区"><a href="#非直接缓存区和缓存区" class="headerlink" title="非直接缓存区和缓存区"></a>非直接缓存区和缓存区</h2><p>原来采用BIO的架构，我们需要从用户态切换成内核态</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/images/image-20200709170907611.png" alt="image-20200709170907611"></p><p>NIO的方式使用了缓存区的概念</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>也可能导致outofMemoryError异常</p><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。<br>缺点</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul><p>直接内存大小可以通过MaxDirectMemorySize设置</p><p>如果不指定，默认与堆的最大值-xmx参数值一致</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/images/image-20200709230647277.png" alt="image-20200709230647277"></p><h1 id="第12章执行引擎"><a href="#第12章执行引擎" class="headerlink" title="第12章执行引擎"></a>第12章执行引擎</h1><h2 id="1-执行引擎概述"><a href="#1-执行引擎概述" class="headerlink" title="1 执行引擎概述"></a>1 执行引擎概述</h2><p>执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710080707873.png" alt="image-20200710080707873"></p><p>执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p><p>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710081118053.png" alt="image-20200710081118053"></p><p>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p><h3 id="执行引擎的工作流程"><a href="#执行引擎的工作流程" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h3><ul><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710081627217.png" alt="image-20200710081627217"></p><p>从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p><h2 id="2-Java代码编译和执行过程"><a href="#2-Java代码编译和执行过程" class="headerlink" title="2 Java代码编译和执行过程"></a>2 Java代码编译和执行过程</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p><ul><li>前面橙色部分是生成字节码文件的过程，和JVM无关</li><li>后面蓝色和绿色才是JVM需要考虑的过程</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710082141643.png" alt="image-20200710082141643"></p><p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710082433146.png" alt="image-20200710082433146"></p><p>Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710083036258.png" alt="image-20200710083036258"></p><p>我们用一个总的图，来说说 解释器和编译器</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710083656277.png" alt="image-20200710083656277"></p><h3 id="2-1-什么是解释器（Interpreter）"><a href="#2-1-什么是解释器（Interpreter）" class="headerlink" title="2.1 什么是解释器（Interpreter）"></a>2.1 什么是解释器（Interpreter）</h3><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><h3 id="2-2-什么是IT编译器"><a href="#2-2-什么是IT编译器" class="headerlink" title="2.2 什么是IT编译器"></a>2.2 什么是IT编译器</h3><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><h3 id="2-3-为什么Java是半编译半解释型语言"><a href="#2-3-为什么Java是半编译半解释型语言" class="headerlink" title="2.3 为什么Java是半编译半解释型语言"></a>2.3 为什么Java是半编译半解释型语言</h3><p>JDK1.x时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p>翻译成本地代码后，就可以做一个缓存操作，存储在方法区中</p><h2 id="3-机器码、指令、汇编语言"><a href="#3-机器码、指令、汇编语言" class="headerlink" title="3 机器码、指令、汇编语言"></a>3 机器码、指令、汇编语言</h2><h3 id="3-1-机器码"><a href="#3-1-机器码" class="headerlink" title="3.1 机器码"></a>3.1 机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p><p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p><p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p><p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p><h3 id="3-2-指令"><a href="#3-2-指令" class="headerlink" title="3.2 指令"></a>3.2 指令</h3><p>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p><p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p><h3 id="3-3-指令集"><a href="#3-3-指令集" class="headerlink" title="3.3 指令集"></a>3.3 指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。<br>如常见的</p><ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul><h3 id="3-4-汇编语言"><a href="#3-4-汇编语言" class="headerlink" title="3.4 汇编语言"></a>3.4 汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p><p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbo1）或标号（Labe1）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><blockquote><p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</p></blockquote><h3 id="3-5-高级语言"><a href="#3-5-高级语言" class="headerlink" title="3.5 高级语言"></a>3.5 高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。</p><p>高级语言比机器语言、汇编语言更接近人的语言当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710085323733.png" alt="image-20200710085323733"></p><p>高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++</p><h3 id="3-6-C、C-源程序执行过程"><a href="#3-6-C、C-源程序执行过程" class="headerlink" title="3.6 C、C++源程序执行过程"></a>3.6 C、C++源程序执行过程</h3><p>编译过程又可以分成两个阶段：编译和汇编。</p><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710085553258.png" alt="image-20200710085553258"></p><h3 id="3-7-字节码"><a href="#3-7-字节码" class="headerlink" title="3.7 字节码"></a>3.7 字节码</h3><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p><ul><li>字节码典型的应用为：Java bytecode</li></ul><h2 id="4-解释器"><a href="#4-解释器" class="headerlink" title="4 解释器"></a>4 解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710090203674.png" alt="image-20200710090203674"></p><p>为什么Java源文件不直接翻译成JMV，而是翻译成字节码文件？可能是因为直接翻译的代码是比较大的</p><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p><h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><p>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</p><p>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p><p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p><ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</p><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p><h2 id="5-JIT编译器"><a href="#5-JIT编译器" class="headerlink" title="5 JIT编译器"></a>5 JIT编译器</h2><h3 id="5-1-Java代码的执行分类"><a href="#5-1-Java代码的执行分类" class="headerlink" title="5.1 Java代码的执行分类"></a>5.1 Java代码的执行分类</h3><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p><p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</p><h3 id="5-2-问题来了"><a href="#5-2-问题来了" class="headerlink" title="5.2 问题来了"></a>5.2 问题来了</h3><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p><ul><li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li></ul><p>首先明确：<br>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。<br>编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p>所以：<br>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</p><p>在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h3 id="5-3-HotSpot-JVM执行方式"><a href="#5-3-HotSpot-JVM执行方式" class="headerlink" title="5.3 HotSpot JVM执行方式"></a>5.3 HotSpot JVM执行方式</h3><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p><h3 id="5-4-案例"><a href="#5-4-案例" class="headerlink" title="5.4 案例"></a>5.4 案例</h3><p>注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710095417462.png" alt="image-20200710095417462"></p><h3 id="5-5-概念解释"><a href="#5-5-概念解释" class="headerlink" title="5.5 概念解释"></a>5.5 概念解释</h3><ul><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）</li><li>把字节码转变成机器码的过程。</li><li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。</li></ul><p>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p><p>JIT编译器：HotSpot VM的C1、C2编译器。</p><p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p><h3 id="5-6-热点探测技术"><a href="#5-6-热点探测技术" class="headerlink" title="5.6 热点探测技术"></a>5.6 热点探测技术</h3><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。</p><p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p><p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</p><p>采用基于计数器的热点探测，HotSpot V将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p><ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul><h3 id="5-7-方法调用计数器"><a href="#5-7-方法调用计数器" class="headerlink" title="5.7 方法调用计数器"></a>5.7 方法调用计数器</h3><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p><p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710101829934.png" alt="image-20200710101829934"></p><h3 id="5-8-热点衰减"><a href="#5-8-热点衰减" class="headerlink" title="5.8 热点衰减"></a>5.8 热点衰减</h3><p> 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）</p><ul><li>半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄</li></ul><p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<br>-XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p><p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p><h3 id="5-9-回边计数器"><a href="#5-9-回边计数器" class="headerlink" title="5.9 回边计数器"></a>5.9 回边计数器</h3><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710103103869.png" alt="image-20200710103103869"></p><h3 id="5-10-HotSpotVM-可以设置程序执行方法"><a href="#5-10-HotSpotVM-可以设置程序执行方法" class="headerlink" title="5.10 HotSpotVM 可以设置程序执行方法"></a>5.10 HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>-Xint：完全采用解释器模式执行程序；</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/JVM/1_%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/images/image-20200710103340273.png" alt="image-20200710103340273"></p><h3 id="5-11-HotSpotVM中-JIT-分类"><a href="#5-11-HotSpotVM中-JIT-分类" class="headerlink" title="5.11 HotSpotVM中 JIT 分类"></a>5.11 HotSpotVM中 JIT 分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><p>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；</p><ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。</li></ul></li><li><p>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。</p><ul><li>C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用C++）</li></ul></li></ul><h3 id="5-12-C1-和-C2编译器不同的优化策略"><a href="#5-12-C1-和-C2编译器不同的优化策略" class="headerlink" title="5.12 C1 和 C2编译器不同的优化策略"></a>5.12 C1 和 C2编译器不同的优化策略</h3><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现樊进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul><h3 id="5-13-分层编译策略"><a href="#5-13-分层编译策略" class="headerlink" title="5.13 分层编译策略"></a>5.13 分层编译策略</h3><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p><p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p><h3 id="5-14-总结"><a href="#5-14-总结" class="headerlink" title="5.14 总结"></a>5.14 总结</h3><ul><li>一般来讲，JIT编译出来的机器码性能比解释器搞</li><li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li></ul><h3 id="5-15-AOT编译器"><a href="#5-15-AOT编译器" class="headerlink" title="5.15 AOT编译器"></a>5.15 AOT编译器</h3><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p><p>Java 9引入了实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p><div class="code-wrapper"><pre><code class="hljs livescript">.java -&gt; .<span class="hljs-keyword">class</span> -&gt; <span class="hljs-function"><span class="hljs-params">(使用jaotc)</span> -&gt;</span> .so</code></pre></div><p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</p><p>缺点：</p><ul><li>破坏了 java  “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ul><h3 id="5-16-写到最后"><a href="#5-16-写到最后" class="headerlink" title="5.16 写到最后"></a>5.16 写到最后</h3><ul><li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器</li><li>编译效果短短几年时间就追评了G2编译器，未来可期</li><li>目前，带着实验状态标签，需要使用开关参数去激活才能使用</li></ul><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</span></code></pre></div>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Java/">Java</category>
      
      <category domain="https://pncalbl.github.io/categories/Java/Tool/">Tool</category>
      
      
      
      <comments>https://pncalbl.github.io/2021/07/20/JVM%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>基于物联网(IoT)的太阳能跟踪器</title>
      <link>https://pncalbl.github.io/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/</link>
      <guid>https://pncalbl.github.io/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/</guid>
      <pubDate>Mon, 07 Jun 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;基于物联网-IoT-的太阳能跟踪器&quot;&gt;&lt;a href=&quot;#基于物联网-IoT-的太阳能跟踪器&quot; class=&quot;headerlink&quot; title=&quot;基于物联网(IoT)的太阳能跟踪器&quot;&gt;&lt;/a&gt;基于物联网(IoT)的太阳能跟踪器&lt;/h1&gt;&lt;h2 id=&quot;1-项目概</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基于物联网-IoT-的太阳能跟踪器"><a href="#基于物联网-IoT-的太阳能跟踪器" class="headerlink" title="基于物联网(IoT)的太阳能跟踪器"></a>基于物联网(IoT)的太阳能跟踪器</h1><h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1 项目概述"></a>1 项目概述</h2><ul><li><p>该项目提供了一个简单和低成本的 IoT 解决方案，用于监控和控制智能双轴太阳能跟踪系统，用于性能评估。</p></li><li><p>项目中的基于 IoT 的太阳能跟踪系统在图 1 中进行了描述。它是一种双轴太阳能跟踪器，可以自动旋转，使用LDR传感器跟踪太阳的位置，或者用户通过物理控制的仪表板手动跟踪太阳的位置。系统从 LDR 传感器检测太阳位置（光的强度）开始，并将数据发送到控制器（Arduino Mega 板）。后者然后处理这些数据以命令保存器 （SM1 和 SM2），这些存储器将光伏面板旋转到太阳。产生的光伏电压值和电流、温度和湿度也通过相关传感器发送到 Arduino。</p></li><li><p>接下来，安装在 Arduino 并允许其连接到 Internet 的以太网扩展模块将把Arduino正在获取或处理的数据发送到云（Webserver）。最后，通过预制的小部件实时显示太阳跟踪器数据，包括LDR传感器、光伏功率、温度和湿度。物联网监控应用程序是使用我的设备卡宴。一旦用户从计算机或智能手机连接到互联网，他可以在物联网应用程序的仪表板中在其相关小部件中可视化所有太阳能跟踪器数据。因此，用户拥有与光伏面板的环境和性能相关的必要数据。</p></li><li><p>此外，在手动模式下，伺服运动器将从仪表板中的相关小部件中获取角度方向。因此，用户可以控制自己的系统，以寻求最佳的环境条件，并从光伏面板中提取最大能量。物联网应用程序还被编程为在senor达到预定阈值时发送通知警报（短信或电子邮件）。</p></li></ul><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/clip_image002.png" alt="图1. 项目总体设计图。"></p><p>​                                            </p><h2 id="2-硬件设计"><a href="#2-硬件设计" class="headerlink" title="2 硬件设计"></a>2 硬件设计</h2><ul><li>如图2所示，物联网太阳能跟踪系统由光伏电池板、两台伺服电机、四个LDR传感器、电压分频器电路、温度和湿度传感器、Led和Arduino Mega 板组成。</li></ul><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/electronic_circuit_of_the_iot-based_solar_tracker_system_9ORL3xysVy.png" alt="图2. 基于物联网（IoT）的太阳能跟踪器的硬件电路图。"></p><ul><li><p>使用的光伏面板尺寸为 115 mm 乘 85mm，输出为 1.6 W，可产生高达 6 V 的电压。两个180度的伺服器用于使太阳能跟踪器电机化，它们由阿尔杜伊诺板通过PWM引脚5和6控制。左右 （L-R） 伺服电机 （MG996R） 在垂直轴上（东/西）旋转太阳跟踪器，而上下 （U-D） 伺服电机 （SG90） 在水平轴 （南/北） 上旋转太阳跟踪器。</p></li><li><p>四个LDR（Cds GL5528）用于感应太阳的位置，这些位置已固定在面板的四个角落。LDR 传感器通过 A0 到 A3 的模拟引脚连接到阿尔杜伊诺。LDR 是一种电阻器，其值随着表面光强度事件的增加而降低。LDR 传感器设计为电压分流器电路，如图 2 所见。分频器输出电压由 Arduino Mega 的微控制器从模拟值转换为 0 到 1023 之间的数字值。因为微控制器的模拟数字转换器 （ADC） 编码为 10 位。LDR 传感器电路中的系列电阻器值为 330 Ω。</p></li><li><p>温度和湿度通过 DHT22 传感器测量。DHT22 内嵌有一个热电容器和电容湿度传感器，可测量温度和相对湿度。其温度范围为 -40 至 80 °C，准确度为 &lt; ±0.5°C，湿度范围为 0 至 100%，±2%（最大±5%）准确性。此传感器使用一根信号线将数据传输到 Arduino（数字引脚 2）和两根用于电源的电线。</p></li><li><p>光伏电压和电流通过电压分隔电路测量，该分频器也作为负载，由两个 10 Ohms 的系列电阻器组成。分频器电路输出与阿尔杜伊诺的模拟引脚 A4 相连。此外，连接到数字引脚 3 的 LED 在系统电路中反映了太阳能跟踪器（手动或自动）的模式状态。</p></li><li><p>Arduino Mega 与ATmega2560 微控制器用作嵌入式控制器，与阿尔杜伊诺以太网屏蔽以及监控平台交互。安装在 Arduino 板上方的以太网防护罩必须通过图 3 中显示的 RJ45 电缆与 Wi-Fi 路由器 （或 PC） 连接。以太网盾基于 Wiznet W5100 以太网芯片，该芯片为 TCP 和 UDP 协议提供了网络 （IP） 堆栈。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/image2_7PtCrbSgOy.png" alt="图3. arduino 和以太网扩展模块之间的硬件连接图。"></p></li></ul><h2 id="3-软件设计"><a href="#3-软件设计" class="headerlink" title="3 软件设计"></a>3 软件设计</h2><h3 id="3-1-Arduino-IDE"><a href="#3-1-Arduino-IDE" class="headerlink" title="3.1 Arduino IDE"></a>3.1 Arduino IDE</h3><p>Arduino 是一个开源电子原型平台，具有易于使用的硬件和软件。Arduino 平台提供集成开发环境 （IDE），其中包括对 C 和C++编程语言的支持。本作品中使用的 Arduino 板由 IDE 编程，该 IDE 充当代码编辑器，程序代码可以通过 USB 电缆上传到微控制器，如图 3 所示。Arduino 巨型板用于实现基于物联网的太阳能跟踪器的所有软件要求。</p><h3 id="3-2-myDevices-Cayenne-我的设备卡宴"><a href="#3-2-myDevices-Cayenne-我的设备卡宴" class="headerlink" title="3.2 myDevices Cayenne (我的设备卡宴)"></a>3.2 myDevices Cayenne (我的设备卡宴)</h3><ul><li>MyDevices 是一家提供完美的物联网解决方案的公司。它为 IoT 提供了端到端平台。在我们的项目中，我们将专注于卡宴，这是来自我的设备的解决方案之一。此工具允许开发人员、设计师和工程师构建物机原型。卡宴使用消息排队电信传输 （MQTT） 协议将任何设备与卡延内克云连接起来。连接后，用户可以通过创建的小部件将设备中的数据发送并接收到 Cayenne 仪表板。MQTT 是基于 TCP/IP 协议的发布订阅消息协议。发布订阅方法使用负责向客户端传递消息的消息代理。MQTT 是用于向卡宴云或卡宴控制的设备发送信息的 API。此连接中的消息代理是云，它管理发送和接收数据的不同客户端（传感器和执行器）。</li><li>要使用 MQTT 与卡宴， 我们需要使用卡宴库。对于阿尔杜伊诺，可以从 IDE 的图书馆经理安装卡延内MQTT 库。要对基于 Cayenne 物联网平台的物联网应用进行编程，我们将利用预先定义的功能。例如，为了建立 Cayenne 云和配备以太网模块的 Arduino Mega 之间的连接，我们调用 CayenneMQTT 以太网库，在那里我们声明我们的身份验证信息（用户名、密码和客户 ID），这些信息应从 Cayenne 仪表板获得。然后，在程序的设置部分，我们调用 <em>Cayenne.开始 （）</em>功能来建立与 Cayenne 仪表板的连接。对于每个执行器，我们创建一个功能，其整数参数在 0 到 31 之间，称为 <em>CAYENNE IN（虚拟通道）。</em>对于每个传感器，我们创建一个功能，其整数参数在 0 到 31 之间，称为<em>CAYENNE_OUT （VIRTUAL_CHANNEL）</em>。在程序的循环部分，我们称为预先定义的函数 <em>Cayenne.loop （），</em>该函数本身称为功能<em>CAYENNE_OUT</em>和<em>CAYENNE_IN。</em>虚拟通道，因为它的名称建议是一个通道，没有物理存在，它的特点是可视化或命令小部件。它允许它们与相应的传感器或执行器连接。</li></ul><h3 id="3-3-The-embedded-software-design-嵌入式软件设计"><a href="#3-3-The-embedded-software-design-嵌入式软件设计" class="headerlink" title="3.3 The embedded software design(嵌入式软件设计)"></a>3.3 The embedded software design(嵌入式软件设计)</h3><p>嵌入式软件将嵌入到 Arduino Mega 中，以便在以太网模块和 Cayenne 云之间进行交互（参见附录）。其设计如下：</p><h4 id="1-功能模式"><a href="#1-功能模式" class="headerlink" title="1 功能模式"></a>1 功能模式</h4><ul><li><p>基于物联网的太阳能跟踪器具有两种功能模式：手动和自动。在 Cayenne 仪表板中创建的按钮具有在两种模式之间切换的作用。非活动时，选择手动模式，否则自动模式。此外，在 Arduino 代码中还建立了一个功能，允许恢复按钮的状态。系统电路中的 LED 反映了此开关的状态。</p></li><li><p>因此，要使控制器了解所选的操作模式，我们只需要测试 LED 连接的引脚状态。例如，如果 LED 状态较低，控制器将调用手动模式功能执行，否则将调用自动功能。</p></li></ul><h4 id="2-手动模式"><a href="#2-手动模式" class="headerlink" title="2 手动模式"></a>2 手动模式</h4><ul><li><p>如果选择手动模式，用户可以直接控制伺服器的位置，通过 L-R 伺服器将光伏板从东向西定向，或通过 U-D 伺服器从南向北定向。该控制由物联网应用程序仪表板中服务器运动器的相关小部件组成。</p></li><li><p>在此模式下，控制器调用 <strong><em>Cayenne.loop（）</em></strong>功能，该函数本身调用所有<strong><em>功能CAYENNE_IN（</em></strong>包括与伺服器相关的功能）执行。 <strong>Cayenne.loop（）</strong>功能还将调用与传感器相连的所有功能CAYENNE_OUT执行。如果将与 LDR 传感器、光伏电流、电压和功率、温度和湿度相关的数据发送到服务器，以便在物联网应用程序中的相关小部件中可视化这些数据。</p></li></ul><h4 id="3-自动模式"><a href="#3-自动模式" class="headerlink" title="3 自动模式"></a>3 自动模式</h4><ul><li><p>如果选择自动模式，将执行图 4 中显示的算法。该算法首先阅读 LDR 传感器返回的模拟值。然后，它会处理这些数据以命令将光伏面板移向太阳位置的伺服运动器。考虑到基于垂直轴的太阳能跟踪器运动，比较了左侧两个LDR和右侧两个LDR的平均值，如果左侧接收到更多的光，光伏电池板将朝这个方向（顺时针方向）穿过L-R伺服器。当差额结果在 -10 和 10 之间时，后者将停止。此范围用于稳定控制器并降低伺服器的功耗。否则，如果正确的LDR集接收更多的光，光伏面板将朝这个方向移动（逆时针）通过L-R伺服器，并将继续旋转，直到差异结果在范围内[−10，10]。同一方法用于基于水平轴的太阳能跟踪器运动，比较顶部两个LDR和底部两个LDR的平均值。</p></li><li><p>除了在自动模式下，控制器还将调用 <strong><em>Cayenne.loop（）</em></strong>功能将太阳能跟踪器数据发送到 IoT 应用程序。</p></li></ul><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/image_3_pZv5s80gr2.png" alt="图4. 太阳能跟踪器自动模式的流程图。"></p><h3 id="3-4-Development-of-the-IoT-monitoring-application-开发-IoT-监控应用程序"><a href="#3-4-Development-of-the-IoT-monitoring-application-开发-IoT-监控应用程序" class="headerlink" title="3.4 Development of the IoT monitoring application(开发 IoT 监控应用程序)"></a>3.4 Development of the IoT monitoring application(开发 IoT 监控应用程序)</h3><h4 id="1-硬件与卡宴-IoT-平台的连接"><a href="#1-硬件与卡宴-IoT-平台的连接" class="headerlink" title="1 硬件与卡宴 IoT 平台的连接"></a>1 硬件与卡宴 IoT 平台的连接</h4><p>要将硬件（包括传感器和执行器）与物联网络平台对接，我们需要遵循以下步骤：</p><ul><li><p>创建帐户后登录卡宴我的Device网站（图5（a））。</p></li><li><p>然后，单击 Cayenne API 中的”自带东西”（图 5（b））。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig5_jaSC4EBHxI.png" alt="图5. 卡宴IoT平台注册（a）。卡宴API（b）。"></p></li><li><p>从克里特岛应用程序（图6）复制 MQTT 凭据（用户名、密码和客户 ID），并将其粘贴到 Arduino 源代码中，如前所述。在成功编译并上传整个代码到 Arduino Mega 后，在 Arduino IDE 中打开串行监视器以获取 Cayenne 日志打印（图 7）。一旦我们的设备上线并连接到 Cayenne，上一页（图 6）将自动更新，我们将在在线仪表板中看到我们的设备，如图 8 所见。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig6_qCu0wEtQwz.png" alt="图6. MQTT凭据和设备连接到卡宴。"></p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fige_yYB61wSOY4.png" alt="图7. 卡宴日志打印在串行监视器上。"></p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig8_lQi9h5PnKM.png" alt="图8. 设备设置。"></p></li><li><p>然后，要接口传感器和执行器，即创建其小部件，单击”添加新…”，选择”设备/小部件”，然后单击”自定义小部件”（图 9）。然后，选择小部件并填充相关设置（通道号必须与代码相同），最后单击”添加小部件”将其添加到设备的仪表板。对于我们来说，我们为所有传感器选择了”价值”小部件，为模式切换选择了”按钮”小部件，为伺服器选择了”滑块”小部件。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig9_0KAhjvvj5M.png" alt="图9. 卡宴自定义小部件。"></p></li></ul><p>最后，图10说明了用于监测太阳能跟踪器数据的设计物联网应用程序。与太阳跟踪器系统建立连接后，传感器数据可以在其相关部件上可视化，跟踪模式（自动或手动）可以从开关按钮中选择，并通过小部件控制伺服者的角度。还可以通过修改其设置中的表示类型或单击小部件上方的图形图标以图形形式获取传感器数据。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig10_Om7yhhrJcO.png" alt="图10. 太阳能跟踪系统的IoT监控应用。"></p><h4 id="2-警报创建"><a href="#2-警报创建" class="headerlink" title="2 警报创建"></a>2 警报创建</h4><p>监控系统中最重要的标准之一是，当发生与其监控设备相关的事件时，它能够发送通知警报通知用户。为此，我们利用 Cayenne 的一个功能为我们的物联网应用程序添加警报，在那里我们可以预先编程我们的应用程序以发送通知警报（短信、电子邮件或两者兼有）或执行指定操作。例如，创建温度警报，以便在监控温度达到阈值时向用户（或收件人）发送电子邮件通知，如图 11 所示。要创建警报，请单击”添加新。”然后选择”触发”，然后设置事件及其操作，最后单击”保存”将其添加到仪表板。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/fig11_HcTpIiwQOI.png" alt="图11. 温度警报设置。"></p><h2 id="4-原型设计"><a href="#4-原型设计" class="headerlink" title="4 原型设计"></a>4 原型设计</h2><p>图12展示了太阳能跟踪器原型在其分离和组装状态。它由光伏面板、R 和 U-D 伺服器和 LDR 传感器组成。该面板一侧连接到 U-Dservomotor，另一侧有轴承，以确保当太阳能跟踪器围绕水平轴旋转时更好的灵活性。装配连接到 L-R 伺服器。LDR 传感器固定在空心气缸内面板的四个角落。如果面板不垂直于太阳，则至少有一个 LDR 将被周围圆柱体造成的阴影覆盖。因此，光强度会有差异。最佳方向是当光的特性在所有LDR传感器中是相等的。图13显示了基于 IoT 的太阳能跟踪系统的整个原型，很明显，硬件部分中的所有报告组件都已用于构建它。</p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/solar_tracker_prototype_in_its_detached_and_assembled_state_zbScjRgUaK.png" alt="图12. 太阳能跟踪器原型处于组装和分离状态"></p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/iot_based_solar_tracker_prototype__PG9L9gMmwr.png" alt="图13. 基于IOT的太阳能跟踪器原型"></p><p>有关所获结果的更多详细信息，请参阅本链接中的论文： <a href="https://link.springer.com/chapter/10.1007%2F978-3-030-64565-6_4">https://link.springer.com/chapter/10.1007%2F978-3-030-64565-6_4</a></p><h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5 代码"></a>5 代码</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/***************************************************************</span><span class="hljs-comment"> PROJECT: IoT based solar tracker system / the embedded software</span><span class="hljs-comment"> Aboubakr El Hammoumi/ aboubakr.elhammoumi@usmba.ac.ma</span><span class="hljs-comment">***************************************************************/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CAYENNE_PRINT Serial</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;CayenneMQTTEthernet.h&gt;</span>    <span class="hljs-comment">//CayenneMQTT library </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Servo.h&gt;</span>                  <span class="hljs-comment">//Servo motor library </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;DHT.h&gt;</span>                    <span class="hljs-comment">//DHT library </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DHTTYPE DHT22</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DHTPIN 2</span><span class="hljs-function">DHT <span class="hljs-title">dht</span><span class="hljs-params">(DHTPIN,DHTTYPE)</span></span>;<span class="hljs-comment">//MQTT credentials   </span><span class="hljs-keyword">char</span> username[]=<span class="hljs-string">&quot;498d2d00-afe2-11ea-883c-638d8ce4c23d&quot;</span>;<span class="hljs-keyword">char</span> password[]=<span class="hljs-string">&quot;ab4a8f92d94033c01f6e18ce1d8a84d8c304c9c4&quot;</span>;<span class="hljs-keyword">char</span> clientID[]=<span class="hljs-string">&quot;17798a40-b968-11ea-93bf-d33a96695544&quot;</span>;Servo servo_x;                   <span class="hljs-comment">//up-down servomotor  </span><span class="hljs-keyword">int</span> servoh = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> servohLimitHigh = <span class="hljs-number">170</span>;     <span class="hljs-keyword">int</span> servohLimitLow = <span class="hljs-number">10</span>;       Servo servo_z;                   <span class="hljs-comment">//left-right servomotor </span><span class="hljs-keyword">int</span> servov = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> servovLimitHigh = <span class="hljs-number">170</span>;<span class="hljs-keyword">int</span> servovLimitLow = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> topl,topr,botl,botr;<span class="hljs-keyword">int</span> threshold_value=<span class="hljs-number">10</span>;        <span class="hljs-keyword">float</span> Vout;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123; Serial.begin(<span class="hljs-number">9600</span>);  Cayenne.begin(username, password, clientID);  servo_x.attach(<span class="hljs-number">5</span>);  servo_z.attach(<span class="hljs-number">6</span>);  dht.begin();  pinMode(<span class="hljs-number">3</span>,OUTPUT);  digitalWrite(<span class="hljs-number">3</span>,LOW); &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123; topr= analogRead(A2);         topl= analogRead(A3);           botl= analogRead(A4);           botr= analogRead(A5);          Vout=(analogRead(A1) * <span class="hljs-number">5.0</span>) / <span class="hljs-number">1023</span>;  Serial.println(<span class="hljs-string">&quot; Manual-mode&quot;</span>);  Cayenne.loop();    <span class="hljs-keyword">if</span> (digitalRead(<span class="hljs-number">3</span>)==HIGH)&#123;    Serial.println(<span class="hljs-string">&quot; Automatic-mode&quot;</span>);    servoh = servo_x.read();    servov = servo_z.read();    <span class="hljs-keyword">int</span> avgtop = (topr + topl) / <span class="hljs-number">2</span>;         <span class="hljs-keyword">int</span> avgbot = (botr + botl) / <span class="hljs-number">2</span>;       <span class="hljs-keyword">int</span> avgright = (topr + botr) / <span class="hljs-number">2</span>;       <span class="hljs-keyword">int</span> avgleft = (topl + botl) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> diffhori= avgtop - avgbot;          <span class="hljs-keyword">int</span> diffverti= avgleft - avgright;            <span class="hljs-comment">/*tracking according to horizontal axis*/</span>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(diffhori) &lt;= threshold_value)    &#123;     servo_x.write(servoh);            <span class="hljs-comment">//stop the servo up-down</span>    &#125;<span class="hljs-keyword">else</span> &#123;       <span class="hljs-keyword">if</span> (diffhori &gt; threshold_value)          &#123; Serial.println(<span class="hljs-string">&quot; x - 2 &quot;</span>);          servo_x.write(servoh <span class="hljs-number">-2</span>);    <span class="hljs-comment">//Clockwise rotation CW</span>          <span class="hljs-keyword">if</span> (servoh &gt; servohLimitHigh)          &#123;           servoh = servohLimitHigh;          &#125;          delay(<span class="hljs-number">10</span>);          &#125;<span class="hljs-keyword">else</span> &#123;           servo_x.write(servoh +<span class="hljs-number">2</span>);   <span class="hljs-comment">//CCW</span>           <span class="hljs-keyword">if</span> (servoh &lt; servohLimitLow)           &#123;           servoh = servohLimitLow;           &#125;           delay(<span class="hljs-number">10</span>);           &#125;      &#125;          <span class="hljs-comment">/*tracking according to vertical axis*/</span>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(diffverti) &lt;= threshold_value)    &#123;          servo_z.write(servov);       <span class="hljs-comment">//stop the servo left-right</span>    &#125;<span class="hljs-keyword">else</span>&#123;       <span class="hljs-keyword">if</span> (diffverti &gt; threshold_value)       &#123;        servo_z.write(servov <span class="hljs-number">-2</span>);  <span class="hljs-comment">//CW</span>       <span class="hljs-keyword">if</span> (servov &gt; servovLimitHigh)        &#123;        servov = servovLimitHigh;       &#125;       delay(<span class="hljs-number">10</span>);       &#125;<span class="hljs-keyword">else</span>&#123;         servo_z.write(servov +<span class="hljs-number">2</span>);  <span class="hljs-comment">//CCW</span>        <span class="hljs-keyword">if</span> (servov &lt; servovLimitLow)         &#123;        servov = servovLimitLow;        &#125;        delay(<span class="hljs-number">10</span>);        &#125;     &#125;  &#125;&#125;<span class="hljs-comment">// Cayenne Functions</span>CAYENNE_IN(<span class="hljs-number">8</span>)&#123;  <span class="hljs-keyword">int</span> value = getValue.asInt();  CAYENNE_LOG(<span class="hljs-string">&quot;Channel %d, pin %d, value %d&quot;</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, value);  digitalWrite(<span class="hljs-number">3</span>,value);&#125;CAYENNE_IN(<span class="hljs-number">7</span>)&#123; <span class="hljs-comment">//up-down servo motor</span>  <span class="hljs-keyword">if</span> (digitalRead(<span class="hljs-number">3</span>)==HIGH)&#123; <span class="hljs-comment">//Automatic_mode</span>  &#125;  <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//Manual_mode</span>  servo_x.write(getValue.asDouble() * <span class="hljs-number">180</span>);  &#125;&#125;CAYENNE_IN(<span class="hljs-number">6</span>)&#123; <span class="hljs-comment">//left-right servo motor</span>  <span class="hljs-keyword">if</span> (digitalRead(<span class="hljs-number">3</span>)==HIGH)&#123;  &#125;    <span class="hljs-keyword">else</span>&#123;  servo_z.write(getValue.asDouble() * <span class="hljs-number">180</span>);  &#125;&#125;CAYENNE_OUT(<span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//Current</span>  <span class="hljs-keyword">float</span> current = Vout/<span class="hljs-number">10</span>;  Cayenne.virtualWrite(<span class="hljs-number">0</span>, current);  Serial.print(<span class="hljs-string">&quot;Current: &quot;</span>);  Serial.println(current);&#125;CAYENNE_OUT(<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//Voltage</span>  <span class="hljs-keyword">float</span> voltage = Vout * <span class="hljs-number">2</span>;  Cayenne.virtualWrite(<span class="hljs-number">1</span>, voltage);  Serial.print(<span class="hljs-string">&quot;Voltage: &quot;</span>);  Serial.println(voltage);&#125;CAYENNE_OUT(<span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//LDR Top-right</span>  Cayenne.virtualWrite(<span class="hljs-number">2</span>, topr);&#125;CAYENNE_OUT(<span class="hljs-number">3</span>)&#123; <span class="hljs-comment">//LDR Top-left</span>  Cayenne.virtualWrite(<span class="hljs-number">3</span>,topl);&#125;CAYENNE_OUT(<span class="hljs-number">4</span>)&#123; <span class="hljs-comment">//LDR Bot-left</span>  Cayenne.virtualWrite(<span class="hljs-number">4</span>,botl);&#125;CAYENNE_OUT(<span class="hljs-number">5</span>)&#123; <span class="hljs-comment">//LDR Bot-right</span>  Cayenne.virtualWrite(<span class="hljs-number">5</span>,botr);&#125;CAYENNE_OUT(<span class="hljs-number">10</span>) &#123; <span class="hljs-comment">//Power</span>  <span class="hljs-keyword">float</span> power = (Vout * <span class="hljs-number">2</span> * Vout)/<span class="hljs-number">10</span> ;  Cayenne.virtualWrite(<span class="hljs-number">10</span>, power);  Serial.print(<span class="hljs-string">&quot;Power: &quot;</span>);  Serial.println(power);&#125;CAYENNE_OUT(<span class="hljs-number">11</span>)&#123; <span class="hljs-comment">//Temperature</span>  <span class="hljs-keyword">float</span> t = dht.readTemperature();  <span class="hljs-comment">//int chk = dht.read(DHT11PIN);</span>  Cayenne.virtualWrite(<span class="hljs-number">11</span>, t, TYPE_TEMPERATURE, UNIT_CELSIUS);  Serial.print(<span class="hljs-string">&quot;temperature: &quot;</span>);  Serial.println(t);&#125;CAYENNE_OUT(<span class="hljs-number">12</span>)&#123; <span class="hljs-comment">//Huidity</span>  <span class="hljs-keyword">float</span> h = dht.readHumidity();  <span class="hljs-comment">//int chk = dht.read(DHT11PIN);</span>  Cayenne.virtualWrite(<span class="hljs-number">12</span>, h);  Serial.print(<span class="hljs-string">&quot;  humidity: &quot;</span>);  Serial.println(h);&#125;</code></pre></div><h2 id="6-发展示例"><a href="#6-发展示例" class="headerlink" title="6 发展示例"></a>6 发展示例</h2><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/img_3581_XDaDENY3ax.JPG" alt="太阳能电池板太阳跟踪器 - 手机充电器"></p><p><img src="/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/image-20210607020629991.png" alt="巨型太阳能跟踪器"></p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Hardware/">Hardware</category>
      
      
      <category domain="https://pncalbl.github.io/tags/IoT/">IoT</category>
      
      <category domain="https://pncalbl.github.io/tags/%E5%A4%AA%E9%98%B3%E8%83%BD/">太阳能</category>
      
      
      <comments>https://pncalbl.github.io/2021/06/08/%E5%9F%BA%E4%BA%8E%E7%89%A9%E8%81%94%E7%BD%91(IoT)%E7%9A%84%E5%A4%AA%E9%98%B3%E8%83%BD%E8%B7%9F%E8%B8%AA%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ElasticSearch 学习</title>
      <link>https://pncalbl.github.io/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Mon, 24 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;ElasticSearch-学习&quot;&gt;&lt;a href=&quot;#ElasticSearch-学习&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch 学习&quot;&gt;&lt;/a&gt;ElasticSearch 学习&lt;/h1&gt;&lt;h2 id=&quot;0-聊聊DougC</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="ElasticSearch-学习"><a href="#ElasticSearch-学习" class="headerlink" title="ElasticSearch 学习"></a>ElasticSearch 学习</h1><h2 id="0-聊聊DougCutting"><a href="#0-聊聊DougCutting" class="headerlink" title="0 聊聊DougCutting"></a>0 聊聊DougCutting</h2><p>为什么要讲这个人,后面要聊大数据</p><blockquote><p>  本故事内容来自公众号：新枣课堂</p></blockquote><p>1998年9月4号,google公司在美国硅谷成立.正如大家所知,它是一家搜索引擎起家的公司</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610550313.png" alt></p><p>无独有偶,一位名叫DougCutting的美国工程师,也迷上了搜索引擎.他做了一个用于文本搜索的函数库(姑且理解为软件的功能组件),命名为Lucene.</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610568104.png" alt></p><p>Lucene使用Java写的,目标是为各种中小型应用软件加入全文检索功能.因为好用而且开源(代码公开),非常受程序员们稀罕)</p><p>在这个过程中,google确实找到了不少好的办法,并且无私地分享了出来.</p><p>开源是一种精神!</p><p>2003年,google发表了一篇技术学术论文,公开介绍了自己的谷歌文件系统GFS(google File System).这是google公司为了存储海量搜素数据而设计的专用文件系统</p><p>第二年,2004年,Doug Cutting基于google的GFS论文,实现了分布式文件存储系统,并将它命名为NDFS(Nutch Distributed File System)</p><p>还是2004年,google又发表了一篇技术学术论文,介绍自己的MapReduce编程模型.这个编程模型,用于大规模数据集(大于1TB)的并行分析运算.</p><p>2005年,Doug Cutting 又基于MapReduce,在Nutch搜索引擎实现了该功能.</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610581999.png" alt></p><p>2006年,当时依然很厉害的Yahoo(雅虎)公司,招安了Doug Cutting</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610607769.png" alt></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610720399.png" alt></p><p>我们继续往下说.</p><p>还是2006年,google有发表论文了</p><p>这次,他们介绍自己的BigTable,这是一种分布式的数据存储系统,一种用来处理海量数据的非关系型数据库.</p><p>Doug Cutting 当然没有放过,在自己的hadoop系统里面,引入了BigTable,并命名为HBase.</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610829469.png" alt></p><p>好吧,反正就是紧跟Google时代步伐,你出什么,我学什么</p><p>所有,Hadoop的核心部分,基本上都有Google的影子.</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596610891867.png" alt></p><p>2008年1月,Hadoop成功上位,成为Apache基金会的顶级项目.</p><p>同年2月,Yahoo宣布建成了一个拥有1W个内核的Hadoop集群,并将自己的搜索引擎产品部署在上面.</p><p>7月,Hadoop打破世界纪录,成为最快排序1TB数据的系统,用时209秒.</p><h2 id="1-什么是Elasticsearch？"><a href="#1-什么是Elasticsearch？" class="headerlink" title="1 什么是Elasticsearch？"></a>1 什么是Elasticsearch？</h2><h3 id="1-1-Lucene简介"><a href="#1-1-Lucene简介" class="headerlink" title="1.1 Lucene简介"></a>1.1 Lucene简介</h3><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/lucene_logo_green_300.png" alt="Lucene Logo"></p><ul><li>Lucene是一套用于<strong>全文检索</strong>和<strong>搜寻</strong>的<strong>开源</strong>程序库，由Apache软件基金会支持和提供</li><li>Lucene提供了一个简单却强大的应用程序接口（API），能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放源代码工具</li><li>Lucene并不是现成的搜索引擎产品，但可以用来制作搜索引擎产品</li><li>Lucene是一套信息检索工具包! jar包!不包含搜索引擎系统!<ul><li>Lucene包含:索引结构!读写索引的工具!排序,搜索规则…工具类!等</li></ul></li><li><strong>Lucene和ElasticSearch关系</strong>:<ul><li>简单来说，ElasticSearch是基于Lucene做了一些<strong>封装</strong>和*<em>增强 *</em></li></ul></li></ul><h3 id="1-2-ElasticSearch简介"><a href="#1-2-ElasticSearch简介" class="headerlink" title="1.2 ElasticSearch简介"></a>1.2 ElasticSearch简介</h3><ul><li><p>ElasticSearch是一个<strong>实时分布式搜索和分析引擎</strong>。它让你以前所未有的速度处理大数据成为可能。</p></li><li><p>它用于<strong>全文搜索、结构化搜索、分析</strong>以及将这三者混合使用:</p><ul><li>维基百科使用Elasticsearch提供<strong>全文搜索并高亮关键字</strong> ,以及<strong>输入实时搜索(search-asyou-type)</strong>和<strong>搜索纠错(did-you-mean)</strong>等搜索建议功能。</li><li>英国卫报使用Elasticsearch结合用户日志和社交网络数据提供给他们的编辑以<strong>实时的反馈</strong>,以便及时了解公众对新发表的文章的回应。</li><li>StackOverflow结合<strong>全文搜索</strong>与<strong>地理位置查询</strong>,以及more-like-this功能来找到相关的问题和答案。</li><li>Github使用Elasticsearch检索<strong>1300亿</strong>行的代码。</li></ul></li><li><p>并且Elasticsearch不仅用于大型企业,它还让像DataDog以及Klout这样的创业公司将最初的想法变成可扩展的解决方案。</p></li><li><p>Elasticsearch可以在你的笔记本。上运行，也可以在数以百计的服务器上<strong>处理PB级别的数据</strong>。</p></li><li><p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。 无论在开源还是专有领域, Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p></li><li><p>但是, Lucene只是一个库。想要使用它,你必须使用Java来作为开发语言并将其直接集成到你的应用中,更糟糕的是, Lucene非常复杂,你需要深入了解检索的相关知识来理解它是如何工作的。</p></li><li><p>Elasticsearch也使用<strong>Java</strong>开发并使用Lucene作为其核心来实现所有索引和搜索的功能,它的目的是通过简单的<strong>RESTful API</strong>（REST风格的网络接口，是当下主流的API）来隐藏Lucene的复杂性,从而让全文搜索变得简单。</p></li></ul><h3 id="1-3-ElasticSearch的应用场景"><a href="#1-3-ElasticSearch的应用场景" class="headerlink" title="1.3 ElasticSearch的应用场景"></a>1.3 ElasticSearch的应用场景</h3><ul><li><p>维基百科,类似百度百科,<strong>全文检索</strong>,<strong>高亮</strong>,<strong>搜索推荐</strong></p></li><li><p>The Guardian (国外新闻网站) , 类似搜狐新闻,用户行为日志(点击,浏览,收藏,评论) +社交网络数据(对某某新闻的相关看法) ,数据分析,给到每篇新闻文章的作者,让他知道他的文章的公众反馈</p></li><li><p>Stack Overflow (国外的程序异常讨论论坛) , IT问题,程序的报错, 提交上去,有人会跟你讨论和回答,全文检索,搜索相关问题和答案,程序报错了,就会将报错信息粘贴到里面去,搜索有没有对应的答案</p></li><li><p>GitHub (开源代码管理)</p></li><li><p>电商网站,<strong>检索商品</strong>.</p></li><li><p>日志数据分析, logstash采集日志, ES进行复杂的数据分析, <strong>ELK技术, elasticsearch（搜索）+logstash（过滤）+kibana（可视化分析）</strong></p></li><li><p>商品价格监控网站,用户设定某商品的价格阈值,当低于该阈值的时候,发送通知消息给用户,比如说订阅牙膏的监控：如果高露洁牙膏的家庭套装低于50块钱,就通知我,我就去买</p></li><li><p>BI系统 ,商业智能, Business Intelligence.比如说有个大型商场集团, BI分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成,产出相关的数张报表, 最近3年,每年消费金额呈现100%的增长,而且用户群体85%是高级白领。</p></li><li><p>国内:<strong>站内搜索</strong>(电商，招聘，门户，等等)，<strong>IT系统搜索</strong>(OA,CRM,ERP，等等)，<strong>数据分析</strong>(ES热门的一个使用场景)</p></li></ul><p>总而言之，Elasticsearch就是提供<strong>高效</strong>、<strong>个性化检索</strong>需求的一种解决方案</p><h3 id="1-4-ELK简介"><a href="#1-4-ELK简介" class="headerlink" title="1.4 ELK简介"></a>1.4 ELK简介</h3><ul><li><p>ELK是<strong>Elasticsearch、Logstash、Kibana</strong>三大开源框架首字母大写简称。市面上也被成为Elastic Stack。</p><ul><li>其中ElasticSearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架,可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为es.</li><li>Logstash是ELK的<strong>中央数据流引擎</strong>,用于<strong>从不同目标</strong>(文件/数据存储/MQ )<strong>收集的不同格式数据</strong>,经过过滤后支持输出以到不同目的地(文件/MQ/redis/elasticsearch/kafka等)。</li><li>Kibana可以将es的<strong>数据</strong>通过友好的页面<strong>展示</strong>出来 ,提供实时分析的功能。</li></ul></li><li><p>总结一下就是：<strong>收集清洗数据–&gt;建立索引，储存–&gt;Kibana分析</strong></p></li><li><p>市面上很多开发只要提到ELK能够一致说出它是一 个日志分析架构技术栈总称,但实际上ELK不仅仅适用于日志分析,它还可以<strong>支持其它任何数据分析和收集的场景</strong>,日志分析和收集只是更具有代表性，并非唯一性。</p></li></ul><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105031.png" alt></p><h2 id="2-其他搜索引擎"><a href="#2-其他搜索引擎" class="headerlink" title="2 其他搜索引擎"></a>2 其他搜索引擎</h2><h3 id="2-1-Solr简介"><a href="#2-1-Solr简介" class="headerlink" title="2.1 Solr简介"></a>2.1 Solr简介</h3><ul><li><p>Solr是Apache下的一个顶级开源项目,采用java开发,它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言,同时实现了可配置、可扩展，并对索引、搜索性能进行了优化</p></li><li><p>Solr可以独立运行在Jetty、Tomcat等这些Servlet容器中 , Solr索引的实现方法很简单,用POST方法向Solr服务器发送一个描述Field及其内容的XML文档，Solr根据xml文档添加、删除、更新索引。</p></li><li><p>列如：搜索name==dayceng&lt;&gt;</p><ul><li>Solr 搜索只需要发送HTTP GET请求,然后对Solr返回xml、<strong>json</strong>等格式的查询结果进行解析,组织页面布局。Solr不提供构建UI的功能, Solr提供了一个管理界面,通过管理界面可以查询Solr的配置和运行情况。</li></ul></li><li><p>solr是基于lucene开发企业级搜索服务器,实际上就是封装了lucene.</p></li><li><p>Solr是一个独立的企业级搜索应用服务器,它对外提供类似于Web-service的API接口。用户可以通过http请求,向搜索引擎服务器提交一定格式的文件,生成索引;也可以通过提出查找请求,并得到返回结果。</p></li></ul><h3 id="2-2-ES与Solr对比"><a href="#2-2-ES与Solr对比" class="headerlink" title="2.2 ES与Solr对比"></a>2.2 ES与Solr对比</h3><ul><li><p>单纯地对已有的数据进行搜索，Solr更快</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105035.png" alt></p></li><li><p>当建立<strong>实时索引</strong>时，Solr会产生IO阻塞，查询性能较差，此时ES具有明显优势</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105045.png" alt></p></li><li><p>随着搜索量的增加，Solr的劣势愈发明显，ES无明显变化</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105121.png" alt></p></li><li><p><strong>总结</strong></p><ul><li>ES基本是开箱即用，非常简单。Solr安装略微复杂</li><li>Solr 利用Zookeeper进行分布式管理，而Elasticsearch 自身带有分布式协调管理功能。</li><li>Solr 支持更多格式的数据，比如JSON、XML、 CSV ，而Elasticsearch仅支持JSON文件格式。</li><li>Solr 官方提供的功能更多，而Elasticsearch本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要kibana友好支撑</li><li>Solr 查询快，但更新索引时慢(即插入删除慢) ，用于电商等查询多的应用;<ul><li>ES建立索引快(即查询慢) ，即<strong>实时性查询快</strong>，用于facebook新浪等搜索。</li><li>Solr是传统搜索应用的有力解决方案，但Elasticsearch 更适用于新兴的实时搜索应用。</li></ul></li><li>Solr比较成熟，有一个更大，更成熟的用户、开发和贡献者社区,而Elasticsearch相对开发维护者较少，更新太快,<strong>学习使用成本较高</strong></li></ul></li></ul><h2 id="3-Elasticsearch安装"><a href="#3-Elasticsearch安装" class="headerlink" title="3 Elasticsearch安装"></a>3 Elasticsearch安装</h2><p>注意：java版本至少为JDK1.8或以上</p><p>Java开发,elasticsearch的版本和我们之后对应的Java的核心jar包! 版本对应! JDK环境是正常的</p><p>这里一定要保证</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/1596614089583.png" alt></p><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p>下载：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>windows下解压即可使用</p><h3 id="3-2-Elasticsearch目录介绍"><a href="#3-2-Elasticsearch目录介绍" class="headerlink" title="3.2 Elasticsearch目录介绍"></a>3.2 Elasticsearch目录介绍</h3><ul><li>bin 相关启动文件</li><li>config 配置文件</li><li>log4j2.properties 日志配置文件</li><li>jvm.options java虚拟机配置文件</li><li>elasticsearch.yml ES配置文件（默认端口：9200，这里在tpot中，docker默认分配的是1111，需要再映射到9200才行）</li><li>lib 相关jar包</li><li>logs 日志</li><li>modules 功能模块</li><li>plugins 插件</li></ul><h3 id="3-3-启动"><a href="#3-3-启动" class="headerlink" title="3.3 启动"></a>3.3 启动</h3><p>双击bin下的<strong>elasticsearch.bat</strong>即可</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105122.png" alt></p><h3 id="3-4-测试访问"><a href="#3-4-测试访问" class="headerlink" title="3.4 测试访问"></a>3.4 测试访问</h3><p>访问其暴露的端口进行验证（<a href="http://127.0.0.1:9200/）">http://127.0.0.1:9200/）</a></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105123.png" alt></p><h3 id="3-5-安装可视化界面Elasticsearch-head"><a href="#3-5-安装可视化界面Elasticsearch-head" class="headerlink" title="3.5 安装可视化界面Elasticsearch-head"></a>3.5 安装可视化界面Elasticsearch-head</h3><p>1、请下载Node.js（<a href="https://nodejs.org/en/），并检查npm为较新的版本">https://nodejs.org/en/），并检查npm为较新的版本</a></p><p>2、安装npm淘宝镜像源（cnpm）</p><blockquote><p>  npm install -g cnpm <em>–registry=<a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></em></p></blockquote><p> 查看是否安装成功</p><blockquote><p>  cnpm -v</p></blockquote><p> 出现以下信息即可</p><blockquote><p>  C:\Users\XXXX&gt; cnpm -v</p><p>  <a href="mailto:cnpm@5.1.1">cnpm@5.1.1</a> (F:\Live\NODE\node_global\node_modules\cnpm\lib\parse_argv.js)<br>  <a href="mailto:npm@5.6.0">npm@5.6.0</a> (F:\Live\NODE\node_global\node_modules\cnpm\node_modules\npm\lib\npm.js)<br>  <a href="mailto:node@8.9.1">node@8.9.1</a> (F:\Live\NODE\node.exe)<br>  <a href="mailto:npminstall@3.2.1">npminstall@3.2.1</a> (F:\Live\NODE\node_global\node_modules\cnpm\node_modules\npminstall\lib\index.js)<br>  prefix=F:\Live\NODE\node_global<br>  win32 x64 10.0.16299<br>  registry=<a href="http://registry.npm.taobao.org">http://registry.npm.taobao.org</a></p></blockquote><p><strong>在ElasticSearch\elasticsearch-head-master即ES head目录下</strong></p><p> <strong>下载依赖</strong></p><blockquote><p>  cnpm install</p></blockquote><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105124.png" alt="image-20210131091020099"></p><p> <strong>运行</strong></p><blockquote><p>  npm run start</p></blockquote><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20210609005919167.png" alt></p><p> <strong>访问<a href="http://localhost:9100/">http://localhost:9100/</a></strong></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105126.png" alt="image-20210131091312021"></p><p> <strong>此时因为跨域访问（跨端口）导致集群无法连接，要通过配置elasticsearch.yml来解决</strong></p><h3 id="3-6-解决跨域问题"><a href="#3-6-解决跨域问题" class="headerlink" title="3.6 解决跨域问题"></a>3.6 解决跨域问题</h3><p>配置es，打开elasticsearch.yml文件，在最后一行加入（注意yalm语法，冒号后要加一个空格）</p><blockquote><p>  http.cors.enabled: true<br>  http.cors.allow-origin: “*”</p></blockquote><p>使用elasticsearch.bat重启es，连接成功</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105127.png" alt="image-20210131092227531"></p><p>注1：Linux下可能会因为进程问题启动失败</p><p><em>#查看elastic的进程号 并杀死</em></p><div class="code-wrapper"><pre><code class="hljs perl">ps aux | <span class="hljs-keyword">grep</span> elasticsearch <span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span> 进程号</code></pre></div><p><em>#重启 -d 后台运行</em></p><div class="code-wrapper"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>elasticsearch -d</code></pre></div><p>注2：Linux下eshead启动失败，提示9100端口占用</p><p><em>#查看占用端口的进程id</em></p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">lsof</span> -i:<span class="hljs-number">9100</span></code></pre></div><p><em>#杀死进行</em></p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> -<span class="hljs-number">9</span> <span class="hljs-number">4852</span></code></pre></div><h2 id="4-Kibana安装"><a href="#4-Kibana安装" class="headerlink" title="4 Kibana安装"></a>4 Kibana安装</h2><p>Kibana是一个针对Elasticsearch的开源分析及可视化平台 ，用来搜索、查看交互存储在Elasticsearch索引中的数据。 使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板( dashboard )实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。</p><p>官网：<a href="https://www.elastic.co/cn/kibana">https://www.elastic.co/cn/kibana</a></p><p>注意：<strong>使用的ES版本要与Kibana的对应</strong></p><p>下载完成解压，双击kibana.bat启动即可</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105128.png" alt="image-20210131103309389"></p><p><strong>汉化</strong></p><p>在Kibana目录下的config中修改Kibana.yml文件，最后一行加上</p><blockquote><p>  i18n.locale: “zh-CN”</p></blockquote><p>重启即可</p><h2 id="5-ES核心概念"><a href="#5-ES核心概念" class="headerlink" title="5 ES核心概念"></a>5 ES核心概念</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>Elasticsearch是面向文档的一种数据库，这意味着其不再需要行列式的表格字段约束。</p><p>ES会存储整个构造好的数据或文档，然而不仅仅是储存数据，这使得文档中每个数据可以被标识，进而可以被检索。在ES中，执行index，search，sort或过滤文档等操作都不是传统意义上的行列式的数据。</p><p>ES从根本上对数据的不同思考方式也正是他能应对复杂数据结构的全文检索的原因之一。</p><p><strong>关系型数据库与Elasticsearch的对比</strong></p><p>以下数据格式均为JSON</p><table><thead><tr><th>Relational DB</th><th>Elasticsearch</th></tr></thead><tbody><tr><td>数据库（database）</td><td>索引（index）</td></tr><tr><td>表（tables）</td><td>类型（types，新版本中逐步弃用）</td></tr><tr><td>行（rows）</td><td>文档（documents）</td></tr><tr><td>字段（columns）</td><td>字段（file）</td></tr></tbody></table><p>Elasticsearch(一般为集群)中可以包含多个索引（对应数据库) ，每个索引中可以包含多个类型(对应表) ，每个类型下又包含多个文档(对应行)，每个文档中又包含多个字段(对应列)。</p><p><strong>物理设计</strong>:<br>Elasticsearch在后台<strong>把每个索引划分成多个分片</strong>,每分分片可以在集群中的不同服务器间迁移（方便集群的搭建）</p><p>实际上只建立一个索引它自己也是一个集群，默认名称就是elasticsearch</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105129.png" alt="image-20210202093954072"></p><p><strong>逻辑设计:</strong><br>一个索引类型中，包含多个文档，如文档1 ,文档2。</p><p>当我们索引一篇文档时，可以通过这样的一个顺序找到它:</p><p> 索引–&gt;类型–&gt;文档ID</p><p>通过这个组合我们就能索引到某个具体的文档。</p><p>（注:ID不必是整数,实际上它是个字符串。）</p><h3 id="5-2-文档"><a href="#5-2-文档" class="headerlink" title="5.2 文档"></a>5.2 文档</h3><p>Elasticsearch是面向文档的,那么就意味着索引和搜索数据的<strong>最小单位是文档</strong>, Elasticsearch中,文档有几个重要属性:</p><ul><li><p>自我包含，一篇文档同时包含字段和对应的值,也就是同时包含key:value</p></li><li><p>可以是层次型的，一个文档中包含着文档，复杂的逻辑实体就是这么来的（即文档就是JSON格式的对象，可用fastjson进行自动转换自动）</p></li><li><p>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在Elasticsearch中，对于字段是非常灵活的，有时候我们可以忽略该字段，或者动态的添加一个新的字段。</p></li></ul><p>我们可以随意的新增或者忽略某个字段，但每个字段的类型非常重要。比如一个年龄字段类型，可以是字符串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型,这也是为什么在elasticsearch中，类型有时候也称为<strong>映射类型</strong></p><p>文档就是<strong>一条条打好标签的数据</strong></p><p><strong>举个例子：</strong></p><blockquote><p>  user</p><p>  1 xiaoming 22</p><p>  2 liming 19</p><p>  。。。</p></blockquote><p>这是一个表，名称为user，里面的每一行就是一个文档，文档中包含着序号、名字、年龄等信息（有点像之前要使用TFIDF算法时做的那个设备文档）</p><h3 id="5-3-类型"><a href="#5-3-类型" class="headerlink" title="5.3 类型"></a>5.3 类型</h3><p>类型是文档的<strong>逻辑容器</strong>，就像关系型数据库一样，表格是行的容器。</p><p>类型中对于字段的定义称为<strong>映射</strong>，比如name可以映射为字符串类型。</p><p>我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段。那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18 ,那么elasticsearch会认为它是整形。</p><p>但是elasticsearch也可能猜不对 ，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用</p><p>类比MySQL中，建立一个表的时候需要设定的数据类型</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105130.png" alt="image-20210202095941630"></p><h3 id="5-4-索引"><a href="#5-4-索引" class="headerlink" title="5.4 索引"></a>5.4 索引</h3><p>索引是<strong>映射类型的容器</strong>， elasticsearch中的索引是一个非常大的文档集合（即数据库）。索引存储了映射类型的字段和其他设置。 然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的。</p><p><strong>物理设计: 节点和分片如何工作</strong></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105131.png" alt="image-20210202100254208"></p><p>存在数据库的数据可以通过不同的分片放在不同的集群上</p><p>一个集群至少有一个节点，而一个节点就是一个elasricsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片( primary shard ,又称<strong>主分片</strong>)构成，每一个主分片会有一个副本( replica shard ,又称<strong>复制分片</strong>)</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105132.png" alt="image-20210202100505894"></p><p>上图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内（比如主分片P0和主分片的复制分片P1分别在节点1/3，同样的分片Px在每个至少有一个），当某个节点挂掉了，数据也不至于丢失。</p><p>实际上，一个分片是一个Lucene索引，一个包含<strong>倒排索引</strong>的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。什么是倒排索引？</p><h3 id="5-5-倒排索引"><a href="#5-5-倒排索引" class="headerlink" title="5.5 倒排索引"></a>5.5 倒排索引</h3><p>elasticsearch使用的是一种称为倒排索引的结构 ,采用<strong>Lucene倒排索引</strong>作为底层。这种结构适用于快速的全文搜索，一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。</p><p>例如，现在有两个文档，每个文档包含如下内容:</p><blockquote><p>  study every day, good good up to forever #文档1包含的内容<br>  To forever, study every day， good good up #文档2包含的内容</p></blockquote><p>为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens) ，然后创建一个包含所有不重复的词条的排序列表，然后列出每个词条出现在哪个文档:（大小写要区分，重复单词也要加入）</p><table><thead><tr><th>term</th><th>doc_1</th><th>doc_2</th></tr></thead><tbody><tr><td>Study</td><td>〇</td><td>X</td></tr><tr><td>To</td><td>X</td><td>X</td></tr><tr><td>forever</td><td>〇</td><td>〇</td></tr><tr><td>every</td><td>〇</td><td>〇</td></tr><tr><td>study</td><td>X</td><td>〇</td></tr><tr><td>day</td><td>〇</td><td>〇</td></tr><tr><td>good</td><td>〇</td><td>〇</td></tr><tr><td>up</td><td>〇</td><td>〇</td></tr><tr><td>to</td><td>〇</td><td>X</td></tr><tr><td>every</td><td>〇</td><td>〇</td></tr></tbody></table><p>现在，我们试图搜索to forever，只需要查看每个词条在对应文档是否出现即可。这里to和forever在doc1里面都有，而doc2中to没有，所以搜索结果为：doc1的<strong>权重</strong>更大，即“to forever”更可能出现在doc1</p><table><thead><tr><th>term</th><th>doc_1</th><th>doc_2</th></tr></thead><tbody><tr><td>to</td><td>〇</td><td>X</td></tr><tr><td>forever</td><td>〇</td><td>〇</td></tr><tr><td>SUM</td><td>2</td><td>1</td></tr></tbody></table><p>这里的“权重”，即为文档的<strong>score</strong>，es搜索完成会对分数进行自动统计</p><p>两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，这两个包含关键字的文档都将返回。</p><p><strong>再举一个例子</strong></p><p>再来看一个示例比如我们通过博客标签来搜索博客文章。 那么倒排索引列表就是这样的一个结构:</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105133.png" alt="image-20210202111236177"></p><p>如果要搜索含有python标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要查看标签这一栏,然后获取相关的文章ID即可。比如这里搜索“Linux”就绝对不会出现1或者2</p><p><strong>elasticsearch的索引和Lucene的索引对比</strong></p><p>在elasticsearch中，索引（数据库）这个词被频繁使用。在elasticsearch中 ，索引被分为多个分片，每份分片是一个Lucene的索引。<strong>所以一个elasticsearch索引是由多个Lucene倒排索引组成的</strong>。（因为elasticsearch使用Lucene作为底层）</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105134.png" alt="image-20210202112920334"></p><p>如无特指，说起<strong>索引都是指elasticsearch的索引</strong>。</p><h2 id="6-IK分词器"><a href="#6-IK分词器" class="headerlink" title="6 IK分词器"></a>6 IK分词器</h2><h3 id="6-1-什么是IK分词器"><a href="#6-1-什么是IK分词器" class="headerlink" title="6.1 什么是IK分词器?"></a>6.1 <strong>什么是IK分词器?</strong></h3><p> <strong>分词</strong>:即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，比如“我爱黎明”会被分为”我”,”爱”,”“黎”,”明” 。这显然是不符合要求的，所以我们需要安装中文分词器IK来解决这个问题。</p><p>IK提供了两个分词算法: ik. smart和ik_max_ word</p><p>其中ik_smart为最少切分， ik _max_word为最细粒度划分</p><h3 id="6-2-安装-IK分词器"><a href="#6-2-安装-IK分词器" class="headerlink" title="6.2 安装 IK分词器"></a>6.2 安装 IK分词器</h3><p><strong>1、下载</strong></p><blockquote><p>  <a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p></blockquote><p><strong>2、安装</strong></p><p>解压后放入es的插件目录plugins下即可</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105135.png" alt="image-20210202144827745"></p><p><strong>3、重启es加载插件</strong></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105136.png" alt="image-20210202145019120"></p><p>可使用以下命令查看插件列表</p><blockquote><p>  elasticsearch-plugin list</p></blockquote><p><strong>4、启动Kibana测试</strong></p><p>测试ik_smart（使用RESTful风格的语句发起GET请求，对我们提供的JSON数据进行分词）</p><blockquote>  <div class="code-wrapper"><pre><code class="hljs json">GET _analyze&#123;<span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span>,<span class="hljs-attr">&quot;text&quot;</span>: [<span class="hljs-string">&quot;新型冠状病毒&quot;</span>]&#125;</code></pre></div></blockquote><p>运行结果：</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105137.png" alt="image-20210202150329532"></p><p>测试ik _max _word</p><blockquote>  <div class="code-wrapper"><pre><code class="hljs json">GET _analyze&#123;<span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<span class="hljs-attr">&quot;text&quot;</span>: [<span class="hljs-string">&quot;新型冠状病毒&quot;</span>]&#125;</code></pre></div></blockquote><p>运行结果：最细粒度划分会把所有可能的组合都划分出来（划分方式由某个字典规定）</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105138.png" alt="image-20210202150645756"></p><p>问题：当遇到自造词时，拆分结果不是我们想要的</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105139.png" alt="image-20210202151449769"></p><p>这时需要把关键词加入字典</p><h3 id="6-3-配置IK分词器"><a href="#6-3-配置IK分词器" class="headerlink" title="6.3 配置IK分词器"></a>6.3 配置IK分词器</h3><p><strong>添加自定义字典</strong></p><blockquote><p>  在 elasticsearch-7.12.1\plugins\ik\config</p></blockquote><p>中可以找到配置文件<strong>IKAnalyzer.cfg.xml</strong></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105140.png" alt="image-20210202152120411"></p><p>只需要在config目录下新建一个自己的.dic字典文件并录入IKAnalyzer.cfg.xml中然后<strong>重启es</strong>即可</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105141.png" alt="image-20210202152518579"></p><p>测试能够识别自定义词语</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105142.png" alt="image-20210202153349063"></p><h2 id="7-REST风格"><a href="#7-REST风格" class="headerlink" title="7 REST风格"></a>7 REST风格</h2><h3 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 <strong>概念</strong></h3><p>一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>即<strong>通过不同的命令实现不同的操作</strong></p><h3 id="7-2-基本REST命令"><a href="#7-2-基本REST命令" class="headerlink" title="7.2 基本REST命令"></a>7.2 基本REST命令</h3><table><thead><tr><th>method</th><th>url地址</th><th>描述</th></tr></thead><tbody><tr><td>PUT</td><td>localhost:9200/索引名称/类型名称/文档id</td><td>创建文档(指定文档id )</td></tr><tr><td>POST</td><td>localhost:9200/索弓|名称/类型名称</td><td>创建文档(随机文档id )</td></tr><tr><td>POST</td><td>localhost:9200/索引名称/类型名称/文档id/_ update</td><td>修改文档</td></tr><tr><td>DELETE</td><td>localhost:9200/索引名称/类型名称/文档id</td><td>删除文档</td></tr><tr><td>GET</td><td>localhost:9200/索引名称/类型名称/文档id</td><td>查询文档（通过文档id）</td></tr><tr><td>POST</td><td>localhost:9200/索弓|名称/类型名称/_ search</td><td>查询所有数据</td></tr></tbody></table><h2 id="8-测试"><a href="#8-测试" class="headerlink" title="8 测试"></a>8 测试</h2><h3 id="8-1-关于索引的操作"><a href="#8-1-关于索引的操作" class="headerlink" title="8.1 关于索引的操作"></a>8.1 关于索引的操作</h3><h4 id="1、创建一个索引"><a href="#1、创建一个索引" class="headerlink" title="1、创建一个索引"></a><strong>1、创建一个索引</strong></h4><blockquote>  <div class="code-wrapper"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/索引名/</span>类型名（新版本逐步废弃）/文档ID&#123;请求体&#125;</code></pre></div></blockquote><div class="code-wrapper"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/test1/</span>type/<span class="hljs-number">1</span>&#123;  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">13</span>&#125;</code></pre></div><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105143.png" alt="image-20210203092727349"></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105144.png" alt="image-20210203110817742"></p><p><strong>注意：</strong></p><p> 1、创建的索引名要<strong>小写</strong></p><p> 2、es head中数据浏览不显示内容就换个浏览器试试</p><h4 id="2、更新一个索引"><a href="#2、更新一个索引" class="headerlink" title="2、更新一个索引"></a>2、更新一个索引</h4><p>修改索引依旧可以使用PUT，此时返回的版本号会增加，”result”会提示update，但如果漏了一些信息，原始信息就会丢失，故现在一般<strong>使用POST来更新索引</strong></p><div class="code-wrapper"><pre><code class="hljs awk">POST <span class="hljs-regexp">/test1/</span>type1/<span class="hljs-number">1</span>&#123; <span class="hljs-string">&quot;doc&quot;</span>:&#123;   <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span> &#125;&#125;</code></pre></div><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105145.png" alt="image-20210203115556670"></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105146.png" alt="image-20210203115639183"></p><p>没有写age，它就会保持原样（如果用PUT的话age就直接没了）</p><h4 id="3、删除一个索引"><a href="#3、删除一个索引" class="headerlink" title="3、删除一个索引"></a>3、删除一个索引</h4><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">DELETE</span> test<span class="hljs-number">1</span>（索引名或文档记录ID）</code></pre></div><h4 id="4、指定类型"><a href="#4、指定类型" class="headerlink" title="4、指定类型"></a>4、指定类型</h4><p><strong>常用的字段类型有：</strong></p><p>●字符串类型<br>text、keyword<br>●数值类型<br>long,. integer, short, byte, double, float, half float, scaled float<br>●日期类型<br>date<br>●te布尔值类型<br>boolean<br>●二进制类型<br>binary.</p><p>创建一个t2索引（或者说索引库）但不创建文档，此时称其为一个“规则”</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105147.png" alt="image-20210203111936090"></p><p>查看t2，里面没有值，后续可以往里面放数据</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105148.png" alt="image-20210203112007717"></p><p>通过GET可以查看规则信息</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105149.png" alt="image-20210203112304214"></p><p>GET请求很好用，除了规则，还可以查看索引、文档的信息</p><p><strong>注：</strong></p><p>1、新版本es中正在逐步弃用type，我们创建索引库的时候可以将原来的type换成_doc，这样es就会自动帮我们配置字段类型</p><p>如下面的新建的test3：</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105150.png" alt="image-20210203113420834"></p><p>2、查看默认配置命令 GET _cat/indices?v</p><p>可以使用这个命令查看集群健康状态等一些信息</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105151.png" alt="image-20210203114043227"></p><h3 id="8-2-关于文档的操作"><a href="#8-2-关于文档的操作" class="headerlink" title="8.2 关于文档的操作"></a>8.2 关于文档的操作</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>1、添加数据</strong></p><div class="code-wrapper"><pre><code class="hljs json">PUT /dayceng/user/1&#123;  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;DAYceng&quot;</span>,  <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-string">&quot;22&quot;</span>,  <span class="hljs-attr">&quot;desc&quot;</span>: <span class="hljs-string">&quot;如此生活三十年&quot;</span>,  <span class="hljs-attr">&quot;tags&quot;</span>: [<span class="hljs-string">&quot;穷&quot;</span>,<span class="hljs-string">&quot;阿宅&quot;</span>,<span class="hljs-string">&quot;脚本小子&quot;</span>]&#125;</code></pre></div><p><strong>2、查询（获取，GET）数据</strong></p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105152.png" alt="image-20210205094004174"></p><p><strong>3、简单搜索</strong>(GET条件查询)</p><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search?q=name:条件</code></pre></div><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105153.png" alt="image-20210205095050550"></p><p>简单的条件查询可根据默认的映射规则产生基本查询结果</p><p>（这里的”_score”代表匹配度，分值越高，匹配度越高）</p><p>说明：</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105154.png" alt="image-20210205095252732"></p><p>字段name，它的类型是keyword，此时进行搜索，分词器不会对类型为keyword的name进行分词（即如果你搜“丹”是不会返回“丹霞”的结果的），如果类型是text则可以查到</p><h4 id="复杂操作（主要是搜索）"><a href="#复杂操作（主要是搜索）" class="headerlink" title="复杂操作（主要是搜索）"></a><strong>复杂操作（主要是搜索）</strong></h4><p><strong>复杂搜索select（排序、分页、模糊/精准查询、高亮）</strong></p><h5 id="1、使用请求体查询"><a href="#1、使用请求体查询" class="headerlink" title="1、使用请求体查询"></a><strong>1、使用请求体查询</strong></h5><p>一般来说，我们进行搜索不是直接写条件搜索，而是需要构建一个JSON格式的请求体，这样可以设置更多参数以实现定制化的搜索</p><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;match&quot;</span>: &#123;      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>    &#125;  &#125;&#125;</code></pre></div><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105155.png" alt="image-20210205105110638"></p><p>如果有相似关键字的多个结果，他们的分数会有不同</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105156.png" alt="image-20210205110206156"></p><p>hits是我们比较关注的一部分，其中包含：</p><p> 索引和文档的信息</p><p> 查询的结果总数</p><p> 查询出来的具体的文档</p><p> 分数：用来判断哪个结果更加符合预期</p><p>通过hits我们可以把数据的信息遍历出来，让我们想要的结果优先显示出来</p><p>后面使用java操控es，所有的方法和对象就是这里的hits、source等key</p><h5 id="2、请求体参数"><a href="#2、请求体参数" class="headerlink" title="2、请求体参数"></a>2、请求体参数</h5><p>我们通过在请求体后添加参数的方式实现一些自定义的操作</p><h6 id="筛选结果"><a href="#筛选结果" class="headerlink" title="筛选结果"></a><strong>筛选结果</strong></h6><p>只返回特定结果</p><div class="code-wrapper"><pre><code class="hljs awk">GET <span class="hljs-regexp">/dayceng/u</span>ser/_search&#123;  <span class="hljs-string">&quot;query&quot;</span>: &#123;    <span class="hljs-string">&quot;match&quot;</span>: &#123;      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>    &#125;  &#125;,   <span class="hljs-string">&quot;_source&quot;</span>:[<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;tags&quot;</span>]&#125;</code></pre></div><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105157.png" alt="image-20210205114109589"></p><h6 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h6><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;match&quot;</span>: &#123;      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>    &#125;  &#125;,  <span class="hljs-attr">&quot;sort&quot;</span>: [    &#123;      <span class="hljs-attr">&quot;age&quot;</span>: &#123;        <span class="hljs-attr">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span>      &#125;    &#125;  ]&#125;</code></pre></div><p>注意：排序只能用于数值类型，我这里的age是text类型，运行就会报错</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105158.png" alt="image-20210205115918067"></p><blockquote><p>  “Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata=true on [age] in order to load field data by uninverting the inverted index. Note that this can use significant memory.”</p></blockquote><p>把“age”换成“age.keyword”即可正常排序</p><p><img src="/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/20210505105159.png" alt="image-20210205120324780"></p><h6 id="分页"><a href="#分页" class="headerlink" title="分页"></a><strong>分页</strong></h6><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;match&quot;</span>: &#123;      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞在&quot;</span>    &#125;  &#125;,  <span class="hljs-attr">&quot;sort&quot;</span>: [    &#123;      <span class="hljs-attr">&quot;age.keyword&quot;</span>: &#123;        <span class="hljs-attr">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span>      &#125;    &#125;  ],   &quot;from&quot;: 0,---从第几个数据开始   &quot;size&quot;: 2 ---返回几个数据&#125;</code></pre></div><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105200.png" alt="image-20210206093248369"></p><h6 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a><strong>过滤</strong></h6><p>使用filter参数即可</p><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105201.png" alt="image-20210206094548128"></p><p> gt：大于</p><p> gte：大于等于</p><p> lt：小于</p><p> lte：小于等于</p><p> （以上条件可混合使用）</p><h5 id="3、布尔值查询"><a href="#3、布尔值查询" class="headerlink" title="3、布尔值查询"></a>3、布尔值查询</h5><p>使用布尔值可进行多条件查询</p><p><strong>must</strong>：设置的所有match都要匹配才会返回结果</p><p><strong>must not</strong>：返回与设置条件相反的结果</p><p><strong>should</strong>：满足条件之一即可返回结果</p><div class="code-wrapper"><pre><code class="hljs json">GET /dayceng/user/_search&#123;  <span class="hljs-attr">&quot;query&quot;</span>: &#123;    <span class="hljs-attr">&quot;bool&quot;</span>: &#123;      <span class="hljs-attr">&quot;must&quot;</span>: [        &#123;          <span class="hljs-attr">&quot;match&quot;</span>: &#123;            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;DAYceng&quot;</span>          &#125;        &#125;,        &#123;          <span class="hljs-attr">&quot;match&quot;</span>: &#123;            <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">22</span>          &#125;        &#125;      ]    &#125;  &#125;&#125;</code></pre></div><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105202.png" alt="image-20210206093144473"></p><h5 id="4、精确查询"><a href="#4、精确查询" class="headerlink" title="4、精确查询"></a>4、精确查询</h5><p>term查询是直接使用倒排索引进行精确查询的</p><p><strong>term与match的比较</strong></p><p> ·term使用倒排索引直接进行精确查询</p><p> ·match则会使用分词器进行解析后再查询（先分析文档，在通过分析结果进行查询）</p><p><strong>类型text与keyword的比较</strong></p><p>text会使用分词器进行分词后再查询</p><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105203.png" alt="image-20210206102310427"></p><p>keyword不会拆分特定词语</p><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105204.png" alt="image-20210206102247047"></p><h5 id="5、高亮查询"><a href="#5、高亮查询" class="headerlink" title="5、高亮查询"></a>5、高亮查询</h5><p>使用highlight参数</p><div class="code-wrapper"><pre><code class="hljs awk">GET <span class="hljs-regexp">/dayceng/u</span>ser/_search&#123;  <span class="hljs-string">&quot;query&quot;</span>: &#123;    <span class="hljs-string">&quot;match&quot;</span>: &#123;      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>    &#125;  &#125;,  <span class="hljs-string">&quot;highlight&quot;</span>: &#123;    <span class="hljs-string">&quot;fields&quot;</span>: &#123;      <span class="hljs-string">&quot;name&quot;</span>:&#123;&#125;    &#125;  &#125;&#125;</code></pre></div><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105205.png" alt="image-20210206104615060"></p><p>在highlight中也可以自定义高亮标签</p><div class="code-wrapper"><pre><code class="hljs awk">GET <span class="hljs-regexp">/dayceng/u</span>ser/_search&#123;  <span class="hljs-string">&quot;query&quot;</span>: &#123;    <span class="hljs-string">&quot;match&quot;</span>: &#123;      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;丹霞&quot;</span>    &#125;  &#125;,  <span class="hljs-string">&quot;highlight&quot;</span>: &#123;    <span class="hljs-string">&quot;pre_tags&quot;</span>: <span class="hljs-string">&quot;&lt;p class=key style=&#x27;color:red&#x27;&gt;&quot;</span>,     <span class="hljs-string">&quot;post_tags&quot;</span>: <span class="hljs-string">&quot;&lt;/p&gt;&quot;</span>,     <span class="hljs-string">&quot;fields&quot;</span>: &#123;      <span class="hljs-string">&quot;name&quot;</span>:&#123;&#125;    &#125;  &#125;&#125;</code></pre></div><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105206.png" alt="image-20210206105030939"></p><h2 id="9-Python-elasticsearch基本用法"><a href="#9-Python-elasticsearch基本用法" class="headerlink" title="9 Python-elasticsearch基本用法"></a>9 Python-elasticsearch基本用法</h2><p>官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html#_getting_a_document">https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html#_getting_a_document</a></p><h3 id="9-1-安装及初始化"><a href="#9-1-安装及初始化" class="headerlink" title="9.1 安装及初始化"></a>9.1 安装及初始化</h3><p>使用pip安装即可</p><div class="code-wrapper"><pre><code class="hljs shell">pip install elasticsearchpip install elasticsearch[async]#支持异步，可不安装</code></pre></div><h3 id="9-2-实例化es客户端"><a href="#9-2-实例化es客户端" class="headerlink" title="9.2 实例化es客户端"></a>9.2 <strong>实例化es客户端</strong></h3><p><img src="https://gitee.com/daycen/drawing-bed/raw/master/img/20210505105207.png" alt="image-20210219115247238"></p><p>实际上这里文档中给了三种创建客户端的方式，我们选择HTTP authentication方式（看起来清晰一些，当然你也可以用别的）实例化es对象</p><div class="code-wrapper"><pre><code class="hljs python">es = Elasticsearch(    [        &#123;<span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">9200</span>&#125;,    ],    http_auth=(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;secret&quot;</span>),    timeout=<span class="hljs-number">3600</span>)</code></pre></div><p>ES提供了两种搜索的方式：　　</p><p>　 请求参数方式</p><p>　 请求体方式（带body 的那种查询，把查询的内容放入body中，会造成一定的开销，但是易于理解）</p><p>这里我们使用请求体方式进行搜索</p><p>配置一个body</p><div class="code-wrapper"><pre><code class="hljs python">body = &#123;    <span class="hljs-string">&quot;settings&quot;</span>: &#123;        <span class="hljs-string">&quot;number_of_shards&quot;</span>: <span class="hljs-number">3</span>,        <span class="hljs-string">&quot;number_of_replicas&quot;</span>: <span class="hljs-number">2</span>    &#125;,    <span class="hljs-string">&quot;mappings&quot;</span>:&#123;        <span class="hljs-comment"># &quot;_doc&quot;:&#123;</span>        <span class="hljs-string">&quot;properties&quot;</span>:&#123;            <span class="hljs-string">&quot;id&quot;</span>:&#123;                <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;integer&quot;</span>,            &#125;,            <span class="hljs-string">&quot;text&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,                <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,  <span class="hljs-comment">#指定ik分词器，适用中文分词。</span>                <span class="hljs-string">&quot;index&quot;</span>:<span class="hljs-literal">False</span>            &#125;,            <span class="hljs-string">&quot;userId&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span>,            &#125;,            <span class="hljs-string">&quot;reprinted&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,            &#125;,        &#125;</code></pre></div><p>注：可以看到，body中实际上就是之前我们使用请求体参数搜索时设置的一些东西</p><h3 id="9-3-单一操作"><a href="#9-3-单一操作" class="headerlink" title="9.3 单一操作"></a>9.3 单一操作</h3><h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p><strong>create</strong></p><p>必须指定待查询的idnex、type、id和查询体body；缺一不可，否则报错</p><div class="code-wrapper"><pre><code class="hljs python">es.indices.create(index = <span class="hljs-string">&quot;testpy&quot;</span>, body = body)</code></pre></div><p><strong>index</strong>　</p><p>相比于create，index的用法就相对灵活很多；id并非是一个必选项，如果指定，则该文档的id就是指定值，若不指定，则系统会自动生成一个全局唯一的id赋给该文档。</p><div class="code-wrapper"><pre><code class="hljs python">es.index(index = <span class="hljs-string">&quot;testpy&quot;</span>, doc_type = <span class="hljs-string">&quot;_doc&quot;</span>, <span class="hljs-built_in">id</span> = <span class="hljs-number">1</span>, body = &#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;小明&quot;</span>&#125;)</code></pre></div><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>　　delete：删除指定index、type、id的文档</p><div class="code-wrapper"><pre><code class="hljs python">es.indices.delete(index = <span class="hljs-string">&#x27;test&#x27;</span>)</code></pre></div><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>　　get：获取指定index、type、id所对应的文档</p><div class="code-wrapper"><pre><code class="hljs python">es.get(index=<span class="hljs-string">&quot;testpy&quot;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>)</code></pre></div><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>　　update：跟新指定index、type、id所对应的文档</p><div class="code-wrapper"><pre><code class="hljs python">es.update(index=<span class="hljs-string">&#x27;testpy&#x27;</span>, doc_type=<span class="hljs-string">&#x27;_doc&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;2&#x27;</span>, body=&#123;待更新字段&#125;)</code></pre></div><h3 id="9-4-批量操作"><a href="#9-4-批量操作" class="headerlink" title="9.4 批量操作"></a>9.4 批量操作</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>search：查询满足条件的所有文档，没有id属性，且index，type和body均可为None。 body的语法格式必须符合DSL格式</p><div class="code-wrapper"><pre><code class="hljs python">es.search(index = <span class="hljs-string">&quot;test&quot;</span>, doc_type = <span class="hljs-string">&quot;_doc&quot;</span>, body = query)</code></pre></div><p>复合查询语句</p><div class="code-wrapper"><pre><code class="hljs python">query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;match_all&#x27;</span>: &#123;&#125;&#125;&#125;<span class="hljs-comment"># 查找所有文档</span>query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;term&#x27;</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;jack&#x27;</span>&#125;&#125;&#125;<span class="hljs-comment"># 查找名字叫做jack的所有文档</span>query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;range&#x27;</span>: &#123;<span class="hljs-string">&#x27;age&#x27;</span>: &#123;<span class="hljs-string">&#x27;gt&#x27;</span>: <span class="hljs-number">11</span>&#125;&#125;&#125;&#125;<span class="hljs-comment"># 查找年龄大于11的所有文档</span>allDoc = es.search(index=<span class="hljs-string">&#x27;indexName&#x27;</span>, doc_type=<span class="hljs-string">&#x27;typeName&#x27;</span>, body=query)</code></pre></div><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>delete_by_query</p><div class="code-wrapper"><pre><code class="hljs python">query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;match&#x27;</span>: &#123;<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;famale&#x27;</span>&#125;&#125;&#125;<span class="hljs-comment"># 删除性别为女性的所有文档</span>query = &#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;range&#x27;</span>: &#123;<span class="hljs-string">&#x27;age&#x27;</span>: &#123;<span class="hljs-string">&#x27;lt&#x27;</span>: <span class="hljs-number">11</span>&#125;&#125;&#125;&#125;<span class="hljs-comment"># 删除年龄小于11的所有文档</span>es.delete_by_query(index=<span class="hljs-string">&#x27;indexName&#x27;</span>, body=query, doc_type=<span class="hljs-string">&#x27;typeName&#x27;</span>)</code></pre></div><h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><p>update_by_query</p><div class="code-wrapper"><pre><code class="hljs python">query = &#123;            <span class="hljs-string">&quot;script&quot;</span>: &#123;            <span class="hljs-string">&quot;lang&quot;</span>: <span class="hljs-string">&quot;painless&quot;</span>,            <span class="hljs-comment"># &quot;inline&quot;: &quot;if (ctx._source.test_code == null) &#123;ctx._source.test_code= &#x27;02&#x27;&#125;&quot;</span>            <span class="hljs-string">&quot;inline&quot;</span>: <span class="hljs-string">&quot;ctx._source.kw_sourceType= &#x27;trueTime&#x27;&quot;</span>   <span class="hljs-comment">#新增字段kw_sourceType值为trueTime</span>              &#125;            &#125;res = es.update_by_query(index=<span class="hljs-string">&quot;hot_rank&quot;</span>, doc_type=<span class="hljs-string">&quot;baidu_hot_search_rank&quot;</span>, body=query)</code></pre></div><h3 id="9-5-完整测试工程代码"><a href="#9-5-完整测试工程代码" class="headerlink" title="9.5 完整测试工程代码"></a>9.5 完整测试工程代码</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> elasticsearch <span class="hljs-keyword">import</span> Elasticsearch<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<span class="hljs-comment">#from elasticsearch import AsyncElasticsearch</span><span class="hljs-comment">#es = Elasticsearch(host=&quot;localhost&quot;, port=9200)</span>es = Elasticsearch(    [        &#123;<span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">9200</span>&#125;,    ],    http_auth=(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;secret&quot;</span>),    timeout=<span class="hljs-number">3600</span>)body = &#123;    <span class="hljs-string">&quot;settings&quot;</span>: &#123;        <span class="hljs-string">&quot;number_of_shards&quot;</span>: <span class="hljs-number">3</span>,        <span class="hljs-string">&quot;number_of_replicas&quot;</span>: <span class="hljs-number">2</span>    &#125;,    <span class="hljs-string">&quot;mappings&quot;</span>:&#123;        <span class="hljs-comment"># &quot;_doc&quot;:&#123;</span>        <span class="hljs-string">&quot;properties&quot;</span>:&#123;            <span class="hljs-string">&quot;id&quot;</span>:&#123;                <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;integer&quot;</span>,            &#125;,            <span class="hljs-string">&quot;text&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,                <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,  <span class="hljs-comment">#指定ik分词器，适用中文分词。</span>                <span class="hljs-string">&quot;index&quot;</span>:<span class="hljs-literal">False</span>            &#125;,            <span class="hljs-string">&quot;userId&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span>,            &#125;,            <span class="hljs-string">&quot;reprinted&quot;</span>: &#123;                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,            &#125;,        &#125;        <span class="hljs-comment"># &#125;</span>    &#125;&#125;<span class="hljs-comment">#创建 index</span><span class="hljs-comment">#es.indices.create(index = &quot;testpy&quot;, body = body)</span><span class="hljs-comment">#删除 index</span><span class="hljs-comment">#es.indices.delete(index = &#x27;test&#x27;)</span><span class="hljs-comment">#插入数据</span><span class="hljs-comment">#es.index(index = &quot;testpy&quot;, doc_type = &quot;_doc&quot;, id = 1, body = &#123;&quot;id&quot;:1, &quot;name&quot;:&quot;小明&quot;&#125;)</span><span class="hljs-comment">#可以不用指定id，create会自动添加id。</span><span class="hljs-comment">#es.create(index=&quot;testpy&quot;, doc_type = &quot;_doc&quot;,id = 2, body = &#123;&quot;id&quot;:2, &quot;name&quot;:&quot;小红&quot;&#125;)</span><span class="hljs-string">&#x27;&#x27;&#x27;doc = &#123;</span><span class="hljs-string">    &#x27;author&#x27;: &#x27;author_name&#x27;,</span><span class="hljs-string">    &#x27;text&#x27;: &#x27;Interensting content...&#x27;,</span><span class="hljs-string">    &#x27;timestamp&#x27;: datetime.now(),</span><span class="hljs-string">&#125;&#x27;&#x27;&#x27;</span>res = es.get(index=<span class="hljs-string">&quot;testpy&quot;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>)<span class="hljs-comment">#es.search(index = &quot;test&quot;, doc_type = &quot;_doc&quot;, body = query)</span><span class="hljs-built_in">print</span>(res[<span class="hljs-string">&#x27;_source&#x27;</span>])</code></pre></div>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Distributed/">Distributed</category>
      
      
      <category domain="https://pncalbl.github.io/tags/ElasticSearch/">ElasticSearch</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/25/ElasticSearch%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Kafka 学习</title>
      <link>https://pncalbl.github.io/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Mon, 24 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Kafka-学习&quot;&gt;&lt;a href=&quot;#Kafka-学习&quot; class=&quot;headerlink&quot; title=&quot;Kafka 学习&quot;&gt;&lt;/a&gt;Kafka 学习&lt;/h1&gt;&lt;h2 id=&quot;1-Kafka-入门&quot;&gt;&lt;a href=&quot;#1-Kafka-入门&quot; class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Kafka-学习"><a href="#Kafka-学习" class="headerlink" title="Kafka 学习"></a>Kafka 学习</h1><h2 id="1-Kafka-入门"><a href="#1-Kafka-入门" class="headerlink" title="1 Kafka 入门"></a>1 Kafka 入门</h2><h3 id="1-1-文档"><a href="#1-1-文档" class="headerlink" title="1.1 文档"></a>1.1 文档</h3><ul><li><p><a href="http://kafka.apache.org/">Kafka官网主页</a></p></li><li><p><a href="http://kafka.apache.org/documentation/">Kafka官方文档</a></p></li></ul><h3 id="1-2-什么是-Kafka"><a href="#1-2-什么是-Kafka" class="headerlink" title="1.2 什么是 Kafka"></a>1.2 什么是 Kafka</h3><p>Kafka 是一个<strong>分布式</strong>的基于<strong>发布/订阅模式</strong>的<strong>消息队列</strong>（Message Queue），主要应用于大数据实时处理领域。</p><h3 id="1-3-消息队列"><a href="#1-3-消息队列" class="headerlink" title="1.3 消息队列"></a>1.3 消息队列</h3><h4 id="传统消息队列的应用场景"><a href="#传统消息队列的应用场景" class="headerlink" title="传统消息队列的应用场景"></a>传统消息队列的应用场景</h4><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/01.png" alt></p><h4 id="使用消息队列的好处"><a href="#使用消息队列的好处" class="headerlink" title="使用消息队列的好处"></a>使用消息队列的好处</h4><ol><li><p>解耦（类似Spring的IOC）</p><p>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p></li><li><p>可恢复性</p><p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p></li><li><p>缓冲</p><p>有助于控制和优化数据流经过系统的速度， 解决生产消息和消费消息的处理速度不一致的情况。</p></li><li><p>灵活性 &amp; 峰值处理能力（削峰）</p><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p></li><li><p>异步通信</p><p>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p></li></ol><h3 id="1-4-消费模式"><a href="#1-4-消费模式" class="headerlink" title="1.4 消费模式"></a>1.4 消费模式</h3><p>消息队列的两种模式</p><h4 id="1-4-1-点对点模式"><a href="#1-4-1-点对点模式" class="headerlink" title="1.4.1 点对点模式"></a>1.4.1 点对点模式</h4><p><strong>一对一，消费者主动拉取数据，消息收到后消息清除</strong></p><p>消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费以后， queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/02.png" alt></p><h4 id="1-4-2-发布-订阅模式"><a href="#1-4-2-发布-订阅模式" class="headerlink" title="1.4.2 发布/订阅模式"></a>1.4.2 发布/订阅模式</h4><p><strong>一对多，消费者消费数据之后不会清除消息</strong></p><p>消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/03.png" alt></p><h3 id="1-5-基础架构"><a href="#1-5-基础架构" class="headerlink" title="1.5 基础架构"></a>1.5 基础架构</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/04.png" alt></p><ol><li><strong>Producer</strong> ： 消息生产者，就是向 Kafka ；</li><li><strong>Consumer</strong> ： 消息消费者，向 Kafka broker 取消息的客户端；</li><li><strong>Consumer Group （CG）</strong>： 消费者组，由多个 consumer 组成。 消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。 所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li><li><strong>Broker</strong> ：经纪人 一台 Kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker可以容纳多个 topic。</li><li><strong>Topic</strong> ： 话题，可以理解为一个队列， 生产者和消费者面向的都是一个 topic；</li><li><strong>Partition</strong>： 为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；</li><li><strong>Replica</strong>： 副本（Replication），为保证集群中的某个节点发生故障时， 该节点上的 partition 数据不丢失，且 Kafka仍然能够继续工作， Kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。</li><li><strong>Leader</strong>： 每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 leader。</li><li><strong>Follower</strong>： 每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据的同步。 leader 发生故障时，某个 Follower 会成为新的 leader。</li></ol><blockquote><p>  replica 英 [ˈreplɪkə] 美 [ˈreplɪkə] n.复制品;仿制品</p></blockquote><blockquote><p>  topic 英 [ˈtɒpɪk] 美 [ˈtɑːpɪk] n.话题;题目;标题</p></blockquote><h3 id="1-6-安装-amp-启动-amp-关闭"><a href="#1-6-安装-amp-启动-amp-关闭" class="headerlink" title="1.6 安装&amp;启动&amp;关闭"></a>1.6 安装&amp;启动&amp;关闭</h3><h4 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h4><p>本次安装学习在Windows操作系统进行。（Linux版本的差别不大，运行脚本文件后缀从<code>bat</code>改为<code>sh</code>，配置路径改用Unix风格的）</p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23quickstart">本节教程来源</a></p><h4 id="Step-1-Download-the-code"><a href="#Step-1-Download-the-code" class="headerlink" title="Step 1: Download the code"></a>Step 1: Download the code</h4><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2Fdownloads">下载代码</a>并解压</p><p>下载<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farchive.apache.org%2Fdist%2Fkafka%2F0.11.0.0%2Fkafka_2.11-0.11.0.0.tgz">kafka 0.11.0.0</a>版本，解压到<code>C:\Kafka\</code>路径下，Kafka主目录文件为<code>C:\Kafka\kafka_2.11-0.11.0.0</code>（下文用KAFKA_HOME表示）。</p><h4 id="Step-2-Start-the-server"><a href="#Step-2-Start-the-server" class="headerlink" title="Step 2: Start the server"></a>Step 2: Start the server</h4><p>Kafka 用到 ZooKeeper 功能，所以要预先运行ZooKeeper。了解更多ZooKeeper信息，可点击阅读<a href="https://my.oschina.net/jallenkwong/blog/4405741">ZooKeeper学习笔记</a>。</p><ul><li>首先，修改<code>%KAFKA_HOME%\conf\zookeeper.properties</code>中的<code>dataDir=/tmp/zookeeper</code>，改为<code>dataDir=C:\\Kafka\\data\\zookeeper</code>。</li><li>创建新目录<code>C:\\Kafka\\data\\zookeeper</code>。</li><li>启动cmd，工作目录切换到<code>%KAFKA_HOME%</code>，执行命令行：</li></ul><div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">start</span> bin\windows\zookeeper-server-<span class="hljs-built_in">start</span>.bat config\zookeeper.properties</code></pre></div><ul><li>修改<code>%KAFKA_HOME%\conf\server.properties</code>中的<code>log.dirs=/tmp/kafka-logs</code>，改为<code>log.dirs=C:\\Kafka\\data\\kafka-logs</code>。</li><li>创建新目录<code>C:\\Kafka\\data\\kafka-logs</code>。</li><li>另启动cmd，工作目录切换到<code>%KAFKA_HOME%</code>，执行命令行：</li></ul><div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">start</span> bin\windows\kafka-server-<span class="hljs-built_in">start</span>.bat config\server.properties</code></pre></div><ul><li><p>可写一脚本，一键启动</p></li><li><p>关闭服务，<code>bin\windows\kafka-server-stop.bat</code>和<code>bin\windows\zookeeper-server-stop.bat</code></p></li></ul><p>TODO:<strong>一个问题</strong>，通过<code>kafka-server-stop.bat</code>或右上角关闭按钮来关闭Kafka服务后，马上下次再启动Kafka，抛出异常，说某文件被占用，需清空<code>log.dirs</code>目录下文件，才能重启Kafka。</p><div class="code-wrapper"><pre><code class="hljs shell">[2020-07-21 21:43:26,755] ERROR There was an error in one of the threads during logs loading: java.nio.file.FileSystemException: C:\Kafka\data\kafka-logs-0\my-replicated-topic-0\00000000000000000000.timeindex: 另一个程序正在使用此文件，进程无法访问。 (kafka.log.LogManager)...</code></pre></div><p>参阅网络，这可能是在windows下的一个Bug，没有更好的解决方案，暂时写个py脚本用来对kafka的log文件进行删除。下次启动kafka，先运行这个删除脚本吧。</p><p><strong>好消息</strong>，当你成功启动kafka，然后在对应的命令行窗口用<code>Ctrl + C</code>结束Kakfa，下次不用清理kafka日志，也能正常启动。</p><h4 id="Step-3-Create-a-topic"><a href="#Step-3-Create-a-topic" class="headerlink" title="Step 3: Create a topic"></a>Step 3: Create a topic</h4><ul><li>用单一partition和单一replica创建一个名为<code>test</code>的topic:</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --create --zookeeper localhost:<span class="hljs-number">2181</span> --replication-factor <span class="hljs-number">1</span> --partitions <span class="hljs-number">1</span> --topic test</code></pre></div><ul><li>查看已创建的topic，也就刚才创建的名为<code>test</code>的topic：</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --list --zookeeper localhost:<span class="hljs-number">2181</span></code></pre></div><p>或者，你可配置你的broker去自动创建未曾发布过的topic，代替手动创建topic</p><h4 id="Step-4-Send-some-messages"><a href="#Step-4-Send-some-messages" class="headerlink" title="Step 4: Send some messages"></a>Step 4: Send some messages</h4><p>运行producer，然后输入几行文本，发至服务器：</p><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="hljs-number">9092</span> --topic test&gt;hello, kafka.&gt;what a nice day!&gt;to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div><p>请勿关闭窗口，下面步骤需要用到</p><h4 id="Step-5-Start-a-consumer"><a href="#Step-5-Start-a-consumer" class="headerlink" title="Step 5: Start a consumer"></a>Step 5: Start a consumer</h4><p>运行consumer，将Step 4中输入的几行句子，标准输出。</p><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9092</span> --topic test --from-beginninghello, kafka.what a nice day!to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div><p>若你另启cmd，执行命令行<code>bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning</code>来运行consumer，然后在<a href="https://my.oschina.net/jallenkwong/blog/4449224#">Step 4</a>中producer窗口输入一行句子，如<code>I must admit, I can&#39;t help but feel a twinge of envy.</code>，两个consumer也会同时输出<code>I must admit, I can&#39;t help but feel a twinge of envy.</code>。</p><h4 id="Step-6-Setting-up-a-multi-broker-cluster"><a href="#Step-6-Setting-up-a-multi-broker-cluster" class="headerlink" title="Step 6: Setting up a multi-broker cluster"></a>Step 6: Setting up a multi-broker cluster</h4><p>目前为止，我们仅作为一个单一broker，这不好玩。让我们弄个有三个节点的集群来玩玩。</p><ul><li>首先，在<code>%KAFKA%\config\server.properties</code>的基础上创建两个副本<code>server-1.properties</code>和<code>server-2.properties</code>。</li></ul><div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">copy</span> config\server.properties config\server-<span class="hljs-number">1</span>.properties<span class="hljs-built_in">copy</span> config\server.properties config\server-<span class="hljs-number">2</span>.properties</code></pre></div><ul><li>打开副本，编辑如下属性</li></ul><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#config/server-1.properties:</span><span class="hljs-meta">broker.id</span>=<span class="hljs-string">1</span><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://127.0.0.1:9093</span><span class="hljs-meta">log.dir</span>=<span class="hljs-string">C:\\Kafka\\data\\kafka-logs-1</span> <span class="hljs-comment">#config/server-2.properties:</span><span class="hljs-meta">broker.id</span>=<span class="hljs-string">2</span><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://127.0.0.1:9094</span><span class="hljs-meta">log.dir</span>=<span class="hljs-string">C:\\Kafka\\data\\kafka-logs-2</span></code></pre></div><p>这个<code>broker.id</code>属性是集群中每个节点的唯一永久的名称。</p><p>我们必须重写端口和日志目录，只是因为我们在同一台机器上运行它们，并且我们希望阻止brokers试图在同一个端口上注册或覆盖彼此的数据。</p><ul><li>我们已经启动了Zookeeper和我们的单个节点，所以我们只需要启动两个新节点：</li></ul><div class="code-wrapper"><pre><code class="hljs bat"><span class="hljs-built_in">start</span> bin\windows\kafka-server-<span class="hljs-built_in">start</span>.bat config\server-<span class="hljs-number">1</span>.properties<span class="hljs-built_in">start</span> bin\windows\kafka-server-<span class="hljs-built_in">start</span>.bat config\server-<span class="hljs-number">2</span>.properties</code></pre></div><ul><li>创建一个replication-factor为3的topic:</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --create --zookeeper localhost:<span class="hljs-number">2181</span> --replication-factor <span class="hljs-number">3</span> --partitions <span class="hljs-number">1</span> --topic my-replicated-topic</code></pre></div><ul><li>OK，现在我们有了一个集群，但是我们怎么知道哪个broker在做什么呢？那就运行<code>describe topics</code>命令：</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --describe --zookeeper localhost:<span class="hljs-number">2181</span> --topic my-replicated-topic<span class="hljs-function">Topic:<span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>       <span class="hljs-title">PartitionCount</span>:1        <span class="hljs-title">ReplicationFactor</span>:3</span><span class="hljs-function"><span class="hljs-title">Configs</span>:</span><span class="hljs-function"><span class="hljs-title">Topic</span>: <span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>      <span class="hljs-title">Partition</span>: 0    <span class="hljs-title">Leader</span>: 0       </span><span class="hljs-function"><span class="hljs-title">Replicas</span>: 0,1,2        <span class="hljs-title">Isr</span>: 0,1,2</span></code></pre></div><ul><li>以下是输出的说明。第一行给出所有Partition的摘要，每一行提供有关一个Partition的信息。因为这个Topic只有一个Partition，所以只有一行。<ul><li>“leader”是负责给定Partition的所有读写的节点。每个节点都可能成为Partition随机选择的leader。</li><li>“replicas”是复制此Partition日志的节点列表，无论它们是leader还是当前处于存活状态。</li><li>“isr”是一组 “in-sync” replicas。这是replicas列表的一个子集，它当前处于存活状态，并补充leader。</li></ul></li></ul><p>注意，<strong>在我的示例中，node 0是Topic唯一Partition的leader</strong>。（下面操作需要用到）</p><ul><li>让我们为我们的新Topic发布一些信息：</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="hljs-number">9092</span> --topic my-replicated-topic&gt;There&#x27;s sadness <span class="hljs-keyword">in</span> your eyes, I don&#x27;t want to say goodbye to you.&gt;Love is a big illusion, I should try to forget, but there&#x27;s something left <span class="hljs-keyword">in</span> my head.&gt;</code></pre></div><ul><li>让我们接收刚刚发布的信息吧！</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9092</span> --from-beginning --topic my-replicated-topicThere&#x27;s sadness <span class="hljs-keyword">in</span> your eyes, I don&#x27;t want to say goodbye to you.Love is a big illusion, I should try to forget, but there&#x27;s something left <span class="hljs-keyword">in</span> my head.</code></pre></div><ul><li>让我们测试一下容错性，由上文可知，Broker 0 身为 leader，因此，让我们干掉它吧：<ul><li>先找出 Broker 0 的进程pid。</li><li>杀掉 Broker 0 的进程。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs bat">wmic process where &quot;caption=&#x27;java.exe&#x27; and commandline like &#x27;<span class="hljs-variable">%server.properties%</span>&#x27;&quot; get processid,captionCaption   ProcessIdjava.exe  <span class="hljs-number">7528</span><span class="hljs-built_in">taskkill</span> /pid <span class="hljs-number">7528</span> /f成功: 已终止 PID 为 <span class="hljs-number">7528</span> 的进程。</code></pre></div><ul><li>原leader已被替换成它的flowers中的其中一个，并且 node 0 不在 in-sync replica 集合当中。</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --describe --zookeeper localhost:<span class="hljs-number">2181</span> --topic my-replicated-topic<span class="hljs-function">Topic:<span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>       <span class="hljs-title">PartitionCount</span>:1        <span class="hljs-title">ReplicationFactor</span>:3</span><span class="hljs-function"><span class="hljs-title">Configs</span>:</span><span class="hljs-function"><span class="hljs-title">Topic</span>: <span class="hljs-title">my</span>-<span class="hljs-title">replicated</span>-<span class="hljs-title">topic</span>      <span class="hljs-title">Partition</span>: 0    <span class="hljs-title">Leader</span>: 1       <span class="hljs-title">Replicas</span>: 0,1,2 <span class="hljs-title">Isr</span>: 1,2</span></code></pre></div><ul><li>尽管原leader已逝，当原来消息依然可以接收。（注意，参数<code>--bootstrap-server localhost:9093</code>，而不是<code>--bootstrap-server localhost:9092</code>）</li></ul><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9093</span> --from-beginning --topic my-replicated-topicThere&#x27;s sadness <span class="hljs-keyword">in</span> your eyes, I don&#x27;t want to say goodbye to you.Love is a big illusion, I should try to forget, but there&#x27;s something left <span class="hljs-keyword">in</span> my head.I don&#x27;t forget the way your kissing, the feeling &#x27;s so strong which is lasting <span class="hljs-keyword">for</span> so long.</code></pre></div><h4 id="server-properties一瞥"><a href="#server-properties一瞥" class="headerlink" title="server.properties一瞥"></a>server.properties一瞥</h4><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#broker 的全局唯一编号，不能重复</span><span class="hljs-meta">broker.id</span>=<span class="hljs-string">0</span><span class="hljs-comment">#删除 topic 功能使能</span><span class="hljs-meta">delete.topic.enable</span>=<span class="hljs-string">true</span><span class="hljs-comment">#处理网络请求的线程数量</span><span class="hljs-meta">num.network.threads</span>=<span class="hljs-string">3</span><span class="hljs-comment">#用来处理磁盘 IO 的现成数量</span><span class="hljs-meta">num.io.threads</span>=<span class="hljs-string">8</span><span class="hljs-comment">#发送套接字的缓冲区大小</span><span class="hljs-meta">socket.send.buffer.bytes</span>=<span class="hljs-string">102400</span><span class="hljs-comment">#接收套接字的缓冲区大小</span><span class="hljs-meta">socket.receive.buffer.bytes</span>=<span class="hljs-string">102400</span><span class="hljs-comment">#请求套接字的缓冲区大小</span><span class="hljs-meta">socket.request.max.bytes</span>=<span class="hljs-string">104857600</span><span class="hljs-comment">#kafka 运行日志存放的路径</span><span class="hljs-meta">log.dirs</span>=<span class="hljs-string">/opt/module/kafka/logs</span><span class="hljs-comment">#topic 在当前 broker 上的分区个数</span><span class="hljs-meta">num.partitions</span>=<span class="hljs-string">1</span><span class="hljs-comment">#用来恢复和清理 data 下数据的线程数量</span><span class="hljs-meta">num.recovery.threads.per.data.dir</span>=<span class="hljs-string">1</span><span class="hljs-comment">#segment 文件保留的最长时间，超时将被删除</span><span class="hljs-meta">log.retention.hours</span>=<span class="hljs-string">168</span><span class="hljs-comment">#配置连接 Zookeeper 集群地址</span><span class="hljs-meta">zookeeper.connect</span>=<span class="hljs-string">hadoop102:2181,hadoop103:2181,hadoop104:2181</span></code></pre></div><h3 id="1-7-命令行操作Topic增删查"><a href="#1-7-命令行操作Topic增删查" class="headerlink" title="1.7 命令行操作Topic增删查"></a>1.7 命令行操作Topic增删查</h3><h4 id="查看当前服务器中的所有-topic"><a href="#查看当前服务器中的所有-topic" class="headerlink" title="查看当前服务器中的所有 topic"></a>查看当前服务器中的所有 topic</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --list --zookeeper localhost:<span class="hljs-number">2181</span></code></pre></div><h4 id="创建-topic"><a href="#创建-topic" class="headerlink" title="创建 topic"></a>创建 topic</h4><div class="code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">bin\windows\kafka</span><span class="hljs-literal">-</span><span class="hljs-comment">topics</span><span class="hljs-string">.</span><span class="hljs-comment">bat</span> --<span class="hljs-comment">create</span> --<span class="hljs-comment">zookeeper</span> <span class="hljs-comment">localhost:2181</span> --<span class="hljs-comment">replication</span><span class="hljs-literal">-</span><span class="hljs-comment">factor</span> <span class="hljs-comment">3</span> --<span class="hljs-comment">partitions</span> <span class="hljs-comment">1</span> --<span class="hljs-comment">topic</span> <span class="hljs-comment">my</span><span class="hljs-literal">-</span><span class="hljs-comment">replicated</span><span class="hljs-literal">-</span><span class="hljs-comment">topic</span></code></pre></div><p>选项说明：</p><ul><li>–topic 定义 topic 名</li><li>–replication-factor 定义副本数</li><li>–partitions 定义分区数</li></ul><blockquote><p>  为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；</p><p>  a broker = a kafka server a broker can contain N topic a topic can contain N partition a broker can contain a part of a topic (a broker can contain M(N&gt;M) partition)</p></blockquote><h4 id="删除-topic"><a href="#删除-topic" class="headerlink" title="删除 topic"></a>删除 topic</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --zookeeper localhost:<span class="hljs-number">2181</span> --delete --topic my-replicated-topic</code></pre></div><p>需要 server.properties 中设置 <code>delete.topic.enable=true</code> 否则只是标记删除。</p><h4 id="查看某个-Topic-的详情"><a href="#查看某个-Topic-的详情" class="headerlink" title="查看某个 Topic 的详情"></a>查看某个 Topic 的详情</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --zookeeper localhost:<span class="hljs-number">2181</span> --describe --topic first</code></pre></div><h4 id="修改分区数"><a href="#修改分区数" class="headerlink" title="修改分区数"></a>修改分区数</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-topics.bat --zookeeper localhost:<span class="hljs-number">2181</span> --alter --topic first --partitions <span class="hljs-number">6</span></code></pre></div><h3 id="1-8-命令行控制台生产者消费者测试"><a href="#1-8-命令行控制台生产者消费者测试" class="headerlink" title="1.8 命令行控制台生产者消费者测试"></a>1.8 命令行控制台生产者消费者测试</h3><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list localhost:<span class="hljs-number">9092</span> --topic test&gt;hello, kafka.&gt;what a nice day!&gt;to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div><h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:<span class="hljs-number">9092</span> --topic test --from-beginninghello, kafka.what a nice day!to be or <span class="hljs-keyword">not</span> to be. that&#x27; s a question.</code></pre></div><ul><li>–from-beginning： 会把主题中以往所有的数据都读取出来。</li></ul><h3 id="1-9-数据日志分离"><a href="#1-9-数据日志分离" class="headerlink" title="1.9 数据日志分离"></a>1.9 数据日志分离</h3><h3 id="1-10-回顾"><a href="#1-10-回顾" class="headerlink" title="1.10 回顾"></a>1.10 回顾</h3><h2 id="2-Kafka高级"><a href="#2-Kafka高级" class="headerlink" title="2 Kafka高级"></a>2 Kafka高级</h2><h3 id="2-1-工作流程"><a href="#2-1-工作流程" class="headerlink" title="2.1 工作流程"></a>2.1 工作流程</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/05.png" alt></p><ul><li><p>Kafka 中消息是以 topic 进行分类的， producer生产消息，consumer消费消息，都是面向 topic的。(从命令行操作看出)</p><div class="code-wrapper"><pre><code class="hljs shell">bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic testbin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning</code></pre></div></li><li><p>topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文件，该 log 文件中存储的就是 producer 生产的数据。（topic = N partition，partition = log）</p></li><li><p>Producer 生产的数据会被不断追加到该log 文件末端，且每条数据都有自己的 offset。 consumer组中的每个consumer， 都会实时记录自己消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。（producer -&gt; log with offset -&gt; consumer(s)）</p></li></ul><h3 id="2-2-文件存储"><a href="#2-2-文件存储" class="headerlink" title="2.2 文件存储"></a>2.2 文件存储</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/06.png" alt></p><ul><li><p>由于生产者生产的消息会不断追加到 log 文件末尾， 为防止 log 文件过大导致数据定位效率低下， Kafka 采取了<strong>分片</strong>和<strong>索引</strong>机制，将每个 partition 分为多个 segment。</p></li><li><p>每个 segment对应两个文件——“.index”文件和“.log”文件。 这些文件位于一个文件夹下， 该文件夹的命名规则为： topic 名称+分区序号。例如， first 这个 topic 有三个分区，则其对应的文件夹为 first-0,first-1,first-2。</p><div class="code-wrapper"><pre><code class="hljs shell">00000000000000000000.index00000000000000000000.log00000000000000170410.index00000000000000170410.log00000000000000239430.index00000000000000239430.log</code></pre></div></li><li><p>index 和 log 文件以当前 segment 的第一条消息的 offset 命名。下图为 index 文件和 log文件的结构示意图。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/07.png" alt></p></li><li><p><strong>“.index”文件存储大量的索引信息，“.log”文件存储大量的数据</strong>，索引文件中的元数据指向对应数据文件中 message 的物理偏移地址。</p><blockquote><p>  segment 英 [ˈseɡmənt , seɡˈment] 美 [ˈseɡmənt , seɡˈment]<br>  n.部分;份;片;段;(柑橘、柠檬等的)瓣;弓形;圆缺 v.分割;划分</p></blockquote></li></ul><h3 id="2-3-生产者分区策略"><a href="#2-3-生产者分区策略" class="headerlink" title="2.3 生产者分区策略"></a>2.3 生产者分区策略</h3><h4 id="1-分区的原因"><a href="#1-分区的原因" class="headerlink" title="1 分区的原因"></a>1 分区的原因</h4><ul><li><strong>方便在集群中扩展</strong>，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic又可以有多个 Partition 组成，因此整个集群就可以适应适合的数据了；</li><li><strong>可以提高并发</strong>，因为可以以 Partition 为单位读写了。（联想到ConcurrentHashMap在高并发环境下读写效率比HashTable的高效）</li></ul><h4 id="2-分区的原则"><a href="#2-分区的原则" class="headerlink" title="2 分区的原则"></a>2 分区的原则</h4><p>我们需要将 producer 发送的数据封装成一个 <code>ProducerRecord</code> 对象。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/08.png" alt></p><ol><li>指明 partition 的情况下，直接将指明的值直接作为 partiton 值；</li><li>没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值；</li><li>既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition值，也就是常说的 round-robin 算法。</li></ol><h3 id="2-4-生产者ISR"><a href="#2-4-生产者ISR" class="headerlink" title="2.4 生产者ISR"></a>2.4 生产者ISR</h3><p>为保证 producer 发送的数据，能可靠的发送到指定的 topic， topic 的每个 partition 收到producer 发送的数据后，都需要向 producer 发送 ack（acknowledgement 确认收到），如果producer 收到 ack， 就会进行下一轮的发送，否则重新发送数据。</p><blockquote><p>  acknowledgement 英 [əkˈnɒlɪdʒmənt] 美 [əkˈnɑːlɪdʒmənt]<br>  n.(对事实、现实、存在的)承认;感谢;谢礼;<strong>收件复函</strong></p></blockquote><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/09.png" alt></p><p><strong>何时发送ack？</strong></p><p>确保有follower与leader同步完成，leader再发送ack，这样才能保证leader挂掉之后，能在follower中选举出新的leader。</p><p><strong>多少个follower同步完成之后发送ack？</strong></p><ol><li>半数以上的follower同步完成，即可发送ack继续发送重新发送</li><li>全部的follower同步完成，才可以发送ack</li></ol><h4 id="1-副本数据同步策略"><a href="#1-副本数据同步策略" class="headerlink" title="1 副本数据同步策略"></a>1 副本数据同步策略</h4><table><thead><tr><th>序号</th><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1</td><td>半数以上完成同步， 就发送 ack</td><td>延迟低</td><td>选举新的 leader 时，容忍 n 台节点的故障，需要 2n+1 个副本。（如果集群有2n+1台机器，选举leader的时候至少需要半数以上即n+1台机器投票，那么能容忍的故障，最多就是n台机器发生故障）容错率：1/2</td></tr><tr><td>2</td><td>全部完成同步，才发送ack</td><td>选举新的 leader 时， 容忍 n 台节点的故障，需要 n+1 个副本（如果集群有n+1台机器，选举leader的时候只要有一个副本就可以了）容错率：1</td><td>延迟高</td></tr></tbody></table><p>Kafka 选择了第二种方案，原因如下：</p><ol><li>同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1 个副本，而 Kafka 的每个分区都有大量的数据， 第一种方案会造成大量数据的冗余。</li><li>虽然第二种方案的网络延迟会比较高，但网络延迟对 Kafka 的影响较小。</li></ol><h4 id="2-ISR"><a href="#2-ISR" class="headerlink" title="2 ISR"></a>2 ISR</h4><p>采用第二种方案之后，设想以下情景： leader 收到数据，所有 follower 都开始同步数据，但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去，直到它完成同步，才能发送 ack。这个问题怎么解决呢？</p><p>Leader 维护了一个动态的 <strong>in-sync replica set</strong> (ISR)，意为和 leader 保持同步的 follower 集合。当 ISR 中的 follower 完成数据的同步之后，就会给 leader 发送 ack。如果 follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由<code>replica.lag.time.max.ms</code>参数设定。 Leader 发生故障之后，就会从 ISR 中选举新的 leader。</p><blockquote><p>  <strong>replica.lag.time.max.ms</strong></p><p>  <strong>DESCRIPTION</strong>: If a follower hasn’t sent any fetch requests or hasn’t consumed up to the leaders log end offset for at least this time, the leader will remove the follower from isr</p><p>  <strong>TYPE</strong>: long</p><p>  <strong>DEFAULT</strong>: 10000</p><p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23brokerconfigs">Source</a></p></blockquote><h3 id="2-5-生产者ACK机制"><a href="#2-5-生产者ACK机制" class="headerlink" title="2.5 生产者ACK机制"></a>2.5 生产者ACK机制</h3><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等 ISR 中的 follower 全部接收成功。</p><p>所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，选择以下的配置。</p><h4 id="acks-参数配置："><a href="#acks-参数配置：" class="headerlink" title="acks 参数配置："></a><strong>acks 参数配置</strong>：</h4><ul><li>0： producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟， broker 一接收到还没有写入磁盘就已经返回，当 broker 故障时有可能<strong>丢失数据</strong>；</li><li>1： producer 等待 broker 的 ack， partition 的 leader 落盘成功后返回 ack，如果在 follower同步成功之前 leader 故障，那么将会<strong>丢失数据</strong>；</li></ul><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/10.png" alt></p><ul><li>-1（all） ： producer 等待 broker 的 ack， partition 的 leader 和 ISR 的follower 全部落盘成功后才返回 ack。但是如果在 follower 同步完成后， broker 发送 ack 之前， leader 发生故障，那么会造成<strong>数据重复</strong>。</li></ul><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/11.png" alt></p><p><strong>助记：返ACK前，0无落盘，1一落盘，-1全落盘，（落盘：消息存到本地）</strong></p><blockquote><p>  <strong>acks</strong></p><p>  <strong>DESCRIPTION</strong>:</p><p>  The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. The following settings are allowed:</p><ul><li><code>acks=0</code> If set to zero then the producer will not wait for any acknowledgment from the server at all. The record will be immediately added to the socket buffer and considered sent. No guarantee can be made that the server has received the record in this case, and the retries configuration will not take effect (as the client won’t generally know of any failures). The offset given back for each record will always be set to -1.</li><li><code>acks=1</code> This will mean the leader will write the record to its local log but will respond without awaiting full acknowledgement from all followers. In this case should the leader fail immediately after acknowledging the record but before the followers have replicated it then the record will be lost.</li><li><code>acks=all</code> This means the leader will wait for the full set of in-sync replicas to acknowledge the record. This guarantees that the record will not be lost as long as at least one in-sync replica remains alive. This is the strongest available guarantee. This is equivalent to the acks=-1 setting.</li></ul><p>  <strong>TYPE</strong>:string</p><p>  <strong>DEFAULT</strong>:1</p><p>  <strong>VALID VALUES</strong>:[all, -1, 0, 1]</p><p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23producerconfigs">Source</a></p></blockquote><h3 id="2-6-数据一致性问题"><a href="#2-6-数据一致性问题" class="headerlink" title="2.6 数据一致性问题"></a>2.6 数据一致性问题</h3><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/12.png" alt></p><ul><li>LEO：（Log End Offset）每个副本的最后一个offset</li><li>HW：（High Watermark）高水位，指的是消费者能见到的最大的 offset， ISR 队列中最小的 LEO</li></ul><h4 id="follower-故障和-leader-故障"><a href="#follower-故障和-leader-故障" class="headerlink" title="follower 故障和 leader 故障"></a>follower 故障和 leader 故障</h4><ul><li><strong>follower 故障</strong>：follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后， follower 会读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重新加入 ISR 了。</li><li><strong>leader 故障</strong>：leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性， 其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader同步数据。</li></ul><p>注意： 这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p><h3 id="2-7-ExactlyOnce"><a href="#2-7-ExactlyOnce" class="headerlink" title="2.7 ExactlyOnce"></a>2.7 ExactlyOnce</h3><p>将服务器的 ACK 级别设置为-1（all），可以保证 Producer 到 Server 之间不会丢失数据，即 <strong>At Least Once</strong> 语义。</p><p>相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被发送一次，即 <strong>At Most Once</strong> 语义。</p><p>At Least Once 可以保证数据不丢失，但是不能保证数据不重复；相对的， At Most Once可以保证数据不重复，但是不能保证数据不丢失。 但是，对于一些非常重要的信息，比如说<strong>交易数据</strong>，下游数据消费者要求数据既不重复也不丢失，即 <strong>Exactly Once</strong> 语义。</p><blockquote><ul><li><p>At least once—Messages are <strong>never lost</strong> but may be redelivered.</p></li><li><p>At most once—Messages <strong>may be lost</strong> but are never redelivered.</p></li><li><p>Exactly once—this is what people actually want, each message is delivered once and only once.</p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23semantics">Source</a></p></li></ul></blockquote><p>在 0.11 版本以前的 Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p><p>0.11 版本的 Kafka，引入了一项重大特性：<strong>幂等性</strong>。<strong>所谓的幂等性就是指 Producer 不论向 Server 发送多少次重复数据， Server 端都只会持久化一条</strong>。幂等性结合 At Least Once 语义，就构成了 Kafka 的 Exactly Once 语义。即：</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">At</span> <span class="hljs-variable">Least</span> <span class="hljs-built_in">Once</span> <span class="hljs-operator">+</span> 幂等性 <span class="hljs-operator">=</span> <span class="hljs-variable">Exactly</span> <span class="hljs-built_in">Once</span></code></pre></div><p>要启用幂等性，只需要将 Producer 的参数中 <code>enable.idempotence</code> 设置为 true 即可。 Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 Producer 在初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而Broker 端会对<code>&lt;PID, Partition, SeqNumber&gt;</code>做缓存，当具有相同主键的消息提交时， Broker 只会持久化一条。</p><p>但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨分区跨会话的 Exactly Once。</p><blockquote><p>  <strong>enable.idempotence</strong></p><p>  DESCRIPTION:When set to ‘true’, the producer will ensure that exactly one copy of each message is written in the stream. If ‘false’, producer retries due to broker failures, etc., may write duplicates of the retried message in the stream. This is set to ‘false’ by default. Note that enabling idempotence requires <code>max.in.flight.requests.per.connection</code> to be set to 1 and <code>retries</code> cannot be zero. Additionally acks must be set to ‘all’. If these values are left at their defaults, we will override the default to be suitable. If the values are set to something incompatible with the idempotent producer, a ConfigException will be thrown.</p><p>  TYPE:boolean</p><p>  DEFAULT:false</p><p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23producerconfigs">Source</a></p></blockquote><h3 id="2-8-生产者总结"><a href="#2-8-生产者总结" class="headerlink" title="2.8 生产者总结"></a>2.8 生产者总结</h3><h3 id="2-9-消费者分区分配策略"><a href="#2-9-消费者分区分配策略" class="headerlink" title="2.9 消费者分区分配策略"></a>2.9 消费者分区分配策略</h3><h4 id="1-消费方式"><a href="#1-消费方式" class="headerlink" title="1 消费方式"></a>1 消费方式</h4><p><strong>consumer 采用 pull（拉） 模式从 broker 中读取数据</strong>。</p><p><strong>push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的</strong>。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</p><p><strong>pull 模式不足之处</strong>是，如果 kafka 没有数据，消费者可能会陷入循环中， 一直返回空数据。 针对这一点， Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有数据可供消费， consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p><p><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23design_pull">Push vs. pull</a></p><h4 id="2-分区分配策略"><a href="#2-分区分配策略" class="headerlink" title="2 分区分配策略"></a>2 分区分配策略</h4><p>一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以必然会涉及到 partition 的分配问题，即确定那个 partition 由哪个 consumer 来消费。</p><p>Kafka 有两种分配策略：</p><ul><li>round-robin循环</li><li>range</li></ul><blockquote><p>  <strong>partition.assignment.strategy</strong></p><p>  Select between the “range” or “roundrobin” strategy for assigning分配 partitions to consumer streams.</p><p>  The <strong>round-robin</strong> partition assignor lays out规划 all the available partitions and all the available consumer threads. It then proceeds to do接着做 a round-robin assignment from partition to consumer thread. If the subscriptions订阅 of all consumer instances are identical完全同样的, then the partitions will be uniformly 均匀地distributed. (i.e.也就是说, the partition ownership counts will be within a delta of exactly one across all consumer threads.) Round-robin assignment is permitted only if:</p><ol><li>Every topic has the same number of streams within a consumer instance</li><li>The set of subscribed topics is identical for every consumer instance within the group.</li></ol><p>  <strong>Range</strong> partitioning works on a per-<strong>topic</strong> basis. For each topic, we lay out the available partitions in numeric order and the consumer threads in lexicographic词典式的 order. We then divide the number of partitions by the total number of consumer streams (threads) to determine the number of partitions to assign to each consumer. If it does not evenly divide, then the first few consumers will have one extra partition.</p><p>  <strong>DEFAULT</strong>:range</p><p>  <a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23oldconsumerconfigs">Source</a></p></blockquote><hr><p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F86718818">Kafka再平衡机制详解</a></p><h4 id="3-Round-Robin"><a href="#3-Round-Robin" class="headerlink" title="3 Round Robin"></a>3 Round Robin</h4><p>关于Roudn Robin重分配策略，其主要采用的是一种轮询的方式分配所有的分区，该策略主要实现的步骤如下。这里我们首先假设有三个topic：t0、t1和t2，这三个topic拥有的分区数分别为1、2和3，那么总共有六个分区，这六个分区分别为：t0-0、t1-0、t1-1、t2-0、t2-1和t2-2。这里假设我们有三个consumer：C0、C1和C2，它们订阅情况为：C0订阅t0，C1订阅t0和t1，C2订阅t0、t1和t2。那么这些分区的分配步骤如下：</p><ul><li>首先将所有的partition和consumer按照字典序进行排序，所谓的字典序，就是按照其名称的字符串顺序，那么上面的六个分区和三个consumer排序之后分别为：</li></ul><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/16.png" alt></p><ul><li>然后依次以按顺序轮询的方式将这六个分区分配给三个consumer，如果当前consumer没有订阅当前分区所在的topic，则轮询的判断下一个consumer：</li><li>尝试将t0-0分配给C0，由于C0订阅了t0，因而可以分配成功；</li><li>尝试将t1-0分配给C1，由于C1订阅了t1，因而可以分配成功；</li><li>尝试将t1-1分配给C2，由于C2订阅了t1，因而可以分配成功；</li><li>尝试将t2-0分配给C0，由于C0没有订阅t2，因而会轮询下一个consumer；</li><li>尝试将t2-0分配给C1，由于C1没有订阅t2，因而会轮询下一个consumer；</li><li>尝试将t2-0分配给C2，由于C2订阅了t2，因而可以分配成功；</li><li>同理由于t2-1和t2-2所在的topic都没有被C0和C1所订阅，因而都不会分配成功，最终都会分配给C2。</li><li>按照上述的步骤将所有的分区都分配完毕之后，最终分区的订阅情况如下：</li></ul><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/17.png" alt></p><p>从上面的步骤分析可以看出，轮询的策略就是简单的将所有的partition和consumer按照字典序进行排序之后，然后依次将partition分配给各个consumer，如果当前的consumer没有订阅当前的partition，那么就会轮询下一个consumer，直至最终将所有的分区都分配完毕。但是从上面的分配结果可以看出，轮询的方式会导致每个consumer所承载的分区数量不一致，从而导致各个consumer压力不均一。</p><h4 id="4-Range"><a href="#4-Range" class="headerlink" title="4 Range"></a>4 Range</h4><p>所谓的Range重分配策略，就是首先会计算各个consumer将会承载的分区数量，然后将指定数量的分区分配给该consumer。这里我们假设有两个consumer：C0和C1，两个topic：t0和t1，这两个topic分别都有三个分区，那么总共的分区有六个：t0-0、t0-1、t0-2、t1-0、t1-1和t1-2。那么Range分配策略将会按照如下步骤进行分区的分配：</p><ul><li>需要注意的是，Range策略是按照topic依次进行分配的，比如我们以t0进行讲解，其首先会获取t0的所有分区：t0-0、t0-1和t0-2，以及所有订阅了该topic的consumer：C0和C1，并且会将这些分区和consumer按照字典序进行排序；</li><li>然后按照平均分配的方式计算每个consumer会得到多少个分区，如果没有除尽，则会将多出来的分区依次计算到前面几个consumer。比如这里是三个分区和两个consumer，那么每个consumer至少会得到1个分区，而3除以2后还余1，那么就会将多余的部分依次算到前面几个consumer，也就是这里的1会分配给第一个consumer，总结来说，那么C0将会从第0个分区开始，分配2个分区，而C1将会从第2个分区开始，分配1个分区；</li><li>同理，按照上面的步骤依次进行后面的topic的分配。</li><li>最终上面六个分区的分配情况如下：</li></ul><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/18.png" alt></p><p>可以看到，如果按照<code>Range</code>分区方式进行分配，其本质上是依次遍历每个topic，然后将这些topic的分区按照其所订阅的consumer数量进行平均的范围分配。这种方式从计算原理上就会导致排序在前面的consumer分配到更多的分区，从而导致各个consumer的压力不均衡。</p><p>TODO:我的问题：topic分多个partition，有些custom根据上述策略，分到topic的部分partition，难道不是要全部partition吗？是不是还要按照相同策略多分配多一次？</p><h3 id="2-10-消费者offset的存储"><a href="#2-10-消费者offset的存储" class="headerlink" title="2.10 消费者offset的存储"></a>2.10 消费者offset的存储</h3><p>由于 consumer 在消费过程中可能会出现断电宕机等故障， consumer 恢复后，需要从故障前的位置的继续消费，所以 <strong>consumer 需要实时记录自己消费到了哪个 offset</strong>，以便故障恢复后继续消费。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/13.png" alt></p><p><strong>Kafka 0.9 版本之前， consumer 默认将 offset 保存在 Zookeeper 中，从 0.9 版本开始，consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为__consumer_offsets</strong>。</p><ol><li>修改配置文件 consumer.properties，<code>exclude.internal.topics=false</code>。</li><li>读取 offset<ul><li>0.11.0.0 之前版本 - <code>bin/kafka-console-consumer.sh --topic __consumer_offsets --zookeeper hadoop102:2181 --formatter &quot;kafka.coordinator.GroupMetadataManager\$OffsetsMessageFormatter&quot; --consumer.config config/consumer.properties --from-beginning</code></li><li>0.11.0.0 及之后版本 - <code>bin/kafka-console-consumer.sh --topic __consumer_offsets --zookeeper hadoop102:2181 --formatter &quot;kafka.coordinator.group.GroupMetadataManager\$OffsetsMessageFormatter&quot; --consumer.config config/consumer.properties --from-beginning</code></li></ul></li></ol><p>TODO:上机实验</p><h3 id="2-11-消费者组案例"><a href="#2-11-消费者组案例" class="headerlink" title="2.11 消费者组案例"></a>2.11 消费者组案例</h3><h4 id="1-需求"><a href="#1-需求" class="headerlink" title="1 需求"></a>1 需求</h4><p>测试同一个消费者组中的消费者， <strong>同一时刻只能有一个</strong>消费者消费。</p><h4 id="2-操作步骤"><a href="#2-操作步骤" class="headerlink" title="2 操作步骤"></a>2 操作步骤</h4><p>1.修改<code>%KAFKA_HOME\config\consumer.properties%</code>文件中的<code>group.id</code>属性。</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">group.id</span>=<span class="hljs-string">shan-kou-zu</span></code></pre></div><p>2.打开两个cmd，分别启动两个消费者。（以<code>%KAFKA_HOME\config\consumer.properties%</code>作配置参数）</p><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-consumer.bat --zookeeper <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2181</span> --topic test --consumer.config config\consumer.properties</code></pre></div><p>3.再打开一个cmd，启动一个生产者。</p><div class="code-wrapper"><pre><code class="hljs bat">bin\windows\kafka-console-producer.bat --broker-list <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">9092</span> --topic test</code></pre></div><p>4.在生产者窗口输入消息，观察两个消费者窗口。<strong>会发现两个消费者窗口中，只有一个才会弹出消息</strong>。</p><h3 id="2-12-高效读写-amp-ZK作用"><a href="#2-12-高效读写-amp-ZK作用" class="headerlink" title="2.12 高效读写&amp;ZK作用"></a>2.12 高效读写&amp;ZK作用</h3><h4 id="1-顺序写磁盘"><a href="#1-顺序写磁盘" class="headerlink" title="1 顺序写磁盘"></a>1 顺序写磁盘</h4><p>Kafka 的 producer 生产数据，要写入到 log 文件中，写的过程是一直追加到文件末端，为顺序写。 官网有数据表明，同样的磁盘，顺序写能到 600M/s，而随机写只有 100K/s。这与磁盘的机械机构有关，顺序写之所以快，是因为其<strong>省去了大量磁头寻址的时间</strong>。</p><h4 id="2-零复制技术"><a href="#2-零复制技术" class="headerlink" title="2 零复制技术"></a>2 零复制技术</h4><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/14.png" alt></p><ul><li>NIC network interface controller 网络接口控制器</li></ul><h4 id="3-Zookeeper-在-Kafka-中的作用"><a href="#3-Zookeeper-在-Kafka-中的作用" class="headerlink" title="3 Zookeeper 在 Kafka 中的作用"></a>3 Zookeeper 在 Kafka 中的作用</h4><p>Kafka 集群中有一个 broker 会被选举为 Controller，负责管理集群 broker 的上下线，所有 topic 的分区副本分配和 leader 选举等工作。<a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fkafka.apache.org%2F0110%2Fdocumentation%2F%23design_replicamanagment">Reference</a></p><p>Controller 的管理工作都是依赖于 Zookeeper 的。</p><p>以下为 partition 的 leader 选举过程：</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/15.png" alt></p><h3 id="2-13-Ranger分区再分析"><a href="#2-13-Ranger分区再分析" class="headerlink" title="2.13 Ranger分区再分析"></a>2.13 Ranger分区再分析</h3><h3 id="2-14-事务"><a href="#2-14-事务" class="headerlink" title="2.14 事务"></a>2.14 事务</h3><p>Kafka 从 0.11 版本开始引入了事务支持。事务可以保证 Kafka 在 Exactly Once 语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p><h4 id="1-Producer-事务"><a href="#1-Producer-事务" class="headerlink" title="1 Producer 事务"></a>1 Producer 事务</h4><p>为了实现跨分区跨会话的事务，需要引入一个全局唯一的 Transaction ID，并将 Producer 获得的PID 和Transaction ID 绑定。这样当Producer 重启后就可以通过正在进行的 TransactionID 获得原来的 PID。</p><p>为了管理 Transaction， Kafka 引入了一个新的组件 Transaction Coordinator。 Producer 就是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。 Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p><h4 id="2-Consumer-事务"><a href="#2-Consumer-事务" class="headerlink" title="2 Consumer 事务"></a>2 Consumer 事务</h4><p>上述事务机制主要是从 Producer 方面考虑，对于 Consumer 而言，事务的保证就会相对较弱，尤其时无法保证 Commit 的信息被精确消费。这是由于 Consumer 可以通过 offset 访问任意信息，而且不同的 Segment File 生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p><h3 id="2-15-API生产者流程"><a href="#2-15-API生产者流程" class="headerlink" title="2.15 API生产者流程"></a>2.15 API生产者流程</h3><p>Kafka 的 Producer 发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了两个线程——main 线程和 Sender 线程，以及一个线程共享变量——RecordAccumulator。 main 线程将消息发送给 RecordAccumulator， Sender 线程不断从 RecordAccumulator 中拉取消息发送到 Kafka broker。</p><p><img src="/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/19.png" alt></p><p>相关参数：</p><ul><li><strong>batch.size</strong>： 只有数据积累到 batch.size 之后， sender 才会发送数据。</li><li><strong>linger.ms</strong>： 如果数据迟迟未达到 batch.size， sender 等待 linger.time 之后就会发送数据。</li></ul><h3 id="2-16异步发送API普通生产者"><a href="#2-16异步发送API普通生产者" class="headerlink" title="2.16异步发送API普通生产者"></a>2.16异步发送API普通生产者</h3><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1 导入依赖"></a>1 导入依赖</h4><p><a href="https://my.oschina.net/jallenkwong/blog/pom.xml">pom.xml</a></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-clients<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2 编写代码"></a>2 编写代码</h4><p>需要用到的类：</p><ul><li>KafkaProducer：需要创建一个生产者对象，用来发送数据</li><li>ProducerConfig：获取所需的一系列配置参数</li><li>ProducerRecord：每条数据都要封装成一个 ProducerRecord 对象</li></ul><p><a href="https://gitee.com/jallenkwong/LearnKafka/blob/master/src/main/java/com/lun/kafka/producer/CustomProducer.java">CustomProducer.java</a></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.Producer;<span class="hljs-keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomProducer</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Properties props = <span class="hljs-keyword">new</span> Properties();<span class="hljs-comment">// kafka 集群， broker-list</span>props.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>);<span class="hljs-comment">//可用ProducerConfig.ACKS_CONFIG 代替 &quot;acks&quot;</span><span class="hljs-comment">//props.put(ProducerConfig.ACKS_CONFIG, &quot;all&quot;);</span>props.put(<span class="hljs-string">&quot;acks&quot;</span>, <span class="hljs-string">&quot;all&quot;</span>);<span class="hljs-comment">// 重试次数</span>props.put(<span class="hljs-string">&quot;retries&quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// 批次大小</span>props.put(<span class="hljs-string">&quot;batch.size&quot;</span>, <span class="hljs-number">16384</span>);<span class="hljs-comment">// 等待时间</span>props.put(<span class="hljs-string">&quot;linger.ms&quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// RecordAccumulator 缓冲区大小</span>props.put(<span class="hljs-string">&quot;buffer.memory&quot;</span>, <span class="hljs-number">33554432</span>);props.put(<span class="hljs-string">&quot;key.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);props.put(<span class="hljs-string">&quot;value.serializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);Producer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> KafkaProducer&lt;&gt;(props);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;producer.send(<span class="hljs-keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;test-&quot;</span> + Integer.toString(i),<span class="hljs-string">&quot;test-&quot;</span> + Integer.toString(i)));&#125;producer.close();&#125;&#125;</code></pre></div><h3 id="2-17-回顾"><a href="#2-17-回顾" class="headerlink" title="2.17 回顾"></a>2.17 回顾</h3>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Distributed/">Distributed</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Kafka/">Kafka</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/25/Kafka%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Clion搭建Gtest单元测试框架</title>
      <link>https://pncalbl.github.io/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</link>
      <guid>https://pncalbl.github.io/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</guid>
      <pubDate>Fri, 21 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Clion搭建Gtest单元测试框架&quot;&gt;&lt;a href=&quot;#Clion搭建Gtest单元测试框架&quot; class=&quot;headerlink&quot; title=&quot;Clion搭建Gtest单元测试框架&quot;&gt;&lt;/a&gt;Clion搭建Gtest单元测试框架&lt;/h1&gt;&lt;h2 id=&quot;1</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Clion搭建Gtest单元测试框架"><a href="#Clion搭建Gtest单元测试框架" class="headerlink" title="Clion搭建Gtest单元测试框架"></a>Clion搭建Gtest单元测试框架</h1><h2 id="1-下载GTest源码"><a href="#1-下载GTest源码" class="headerlink" title="1 下载GTest源码"></a>1 下载GTest源码</h2><div class="code-wrapper"><pre><code class="hljs shell">git clone https://github.com/google/googletest.git</code></pre></div><p>下载下来的google gtest源码目录结构如下，里面包含了很多东西，这里我们只是想利用gtest对自己的代码进行单元测试，因此只需要关注红框所求的文件夹即可，其他的暂时不需要关注</p><p><img src="/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/570699-20190715005207916-173277913.png" alt="img"></p><h2 id="2-导入-Gtest"><a href="#2-导入-Gtest" class="headerlink" title="2 导入 Gtest"></a>2 导入 Gtest</h2><p>使用CLion新建一下C++项目，把gtest引入到项目中，将上面googletest目录放在external下面了，这个目录随意，看个人喜好了。</p><p><img src="/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/image-20210525000900512.png" alt="image-20210525000900512"></p><h2 id="3-配置-CMakeList-txt"><a href="#3-配置-CMakeList-txt" class="headerlink" title="3 配置 CMakeList.txt"></a>3 配置 CMakeList.txt</h2><ul><li>设置<strong>GOOGLETEST_VERSION</strong>变量，这个变量，其实是在googletest-master目录下的CMakeLists.txt中设置的，在googlegtest目录下的CMakeLists.txt中使用，如果我们不在项目的CMaksLists.txt中设置这个变量，则gtest的编译会失败，这点非常重要。</li><li>添加googletest目录到项目中，这个很简单。</li><li>添加target link，这个示例中，我新了一个demotest.cpp，里面用来放置单元测试用例相关的代码，将其编译为二进制可执行文件，来对正式项目代码进行测试，因为它依赖于gtest_main，因此这里必须把它们link起来，否则，test_main的编译会失败。</li></ul><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.17</span>)    <span class="hljs-comment"># cmake最低版本号要求</span><span class="hljs-keyword">project</span>(TestProject)    <span class="hljs-comment"># 项目名</span><span class="hljs-keyword">set</span>(GOOGLETEST_VERSION <span class="hljs-number">1.10</span>.<span class="hljs-number">0</span>)  <span class="hljs-comment"># 设置 Gtest 的版本</span><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)      <span class="hljs-comment"># C++ 版本</span><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;-Wall&quot;</span>)    <span class="hljs-comment">#</span><span class="hljs-comment"># 编译google test，会在当前目录生成libtest.a静态库</span><span class="hljs-keyword">add_subdirectory</span>(        external/googletest)<span class="hljs-comment"># 添加头文件</span><span class="hljs-keyword">include_directories</span>(        <span class="hljs-keyword">include</span>        external/googletest/<span class="hljs-keyword">include</span>)<span class="hljs-comment">#需要添加googletest运行需要的pthread</span><span class="hljs-keyword">set</span>(LIBRARIES        gtest        pthread)<span class="hljs-keyword">set</span>(SOURCE_FLIES tests/demotest.cpp) <span class="hljs-comment"># 其余文件</span><span class="hljs-keyword">add_executable</span>(main src/main.cpp)   <span class="hljs-comment"># main 函数</span><span class="hljs-keyword">add_executable</span>(TestProject <span class="hljs-variable">$&#123;SOURCE_FLIES&#125;</span> external/googletest)<span class="hljs-keyword">target_link_libraries</span>(TestProject gtest_main)</code></pre></div><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><p>demotest.cpp</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gtest/gtest.h&quot;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> ::testing;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GTestDemo</span> :</span> <span class="hljs-keyword">public</span> Test &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">GTestDemo</span>() : <span class="hljs-built_in">Test</span>() &#123;    &#125;    ~<span class="hljs-built_in">GTestDemo</span>() <span class="hljs-keyword">override</span> = <span class="hljs-keyword">default</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetUp</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;        Test::<span class="hljs-built_in">SetUp</span>();        std::cout &lt;&lt; <span class="hljs-string">&quot;I am setup&quot;</span> &lt;&lt; std::endl;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;        Test::<span class="hljs-built_in">TearDown</span>();        std::cout &lt;&lt; <span class="hljs-string">&quot;I am teardown&quot;</span> &lt;&lt; std::endl;    &#125;&#125;;<span class="hljs-built_in">TEST_F</span>(GTestDemo, tc_example_01) &#123;    std::cout &lt;&lt; <span class="hljs-string">&quot;GTestDemo&quot;</span> &lt;&lt; std::endl;&#125;</code></pre></div><p><img src="/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/image-20210525001538855.png" alt="image-20210525001538855"></p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Win/">Win</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Note/">Note</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Netty 学习</title>
      <link>https://pncalbl.github.io/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 21 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Netty-学习&quot;&gt;&lt;a href=&quot;#Netty-学习&quot; class=&quot;headerlink&quot; title=&quot;Netty 学习&quot;&gt;&lt;/a&gt;Netty 学习&lt;/h1&gt;&lt;h2 id=&quot;1-Netty-介绍和应用场景&quot;&gt;&lt;a href=&quot;#1-Netty-介绍和应用场</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Netty-学习"><a href="#Netty-学习" class="headerlink" title="Netty 学习"></a>Netty 学习</h1><h2 id="1-Netty-介绍和应用场景"><a href="#1-Netty-介绍和应用场景" class="headerlink" title="1 Netty 介绍和应用场景"></a>1 Netty 介绍和应用场景</h2><h3 id="1-1-本课程的学习要求"><a href="#1-1-本课程的学习要求" class="headerlink" title="1.1 本课程的学习要求"></a>1.1 本课程的学习要求</h3><ol><li>本课程不适用于 <code>0</code> 基础的学员。</li><li>要求已经掌握了 <code>Java</code> 编程，主要技术构成：<code>Java OOP</code> 编程、<code>Java</code> 多线程编程、<code>Java IO</code> 编程、<code>Java</code> 网络编程、常用的 <code>Java</code> 设计模式（比如观察者模式，命令模式，职责链模式）、常用的数据结构（比如链表）。</li><li>本课程的《<code>Netty</code> 核心源码剖析章节》要求学员最好有项目开发和阅读源码的经历。</li></ol><h3 id="1-2-Netty-的介绍"><a href="#1-2-Netty-的介绍" class="headerlink" title="1.2 Netty 的介绍"></a>1.2 Netty 的介绍</h3><ol><li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li><li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li><li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li><li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li><li>要透彻理解 <code>Netty</code>，需要先学习 <code>NIO</code>，这样我们才能阅读 <code>Netty</code> 的源码。</li></ol><h3 id="1-3-Netty-的应用场景"><a href="#1-3-Netty-的应用场景" class="headerlink" title="1.3 Netty 的应用场景"></a>1.3 Netty 的应用场景</h3><h4 id="1-3-1-互联网行业"><a href="#1-3-1-互联网行业" class="headerlink" title="1.3.1 互联网行业"></a>1.3.1 互联网行业</h4><ol><li><p>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <code>RPC</code> 框架必不可少，<code>Netty</code> 作为异步高性能的通信框架，往往作为基础通信组件被这些 <code>RPC</code> 框架使用。</p></li><li><p>典型的应用有：阿里分布式服务框架 <code>Dubbo</code> 的 <code>RPC</code> 框 架使用 <code>Dubbo</code> 协议进行节点间通信，<code>Dubbo</code> 协议默认使用 <code>Netty</code> 作为基础通信组件，用于实现各进程节点之间的内部通信。</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_01.png" alt></p></li></ol><h4 id="1-3-2-游戏行业"><a href="#1-3-2-游戏行业" class="headerlink" title="1.3.2 游戏行业"></a>1.3.2 游戏行业</h4><ol><li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用。</li><li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器。</li><li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信。</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_02.png" alt></p><p>​                    <img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_03.png" alt></p><h4 id="1-3-3-大数据领域"><a href="#1-3-3-大数据领域" class="headerlink" title="1.3.3 大数据领域"></a>1.3.3 大数据领域</h4><ol><li>经典的 <code>Hadoop</code> 的高性能通信和序列化组件 <code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信。</li><li>它的 <code>NettyService</code> 基于 <code>Netty</code> 框架二次封装实现。</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_04.png" alt></p><h4 id="1-3-4-其他开源项目使用到-Netty"><a href="#1-3-4-其他开源项目使用到-Netty" class="headerlink" title="1.3.4 其他开源项目使用到 Netty"></a>1.3.4 其他开源项目使用到 Netty</h4><p>网址：<a href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a></p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_05.png" alt></p><h3 id="1-4-Netty-的学习资料的参考"><a href="#1-4-Netty-的学习资料的参考" class="headerlink" title="1.4 Netty 的学习资料的参考"></a>1.4 Netty 的学习资料的参考</h3><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/59141c1dN7a93c127.jpg" alt></p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/555080b2Ne6cbf9e3.jpg" alt></p><h2 id="2-Java-BIO-编程"><a href="#2-Java-BIO-编程" class="headerlink" title="2 Java BIO 编程"></a>2 Java BIO 编程</h2><h3 id="2-1-I-O-模型"><a href="#2-1-I-O-模型" class="headerlink" title="2.1 I/O 模型"></a>2.1 I/O 模型</h3><h4 id="2-1-1-模型基本说明"><a href="#2-1-1-模型基本说明" class="headerlink" title="2.1.1 模型基本说明"></a>2.1.1 模型基本说明</h4><ol><li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li><li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li><li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_01.png" alt></p><ol start="4"><li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_02.png" alt></p><ol start="5"><li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li></ol><h3 id="2-2-BIO、NIO、AIO-使用场景分析"><a href="#2-2-BIO、NIO、AIO-使用场景分析" class="headerlink" title="2.2  BIO、NIO、AIO 使用场景分析"></a>2.2  BIO、NIO、AIO 使用场景分析</h3><ol><li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li><li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li><li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li></ol><h3 id="2-3-Java-BIO-的基本介绍"><a href="#2-3-Java-BIO-的基本介绍" class="headerlink" title="2.3 Java BIO 的基本介绍"></a>2.3 Java BIO 的基本介绍</h3><ol><li><code>Java BIO</code>就是传统的<code>Java I/O</code>编程，其相关的类和接口在<code>java.io</code>。</li><li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户端连接服务器）。</li><li><code>BIO</code>方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code>以前的唯一选择，程序简易理解。</li></ol><h3 id="2-4-Java-BIO-的工作机制"><a href="#2-4-Java-BIO-的工作机制" class="headerlink" title="2.4 Java BIO 的工作机制"></a>2.4 Java BIO 的工作机制</h3><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_03.png" alt></p><p>对<code>BIO</code>编程流程的梳理</p><ol><li>服务器端启动一个<code>ServerSocket</code>。</li><li>客户端启动<code>Socket</code>对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通信。</li><li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li><li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li></ol><h3 id="2-5-Java-BIO-应用实例"><a href="#2-5-Java-BIO-应用实例" class="headerlink" title="2.5 Java BIO 应用实例"></a>2.5 Java BIO 应用实例</h3><p>实例说明：</p><ol><li><p>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</p></li><li><p>要求使用线程池机制改善，可以连接多个客户端。</p></li><li><p>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</p></li><li><p>代码演示</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.bio;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.net.ServerSocket;<span class="hljs-keyword">import</span> java.net.Socket;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIOServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 线程池机制</span>        <span class="hljs-comment">// 思路</span>        <span class="hljs-comment">// 1. 创建一个线程池</span>        <span class="hljs-comment">// 2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span>        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        <span class="hljs-comment">// 创建 ServerSocket</span>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);        System.out.println(<span class="hljs-string">&quot;服务器启动了&quot;</span>);        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());            <span class="hljs-comment">// 监听，等待客户端连接</span>            System.out.println(<span class="hljs-string">&quot;等待连接....&quot;</span>);            <span class="hljs-keyword">final</span> Socket socket = serverSocket.accept();            System.out.println(<span class="hljs-string">&quot;连接到一个客户端&quot;</span>);            <span class="hljs-comment">// 就创建一个线程，与之通讯(单独写一个方法)</span>            newCachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 我们重写</span>                    <span class="hljs-comment">// 可以和客户端通讯</span>                    handler(socket);                &#125;            &#125;);        &#125;    &#125;    <span class="hljs-comment">// 编写一个handler方法，和客户端通讯</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Socket socket)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];            <span class="hljs-comment">// 通过socket获取输入流</span>            InputStream inputStream = socket.getInputStream();            <span class="hljs-comment">// 循环的读取客户端发送的数据</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());                System.out.println(<span class="hljs-string">&quot;read....&quot;</span>);                <span class="hljs-keyword">int</span> read = inputStream.read(bytes);                <span class="hljs-keyword">if</span> (read != -<span class="hljs-number">1</span>) &#123;                    System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));<span class="hljs-comment">// 输出客户端发送的数据</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(<span class="hljs-string">&quot;关闭和client的连接&quot;</span>);            <span class="hljs-keyword">try</span> &#123;                socket.close();            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre></div></li></ol><h3 id="2-6-Java-BIO-问题分析"><a href="#2-6-Java-BIO-问题分析" class="headerlink" title="2.6 Java BIO 问题分析"></a>2.6 Java BIO 问题分析</h3><ol><li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li></ol><h2 id="3-Java-NIO-编程"><a href="#3-Java-NIO-编程" class="headerlink" title="3 Java NIO 编程"></a>3 Java NIO 编程</h2><h3 id="3-1-Java-NIO-基本介绍"><a href="#3-1-Java-NIO-基本介绍" class="headerlink" title="3.1 Java NIO 基本介绍"></a>3.1 Java NIO 基本介绍</h3><ol><li><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong>，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li><li><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li><li><code>NIO</code> 有三大核心部分：<strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</li><li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li><li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li><li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li><li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li><li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.nio.IntBuffer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicBuffer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//举例说明 Buffer 的使用(简单说明)</span>        <span class="hljs-comment">//创建一个 Buffer，大小为 5，即可以存放 5 个 int</span>        IntBuffer intBuffer = IntBuffer.allocate(<span class="hljs-number">5</span>);        <span class="hljs-comment">//向buffer存放数据</span>        <span class="hljs-comment">//intBuffer.put(10);</span>        <span class="hljs-comment">//intBuffer.put(11);</span>        <span class="hljs-comment">//intBuffer.put(12);</span>        <span class="hljs-comment">//intBuffer.put(13);</span>        <span class="hljs-comment">//intBuffer.put(14);</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;            intBuffer.put(i * <span class="hljs-number">2</span>);        &#125;        <span class="hljs-comment">//如何从 buffer 读取数据</span>        <span class="hljs-comment">//将 buffer 转换，读写切换(!!!)</span>        intBuffer.flip();        <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;            System.out.println(intBuffer.get());        &#125;    &#125;&#125;</code></pre></div><h3 id="3-2-NIO-和-BIO-的比较"><a href="#3-2-NIO-和-BIO-的比较" class="headerlink" title="3.2 NIO 和 BIO 的比较"></a>3.2 NIO 和 BIO 的比较</h3><ol><li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li><li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li><li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li></ol><h3 id="3-3-NIO-三大核心原理示意图"><a href="#3-3-NIO-三大核心原理示意图" class="headerlink" title="3.3 NIO 三大核心原理示意图"></a>3.3 NIO 三大核心原理示意图</h3><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p><h4 id="3-3-1-Selector、Channel-和-Buffer-关系图（简单版）"><a href="#3-3-1-Selector、Channel-和-Buffer-关系图（简单版）" class="headerlink" title="3.3.1 Selector、Channel 和 Buffer 关系图（简单版）"></a>3.3.1 Selector、Channel 和 Buffer 关系图（简单版）</h4><p>关系图的说明:</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_01.png" alt="img"></p><ol><li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li><li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li><li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li><li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li><li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li><li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li><li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li></ol><h3 id="3-4-缓冲区（Buffer）"><a href="#3-4-缓冲区（Buffer）" class="headerlink" title="3.4 缓冲区（Buffer）"></a>3.4 缓冲区（Buffer）</h3><h4 id="3-4-1-基本介绍"><a href="#3-4-1-基本介绍" class="headerlink" title="3.4.1 基本介绍"></a>3.4.1 基本介绍</h4><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_02.png" alt="img"></p><h4 id="3-4-2-Buffer-类及其子类"><a href="#3-4-2-Buffer-类及其子类" class="headerlink" title="3.4.2 Buffer 类及其子类"></a>3.4.2 Buffer 类及其子类</h4><ol><li>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_03.png" alt="img"></p><ol><li><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_05.png" alt="img"></p><ol><li><code>Buffer</code> 类相关方法一览</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_06.png" alt="img"></p><h4 id="3-4-3-ByteBuffer"><a href="#3-4-3-ByteBuffer" class="headerlink" title="3.4.3 ByteBuffer"></a>3.4.3 ByteBuffer</h4><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_07.png" alt="img"></p><h3 id="3-5-通道（Channel）"><a href="#3-5-通道（Channel）" class="headerlink" title="3.5 通道（Channel）"></a>3.5 通道（Channel）</h3><h4 id="3-5-0-基本介绍"><a href="#3-5-0-基本介绍" class="headerlink" title="3.5.0 基本介绍"></a>3.5.0 基本介绍</h4><ol><li><p><code>NIO</code> 的通道类似于流，但有些区别如下：</p><ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li></ul></li><li><p><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</p></li><li><p><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></p></li><li><p>常用的 <code>Channel</code> 类有：<strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong>。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</p></li><li><p><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</p></li><li><p>图示</p></li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_08.png" alt="img"></p><h4 id="3-5-1-FileChannel-类"><a href="#3-5-1-FileChannel-类" class="headerlink" title="3.5.1 FileChannel 类"></a>3.5.1 FileChannel 类</h4><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p><ul><li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li><li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li><li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li><li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li></ul><h4 id="3-5-2-应用实例1-本地文件写数据"><a href="#3-5-2-应用实例1-本地文件写数据" class="headerlink" title="3.5.2 应用实例1 - 本地文件写数据"></a>3.5.2 应用实例1 - 本地文件写数据</h4><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li><li>文件不存在就创建</li><li>代码演示</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        String str = <span class="hljs-string">&quot;hello,尚硅谷&quot;</span>;        <span class="hljs-comment">//创建一个输出流 -&gt; channel</span>        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d:\\file01.txt&quot;</span>);        <span class="hljs-comment">//通过 fileOutputStream 获取对应的 FileChannel</span>        <span class="hljs-comment">//这个 fileChannel 真实类型是 FileChannelImpl</span>        FileChannel fileChannel = fileOutputStream.getChannel();        <span class="hljs-comment">//创建一个缓冲区 ByteBuffer</span>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        <span class="hljs-comment">//将 str 放入 byteBuffer</span>        byteBuffer.put(str.getBytes());        <span class="hljs-comment">//对 byteBuffer 进行 flip</span>        byteBuffer.flip();        <span class="hljs-comment">//将 byteBuffer 数据写入到 fileChannel</span>        fileChannel.write(byteBuffer);        fileOutputStream.close();    &#125;&#125;</code></pre></div><h4 id="3-5-3-应用实例2-本地文件读数据"><a href="#3-5-3-应用实例2-本地文件读数据" class="headerlink" title="3.5.3 应用实例2 - 本地文件读数据"></a>3.5.3 应用实例2 - 本地文件读数据</h4><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li><li>假定文件已经存在</li><li>代码演示</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建文件的输入流</span>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\file01.txt&quot;</span>);        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);                <span class="hljs-comment">//通过 fileInputStream 获取对应的 FileChannel -&gt; 实际类型 FileChannelImpl</span>        FileChannel fileChannel = fileInputStream.getChannel();                <span class="hljs-comment">//创建缓冲区</span>        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="hljs-keyword">int</span>)file.length());                <span class="hljs-comment">//将通道的数据读入到 Buffer</span>        fileChannel.read(byteBuffer);                <span class="hljs-comment">//将 byteBuffer 的字节数据转成 String</span>        System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array()));        fileInputStream.close();    &#125;&#125;</code></pre></div><h4 id="3-5-4-应用实例3-使用一个-Buffer-完成文件读取、写入"><a href="#3-5-4-应用实例3-使用一个-Buffer-完成文件读取、写入" class="headerlink" title="3.5.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入"></a>3.5.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入</h4><p>实例要求：</p><ol><li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li><li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li><li>代码演示</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_09.png" alt="img"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel03</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;1.txt&quot;</span>);        FileChannel fileChannel01 = fileInputStream.getChannel();        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;2.txt&quot;</span>);        FileChannel fileChannel02 = fileOutputStream.getChannel();        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123; <span class="hljs-comment">//循环读取</span>            <span class="hljs-comment">//这里有一个重要的操作，一定不要忘了</span>            <span class="hljs-comment">/*</span><span class="hljs-comment">            public final Buffer clear() &#123;</span><span class="hljs-comment">                position = 0;</span><span class="hljs-comment">                limit = capacity;</span><span class="hljs-comment">                mark = -1;</span><span class="hljs-comment">                return this;</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">            */</span>            byteBuffer.clear(); <span class="hljs-comment">//清空 buffer</span>            <span class="hljs-keyword">int</span> read = fileChannel01.read(byteBuffer);            System.out.println(<span class="hljs-string">&quot;read = &quot;</span> + read);            <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//表示读完</span>                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//将 buffer 中的数据写入到 fileChannel02--2.txt</span>            byteBuffer.flip();            fileChannel02.write(byteBuffer);        &#125;        <span class="hljs-comment">//关闭相关的流</span>        fileInputStream.close();        fileOutputStream.close();    &#125;&#125;</code></pre></div><h4 id="3-5-5-应用实例4-拷贝文件-transferFrom-方法"><a href="#3-5-5-应用实例4-拷贝文件-transferFrom-方法" class="headerlink" title="3.5.5 应用实例4 - 拷贝文件 transferFrom 方法"></a>3.5.5 应用实例4 - 拷贝文件 transferFrom 方法</h4><ol><li>实例要求：</li><li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li><li>拷贝一张图片</li><li>代码演示</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel04</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建相关流</span>        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\a.jpg&quot;</span>);        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d:\\a2.jpg&quot;</span>);                <span class="hljs-comment">//获取各个流对应的 FileChannel</span>        FileChannel sourceCh = fileInputStream.getChannel();        FileChannel destCh = fileOutputStream.getChannel();        <span class="hljs-comment">//使用 transferForm 完成拷贝</span>        destCh.transferFrom(sourceCh, <span class="hljs-number">0</span>, sourceCh.size());        <span class="hljs-comment">//关闭相关通道和流</span>        sourceCh.close();        destCh.close();        fileInputStream.close();        fileOutputStream.close();    &#125;&#125;</code></pre></div><h4 id="3-5-6-关于-Buffer-和-Channel-的注意事项和细节"><a href="#3-5-6-关于-Buffer-和-Channel-的注意事项和细节" class="headerlink" title="3.5.6 关于 Buffer 和 Channel 的注意事项和细节"></a>3.5.6 关于 Buffer 和 Channel 的注意事项和细节</h4><ol><li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOByteBufferPutGet</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                <span class="hljs-comment">//创建一个 Buffer</span>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);        <span class="hljs-comment">//类型化方式放入数据</span>        buffer.putInt(<span class="hljs-number">100</span>);        buffer.putLong(<span class="hljs-number">9</span>);        buffer.putChar(<span class="hljs-string">&#x27;尚&#x27;</span>);        buffer.putShort((<span class="hljs-keyword">short</span>) <span class="hljs-number">4</span>);        <span class="hljs-comment">//取出</span>        buffer.flip();                System.out.println();                System.out.println(buffer.getInt());        System.out.println(buffer.getLong());        System.out.println(buffer.getChar());        System.out.println(buffer.getShort());    &#125;&#125;</code></pre></div><ol start="2"><li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadOnlyBuffer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建一个 buffer</span>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;            buffer.put((<span class="hljs-keyword">byte</span>) i);        &#125;        <span class="hljs-comment">//读取</span>        buffer.flip();        <span class="hljs-comment">//得到一个只读的 Buffer</span>        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();        System.out.println(readOnlyBuffer.getClass());        <span class="hljs-comment">//读取</span>        <span class="hljs-keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123;            System.out.println(readOnlyBuffer.get());        &#125;        readOnlyBuffer.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">100</span>); <span class="hljs-comment">//ReadOnlyBufferException</span>    &#125;&#125;</code></pre></div><ol start="3"><li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.io.RandomAccessFile;<span class="hljs-keyword">import</span> java.nio.MappedByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MappedByteBufferTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        RandomAccessFile randomAccessFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);        <span class="hljs-comment">//获取对应的通道</span>        FileChannel channel = randomAccessFile.getChannel();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式</span><span class="hljs-comment">         * 参数 2：0：可以直接修改的起始位置</span><span class="hljs-comment">         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span><span class="hljs-comment">         * 可以直接修改的范围就是 0-5</span><span class="hljs-comment">         * 实际类型 DirectByteBuffer</span><span class="hljs-comment">         */</span>        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);        mappedByteBuffer.put(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;H&#x27;</span>);        mappedByteBuffer.put(<span class="hljs-number">3</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;9&#x27;</span>);        mappedByteBuffer.put(<span class="hljs-number">5</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;Y&#x27;</span>);<span class="hljs-comment">//IndexOutOfBoundsException</span>        randomAccessFile.close();        System.out.println(<span class="hljs-string">&quot;修改成功~~&quot;</span>);    &#125;&#125;</code></pre></div><ol start="4"><li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;<span class="hljs-keyword">import</span> java.net.InetSocketAddress;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]</span><span class="hljs-comment"> * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScatteringAndGatheringTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span>        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7000</span>);        <span class="hljs-comment">//绑定端口到 socket，并启动</span>        serverSocketChannel.socket().bind(inetSocketAddress);        <span class="hljs-comment">//创建 buffer 数组</span>        ByteBuffer[] byteBuffers = <span class="hljs-keyword">new</span> ByteBuffer[<span class="hljs-number">2</span>];        byteBuffers[<span class="hljs-number">0</span>] = ByteBuffer.allocate(<span class="hljs-number">5</span>);        byteBuffers[<span class="hljs-number">1</span>] = ByteBuffer.allocate(<span class="hljs-number">3</span>);        <span class="hljs-comment">//等客户端连接 (telnet)</span>        SocketChannel socketChannel = serverSocketChannel.accept();        <span class="hljs-keyword">int</span> messageLength = <span class="hljs-number">8</span>; <span class="hljs-comment">//假定从客户端接收 8 个字节</span>        <span class="hljs-comment">//循环的读取</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">int</span> byteRead = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (byteRead &lt; messageLength) &#123;                <span class="hljs-keyword">long</span> l = socketChannel.read(byteBuffers);                byteRead += l; <span class="hljs-comment">//累计读取的字节数</span>                System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead);                <span class="hljs-comment">//使用流打印,看看当前的这个 buffer 的 position 和 limit</span>                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="hljs-string">&quot;position = &quot;</span> + buffer.position() + <span class="hljs-string">&quot;, limit = &quot;</span> + buffer.limit()).forEach(System.out::println);            &#125;            <span class="hljs-comment">//将所有的 buffer 进行 flip</span>            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());            <span class="hljs-comment">//将数据读出显示到客户端</span>            <span class="hljs-keyword">long</span> byteWirte = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (byteWirte &lt; messageLength) &#123;                <span class="hljs-keyword">long</span> l = socketChannel.write(byteBuffers);<span class="hljs-comment">//</span>                byteWirte += l;            &#125;                        <span class="hljs-comment">//将所有的buffer进行clear</span>            Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123;                buffer.clear();            &#125;);                        System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead + <span class="hljs-string">&quot;, byteWrite = &quot;</span> + byteWirte + <span class="hljs-string">&quot;, messagelength = &quot;</span> + messageLength);        &#125;    &#125;&#125;</code></pre></div><h3 id="3-6-Selector（选择器）"><a href="#3-6-Selector（选择器）" class="headerlink" title="3.6 Selector（选择器）"></a>3.6 Selector（选择器）</h3><h4 id="3-6-1-基本介绍"><a href="#3-6-1-基本介绍" class="headerlink" title="3.6.1 基本介绍"></a>3.6.1 基本介绍</h4><ol><li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li><li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</li><li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li><li>避免了多线程之间的上下文切换导致的开销。</li></ol><h4 id="3-6-2-Selector-示意图和特点说明"><a href="#3-6-2-Selector-示意图和特点说明" class="headerlink" title="3.6.2 Selector 示意图和特点说明"></a>3.6.2 Selector 示意图和特点说明</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_10.png" alt="img"></p><p>说明如下：</p><ol><li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li><li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li><li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li><li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li><li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li></ol><h4 id="3-6-3-Selector-类相关方法"><a href="#3-6-3-Selector-类相关方法" class="headerlink" title="3.6.3 Selector 类相关方法"></a>3.6.3 Selector 类相关方法</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_11.png" alt="img"></p><h4 id="3-6-4-注意事项"><a href="#3-6-4-注意事项" class="headerlink" title="3.6.4 注意事项"></a>3.6.4 注意事项</h4><ol><li><p><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</p></li><li><p><code>Selector</code> 相关方法说明</p><ul><li><code>selector.select();</code> //阻塞</li><li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li><li><code>selector.wakeup();</code> //唤醒 selector</li><li><code>selector.selectNow();</code> //不阻塞，立马返还</li></ul></li></ol><h3 id="3-7-NIO-非阻塞网络编程原理分析图"><a href="#3-7-NIO-非阻塞网络编程原理分析图" class="headerlink" title="3.7 NIO 非阻塞网络编程原理分析图"></a>3.7 NIO 非阻塞网络编程原理分析图</h3><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_22.png" alt="img"></p><p>对上图的说明：</p><ol><li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li><li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li><li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li><li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li><li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li><li>可以通过得到的 <code>channel</code>，完成业务处理。</li><li>代码撑腰。。。</li></ol><h3 id="3-8-NIO-非阻塞网络编程快速入门"><a href="#3-8-NIO-非阻塞网络编程快速入门" class="headerlink" title="3.8 NIO 非阻塞网络编程快速入门"></a>3.8 NIO 非阻塞网络编程快速入门</h3><p>案例要求：</p><ol><li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li><li>看老师代码演示</li></ol><h3 id="3-9-SelectionKey"><a href="#3-9-SelectionKey" class="headerlink" title="3.9 SelectionKey"></a>3.9 SelectionKey</h3><ol><li><code>SelectionKey</code>，表示 <code>Selector</code> 和网络通道的注册关系，共四种：<ul><li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li><li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li><li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li><li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li></ul></li></ol><p>源码中：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_READ = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_WRITE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_CONNECT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_ACCEPT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;</code></pre></div><ol start="2"><li><code>SelectionKey</code> 相关方法</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_12.png" alt="img"></p><h3 id="3-10-ServerSocketChannel"><a href="#3-10-ServerSocketChannel" class="headerlink" title="3.10 ServerSocketChannel"></a>3.10 ServerSocketChannel</h3><ol><li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接</li><li>相关方法如下</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_13.png" alt="img"></p><h3 id="3-11-SocketChannel"><a href="#3-11-SocketChannel" class="headerlink" title="3.11 SocketChannel"></a>3.11 SocketChannel</h3><ol><li><code>SocketChannel</code>，网络 <code>IO</code> 通道，具体负责进行读写操作。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li><li>相关方法如下</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_14.png" alt="img"></p><h3 id="3-12-NIO-网络编程应用实例-群聊系统"><a href="#3-12-NIO-网络编程应用实例-群聊系统" class="headerlink" title="3.12 NIO 网络编程应用实例 - 群聊系统"></a>3.12 NIO 网络编程应用实例 - 群聊系统</h3><p>实例要求：</p><ol><li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li><li>示意图分析和代码</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_15.png" alt="img"></p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 服务端：</span><span class="hljs-keyword">package</span> com.atguigu.nio.groupchat;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.net.InetSocketAddress;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.Channel;<span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<span class="hljs-keyword">import</span> java.nio.channels.Selector;<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<span class="hljs-keyword">import</span> java.util.Iterator;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>&#123;    <span class="hljs-comment">//定义属性</span>    <span class="hljs-keyword">private</span> Selector selector;    <span class="hljs-keyword">private</span> ServerSocketChannel listenChannel;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;    <span class="hljs-comment">//构造器</span>    <span class="hljs-comment">//初始化工作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//得到选择器</span>            selector = Selector.open();            <span class="hljs-comment">//ServerSocketChannel</span>            listenChannel = ServerSocketChannel.open();            <span class="hljs-comment">//绑定端口</span>            listenChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(PORT));            <span class="hljs-comment">//设置非阻塞模式</span>            listenChannel.configureBlocking(<span class="hljs-keyword">false</span>);            <span class="hljs-comment">//将该 listenChannel 注册到 selector</span>            listenChannel.register(selector, SelectionKey.OP_ACCEPT);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//循环处理</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">int</span> count = selector.select();                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//有事件处理</span>                    <span class="hljs-comment">// 遍历得到 selectionKey 集合</span>                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                        <span class="hljs-comment">//取出 selectionkey</span>                        SelectionKey key = iterator.next();                        <span class="hljs-comment">//监听到 accept</span>                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;                            SocketChannel sc = listenChannel.accept();                            sc.configureBlocking(<span class="hljs-keyword">false</span>);                            <span class="hljs-comment">//将该 sc 注册到 seletor</span>                            sc.register(selector, SelectionKey.OP_READ);                            <span class="hljs-comment">//提示</span>                            System.out.println(sc.getRemoteAddress() + <span class="hljs-string">&quot; 上线 &quot;</span>);                        &#125;                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<span class="hljs-comment">//通道发送read事件，即通道是可读的状态</span>                            <span class="hljs-comment">// 处理读(专门写方法..)</span>                            readData(key);                        &#125;                        <span class="hljs-comment">//当前的 key 删除，防止重复处理</span>                        iterator.remove();                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    System.out.println(<span class="hljs-string">&quot;等待....&quot;</span>);                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//发生异常处理....</span>        &#125;    &#125;    <span class="hljs-comment">//读取客户端消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readData</span><span class="hljs-params">(SelectionKey key)</span> </span>&#123;        SocketChannel channel = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//得到 channel</span>            channel = (SocketChannel) key.channel();            <span class="hljs-comment">//创建 buffer</span>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);            <span class="hljs-keyword">int</span> count = channel.read(buffer);            <span class="hljs-comment">//根据 count 的值做处理</span>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//把缓存区的数据转成字符串</span>                String msg = <span class="hljs-keyword">new</span> String(buffer.array());                <span class="hljs-comment">//输出该消息</span>                System.out.println(<span class="hljs-string">&quot;form客户端:&quot;</span> + msg);                <span class="hljs-comment">//向其它的客户端转发消息(去掉自己),专门写一个方法来处理</span>                sendInfoToOtherClients(msg, channel);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-keyword">try</span> &#123;                System.out.println(channel.getRemoteAddress() + <span class="hljs-string">&quot;离线了..&quot;</span>);                <span class="hljs-comment">//取消注册</span>                key.cancel();                <span class="hljs-comment">//关闭通道</span>                channel.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e2) &#123;                e2.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-comment">//转发消息给其它客户(通道)</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfoToOtherClients</span><span class="hljs-params">(String msg, SocketChannel self)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        System.out.println(<span class="hljs-string">&quot;服务器转发消息中...&quot;</span>);        <span class="hljs-comment">//遍历所有注册到 selector 上的 SocketChannel,并排除 self</span>        <span class="hljs-keyword">for</span> (SelectionKey key : selector.keys()) &#123;            <span class="hljs-comment">//通过 key 取出对应的 SocketChannel</span>            Channel targetChannel = key.channel();            <span class="hljs-comment">//排除自己</span>            <span class="hljs-keyword">if</span> (targetChannel <span class="hljs-keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;                <span class="hljs-comment">//转型</span>                SocketChannel dest = (SocketChannel) targetChannel;                <span class="hljs-comment">//将 msg 存储到 buffer</span>                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());                <span class="hljs-comment">//将 buffer 的数据写入通道</span>                dest.write(buffer);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建服务器对象</span>        GroupChatServer groupChatServer = <span class="hljs-keyword">new</span> GroupChatServer();        groupChatServer.listen();    &#125;&#125;<span class="hljs-comment">// 客户端：</span><span class="hljs-keyword">package</span> com.atguigu.nio.groupchat;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.net.InetSocketAddress;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;<span class="hljs-keyword">import</span> java.nio.channels.Selector;<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<span class="hljs-keyword">import</span> java.util.Iterator;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>&#123;    <span class="hljs-comment">//定义相关的属性</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<span class="hljs-comment">//服务器的ip</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;<span class="hljs-comment">//服务器端口</span>    <span class="hljs-keyword">private</span> Selector selector;    <span class="hljs-keyword">private</span> SocketChannel socketChannel;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-comment">//构造器,完成初始化工作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                selector = Selector.open();        <span class="hljs-comment">//连接服务器</span>        socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(HOST, PORT));        <span class="hljs-comment">//设置非阻塞</span>        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//将 channel 注册到selector</span>        socketChannel.register(selector, SelectionKey.OP_READ);        <span class="hljs-comment">//得到 username</span>        username = socketChannel.getLocalAddress().toString().substring(<span class="hljs-number">1</span>);        System.out.println(username + <span class="hljs-string">&quot; is ok...&quot;</span>);    &#125;    <span class="hljs-comment">//向服务器发送消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfo</span><span class="hljs-params">(String info)</span> </span>&#123;        info = username + <span class="hljs-string">&quot; 说：&quot;</span> + info;        <span class="hljs-keyword">try</span> &#123;            socketChannel.write(ByteBuffer.wrap(info.getBytes()));        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">//读取从服务器端回复的消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">int</span> readChannels = selector.select();            <span class="hljs-keyword">if</span> (readChannels &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有可以用的通道</span>                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;                    SelectionKey key = iterator.next();                    <span class="hljs-keyword">if</span> (key.isReadable()) &#123;                        <span class="hljs-comment">//得到相关的通道</span>                        SocketChannel sc = (SocketChannel) key.channel();                        <span class="hljs-comment">//得到一个 Buffer</span>                        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);                        <span class="hljs-comment">//读取</span>                        sc.read(buffer);                        <span class="hljs-comment">//把读到的缓冲区的数据转成字符串</span>                        String msg = <span class="hljs-keyword">new</span> String(buffer.array());                        System.out.println(msg.trim());                    &#125;                &#125;                iterator.remove(); <span class="hljs-comment">//删除当前的 selectionKey,防止重复操作</span>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span>            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//启动我们客户端</span>        GroupChatClient chatClient = <span class="hljs-keyword">new</span> GroupChatClient();        <span class="hljs-comment">//启动一个线程,每个 3 秒，读取从服务器发送数据</span>        <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    chatClient.readInfo();                    <span class="hljs-keyword">try</span> &#123;                        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;.start();        <span class="hljs-comment">//发送数据给服务器端</span>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;            String s = scanner.nextLine();            chatClient.sendInfo(s);        &#125;    &#125;&#125;</code></pre></div><h3 id="3-13-NIO-与零拷贝"><a href="#3-13-NIO-与零拷贝" class="headerlink" title="3.13 NIO 与零拷贝"></a>3.13 NIO 与零拷贝</h3><h4 id="3-13-1-零拷贝基本介绍"><a href="#3-13-1-零拷贝基本介绍" class="headerlink" title="3.13.1 零拷贝基本介绍"></a>3.13.1 零拷贝基本介绍</h4><ol><li>零拷贝是网络编程的关键，很多性能优化都离不开。</li><li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li><li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li></ol><h4 id="3-13-2-传统-IO-数据读写"><a href="#3-13-2-传统-IO-数据读写" class="headerlink" title="3.13.2 传统 IO 数据读写"></a>3.13.2 传统 IO 数据读写</h4><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p><div class="code-wrapper"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(file, <span class="hljs-string">&quot;rw&quot;</span>);<span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) file.length()];raf.read(arr);Socket socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>).accept();socket.getOutputStream().write(arr);</code></pre></div><h4 id="3-13-3-传统-IO-模型"><a href="#3-13-3-传统-IO-模型" class="headerlink" title="3.13.3 传统 IO 模型"></a>3.13.3 传统 IO 模型</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_17.png" alt="img"></p><p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p><h4 id="3-13-4-mmap-优化"><a href="#3-13-4-mmap-优化" class="headerlink" title="3.13.4 mmap 优化"></a>3.13.4 mmap 优化</h4><ol><li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li><li><code>mmap</code> 示意图</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_18.png" alt="img"></p><h4 id="3-13-5-sendFile-优化"><a href="#3-13-5-sendFile-优化" class="headerlink" title="3.13.5 sendFile 优化"></a>3.13.5 sendFile 优化</h4><ol><li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li><li>示意图和小结</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_19.png" alt="img"></p><ol start="3"><li><p>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</p></li><li><p><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</p></li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_20.png" alt="img"></p><ol start="5"><li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li></ol><h4 id="3-13-6-零拷贝的再次理解"><a href="#3-13-6-零拷贝的再次理解" class="headerlink" title="3.13.6 零拷贝的再次理解"></a>3.13.6 零拷贝的再次理解</h4><ol><li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li><li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li></ol><h4 id="3-13-7-mmap-和-sendFile-的区别"><a href="#3-13-7-mmap-和-sendFile-的区别" class="headerlink" title="3.13.7 mmap 和 sendFile 的区别"></a>3.13.7 mmap 和 sendFile 的区别</h4><ol><li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li><li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li><li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li></ol><h4 id="3-13-8-NIO-零拷贝案例"><a href="#3-13-8-NIO-零拷贝案例" class="headerlink" title="3.13.8 NIO 零拷贝案例"></a>3.13.8 NIO 零拷贝案例</h4><p>案例要求：</p><ol><li>使用传统的 <code>IO</code> 方法传递一个大文件</li><li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li><li>看看两种传递方式耗时时间分别是多少</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio.zerocopy;<span class="hljs-keyword">import</span> java.net.InetSocketAddress;<span class="hljs-keyword">import</span> java.net.ServerSocket;<span class="hljs-keyword">import</span> java.nio.ByteBuffer;<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<span class="hljs-comment">//服务器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7001</span>);        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        ServerSocket serverSocket = serverSocketChannel.socket();        serverSocket.bind(address);        <span class="hljs-comment">//创建buffer</span>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">4096</span>);        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            SocketChannel socketChannel = serverSocketChannel.accept();            <span class="hljs-keyword">int</span> readcount = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (-<span class="hljs-number">1</span> != readcount) &#123;                <span class="hljs-keyword">try</span> &#123;                    readcount = socketChannel.read(byteBuffer);                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;                    <span class="hljs-comment">// ex.printStackTrace();</span>                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">//</span>                byteBuffer.rewind(); <span class="hljs-comment">//倒带 position = 0 mark 作废</span>            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.nio.zerocopy;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.net.InetSocketAddress;<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOClient</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SocketChannel socketChannel = SocketChannel.open();        socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">7001</span>));        String filename = <span class="hljs-string">&quot;protoc-3.6.1-win32.zip&quot;</span>;        <span class="hljs-comment">//得到一个文件channel</span>        FileChannel fileChannel = <span class="hljs-keyword">new</span> FileInputStream(filename).getChannel();        <span class="hljs-comment">//准备发送</span>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();        <span class="hljs-comment">//在 linux 下一个 transferTo 方法就可以完成传输</span>        <span class="hljs-comment">//在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要</span>        <span class="hljs-comment">//传输时的位置=》课后思考...</span>        <span class="hljs-comment">//transferTo 底层使用到零拷贝</span>        <span class="hljs-keyword">long</span> transferCount = fileChannel.transferTo(<span class="hljs-number">0</span>, fileChannel.size(), socketChannel);        System.out.println(<span class="hljs-string">&quot;发送的总的字节数 = &quot;</span> + transferCount + <span class="hljs-string">&quot; 耗时: &quot;</span> + (System.currentTimeMillis() - startTime));        <span class="hljs-comment">//关闭</span>        fileChannel.close();    &#125;&#125;</code></pre></div><h3 id="3-14-Java-AIO-基本介绍"><a href="#3-14-Java-AIO-基本介绍" class="headerlink" title="3.14 Java AIO 基本介绍"></a>3.14 Java AIO 基本介绍</h3><ol><li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li><li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li><li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li></ol><h3 id="3-15-BIO、NIO、AIO-对比表"><a href="#3-15-BIO、NIO、AIO-对比表" class="headerlink" title="3.15 BIO、NIO、AIO 对比表"></a>3.15 BIO、NIO、AIO 对比表</h3><table><thead><tr><th></th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>IO模型</td><td>同步阻塞</td><td>同步非阻塞（多路复用）</td><td>异步非阻塞</td></tr><tr><td>编程难度</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>可靠性</td><td>差</td><td>好</td><td>好</td></tr><tr><td>吞吐量</td><td>低</td><td>高</td><td>高</td></tr></tbody></table><p><strong>举例说明</strong></p><ol><li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li><li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li><li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li></ol><h2 id="4-Netty-概述"><a href="#4-Netty-概述" class="headerlink" title="4 Netty 概述"></a>4 Netty 概述</h2><h3 id="4-1-原生-NIO-存在的问题"><a href="#4-1-原生-NIO-存在的问题" class="headerlink" title="4.1 原生 NIO 存在的问题"></a>4.1 原生 NIO 存在的问题</h3><ol><li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li><li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li><li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。4. <code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决。</li></ol><h3 id="4-2-Netty-官网说明"><a href="#4-2-Netty-官网说明" class="headerlink" title="4.2 Netty 官网说明"></a>4.2 Netty 官网说明</h3><p>官网：<a href="https://netty.io/">https://netty.io/</a></p><p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter04_01.png" alt="img"></p><h3 id="4-3-Netty-的优点"><a href="#4-3-Netty-的优点" class="headerlink" title="4.3 Netty 的优点"></a>4.3 Netty 的优点</h3><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p><ol><li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li><li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li><li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li><li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li><li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li></ol><h3 id="4-4-Netty-版本说明"><a href="#4-4-Netty-版本说明" class="headerlink" title="4.4 Netty 版本说明"></a>4.4 Netty 版本说明</h3><ol><li><p><code>Netty</code> 版本分为 <code>Netty 3.x</code> 和 <code>Netty 4.x</code>、<code>Netty 5.x</code></p></li><li><p>因为 <code>Netty 5</code> 出现重大 <code>bug</code>，已经被官网废弃了，目前推荐使用的是 <code>Netty 4.x</code>的稳定版本</p></li><li><p>目前在官网可下载的版本 <code>Netty 3.x</code>、<code>Netty 4.0.x</code> 和 <code>Netty 4.1.x</code></p></li><li><p>在本套课程中，我们讲解 <code>Netty4.1.x</code> 版本</p></li><li><p><code>Netty</code> 下载地址：<a href="https://bintray.com/netty/downloads/netty/">https://bintray.com/netty/downloads/netty/</a></p></li><li><p>maven</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.netty/netty-all --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.42.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li></ol><h2 id="5-Netty-高性能架构设计"><a href="#5-Netty-高性能架构设计" class="headerlink" title="5  Netty 高性能架构设计"></a>5  Netty 高性能架构设计</h2><h3 id="5-1-线程模型基本介绍"><a href="#5-1-线程模型基本介绍" class="headerlink" title="5.1 线程模型基本介绍"></a>5.1 线程模型基本介绍</h3><ol><li>不同的线程模式，对程序的性能有很大影响，为了搞清 <code>Netty</code> 线程模式，我们来系统的讲解下各个线程模式，最后看看 <code>Netty</code> 线程模型有什么优越性。</li><li>目前存在的线程模型有：传统阻塞 <code>I/O</code> 服务模型 <code>Reactor</code> 模式</li><li>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现单 <code>Reactor</code> 单线程；单 <code>Reactor</code>多线程；主从 <code>Reactor</code>多线程</li><li><code>Netty</code> 线程模式（<code>Netty</code> 主要基于主从 <code>Reactor</code> 多线程模型做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>）</li></ol><h3 id="5-2-传统阻塞-I-O-服务模型"><a href="#5-2-传统阻塞-I-O-服务模型" class="headerlink" title="5.2 传统阻塞 I/O 服务模型"></a>5.2 传统阻塞 I/O 服务模型</h3><h4 id="5-2-1-工作原理图"><a href="#5-2-1-工作原理图" class="headerlink" title="5.2.1 工作原理图"></a>5.2.1 工作原理图</h4><ol><li>黄色的框表示对象，蓝色的框表示线程</li><li>白色的框表示方法（<code>API</code>）</li></ol><h4 id="5-2-2-模型特点"><a href="#5-2-2-模型特点" class="headerlink" title="5.2.2 模型特点"></a>5.2.2 模型特点</h4><ol><li>采用阻塞 <code>IO</code> 模式获取输入的数据</li><li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li></ol><h4 id="5-2-3-问题分析"><a href="#5-2-3-问题分析" class="headerlink" title="5.2.3 问题分析"></a>5.2.3 问题分析</h4><ol><li>当并发数很大，就会创建大量的线程，占用很大系统资源</li><li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 <code>read</code> 操作，造成线程资源浪费</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_01.png" alt="img"></p><h3 id="5-3-Reactor-模式"><a href="#5-3-Reactor-模式" class="headerlink" title="5.3 Reactor 模式"></a>5.3 Reactor 模式</h3><h4 id="5-3-1-针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案："><a href="#5-3-1-针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案：" class="headerlink" title="5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案："></a>5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</h4><ol><li>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理 <code>Reactor</code> 对应的叫法：<ol><li>反应器模式</li><li>分发者模式（Dispatcher）</li><li>通知者模式（notifier）</li></ol></li><li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_02.png" alt="img"></p><h4 id="5-3-2-I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图"><a href="#5-3-2-I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图" class="headerlink" title="5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图"></a>5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</h4><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_03.png" alt="img"></p><p>对上图说明：</p><ol><li><code>Reactor</code> 模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li><li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 <code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式</li><li><code>Reactor</code> 模式使用 <code>IO</code> 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li></ol><h4 id="5-3-3-Reactor-模式中核心组成"><a href="#5-3-3-Reactor-模式中核心组成" class="headerlink" title="5.3.3 Reactor 模式中核心组成"></a>5.3.3 Reactor 模式中核心组成</h4><ol><li><code>Reactor</code>：<code>Reactor</code> 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 <code>IO</code> 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li><li><code>Handlers</code>：处理程序执行 <code>I/O</code> 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code> 通过调度适当的处理程序来响应 <code>I/O</code> 事件，处理程序执行非阻塞操作。</li></ol><h4 id="5-3-4-Reactor-模式分类"><a href="#5-3-4-Reactor-模式分类" class="headerlink" title="5.3.4 Reactor 模式分类"></a>5.3.4 Reactor 模式分类</h4><p>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现</p><ol><li>单 <code>Reactor</code> 单线程</li><li>单 <code>Reactor</code> 多线程</li><li>主从 <code>Reactor</code> 多线程</li></ol><h3 id="5-4-单-Reactor-单线程"><a href="#5-4-单-Reactor-单线程" class="headerlink" title="5.4 单 Reactor 单线程"></a>5.4 单 Reactor 单线程</h3><p>原理图，并使用 <code>NIO</code> 群聊系统验证</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_04.png" alt="img"></p><h4 id="5-4-1-方案说明"><a href="#5-4-1-方案说明" class="headerlink" title="5.4.1 方案说明"></a>5.4.1 方案说明</h4><ol><li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 <code>API</code>，可以实现应用程序通过一个阻塞对象监听多路连接请求</li><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li><li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li><li><code>Handler</code> 会完成 <code>Read</code> → 业务处理 → <code>Send</code> 的完整业务流程</li></ol><p>结合实例：服务器端用一个线程通过多路复用搞定所有的 <code>IO</code> 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 <code>NIO</code> 案例就属于这种模型。</p><h4 id="5-4-2-方案优缺点分析"><a href="#5-4-2-方案优缺点分析" class="headerlink" title="5.4.2 方案优缺点分析"></a>5.4.2 方案优缺点分析</h4><ol><li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li><li>缺点：性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li><li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li><li>使用场景：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code> 在业务处理的时间复杂度 <code>O(1)</code> 的情况</li></ol><h3 id="5-5-单-Reactor-多线程"><a href="#5-5-单-Reactor-多线程" class="headerlink" title="5.5 单 Reactor 多线程"></a>5.5 单 Reactor 多线程</h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_05.png" alt="img"></p><h4 id="5-5-1-原理图"><a href="#5-5-1-原理图" class="headerlink" title="5.5.1 原理图"></a>5.5.1 原理图</h4><h4 id="5-5-2-对上图的小结"><a href="#5-5-2-对上图的小结" class="headerlink" title="5.5.2 对上图的小结"></a>5.5.2 对上图的小结</h4><ol><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后，通过 <code>Dispatch</code> 进行分发</li><li>如果建立连接请求，则右 <code>Acceptor</code> 通过 <code>accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理</li><li><code>handler</code> 只负责响应事件，不做具体的业务处理，通过 <code>read</code> 读取数据后，会分发给后面的 <code>worker</code> 线程池的某个线程处理业务</li><li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给 <code>handler</code></li><li><code>handler</code> 收到响应后，通过 <code>send</code> 将结果返回给 <code>client</code></li></ol><h4 id="5-5-3-方案优缺点分析"><a href="#5-5-3-方案优缺点分析" class="headerlink" title="5.5.3 方案优缺点分析"></a>5.5.3 方案优缺点分析</h4><ol><li>优点：可以充分的利用多核 <code>cpu</code> 的处理能力</li><li>缺点：多线程数据共享和访问比较复杂，<code>Reactor</code> 处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</li></ol><h3 id="5-6-主从-Reactor-多线程"><a href="#5-6-主从-Reactor-多线程" class="headerlink" title="5.6 主从 Reactor 多线程"></a>5.6 主从 Reactor 多线程</h3><h4 id="5-6-1-工作原理图"><a href="#5-6-1-工作原理图" class="headerlink" title="5.6.1 工作原理图"></a>5.6.1 工作原理图</h4><p>针对单 <code>Reactor</code> 多线程模型中，<code>Reactor</code> 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 <code>Reactor</code> 在多线程中运行</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_06.png" alt="img"></p><h4 id="5-6-2-上图的方案说明"><a href="#5-6-2-上图的方案说明" class="headerlink" title="5.6.2 上图的方案说明"></a>5.6.2 上图的方案说明</h4><ol><li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件</li><li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code></li><li><code>subreactor</code> 将连接加入到连接队列进行监听，并创建 <code>handler</code> 进行各种事件处理</li><li>当有新事件发生时，<code>subreactor</code> 就会调用对应的 <code>handler</code> 处理</li><li><code>handler</code> 通过 <code>read</code> 读取数据，分发给后面的 <code>worker</code> 线程处理</li><li><code>worker</code> 线程池分配独立的 <code>worker</code> 线程进行业务处理，并返回结果</li><li><code>handler</code> 收到响应的结果后，再通过 <code>send</code> 将结果返回给 <code>client</code></li><li><code>Reactor</code> 主线程可以对应多个 <code>Reactor</code> 子线程，即 <code>MainRecator</code> 可以关联多个 <code>SubReactor</code></li></ol><h4 id="5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解："><a href="#5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解：" class="headerlink" title="5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解："></a>5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解：</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_07.png" alt="img"></p><h4 id="5-6-4-方案优缺点说明"><a href="#5-6-4-方案优缺点说明" class="headerlink" title="5.6.4 方案优缺点说明"></a>5.6.4 方案优缺点说明</h4><ol><li>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li><li>优点：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据。</li><li>缺点：编程复杂度较高</li><li>结合实例：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li></ol><h3 id="5-7-Reactor-模式小结"><a href="#5-7-Reactor-模式小结" class="headerlink" title="5.7 Reactor 模式小结"></a>5.7 Reactor 模式小结</h3><h4 id="5-7-1-3-种模式用生活案例来理解"><a href="#5-7-1-3-种模式用生活案例来理解" class="headerlink" title="5.7.1 3 种模式用生活案例来理解"></a>5.7.1 3 种模式用生活案例来理解</h4><ol><li>单 <code>Reactor</code> 单线程，前台接待员和服务员是同一个人，全程为顾客服务</li><li>单 <code>Reactor</code> 多线程，<code>1</code> 个前台接待员，多个服务员，接待员只负责接待</li><li>主从 <code>Reactor</code> 多线程，多个前台接待员，多个服务生</li></ol><h4 id="5-7-2-Reactor-模式具有如下的优点"><a href="#5-7-2-Reactor-模式具有如下的优点" class="headerlink" title="5.7.2 Reactor 模式具有如下的优点"></a>5.7.2 Reactor 模式具有如下的优点</h4><ol><li>响应快，不必为单个同步时间所阻塞，虽然 <code>Reactor</code> 本身依然是同步的</li><li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li><li>扩展性好，可以方便的通过增加 <code>Reactor</code> 实例个数来充分利用 <code>CPU</code> 资源</li><li>复用性好，<code>Reactor</code> 模型本身与具体事件处理逻辑无关，具有很高的复用性</li></ol><h3 id="5-8-Netty-模型"><a href="#5-8-Netty-模型" class="headerlink" title="5.8 Netty 模型"></a>5.8 Netty 模型</h3><h4 id="5-8-1-工作原理示意图-简单版"><a href="#5-8-1-工作原理示意图-简单版" class="headerlink" title="5.8.1 工作原理示意图 - 简单版"></a>5.8.1 工作原理示意图 - 简单版</h4><p>Netty主要基于<code>主从 Reactors</code> 多线程模型（如图）做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 `Reactor</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_08.png" alt="img"></p><h4 id="5-8-2-对上图说明"><a href="#5-8-2-对上图说明" class="headerlink" title="5.8.2 对上图说明"></a>5.8.2 对上图说明</h4><ol><li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code></li><li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护</li><li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 <code>handler</code>），注意 <code>handler</code> 已经加入到通道</li></ol><h4 id="5-8-3-工作原理示意图-进阶版"><a href="#5-8-3-工作原理示意图-进阶版" class="headerlink" title="5.8.3 工作原理示意图 - 进阶版"></a>5.8.3 工作原理示意图 - 进阶版</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_09.png" alt="img"></p><h4 id="5-8-4-工作原理示意图-详细版"><a href="#5-8-4-工作原理示意图-详细版" class="headerlink" title="5.8.4 工作原理示意图 - 详细版"></a>5.8.4 工作原理示意图 - 详细版</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_10.png" alt="img"></p><h4 id="5-8-5-对上图的说明小结"><a href="#5-8-5-对上图的说明小结" class="headerlink" title="5.8.5 对上图的说明小结"></a>5.8.5 对上图的说明小结</h4><ol><li><p><code>Netty</code> 抽象出两组线程池 <code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</p></li><li><p><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code></p></li><li><p><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code></p></li><li><p><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</p></li><li><p><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code></p></li><li><p>每个 循环执行的步骤有 <code>BossNioEventLoop``3</code></p><ul><li>轮询 <code>accept</code> 事件</li><li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>worker</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li><li>处理任务队列的任务，即 <code>runAllTasks</code></li></ul></li><li><p>每个 循环执行的步骤<code>Worker``NIOEventLoo</code></p><ul><li>轮询 <code>read</code>，<code>write</code> 事件</li><li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li><li>处理任务队列的任务，即 <code>runAllTasks</code></li></ul></li><li><p>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器</p></li></ol><h4 id="5-8-6-Netty-快速入门实例-TCP-服务"><a href="#5-8-6-Netty-快速入门实例-TCP-服务" class="headerlink" title="5.8.6 Netty 快速入门实例 - TCP 服务"></a>5.8.6 Netty 快速入门实例 - TCP 服务</h4><p>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</p><ol><li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，客户端能发送消息给服务器”hello,服务器~”</li><li>服务器可以回复消息给客户端”hello,客户端~”</li><li>目的：对 <code>Netty</code> 线程模型有一个初步认识，便于理解 <code>Netty</code> 模型理论</li><li>看老师代码演示 5.1 编写服务端 5.2 编写客户端 5.3 对 <code>netty</code> 程序进行分析，看看 <code>netty</code> 模型特点 说明：创建 <code>Maven</code> 项目，并引入 <code>Netty</code> 包</li><li>代码如下</li></ol><div class="code-wrapper"><pre><code class="hljs java">NettyServer.java<span class="hljs-keyword">package</span> com.atguigu.netty.simple;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFutureListener;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-comment">//创建BossGroup 和 WorkerGroup</span>        <span class="hljs-comment">//说明</span>        <span class="hljs-comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span>        <span class="hljs-comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span>        <span class="hljs-comment">//3. 两个都是无限循环</span>        <span class="hljs-comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span>        <span class="hljs-comment">//   默认实际 cpu核数 * 2</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8</span>                <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建服务器端的启动对象，配置参数</span>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            <span class="hljs-comment">//使用链式编程来进行设置</span>            bootstrap.group(bossGroup, workerGroup) <span class="hljs-comment">//设置两个线程组</span>                    .channel(NioServerSocketChannel.class) <span class="hljs-comment">//使用NioSocketChannel 作为服务器的通道实现</span>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>) <span class="hljs-comment">// 设置线程队列得到连接个数</span>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>) <span class="hljs-comment">//设置保持活动连接状态</span>            <span class="hljs-comment">//          .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="hljs-comment">//创建一个通道初始化对象(匿名对象)</span>                        <span class="hljs-comment">//给pipeline 设置处理器</span>                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            System.out.println(<span class="hljs-string">&quot;客户socketchannel hashcode=&quot;</span> + ch.hashCode()); <span class="hljs-comment">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());                        &#125;                    &#125;); <span class="hljs-comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span>            System.out.println(<span class="hljs-string">&quot;.....服务器 is ready...&quot;</span>);            <span class="hljs-comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span>            <span class="hljs-comment">//启动服务器(并绑定端口)</span>            ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();            <span class="hljs-comment">//给cf 注册监听器，监控我们关心的事件</span>            cf.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;                        System.out.println(<span class="hljs-string">&quot;监听端口 6668 成功&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> &#123;                        System.out.println(<span class="hljs-string">&quot;监听端口 6668 失败&quot;</span>);                    &#125;                &#125;            &#125;);            <span class="hljs-comment">//对关闭通道进行监听</span>            cf.channel().closeFuture().sync();        &#125;<span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;NettyServerHandler.java<span class="hljs-keyword">package</span> com.atguigu.netty.simple;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.Channel;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 说明</span><span class="hljs-comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span><span class="hljs-comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span><span class="hljs-comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                System.out.println(<span class="hljs-string">&quot;服务器读取线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; channle =&quot;</span> + ctx.channel());        System.out.println(<span class="hljs-string">&quot;server ctx =&quot;</span> + ctx);        System.out.println(<span class="hljs-string">&quot;看看channel 和 pipeline的关系&quot;</span>);        Channel channel = ctx.channel();        ChannelPipeline pipeline = ctx.pipeline(); <span class="hljs-comment">//本质是一个双向链接, 出站入站</span>                <span class="hljs-comment">//将 msg 转成一个 ByteBuf</span>        <span class="hljs-comment">//ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span>        ByteBuf buf = (ByteBuf) msg;        System.out.println(<span class="hljs-string">&quot;客户端发送消息是:&quot;</span> + buf.toString(CharsetUtil.UTF_8));        System.out.println(<span class="hljs-string">&quot;客户端地址:&quot;</span> + channel.remoteAddress());    &#125;    <span class="hljs-comment">//数据读取完毕</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//writeAndFlush 是 write + flush</span>        <span class="hljs-comment">//将数据写入到缓存，并刷新</span>        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));    &#125;        <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.close();    &#125;&#125;NettyClient.java<span class="hljs-keyword">package</span> com.atguigu.netty.simple;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//客户端需要一个事件循环组</span>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-comment">//创建客户端启动对象</span>            <span class="hljs-comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();            <span class="hljs-comment">//设置相关参数</span>            bootstrap.group(group) <span class="hljs-comment">//设置线程组</span>                    .channel(NioSocketChannel.class) <span class="hljs-comment">// 设置客户端通道的实现类(反射)</span>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler()); <span class="hljs-comment">//加入自己的处理器</span>                        &#125;                    &#125;);                        System.out.println(<span class="hljs-string">&quot;客户端 ok..&quot;</span>);            <span class="hljs-comment">//启动客户端去连接服务器端</span>            <span class="hljs-comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6668</span>).sync();            <span class="hljs-comment">//给关闭通道进行监听</span>            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully();        &#125;    &#125;&#125;NettyClientHandler.java<span class="hljs-keyword">package</span> com.atguigu.netty.simple;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;        <span class="hljs-comment">//当通道就绪就会触发该方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;client &quot;</span> + ctx);        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, server: (&gt;^ω^&lt;)喵&quot;</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">//当通道有读取事件时，会触发</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ByteBuf buf = (ByteBuf) msg;        System.out.println(<span class="hljs-string">&quot;服务器回复的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));        System.out.println(<span class="hljs-string">&quot;服务器的地址： &quot;</span> + ctx.channel().remoteAddress());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><h4 id="5-8-7-任务队列中的-Task-有-3-种典型使用场景"><a href="#5-8-7-任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="5.8.7 任务队列中的 Task 有 3 种典型使用场景"></a>5.8.7 任务队列中的 Task 有 3 种典型使用场景</h4><ol><li>用户程序自定义的普通任务【举例说明】</li><li>用户自定义定时任务</li><li>非当前 <code>Reactor</code> 线程调用 <code>Channel</code> 的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的 <code>Channel</code> 引用，然后调用 <code>Write</code> 类方法向该用户推送消息，就会进入到这种场景。最终的 <code>Write</code> 会提交到任务队列中后被异步消费</li><li>代码演示</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.simple;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 说明</span><span class="hljs-comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span><span class="hljs-comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span><span class="hljs-comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的</span>        <span class="hljs-comment">// NIOEventLoop 的 taskQueue中,</span>        <span class="hljs-comment">// 解决方案1 用户程序自定义的普通任务</span>        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;</span>, CharsetUtil.UTF_8));                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());                &#125;            &#125;        &#125;);        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵3&quot;</span>, CharsetUtil.UTF_8));                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());                &#125;            &#125;        &#125;);        <span class="hljs-comment">//解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中</span>        ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵4&quot;</span>, CharsetUtil.UTF_8));                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());                &#125;            &#125;        &#125;, <span class="hljs-number">5</span>, TimeUnit.SECONDS);        System.out.println(<span class="hljs-string">&quot;go on ...&quot;</span>);<span class="hljs-comment">//        System.out.println(&quot;服务器读取线程 &quot; + Thread.currentThread().getName() + &quot; channle =&quot; + ctx.channel());</span><span class="hljs-comment">//        System.out.println(&quot;server ctx =&quot; + ctx);</span><span class="hljs-comment">//        System.out.println(&quot;看看channel 和 pipeline的关系&quot;);</span><span class="hljs-comment">//        Channel channel = ctx.channel();</span><span class="hljs-comment">//        ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站</span><span class="hljs-comment">//        </span><span class="hljs-comment">//        //将 msg 转成一个 ByteBuf</span><span class="hljs-comment">//        //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span><span class="hljs-comment">//        ByteBuf buf = (ByteBuf) msg;</span><span class="hljs-comment">//        System.out.println(&quot;客户端发送消息是:&quot; + buf.toString(CharsetUtil.UTF_8));</span><span class="hljs-comment">//        System.out.println(&quot;客户端地址:&quot; + channel.remoteAddress());</span>    &#125;    <span class="hljs-comment">//数据读取完毕</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//writeAndFlush 是 write + flush</span>        <span class="hljs-comment">//将数据写入到缓存，并刷新</span>        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));    &#125;    <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.close();    &#125;&#125;</code></pre></div><h4 id="5-8-8-方案再说明"><a href="#5-8-8-方案再说明" class="headerlink" title="5.8.8 方案再说明"></a>5.8.8 方案再说明</h4><ol><li><code>Netty</code> 抽象出两组线程池，<code>BossGroup</code> 专门负责接收客户端连接，<code>WorkerGroup</code> 专门负责网络读写操作。</li><li><code>NioEventLoop</code> 表示一个不断循环执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code>网络通道。</li><li><code>NioEventLoop</code> 内部采用串行化设计，从消息的 <strong>读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</strong>，始终由 <code>IO</code> 线程 <code>NioEventLoop</code> 负责<code>NioEventLoopGroup</code>下包含多个 <code>NioEventLoop</code></li></ol><ul><li>每个 <code>NioEventLoop</code> 中包含有一个 <code>Selector</code>，一个 <code>taskQueue</code></li><li>每个 <code>NioEventLoop</code> 的 <code>Selector</code> 上可以注册监听多个 <code>NioChannel</code></li><li>每个 <code>NioChannel</code> 只会绑定在唯一的 <code>NioEventLoop</code> 上</li><li>每个 <code>NioChannel</code> 都绑定有一个自己的 <code>ChannelPipeline</code></li></ul><h3 id="5-9-异步模型"><a href="#5-9-异步模型" class="headerlink" title="5.9 异步模型"></a>5.9 异步模型</h3><h4 id="5-9-1-基本介绍"><a href="#5-9-1-基本介绍" class="headerlink" title="5.9.1 基本介绍"></a>5.9.1 基本介绍</h4><ol><li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li><li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind、Write、Connect</code> 等操作会简单的返回一个 <code>ChannelFuture</code>。</li><li>调用者并不能立刻获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机制获得 <code>IO</code> 操作结果。</li><li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code> 返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code> 去监控方法 <code>fun</code> 的处理过程（即：<code>Future-Listener</code> 机制）</li></ol><h4 id="5-9-2-Future-说明"><a href="#5-9-2-Future-说明" class="headerlink" title="5.9.2 Future 说明"></a>5.9.2 Future 说明</h4><ol><li>表示异步的执行结果,可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</li><li><code>ChannelFuture</code> 是一个接口：<code>public interface ChannelFuture extends Future&lt;Void&gt;</code> 我们可以添加监听器，当监听的事件发生时，就会通知到监听器。案例说明</li></ol><h4 id="5-9-3-工作原理示意图"><a href="#5-9-3-工作原理示意图" class="headerlink" title="5.9.3 工作原理示意图"></a>5.9.3 工作原理示意图</h4><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_11.png" alt="img"></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_12.png" alt="img"></p><p>说明：</p><ol><li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用 <code>future</code> 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。</li><li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。</li></ol><h4 id="5-9-4-Future-Listener-机制"><a href="#5-9-4-Future-Listener-机制" class="headerlink" title="5.9.4 Future-Listener 机制"></a>5.9.4 Future-Listener 机制</h4><ol><li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li><li>常见有如下操作<ul><li>通过 <code>isDone</code> 方法来判断当前操作是否完成；</li><li>通过 <code>isSuccess</code> 方法来判断已完成的当前操作是否成功；</li><li>通过 <code>getCause</code> 方法来获取已完成的当前操作失败的原因；</li><li>通过 <code>isCancelled</code> 方法来判断已完成的当前操作是否被取消；</li><li>通过 <code>addListener</code> 方法来注册监听器，当操作已完成（<code>isDone</code>方法返回完成），将会通知指定的监听器；如果 <code>Future</code> 对象已完成，则通知指定的监听器</li></ul></li></ol><p>举例说明 演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//绑定一个端口并且同步,生成了一个ChannelFuture对象</span><span class="hljs-comment">//启动服务器(并绑定端口)</span>ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();<span class="hljs-comment">//给cf 注册监听器，监控我们关心的事件</span>cf.addListener((ChannelFutureListener) future -&gt; &#123;    <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;        System.out.println(<span class="hljs-string">&quot;监听端口 6668 成功&quot;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        System.out.println(<span class="hljs-string">&quot;监听端口 6668 失败&quot;</span>);    &#125;&#125;);</code></pre></div><h3 id="5-10-快速入门实例-HTTP服务"><a href="#5-10-快速入门实例-HTTP服务" class="headerlink" title="5.10 快速入门实例 - HTTP服务"></a>5.10 快速入门实例 - HTTP服务</h3><ol><li>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</li><li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，浏览器发出请求 <code>http://localhost:6668/</code></li><li>服务器可以回复消息给客户端”Hello!我是服务器5”,并对特定请求资源进行过滤。</li><li>目的：<code>Netty</code> 可以做 <code>Http</code> 服务开发，并且理解 <code>Handler</code> 实例和客户端及其请求的关系。</li><li>看老师代码演示</li></ol><div class="code-wrapper"><pre><code class="hljs java">TestServer.java<span class="hljs-keyword">package</span> com.atguigu.netty.http;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServer</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="hljs-keyword">new</span> TestServerInitializer());            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">6668</span>).sync();            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;TestServerInitializer.java<span class="hljs-keyword">package</span> com.atguigu.netty.http;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//向管道加入处理器</span>        <span class="hljs-comment">//得到管道</span>        ChannelPipeline pipeline = ch.pipeline();        <span class="hljs-comment">//加入一个netty 提供的httpServerCodec codec =&gt;[coder - decoder]</span>        <span class="hljs-comment">//HttpServerCodec 说明</span>        <span class="hljs-comment">//1. HttpServerCodec 是netty 提供的处理http的 编-解码器</span>        pipeline.addLast(<span class="hljs-string">&quot;MyHttpServerCodec&quot;</span>, <span class="hljs-keyword">new</span> HttpServerCodec());        <span class="hljs-comment">//2. 增加一个自定义的handler</span>        pipeline.addLast(<span class="hljs-string">&quot;MyTestHttpServerHandler&quot;</span>, <span class="hljs-keyword">new</span> TestHttpServerHandler());        System.out.println(<span class="hljs-string">&quot;ok~~~~&quot;</span>);    &#125;&#125;TestHttpServerHandler.java<span class="hljs-keyword">package</span> com.atguigu.netty.http;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.*;<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<span class="hljs-keyword">import</span> java.net.URI;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 说明</span><span class="hljs-comment"> * 1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter</span><span class="hljs-comment"> * 2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHttpServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">HttpObject</span>&gt; </span>&#123;    <span class="hljs-comment">//channelRead0 读取客户端数据</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;对应的channel=&quot;</span> + ctx.channel() + <span class="hljs-string">&quot; pipeline=&quot;</span> + ctx                .pipeline() + <span class="hljs-string">&quot; 通过pipeline获取channel&quot;</span> + ctx.pipeline().channel());        System.out.println(<span class="hljs-string">&quot;当前ctx的handler=&quot;</span> + ctx.handler());        <span class="hljs-comment">//判断 msg 是不是 httprequest请求</span>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> HttpRequest) &#123;            System.out.println(<span class="hljs-string">&quot;ctx 类型=&quot;</span> + ctx.getClass());            System.out.println(<span class="hljs-string">&quot;pipeline hashcode&quot;</span> + ctx.pipeline().hashCode() + <span class="hljs-string">&quot; TestHttpServerHandler hash=&quot;</span> + <span class="hljs-keyword">this</span>.hashCode());            System.out.println(<span class="hljs-string">&quot;msg 类型=&quot;</span> + msg.getClass());            System.out.println(<span class="hljs-string">&quot;客户端地址&quot;</span> + ctx.channel().remoteAddress());            <span class="hljs-comment">//获取到</span>            HttpRequest httpRequest = (HttpRequest) msg;            <span class="hljs-comment">//获取uri, 过滤指定的资源</span>            URI uri = <span class="hljs-keyword">new</span> URI(httpRequest.uri());            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;                System.out.println(<span class="hljs-string">&quot;请求了 favicon.ico, 不做响应&quot;</span>);                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">//回复信息给浏览器 [http协议]</span>            ByteBuf content = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 我是服务器&quot;</span>, CharsetUtil.UTF_8);            <span class="hljs-comment">//构造一个http的相应，即 httpresponse</span>            FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="hljs-string">&quot;text/plain&quot;</span>);            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());            <span class="hljs-comment">//将构建好 response返回</span>            ctx.writeAndFlush(response);        &#125;    &#125;&#125;</code></pre></div><h2 id="6-Netty-核心模块组件"><a href="#6-Netty-核心模块组件" class="headerlink" title="6 Netty 核心模块组件"></a>6 Netty 核心模块组件</h2><h3 id="6-1-Bootstrap、ServerBootstrap"><a href="#6-1-Bootstrap、ServerBootstrap" class="headerlink" title="6.1 Bootstrap、ServerBootstrap"></a>6.1 Bootstrap、ServerBootstrap</h3><ol><li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li><li>常见的方法有<ul><li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li><li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li><li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li><li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li><li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li><li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li><li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li><li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li></ul></li></ol><h3 id="6-2-Future、ChannelFuture"><a href="#6-2-Future、ChannelFuture" class="headerlink" title="6.2 Future、ChannelFuture"></a>6.2 Future、ChannelFuture</h3><p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p><p>常见的方法有</p><ul><li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li><li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li></ul><h3 id="6-3-Channel"><a href="#6-3-Channel" class="headerlink" title="6.3 Channel"></a>6.3 Channel</h3><ol><li><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</p></li><li><p>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</p></li><li><p>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</p></li><li><p><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</p></li><li><p>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</p></li><li><p>支持关联 <code>I/O</code> 操作与对应的处理程序</p></li><li><p>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code>类型与之对应，常用的<code>Channel</code>类型：</p><ul><li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li><li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li><li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li><li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li><li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li></ul></li></ol><h3 id="6-4-Selector"><a href="#6-4-Selector" class="headerlink" title="6.4 Selector"></a>6.4 Selector</h3><ol><li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li><li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li></ol><h3 id="6-5-ChannelHandler-及其实现类"><a href="#6-5-ChannelHandler-及其实现类" class="headerlink" title="6.5 ChannelHandler 及其实现类"></a>6.5 ChannelHandler 及其实现类</h3><ol><li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li><li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li><li><code>ChannelHandler</code> 及其实现类一览图（后）</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_01.png" alt="img"></p><ol><li>我们经常需要自定义一个 <code>Handler</code> 类去继承 <code>ChannelInboundHandlerAdapter</code>，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_02.png" alt="img"></p><h3 id="6-6-Pipeline-和-ChannelPipelin"><a href="#6-6-Pipeline-和-ChannelPipelin" class="headerlink" title="6.6 Pipeline 和 ChannelPipelin"></a>6.6 Pipeline 和 ChannelPipelin</h3><p><code>ChannelPipeline</code> 是一个重点：</p><ol><li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li><li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li><li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_03.png" alt="img"></p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_04.png" alt="img"></p><ol><li>常用方法 <code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li></ol><h3 id="6-7-ChannelHandlerContext"><a href="#6-7-ChannelHandlerContext" class="headerlink" title="6.7 ChannelHandlerContext"></a>6.7 ChannelHandlerContext</h3><ol><li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li><li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</li><li>常用方法<ul><li><code>ChannelFuture close()</code>，关闭通道</li><li><code>ChannelOutboundInvoker flush()</code>，刷新</li><li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到</li><li><code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</li></ul></li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_05.png" alt="img"></p><h3 id="6-8-ChannelOption"><a href="#6-8-ChannelOption" class="headerlink" title="6.8 ChannelOption"></a>6.8 ChannelOption</h3><ol><li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li><li><code>ChannelOption</code> 参数如下：</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_06.png" alt="img"></p><h3 id="6-9-EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#6-9-EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="6.9 EventLoopGroup 和其实现类 NioEventLoopGroup"></a>6.9 EventLoopGroup 和其实现类 NioEventLoopGroup</h3><ol><li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，<code>Netty</code> 为了更好的利用多核 <code>CPU</code> 资源，一般会有多个 <code>EventLoop</code> 同时工作，每个 <code>EventLoop</code> 维护着一个 <code>Selector</code> 实例。</li><li><code>EventLoopGroup</code> 提供 <code>next</code> 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code> 来处理任务。在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</li><li>通常一个服务端口即一个 <code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和一个 <code>EventLoop</code> 线程。<code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_07.png" alt="img"></p><ol><li>常用方法 <code>public NioEventLoopGroup()</code>，构造方法 <code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li></ol><h3 id="6-10-Unpooled-类"><a href="#6-10-Unpooled-类" class="headerlink" title="6.10 Unpooled 类"></a>6.10 Unpooled 类</h3><ol><li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li><li>常用方法如下所示</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_08.png" alt="img"></p><ol><li>举例说明 <code>Unpooled</code> 获取 <code>Netty</code> 的数据容器 <code>ByteBuf</code> 的基本使用【案例演示】</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_09.png" alt="img"></p><p>案例 1</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.buf;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyByteBuf01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                <span class="hljs-comment">//创建一个ByteBuf</span>        <span class="hljs-comment">//说明</span>        <span class="hljs-comment">//1. 创建 对象，该对象包含一个数组arr , 是一个byte[10]</span>        <span class="hljs-comment">//2. 在netty 的buffer中，不需要使用flip 进行反转</span>        <span class="hljs-comment">//   底层维护了 readerindex 和 writerIndex</span>        <span class="hljs-comment">//3. 通过 readerindex 和  writerIndex 和  capacity， 将buffer分成三个区域</span>        <span class="hljs-comment">// 0---readerindex 已经读取的区域</span>        <span class="hljs-comment">// readerindex---writerIndex ， 可读的区域</span>        <span class="hljs-comment">// writerIndex -- capacity, 可写的区域</span>        ByteBuf buffer = Unpooled.buffer(<span class="hljs-number">10</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            buffer.writeByte(i);        &#125;        System.out.println(<span class="hljs-string">&quot;capacity=&quot;</span> + buffer.capacity());<span class="hljs-comment">//10</span>        <span class="hljs-comment">//输出</span><span class="hljs-comment">//        for(int i = 0; i&lt;buffer.capacity(); i++) &#123;</span><span class="hljs-comment">//            System.out.println(buffer.getByte(i));</span><span class="hljs-comment">//        &#125;</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.capacity(); i++) &#123;            System.out.println(buffer.readByte());        &#125;        System.out.println(<span class="hljs-string">&quot;执行完毕&quot;</span>);    &#125;&#125;</code></pre></div><p>案例 2</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.buf;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyByteBuf02</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建ByteBuf</span>        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello,world!&quot;</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));        <span class="hljs-comment">//使用相关的方法</span>        <span class="hljs-keyword">if</span> (byteBuf.hasArray()) &#123; <span class="hljs-comment">// true</span>            <span class="hljs-keyword">byte</span>[] content = byteBuf.array();            <span class="hljs-comment">//将 content 转成字符串</span>            System.out.println(<span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));            System.out.println(<span class="hljs-string">&quot;byteBuf=&quot;</span> + byteBuf);            System.out.println(byteBuf.arrayOffset()); <span class="hljs-comment">// 0</span>            System.out.println(byteBuf.readerIndex()); <span class="hljs-comment">// 0</span>            System.out.println(byteBuf.writerIndex()); <span class="hljs-comment">// 12</span>            System.out.println(byteBuf.capacity()); <span class="hljs-comment">// 36</span>            <span class="hljs-comment">//System.out.println(byteBuf.readByte()); //</span>            System.out.println(byteBuf.getByte(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 104</span>            <span class="hljs-keyword">int</span> len = byteBuf.readableBytes(); <span class="hljs-comment">//可读的字节数  12</span>            System.out.println(<span class="hljs-string">&quot;len=&quot;</span> + len);            <span class="hljs-comment">//使用for取出各个字节</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;                System.out.println((<span class="hljs-keyword">char</span>) byteBuf.getByte(i));            &#125;            <span class="hljs-comment">//按照某个范围读取</span>            System.out.println(byteBuf.getCharSequence(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));            System.out.println(byteBuf.getCharSequence(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));        &#125;    &#125;&#125;</code></pre></div><h3 id="6-11-Netty-应用实例-群聊系统"><a href="#6-11-Netty-应用实例-群聊系统" class="headerlink" title="6.11 Netty 应用实例-群聊系统"></a>6.11 Netty 应用实例-群聊系统</h3><p>实例要求：</p><ol><li>编写一个 <code>Netty</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>Netty</code> 非阻塞网络编程机制</li><li>看老师代码演示</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_10.png" alt="img"></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.*;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port; <span class="hljs-comment">//监听端口</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-comment">//编写run方法，处理客户端的请求</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建两个线程组</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//获取到pipeline</span>                            ChannelPipeline pipeline = ch.pipeline();                            <span class="hljs-comment">//向pipeline加入解码器</span>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> StringDecoder());                            <span class="hljs-comment">//向pipeline加入编码器</span>                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> StringEncoder());                            <span class="hljs-comment">//加入自己的业务处理handler</span>                            pipeline.addLast(<span class="hljs-keyword">new</span> GroupChatServerHandler());                        &#125;                    &#125;);            System.out.println(<span class="hljs-string">&quot;netty 服务器启动&quot;</span>);            ChannelFuture channelFuture = b.bind(port).sync();            <span class="hljs-comment">//监听关闭</span>            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">new</span> GroupChatServer(<span class="hljs-number">7000</span>).run();    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<span class="hljs-keyword">import</span> io.netty.channel.Channel;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.channel.group.ChannelGroup;<span class="hljs-keyword">import</span> io.netty.channel.group.DefaultChannelGroup;<span class="hljs-keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-comment">//public static List&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;();</span>    <span class="hljs-comment">//使用一个hashmap 管理</span>    <span class="hljs-comment">//public static Map&lt;String, Channel&gt; channels = new HashMap&lt;String,Channel&gt;();</span>    <span class="hljs-comment">//定义一个channle 组，管理所有的channel</span>    <span class="hljs-comment">//GlobalEventExecutor.INSTANCE) 是全局的事件执行器，是一个单例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ChannelGroup channelGroup = <span class="hljs-keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);    <span class="hljs-comment">//handlerAdded 表示连接建立，一旦连接，第一个被执行</span>    <span class="hljs-comment">//将当前channel 加入到  channelGroup</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Channel channel = ctx.channel();        <span class="hljs-comment">//将该客户加入聊天的信息推送给其它在线的客户端</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">        该方法会将 channelGroup 中所有的channel 遍历，并发送 消息，</span><span class="hljs-comment">        我们不需要自己遍历</span><span class="hljs-comment">         */</span>        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 加入聊天&quot;</span> + sdf.format(<span class="hljs-keyword">new</span> java.util.Date()) + <span class="hljs-string">&quot; \n&quot;</span>);        channelGroup.add(channel);    &#125;    <span class="hljs-comment">//断开连接, 将xx客户离开信息推送给当前在线的客户</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Channel channel = ctx.channel();        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 离开了\n&quot;</span>);        System.out.println(<span class="hljs-string">&quot;channelGroup size&quot;</span> + channelGroup.size());    &#125;    <span class="hljs-comment">//表示channel 处于活动状态, 提示 xx上线</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 上线了~&quot;</span>);    &#125;    <span class="hljs-comment">//表示channel 处于不活动状态, 提示 xx离线了</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 离线了~&quot;</span>);    &#125;    <span class="hljs-comment">//读取数据</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取到当前channel</span>        Channel channel = ctx.channel();        <span class="hljs-comment">//这时我们遍历channelGroup, 根据不同的情况，回送不同的消息</span>        channelGroup.forEach(ch -&gt; &#123;            <span class="hljs-keyword">if</span> (channel != ch) &#123; <span class="hljs-comment">//不是当前的channel,转发消息</span>                ch.writeAndFlush(<span class="hljs-string">&quot;[客户]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 发送了消息&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//回显自己发送的消息给自己</span>                ch.writeAndFlush(<span class="hljs-string">&quot;[自己]发送了消息&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);            &#125;        &#125;);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//关闭通道</span>        ctx.close();    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.*;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>&#123;        <span class="hljs-comment">//属性</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.host = host;        <span class="hljs-keyword">this</span>.port = port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;                        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap()                    .group(group)                    .channel(NioSocketChannel.class)                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            <span class="hljs-comment">//得到pipeline</span>                            ChannelPipeline pipeline = ch.pipeline();                            <span class="hljs-comment">//加入相关handler</span>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> StringDecoder());                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> StringEncoder());                            <span class="hljs-comment">//加入自定义的handler</span>                            pipeline.addLast(<span class="hljs-keyword">new</span> GroupChatClientHandler());                        &#125;                    &#125;);            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();            <span class="hljs-comment">//得到channel</span>            Channel channel = channelFuture.channel();            System.out.println(<span class="hljs-string">&quot;-------&quot;</span> + channel.localAddress() + <span class="hljs-string">&quot;--------&quot;</span>);            <span class="hljs-comment">//客户端需要输入信息，创建一个扫描器</span>            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);            <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;                String msg = scanner.nextLine();                <span class="hljs-comment">//通过channel 发送到服务器端</span>                channel.writeAndFlush(msg + <span class="hljs-string">&quot;\r\n&quot;</span>);            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            group.shutdownGracefully();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">new</span> GroupChatClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>).run();    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(msg.trim());    &#125;&#125;</code></pre></div><h3 id="6-12-Netty-心跳检测机制案例"><a href="#6-12-Netty-心跳检测机制案例" class="headerlink" title="6.12 Netty 心跳检测机制案例"></a>6.12 Netty 心跳检测机制案例</h3><p>实例要求：</p><ol><li>编写一个 <code>Netty</code> 心跳检测机制案例,当服务器超过 <code>3</code> 秒没有读时，就提示读空闲</li><li>当服务器超过 <code>5</code> 秒没有写操作时，就提示写空闲</li><li>实现当服务器超过 <code>7</code> 秒没有读或者写操作时，就提示读写空闲</li><li>代码如下：</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.heartbeat;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;<span class="hljs-keyword">import</span> io.netty.handler.timeout.IdleStateHandler;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-comment">//创建两个线程组</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup);            serverBootstrap.channel(NioServerSocketChannel.class);            serverBootstrap.handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO));            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ChannelPipeline pipeline = ch.pipeline();                    <span class="hljs-comment">//加入一个netty 提供 IdleStateHandler</span>                    <span class="hljs-comment">/*</span><span class="hljs-comment">                    说明</span><span class="hljs-comment">                    1. IdleStateHandler 是netty 提供的处理空闲状态的处理器</span><span class="hljs-comment">                    2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span><span class="hljs-comment">                    3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span><span class="hljs-comment">                    4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span><span class="hljs-comment"></span><span class="hljs-comment">                    5. 文档说明</span><span class="hljs-comment">                    triggers an &#123;@link IdleStateEvent&#125; when a &#123;@link Channel&#125; has not performed</span><span class="hljs-comment"> * read, write, or both operation for a while.</span><span class="hljs-comment"> *                  6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个handler去处理</span><span class="hljs-comment"> *                  通过调用(触发)下一个handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)</span><span class="hljs-comment">                     */</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">7000</span>, <span class="hljs-number">7000</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS));                    <span class="hljs-comment">//加入一个对空闲检测进一步处理的handler(自定义)</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> MyServerHandler());                &#125;            &#125;);            <span class="hljs-comment">//启动服务器</span>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.heartbeat;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.handler.timeout.IdleStateEvent;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evt 事件</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;            <span class="hljs-comment">//将  evt 向下转型 IdleStateEvent</span>            IdleStateEvent event = (IdleStateEvent) evt;            String eventType = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">switch</span> (event.state()) &#123;                <span class="hljs-keyword">case</span> READER_IDLE:                    eventType = <span class="hljs-string">&quot;读空闲&quot;</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> WRITER_IDLE:                    eventType = <span class="hljs-string">&quot;写空闲&quot;</span>;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> ALL_IDLE:                    eventType = <span class="hljs-string">&quot;读写空闲&quot;</span>;                    <span class="hljs-keyword">break</span>;            &#125;            System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot;--超时时间--&quot;</span> + eventType);            System.out.println(<span class="hljs-string">&quot;服务器做相应处理..&quot;</span>);            <span class="hljs-comment">//如果发生空闲，我们关闭通道</span>            <span class="hljs-comment">// ctx.channel().close();</span>        &#125;    &#125;&#125;</code></pre></div><h3 id="6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接"><a href="#6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接" class="headerlink" title="6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接"></a>6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接</h3><p>实例要求：</p><ol><li><code>Http</code> 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。</li><li>要求：实现基于 <code>WebSocket</code> 的长连接的全双工的交互</li><li>改变 <code>Http</code> 协议多次请求的约束，实现长连接了，服务器可以发送消息给浏览器</li><li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li><li>运行界面</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_11.png" alt="img"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.websocket;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;<span class="hljs-keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建两个线程组</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup);            serverBootstrap.channel(NioServerSocketChannel.class);            serverBootstrap.handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO));            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    ChannelPipeline pipeline = ch.pipeline();                    <span class="hljs-comment">//因为基于http协议，使用http的编码和解码器</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> HttpServerCodec());                    <span class="hljs-comment">//是以块方式写，添加ChunkedWriteHandler处理器</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler());                    <span class="hljs-comment">/*</span><span class="hljs-comment">                    说明</span><span class="hljs-comment">                    1. http数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span><span class="hljs-comment">                    2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span><span class="hljs-comment">                     */</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">8192</span>));                    <span class="hljs-comment">/*</span><span class="hljs-comment">                    说明</span><span class="hljs-comment">                    1. 对应websocket ，它的数据是以 帧(frame) 形式传递</span><span class="hljs-comment">                    2. 可以看到WebSocketFrame 下面有六个子类</span><span class="hljs-comment">                    3. 浏览器请求时 ws://localhost:7000/hello 表示请求的uri</span><span class="hljs-comment">                    4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws协议 , 保持长连接</span><span class="hljs-comment">                    5. 是通过一个 状态码 101</span><span class="hljs-comment">                     */</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">&quot;/hello2&quot;</span>));                    <span class="hljs-comment">//自定义的handler ，处理业务逻辑</span>                    pipeline.addLast(<span class="hljs-keyword">new</span> MyTextWebSocketFrameHandler());                &#125;            &#125;);            <span class="hljs-comment">//启动服务器</span>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.websocket;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;<span class="hljs-keyword">import</span> java.time.LocalDateTime;<span class="hljs-comment">//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTextWebSocketFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;服务器收到消息 &quot;</span> + msg.text());        <span class="hljs-comment">//回复消息</span>        ctx.channel().writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">&quot;服务器时间&quot;</span> + LocalDateTime.now() + <span class="hljs-string">&quot; &quot;</span> + msg.text()));    &#125;    <span class="hljs-comment">//当web客户端连接后， 触发方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span>        System.out.println(<span class="hljs-string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());        System.out.println(<span class="hljs-string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asShortText());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;异常发生 &quot;</span> + cause.getMessage());        ctx.close(); <span class="hljs-comment">//关闭连接</span>    &#125;&#125;</code></pre></div><p>hello.html</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">var</span> socket;</span><span class="javascript">    <span class="hljs-comment">//判断当前浏览器是否支持websocket</span></span><span class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.WebSocket) &#123;</span><span class="javascript">        <span class="hljs-comment">//go on</span></span><span class="javascript">        socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://localhost:7000/hello2&quot;</span>);</span><span class="javascript">        <span class="hljs-comment">//相当于channelRead, ev 收到服务器端回送的消息</span></span><span class="javascript">        socket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span><span class="javascript">            rt.value = rt.value + <span class="hljs-string">&quot;\n&quot;</span> + ev.data;</span>        &#125;<span class="javascript">        <span class="hljs-comment">//相当于连接开启(感知到连接开启)</span></span><span class="javascript">        socket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span><span class="javascript">            rt.value = <span class="hljs-string">&quot;连接开启了..&quot;</span></span>        &#125;<span class="javascript">        <span class="hljs-comment">//相当于连接关闭(感知到连接关闭)</span></span><span class="javascript">        socket.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span><span class="javascript">            rt.value = rt.value + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;连接关闭了..&quot;</span></span>        &#125;<span class="javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="javascript">        alert(<span class="hljs-string">&quot;当前浏览器不支持websocket&quot;</span>)</span>    &#125;<span class="javascript">    <span class="hljs-comment">//发送消息到服务器</span></span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params">message</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.socket) &#123; <span class="hljs-comment">//先判断socket是否创建好</span></span><span class="javascript">            <span class="hljs-keyword">return</span>;</span>        &#125;        if (socket.readyState === WebSocket.OPEN) &#123;<span class="javascript">            <span class="hljs-comment">//通过socket 发送消息</span></span>            socket.send(message)<span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="javascript">            alert(<span class="hljs-string">&quot;连接没有开启&quot;</span>);</span>        &#125;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return false&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;发生消息&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send(this.form.message.value)&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;responseText&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;responseText&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;清空内容&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="7-Google-Protobuf"><a href="#7-Google-Protobuf" class="headerlink" title="7 Google Protobuf"></a>7 Google Protobuf</h2><h3 id="7-1-编码和解码的基本介绍"><a href="#7-1-编码和解码的基本介绍" class="headerlink" title="7.1 编码和解码的基本介绍"></a>7.1 编码和解码的基本介绍</h3><ol><li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码[示意图]</li><li><code>codec</code>（编解码器）的组成部分有两个：<code>decoder</code>（解码器）和 <code>encoder</code>（编码器）。<code>encoder</code> 负责把业务数据转换成字节码数据，<code>decoder</code> 负责把字节码数据转换成业务数据</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_01.png" alt="img"></p><h3 id="7-2-Netty-本身的编码解码的机制和问题分析"><a href="#7-2-Netty-本身的编码解码的机制和问题分析" class="headerlink" title="7.2 Netty 本身的编码解码的机制和问题分析"></a>7.2 Netty 本身的编码解码的机制和问题分析</h3><ol><li><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)</li><li><code>Netty</code> 提供的编码器 <code>StringEncoder</code>，对字符串数据进行编码 <code>ObjectEncoder</code>，对Java对象进行编码…</li><li><code>Netty</code> 提供的解码器 <code>StringDecoder</code>,对字符串数据进行解码 <code>ObjectDecoder</code>，对 <code>Java</code> 对象进行解码…</li><li><code>Netty</code> 本身自带的 <code>ObjectDecoder</code> 和 <code>ObjectEncoder</code> 可以用来实现 <code>POJO</code> 对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，存在如下问题<ul><li>无法跨语言</li><li>序列化后的体积太大，是二进制编码的5倍多。</li><li>序列化性能太低</li></ul></li><li>=&gt;引出新的解决方案[<code>Google</code> 的 <code>Protobuf</code>]</li></ol><h3 id="7-3-Protobuf"><a href="#7-3-Protobuf" class="headerlink" title="7.3 Protobuf"></a>7.3 Protobuf</h3><ol><li><code>Protobuf</code> 基本介绍和使用示意图</li><li><code>Protobuf</code> 是 <code>Google</code> 发布的开源项目，全称 <code>Google Protocol Buffers</code>，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 <code>RPC</code> [远程过程调用 <code>remote procedure call</code> ]数据交换格式。目前很多公司 <code>http + json tcp + protobuf</code></li><li>参考文档：<a href="https://developers.google.com/protocol-buffers/docs/proto">https://developers.google.com/protocol-buffers/docs/proto</a> 语言指南</li><li><code>Protobuf</code> 是以 <code>message</code> 的方式来管理数据的.</li><li>支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的]（支持目前绝大多数语言，例如 <code>C++</code>、<code>C#</code>、<code>Java</code>、<code>python</code> 等）</li><li>高性能，高可靠性</li><li>使用 <code>protobuf</code> 编译器能自动生成代码，<code>Protobuf</code> 是将类的定义使用 <code>.proto</code> 文件进行描述。说明，在 <code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.ptoto</code> 编写插件.可以让语法高亮。</li><li>然后通过 <code>protoc.exe</code> 编译器根据 <code>.proto</code> 自动生成 <code>.java</code> 文件</li><li><code>protobuf</code> 使用示意图</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_02.png" alt="img"></p><h3 id="7-4-Protobuf-快速入门实例"><a href="#7-4-Protobuf-快速入门实例" class="headerlink" title="7.4 Protobuf 快速入门实例"></a>7.4 Protobuf 快速入门实例</h3><p>编写程序，使用 <code>Protobuf</code> 完成如下功能</p><ol><li>客户端可以发送一个 <code>StudentPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li><li>服务端能接收 <code>StudentPoJo</code> 对象，并显示信息(通过 <code>Protobuf</code> 解码)</li><li>具体看老师演示步骤</li></ol><div class="code-wrapper"><pre><code class="hljs java">Student.protosyntax = <span class="hljs-string">&quot;proto3&quot;</span>; <span class="hljs-comment">//版本</span>option java_outer_classname = <span class="hljs-string">&quot;StudentPOJO&quot;</span>;<span class="hljs-comment">//生成的外部类名，同时也是文件名</span><span class="hljs-comment">//protobuf 使用message 管理数据</span>message Student &#123; <span class="hljs-comment">//会在 StudentPOJO 外部类生成一个内部类 Student， 他是真正发送的POJO对象</span>    int32 id = <span class="hljs-number">1</span>; <span class="hljs-comment">// Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span>    string name = <span class="hljs-number">2</span>;&#125;编译protoc.exe--java_out=.Student.proto将生成的 StudentPOJO 放入到项目使用</code></pre></div><h3 id="7-5-Protobuf-快速入门实例-2"><a href="#7-5-Protobuf-快速入门实例-2" class="headerlink" title="7.5 Protobuf 快速入门实例 2"></a>7.5 Protobuf 快速入门实例 2</h3><ol><li>编写程序，使用 <code>Protobuf</code> 完成如下功能</li><li>客户端可以随机发送 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li><li>服务端能接收 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象(需要判断是哪种类型)，并显示信息(通过 <code>Protobuf</code> 解码)</li><li>具体看老师演示步骤</li></ol><div class="code-wrapper"><pre><code class="hljs java">Student.protosyntax = <span class="hljs-string">&quot;proto3&quot;</span>;option optimize_for = SPEED; <span class="hljs-comment">// 加快解析</span>option java_package=<span class="hljs-string">&quot;com.atguigu.netty.codec2&quot;</span>;   <span class="hljs-comment">//指定生成到哪个包下</span>option java_outer_classname=<span class="hljs-string">&quot;MyDataInfo&quot;</span>; <span class="hljs-comment">// 外部类名, 文件名</span><span class="hljs-comment">//protobuf 可以使用message 管理其他的message</span>message MyMessage &#123;    <span class="hljs-comment">//定义一个枚举类型</span>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DataType</span> </span>&#123;        StudentType = <span class="hljs-number">0</span>; <span class="hljs-comment">//在proto3 要求enum的编号从0开始</span>        WorkerType = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//用data_type 来标识传的是哪一个枚举类型</span>    DataType data_type = <span class="hljs-number">1</span>;    <span class="hljs-comment">//表示每次枚举类型最多只能出现其中的一个, 节省空间</span>    oneof dataBody &#123;        Student student = <span class="hljs-number">2</span>;        Worker worker = <span class="hljs-number">3</span>;    &#125;&#125;message Student &#123;    int32 id = <span class="hljs-number">1</span>;<span class="hljs-comment">//Student类的属性</span>    string name = <span class="hljs-number">2</span>; <span class="hljs-comment">//</span>&#125;message Worker &#123;    string name=<span class="hljs-number">1</span>;    int32 age=<span class="hljs-number">2</span>;&#125;</code></pre></div><h2 id="8-Netty-编解码器和-Handler-调用机制"><a href="#8-Netty-编解码器和-Handler-调用机制" class="headerlink" title="8 Netty 编解码器和 Handler 调用机制"></a>8 Netty 编解码器和 Handler 调用机制</h2><h3 id="8-1-基本说明"><a href="#8-1-基本说明" class="headerlink" title="8.1 基本说明"></a>8.1 基本说明</h3><ol><li><code>Netty</code> 的组件设计：<code>Netty</code> 的主要组件有 <code>Channel</code>、<code>EventLoop</code>、<code>ChannelFuture</code>、<code>ChannelHandler</code>、<code>ChannelPipe</code> 等</li><li><code>ChannelHandler</code> 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 <code>ChannelInboundHandler</code> 接口（或 <code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从 <code>ChannelInboundHandler</code> 冲刷数据。业务逻辑通常写在一个或者多个 <code>ChannelInboundHandler</code> 中。<code>ChannelOutboundHandler</code> 原理一样，只不过它是用来处理出站数据的</li><li><code>ChannelPipeline</code> 提供了 <code>ChannelHandler</code> 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 <code>pipeline</code> 中的一系列 <code>ChannelOutboundHandler</code>，并被这些 <code>Handler</code> 处理，反之则称为入站的</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_01.png" alt="img"></p><h3 id="8-2编码解码器"><a href="#8-2编码解码器" class="headerlink" title="8.2编码解码器"></a>8.2编码解码器</h3><ol><li>当 <code>Netty</code> 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 <code>java</code> 对象）；如果是出站消息，它会被编码成字节。</li><li><code>Netty</code> 提供一系列实用的编解码器，他们都实现了 <code>ChannelInboundHadnler</code> 或者 <code>ChannelOutboundHandler</code> 接口。在这些类中，<code>channelRead</code> 方法已经被重写了。以入站为例，对于每个从入站 <code>Channel</code> 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 <code>decode()</code> 方法进行解码，并将已经解码的字节转发给 <code>ChannelPipeline</code> 中的下一个 <code>ChannelInboundHandler</code>。</li></ol><h3 id="8-3-解码器-ByteToMessageDecoder"><a href="#8-3-解码器-ByteToMessageDecoder" class="headerlink" title="8.3 解码器 - ByteToMessageDecoder"></a>8.3 解码器 - ByteToMessageDecoder</h3><ol><li>关系继承图</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_02.png" alt="img"></p><ol><li>由于不可能知道远程节点是否会一次性发送一个完整的信息，<code>tcp</code> 有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理.</li><li>一个关于 <code>ByteToMessageDecoder</code> 实例分析</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_03.png" alt="img"></p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_04.png" alt="img"></p><h3 id="8-4-Netty-的-handler-链的调用机制"><a href="#8-4-Netty-的-handler-链的调用机制" class="headerlink" title="8.4 Netty 的 handler 链的调用机制"></a>8.4 Netty 的 handler 链的调用机制</h3><p>实例要求:</p><ol><li>使用自定义的编码器和解码器来说明 <code>Netty</code> 的 <code>handler</code> 调用机制 客户端发送 <code>long</code> -&gt; 服务器 服务端发送 <code>long</code> -&gt; 客户端</li><li>案例演示</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_05.png" alt="img"></p><ol><li>结论<ul><li>不论解码器 <code>handler</code> 还是编码器 <code>handler</code> 即接收的消息类型必须与待处理的消息类型一致，否则该 <code>handler</code> 不会被执行</li><li>在解码器进行数据解码时，需要判断缓存区（<code>ByteBuf</code>）的数据是否足够，否则接收到的结果会期望结果可能不一致</li></ul></li></ol><h3 id="8-5-解码器-ReplayingDecoder"><a href="#8-5-解码器-ReplayingDecoder" class="headerlink" title="8.5 解码器 - ReplayingDecoder"></a>8.5 解码器 - ReplayingDecoder</h3><ol><li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></li><li><code>ReplayingDecoder</code> 扩展了 <code>ByteToMessageDecoder</code> 类，使用这个类，我们不必调用 <code>readableBytes()</code> 方法。参数 <code>S</code> 指定了用户状态管理的类型，其中 <code>Void</code> 代表不需要状态管理</li><li>应用实例：使用 <code>ReplayingDecoder</code> 编写解码器，对前面的案例进行简化[案例演示]</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyByteToLongDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyByteToLongDecoder2 被调用&quot;</span>);        <span class="hljs-comment">//在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断</span>        out.add(in.readLong());    &#125;&#125;</code></pre></div><ol start="4"><li><code>ReplayingDecoder</code>使用方便，但它也有一些局限性：<ul><li>并不是所有的 <code>ByteBuf</code> 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>。</li><li><code>ReplayingDecoder</code> 在某些情况下可能稍慢于 <code>ByteToMessageDecoder</code>，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li></ul></li></ol><h3 id="8-6-其它编解码器"><a href="#8-6-其它编解码器" class="headerlink" title="8.6 其它编解码器"></a>8.6 其它编解码器</h3><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_06.png" alt="img"></p><h4 id="8-6-1-其它解码器"><a href="#8-6-1-其它解码器" class="headerlink" title="8.6.1 其它解码器"></a>8.6.1 其它解码器</h4><ol><li><code>LineBasedFrameDecoder</code>：这个类在 <code>Netty</code> 内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</li><li><code>DelimiterBasedFrameDecoder</code>：使用自定义的特殊字符作为消息的分隔符。</li><li><code>HttpObjectDecoder</code>：一个 <code>HTTP</code> 数据的解码器</li><li><code>LengthFieldBasedFrameDecoder</code>：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li></ol><h4 id="8-6-2-其它编码器"><a href="#8-6-2-其它编码器" class="headerlink" title="8.6.2 其它编码器"></a>8.6.2 其它编码器</h4><h3 id="8-7-Log4j-整合到-Netty"><a href="#8-7-Log4j-整合到-Netty" class="headerlink" title="8.7 Log4j 整合到 Netty"></a>8.7 Log4j 整合到 Netty</h3><ol><li>在 <code>Maven</code> 中添加对 <code>Log4j</code> 的依赖在 <code>pom.xml</code></li></ol><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ol><li>配置 <code>Log4j</code>，在 <code>resources/log4j.properties</code></li></ol><div class="code-wrapper"><pre><code class="hljs xml">log4j.rootLogger=DEBUG,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%p]%C&#123;1&#125;-%m%n</code></pre></div><ol><li>演示整合</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_07.png" alt="img"></p><h2 id="9-TCP-粘包和拆包及解决方案"><a href="#9-TCP-粘包和拆包及解决方案" class="headerlink" title="9 TCP 粘包和拆包及解决方案"></a>9 TCP 粘包和拆包及解决方案</h2><h3 id="9-1-TCP-粘包和拆包基本介绍"><a href="#9-1-TCP-粘包和拆包基本介绍" class="headerlink" title="9.1 TCP 粘包和拆包基本介绍"></a>9.1 TCP 粘包和拆包基本介绍</h3><ol><li><code>TCP</code> 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 <code>socket</code>，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（<code>Nagle</code> 算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的</li><li>由于 <code>TCP</code> 无消息保护边界,需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题,看一张图</li><li>示意图 <code>TCP</code> 粘包、拆包图解</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter09_01.png" alt="img"></p><p>对图的说明: 假设客户端分别发送了两个数据包 <code>D1</code> 和 <code>D2</code> 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p><ol><li>服务端分两次读取到了两个独立的数据包，分别是 <code>D1</code> 和 <code>D2</code>，没有粘包和拆包</li><li>服务端一次接受到了两个数据包，<code>D1</code> 和 <code>D2</code> 粘合在一起，称之为 <code>TCP</code> 粘包</li><li>服务端分两次读取到了数据包，第一次读取到了完整的 <code>D1</code> 包和 <code>D2</code> 包的部分内容，第二次读取到了 <code>D2</code> 包的剩余内容，这称之为 <code>TCP</code> 拆包</li><li>服务端分两次读取到了数据包，第一次读取到了 <code>D1</code> 包的部分内容 <code>D1_1</code>，第二次读取到了 <code>D1</code> 包的剩余部分内容 <code>D1_2</code> 和完整的 <code>D2</code> 包。</li></ol><h3 id="9-2-TCP-粘包和拆包现象实例"><a href="#9-2-TCP-粘包和拆包现象实例" class="headerlink" title="9.2 TCP 粘包和拆包现象实例"></a>9.2 TCP 粘包和拆包现象实例</h3><p>在编写 <code>Netty</code> 程序时，如果没有做处理，就会发生粘包和拆包的问题</p><p>看一个具体的实例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 核心代码</span>MyClientHandler.java<span class="hljs-keyword">package</span> com.atguigu.netty.tcp;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//使用客户端发送10条数据 hello,server 编号</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;            ByteBuf buffer = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello,server &quot;</span> + i, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));            ctx.writeAndFlush(buffer);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[msg.readableBytes()];        msg.readBytes(buffer);        String message = <span class="hljs-keyword">new</span> String(buffer, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));        System.out.println(<span class="hljs-string">&quot;客户端接收到消息=&quot;</span> + message);        System.out.println(<span class="hljs-string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;MyServerHandler.java<span class="hljs-keyword">package</span> com.atguigu.netty.tcp;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-keyword">import</span> java.util.UUID;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//cause.printStackTrace();</span>        ctx.close();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[msg.readableBytes()];        msg.readBytes(buffer);        <span class="hljs-comment">//将buffer转成字符串</span>        String message = <span class="hljs-keyword">new</span> String(buffer, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));        System.out.println(<span class="hljs-string">&quot;服务器接收到数据 &quot;</span> + message);        System.out.println(<span class="hljs-string">&quot;服务器接收到消息量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));        <span class="hljs-comment">//服务器回送数据给客户端, 回送一个随机id ,</span>        ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="hljs-string">&quot; &quot;</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));        ctx.writeAndFlush(responseByteBuf);    &#125;&#125;</code></pre></div><h3 id="9-3-TCP-粘包和拆包解决方案"><a href="#9-3-TCP-粘包和拆包解决方案" class="headerlink" title="9.3 TCP 粘包和拆包解决方案"></a>9.3 TCP 粘包和拆包解决方案</h3><ol><li>使用自定义协议+编解码器来解决</li><li>关键就是要解决服务器端每次读取数据长度的问题，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 <code>TCP</code> 粘包、拆包。</li></ol><h3 id="9-4-看一个具体的实例"><a href="#9-4-看一个具体的实例" class="headerlink" title="9.4 看一个具体的实例"></a>9.4 看一个具体的实例</h3><ol><li>要求客户端发送 <code>5</code> 个 <code>Message</code> 对象，客户端每次发送一个 <code>Message</code> 对象</li><li>服务器端每次接收一个 <code>Message</code>，分 <code>5</code> 次进行解码，每读取到一个 <code>Message</code>，会回复一个 <code>Message</code> 对象给客户端。</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter09_02.png" alt="img"></p><ol><li>代码演示，全部代码核心</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 核心</span><span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<span class="hljs-comment">//协议包</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProtocol</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> len; <span class="hljs-comment">//关键</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] content;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> len;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;        <span class="hljs-keyword">this</span>.len = len;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getContent() &#123;        <span class="hljs-keyword">return</span> content;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] content)</span> </span>&#123;        <span class="hljs-keyword">this</span>.content = content;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//使用客户端发送10条数据 &quot;今天天气冷，吃火锅&quot; 编号</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            String mes = <span class="hljs-string">&quot;今天天气冷，吃火锅&quot;</span>;            <span class="hljs-keyword">byte</span>[] content = mes.getBytes(Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));            <span class="hljs-keyword">int</span> length = mes.getBytes(Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)).length;            <span class="hljs-comment">//创建协议包对象</span>            MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();            messageProtocol.setLen(length);            messageProtocol.setContent(content);            ctx.writeAndFlush(messageProtocol);        &#125;    &#125;    <span class="hljs-comment">//    @Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> len = msg.getLen();        <span class="hljs-keyword">byte</span>[] content = msg.getContent();        System.out.println(<span class="hljs-string">&quot;客户端接收到消息如下&quot;</span>);        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + len);        System.out.println(<span class="hljs-string">&quot;内容=&quot;</span> + <span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));        System.out.println(<span class="hljs-string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;异常消息=&quot;</span> + cause.getMessage());        ctx.close();    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyMessageEncoder encode 方法被调用&quot;</span>);        out.writeInt(msg.getLen());        out.writeBytes(msg.getContent());    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot;MyMessageDecoder decode 被调用&quot;</span>);        <span class="hljs-comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span>        <span class="hljs-keyword">int</span> length = in.readInt();        <span class="hljs-keyword">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];        in.readBytes(content);        <span class="hljs-comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span>        MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();        messageProtocol.setLen(length);        messageProtocol.setContent(content);        out.add(messageProtocol);    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-keyword">import</span> java.util.UUID;<span class="hljs-comment">//处理业务的handler</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//cause.printStackTrace();</span>        ctx.close();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//接收到数据，并处理</span>        <span class="hljs-keyword">int</span> len = msg.getLen();        <span class="hljs-keyword">byte</span>[] content = msg.getContent();        System.out.println();        System.out.println();        System.out.println();        System.out.println(<span class="hljs-string">&quot;服务器接收到信息如下&quot;</span>);        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + len);        System.out.println(<span class="hljs-string">&quot;内容=&quot;</span> + <span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));        System.out.println(<span class="hljs-string">&quot;服务器接收到消息包数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));        <span class="hljs-comment">//回复消息</span>        String responseContent = UUID.randomUUID().toString();        <span class="hljs-keyword">int</span> responseLen = responseContent.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>).length;        <span class="hljs-keyword">byte</span>[] responseContent2 = responseContent.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);        <span class="hljs-comment">//构建一个协议包</span>        MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();        messageProtocol.setLen(responseLen);        messageProtocol.setContent(responseContent2);        ctx.writeAndFlush(messageProtocol);    &#125;&#125;</code></pre></div><h2 id="10-Netty-核心源码剖析"><a href="#10-Netty-核心源码剖析" class="headerlink" title="10 Netty 核心源码剖析"></a>10 Netty 核心源码剖析</h2><h3 id="10-1-基本说明"><a href="#10-1-基本说明" class="headerlink" title="10.1 基本说明"></a>10.1 基本说明</h3><ol><li>只有看过 <code>Netty</code> 源码，才能说是真的掌握了 <code>Netty</code> 框架。</li><li>在 <code>io.netty.example</code> 包下，有很多 <code>Netty</code> 源码案例，可以用来分析。</li><li>源码分析章节是针对有 <code>Java</code> 项目经验，并且玩过框架源码的人员讲的，否则你听起来会有相当的难度。</li></ol><h3 id="10-2-Netty-启动过程源码剖析"><a href="#10-2-Netty-启动过程源码剖析" class="headerlink" title="10.2 Netty 启动过程源码剖析"></a>10.2 Netty 启动过程源码剖析</h3><h4 id="10-2-1-源码剖析目的"><a href="#10-2-1-源码剖析目的" class="headerlink" title="10.2.1 源码剖析目的"></a>10.2.1 源码剖析目的</h4><p>用源码分析的方式走一下 <code>Netty</code>（服务器）的启动过程，更好的理解 <code>Netty</code> 的整体设计和运行机制。</p><h4 id="10-2-2-源码剖析"><a href="#10-2-2-源码剖析" class="headerlink" title="10.2.2 源码剖析"></a>10.2.2 源码剖析</h4><p>说明：</p><ol><li>源码需要剖析到 <code>Netty</code> 调用 <code>doBind</code> 方法，追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>。</li><li>并且要 <code>Debug</code> 程序到 <code>NioEventLoop</code> 类的 <code>run</code> 代码，无限循环，在服务器端运行。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_01.png" alt="img"></p><h4 id="10-2-3-源码剖析过程"><a href="#10-2-3-源码剖析过程" class="headerlink" title="10.2.3 源码剖析过程"></a>10.2.3 源码剖析过程</h4><p><strong>1. <code>demo</code> 源码的基本理解</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 服务器启动类源码</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * Copyright 2012 The Netty Project</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * The Netty Project licenses this file to you under the Apache License,</span><span class="hljs-comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span><span class="hljs-comment"> * with the License. You may obtain a copy of the License at:</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span><span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span><span class="hljs-comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span><span class="hljs-comment"> * License for the specific language governing permissions and limitations</span><span class="hljs-comment"> * under the License.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> atguigu.netty.example.echo2;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;<span class="hljs-keyword">import</span> io.netty.handler.ssl.SslContext;<span class="hljs-keyword">import</span> io.netty.handler.ssl.SslContextBuilder;<span class="hljs-keyword">import</span> io.netty.handler.ssl.util.SelfSignedCertificate;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Echoes back any received data from a client.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> SSL = System.getProperty(<span class="hljs-string">&quot;ssl&quot;</span>) != <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>));    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// Configure SSL.</span>        <span class="hljs-keyword">final</span> SslContext sslCtx;        <span class="hljs-keyword">if</span> (SSL) &#123;            SelfSignedCertificate ssc = <span class="hljs-keyword">new</span> SelfSignedCertificate();            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();        &#125; <span class="hljs-keyword">else</span> &#123;            sslCtx = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// Configure the server.</span>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();            b.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)                    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                            ChannelPipeline p = ch.pipeline();                            <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;                                p.addLast(sslCtx.newHandler(ch.alloc()));                            &#125;                            <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>                            p.addLast(<span class="hljs-keyword">new</span> EchoServerHandler());                        &#125;                    &#125;);            <span class="hljs-comment">// Start the server.</span>            ChannelFuture f = b.bind(PORT).sync();            <span class="hljs-comment">// Wait until the server socket is closed.</span>            f.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// Shut down all event loops to terminate all threads.</span>            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;</code></pre></div><p>说明：</p><ol><li>先看启动类：<code>main</code> 方法中，首先创建了关于 SSL 的配置类。</li><li>重点分析下创建了两个 <code>EventLoopGroup</code> 对象：</li></ol><div class="code-wrapper"><pre><code class="hljs java">EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();</code></pre></div><p>(1) 这两个对象是整个 <code>Netty</code> 的核心对象，可以说，整个 <code>Netty</code> 的运作都依赖于他们。<code>bossGroup</code> 用于接受 <code>TCP</code> 请求，他会将请求交给 <code>workerGroup</code>，<code>workerGroup</code> 会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作。</p><p>(2) <code>EventLoopGroup</code> 是事件循环组（线程组）含有多个 <code>EventLoop</code>，可以注册 <code>channel</code>，用于在事件循环中去进行选择（和选择器相关）。【debug看】</p><p>(3) <code>new NioEventLoopGroup(1);</code> 这个 <code>1</code> 表示 <code>bossGroup</code> 事件组有 <code>1</code> 个线程你可以指定，如果 <code>new NioEventLoopGroup()</code> 会含有默认个线程 <code>cpu核数 * 2</code>，即可以充分的利用多核的优势，【可以dubug一把】</p><div class="code-wrapper"><pre><code class="hljs java">DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));</code></pre></div><p>会创建 <code>EventExecutor</code> 数组 <code>children = new EventExecutor[nThreads];</code> // <code>debug</code> 一下每个元素的类型就是 <code>NIOEventLoop</code>，<code>NIOEventLoop</code> 实现了 <code>EventLoop</code> 接口和 <code>Executor</code> 接口 <code>try</code> 块中创建了一个 <code>ServerBootstrap</code> 对象，他是一个引导类，用于启动服务器和引导整个程序的初始化（看下源码 <code>allowseasybootstrapof&#123;@linkServerChannel&#125;</code>）。它和 <code>ServerChannel</code> 关联，而 <code>ServerChannel</code> 继承了 <code>Channel</code>，有一些方法 <code>remoteAddress</code> 等[可以Debug下]随后，变量 <code>b</code> 调用了 <code>group</code> 方法将两个 <code>group</code> 放入了自己的字段中，用于后期引导使用【<code>debug</code> 下 <code>group</code> 方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *Set the &#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125; for the parent (acceptor) and the child (client) . These</span><span class="hljs-comment"> *&#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125;&#x27;s are used to handle all the events and IO for &#123;<span class="hljs-doctag">@link</span> ServerChannel&#125; and </span><span class="hljs-comment"> *&#123;<span class="hljs-doctag">@link</span> Channel&#125;&#x27;s.</span><span class="hljs-comment"> */</span></code></pre></div><p>】。</p><p>(4) 然后添加了一个 <code>channel</code>，其中参数一个 <code>Class</code> 对象，引导类将通过这个 <code>Class</code> 对象反射创建 <code>ChannelFactory</code>。然后添加了一些 <code>TCP</code> 的参数。【说明：<code>Channel</code> 的创建在 <code>bind</code> 方法，可以 <code>Debug</code> 下 <code>bind</code>，会找到 <code>channel = channelFactory.newChannel();</code> 】</p><p>(5) 再添加了一个服务器专属的日志处理器 <code>handler</code> 。</p><p>(6) 再添加一个 <code>SocketChannel</code>（不是 <code>ServerSocketChannel</code>）的 <code>handler</code>。</p><p>(7) 然后绑定端口并阻塞至连接成功。</p><p>(8) 最后 <code>main</code> 线程阻塞等待关闭。</p><p>(9) <code>finally</code> 块中的代码将在服务器关闭时优雅关闭所有资源。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Copyright 2012 The Netty Project</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * The Netty Project licenses this file to you under the Apache License,</span><span class="hljs-comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span><span class="hljs-comment"> * with the License. You may obtain a copy of the License at:</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span><span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span><span class="hljs-comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span><span class="hljs-comment"> * License for the specific language governing permissions and limitations</span><span class="hljs-comment"> * under the License.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> atguigu.netty.example.echo2;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandler.Sharable;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Handler implementation for the echo server.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Sharable</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;        ctx.write(msg);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;        ctx.flush();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;        <span class="hljs-comment">// Close the connection when an exception is raised.</span>        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><p>说明:</p><ol><li>这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端。</li><li>大致讲解了我们的 <code>demo</code> 源码的作用。后面的 <code>debug</code> 的时候会详细。</li></ol><p><strong>2. 分析 EventLoopGroup 的过程</strong></p><p>2.1 构造器方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;     <span class="hljs-keyword">this</span>(nThreads, (Executor) <span class="hljs-keyword">null</span>);&#125;</code></pre></div><p>2.2 上面的 <code>this(nThreads, (Executor) null);</code> 调用构造器（通过 <code>alt + d</code> 看即可）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor)</span> </span>&#123;    <span class="hljs-keyword">this</span>(nThreads, executor, SelectorProvider.provider());&#125;</code></pre></div><p>2.3 上面的 <code>this(nThreads, executor, SelectorProvider.provider());</code> 调用下面构造器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider)</span> </span>&#123;    <span class="hljs-keyword">this</span>(nThreads, executor, selectorProvider,DefaultSelectStrategyFactory.INSTANCE);&#125;</code></pre></div><p>2.4 上面的 <code>this()...</code> 调用构造器（<code>alt + d</code>）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider,<span class="hljs-keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;    <span class="hljs-keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());&#125;</code></pre></div><p>2.5 上面的 <code>super()..</code> 的方法是父类：<code>MultithreadEventLoopGroup</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, Object...args)</span> </span>&#123;    <span class="hljs-keyword">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);&#125;</code></pre></div><p>2.6 追踪到源码抽象类 <code>MultithreadEventExecutorGroup</code> 的构造器方法 <code>MultithreadEventExecutorGroup</code> 才是 <code>NioEventLoopGroup</code> 真正的构造方法，这里可以看成是一个模板方法，使用了设计模式的模板模式（可看我录制视频），所以，我们就需要好好分析 <code>MultithreadEventExecutorGroup</code> 方法了</p><p>2.7 分析 <code>MultithreadEventExecutorGroup</code></p><p>参数说明：</p><ul><li><code>@param nThreads</code> 使用的线程数，默认为 <code>core * 2</code>【可以追踪源码】</li><li><code>@param executor</code> 执行器:如果传入 <code>null</code>, 则采用 <code>Netty</code> 默认的线程工厂和默认的执行器 <code>ThreadPerTaskExecutor</code></li><li><code>@param chooserFactory</code> 单例 <code>new DefaultEventExecutorChooserFactory()</code></li><li><code>@param args args</code> 在创建执行器的时候传入固定参数</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor,</span></span><span class="hljs-function"><span class="hljs-params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;    <span class="hljs-keyword">if</span> (nThreads &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));    &#125;    <span class="hljs-keyword">if</span> (executor == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果传入的执行器是空的则采用默认的线程工厂和默认的执行器</span>        executor = <span class="hljs-keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());    &#125;    <span class="hljs-comment">// 创建指定线程数的执行器数组</span>    children = <span class="hljs-keyword">new</span> EventExecutor[nThreads];    <span class="hljs-comment">// 初始化线程数组</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;        <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 创建 new NioEventLoop</span>            children[i] = newChild(executor, args);            success = <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 如果创建失败，优雅关闭</span>            <span class="hljs-keyword">if</span> (!success) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;                    children[j].shutdownGracefully();                &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;                    EventExecutor e = children[j];                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);                        &#125;                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;                        <span class="hljs-comment">// Let the caller handle the interruption.</span>                        Thread.currentThread().interrupt();                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;            &#125;        &#125;    &#125;    chooser = chooserFactory.newChooser(children);    <span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> FutureListener&lt;Object&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;                terminationFuture.setSuccess(<span class="hljs-keyword">null</span>);            &#125;        &#125;    &#125;;        <span class="hljs-comment">// 为每一个单例线程池添加一个关闭监听器</span>    <span class="hljs-keyword">for</span> (EventExecutor e: children) &#123;        e.terminationFuture().addListener(terminationListener);    &#125;    Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);    <span class="hljs-comment">//将所有的单例线程池添加到一个 HashSet 中。</span>    Collections.addAll(childrenSet, children);    readonlyChildren = Collections.unmodifiableSet(childrenSet);&#125;</code></pre></div><p>说明：</p><ol><li>如果 <code>executor</code> 是 <code>null</code>，创建一个默认的 <code>ThreadPerTaskExecutor</code>，使用 <code>Netty</code> 默认的线程工厂。</li><li>根据传入的线程数（<code>CPU * 2</code>）创建一个线程池（单例线程池）数组。</li><li>循环填充数组中的元素。如果异常，则关闭所有的单例线程池。</li><li>根据线程选择工厂创建一个线程选择器。</li><li>为每一个单例线程池添加一个关闭监听器。</li><li>将所有的单例线程池添加到一个 <code>HashSet</code> 中。</li></ol><p><strong>3. ServerBootstrap 创建和构造过程</strong></p><p>3.1 <code>ServerBootstrap</code> 是个空构造，但是有默认的成员变量</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="hljs-keyword">new</span> LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();<span class="hljs-comment">// config 对象，会在后面起很大作用</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerBootstrapConfig config = <span class="hljs-keyword">new</span> ServerBootstrapConfig(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> EventLoopGroup childGroup;<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ChannelHandler childHandler;</code></pre></div><p>3.2 分析一下 <code>ServerBootstrap</code> 基本使用情况</p><div class="code-wrapper"><pre><code class="hljs java">ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();b.group(bossGroup, workerGroup)        .channel(NioServerSocketChannel.class)        .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)        .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))        .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                ChannelPipeline p = ch.pipeline();                <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;                    p.addLast(sslCtx.newHandler(ch.alloc()));                &#125;                <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>                p.addLast(<span class="hljs-keyword">new</span> EchoServerHandler());            &#125;        &#125;);</code></pre></div><p>说明:</p><ol><li>链式调用：<code>group</code> 方法，将 <code>boss</code> 和 <code>worker</code> 传入，<code>boss</code> 赋值给 <code>parentGroup</code> 属性, <code>worker</code> 赋值给 <code>childGroup</code> 属性。</li><li><code>channel</code> 方法传入 <code>NioServerSocketChannelclass</code> 对象。会根据这个 <code>class</code> 创建 <code>channel</code> 对象。</li><li><code>option</code> 方法传入 <code>TCP</code> 参数，放在一个 <code>LinkedHashMap</code> 中。</li><li><code>handler</code> 方法传入一个 <code>handler</code> 中，这个 <code>hanlder</code> 只专属于 <code>ServerSocketChannel</code> 而不是 <code>SocketChannel</code>。</li><li><code>childHandler</code> 传入一个 <code>hanlder</code>，这个 <code>handler</code> 将会在每个客户端连接的时候调用。供 <code>SocketChannel</code> 使用。</li></ol><p><strong>4. 绑定端口的分析</strong></p><p>4.1 服务器就是在这个 <code>bind</code> 方法里启动完成的 4.2 <code>bind</code> 方法代码,追踪到创建了一个端口对象，并做了一些空判断，核心代码 <code>doBind</code>，我们看看</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;    validate();    <span class="hljs-keyword">if</span> (localAddress == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;localAddress&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> doBind(localAddress);&#125;</code></pre></div><p>4.3 <code>doBind</code> 源码剖析，核心是两个方法 <code>initAndRegister</code> 和 <code>doBind0</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> </span>&#123;    <span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();    <span class="hljs-keyword">final</span> Channel channel = regFuture.channel();    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> regFuture;    &#125;    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span>        ChannelPromise promise = channel.newPromise();        <span class="hljs-comment">//============================================</span>        <span class="hljs-comment">//说明:执行doBind0方法，完成对端口的绑定</span>        <span class="hljs-comment">//============================================</span>        doBind0(regFuture, channel, localAddress, promise);        <span class="hljs-keyword">return</span> promise;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span>        <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);        regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                Throwable cause = future.cause();                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span>                    promise.setFailure(cause);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span>                    promise.registered();                    doBind0(regFuture, channel, localAddress, promise);                &#125;            &#125;        &#125;);        <span class="hljs-keyword">return</span> promise;    &#125;&#125;</code></pre></div><p>4.4 分析说明 <code>initAndRegister</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">initAndRegister</span><span class="hljs-params">()</span> </span>&#123;    Channel channel = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        channel = channelFactory.newChannel();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 说明：channelFactory.newChannel() 方法的作用通过 ServerBootstrap 的通道工厂反射创建一个 NioServerSocketChannel,具体追踪源码可以得到下面结论</span><span class="hljs-comment">         * (1)通过 NIO 的 SelectorProvider 的 openServerSocketChannel 方法得到 JDK 的 channel。目的是让 Netty 包装 JDK 的 channel。</span><span class="hljs-comment">         * (2)创建了一个唯一的 ChannelId，创建了一个 NioMessageUnsafe，用于操作消息，创建了一个 DefaultChannelPipeline 管道，是个双向链表结构，用于过滤所有的进出的消息。</span><span class="hljs-comment">         * (3)创建了一个 NioServerSocketChannelConfig 对象，用于对外展示一些配置。 </span><span class="hljs-comment">         </span><span class="hljs-comment">         * channel = channelFactory.newChannel();//NioServerSocketChannel</span><span class="hljs-comment"></span><span class="hljs-comment">         * 说明：init 初始化这个 NioServerSocketChannel，具体追踪源码可以得到如下结论</span><span class="hljs-comment">         * (1) init 方法，这是个抽象方法 (AbstractBootstrap类的），由ServerBootstrap实现（可以追一下源码//setChannelOptions(channel,options,logger);）。</span><span class="hljs-comment">         * (2)设置 NioServerSocketChannel 的 TCP 属性。</span><span class="hljs-comment">         * (3)由于 LinkedHashMap 是非线程安全的，使用同步进行处理。</span><span class="hljs-comment">         * (4)对 NioServerSocketChannel 的 ChannelPipeline 添加 ChannelInitializer 处理器。</span><span class="hljs-comment">         * (5)可以看出，init 的方法的核心作用在和 ChannelPipeline 相关。</span><span class="hljs-comment">         * (6)从 NioServerSocketChannel 的初始化过程中，我们知道，pipeline 是一个双向链表，并且，他本身就初始化了 head 和 tail，这里调用了他的 addLast 方法，也就是将整个 handler 插入到 tail 的前面，因为 tail 永远会在后面，需要做一些系统的固定工作。</span><span class="hljs-comment">         */</span>        init(channel);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;            channel.unsafe().closeForcibly();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);    &#125;    ChannelFuture regFuture = config().group().register(channel);    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;            channel.close();        &#125; <span class="hljs-keyword">else</span> &#123;            channel.unsafe().closeForcibly();        &#125;    &#125;    <span class="hljs-keyword">return</span> regFuture;&#125;</code></pre></div><p>说明：</p><ol><li>基本说明：<code>initAndRegister()</code> 初始化 <code>NioServerSocketChannel</code> 通道并注册各个 <code>handler</code>，返回一个 <code>future</code>。</li><li>通过 <code>ServerBootstrap</code> 的通道工厂反射创建一个 <code>NioServerSocketChannel</code>。</li><li><code>init</code> 初始化这个 <code>NioServerSocketChannel</code>。</li><li><code>config().group().register(channel)</code> 通过 <code>ServerBootstrap</code> 的 <code>bossGroup</code> 注册 <code>NioServerSocketChannel</code>。</li><li>最后，返回这个异步执行的占位符即 <code>regFuture</code>。</li></ol><p>4.5 <code>init</code> 方法会调用 <code>addLast</code>，现在进入到 <code>addLast</code> 方法内查看</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;        checkMultiplicity(handler);        newCtx = newContext(group, filterName(name, handler), handler);        addLast0(newCtx);        <span class="hljs-keyword">if</span> (!registered) &#123;            newCtx.setAddPending();            callHandlerCallbackLater(newCtx, <span class="hljs-keyword">true</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        EventExecutor executor = newCtx.executor();        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;            callHandlerAddedInEventLoop(newCtx, executor);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;    &#125;    callHandlerAdded0(newCtx);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre></div><p>说明：</p><ol><li><code>addLast</code> 方法，在 <code>DefaultChannelPipeline</code> 类中</li><li><code>addLast</code> 方法这就是 <code>pipeline</code> 方法的核心</li><li>检查该 <code>handler</code> 是否符合标准。</li><li>创建一个 <code>AbstractChannelHandlerContext</code> 对象，这里说一下，<code>ChannelHandlerContext</code> 对象是 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的关联，每当有 <code>ChannelHandler</code> 添加到 <code>Pipeline</code> 中时，都会创建 <code>Context</code>。<code>Context</code> 的主要功能是管理他所关联的 <code>Handler</code> 和同一个 <code>Pipeline</code> 中的其他 <code>Handler</code> 之间的交互。</li><li>将 <code>Context</code> 添加到链表中。也就是追加到 <code>tail</code> 节点的前面。</li><li>最后，同步或者异步或者晚点异步的调用 <code>callHandlerAdded0</code> 方法</li></ol><p>4.6 前面说了 <code>dobind</code> 方法有 <code>2</code> 个重要的步骤，<code>initAndRegister</code> 说完，接下来看 <code>doBind0</code> 方法，代码如下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind0</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> ChannelFuture regFuture, <span class="hljs-keyword">final</span> Channel channel,</span></span><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;    <span class="hljs-comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span>    <span class="hljs-comment">// the pipeline in its channelRegistered() implementation.</span>    channel.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (regFuture.isSuccess()) &#123;                <span class="hljs-comment">//bind方法这里下断点，这里下断点，来玩!!</span>                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);            &#125; <span class="hljs-keyword">else</span> &#123;                promise.setFailure(regFuture.cause());            &#125;        &#125;    &#125;);&#125;</code></pre></div><p>说明：</p><ol><li>该方法的参数为 <code>initAndRegister</code> 的 <code>future</code>，<code>NioServerSocketChannel</code>，端口地址，<code>NioServerSocketChannel</code> 的 <code>promise</code></li><li>这里就可以根据前面下的断点，一直 <code>debug</code>：</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 将调用 LoggingHandler 的 invokeBind 方法,最后会追到</span><span class="hljs-comment">// DefaultChannelPipeline 类的 bind</span><span class="hljs-comment">// 然后进入到 unsafe.bind 方法 debug，注意要追踪到</span><span class="hljs-comment">// unsafe.bind，要 debug 第二圈的时候，才能看到。</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span> <span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    unsafe.bind(localAddress,promise);&#125;<span class="hljs-comment">// 继续追踪 AbstractChannel 的 </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span> <span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;    <span class="hljs-comment">//....</span>    <span class="hljs-keyword">try</span>&#123;        <span class="hljs-comment">//!!!! 小红旗可以看到，这里最终的方法就是 doBind 方法，执行成功后，执行通道的 fireChannelActive 方法，告诉所有的 handler，已经成功绑定。</span>        doBind(localAddress);<span class="hljs-comment">//</span>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        safeSetFailure(promise, t);        closeIfClosed();        <span class="hljs-keyword">return</span>;    &#125;&#125;</code></pre></div><ol><li>最终 <code>doBind</code> 就会追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>，说明 <code>Netty</code> 底层使用的是 <code>NIO</code></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span> <span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;        javaChannel().bind(localAddress, config.getBacklog());    &#125; <span class="hljs-keyword">else</span> &#123;        javaChannel().socket().bind(localAddress, config.getBacklog());    &#125;&#125;</code></pre></div><ol><li>回到 <code>bind</code> 方法（<code>alt + v</code>），最后一步：<code>safeSetSuccess(promise)</code>，告诉 <code>promise</code> 任务成功了。其可以执行监听器的方法了。到此整个启动过程已经结束了，ok 了</li><li>继续 <code>atl + v</code> 服务器就回进入到（<code>NioEventLoop</code> 类）一个循环代码，进行监听</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(;;) &#123;        <span class="hljs-keyword">try</span>&#123;        &#125;    &#125;&#125;</code></pre></div><h4 id="10-2-4-Netty-启动过程梳理"><a href="#10-2-4-Netty-启动过程梳理" class="headerlink" title="10.2.4 Netty 启动过程梳理"></a>10.2.4 Netty 启动过程梳理</h4><ol><li>创建 <code>2</code> 个 <code>EventLoopGroup</code> 线程池数组。数组默认大小 <code>CPU * 2</code>，方便 <code>chooser</code> 选择线程池时提高性能</li><li><code>BootStrap</code> 将 <code>boss</code> 设置为 <code>group</code> 属性，将 <code>worker</code> 设置为 <code>childer</code> 属性</li><li>通过 <code>bind</code> 方法启动，内部重要方法为 <code>initAndRegister</code> 和 <code>dobind</code> 方法</li><li><code>initAndRegister</code> 方法会反射创建 <code>NioServerSocketChannel</code> 及其相关的 <code>NIO</code> 的对象，<code>pipeline</code>，<code>unsafe</code>，同时也为 <code>pipeline</code> 初始了 <code>head</code> 节点和 <code>tail</code> 节点。</li><li>在 <code>register0</code> 方法成功以后调用在 <code>dobind</code> 方法中调用 <code>doBind0</code> 方法，该方法会调用 <code>NioServerSocketChannel</code> 的 <code>doBind</code> 方法对 <code>JDK</code> 的 <code>channel</code> 和端口进行绑定，完成 <code>Netty</code> 服务器的所有启动，并开始监听连接事件。</li></ol><h3 id="10-3-Netty-接受请求过程源码剖析"><a href="#10-3-Netty-接受请求过程源码剖析" class="headerlink" title="10.3 Netty 接受请求过程源码剖析"></a>10.3 Netty 接受请求过程源码剖析</h3><h4 id="10-3-1-源码剖析目的"><a href="#10-3-1-源码剖析目的" class="headerlink" title="10.3.1 源码剖析目的"></a>10.3.1 源码剖析目的</h4><ol><li>服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，下面源码分析 <code>Netty</code> 在启动之后是如何接受客户端请求的</li><li>在 <code>io.netty.example</code> 包下</li></ol><h4 id="10-3-2-源码剖析"><a href="#10-3-2-源码剖析" class="headerlink" title="10.3.2 源码剖析"></a>10.3.2 源码剖析</h4><p>说明：</p><ol><li>从之前服务器启动的源码中，我们得知，服务器最终注册了一个 <code>Accept</code> 事件等待客户端的连接。我们也知道，<code>NioServerSocketChannel</code> 将自己注册到了 <code>boss</code> 单例线程池（<code>reactor</code> 线程）上，也就是 <code>EventLoop</code>。</li><li>先简单说下 <code>EventLoop</code> 的逻辑(后面我们详细讲解 <code>EventLoop</code>)</li></ol><p><code>EventLoop</code> 的作用是一个死循环，而这个循环中做 3 件事情：</p><ol><li><p>有条件的等待 <code>NIO</code> 事件。</p></li><li><p>处理 <code>NIO</code> 事件。</p></li><li><p>处理消息队列中的任务。</p></li><li><p>仍用前面的项目来分析：进入到 <code>NioEventLoop</code> 源码中后，在 <code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法开始调试最终我们要分析到 <code>AbstractNioChannel</code> 的 <code>doBeginRead</code> 方法，当到这个方法时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</p><p>源码分析过程</p></li><li><p>断点位置 <code>NioEventLoop</code> 的如下方法 <code>processSelectedKey</code></p></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;    unsafe.read();<span class="hljs-comment">//断点位置</span>&#125;</code></pre></div><ol><li>执行浏览器 <code>http://localhost:8007/</code> ，客户端发出请求</li><li>从的断点我们可以看到，<code>readyOps</code> 是 <code>16</code>，也就是 <code>Accept</code> 事件。说明浏览器的请求已经进来了。</li><li>这个 <code>unsafe</code> 是 <code>boss</code> 线程中 <code>NioServerSocketChannel</code> 的 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 对象。我们进入到 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 的 <code>read</code> 方法中</li><li><code>read</code> 方法代码并分析:</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    asserteventLoop().inEventLoop();    <span class="hljs-keyword">final</span> ChannelConfig config = config();    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();    allocHandle.reset(config);    booleanclosed = <span class="hljs-keyword">false</span>;    Throwable exception = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-keyword">int</span> localRead = doReadMessages(readBuf);                <span class="hljs-keyword">if</span> (localRead == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (localRead &lt; <span class="hljs-number">0</span>) &#123;                    closed = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;                                allocHandle.incMessagesRead(localRead);            &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            exception = t;        &#125;                <span class="hljs-keyword">int</span> size = readBuf.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            readPending = <span class="hljs-keyword">false</span>;            pipeline.fireChannelRead(readBuf.get(i));        &#125;        readBuf.clear();        allocHandle.readComplete();        pipeline.fireChannelReadComplete();                <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;            closed = closeOnReadError(exception);            pipeline.fireExceptionCaught(exception);        &#125;                <span class="hljs-keyword">if</span> (closed) &#123;            inputShutdown = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span>(isOpen()) &#123;                close(voidPromise());            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">//Check if there is a readPending which was not processed yet.</span>        <span class="hljs-comment">//This could be for two reasons:</span>        <span class="hljs-comment">//* The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span>        <span class="hljs-comment">//* The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span>        <span class="hljs-comment">//</span>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;            removeReadOp();        &#125;    &#125;&#125;</code></pre></div><p>说明： 1)检查该 <code>eventloop</code> 线程是否是当前线程。<code>asserteventLoop().inEventLoop()</code></p><p>2)执行 <code>doReadMessages</code> 方法，并传入一个 <code>readBuf</code> 变量，这个变量是一个 <code>List</code>，也就是容器。</p><p>3)循环容器，执行 <code>pipeline.fireChannelRead(readBuf.get(i));</code></p><p>4)<code>doReadMessages</code> 是读取 <code>boss</code> 线程中的 <code>NioServerSocketChannel</code> 接受到的请求。并把这些请求放进容器，一会我们 <code>debug</code> 下 <code>doReadMessages</code> 方法。</p><p>5)循环遍历容器中的所有请求，调用 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法，用于处理这些接受的请求或者其他事件，在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p><ol><li>追踪一下 <code>doReadMessages</code> 方法，就可以看得更清晰</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span> <span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    SocketChannel ch = SocketUtils.accept(javaChannel());    buf.add(newNioSocketChannel(<span class="hljs-keyword">this</span>, ch));    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><p>说明： 1)通过工具类，调用 <code>NioServerSocketChannel</code> 内部封装的 <code>serverSocketChannel</code> 的 <code>accept</code> 方法，这是 <code>NIO</code> 做法。</p><p>2)获取到一个 <code>JDK</code> 的 <code>SocketChannel</code>，然后，使用 <code>NioSocketChannel</code> 进行封装。最后添加到容器中</p><p>3)这样容器 <code>buf</code> 中就有了 <code>NioSocketChannel</code> 【如果有兴趣可以追一下 <code>NioSocketChannel</code> 是如何创建的，我就不追了】</p><ol><li>回到 <code>read</code> 方法，继续分析循环执行 <code>pipeline.fireChannelRead</code> 方法</li></ol><p>1)前面分析 <code>doReadMessages</code> 方法的作用是通过 <code>ServerSocket</code> 的 <code>accept</code> 方法获取到 <code>TCP</code> 连接，然后封装成 <code>Netty</code> 的 <code>NioSocketChannel</code> 对象。最后添加到容器中</p><p>2)在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p><p>3)经过 <code>dubug</code>（多次），可以看到会反复执行多个 <code>handler</code> 的 <code>ChannelRead</code>，我们知道，<code>pipeline</code> 里面又 <code>4</code> 个 <code>handler</code>，分别是 <code>Head</code>，<code>LoggingHandler</code>，<code>ServerBootstrapAcceptor</code>，<code>Tail</code>。</p><p>4)我们重点看看 <code>ServerBootstrapAcceptor</code>。<code>debug</code> 之后，断点会进入到 <code>ServerBootstrapAcceptor</code> 中来。我们来看看 <code>ServerBootstrapAcceptor</code> 的 <code>channelRead</code> 方法（要多次 <code>debug</code> 才可以）</p><p>5)<code>channelRead</code> 方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span> <span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;    <span class="hljs-keyword">final</span> Channelchild = (Channel)msg;    child.pipeline().addLast(childHandler);    setChannelOptions(child, childOptions, logger);    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e : childAttrs) &#123;        child.attr((AttributeKey&lt;Object&gt;)e.getKey()).set(e.getValue());    &#125;    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//将客户端连接注册到 worker 线程池</span>        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuturefuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;                    forceClose(child, future.cause());                &#125;            &#125;        &#125;);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        forceClose(child, t);    &#125;&#125;</code></pre></div><p>说明： 1)<code>msg</code> 强转成 <code>Channel</code>，实际上就是 <code>NioSocketChannel</code>。</p><p>2)添加 <code>NioSocketChannel</code> 的 <code>pipeline</code> 的 <code>handler</code>，就是我们 <code>main</code> 方法里面设置的 <code>childHandler</code> 方法里的。</p><p>3)设置 <code>NioSocketChannel</code> 的各种属性。</p><p>4)将该 <code>NioSocketChannel</code> 注册到 <code>childGroup</code> 中的一个 <code>EventLoop</code> 上，并添加一个监听器。</p><p>5)这个 <code>childGroup</code> 就是我们 <code>main</code> 方法创建的数组 <code>workerGroup</code>。</p><ol><li>进入 <code>register</code> 方法查看(步步追踪会到)</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span> <span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;        register0(promise);    &#125; <span class="hljs-keyword">else</span> &#123;        eventLoop.execute(<span class="hljs-keyword">new</span> Runnable()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                register0(promise);<span class="hljs-comment">//进入到这里</span>            &#125;        &#125;);    &#125;&#125;<span class="hljs-comment">// 继续进入到下面方法，执行管道中可能存在的任务,这里我们就不追了</span></code></pre></div><ol><li>最终会调用 <code>doBeginRead</code> 方法，也就是 <code>AbstractNioChannel</code> 类的方法</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">//Channel.read() or ChannelHandlerContext.read() was called</span>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<span class="hljs-comment">//断点</span>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;        <span class="hljs-keyword">return</span>;    &#125;    readPending = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();    <span class="hljs-keyword">if</span> ((interestOps&amp;readInterestOp) == <span class="hljs-number">0</span>) &#123;        selectionKey.interestOps(interestOps | readInterestOp);    &#125;&#125;</code></pre></div><ol><li>这个地方调试时，请把前面的断点都去掉，然后启动服务器就会停止在 <code>doBeginRead</code>（需要先放过该断点，然后浏览器请求，才能看到效果）</li><li>执行到这里时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</li></ol><h4 id="10-3-3-Netty-接受请求过程梳理"><a href="#10-3-3-Netty-接受请求过程梳理" class="headerlink" title="10.3.3 Netty 接受请求过程梳理"></a>10.3.3 Netty 接受请求过程梳理</h4><p>总体流程：接受连接 –&gt; 创建一个新的 <code>NioSocketChannel</code> –&gt; 注册到一个 <code>workerEventLoop</code> 上 –&gt; 注册 <code>selecotRead</code> 事件。</p><ol><li>服务器轮询 <code>Accept</code> 事件，获取事件后调用 <code>unsafe</code> 的 <code>read</code> 方法，这个 <code>unsafe</code> 是 <code>ServerSocket</code> 的内部类，该方法内部由 <code>2</code> 部分组成</li><li><code>doReadMessages</code> 用于创建 <code>NioSocketChannel</code> 对象，该对象包装 <code>JDK</code> 的 <code>NioChannel</code> 客户端。该方法会像创建 <code>ServerSocketChanel</code> 类似创建相关的 <code>pipeline</code>，<code>unsafe</code>，<code>config</code></li><li>随后执行执行 <code>pipeline.fireChannelRead</code> 方法，并将自己绑定到一个 <code>chooser</code> 选择器选择的 <code>workerGroup</code> 中的一个 <code>EventLoop</code>。并且注册一个 <code>0</code>，表示注册成功，但并没有注册读（1）事件</li></ol><h3 id="10-4-Pipeline-Handler-HandlerContext-创建源码剖析"><a href="#10-4-Pipeline-Handler-HandlerContext-创建源码剖析" class="headerlink" title="10.4 Pipeline Handler HandlerContext 创建源码剖析"></a>10.4 Pipeline Handler HandlerContext 创建源码剖析</h3><h4 id="10-4-1-源码剖析目的"><a href="#10-4-1-源码剖析目的" class="headerlink" title="10.4.1 源码剖析目的"></a>10.4.1 源码剖析目的</h4><p><code>Netty</code> 中的 <code>ChannelPipeline</code>、<code>ChannelHandler</code> 和 <code>ChannelHandlerContext</code> 是非常核心的组件，我们从源码来分析 <code>Netty</code> 是如何设计这三个核心组件的，并分析是如何创建和协调工作的.</p><h4 id="10-4-2-源码剖析说明"><a href="#10-4-2-源码剖析说明" class="headerlink" title="10.4.2 源码剖析说明"></a>10.4.2 源码剖析说明</h4><p>说明 分析过程中，有很多的图形，所以我们准备了一个文档，在文档的基础上来做源码剖析</p><h4 id="10-4-3-源码剖析"><a href="#10-4-3-源码剖析" class="headerlink" title="10.4.3 源码剖析"></a>10.4.3 源码剖析</h4><ol><li>ChannelPipeline | ChannelHandler | ChannelHandlerContext介绍</li><li>1 三者关系</li></ol><p>1)每当 <code>ServerSocket</code> 创建一个新的连接，就会创建一个 <code>Socket</code>，对应的就是目标客户端。</p><p>2)每一个新创建的 <code>Socket</code> 都将会分配一个全新的 <code>ChannelPipeline</code>（以下简称 <code>pipeline</code>）</p><p>3)每一个 <code>ChannelPipeline</code> 内部都含有多个 <code>ChannelHandlerContext</code>（以下简称 <code>Context</code>）</p><p>4)他们一起组成了双向链表，这些 <code>Context</code> 用于包装我们调用 <code>addLast</code> 方法时添加的 <code>ChannelHandler</code>（以下简称 <code>handler</code>）</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_02.png" alt="img"></p><p>1)上图中：<code>ChannelSocket</code> 和 <code>ChannelPipeline</code> 是一对一的关联关系，而 <code>pipeline</code> 内部的多个 <code>Context</code> 形成了链表，<code>Context</code> 只是对 <code>Handler</code> 的封装。 2)当一个请求进来的时候，会进入 <code>Socket</code> 对应的 <code>pipeline</code>，并经过 <code>pipeline</code> 所有的 <code>handler</code>，对，就是设计模式中的过滤器模式。</p><p>1.2 ChannelPipeline 作用及设计</p><p>1)<code>pipeline</code> 的接口设计</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_03.png" alt="img"></p><p>部分源码</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_04.png" alt="img"></p><p>可以看到该接口继承了 <code>inBound</code>，<code>outBound</code>，<code>Iterable</code> 接口，表示他可以调用数据出站的方法和入站的方法，同时也能遍历内部的链表，看看他的几个代表性的方法，基本上都是针对 <code>handler</code> 链表的插入，追加，删除，替换操作，类似是一个 <code>LinkedList</code>。同时，也能返回 <code>channel</code>（也就是 <code>socket</code>）</p><p>1)在 <code>pipeline</code> 的接口文档上，提供了一幅图</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_05.png" alt="img"></p><p>对上图的解释说明： *这是一个 <code>handler</code> 的 <code>list</code>，<code>handler</code> 用于处理或拦截入站事件和出站事件，<code>pipeline</code> 实现了过滤器的高级形式，以便用户控制事件如何处理以及 <code>handler</code> 在 <code>pipeline</code> 中如何交互。</p><p>*上图描述了一个典型的 <code>handler</code> 在 <code>pipeline</code> 中处理 <code>I/O</code> 事件的方式，<code>IO</code> 事件由 <code>inboundHandler</code> 或者 <code>outBoundHandler</code> 处理，并通过调用 <code>ChannelHandlerContext.fireChannelRead</code> 方法转发给其最近的处理程序。</p><p>*入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的 <code>I/O</code> 线程生成入站数据。入站数据通常从如 <code>SocketChannel.read(ByteBuffer)</code> 获取。</p><p>*通常一个 <code>pipeline</code> 有多个 <code>handler</code>，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序协议解码器-将二进制数据转换为 <code>Java</code> 对象。协议编码器-将 <code>Java</code> 对象转换为二进制数据。业务逻辑处理程序-执行实际业务逻辑（例如数据库访问）</p><p>*你的业务程序不能将线程阻塞，会影响 <code>IO</code> 的速度，进而影响整个 <code>Netty</code> 程序的性能。如果你的业务程序很快，就可以放在 <code>IO</code> 线程中，反之，你需要异步执行。或者在添加 <code>handler</code> 的时候添加一个线程池，例如：</p><p>// 下面这个任务执行的时候，将不会阻塞 <code>IO</code> 线程，执行的线程来自 <code>group</code> 线程池</p><div class="code-wrapper"><pre><code class="hljs reasonml">pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">group</span>, <span class="hljs-string">&quot;handler&quot;</span>, <span class="hljs-params">new</span> MyBusinessLogicHandler()</span>);</code></pre></div><p>1.3 <code>ChannelHandler</code> 作用及设计</p><p>1)源码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelHandler</span> </span>&#123;    <span class="hljs-comment">//当把 ChannelHandler 添加到 pipeline 时被调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-comment">//当从 pipeline 中移除时调用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-comment">//当处理过程中在 pipeline 发生异常时调用</span>    <span class="hljs-meta">@Deprecated</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre></div><p>2)<code>ChannelHandler</code> 的作用就是处理 <code>IO</code> 事件或拦截 <code>IO</code> 事件，并将其转发给下一个处理程序 <code>ChannelHandler</code>。<code>Handler</code> 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，<code>Netty</code> 定义了两个子接口继承 <code>ChannelHandler</code></p><p>2)<code>ChannelInboundHandler</code> 入站事件接口</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_06.png" alt="img"></p><p>*<code>channelActive</code> 用于当 <code>Channel</code> 处于活动状态时被调用；</p><p>*<code>channelRead</code> 当从 <code>Channel</code> 读取数据时被调用等等方法。</p><p>*程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，<code>Netty</code> 会回调对应的方法。</p><p>3)`ChannelOutboundHandler 出站事件接口</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_07.png" alt="img"></p><p>*<code>bind</code> 方法，当请求将 <code>Channel</code> 绑定到本地地址时调用</p><p>*<code>close</code> 方法，当请求关闭 <code>Channel</code> 时调用等等</p><p>*出站操作都是一些连接和写出数据类似的方法。</p><p>4)<code>ChannelDuplexHandler</code> 处理出站和入站事件</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_08.png" alt="img"></p><p>*<code>ChannelDuplexHandler</code> 间接实现了入站接口并直接实现了出站接口。</p><p>*是一个通用的能够同时处理入站事件和出站事件的类。</p><p>1.4 <code>ChannelHandlerContext</code> 作用及设计</p><p>1)<code>ChannelHandlerContext</code> <code>UML</code> 图</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_09.png" alt="img"></p><p><code>ChannelHandlerContext</code> 继承了出站方法调用接口和入站方法调用接口</p><p>1)<code>ChannelOutboundInvoker</code> 和 <code>ChannelInboundInvoker</code> 部分源码</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_10.png" alt="img"></p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_11.png" alt="img"></p><p>*这两个 <code>invoker</code> 就是针对入站或出站方法来的，就是在入站或出站 <code>handler</code> 的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的</p><p>2)<code>ChannelHandlerContext</code> 部分源码</p><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_12.png" alt="img"></p><p>*<code>ChannelHandlerContext</code> 不仅仅时继承了他们两个的方法，同时也定义了一些自己的方法</p><p>*这些方法能够获取 <code>Context</code> 上下文环境中对应的比如 <code>channel</code>，<code>executor</code>，<code>handler</code>，<code>pipeline</code>，内存分配器，关联的 <code>handler</code> 是否被删除。</p><p>*<code>Context</code> 就是包装了 <code>handler</code> 相关的一切，以方便 <code>Context</code> 可以在 <code>pipeline</code> 方便的操作 <code>handler</code></p><p>2.ChannelPipeline | ChannelHandler | ChannelHandlerContext</p><p>创建过程分为 <code>3</code> 个步骤来看创建的过程：</p><p>*任何一个 <code>ChannelSocket</code> 创建的同时都会创建一个 <code>pipeline</code>。</p><p>*当用户或系统内部调用 <code>pipeline</code> 的 <code>add</code></p><p>*** 方法添加 <code>handler</code> 时，都会创建一个包装这 <code>handler</code> 的 <code>Context</code>。</p><p>*这些 <code>Context</code> 在 <code>pipeline</code> 中组成了双向链表。</p><p>2.1 <code>Socket</code> 创建的时候创建 <code>pipeline</code> 在 <code>SocketChannel</code> 的抽象父类 <code>AbstractChannel</code> 的构造方法中</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractChannel</span><span class="hljs-params">(Channel parent)</span> </span>&#123;    <span class="hljs-keyword">this</span>.parent=parent;<span class="hljs-comment">//断点测试</span>    id = newId();    unsafe = <span class="hljs-keyword">new</span> Unsafe();    pipeline = <span class="hljs-keyword">new</span> ChannelPipeline();&#125;</code></pre></div><p><code>Debug</code> 一下，可以看到代码会执行到这里，然后继续追踪到</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">DefaultChannelPipeline</span><span class="hljs-params">(Channel channel)</span> </span>&#123;    <span class="hljs-keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="hljs-string">&quot;channel&quot;</span>);    succeededFuture = <span class="hljs-keyword">new</span> SucceededChannelFuture(channel, <span class="hljs-keyword">null</span>);    voidPromise = <span class="hljs-keyword">new</span> VoidChannelPromise(channel, <span class="hljs-keyword">true</span>);    tail = <span class="hljs-keyword">new</span> TailContext(<span class="hljs-keyword">this</span>);    head = <span class="hljs-keyword">new</span> HeadContext(<span class="hljs-keyword">this</span>);    head.next = tail;    tail.prev = head;&#125;</code></pre></div><p>说明：</p><p>1）将 <code>channel</code> 赋值给 <code>channel</code> 字段，用于 <code>pipeline</code> 操作 <code>channel</code>。</p><p>2）创建一个 <code>future</code> 和 <code>promise</code>，用于异步回调使用。</p><p>3）创建一个 <code>inbound</code> 的 <code>tailContext</code>，创建一个既是 <code>inbound</code> 类型又是 <code>outbound</code> 类型的 <code>headContext</code>。</p><p>4）最后，将两个 <code>Context</code> 互相连接，形成双向链表。</p><p>5）<code>tailContext</code> 和 <code>HeadContext</code> 非常的重要，所有 <code>pipeline</code> 中的事件都会流经他们，</p><p>2.2 在 add<strong>添加处理器的时候创建Context</strong>看下 <code>DefaultChannelPipeline</code> 的 <code>addLast</code> 方法如何创建的 <code>Context</code>，代码如下</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;    <span class="hljs-keyword">if</span> (handlers == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//断点</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;handlers&quot;</span>);    &#125;    <span class="hljs-keyword">for</span> (ChannelHandler h : handlers) &#123;        <span class="hljs-keyword">if</span> (h == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        addLast(executor, <span class="hljs-keyword">null</span>, h);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre></div><p>继续 Debug</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;        checkMultiplicity(handler);        newCtx = newContext(group, filterName(name, handler), handler);        addLast0(newCtx);        <span class="hljs-comment">//If the registered is false it means that the channel was not registered on an eventloop yet.</span>        <span class="hljs-comment">//In this case we add the context to the pipeline and add a task that will call</span>        <span class="hljs-comment">//ChannelHandler.handlerAdded(...) once the channel is registered.</span>        <span class="hljs-keyword">if</span> (!registered) &#123;            newCtx.setAddPending();            callHandlerCallbackLater(newCtx, <span class="hljs-keyword">true</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;        EventExecutor executor = newCtx.executor();        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;            newCtx.setAddPending();            executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>&#123;                    callHandlerAdded0(newCtx);                &#125;            &#125;);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;        &#125;    &#125;    callHandlerAdded0(newCtx);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre></div><p>说明 1)<code>pipeline</code> 添加 <code>handler</code>，参数是线程池，<code>name</code> 是 <code>null</code>，<code>handler</code> 是我们或者系统传入的 <code>handler</code>。<code>Netty</code> 为了防止多个线程导致安全问题，同步了这段代码，步骤如下：</p><p>2)检查这个 <code>handler</code> 实例是否是共享的，如果不是，并且已经被别的 <code>pipeline</code> 使用了，则抛出异常。</p><p>3)调用 <code>new Context(group, filterName(name, handler), handler)</code> 方法，创建一个 <code>Context</code>。从这里可以看出来了，每次添加一个 <code>handler</code> 都会创建一个关联 <code>Context</code>。</p><p>4)调用 <code>addLast</code> 方法，将 <code>Context</code> 追加到链表中。</p><p>5)如果这个通道还没有注册到 <code>selecor</code> 上，就将这个 <code>Context</code> 添加到这个 <code>pipeline</code> 的待办任务中。当注册好了以后，就会调用 <code>callHandlerAdded0</code> 方法（默认是什么都不做，用户可以实现这个方法）。</p><p>6)到这里，针对三对象创建过程，了解的差不多了，和最初说的一样，每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。<code>tail</code> 是入站 <code>inbound</code> 类型的 <code>handler</code>，<code>head</code> 既是 <code>inbound</code> 也是 <code>outbound</code> 类型的 <code>handler</code>。在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。到此就 <code>OK</code> 了。</p><h4 id="10-4-4-Pipeline-Handler-HandlerContext-创建过程梳理"><a href="#10-4-4-Pipeline-Handler-HandlerContext-创建过程梳理" class="headerlink" title="10.4.4 Pipeline Handler HandlerContext 创建过程梳理"></a>10.4.4 Pipeline Handler HandlerContext 创建过程梳理</h4><ol><li>每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。</li><li>在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。</li><li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表</li><li>入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始</li></ol><h3 id="10-5-ChannelPipeline-调度-handler-的源码剖析"><a href="#10-5-ChannelPipeline-调度-handler-的源码剖析" class="headerlink" title="10.5 ChannelPipeline 调度 handler 的源码剖析"></a>10.5 ChannelPipeline 调度 handler 的源码剖析</h3><h4 id="10-5-1-源码剖析目的"><a href="#10-5-1-源码剖析目的" class="headerlink" title="10.5.1 源码剖析目的"></a>10.5.1 源码剖析目的</h4><ol><li>当一个请求进来的时候，<code>ChannelPipeline</code> 是如何调用内部的这些 <code>handler</code> 的呢？我们一起来分析下。</li><li>首先，当一个请求进来的时候，会第一个调用 <code>pipeline</code> 的相关方法，如果是入站事件，这些方法由 <code>fire</code> 开头，表示开始管道的流动。让后面的 <code>handler</code> 继续处理</li></ol><h4 id="10-5-2-源码剖析"><a href="#10-5-2-源码剖析" class="headerlink" title="10.5.2 源码剖析"></a>10.5.2 源码剖析</h4><p>当浏览器输入 <code>http://localhost:8007</code> 。可以看到会执行 <code>handler</code> 在 <code>Debug</code> 时，可以将断点下在 <code>DefaultChannelPipeline</code> 类的</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelActive</span><span class="hljs-params">()</span> </span>&#123;    AbstractChannelHandlerContext.invokeChannelActive(head);<span class="hljs-comment">//断点</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre></div><p>源码分析</p><ol><li><code>DefaultChannelPipeline</code> 是如何实现这些 <code>fire</code> 方法的 3.1 <code>DefaultChannelPipeline</code> 源码</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultChannelPipeline</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelPipeline</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelActive</span><span class="hljs-params">()</span> </span>&#123;        AbstractChannelHandlerContext.invokeChannelActive(head);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-title">ChannelPipelinefireChannelInactive</span><span class="hljs-params">()</span> </span>&#123;        AbstractChannelHandlerContext.invokeChannelInactive(head);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireExceptionCaught</span><span class="hljs-params">(Throwable cause)</span> </span>&#123;        AbstractChannelHandlerContext.invokeExceptionCaught(head, cause);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireUserEventTriggered</span><span class="hljs-params">(Object event)</span> </span>&#123;        AbstractChannelHandlerContext.invokeUserEventTriggered(head, event);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelRead</span><span class="hljs-params">(Objectmsg)</span> </span>&#123;        AbstractChannelHandlerContext.invokeChannelRead(head, msg);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelReadComplete</span><span class="hljs-params">()</span> </span>&#123;        AbstractChannelHandlerContext.invokeChannelReadComplete(head);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelWritabilityChanged</span><span class="hljs-params">()</span> </span>&#123;        AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;</code></pre></div><p>说明： 可以看出来，这些方法都是 <code>inbound</code> 的方法，也就是入站事件，调用静态方法传入的也是 <code>inbound</code> 的类型 <code>head</code> <code>handler</code>。这些静态方法则会调用 <code>head</code> 的 <code>ChannelInboundInvoker</code> 接口的方法，再然后调用 <code>handler</code> 的真正方法</p><p>3.2再看下 <code>piepline</code> 的 <code>outbound</code> 的 <code>fire</code> 方法实现源码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultChannelPipeline</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelPipeline</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.bind(localAddress);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.connect(remoteAddress);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, localAddress);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> tail.disconnect();    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.close();    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">deregister</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.deregister();    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;        tail.flush();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.bind(localAddress, promise);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, promise);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, localAddress, promise);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;        <span class="hljs-keyword">return</span> tail.disconnect(promise);    &#125;&#125;</code></pre></div><p>说明：</p><p>1)这些都是出站的实现，但是调用的是 <code>outbound</code> 类型的 <code>tailhandler</code> 来进行处理，因为这些都是 <code>outbound</code> 事件。</p><p>2)出站是 <code>tail</code> 开始，入站从 <code>head</code> 开始。因为出站是从内部向外面写，从 <code>tail</code> 开始，能够让前面的 <code>handler</code> 进行处理，防止 <code>handler</code> 被遗漏，比如编码。反之，入站当然是从 <code>head</code> 往内部输入，让后面的 <code>handler</code> 能够处理这些输入的数据。比如解码。因此虽然 <code>head</code> 也实现了 <code>outbound</code> 接口，但不是从 head 开始执行出站任务</p><p>4.关于如何调度，用一张图来表示:</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_13.png" alt="img"></p><p>说明： 1)<code>pipeline</code> 首先会调用 <code>Context</code> 的静态方法 <code>fireXXX</code>，并传入 <code>Context</code></p><p>2)然后，静态方法调用 <code>Context</code> 的 <code>invoker</code> 方法，而 <code>invoker</code> 方法内部会调用该 <code>Context</code> 所包含的 <code>Handler</code> 的真正的 <code>XXX</code> 方法，调用结束后，如果还需要继续向后传递，就调用 <code>Context</code> 的 <code>fireXXX2</code> 方法，循环往复。</p><h4 id="10-5-3-ChannelPipeline-调度-handler-梳理"><a href="#10-5-3-ChannelPipeline-调度-handler-梳理" class="headerlink" title="10.5.3 ChannelPipeline 调度 handler 梳理"></a>10.5.3 ChannelPipeline 调度 handler 梳理</h4><ol><li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表，入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始。</li><li>而节点中间的传递通过 <code>Abstract ChannelHandlerContext</code> 类内部的 <code>fire</code> 系列方法，找到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对 <code>handler</code> 的调度</li></ol><h3 id="10-6-Netty-心跳-heartbeat-服务源码剖析"><a href="#10-6-Netty-心跳-heartbeat-服务源码剖析" class="headerlink" title="10.6 Netty 心跳(heartbeat)服务源码剖析"></a>10.6 Netty 心跳(heartbeat)服务源码剖析</h3><h4 id="10-6-1-源码剖析目的"><a href="#10-6-1-源码剖析目的" class="headerlink" title="10.6.1 源码剖析目的"></a>10.6.1 源码剖析目的</h4><p><code>Netty</code> 作为一个网络框架，提供了诸多功能，比如编码解码等，<code>Netty</code> 还提供了非常重要的一个服务 – 心跳机制 <code>heartbeat</code>。通过心跳检查对方是否有效，这是 <code>RPC</code> 框架中是必不可少的功能。下面我们分析一下 <code>Netty</code> 内部心跳服务源码实现。</p><h4 id="10-6-2-源码剖析"><a href="#10-6-2-源码剖析" class="headerlink" title="10.6.2 源码剖析"></a>10.6.2 源码剖析</h4><p><code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性，重点分析 <code>IdleStateHandler</code>。</p><p>如图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_14.png" alt="img"></p><p>源码剖析：</p><p>5.<code>Netty</code> 提供的心跳介绍</p><p>1)<code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性。</p><p>2)如图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_15.png" alt="img"></p><p>3)<code>ReadTimeout</code> 事件和 <code>WriteTimeout</code> 事件都会自动关闭连接，而且，属于异常处理，所以，这里只是介绍以下，我们重点看 <code>IdleStateHandler</code>。</p><p>6.<code>IdleStateHandler</code> 分析</p><p>6.1 <code>4</code> 个属性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> observeOutput; <span class="hljs-comment">//是否考虑出站时较慢的情况。默认值是 false</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> readerIdleTimeNanos; <span class="hljs-comment">//读事件空闲时间，0 则禁用事件</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> writerIdleTimeNanos;<span class="hljs-comment">//写事件空闲时间，0 则禁用事件</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> allIdleTimeNanos;<span class="hljs-comment">//读或写空闲时间，0 则禁用事件</span></code></pre></div><p>6.2<code>handlerAdded</code> 方法</p><p>当该 <code>handler</code> 被添加到 <code>pipeline</code> 中时，则调用 <code>initialize</code> 方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;    <span class="hljs-comment">//Avoid the case where destroy() is called before scheduling timeouts.</span>    <span class="hljs-comment">//See:https://github.com/netty/netty/issues/143</span>    <span class="hljs-keyword">switch</span>(state) &#123;        case1:        case2:            <span class="hljs-keyword">return</span>;    &#125;        state=<span class="hljs-number">1</span>;    initOutputChanged(ctx);        lastReadTime = lastWriteTime = ticksInNanos();        <span class="hljs-keyword">if</span>(readerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列中</span>        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> ReaderIdleTimeoutTask(ctx), readerIdleTimeNanos, TimeUnit.NANOSECONDS);    &#125;        <span class="hljs-keyword">if</span>(writerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> WriterIdleTimeoutTask(ctx), writerIdleTimeNanos, TimeUnit.NANOSECONDS);    &#125;        <span class="hljs-keyword">if</span>(allIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> AllIdleTimeoutTask(ctx), allIdleTimeNanos, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre></div><p>只要给定的参数大于 <code>0</code>，就创建一个定时任务，每个事件都创建。同时，将 <code>state</code> 状态设置为 <code>1</code>，防止重复初始化。调用 <code>initOutputChanged</code> 方法，初始化“监控出站数据属性”。</p><p>6.3该类内部的 <code>3</code> 个定时任务类</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_16.png" alt="img"></p><p>1)这 <code>3</code> 个定时任务分别对应读，写，读或者写事件。共有一个父类（<code>AbstractIdleTask</code>）。这个父类提供了一个模板方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractIdleTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelHandlerContext ctx;        AbstractIdleTask(ChannelHandlerContext ctx) &#123;        <span class="hljs-keyword">this</span>.ctx = ctx;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(!ctx.channel().isOpen()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        run(ctx);    &#125;        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>;&#125;</code></pre></div><p>说明：当通道关闭了，就不执行任务了。反之，执行子类的 <code>run</code> 方法</p><p>7.读事件的 <code>run</code> 方法（即 <code>ReaderIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>1)代码及其说明</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;    <span class="hljs-keyword">long</span> nextDelay = readerIdleTimeNanos;    <span class="hljs-keyword">if</span>(!reading) &#123;        nextDelay -= ticksInNanos() - lastReadTime;    &#125;        <span class="hljs-keyword">if</span>(nextDelay &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//Reader is idle-set a new timeout and notify the callback.</span>        <span class="hljs-comment">//用于取消任务 promise</span>        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);        <span class="hljs-keyword">boolean</span> first = firstReaderIdleEvent;        firstReaderIdleEvent = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//再次提交任务</span>            IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.READER_IDLE, first);            <span class="hljs-comment">//触发用户 handler use</span>            channelIdle(ctx, event);        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            ctx.fireExceptionCaught(t);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//Read occurred before the timeout - set a new timeout with shorter delay.</span>        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre></div><p>说明：</p><p>1)得到用户设置的超时时间。</p><p>2)如果读取操作结束了（执行了 <code>channelReadComplete</code> 方法设置），就用当前时间减去给定时间和最后一次读（执操作的时间行了 <code>channelReadComplete</code> 方法设置），如果小于 <code>0</code>，就触发事件。反之，继续放入队列。间隔时间是新的计算时间。</p><p>3)触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个 <code>promise</code> 对象，用于做取消操作。然后，设置 <code>first</code> 属性为<code>false</code>，表示，下一次读取不再是第一次了，这个属性在 <code>channelRead</code> 方法会被改成 <code>true</code>。</p><p>4)创建一个 <code>IdleStateEvent</code> 类型的写事件对象，将此对象传递给用户的 <code>UserEventTriggered</code> 方法。完成触发事件的操作。</p><p>5)总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发 <code>UserEventTriggered</code> 方法。//前面介绍 <code>IdleStateHandler</code> 说过,可以看一下</p><p>8.写事件的 <code>run</code> 方法（即 <code>WriterIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>1)<code>run</code> 代码和分析</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;    <span class="hljs-keyword">long</span> lastWriteTime = IdleStateHandler.<span class="hljs-keyword">this</span>.lastWriteTime;    <span class="hljs-keyword">long</span> nextDelay = writerIdleTimeNanos - (ticksInNanos()-lastWriteTime);    <span class="hljs-keyword">if</span> (nextDelay &lt;=<span class="hljs-number">0</span> ) &#123;        <span class="hljs-comment">//Writer is idle - set a new timeout and notify the callback.</span>        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, writerIdleTimeNanos, TimeUnit.NANOSECONDS);        <span class="hljs-keyword">boolean</span> first = firstWriterIdleEvent;        firstWriterIdleEvent = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(hasOutputChanged(ctx, first)) &#123;                <span class="hljs-keyword">return</span>;            &#125;                        IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.WRITER_IDLE, first);            channelIdle(ctx, event);        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            ctx.fireExceptionCaught(t);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//Write occurred before the timeout - set a new timeout with shorter delay.</span>        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre></div><p>说明：写任务的 <code>run</code> 代码逻辑基本和读任务的逻辑一样，唯一不同的就是有一个针对出站较慢数据的判断 <code>hasOutputChanged</code></p><p>9.所有事件的 <code>run</code> 方法（即 <code>AllIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>代码分析</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;    <span class="hljs-keyword">long</span> nextDelay = allIdleTimeNanos;    <span class="hljs-keyword">if</span>(!reading) &#123;        nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);    &#125;        <span class="hljs-keyword">if</span>(nextDelay &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//Both reader and writer are idle - set a new timeout and</span>        <span class="hljs-comment">//notify the callback.</span>        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, allIdleTimeNanos, TimeUnit.NANOSECONDS);        <span class="hljs-keyword">boolean</span> first = firstAllIdleEvent;        firstAllIdleEvent = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(hasOutputChanged(ctx, first)) &#123;                <span class="hljs-keyword">return</span>;            &#125;                        IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.ALL_IDLE, first);            channelIdle(ctx, event);        &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;            ctx.fireExceptionCaught(t);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//Either read or write occurred before the timeout - set a new</span>        <span class="hljs-comment">//timeout with shorter delay.</span>        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre></div><p>说明：</p><p>1)表示这个监控着所有的事件。当读写事件发生时，都会记录。代码逻辑和写事件的的基本一致：</p><p>2)需要大家注意的地方是</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">long</span> nextDelay = allIdleTimeNanos;<span class="hljs-keyword">if</span>(!reading) &#123;    <span class="hljs-comment">//当前时间减去最后一次写或读的时间，若大于 0，说明超时了</span>    nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);&#125;</code></pre></div><p>3)这里的时间计算是取读写事件中的最大值来的。然后像写事件一样，判断是否发生了写的慢的情况。</p><p>10.小结 <code>Netty</code> 的心跳机制</p><p>1)<code>IdleStateHandler</code> 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 <code>handler</code> 的 <code>userEventTriggered</code> 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接。</p><p>2)<code>IdleStateHandler</code> 的实现基于 <code>EventLoop</code> 的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。</p><p>3)内部有 <code>3</code> 个定时任务，分别对应读事件，写事件，读写事件。通常用户监听读写事件就足够了。</p><p>4)同时，<code>IdleStateHandler</code> 内部也考虑了一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间。<code>Netty</code> 通过构造方法中的 <code>observeOutput</code> 属性来决定是否对出站缓冲区的情况进行判断。</p><p>5)如果出站缓慢，<code>Netty</code> 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，可能造成 <code>OOM</code>，<code>OOM</code> 比空闲的问题更大。</p><p>6)所以，当你的应用出现了内存溢出，<code>OOM</code> 之类，并且写空闲极少发生（使用了 <code>observeOutput</code> 为 <code>true</code>），那么就需要注意是不是数据出站速度过慢。</p><p>7)还有一个注意的地方：就是 <code>ReadTimeoutHandler</code>，它继承自 <code>IdleStateHandler</code>，当触发读空闲事件的时候，就触发 <code>ctx</code>. <code>fireExceptionCaught</code> 方法，并传入一个 <code>ReadTimeoutException</code>，然后关闭 <code>Socket</code>。</p><p>8)而 <code>WriteTimeoutHandler</code> 的实现不是基于 <code>IdleStateHandler</code> 的，他的原理是，当调用 <code>write</code> 方法的时候，会创建一个定时任务，任务内容是根据传入的 <code>promise</code> 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 <code>promise</code> 的 <code>isDone</code> 方法返回 <code>false</code>，表明还没有写完，说明超时了，则抛出异常。当 <code>write</code> 方法完成后，会打断定时任务。</p><h3 id="10-7-Netty-核心组件-EventLoop-源码剖析"><a href="#10-7-Netty-核心组件-EventLoop-源码剖析" class="headerlink" title="10.7 Netty 核心组件 EventLoop 源码剖析]"></a>10.7 Netty 核心组件 EventLoop 源码剖析]</h3><h4 id="10-7-1-源码剖析目的"><a href="#10-7-1-源码剖析目的" class="headerlink" title="10.7.1 源码剖析目的"></a>10.7.1 源码剖析目的</h4><p><code>Echo</code> 第一行代码就是：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1)</code>; 下面分析其最核心的组件 <code>EventLoop</code>。</p><h4 id="10-7-2-源码剖析"><a href="#10-7-2-源码剖析" class="headerlink" title="10.7.2 源码剖析"></a>10.7.2 源码剖析</h4><p>源码剖析</p><p>1.<code>EventLoop</code>介绍 1.1首先看看 <code>NioEventLoop</code> 的继承图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_17.png" alt="img"></p><p>说明重点： 1)<code>ScheduledExecutorService</code> 接口表示是一个定时任务接口，<code>EventLoop</code> 可以接受定时任务。</p><p>2)<code>EventLoop</code> 接口：<code>Netty</code> 接口文档说明该接口作用：一旦 <code>Channel</code> 注册了，就处理该 <code>Channel</code> 对应的所有 <code>I/O</code> 操作。</p><p>3)<code>SingleThreadEventExecutor</code> 表示这是一个单个线程的线程池</p><p>4)<code>EventLoop</code> 是一个单例的线程池，里面含有一个死循环的线程不断的做着 <code>3</code> 件事情：监听端口，处理端口事件，处理队列事件。每个 <code>EventLoop</code> 都可以绑定多个 <code>Channel</code>，而每个 <code>Channel</code> 始终只能由一个 <code>EventLoop</code> 来处理</p><ol><li><code>NioEventLoop</code> 的使用 - <code>execute</code> 方法</li></ol><p>2.1 <code>execute</code> 源码剖析</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_18.png" alt="img"></p><p>在 <code>EventLoop</code> 的使用，一般就是 <code>eventloop.execute(task);</code> 看下 <code>execute</code> 方法的实现(在 <code>SingleThreadEventExecutor</code> 类中)</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;    <span class="hljs-keyword">if</span>(task == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);    &#125;    <span class="hljs-keyword">boolean</span> inEventLoop = inEventLoop();    <span class="hljs-keyword">if</span>(inEventLoop) &#123;        addTask(task);    &#125; <span class="hljs-keyword">else</span> &#123;        startThread();        addTask(task);        <span class="hljs-keyword">if</span>(isShutdown() &amp;&amp; removeTask(task)) &#123;            reject();        &#125;    &#125;        <span class="hljs-keyword">if</span>(!addTaskWakesUp&amp;&amp;wakesUpForTask(task)) &#123;        wakeup(inEventLoop);    &#125;&#125;</code></pre></div><p>说明: 1)首先判断该 <code>EventLoop</code> 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。</p><p>2)如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。</p><p>3)如果 <code>addTaskWakesUp</code> 是 <code>false</code>，并且任务不是 <code>NonWakeupRunnable</code> 类型的，就尝试唤醒 <code>selector</code>。这个时候，阻塞在 <code>selecor</code>的线程就会立即返回</p><p>4)可以下断点来追踪</p><p>2.2我们 <code>debugaddTask</code> 和 <code>offerTask</code> 方法源码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(Runnable task)</span> </span>&#123;    <span class="hljs-keyword">if</span>(task == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);    &#125;        <span class="hljs-keyword">if</span>(!offerTask(task)) &#123;        reject(task);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerTask</span><span class="hljs-params">(Runnable task)</span> </span>&#123;    <span class="hljs-keyword">if</span>(isShutdown()) &#123;        reject();    &#125;    <span class="hljs-keyword">return</span> taskQueue.offer(task);&#125;</code></pre></div><p>3.<code>NioEventLoop</code> 的父类 <code>SingleThreadEventExecutor</code> 的 <code>startThread</code> 方法 3.1当执行 <code>execute</code> 方法的时候，如果当前线程不是 <code>EventLoop</code> 所属线程，则尝试启动线程，也就是 <code>startThread</code> 方法，dubug 代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startThread</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span>(state == ST_NOT_STARTED) &#123;        <span class="hljs-keyword">if</span>(STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;            <span class="hljs-keyword">try</span>&#123;                doStartThread();            &#125; <span class="hljs-keyword">catch</span>(Throwable cause) &#123;                STATE_UPDATER.set(<span class="hljs-keyword">this</span>, ST_NOT_STARTED);                PlatformDependent.throwException(cause);            &#125;        &#125;    &#125;&#125;</code></pre></div><p>说明:该方法首先判断是否启动过了，保证 <code>EventLoop</code> 只有一个线程，如果没有启动过，则尝试使用 <code>Cas</code> 将 <code>state</code> 状态改为 <code>ST_STARTED</code>，也就是已启动。然后调用 <code>doStartThread</code> 方法。如果失败，则进行回滚</p><p>看下 <code>doStartThread</code> 方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStartThread</span><span class="hljs-params">()</span> </span>&#123;    executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;            updateLastExecutionTime();            <span class="hljs-keyword">try</span>&#123;                SingleThreadEventExecutor.<span class="hljs-keyword">this</span>.run();                success=<span class="hljs-keyword">true</span>;            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">for</span>( ; ; ) &#123;                    intoldState = state;                    <span class="hljs-keyword">if</span>(oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.<span class="hljs-keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">for</span>( ; ; ) &#123;                        <span class="hljs-keyword">if</span>(confirmShutdown()) &#123;                            <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-keyword">try</span> &#123;                        cleanup();                    &#125; <span class="hljs-keyword">finally</span> &#123;                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class="hljs-keyword">this</span>,ST_TERMINATED);                        threadLock.release();                        terminationFuture.setSuccess(<span class="hljs-keyword">null</span>);                    &#125;                &#125;            &#125;        &#125;    &#125;);&#125;</code></pre></div><p>说明： 1)首先调用 <code>executor</code> 的 <code>execute</code> 方法，这个 <code>executor</code> 就是在创建 <code>EventLoopGroup</code> 的时候创建的 <code>ThreadPerTaskExecutor</code> 类。该 <code>execute</code> 方法会将 <code>Runnable</code> 包装成 <code>Netty</code> 的 <code>FastThreadLocalThread</code>。</p><p>2)任务中，首先判断线程中断状态，然后设置最后一次的执行时间。</p><p>3)执行当前 <code>NioEventLoop</code> 的 <code>run</code> 方法，注意：这个方法是个死循环，是整个 <code>EventLoop</code> 的核心</p><p>4)在 <code>finally</code> 块中，使用 <code>CAS</code> 不断修改 <code>state</code> 状态，改成 <code>ST_SHUTTING_DOWN</code>。也就是当线程 <code>Loop</code> 结束的时候。关闭线程。最后还要死循环确认是否关闭，否则不会 <code>break</code>。然后，执行 <code>cleanup</code> 操作，更新状态为</p><p>5)<code>ST_TERMINATED</code>，并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。并回调 <code>terminationFuture</code> 方法。</p><p>6)其实最核心的就是 <code>EventLoop</code> 自身的 <code>run</code> 方法。再继续深入 <code>run</code> 方法</p><p>4.<code>EventLoop</code> 中的 <code>Loop</code> 是靠 <code>run</code> 实现的，我们分析下 <code>run</code> 方法(该方法在 <code>NioEventLoop</code>)</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>( ; ; ) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">switch</span>(selectStrategy.calculateStrategy(selectNowSupplier,hasTasks())) &#123;                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:                    <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:                    select(wakenUp.getAndSet(<span class="hljs-keyword">false</span>));                    <span class="hljs-keyword">if</span>(wakenUp.get()) &#123;                        selector.wakeup();                    &#125;                    <span class="hljs-keyword">default</span>:            &#125;                        cancelledKeys = <span class="hljs-number">0</span>;            needsToSelectAgain = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;            <span class="hljs-keyword">if</span>(ioRatio == <span class="hljs-number">100</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    processSelectedKeys();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">//Ensure we always run tasks.</span>                    runAllTasks();                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();                <span class="hljs-keyword">try</span> &#123;                    processSelectedKeys();                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">//Ensure we always runtasks.</span>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;            handleLoopException(t);        &#125;        <span class="hljs-comment">//Always handle shutdown even if the loop processing threw an exception.</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(isShuttingDown()) &#123;                closeAll();                <span class="hljs-keyword">if</span>(confirmShutdown()) &#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            handleLoopException(t);        &#125;    &#125;&#125;</code></pre></div><p>说明: 1)从上面的步骤可以看出，整个 <code>run</code> 方法做了 <code>3</code> 件事情： <code>select</code> 获取感兴趣的事件。 <code>processSelectedKeys</code> 处理事件。 <code>runAllTasks</code> 执行队列中的任务。</p><p>2)上面的三个方法，我们就追一下 <code>select</code> 方法(体现非阻塞)核心 <code>select</code> 方法解析</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> oldWakenUp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    Selector selector = <span class="hljs-keyword">this</span>.selector;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">long</span> currentTimeNanos = System.nanoTime();        <span class="hljs-keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);        <span class="hljs-keyword">for</span>( ; ; ) &#123;            <span class="hljs-keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="hljs-number">500000L</span>)/<span class="hljs-number">1000000L</span>;            <span class="hljs-keyword">if</span>(timeoutMillis &lt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span>(selectCnt == <span class="hljs-number">0</span>) &#123;                    selector.selectNow();                    selectCnt=<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">//If a task was submitted when wakenUp value was true, the task didn&#x27;t get a chance to call</span>            <span class="hljs-comment">//Selector#wakeup. So we need to check task queue again before executing select operation.</span>            <span class="hljs-comment">//If wedon&#x27;t, the task might be pended until select operation was timedout.</span>            <span class="hljs-comment">//It might be pended until idle timeout if IdleStateHandler existed inpipeline.</span>            <span class="hljs-keyword">if</span>(hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;                selector.selectNow();                selectCnt = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;                        <span class="hljs-keyword">int</span> selectedKeys = selector.select(timeoutMillis);<span class="hljs-comment">//否则阻塞给定时间，默认一秒</span>            selectCnt++;            <span class="hljs-comment">//如果 1 秒后返回，有返回值||select被用户唤醒||任务队列有任务||有定时任务即将被执行；则跳出循环</span>            <span class="hljs-keyword">if</span>(selectedKeys != <span class="hljs-number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;                <span class="hljs-comment">//-Selected something,</span>                <span class="hljs-comment">//-waken up by user,or</span>                <span class="hljs-comment">//-the task queue has apending task.</span>                <span class="hljs-comment">//-a scheduled task is ready for processing</span>                <span class="hljs-keyword">break</span>;            &#125;                        <span class="hljs-keyword">if</span>(Thread.interrupted()) &#123;                <span class="hljs-comment">//Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span>                <span class="hljs-comment">//As this is most likely a bug in the handler of the user or it&#x27;s client library we will</span>                <span class="hljs-comment">//also log it.</span>                <span class="hljs-comment">//</span>                <span class="hljs-comment">//See https://github.com/netty/netty/issues/2426</span>                <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;                    logger.debug(<span class="hljs-string">&quot;Selector.select() returned prematurely because &quot;</span> + <span class="hljs-string">&quot; Thread.currentThread().interrupt() was called. Use &quot;</span> + <span class="hljs-string">&quot; NioEventLoop.shutdownGracefully() to shutdowntheNioEventLoop.&quot;</span>);                &#125;                selectCnt = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">long</span> time = System.nanoTime();            <span class="hljs-keyword">if</span>(time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;                <span class="hljs-comment">//timeoutMillis elapsed without any thing selected.</span>                selectCnt =<span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;                <span class="hljs-comment">//The selector returned prematurely many times in a row.</span>                <span class="hljs-comment">//Rebuild the selector to work around the problem.</span>                logger.warn(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>, selectCnt, selector);                rebuildSelector();                selector = <span class="hljs-keyword">this</span>.selector;                <span class="hljs-comment">//Select again to populate selectedKeys.</span>                selector.selectNow();                selectCnt = <span class="hljs-number">1</span>;                <span class="hljs-keyword">break</span>;            &#125;                        currentTimeNanos = time;        &#125;                <span class="hljs-keyword">if</span>(selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;            <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;                logger.debug(<span class="hljs-string">&quot;Selector.select()returned prematurely &#123;&#125; times in a row for Selector&#123;&#125;.&quot;</span>, selectCnt - <span class="hljs-number">1</span>, selector);            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;        <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;            logger.debug(CancelledKeyException.class.getSimpleName() + <span class="hljs-string">&quot;raisedbyaSelector &#123;&#125; - JDKbug?&quot;</span>, selector, e);        &#125;        <span class="hljs-comment">//Harmless exception - log anyway</span>    &#125;&#125;</code></pre></div><p>说明：调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selector</code>，防止 <code>selector</code> 阻塞时间过长</p><p>5.<code>EventLoop</code> 作为 <code>Netty</code> 的核心的运行机制小结</p><p>1)每次执行 <code>execute</code> 方法都是向队列中添加任务。当第一次添加时就启动线程，执行 <code>run</code> 方法，而 <code>run</code> 方法是整个 <code>EventLoop</code> 的核心，就像 <code>EventLoop</code> 的名字一样，<code>LoopLoop</code>，不停的 <code>Loop</code>，<code>Loop</code> 做什么呢？做 <code>3</code> 件事情。</p><p>调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selecor</code>，防止 <code>selector</code> 阻塞时间过长。</p><p>当 <code>selector</code> 返回的时候，回调用 <code>processSelectedKeys</code> 方法对 <code>selectKey</code> 进行处理。</p><p>当 <code>processSelectedKeys</code> 方法执行结束后，则按照 <code>ioRatio</code> 的比例执行 <code>runAllTasks</code> 方法，默认是 <code>IO</code> 任务时间和非 <code>IO</code> 任务时间是相同的，你也可以根据你的应用特点进行调优。比如非 <code>IO</code> 任务比较多，那么你就将</p><p><code>ioRatio</code> 调小一点，这样非 <code>IO</code> 任务就能执行的长一点。防止队列积攒过多的任务。</p><h3 id="10-8-handler-中加入线程池和-Context-中添加线程池的源码剖析"><a href="#10-8-handler-中加入线程池和-Context-中添加线程池的源码剖析" class="headerlink" title="10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析"></a>10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析</h3><h4 id="10-8-1-源码剖析目的"><a href="#10-8-1-源码剖析目的" class="headerlink" title="10.8.1 源码剖析目的"></a>10.8.1 源码剖析目的</h4><ol><li>在 <code>Netty</code> 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 <code>Netty</code> 对 <code>Socket</code> 的处理速度。</li><li>而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有 <code>2</code> 种方式，而且这 <code>2</code> 种方式实现的区别也蛮大的。</li><li>处理耗时业务的第一种方式 – <code>handler</code> 中加入线程池</li><li>处理耗时业务的第二种方式 – <code>Context</code> 中添加线程池</li><li>我们就来分析下两种方式</li></ol><h4 id="10-8-2-源码剖析"><a href="#10-8-2-源码剖析" class="headerlink" title="10.8.2 源码剖析"></a>10.8.2 源码剖析</h4><p>说明 演示两种方式的实现，以及从源码来追踪两种方式执行流程</p><ol><li>处理耗时业务的第一种方式 – handler种加入线程池</li><li>1对前面的 <code>Netty</code> <code>demo</code>源码进行修改，在 <code>EchoServerHandler</code> 的 <code>channelRead</code> 方法进行异步</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventExecutorGroup group = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<span class="hljs-number">16</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException, InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> Object msgCop = msg;        <span class="hljs-keyword">final</span> ChannelHandlerContext cxtCop = ctx;        group.submit(<span class="hljs-keyword">new</span> Callable&lt;Object&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                ByteBuf buf = (ByteBuf)msgCop;                <span class="hljs-keyword">byte</span>[] req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buf.readableBytes()];                buf.readBytes(req);                String body = <span class="hljs-keyword">new</span> String(req, <span class="hljs-string">&quot;UTF-8&quot;</span>);                Thread.sleep(<span class="hljs-number">10</span> * <span class="hljs-number">1000</span>);                System.err.println(body + <span class="hljs-string">&quot; &quot;</span> + Thread.currentThread().getName());                String reqString = <span class="hljs-string">&quot;Helloiamserver~~~&quot;</span>;                ByteBuf resp = Unpooled.copiedBuffer(reqString.getBytes());                cxtCop.writeAndFlush(resp);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125;);        System.out.println(<span class="hljs-string">&quot;goon..&quot;</span>);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;        ctx.flush();    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;        <span class="hljs-comment">// Close the connection when an exception is raised.</span>        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre></div><p>说明： 1)在 <code>channelRead</code> 方法，模拟了一个耗时 <code>10</code> 秒的操作，这里，我们将这个任务提交到了一个自定义的业务线程池中，这样，就不会阻塞 <code>Netty</code> 的 <code>IO</code> 线程。</p><p>11.2这样处理之后，整个程序的逻辑如图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_19.png" alt="img"></p><p>说明：</p><p>1)解释一下上图，当 <code>IO</code> 线程轮询到一个 <code>socket</code> 事件，然后，<code>IO</code> 线程开始处理，当走到耗时 <code>handler</code> 的时候，将耗时任务交给业务线程池。</p><p>2)当耗时任务执行完毕再执行 <code>pipeline write</code> 方法的时候，(代码中使用的是 <code>context</code> 的 <code>write</code> 方法，上图画的是执行 <code>pipeline</code> 方法，是一个意思)会将任务这个任务交给 <code>IO</code> 线程</p><p>11.3 <code>write</code> 方法的源码(在 <code>AbstractChannelHandlerContext</code> 类)</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Object msg, <span class="hljs-keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;    AbstractChannelHandlerContext next = findContextOutbound();    <span class="hljs-keyword">final</span> Object m = pipeline.touch(msg, next);    EventExecutor executor = next.executor();    <span class="hljs-keyword">if</span>(executor.inEventLoop()) &#123;        <span class="hljs-keyword">if</span>(flush) &#123;            next.invokeWriteAndFlush(m, promise);        &#125; <span class="hljs-keyword">else</span> &#123;            next.invokeWrite(m, promise);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        AbstractWriteTask task;        <span class="hljs-keyword">if</span>(flush) &#123;            task = WriteAndFlushTask.newInstance(next, m, promise);        &#125; <span class="hljs-keyword">else</span> &#123;            task = WriteTask.newInstance(next, m, promise);        &#125;        safeExecute(executor, task, promise, m);    &#125;&#125;</code></pre></div><p>说明:</p><p>1)当判定下个 <code>outbound</code> 的 <code>executor</code> 线程不是当前线程的时候，会将当前的工作封装成 <code>task</code>，然后放入 <code>mpsc</code> 队列中，等待 <code>IO</code> 任务执行完毕后执行队列中的任务。</p><p>2)这里可以 Debug 来验证(提醒：Debug 时，服务器端 Debug, 客户端 <code>Run</code> 的方式)，当我们使用了 <code>group.submit(new Callable&lt;Object&gt; ()&#123;&#125;</code> 在 <code>handler</code> 中加入线程池，就会进入到 <code>safeExecute(executor, task, promise, m);</code> 如果去掉这段代码，而使用普通方式来执行耗时的业务，那么就不会进入到 <code>safeExecute(executor, task, promise, m);</code>（说明：普通方式执行耗时代码，看我准备好的案例即可）</p><p>12.处理耗时业务的第二种方式 -<code>Context</code> 中添加线程池 1.1在添加 <code>pipeline</code> 中的 <code>handler</code> 时候，添加一个线程池</p><p>//属性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventExecutorGroup group = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<span class="hljs-number">16</span>);ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();                b.group(bossGroup, workerGroup)                 .channel(NioServerSocketChannel.class)                 .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)                 .handler(newLoggingHandler(LogLevel.INFO))                 .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                     <span class="hljs-meta">@Override</span>                     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                         ChannelPipeline p = ch.pipeline();                         <span class="hljs-keyword">if</span>(sslCtx != <span class="hljs-keyword">null</span>) &#123;                             p.addLast(sslCtx.newHandler(ch.alloc()));                         &#125;                         <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>                         <span class="hljs-comment">//p.addLast(new EchoServerHandler());</span>                         p.addLast(group, <span class="hljs-keyword">new</span> EchoServerHandler());                    &#125;                &#125;);</code></pre></div><p>说明：</p><p>1)<code>handler</code> 中的代码就使用普通的方式来处理耗时业务。</p><p>2)当我们在调用 <code>addLast</code> 方法添加线程池后，<code>handler</code> 将优先使用这个线程池，如果不添加，将使用 <code>IO</code> 线程</p><p>3)当走到 <code>AbstractChannelHandlerContext</code> 的 <code>invokeChannelRead</code> 方法的时候，<code>executor.inEventLoop()</code> 是不会通过的，因为当前线程是 <code>IO</code> 线程 <code>Context</code>（也就是 <code>Handler</code>）的 <code>executor</code> 是业务线程，所以会异步执行，debug 下源码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;    <span class="hljs-keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);    EventExecutor executor = next.executor();    <span class="hljs-keyword">if</span>(executor.inEventLoop()) &#123;        next.invokeChannelRead(m);    &#125; <span class="hljs-keyword">else</span> &#123;        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-comment">//执行run</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                next.invokeChannelRead(m);            &#125;        &#125;);    &#125;&#125;</code></pre></div><p>4)验证时，我们如果去掉 <code>p.addLast(group,newEchoServerHandler());</code> 改成 <code>p.addLastnewEchoServerHandler());</code> 你会发现代码不会进行异步执行。</p><p>5)后面的整个流程就变成和第一个方式一样了</p><p>13.两种方式的比较</p><p>1)第一种方式在 <code>handler</code> 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 <code>mpscTask</code> 中。如果 <code>IO</code> 时间很短，<code>task</code> 很多，可能一个循环下来，都没时间执行整个 <code>task</code>，导致响应时间达不到指标。</p><p>2)第二种方式是 <code>Netty</code> 标准方式(即加入到队列)，但是，这么做会将整个 <code>handler</code> 都交给业务线程池。不论耗时不耗时，都加入到队列里，不够灵活。</p><p>3)各有优劣，从灵活性考虑，第一种较好。</p><h2 id="11-用-Netty-自己实现-Dubbo-RPC"><a href="#11-用-Netty-自己实现-Dubbo-RPC" class="headerlink" title="11 用 Netty 自己实现 Dubbo RPC"></a>11 用 Netty 自己实现 Dubbo RPC</h2><h3 id="11-1-RPC-基本介绍"><a href="#11-1-RPC-基本介绍" class="headerlink" title="11.1 RPC 基本介绍"></a>11.1 RPC 基本介绍</h3><ol><li><code>RPC（Remote Procedure Call）</code>—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li><li>两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图)</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_01.png" alt="img"></p><ol><li>常见的 <code>RPC</code> 框架有：比较知名的如阿里的 <code>Dubbo</code>、<code>Google</code> 的 <code>gRPC</code>、<code>Go</code> 语言的 <code>rpcx</code>、<code>Apache</code> 的 <code>thrift</code>，<code>Spring</code> 旗下的 <code>SpringCloud</code>。</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_02.png" alt="img"></p><h3 id="11-2-RPC-调用流程图"><a href="#11-2-RPC-调用流程图" class="headerlink" title="11.2 RPC 调用流程图"></a>11.2 RPC 调用流程图<img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_03.png" alt="img"></h3><h3 id="11-3-PRC-调用流程说明"><a href="#11-3-PRC-调用流程说明" class="headerlink" title="11.3 PRC 调用流程说明"></a>11.3 PRC 调用流程说明</h3><ol><li>服务消费方（<code>client</code>）以本地调用方式调用服务</li><li><code>client stub</code> 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体</li><li><code>client stub</code> 将消息进行编码并发送到服务端</li><li><code>server stub</code> 收到消息后进行解码</li><li><code>server stub</code> 根据解码结果调用本地的服务</li><li>本地服务执行并将结果返回给 <code>server stub</code></li><li><code>server stub</code> 将返回导入结果进行编码并发送至消费方</li><li><code>client stub</code> 接收到消息并进行解码</li><li>服务消费方（<code>client</code>）得到结果</li></ol><p>小结：<code>RPC</code> 的目标就是将 <code>2 - 8</code> 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用</p><h3 id="11-4-自己实现-Dubbo-RPC（基于-Netty）"><a href="#11-4-自己实现-Dubbo-RPC（基于-Netty）" class="headerlink" title="11.4 自己实现 Dubbo RPC（基于 Netty）"></a>11.4 自己实现 Dubbo RPC（基于 Netty）</h3><h4 id="11-4-1-需求说明"><a href="#11-4-1-需求说明" class="headerlink" title="11.4.1 需求说明"></a>11.4.1 需求说明</h4><ol><li><code>Dubbo</code> 底层使用了 <code>Netty</code> 作为网络通讯框架，要求用 <code>Netty</code> 实现一个简单的 <code>RPC</code> 框架</li><li>模仿 <code>Dubbo</code>，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 <code>Netty 4.1.20</code></li></ol><h4 id="11-4-2-设计说明"><a href="#11-4-2-设计说明" class="headerlink" title="11.4.2 设计说明"></a>11.4.2 设计说明</h4><ol><li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。</li><li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。</li><li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 <code>Netty</code> 请求提供者返回数据</li><li>开发的分析图</li></ol><p><img src="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_04.png" alt="img"></p><h4 id="11-4-3-代码实现"><a href="#11-4-3-代码实现" class="headerlink" title="11.4.3 代码实现"></a>11.4.3 代码实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.publicinterface;<span class="hljs-comment">//这个是接口，是服务提供方和 服务消费方都需要</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">hello</span><span class="hljs-params">(String mes)</span></span>;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.provider;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-comment">//当有消费方调用该方法时， 就返回一个结果</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String mes)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;收到客户端消息=&quot;</span> + mes);        <span class="hljs-comment">//根据mes 返回不同的结果</span>        <span class="hljs-keyword">if</span> (mes != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好客户端, 我已经收到你的消息 [&quot;</span> + mes + <span class="hljs-string">&quot;] 第&quot;</span> + (++count) + <span class="hljs-string">&quot; 次&quot;</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好客户端, 我已经收到你的消息 &quot;</span>;        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.provider;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyServer;<span class="hljs-comment">//ServerBootstrap 会启动一个服务提供者，就是 NettyServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerBootstrap</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//代码代填..</span>        NettyServer.startServer(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>);    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer</span><span class="hljs-params">(String hostName, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        startServer0(hostName, port);    &#125;    <span class="hljs-comment">//编写一个方法，完成对NettyServer的初始化和启动</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer0</span><span class="hljs-params">(String hostname, <span class="hljs-keyword">int</span> port)</span> </span>&#123;        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                                      <span class="hljs-meta">@Override</span>                                      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                          ChannelPipeline pipeline = ch.pipeline();                                          pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());                                          pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());                                          pipeline.addLast(<span class="hljs-keyword">new</span> NettyServerHandler()); <span class="hljs-comment">//业务处理器</span>                                      &#125;                                  &#125;                    );            ChannelFuture channelFuture = serverBootstrap.bind(hostname, port).sync();            System.out.println(<span class="hljs-string">&quot;服务提供方开始提供服务~~&quot;</span>);            channelFuture.channel().closeFuture().sync();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.customer.ClientBootstrap;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.provider.HelloServiceImpl;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-comment">//服务器这边handler比较简单</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//获取客户端发送的消息，并调用服务</span>        System.out.println(<span class="hljs-string">&quot;msg=&quot;</span> + msg);        <span class="hljs-comment">//客户端在调用服务器的api 时，我们需要定义一个协议</span>        <span class="hljs-comment">//比如我们要求 每次发消息是都必须以某个字符串开头 &quot;HelloService#hello#你好&quot;</span>        <span class="hljs-keyword">if</span> (msg.toString().startsWith(ClientBootstrap.providerName)) &#123;            String result = <span class="hljs-keyword">new</span> HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(<span class="hljs-string">&quot;#&quot;</span>) + <span class="hljs-number">1</span>));            ctx.writeAndFlush(result);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.close();    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> java.util.concurrent.Callable;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;    <span class="hljs-keyword">private</span> ChannelHandlerContext context;<span class="hljs-comment">//上下文</span>    <span class="hljs-keyword">private</span> String result; <span class="hljs-comment">//返回的结果</span>    <span class="hljs-keyword">private</span> String para; <span class="hljs-comment">//客户端调用方法时，传入的参数</span>        <span class="hljs-comment">//与服务器的连接创建后，就会被调用, 这个方法是第一个被调用(1)</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot; channelActive 被调用  &quot;</span>);        context = ctx; <span class="hljs-comment">//因为我们在其它方法会使用到 ctx</span>    &#125;    <span class="hljs-comment">//收到服务器的数据后，调用方法 (4)</span>    <span class="hljs-comment">//</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot; channelRead 被调用  &quot;</span>);        result = msg.toString();        notify(); <span class="hljs-comment">//唤醒等待的线程</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ctx.close();    &#125;    <span class="hljs-comment">//被代理对象调用, 发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果 (3)-》5</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">&quot; call1 被调用  &quot;</span>);        context.writeAndFlush(para);        <span class="hljs-comment">//进行wait</span>        wait(); <span class="hljs-comment">//等待channelRead 方法获取到服务器的结果后，唤醒</span>        System.out.println(<span class="hljs-string">&quot; call2 被调用  &quot;</span>);        <span class="hljs-keyword">return</span> result; <span class="hljs-comment">//服务方返回的结果</span>    &#125;    <span class="hljs-comment">//(2)</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPara</span><span class="hljs-params">(String para)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot; setPara  &quot;</span>);        <span class="hljs-keyword">this</span>.para = para;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<span class="hljs-keyword">import</span> java.util.concurrent.Executor;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;    <span class="hljs-comment">//创建线程池</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> NettyClientHandler client;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-comment">//编写方法使用代理模式，获取一个代理对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; serivceClass, <span class="hljs-keyword">final</span> String providerName)</span> </span>&#123;        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),                <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;serivceClass&#125;, (proxy, method, args) -&gt; &#123;                    System.out.println(<span class="hljs-string">&quot;(proxy, method, args) 进入....&quot;</span> + (++count) + <span class="hljs-string">&quot; 次&quot;</span>);                    <span class="hljs-comment">//&#123;&#125;  部分的代码，客户端每调用一次 hello, 就会进入到该代码</span>                    <span class="hljs-keyword">if</span> (client == <span class="hljs-keyword">null</span>) &#123;                        initClient();                    &#125;                    <span class="hljs-comment">//设置要发给服务器端的信息</span>                    <span class="hljs-comment">//providerName 协议头 args[0] 就是客户端调用api hello(???), 参数</span>                    client.setPara(providerName + args[<span class="hljs-number">0</span>]);                    <span class="hljs-comment">//</span>                    <span class="hljs-keyword">return</span> executor.submit(client).get();                &#125;);    &#125;    <span class="hljs-comment">//初始化客户端</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initClient</span><span class="hljs-params">()</span> </span>&#123;        client = <span class="hljs-keyword">new</span> NettyClientHandler();        <span class="hljs-comment">//创建EventLoopGroup</span>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();        bootstrap.group(group)                .channel(NioSocketChannel.class)                .option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)                .handler(                        <span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                                ChannelPipeline pipeline = ch.pipeline();                                pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());                                pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());                                pipeline.addLast(client);                            &#125;                        &#125;                );        <span class="hljs-keyword">try</span> &#123;            bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>).sync();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.customer;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyClient;<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientBootstrap</span> </span>&#123;        <span class="hljs-comment">//这里定义协议头</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String providerName = <span class="hljs-string">&quot;HelloService#hello#&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建一个消费者</span>        NettyClient customer = <span class="hljs-keyword">new</span> NettyClient();        <span class="hljs-comment">//创建代理对象</span>        HelloService service = (HelloService) customer.getBean(HelloService.class, providerName);        <span class="hljs-keyword">for</span> (; ; ) &#123;            Thread.sleep(<span class="hljs-number">2</span> * <span class="hljs-number">1000</span>);            <span class="hljs-comment">//通过代理对象调用服务提供者的方法(服务)</span>            String res = service.hello(<span class="hljs-string">&quot;你好 dubbo~&quot;</span>);            System.out.println(<span class="hljs-string">&quot;调用的结果 res= &quot;</span> + res);        &#125;    &#125;&#125;</code></pre></div>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Java/">Java</category>
      
      <category domain="https://pncalbl.github.io/categories/Java/Network/">Network</category>
      
      
      <category domain="https://pncalbl.github.io/tags/network/">network</category>
      
      <category domain="https://pncalbl.github.io/tags/framework/">framework</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Win10 搭建 PyTorch 环境</title>
      <link>https://pncalbl.github.io/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/</link>
      <guid>https://pncalbl.github.io/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/</guid>
      <pubDate>Wed, 19 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Win10-搭建-PyTorch-环境&quot;&gt;&lt;a href=&quot;#Win10-搭建-PyTorch-环境&quot; class=&quot;headerlink&quot; title=&quot;Win10 搭建 PyTorch 环境&quot;&gt;&lt;/a&gt;Win10 搭建 PyTorch 环境&lt;/h1&gt;&lt;h2 i</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Win10-搭建-PyTorch-环境"><a href="#Win10-搭建-PyTorch-环境" class="headerlink" title="Win10 搭建 PyTorch 环境"></a>Win10 搭建 PyTorch 环境</h1><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0 说明"></a>0 说明</h2><p>为了进行深度学习，需要电脑上安装相应的软件，pytorch 就是其中一种。至于 pytorch 是什么的科普，建议去网上搜索。</p><p>而为了安装好 pytorch，需要安装众多软件，网上一搜一大把流程。但事实上随着技术的更新，很多流程都会变得过时，就像我现在这篇，因此我也特意标注了时间。</p><p>本流程的目的是：在 win 10 上安装 pytorch 且能调用 GPU（你需要英伟达的显卡）。</p><p>本流程涉及的程序有：conda，CUDA，cuDNN，pytorch。注意一定要按流程来，如果跳过了 cuDNN 安装 pytorch，是不会成功调用 GPU 的。</p><h2 id="1-Miniconda3"><a href="#1-Miniconda3" class="headerlink" title="1 Miniconda3"></a>1 Miniconda3</h2><p>清华源镜像已经没有维护 miniconda，所以我们使用北外源。</p><ul><li><p><strong>下载地址</strong></p><p><a href="https://mirrors.bfsu.edu.cn/anaconda/miniconda/">Index of /anaconda/miniconda</a></p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521111325301.png" alt="image-20210521111325301"></p></li><li><p><strong>配置环境变量</strong></p><p>一般来说，安装程序会自动把四个 path 变量，写入系统变量的path变量中，但是会写入第一行，我们可以手动下移位置。</p><ul><li><p>打开 cmd（win+R，输入 cmd 后回车），输入 conda info，如果正确无误的话，会显示 conda 的信息。</p></li><li><p>为了 conda 的下载速度，需要添加国内的北外源，输入：</p><div class="code-wrapper"><pre><code class="hljs shell">conda config --set show_channel_urls yes</code></pre></div><p>创建配置文件 .condarc，该文件位于：C:\Users\你的用户名\ 下。</p><p>用文本编辑器打开它，然后复制以下内容完全覆盖已有内容：</p><div class="code-wrapper"><pre><code class="hljs shell">channels:  - defaultsshow_channel_urls: truedefault_channels:  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/main  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/r  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.bfsu.edu.cn/anaconda/cloud  msys2: https://mirrors.bfsu.edu.cn/anaconda/cloud  bioconda: https://mirrors.bfsu.edu.cn/anaconda/cloud  menpo: https://mirrors.bfsu.edu.cn/anaconda/cloud  pytorch: https://mirrors.bfsu.edu.cn/anaconda/cloud  simpleitk: https://mirrors.bfsu.edu.cn/anaconda/cloud</code></pre></div></li></ul></li><li><p><strong>生成并进入环境</strong></p><ul><li><p>使用命令创建环境：</p><div class="code-wrapper"><pre><code class="hljs shell">conda create --name py37 python=3.7</code></pre></div></li><li><p>即创建了名为 py37 的环境，你可以自定义名字，python 设定用的版本。</p><p>随后进入环境</p><div class="code-wrapper"><pre><code class="hljs shell">conda activate py37</code></pre></div></li><li><p><strong>避坑：操作需要在 cmd 里做，而不是 powershell，不知道原理，但会报错。</strong></p><p>如果在 powershell 里运行的话，会报错：</p><div class="code-wrapper"><pre><code class="hljs powershell">CommandNotFoundError: Your shell has not been properly configured to use <span class="hljs-string">&#x27;conda activate&#x27;</span>.</code></pre></div><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/v2-e641b91a6a360410b575d83c3030daf4_1440w.jpg" alt="img"></p></li></ul></li><li><p><strong>安装 ipython</strong></p><ul><li><p>ipython 的操作比 python 用起来舒服多了，具体介绍搜索网上</p><div class="code-wrapper"><pre><code class="hljs shell">conda install ipython</code></pre></div></li><li><p>之后输入 ipython 进入 python。</p></li></ul></li></ul><h2 id="2-CUDA"><a href="#2-CUDA" class="headerlink" title="2 CUDA"></a>2 CUDA</h2><ul><li><p>下载</p><p>链接：<a href="https://developer.nvidia.com/cuda-10.2-download-archive">https://developer.nvidia.com/cuda-downloads</a></p><p>依次选择：Windows -&gt; x86_64 -&gt; 10 -&gt; exe(local)，点击 Download。下载的为适合PyTorch的 <em>cuda_10.2.89_441.22_win10.exe</em></p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521112724889.png" alt="image-20210521112724889"></p><p><strong>避坑：复制下载链接后用迅雷下载，比直接下载快数倍。</strong></p></li><li><p>安装</p><ul><li><p>注意，不要修改安装路径，因为改了没有用，安装程序还是会安装在 C盘下的 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA</p></li><li><p>必须手动添加环境变量。一般来说，CUDA_PATH，安装程序会自动写入。</p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521113202277.png" alt="image-20210521113202277"></p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521113121745.png" alt="image-20210521113121745"></p></li></ul></li></ul><ul><li><p><strong>测试</strong></p><ul><li><p>如果安装成功，在 cmd 里输入：</p><div class="code-wrapper"><pre><code class="hljs shell">nvcc -V</code></pre></div><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521113321717.png" alt="image-20210521113321717"></p></li></ul></li></ul><h2 id="3-cuDNN"><a href="#3-cuDNN" class="headerlink" title="3 cuDNN"></a>3 cuDNN</h2><ul><li><p><strong>下载</strong></p><p><strong>避坑：建议在翻墙的情况下操作，注册时的验证码是谷歌的。</strong></p><p>你需要注册账号后才能继续。现在可以<strong>微信登录</strong>，方便了不少。</p><p>链接：<a href="/compute/machine-learning/cudnn/secure/8.0.2.39/10.2_20200724/cudnn-10.2-windows10-x64-v8.0.2.39.zip">https://developer.nvidia.com</a></p></li><li><p><strong>安装</strong></p><p>说是安装，其实是复制文件。</p><p>下载后是一个压缩文件夹，解压文件夹，将里面的 3 个文件夹：bin，include，lib 里面的内容分别放入 CUDA 安装位置的对应文件夹。</p><p>CUDA 安装的位置在：</p><p>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0</p><p>不会出现覆盖的警告，因为是新增的文件。</p></li></ul><h2 id="4-PyTorch"><a href="#4-PyTorch" class="headerlink" title="4 PyTorch"></a>4 PyTorch</h2><ul><li><p><strong>1. 下载与安装</strong></p><p><strong>避坑：务必在完成以上步骤后才进行。</strong></p><p>网址：<a href="https://link.zhihu.com/?target=https%3A//pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a>，根据实际情况选择。</p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114119171.png" alt="image-20210521114119171"></p><p>得到下载安装的命令：</p><div class="code-wrapper"><pre><code class="hljs shell">conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch</code></pre></div><p>使用 cmd 进入了我们之前设置的环境 py37 后，输入以上命令，开始安装 pytorch，如下图：</p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/v2-58b3d7c11020aca95ab177253cf5d1b0_1440w.jpg" alt="img"></p><p><strong>避坑：很多教程里说，去掉 -c pytorch 后，可以加速下载。可以加速没错，但下载的东西却不是我们要的 gpu 版本，而是 cpu 版本，这也是很多人照着教程做，最终都无法使用 gpu 的，却百思不得其解。</strong></p></li><li><p><strong>2. 测试</strong></p><ul><li><p>等待安装完成后，输入 ipython 进入 python，输入：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchtorch.cuda.is_available()</code></pre></div><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/v2-6acee085f9449a931afaee3cdd36336a_1440w.jpg" alt="img"></p></li><li><p>显示 True 即表明启用了 pytorch 的 gpu，到此安装结束。</p></li><li><p>如果 torch.cuda.isavailable() 是 False，你可能需要看看前面哪个步骤不对。</p></li></ul></li></ul><h2 id="5-Pycharm"><a href="#5-Pycharm" class="headerlink" title="5 Pycharm"></a>5 Pycharm</h2><ul><li><p>创建一个项目 PyTorchTest</p></li><li><p>打开设置 Ctrl + Alt + s</p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114808829.png" alt="image-20210521114808829"></p></li><li><p>引入 py37 </p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114859777.png" alt="image-20210521114859777"></p></li><li><p>切换环境为 py37</p><p><img src="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/image-20210521114957218.png" alt="image-20210521114957218"></p></li><li><p>重启 Pycharm</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Win/">Win</category>
      
      
      <category domain="https://pncalbl.github.io/tags/PyTorch/">PyTorch</category>
      
      <category domain="https://pncalbl.github.io/tags/Win10/">Win10</category>
      
      <category domain="https://pncalbl.github.io/tags/Deep-learning/">Deep learning</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Liunx 一般配置与命令</title>
      <link>https://pncalbl.github.io/2021/05/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <guid>https://pncalbl.github.io/2021/05/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Sun, 09 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-Liunx-常用命令&quot;&gt;&lt;a href=&quot;#1-Liunx-常用命令&quot; class=&quot;headerlink&quot; title=&quot;1 Liunx 常用命令&quot;&gt;&lt;/a&gt;1 Liunx 常用命令&lt;/h1&gt;&lt;h2 id=&quot;命令行&quot;&gt;&lt;a href=&quot;#命令行&quot; class</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-Liunx-常用命令"><a href="#1-Liunx-常用命令" class="headerlink" title="1 Liunx 常用命令"></a>1 Liunx 常用命令</h1><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><table><thead><tr><th>描述</th><th>命令</th></tr></thead><tbody><tr><td>编辑环境变量</td><td>vim /etc/profile</td></tr><tr><td>生效环境变量</td><td>source /etc/profile</td></tr><tr><td>检查目标服务的端口监听状态</td><td>netstat -ntlp | grep 3306</td></tr><tr><td>启动目标服务</td><td>systemctl start service</td></tr><tr><td>检查目标服务的状态</td><td>systemctl status service</td></tr><tr><td>停止目标服务</td><td>systemctl stop service</td></tr><tr><td>查看安装包</td><td>rpm -qa | grep Git</td></tr><tr><td>添加用户组 docker</td><td>sudo groupadd docker</td></tr><tr><td>将登陆用户加入到 docker 用户组中</td><td>sudo gpasswd -a $USER docker</td></tr><tr><td>更新用户组</td><td>newgrp docker</td></tr></tbody></table><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><table><thead><tr><th>描述</th><th>命令模式</th><th>底线命令模式</th></tr></thead><tbody><tr><td>移到最第一行</td><td>gg</td><td>:0或:1</td></tr><tr><td>移到最后一行</td><td>shift+g</td><td>:$</td></tr><tr><td>搜索字符串</td><td>查看下一个  按下 n<br>转到上一个  按下 N</td><td>:/字符串</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="2-设置快捷键"><a href="#2-设置快捷键" class="headerlink" title="2 设置快捷键"></a>2 设置快捷键</h1><ol><li>进入设置 / <code>settings</code></li><li>进入 <code>Keyboard</code></li><li>点击 添加按钮 <code>+</code></li><li>定义名称 <code>Open Terminal</code></li><li>输入命令 <code>/usr/bin/gnome-terminal</code></li></ol><h1 id="3-更换-yum-源"><a href="#3-更换-yum-源" class="headerlink" title="3 更换 yum 源"></a>3 更换 yum 源</h1><h2 id="1-下载wget的rpm包"><a href="#1-下载wget的rpm包" class="headerlink" title="1.下载wget的rpm包"></a>1.下载wget的rpm包</h2><p>首先去<a href="http://mirrors.163.com/centos/7/os/x86_64/Packages/找到wget的rpm包，复制链接，使用curl命令下载">http://mirrors.163.com/centos/7/os/x86_64/Packages/找到wget的rpm包，复制链接，使用curl命令下载</a></p><p><img src="/2021/05/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1089423-20191203231224175-577731216.png" alt="img"></p><p> 使用curl下载（注意相关的包版本可能已经变，请以最新的下载地址为准)）</p><div class="code-wrapper"><pre><code class="hljs shell">curl http://mirrors.163.com/centos/7/os/x86_64/Packages/wget-1.14-18.el7_6.1.x86_64.rpm</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">rpm -ivh wget-1.14-18.el7_6.1.x86_64.rpm</code></pre></div><h2 id="2-安装yum"><a href="#2-安装yum" class="headerlink" title="2.安装yum"></a>2.安装yum</h2><p> 1.删除原有的yum</p><div class="code-wrapper"><pre><code class="hljs shell">rpm -aq|grep yum|xargs rpm -e --nodeps</code></pre></div><p> 2.下载yum,注意自己的LINUX系统版本，是什么版本就进相关版本目录去下载。但小版本的目录就不用进了。如版本是6.5，就只需进6 目录，版本是 7.2，只需进7目录</p><div class="code-wrapper"><pre><code class="hljs shell">1 yum-*.rpm2 yum-metadata-parser-*.rpm3 yum-plugin-fastestmirror-*.rpm4 python-iniparse-*.rpm</code></pre></div><p>3.使用wget下载(注意相关的包版本可能已经变，请以最新的下载地址为准)</p><div class="code-wrapper"><pre><code class="hljs shell">wget https://mirrors.163.com/centos/7/os/x86_64/Packages/yum-3.4.3-168.el7.centos.noarch.rpmwget https://mirrors.163.com/centos/7/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpmwget https://mirrors.163.com/centos/7/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpmwget https://mirrors.163.com/centos/7/os/x86_64/Packages/python-iniparse-0.4-9.el7.noarch.rpm</code></pre></div><p>4.下载后安转yum依赖的包</p><div class="code-wrapper"><pre><code class="hljs shell">rpm -ivh python-iniparse-*.rpmrpm -ivh yum-*.rpm  yum-metadata-parser-*.rpm  yum-plugin-fastestmirror-*.rpm</code></pre></div><h2 id="3-修改yum源"><a href="#3-修改yum源" class="headerlink" title="3.修改yum源"></a>3.修改yum源</h2><p> 1.进入到系统yum源的目录下：</p><div class="code-wrapper"><pre><code class="hljs shell">cd /etc/yum.repos.d</code></pre></div><p> 2.下载yum源</p><div class="code-wrapper"><pre><code class="hljs shell">wget http://mirrors.163.com/.help/CentOS7-Base-163.repo</code></pre></div><p> 3.修改源文件名（注意需要把之前的删掉，或者改为.bak文件）</p><div class="code-wrapper"><pre><code class="hljs shell">mv CentOS7-Base-163.repo CentOS-Base.repo</code></pre></div><p>4.运行makecache 生成缓存 使配置生效</p><div class="code-wrapper"><pre><code class="hljs shell">yum makecache</code></pre></div><p>5.验证yum源</p><div class="code-wrapper"><pre><code class="hljs shell">yum repolist查看是否有163的标识 有则证明配置国内163镜像源成功</code></pre></div><p>7.运行yum clean all（等同于 yum cleanheaders ; yum cleanpackages）;</p><div class="code-wrapper"><pre><code class="hljs shell">yum clean allyum 会把下载的软件包和header存储在cache中，而不自动删除。如果觉得占用磁盘空间，可以使用yum clean指令进行清除，更精确 的用法是yum clean headers清除header，yum clean packages清除下载的rpm包，yum clean all一全部清除。</code></pre></div><p>8.更新YUM文件 全部更新软件包</p><div class="code-wrapper"><pre><code class="hljs shell">yum  update</code></pre></div><p>10.yum常用操作</p><div class="code-wrapper"><pre><code class="hljs shell">yum install XXXyum remove XXXyum listyum list installed</code></pre></div><h1 id="4-美化界面"><a href="#4-美化界面" class="headerlink" title="4 美化界面"></a>4 美化界面</h1><ol><li><p>先安装 gnome-tweak-tool</p><div class="code-wrapper"><pre><code class="hljs shell">yum install gnome-tweak-tool</code></pre></div></li><li><p>主题：<a href="mailto:git@gitzab.com">git@gitzab.com</a>:Anduin/GNOME-OSX-II-Theme.git </p><p>解压 GNOME-OSX-II-Theme-master.zip 到 /home/pncalbl/.themes </p><p>在 tweak 中切换主题 GNOME-OSX-II-Theme</p></li><li><p>图标：<a href="mailto:git@github.com">git@github.com</a>:keeferrourke/la-capitaine-icon-theme.git </p><p>解压 la-capitaine-icon-theme-master.zip 到 /home/pncalbl/.icons</p><p>在 tweak 中切换主题 图标</p></li><li><p>启动器：<a href="mailto:git@github.com">git@github.com</a>:micheleg/dash-to-dock.git</p></li></ol><h1 id="5-生成密钥"><a href="#5-生成密钥" class="headerlink" title="5 生成密钥"></a>5 生成密钥</h1><ol><li>生成秘钥</li></ol><div class="code-wrapper"><pre><code class="hljs shell">//换成你自己的邮箱ssh-keygen -t rsa -C &quot;pncalbl@qq.com&quot;//一直next并记住生成的地址Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa):Created directory &#x27;/root/.ssh&#x27;.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.</code></pre></div><ol><li>进入.ssh 目录提出key</li></ol><div class="code-wrapper"><pre><code class="hljs shell">[root@localhost ~]# cd .ssh[root@localhost .ssh]# lsid_rsa  id_rsa.pub//把显示的内容复制到GitHub的SSHkey配置即可[root@localhost .ssh]# cat id_rsa.pub</code></pre></div><ol><li>测试</li></ol><div class="code-wrapper"><pre><code class="hljs shell">[root@localhost .ssh]# ssh -T git@github.comThe authenticity of host &#x27;github.com (192.30.255.113)&#x27; can&#x27;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yPlease type &#x27;yes&#x27; or &#x27;no&#x27;: yesWarning: Permanently added &#x27;github.com,192.30.255.113&#x27; (RSA) to the list of known hosts.Hi megoc! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</code></pre></div>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Linux/">Linux</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Linux/">Linux</category>
      
      <category domain="https://pncalbl.github.io/tags/%E5%91%BD%E4%BB%A4/">命令</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/10/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>分析开源项目</title>
      <link>https://pncalbl.github.io/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</link>
      <guid>https://pncalbl.github.io/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</guid>
      <pubDate>Sat, 08 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;分析开源项目-EL-ADMIN&quot;&gt;&lt;a href=&quot;#分析开源项目-EL-ADMIN&quot; class=&quot;headerlink&quot; title=&quot;分析开源项目 (EL-ADMIN)&quot;&gt;&lt;/a&gt;分析开源项目 (EL-ADMIN)&lt;/h1&gt;&lt;h2 id=&quot;1-观察开源项目&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="分析开源项目-EL-ADMIN"><a href="#分析开源项目-EL-ADMIN" class="headerlink" title="分析开源项目 (EL-ADMIN)"></a>分析开源项目 (EL-ADMIN)</h1><h2 id="1-观察开源项目"><a href="#1-观察开源项目" class="headerlink" title="1 观察开源项目"></a>1 观察开源项目</h2><ul><li>后端</li></ul><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210509215359473.png" alt="image-20210509215359473"></p><ul><li>前端</li></ul><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210509215706676.png" alt="image-20210509215706676"></p><h2 id="2-开源项目下载"><a href="#2-开源项目下载" class="headerlink" title="2 开源项目下载"></a>2 开源项目下载</h2><p>下载完毕 ==&gt; 解压 ==&gt; 不要着急运行</p><p><strong>观察</strong></p><ul><li>用了那些技术 (Spring Boot 2.1.0 、 Spring Boot Jpa、 JWT、Spring Security、Redis、Vue、Element-UI)</li><li>是否有数据库 (MySQL)</li><li>你的环境是否匹配 (java， maven，npm，nodejs，redis)</li></ul><p>通过了，然后想办法运行</p><h2 id="3-跑起来是第一步"><a href="#3-跑起来是第一步" class="headerlink" title="3 跑起来是第一步"></a>3 跑起来是第一步</h2><ol><li><p>安装数据库，执行SQL（注意：有没有建库语句）</p></li><li><p>前端需要跑起来(npm 版本最好 6.x.xx)</p></li><li><p>后端项目导入</p></li><li><p>启动后端项目</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210509231414116.png" alt="image-20210509231414116"></p><p>只要发现了 Swagger, 那么跑起来的第一步就是先进入 Swagger-ui 界面! 因为这里面都是接口! </p><p>进而查看配置文件! 默认端口….</p><p>前端就是安装依赖, 启动测试, 看接口是否正常</p></li></ol><h2 id="4-前后端分离项目的固定套路"><a href="#4-前后端分离项目的固定套路" class="headerlink" title="4 前后端分离项目的固定套路"></a>4 前后端分离项目的固定套路</h2><ol><li><p>从前端开始分析。打开控制台，点一个接口，分析一波调用关系！</p></li><li><p>前后端端口调用不一致 8013 - - 8000，怎么操作的</p><ul><li><p>封装了接口请求    ajax    axios    request</p></li><li><p>找到配置</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510005019305.png" alt="image-20210510005019305"></p></li><li><p>前后端 分离项目：找到接口的调用关系</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510005313002.png" alt="image-20210510005313002"></p></li><li><p>SpringBoot提供服务！前端调用接口获取数据！Vue负责渲染页面！</p></li><li><p>前端项目固定套路</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510005527489.png" alt="image-20210510005527489"></p></li><li><p>通过抓取前端的请求，找到后端对应的接口</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510014254626.png" alt="image-20210510014254626"></p></li><li><p>后端分析</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510014559981.png" alt="image-20210510014559981"></p></li><li><p>Controller — Service — Dao/Mapper</p></li><li><p>现在从前到后就可以分析了！但是如何渲染到视图上？看前端</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510014916833.png" alt="image-20210510014916833"></p></li><li><p>Vue 标准套路</p><p><img src="/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/image-20210510015129858.png" alt="image-20210510015129858"></p></li></ul></li></ol><h2 id="5-如何找到一个好的开源项目"><a href="#5-如何找到一个好的开源项目" class="headerlink" title="5 如何找到一个好的开源项目"></a>5 如何找到一个好的开源项目</h2><ol><li>按分类</li><li>看收藏</li><li>看具有价值</li></ol>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Win/">Win</category>
      
      
      <category domain="https://pncalbl.github.io/tags/%E5%BC%80%E6%BA%90/">开源</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/09/%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MybatisPlus 学习</title>
      <link>https://pncalbl.github.io/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 07 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;MybatisPlus-学习&quot;&gt;&lt;a href=&quot;#MybatisPlus-学习&quot; class=&quot;headerlink&quot; title=&quot;MybatisPlus 学习&quot;&gt;&lt;/a&gt;MybatisPlus 学习&lt;/h1&gt;&lt;h2 id=&quot;1-特性&quot;&gt;&lt;a href=&quot;#1</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="MybatisPlus-学习"><a href="#MybatisPlus-学习" class="headerlink" title="MybatisPlus 学习"></a>MybatisPlus 学习</h1><h2 id="1-特性"><a href="#1-特性" class="headerlink" title="1 特性"></a>1 特性</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑。</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2 快速入门"></a>2 快速入门</h2><p>地址: <a href="https://baomidou.com/guide/quick-start.html#初始化工程">快速开始 | MyBatis-Plus (baomidou.com)</a></p><p>使用第三方插件</p><ul><li>导入依赖</li><li>研究依赖如何配置</li><li>代码如何编写</li><li>提高扩展技术能力</li></ul><blockquote><p>  步骤</p></blockquote><ol><li><p>创建数据库 <code>mybatis_plus</code></p></li><li><p>创建user表</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-keyword">user</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>(id <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;主键ID&#x27;</span>,<span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,age <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;年龄&#x27;</span>,email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;邮箱&#x27;</span>,<span class="hljs-keyword">PRIMARY KEY</span> (id));# 插入数据<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (id, <span class="hljs-type">name</span>, age, email) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Jone&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;test1@baomidou.com&#x27;</span>),(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;test2@baomidou.com&#x27;</span>),(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&#x27;test3@baomidou.com&#x27;</span>),(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Sandy&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;test4@baomidou.com&#x27;</span>),(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;Billie&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;test5@baomidou.com&#x27;</span>);</code></pre></div></li><li><p>编写项目, 使用springBoot初始化!</p></li><li><p>导入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>说明: 我们使用mybatis-plus可以节省我们大量的代码, 尽量不要同时导入 mybatis 和 mybatis-plus, 可能会产生版本差异!</p></li><li><p>连接数据库</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis_plus?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=GMT</span></code></pre></div></li><li><p>pojo dao-service-controller</p><ul><li><p>pojo</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<span class="hljs-keyword">private</span> Long id;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> Integer age;<span class="hljs-keyword">private</span> String email;&#125;</code></pre></div></li><li><p>mapper</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 在对应的Mapper上面继承基本的类 BaseMapper</span><span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<span class="hljs-comment">//所有的CRUD操作都已经编写完成</span>&#125;</code></pre></div></li><li><p>启动类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 扫描我们的 mapper 文件夹</span><span class="hljs-meta">@MapperScan(&quot;com.pnca.mapper&quot;)</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusApplication</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SpringApplication.run(MybatisPlusApplication.class, args);   &#125;&#125;</code></pre></div></li><li><p>test</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusApplicationTests</span> </span>&#123;   <span class="hljs-comment">//    继承了 BaseMapper, 所有的方法都来自于父类</span>   <span class="hljs-comment">// 我们也可以编写自己的扩展方法</span>   <span class="hljs-meta">@Resource</span>   <span class="hljs-keyword">private</span> UserMapper userMapper;   <span class="hljs-meta">@Test</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">// 参数是一个 queryWrapper, 条件构造器</span>      List&lt;User&gt; users = userMapper.selectList(<span class="hljs-keyword">null</span>);      users.forEach(System.out::println);   &#125;&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210508023409052-1620412451084.png" alt="image-20210508023409052"></p></li></ul></li></ol><h2 id="3-配置日志"><a href="#3-配置日志" class="headerlink" title="3 配置日志"></a>3 配置日志</h2><p>我们所有的sqld现在都是不可见的，我们希望知道它是怎么执行的，所以我们必须要看日志！</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># 配置日志 (系统自带的，控制台输出)</span><span class="hljs-attr">mybatis-plus:</span>  <span class="hljs-attr">configuration:</span>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span></code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210511230039334.png" alt="image-20210511230039334"></p><p>配置完毕日志之后，后面的学习就需要注意这个自动生成的SQL，你们就会喜欢上MyBatis-Plus !</p><h2 id="4-CRUD"><a href="#4-CRUD" class="headerlink" title="4 CRUD"></a>4 CRUD</h2><h3 id="4-1-插入操作"><a href="#4-1-插入操作" class="headerlink" title="4.1 插入操作"></a>4.1 插入操作</h3><blockquote><p>  Insert 插入</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;User user = <span class="hljs-keyword">new</span> User();user.setName(<span class="hljs-string">&quot;Daniel&quot;</span>);user.setAge(<span class="hljs-number">3</span>);user.setEmail(<span class="hljs-string">&quot;daniel@alibaba.com&quot;</span>);<span class="hljs-keyword">int</span> result = userMapper.insert(user);   <span class="hljs-comment">//帮我们自动生成id</span>System.out.println(result); <span class="hljs-comment">// 受影响的行数</span>System.out.println(user);   <span class="hljs-comment">// 发现: id自动回填</span>&#125;</code></pre></div><blockquote><p>  数据库插入的id默认值为：全局的唯一id</p></blockquote><h3 id="4-2-主键生成策略"><a href="#4-2-主键生成策略" class="headerlink" title="4.2 主键生成策略"></a>4.2 主键生成策略</h3><blockquote><p>  默认 ID_WORKER 全局唯一id</p></blockquote><p>分布式系统唯一id生成：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p><p><strong>雪花算法：</strong></p><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！</p><blockquote><p>  主键自增</p></blockquote><p>我们需要配置主键自增：</p><ol><li><p>实体类字段上 <code>@TableId(type = IdType.AUTO)</code></p></li><li><p>数据库字段上一定是自增的</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210511231840472.png" alt="image-20210511231840472"></p></li><li><p>再次测试即可</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210511232040319.png" alt="image-20210511232040319"></p></li></ol><blockquote><p>  其余的源码解释</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">IdType</span> </span>&#123;    AUTO(<span class="hljs-number">0</span>), <span class="hljs-comment">// 数据库id自增</span>    NONE(<span class="hljs-number">1</span>), <span class="hljs-comment">// 未设置主键</span>    INPUT(<span class="hljs-number">2</span>), <span class="hljs-comment">// 手动输入，自己写id</span>    ID_WORKER(<span class="hljs-number">3</span>), <span class="hljs-comment">// 默认的全局唯一id</span>    UUID(<span class="hljs-number">4</span>), <span class="hljs-comment">// 全局唯一id uuid</span>    ID_WORKER_STR(<span class="hljs-number">5</span>); <span class="hljs-comment">// ID_WORKER 字符串表示法</span>&#125;</code></pre></div><h3 id="4-3-更新操作"><a href="#4-3-更新操作" class="headerlink" title="4.3 更新操作"></a>4.3 更新操作</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试更新</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span></span>&#123;    User user = <span class="hljs-keyword">new</span> User();    <span class="hljs-comment">// 通过条件自动拼接动态sql</span>    user.setId(<span class="hljs-number">6L</span>);    user.setName(<span class="hljs-string">&quot;关注我的微信公众号&quot;</span>);    user.setAge(<span class="hljs-number">18</span>);    <span class="hljs-comment">// 注意： updateById 但是参数是一个 对象</span>    <span class="hljs-keyword">int</span> i = userMapper.updateById(user);    System.out.println(i);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210512000742878.png" alt="image-20210512000742878"></p><p>所有的sql都是自动帮你动态配置的！</p><h3 id="4-4-自动填充"><a href="#4-4-自动填充" class="headerlink" title="4.4 自动填充"></a>4.4 自动填充</h3><p>创建时间、修改时间！这些个操作一般都是自动化完成的，我们不希望手动更新！</p><p><strong>阿里巴巴开发手册：</strong>所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需要自动化！</p><blockquote><p>  方式一：数据库级别（工作中不允许修改数据库）</p></blockquote><ol><li>在表中新增字段 create_time,update_time</li></ol><ol start="2"><li><p>再次测试插入方法，我们需要先把实体类同步</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Date createTime;<span class="hljs-keyword">private</span> Date updateTime;</code></pre></div></li></ol><ol start="3"><li>再次查看更新结果即可</li></ol><blockquote><p>  方式二：代码级别</p></blockquote><ol><li><p>删除数据库中的默认值、更新操作</p></li><li><p>实体类的字段属性上需要增加注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//字段添加填充内容</span><span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><span class="hljs-keyword">private</span> LocalDateTime createTime;<span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><span class="hljs-keyword">private</span> LocalDateTime updateTime;</code></pre></div></li><li><p>编写处理器来处理这个注解即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Log4j2</span><span class="hljs-meta">@Component</span>  <span class="hljs-comment">// 一定不要忘记把处理器加到IOC容器中</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MetaObjectHandler</span> </span>&#123;<span class="hljs-comment">// 插入时的填充策略</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;log.info(<span class="hljs-string">&quot;start insert fill.........&quot;</span>);<span class="hljs-keyword">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;createTime&quot;</span>, LocalDateTime::now, LocalDateTime.class); <span class="hljs-comment">// 起始版本 3.3.3(推荐)</span><span class="hljs-keyword">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime::now, LocalDateTime.class);&#125;<span class="hljs-comment">// 更新时的填充策略</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;log.info(<span class="hljs-string">&quot;start update fill.........&quot;</span>);<span class="hljs-keyword">this</span>.strictUpdateFill(metaObject, <span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime::now, LocalDateTime.class); <span class="hljs-comment">// 起始版本 3.3.3(推荐)</span>&#125;&#125;</code></pre></div></li></ol><h3 id="4-5-乐观锁"><a href="#4-5-乐观锁" class="headerlink" title="4.5 乐观锁"></a>4.5 乐观锁</h3><p>在面试过程中，我们经常会被问到乐观锁，悲观锁。</p><ul><li>乐观锁：顾名思义，它总是认为不会出现问题，无论干什么都不去上锁！如果出现了问题，再次更新值测试！</li></ul><ul><li>悲观锁：顾名思义，它总是认为总是出现问题，无论干什么都上锁！再去操作！</li></ul><p>乐观锁实现方式：</p><ul><li><p>取出记录时，获取当前version</p></li><li><p>更新时，带上这个version</p></li><li><p>执行更新时， set version = newVersion where version = oldVersion</p></li><li><p>如果version不对，就更新失败</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210516214644902.png" alt="image-20210516214644902"></p></li><li><p>测试一下MyBatisPlus的插件：</p><ul><li><p>增加 version 字段</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210516214935863.png" alt="image-20210516214935863"></p></li><li><p>我们给实体类增加相应的字段</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Version</span>    <span class="hljs-comment">// 乐观锁 Version 注解</span><span class="hljs-keyword">private</span> Integer version;</code></pre></div></li><li><p>注册组件, 编写配置类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 扫描我们的 mapper 文件夹</span><span class="hljs-meta">@MapperScan(&quot;com.pnca.mapper&quot;)</span><span class="hljs-meta">@EnableTransactionManagement</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 新版</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title">mybatisPlusInterceptor</span><span class="hljs-params">()</span> </span>&#123;MybatisPlusInterceptor mybatisPlusInterceptor = <span class="hljs-keyword">new</span> MybatisPlusInterceptor();mybatisPlusInterceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> OptimisticLockerInnerInterceptor());<span class="hljs-keyword">return</span> mybatisPlusInterceptor;&#125;&#125;</code></pre></div></li></ul></li></ul><h3 id="4-6-查询操作"><a href="#4-6-查询操作" class="headerlink" title="4.6 查询操作"></a>4.6 查询操作</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试查询</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectById</span><span class="hljs-params">()</span> </span>&#123;    User user = userMapper.selectById(<span class="hljs-number">1L</span>);    System.out.println(<span class="hljs-string">&quot;查询的用户为: &quot;</span> + user);&#125;<span class="hljs-comment">// 批量查询</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectByBatchId</span><span class="hljs-params">()</span> </span>&#123;    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));    users.forEach(System.out::println);&#125;<span class="hljs-comment">// 条件查询, 使用map</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectByMap</span><span class="hljs-params">()</span> </span>&#123;    HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">// 自定义查询</span>    map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>);    map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">28</span>);    List&lt;User&gt; users = userMapper.selectByMap(map);    users.forEach(System.out::println);&#125;</code></pre></div><h3 id="4-7-分页查询"><a href="#4-7-分页查询" class="headerlink" title="4.7 分页查询"></a>4.7 分页查询</h3><p>分页网站频繁使用</p><ol><li>原始使用limit进行分页</li><li>pageHelper第三方插件</li><li>MybatisPlus内置了分页插件</li></ol><blockquote><p>  如何使用？</p></blockquote><ol><li><p>配置拦截器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 分页插件</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title">paginationInterceptor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PaginationInterceptor();&#125;</code></pre></div></li><li><p>直接使用Page对象即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试分页查询</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPage</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 参数一: 当前页</span>    <span class="hljs-comment">// 参数二： 页面大小</span>    <span class="hljs-comment">// 使用了分页插件之后，所有的分页操作变得简单了</span>    Page&lt;User&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);    userMapper.selectPage(page, <span class="hljs-keyword">null</span>);    page.getRecords().forEach(System.out::println);    System.out.println(page.getTotal());&#125;</code></pre></div></li></ol><h3 id="4-8-删除操作"><a href="#4-8-删除操作" class="headerlink" title="4.8 删除操作"></a>4.8 删除操作</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试删除</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testdelete</span><span class="hljs-params">()</span></span>&#123;    userMapper.deleteById(<span class="hljs-number">6L</span>);&#125;<span class="hljs-comment">// 测试批量删除</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testdeleteBatchId</span><span class="hljs-params">()</span></span>&#123;    userMapper.deleteBatchIds(Arrays.asList(<span class="hljs-number">1287326823914405893L</span>,<span class="hljs-number">1287326823914405894L</span>));&#125;<span class="hljs-comment">//通过map删除</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeleteByMap</span><span class="hljs-params">()</span></span>&#123;    HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;KUANG&quot;</span>);    userMapper.deleteByMap(map);&#125;</code></pre></div><p>我们在工作中会遇到一些问题：逻辑删除！</p><h3 id="4-9-逻辑删除"><a href="#4-9-逻辑删除" class="headerlink" title="4.9 逻辑删除"></a>4.9 逻辑删除</h3><blockquote><p>  物理删除：从数据库中直接移除</p><p>  逻辑删除：在数据库中没有被移除，而是通过一个变量让他生效！deleted=0 –&gt; deleted=1</p></blockquote><p>管理员可以查看被删除的记录！防止数据的丢失！类似于回收站！</p><p><strong>测试：</strong></p><ol><li><p>在数据库表中增加一个deleted字段</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210518235020299.png" alt="image-20210518235020299"></p></li><li><p>实体类中增加属性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@TableLogic</span> <span class="hljs-comment">// 逻辑删除</span><span class="hljs-keyword">private</span> Integer deleted;</code></pre></div></li><li><p>配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 逻辑删除组件</span><span class="hljs-comment">// 高版本不用配置,直接注解即可</span><span class="hljs-function"><span class="hljs-keyword">public</span> ISqlInjector <span class="hljs-title">sqlInjector</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogicSqlInjector();&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">global-config:</span>  <span class="hljs-attr">db-config:</span>    <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span>    <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span></code></pre></div></li><li><p>测试删除</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210519000137360.png" alt="image-20210519000137360"></p></li><li><p>测试查询</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210519000241200.png" alt="image-20210519000241200"></p></li></ol><blockquote><p>  以上所有的CRUD操作及其扩展操作，我们必须精通掌握！会大大提高工作效率！</p></blockquote><h2 id="5-性能分析插件"><a href="#5-性能分析插件" class="headerlink" title="5 性能分析插件"></a>5 性能分析插件</h2><p>我们在平时的开发中，会遇到一些慢sql。解决方案：测试，druid监控…</p><p><strong>作用：性能分析拦截器，用于输出每条SQL语句及其执行时间</strong></p><p>MyBatisPlus也提供性能分析插件，如果超过这个时间就停止运行！</p><ol><li><p>导入插件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// SQL执行效率插件</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> PerformanceInterceptor <span class="hljs-title">performanceInterceptor</span><span class="hljs-params">()</span></span>&#123;    PerformanceInterceptor performanceInterceptor = <span class="hljs-keyword">new</span> PerformanceInterceptor();    performanceInterceptor.setMaxTime(<span class="hljs-number">100</span>); <span class="hljs-comment">//ms 设置sql执行的最大时间，如果超过了则不执行</span>    performanceInterceptor.setFormat(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 是否格式化</span>    <span class="hljs-keyword">return</span> performanceInterceptor;&#125;</code></pre></div><p>记住，要在SpringBoot中配置环境为dev或者test环境！</p></li><li><p>测试使用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 测试查询</span><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelectById</span><span class="hljs-params">()</span></span>&#123;    User user = userMapper.selectById(<span class="hljs-number">3</span>);    System.out.println(user);&#125;</code></pre></div></li><li><p><strong>注意</strong>：此插件在 3.2.0 版本被移除，推荐使用第三方扩展，执行 SQL 分析打印。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/p6spy/p6spy --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>p6spy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>p6spy<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522160038875.png" alt="image-20210522160038875"></p></li></ol><h2 id="6-条件构造器"><a href="#6-条件构造器" class="headerlink" title="6 条件构造器"></a>6 条件构造器</h2><p>十分重要：wrapper</p><p>我们写一些复杂的sql就可以使用它来代替！</p><ul><li><p>测试1</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 查询 name 不为空的用户, 并且邮箱不为空的用户, 年龄大于等于12</span>QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();wrapper.isNotNull(<span class="hljs-string">&quot;name&quot;</span>).isNotNull(<span class="hljs-string">&quot;email&quot;</span>).ge(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">12</span>);<span class="hljs-comment">// 参数是一个 queryWrapper, 条件构造器</span>List&lt;User&gt; users = userMapper.selectList(wrapper);users.forEach(System.out::println);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522162040245.png" alt="image-20210522162040245"></p></li><li><p>测试2</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testEqName</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// 查询名字为 pncalbl</span>   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();   wrapper.eq(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;pncalbl&quot;</span>);   <span class="hljs-comment">// 参数是一个 queryWrapper, 条件构造器</span>   User user = userMapper.selectOne(wrapper);   System.out.println(user);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522162009883.png" alt="image-20210522162009883"></p></li><li><p>测试3</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCount</span><span class="hljs-params">()</span> </span>&#123;   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();   wrapper.between(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 区间</span>   userMapper.selectCount(wrapper);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522162331965.png" alt="image-20210522162331965"></p></li><li><p>测试4</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testLike</span><span class="hljs-params">()</span> </span>&#123;   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();   <span class="hljs-comment">// 左和右 %e%，例如 t%</span>   wrapper.notLike(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;pncalbl&quot;</span>)         .likeRight(<span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>);   List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);   maps.forEach(System.out::println);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522163022658.png" alt="image-20210522163022658"></p></li><li><p>测试5</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSelectObjects</span><span class="hljs-params">()</span> </span>&#123;   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();   <span class="hljs-comment">// id 在子查询中查出来</span>   wrapper.inSql(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;select id from user where id &lt; 3&quot;</span>);   List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);   objects.forEach(System.out::println);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522163345953.png" alt="image-20210522163345953"></p></li><li><p>测试6</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testOrder</span><span class="hljs-params">()</span> </span>&#123;   QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();   <span class="hljs-comment">// 通过 id 进行排序</span>   wrapper.orderByDesc(<span class="hljs-string">&quot;id&quot;</span>);   List&lt;User&gt; users = userMapper.selectList(wrapper);   users.forEach(System.out::println);&#125;</code></pre></div><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/image-20210522163715836.png" alt="image-20210522163715836"></p></li></ul><h2 id="7-代码生成器"><a href="#7-代码生成器" class="headerlink" title="7 代码生成器"></a>7 代码生成器</h2><p>dao、pojo、service、controller都给我自己去编写完成！</p><p>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p><blockquote><p>  特别说明:</p><p>  自定义模板有哪些可用参数？<a href="https://github.com/baomidou/generator/blob/develop/mybatis-plus-generator/src/main/java/com/baomidou/mybatisplus/generator/engine/AbstractTemplateEngine.java">Github (opens new window)</a>AbstractTemplateEngine 类中方法 getObjectMap 返回 objectMap 的所有值都可用。</p></blockquote><h3 id="演示效果图："><a href="#演示效果图：" class="headerlink" title="演示效果图："></a>演示效果图：</h3><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/generator.gif" alt="relationship"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeGenerator</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * &lt;p&gt;</span><span class="hljs-comment">     * 读取控制台内容</span><span class="hljs-comment">     * &lt;/p&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">scanner</span><span class="hljs-params">(String tip)</span> </span>&#123;        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);        StringBuilder help = <span class="hljs-keyword">new</span> StringBuilder();        help.append(<span class="hljs-string">&quot;请输入&quot;</span> + tip + <span class="hljs-string">&quot;：&quot;</span>);        System.out.println(help.toString());        <span class="hljs-keyword">if</span> (scanner.hasNext()) &#123;            String ipt = scanner.next();            <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;                <span class="hljs-keyword">return</span> ipt;            &#125;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MybatisPlusException(<span class="hljs-string">&quot;请输入正确的&quot;</span> + tip + <span class="hljs-string">&quot;！&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 代码生成器</span>        AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();        <span class="hljs-comment">// 全局配置</span>        GlobalConfig gc = <span class="hljs-keyword">new</span> GlobalConfig();        String projectPath = System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>);        gc.setOutputDir(projectPath + <span class="hljs-string">&quot;/src/main/java&quot;</span>);        gc.setAuthor(<span class="hljs-string">&quot;jobob&quot;</span>);        gc.setOpen(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">// gc.setSwagger2(true); 实体属性 Swagger2 注解</span>        mpg.setGlobalConfig(gc);        <span class="hljs-comment">// 数据源配置</span>        DataSourceConfig dsc = <span class="hljs-keyword">new</span> DataSourceConfig();        dsc.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/ant?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);        <span class="hljs-comment">// dsc.setSchemaName(&quot;public&quot;);</span>        dsc.setDriverName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);        dsc.setUsername(<span class="hljs-string">&quot;root&quot;</span>);        dsc.setPassword(<span class="hljs-string">&quot;密码&quot;</span>);        mpg.setDataSource(dsc);        <span class="hljs-comment">// 包配置</span>        PackageConfig pc = <span class="hljs-keyword">new</span> PackageConfig();        pc.setModuleName(scanner(<span class="hljs-string">&quot;模块名&quot;</span>));        pc.setParent(<span class="hljs-string">&quot;com.baomidou.ant&quot;</span>);        mpg.setPackageInfo(pc);        <span class="hljs-comment">// 自定义配置</span>        InjectionConfig cfg = <span class="hljs-keyword">new</span> InjectionConfig() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-comment">// to do nothing</span>            &#125;        &#125;;        <span class="hljs-comment">// 如果模板引擎是 freemarker</span>        String templatePath = <span class="hljs-string">&quot;/templates/mapper.xml.ftl&quot;</span>;        <span class="hljs-comment">// 如果模板引擎是 velocity</span>        <span class="hljs-comment">// String templatePath = &quot;/templates/mapper.xml.vm&quot;;</span>        <span class="hljs-comment">// 自定义输出配置</span>        List&lt;FileOutConfig&gt; focList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 自定义配置会被优先输出</span>        focList.add(<span class="hljs-keyword">new</span> FileOutConfig(templatePath) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">outputFile</span><span class="hljs-params">(TableInfo tableInfo)</span> </span>&#123;                <span class="hljs-comment">// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span>                <span class="hljs-keyword">return</span> projectPath + <span class="hljs-string">&quot;/src/main/resources/mapper/&quot;</span> + pc.getModuleName()                        + <span class="hljs-string">&quot;/&quot;</span> + tableInfo.getEntityName() + <span class="hljs-string">&quot;Mapper&quot;</span> + StringPool.DOT_XML;            &#125;        &#125;);        <span class="hljs-comment">/*</span><span class="hljs-comment">        cfg.setFileCreate(new IFileCreate() &#123;</span><span class="hljs-comment">            @Override</span><span class="hljs-comment">            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) &#123;</span><span class="hljs-comment">                // 判断自定义文件夹是否需要创建</span><span class="hljs-comment">                checkDir(&quot;调用默认方法创建的目录，自定义目录用&quot;);</span><span class="hljs-comment">                if (fileType == FileType.MAPPER) &#123;</span><span class="hljs-comment">                    // 已经生成 mapper 文件判断存在，不想重新生成返回 false</span><span class="hljs-comment">                    return !new File(filePath).exists();</span><span class="hljs-comment">                &#125;</span><span class="hljs-comment">                // 允许生成模板文件</span><span class="hljs-comment">                return true;</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">        &#125;);</span><span class="hljs-comment">        */</span>        cfg.setFileOutConfigList(focList);        mpg.setCfg(cfg);        <span class="hljs-comment">// 配置模板</span>        TemplateConfig templateConfig = <span class="hljs-keyword">new</span> TemplateConfig();        <span class="hljs-comment">// 配置自定义输出模板</span>        <span class="hljs-comment">//指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别</span>        <span class="hljs-comment">// templateConfig.setEntity(&quot;templates/entity2.java&quot;);</span>        <span class="hljs-comment">// templateConfig.setService();</span>        <span class="hljs-comment">// templateConfig.setController();</span>        templateConfig.setXml(<span class="hljs-keyword">null</span>);        mpg.setTemplate(templateConfig);        <span class="hljs-comment">// 策略配置</span>        StrategyConfig strategy = <span class="hljs-keyword">new</span> StrategyConfig();        strategy.setNaming(NamingStrategy.underline_to_camel);        strategy.setColumnNaming(NamingStrategy.underline_to_camel);        strategy.setSuperEntityClass(<span class="hljs-string">&quot;你自己的父类实体,没有就不用设置!&quot;</span>);        strategy.setEntityLombokModel(<span class="hljs-keyword">true</span>);        strategy.setRestControllerStyle(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">// 公共父类</span>        strategy.setSuperControllerClass(<span class="hljs-string">&quot;你自己的父类控制器,没有就不用设置!&quot;</span>);        <span class="hljs-comment">// 写于父类中的公共字段</span>        strategy.setSuperEntityColumns(<span class="hljs-string">&quot;id&quot;</span>);        strategy.setInclude(scanner(<span class="hljs-string">&quot;表名，多个英文逗号分割&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>));        strategy.setControllerMappingHyphenStyle(<span class="hljs-keyword">true</span>);        strategy.setTablePrefix(pc.getModuleName() + <span class="hljs-string">&quot;_&quot;</span>);        mpg.setStrategy(strategy);        mpg.setTemplateEngine(<span class="hljs-keyword">new</span> FreemarkerTemplateEngine());        mpg.execute();    &#125;&#125;</code></pre></div><h3 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h3><h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1 添加依赖"></a>1 添加依赖</h4><p>MyBatis-Plus 从 <code>3.0.3</code> 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖：</p><ul><li><p>添加 代码生成器 依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>添加 模板引擎 依赖，MyBatis-Plus 支持 Velocity（默认）、Freemarker、Beetl，用户可以选择自己熟悉的模板引擎，如果都不满足您的要求，可以采用自定义模板引擎。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity-engine-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>注意！如果您选择了非默认引擎，需要在 AutoGenerator 中 设置模板引擎。</p><div class="code-wrapper"><pre><code class="hljs java">AutoGenerator generator = <span class="hljs-keyword">new</span> AutoGenerator();<span class="hljs-comment">// set freemarker engine</span>generator.setTemplateEngine(<span class="hljs-keyword">new</span> FreemarkerTemplateEngine());<span class="hljs-comment">// set beetl engine</span>generator.setTemplateEngine(<span class="hljs-keyword">new</span> BeetlTemplateEngine());<span class="hljs-comment">// set custom engine (reference class is your custom engine class)</span>generator.setTemplateEngine(<span class="hljs-keyword">new</span> CustomTemplateEngine());<span class="hljs-comment">// other config</span>...</code></pre></div></li></ul><h4 id="2-编写配置"><a href="#2-编写配置" class="headerlink" title="2 编写配置"></a>2 编写配置</h4><p>MyBatis-Plus 的代码生成器提供了大量的自定义参数供用户选择，能够满足绝大部分人的使用需求。</p><ul><li><p>配置 GlobalConfig</p><div class="code-wrapper"><pre><code class="hljs java">GlobalConfig globalConfig = <span class="hljs-keyword">new</span> GlobalConfig();globalConfig.setOutputDir(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;/src/main/java&quot;</span>);globalConfig.setAuthor(<span class="hljs-string">&quot;jobob&quot;</span>);globalConfig.setOpen(<span class="hljs-keyword">false</span>);</code></pre></div></li><li><p>配置 DataSourceConfig</p><div class="code-wrapper"><pre><code class="hljs java">DataSourceConfig dataSourceConfig = <span class="hljs-keyword">new</span> DataSourceConfig();dataSourceConfig.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/ant?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);dataSourceConfig.setDriverName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);dataSourceConfig.setUsername(<span class="hljs-string">&quot;root&quot;</span>);dataSourceConfig.setPassword(<span class="hljs-string">&quot;password&quot;</span>);</code></pre></div></li></ul><h4 id="3-自定义模板引擎"><a href="#3-自定义模板引擎" class="headerlink" title="3 自定义模板引擎"></a>3 自定义模板引擎</h4><p>请继承类 com.baomidou.mybatisplus.generator.engine.AbstractTemplateEngine</p><ul><li><p>自定义代码模板</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//指定自定义模板路径, 位置：/resources/templates/entity2.java.ftl(或者是.vm)</span><span class="hljs-comment">//注意不要带上.ftl(或者是.vm), 会根据使用的模板引擎自动识别</span>TemplateConfig templateConfig = <span class="hljs-keyword">new</span> TemplateConfig()    .setEntity(<span class="hljs-string">&quot;templates/entity2.java&quot;</span>);AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();<span class="hljs-comment">//配置自定义模板</span>mpg.setTemplate(templateConfig);</code></pre></div></li><li><p>自定义属性注入</p><div class="code-wrapper"><pre><code class="hljs java">InjectionConfig injectionConfig = <span class="hljs-keyword">new</span> InjectionConfig() &#123;    <span class="hljs-comment">//自定义属性注入:abc</span>    <span class="hljs-comment">//在.ftl(或者是.vm)模板中，通过$&#123;cfg.abc&#125;获取属性</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span><span class="hljs-params">()</span> </span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-keyword">this</span>.getConfig().getGlobalConfig().getAuthor() + <span class="hljs-string">&quot;-mp&quot;</span>);        <span class="hljs-keyword">this</span>.setMap(map);    &#125;&#125;;AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();<span class="hljs-comment">//配置自定义属性注入</span>mpg.setCfg(injectionConfig);</code></pre></div></li><li><p>字段其他信息查询注入</p><p><img src="/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/custom-fields.png" alt="relationship"></p></li></ul><div class="code-wrapper"><pre><code><pre><code class="hljs java"><span class="hljs-keyword">new</span> DataSourceConfig().setDbQuery(<span class="hljs-keyword">new</span> MySqlQuery() &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 重写父类预留查询自定义字段&lt;br&gt;</span><span class="hljs-comment">     * 这里查询的 SQL 对应父类 tableFieldsSql 的查询字段，默认不能满足你的需求请重写它&lt;br&gt;</span><span class="hljs-comment">     * 模板中调用：  table.fields 获取所有字段信息，</span><span class="hljs-comment">     * 然后循环字段获取 field.customMap 从 MAP 中获取注入字段如下  NULL 或者 PRIVILEGES</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String[] fieldCustom() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;NULL&quot;</span>, <span class="hljs-string">&quot;PRIVILEGES&quot;</span>&#125;;    &#125;&#125;)</code></pre></div></code></pre>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Java/">Java</category>
      
      <category domain="https://pncalbl.github.io/categories/Java/Mybatis/">Mybatis</category>
      
      
      
      <comments>https://pncalbl.github.io/2021/05/08/MybatisPlus%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Redis 学习</title>
      <link>https://pncalbl.github.io/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 07 May 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Redis-学习&quot;&gt;&lt;a href=&quot;#Redis-学习&quot; class=&quot;headerlink&quot; title=&quot;Redis 学习&quot;&gt;&lt;/a&gt;Redis 学习&lt;/h1&gt;&lt;h2 id=&quot;1-Nosql-概述&quot;&gt;&lt;a href=&quot;#1-Nosql-概述&quot; class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Redis-学习"><a href="#Redis-学习" class="headerlink" title="Redis 学习"></a>Redis 学习</h1><h2 id="1-Nosql-概述"><a href="#1-Nosql-概述" class="headerlink" title="1  Nosql 概述"></a>1  Nosql 概述</h2><h3 id="1-1-为什么要使用-Nosql"><a href="#1-1-为什么要使用-Nosql" class="headerlink" title="1.1 为什么要使用 Nosql"></a>1.1 为什么要使用 Nosql</h3><blockquote><p>  1、单机Mysql时代</p></blockquote><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020082010365930.png" alt></p><p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题</p><ol><li>数据量增加到一定程度，单机数据库就放不下了</li><li>数据的索引（B+ Tree）,一个机器内存也存放不下</li><li>访问量变大后（读写混合），一台服务器承受不住。</li></ol><blockquote><p>  2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）</p></blockquote><p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103713734.png" alt></p><p>优化过程经历了以下几个过程：</p><p>优化数据库的数据结构和索引(难度大)</p><p>文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</p><p>MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</p><blockquote><p>  3、分库分表 + 水平拆分 + Mysql集群</p></blockquote><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103739584.png" alt></p><blockquote><p>  4、如今最近的年代</p></blockquote><p>如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。</p><h3 id="1-2-什么是-Nosql"><a href="#1-2-什么是-Nosql" class="headerlink" title="1.2 什么是 Nosql"></a>1.2 什么是 Nosql</h3><p><strong>NoSQL = Not Only SQL（不仅仅是SQL）</strong></p><p>Not Only Structured Query Language</p><p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p><p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p><p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p><h3 id="1-3-Nosql-特点"><a href="#1-3-Nosql-特点" class="headerlink" title="1.3 Nosql 特点"></a>1.3 Nosql 特点</h3><ol><li><p>方便扩展（数据之间没有关系，很好扩展！）</p></li><li><p>大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p></li><li><p>数据类型是多样型的！（不需要事先设计数据库，随取随用）</p></li><li><p>传统的 RDBMS 和 NoSQL</p><div class="code-wrapper"><pre><code class="hljs asciidoc">传统的 RDBMS(关系型数据库)<span class="hljs-bullet">- </span>结构化组织<span class="hljs-bullet">- </span>SQL<span class="hljs-bullet">- </span>数据和关系都存在单独的表中 row col<span class="hljs-bullet">- </span>操作，数据定义语言<span class="hljs-bullet">- </span>严格的一致性<span class="hljs-bullet">- </span>基础的事务<span class="hljs-bullet">- </span>...</code></pre></div><div class="code-wrapper"><pre><code class="hljs asciidoc">Nosql<span class="hljs-bullet">- </span>不仅仅是数据<span class="hljs-bullet">- </span>没有固定的查询语言<span class="hljs-bullet">- </span>键值对存储，列存储，文档存储，图形数据库（社交关系）<span class="hljs-bullet">- </span>最终一致性<span class="hljs-bullet">- </span>CAP定理和BASE<span class="hljs-bullet">- </span>高性能，高可用，高扩展<span class="hljs-bullet">- </span>...</code></pre></div></li></ol><blockquote><p>  了解：3V + 3高</p></blockquote><p>大数据时代的3V ：主要是<strong>描述问题</strong>的</p><ol><li>海量Velume</li><li>多样Variety</li><li>实时Velocity</li></ol><p>大数据时代的3高 ： 主要是<strong>对程序的要求</strong></p><ol><li>高并发</li><li>高可扩</li><li>高性能</li></ol><p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p><h3 id="1-4-阿里巴巴演进分析"><a href="#1-4-阿里巴巴演进分析" class="headerlink" title="1.4 阿里巴巴演进分析"></a>1.4 阿里巴巴演进分析</h3><p>推荐阅读：阿里云的这群疯子<a href="https://yq.aliyun.com/articles/653511">https://yq.aliyun.com/articles/653511</a></p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103829446.png" alt></p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103851613.png" alt></p><div class="code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># 商品信息</span><span class="hljs-bullet">-</span> 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。<span class="hljs-section"># 商品描述、评论(文字居多)</span><span class="hljs-bullet">-</span> 文档型数据库：MongoDB<span class="hljs-section"># 图片</span><span class="hljs-bullet">-</span> 分布式文件系统 FastDFS<span class="hljs-bullet">-</span> 淘宝：TFS<span class="hljs-bullet">-</span> Google: GFS<span class="hljs-bullet">-</span> Hadoop: HDFS<span class="hljs-bullet">-</span> 阿里云: oss<span class="hljs-section"># 商品关键字 用于搜索</span><span class="hljs-bullet">-</span> 搜索引擎：solr,elasticsearch<span class="hljs-bullet">-</span> 阿里：Isearch 多隆<span class="hljs-section"># 商品热门的波段信息</span><span class="hljs-bullet">-</span> 内存数据库：Redis，Memcache<span class="hljs-section"># 商品交易，外部支付接口</span><span class="hljs-bullet">-</span> 第三方应用</code></pre></div><h3 id="1-5-Nosql-的四大分类"><a href="#1-5-Nosql-的四大分类" class="headerlink" title="1.5 Nosql 的四大分类"></a>1.5 Nosql 的四大分类</h3><blockquote><p>  <strong>KV键值对</strong></p></blockquote><ul><li>新浪：<strong>Redis</strong></li><li>美团：Redis + Tair</li><li>阿里、百度：Redis + Memcache</li></ul><blockquote><p>  <strong>文档型数据库（bson数据格式）：</strong></p></blockquote><ul><li><strong>MongoDB</strong>(掌握)<ul><li>基于分布式文件存储的数据库。C++编写，用于处理大量文档。</li><li>MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。</li></ul></li><li>ConthDB</li></ul><blockquote><p>  <strong>列存储数据库</strong></p></blockquote><ul><li><strong>HBase</strong>(大数据必学)</li><li>分布式文件系统</li></ul><blockquote><p>  <strong>图关系数据库</strong></p></blockquote><p>用于广告推荐，社交网络</p><ul><li><strong>Neo4j</strong>、InfoGrid</li></ul><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210512004919811.png" alt></p><h2 id="2-redis-入门"><a href="#2-redis-入门" class="headerlink" title="2 redis 入门"></a>2 redis 入门</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1  概述"></a>1  概述</h3><ul><li><p>Redis是什么？</p><ul><li><p>Redis（Remote Dictionary Server )，即远程字典服务。</p></li><li><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p></li><li><p>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p></li></ul></li><li><p>Redis能该干什么？</p><ul><li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li><li>高效率、用于高速缓冲</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器(eg：浏览量)</li></ul></li><li><p>特性</p><ul><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li></ul></li></ul><h3 id="1-2-环境搭建"><a href="#1-2-环境搭建" class="headerlink" title="1.2 环境搭建"></a>1.2 环境搭建</h3><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>推荐使用Linux服务器学习。</p><p>windows版本的Redis已经停更很久了</p><h3 id="1-3-windows-安装"><a href="#1-3-windows-安装" class="headerlink" title="1.3 windows 安装"></a>1.3 windows 安装</h3><p><a href="https://github.com/dmajkic/redis">https://github.com/dmajkic/redis</a></p><ul><li><p>解压安装包</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103922318.png" alt></p></li><li><p>开启redis-server.exe</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820103950934.png" alt></p></li><li><p>启动redis-cli.exe测试</p></li></ul><h3 id="1-4-Linux-安装"><a href="#1-4-Linux-安装" class="headerlink" title="1.4 Linux 安装"></a>1.4 Linux 安装</h3><ul><li><p>下载安装包！<code>redis-5.0.8.tar.gz</code></p></li><li><p>解压Redis的安装包！程序一般放在 <code>/usr/local/redis</code> 目录下</p></li><li><p>基本环境安装</p><div class="code-wrapper"><pre><code class="hljs shell">yum install gcc-c++<span class="hljs-meta">#</span><span class="bash"> 然后进入redis目录下执行</span>make<span class="hljs-meta">#</span><span class="bash"> 然后执行</span>make install</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104048327.png" alt></p></li><li><p>将 REDIS 安装为系统服务并后台启动</p><div class="code-wrapper"><pre><code class="hljs shell">[root@localhost redis-5.0.8]# cd utils/ [root@localhost utils]# ./install_server.sh</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214319345.png" alt></p></li><li><p>查看REDIS服务启动情况</p><div class="code-wrapper"><pre><code class="hljs shell">systemctl status redis_6379.service</code></pre></div></li></ul><h3 id="1-5-测试性能"><a href="#1-5-测试性能" class="headerlink" title="1.5 测试性能"></a>1.5 测试性能</h3><ul><li><p>启动REDIS客户端并测试</p><div class="code-wrapper"><pre><code class="hljs shell">redis-cli</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214531489.png" alt></p></li><li><p>设置允许远程连接</p><div class="code-wrapper"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>redis/<span class="hljs-number">6379</span>.conf</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214552849-1621086353677.png" alt></p><div class="code-wrapper"><pre><code class="hljs shell">systemctl restart redis_6379.service</code></pre></div></li><li><p>设置访问密码</p><div class="code-wrapper"><pre><code class="hljs shell">vim /etc/redis/6379.conf</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214651751.png" alt></p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/image-20210515214712651.png" alt></p></li><li><p>redis-benchmark：Redis官方提供的性能测试工具，参数选项如下：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214125892.png" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试：100个并发连接 100000请求</span>redis-benchmark -h localhost -p 6379 -c 100 -n 100000</code></pre></div><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104343472.png" alt></p></li></ul><h3 id="1-6-基础知识"><a href="#1-6-基础知识" class="headerlink" title="1.6 基础知识"></a>1.6 基础知识</h3><ul><li><p>redis默认有16个数据库</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104357466.png" alt></p><p>默认使用的第0个;</p><p>16个数据库为：DB 0~DB 15<br>默认使用DB 0 ，可以使用<code>select n</code>切换到DB n，<code>dbsize</code>可以查看当前数据库的大小，与key数量相关。</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; config get databases # 命令行查看数据库数量databases1) &quot;databases&quot;2) &quot;16&quot;127.0.0.1:6379&gt; select 8 # 切换数据库 DB 8OK127.0.0.1:6379[8]&gt; dbsize # 查看数据库大小(integer) 0<span class="hljs-meta">#</span><span class="bash"> 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。</span>127.0.0.1:6379&gt; set name sakura OK127.0.0.1:6379&gt; SELECT 8OK127.0.0.1:6379[8]&gt; get name # db8中并不能获取db0中的键值对。(nil)127.0.0.1:6379[8]&gt; DBSIZE(integer) 0127.0.0.1:6379[8]&gt; SELECT 0OK127.0.0.1:6379&gt; keys *1) &quot;counter:__rand_int__&quot;2) &quot;mylist&quot;3) &quot;name&quot;4) &quot;key:__rand_int__&quot;5) &quot;myset:__rand_int__&quot;127.0.0.1:6379&gt; DBSIZE # size和key个数相关(integer) 5</code></pre></div><p><code>keys *</code> ：查看当前数据库中所有的key。</p><p><code>flushdb</code>：清空当前数据库中的键值对。</p><p><code>flushall</code>：清空所有数据库的键值对。</p></li><li><p><strong>Redis是单线程的，Redis是基于内存操作的。</strong></p><ul><li>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</li><li>那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+</li></ul></li><li><p><strong>Redis为什么单线程还这么快</strong></p><ul><li>误区1：高性能的服务器一定是多线程的？</li><li>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</li><li>核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</li></ul></li></ul><h2 id="3-五大数据类型"><a href="#3-五大数据类型" class="headerlink" title="3 五大数据类型"></a>3 五大数据类型</h2><p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p><h3 id="3-1-Redis-key"><a href="#3-1-Redis-key" class="headerlink" title="3.1 Redis-key"></a>3.1 Redis-key</h3><p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p><p>下面学习的命令：</p><ul><li><p><code>exists key</code>：判断键是否存在</p></li><li><p><code>del key</code>：删除键值对</p></li><li><p><code>move key db</code>：将键值对移动到指定数据库</p></li><li><p><code>expire key second</code>：设置键值对的过期时间</p></li><li><p><code>type key</code>：查看value的数据类型</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; keys * # 查看当前数据库所有key(empty list or set)127.0.0.1:6379&gt; set name qinjiang # set keyOK127.0.0.1:6379&gt; set age 20OK127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; move age 1 # 将键值对移动到指定数据库(integer) 1127.0.0.1:6379&gt; EXISTS age # 判断键是否存在(integer) 0 # 不存在127.0.0.1:6379&gt; EXISTS name(integer) 1 # 存在127.0.0.1:6379&gt; SELECT 1OK127.0.0.1:6379[1]&gt; keys *1) &quot;age&quot;127.0.0.1:6379[1]&gt; del age # 删除键值对(integer) 1 # 删除个数127.0.0.1:6379&gt; set age 20OK127.0.0.1:6379&gt; EXPIRE age 15 # 设置键值对的过期时间(integer) 1 # 设置成功 开始计数127.0.0.1:6379&gt; ttl age # 查看key的过期剩余时间(integer) 13127.0.0.1:6379&gt; ttl age(integer) 11127.0.0.1:6379&gt; ttl age(integer) 9127.0.0.1:6379&gt; ttl age(integer) -2 # -2 表示key过期，-1表示key未设置过期时间127.0.0.1:6379&gt; get age # 过期的key 会被自动delete(nil)127.0.0.1:6379&gt; keys *&quot;name&quot;127.0.0.1:6379&gt; type name # 查看value的数据类型string</code></pre></div></li><li><p>关于TTL命令</p></li><li><p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p><ul><li>当前key没有设置过期时间，所以会返回-1.</li><li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li><li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li></ul></li><li><p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p><ul><li><code>RENAME key newkey</code>修改 key 的名称</li><li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li></ul></li></ul><h3 id="3-2-String"><a href="#3-2-String" class="headerlink" title="3.2 String"></a>3.2 String</h3><p>普通的set、get直接略过。</p><p>常用命令及其示例：</p><p><code>APPEND key value</code>: 向指定的key的value后追加字符串</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg &quot; world&quot; (integer) 11 127.0.0.1:6379&gt; get msg “hello world”</code></pre></div><p><code>DECR/INCR key</code>: 将指定key的value数值进行+1/-1(仅对于数字)</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20</code></pre></div><p><code>INCRBY/DECRBY key n</code>: 按指定的步长对数值进行加减</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; INCRBY age 5(integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15</code></pre></div><p><code>INCRBYFLOAT key n</code>: 为数值加上浮点型数值</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</code></pre></div><p><code>STRLEN key</code>: 获取key保存值的字符串长度</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11</code></pre></div><p><code>GETRANGE key start end</code>: 按起止位置获取字符串（闭区间，起止位置都取）</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”</code></pre></div><p><code>SETRANGE key offset value</code>:用指定的value 替换key中 offset开始的值</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set msg helloOK127.0.0.1:6379&gt; setrange msg 2 hello(integer) 7127.0.0.1:6379&gt; get msg&quot;hehello&quot;127.0.0.1:6379&gt; set msg2 worldOK127.0.0.1:6379&gt; setrange msg2 2 ww(integer) 5127.0.0.1:6379&gt; get msg2&quot;wowwd&quot;</code></pre></div><p><code>GETSET key value</code>: 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; GETSET msg test “hello world”</code></pre></div><p><code>SETNX key value</code>: 仅当key不存在时进行set</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1</code></pre></div><p><code>SETEX key seconds value</code>: set 键值对并设置过期时间</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)</code></pre></div><p><code>MSET key1 value1 [key2 value2..]</code>: 批量set键值对</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK</code></pre></div><p><code>MSETNX key1 value1 [key2 value2..]</code>: 批量设置键值对，仅当参数中所有的key都不存在时执行</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0</code></pre></div><p><code>MGET key1 [key2..]</code>: 批量获取多个key保存的值</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</code></pre></div><p><code>PSETEX key milliseconds value</code>: 和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间</p><p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p><ul><li>计数器</li><li>统计多单位的数量：uid:123666：follow 0</li><li>粉丝数</li><li>对象存储缓存</li></ul><h3 id="3-3-List"><a href="#3-3-List" class="headerlink" title="3.3 List"></a>3.3 List</h3><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p><p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200820104440398.png" alt></p><p>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p><ul><li><code>LPUSH/RPUSH key value1[value2..]</code>从左边/右边向列表中PUSH值(一个或者多个)。</li><li><code>LRANGE key start end</code> 获取list 起止元素== （索引从左往右 递增）==</li><li><code>LPUSHX/RPUSHX key value</code> 向已存在的列名中push值（一个或者多个）</li><li><code>LINSERT key BEFORE|AFTER pivot value</code> 在指定列表元素的前/后 插入value</li><li><code>LLEN key</code> 查看列表长度</li><li><code>LINDEX key index</code> 通过索引获取列表元素</li><li><code>LSET key index value</code> 通过索引为元素设值</li><li><code>LPOP/RPOP key</code> 从最左边/最右边移除值 并返回</li><li><code>RPOPLPUSH source destination</code> 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</li><li><code>LTRIM key start end</code> 通过下标截取指定范围内的列表</li><li><code>LREM key count value</code> List中是允许value重复的 count &gt; 0：从头部开始搜索 然后删除指定的value 至多删除count个 count &lt; 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。</li><li><code>BLPOP/BRPOP key1[key2] timout</code> 移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li><li><code>BRPOPLPUSH source destination timeout</code> 和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">---------------------------LPUSH---RPUSH---LRANGE--------------------------------127.0.0.1:6379&gt; LPUSH mylist k1 # LPUSH mylist=&gt;&#123;1&#125;(integer) 1127.0.0.1:6379&gt; LPUSH mylist k2 # LPUSH mylist=&gt;&#123;2,1&#125;(integer) 2127.0.0.1:6379&gt; RPUSH mylist k3 # RPUSH mylist=&gt;&#123;2,1,3&#125;(integer) 3127.0.0.1:6379&gt; get mylist # 普通的get是无法获取list值的(error) WRONGTYPE Operation against a key holding the wrong kind of value127.0.0.1:6379&gt; LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素&quot;k2&quot;&quot;k1&quot;&quot;k3&quot;127.0.0.1:6379&gt; LRANGE mylist 0 2&quot;k2&quot;&quot;k1&quot;&quot;k3&quot;127.0.0.1:6379&gt; LRANGE mylist 0 1&quot;k2&quot;&quot;k1&quot;127.0.0.1:6379&gt; LRANGE mylist 0 -1 # 获取全部元素&quot;k2&quot;&quot;k1&quot;&quot;k3&quot;---------------------------LPUSHX---RPUSHX-----------------------------------127.0.0.1:6379&gt; LPUSHX list v1 # list不存在 LPUSHX失败(integer) 0127.0.0.1:6379&gt; LPUSHX list v1 v2(integer) 0127.0.0.1:6379&gt; LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5(integer) 5127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k5&quot;&quot;k4&quot;&quot;k2&quot;&quot;k1&quot;&quot;k3&quot;---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1(integer) 6127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k5&quot;&quot;k4&quot;&quot;k2&quot;&quot;ins_key1&quot;&quot;k1&quot;&quot;k3&quot;127.0.0.1:6379&gt; LLEN mylist # 查看mylist的长度(integer) 6127.0.0.1:6379&gt; LINDEX mylist 3 # 获取下标为3的元素&quot;ins_key1&quot;127.0.0.1:6379&gt; LINDEX mylist 0&quot;k5&quot;127.0.0.1:6379&gt; LSET mylist 3 k6 # 将下标3的元素 set值为k6OK127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k5&quot;&quot;k4&quot;&quot;k2&quot;&quot;k6&quot;&quot;k1&quot;&quot;k3&quot;---------------------------LPOP--RPOP--------------------------127.0.0.1:6379&gt; LPOP mylist # 左侧(头部)弹出&quot;k5&quot;127.0.0.1:6379&gt; RPOP mylist # 右侧(尾部)弹出&quot;k3&quot;---------------------------RPOPLPUSH--------------------------127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k4&quot;&quot;k2&quot;&quot;k6&quot;&quot;k1&quot;127.0.0.1:6379&gt; RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部&quot;k1&quot;127.0.0.1:6379&gt; LRANGE newlist 0 -1&quot;k1&quot;127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k4&quot;&quot;k2&quot;&quot;k6&quot;---------------------------LTRIM--------------------------127.0.0.1:6379&gt; LTRIM mylist 0 1 # 截取mylist中的 0~1部分OK127.0.0.1:6379&gt; LRANGE mylist 0 -1&quot;k4&quot;&quot;k2&quot;初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2---------------------------LREM--------------------------127.0.0.1:6379&gt; LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2(integer) 3删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2127.0.0.1:6379&gt; LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2(integer) 2删除后：mylist: k2,k2,k2,k4,k2,k2---------------------------BLPOP--BRPOP--------------------------mylist: k2,k2,k2,k4,k2,k2newlist: k1127.0.0.1:6379&gt; BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选&quot;newlist&quot; # 弹出&quot;k1&quot;127.0.0.1:6379&gt; BLPOP newlist mylist 30&quot;mylist&quot; # 由于newlist空了 从mylist中弹出&quot;k2&quot;127.0.0.1:6379&gt; BLPOP newlist 30(30.10s) # 超时了127.0.0.1:6379&gt; BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。&quot;newlist&quot;&quot;test&quot;(12.54s)</code></pre></div><p><strong>小结</strong></p><ul><li>list实际上是一个链表，before Node after , left, right 都可以插入值</li><li>如果key不存在，则创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li></ul><p>应用：</p><p>消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）</p><h3 id="3-3-Set"><a href="#3-3-Set" class="headerlink" title="3.3 Set"></a>3.3 Set</h3><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><ul><li><code>SADD key member1[member2..]</code> 向集合中无序增加一个/多个成员</li><li><code>SCARD key</code> 获取集合的成员数</li><li><code>SMEMBERS key</code> 返回集合中所有的成员</li><li><code>SISMEMBER key member</code> 查询member元素是否是集合的成员,结果是无序的</li><li><code>SRANDMEMBER key [count]</code> 随机返回集合中count个成员，count缺省值为1</li><li><code>SPOP key [count]</code> 随机移除并返回集合中count个成员，count缺省值为1</li><li><code>SMOVE source destination member</code> 将source集合的成员member移动到destination集合</li><li><code>SREM key member1[member2..]</code> 移除集合中一个/多个成员</li><li><code>SDIFF key1[key2..]</code> 返回所有集合的差集 key1- key2 - …</li><li><code>SDIFFSTORE destination key1[key2..]</code> 在SDIFF的基础上，将结果保存到集合中<strong>(覆盖)</strong>。不能保存到其他类型key噢！</li><li><code>SINTER key1 [key2..]</code> 返回所有集合的交集</li><li><code>SINTERSTORE destination key1[key2..]</code> 在SINTER的基础上，存储结果到集合中。覆盖</li><li><code>SUNION key1 [key2..]</code> 返回所有集合的并集</li><li><code>SUNIONSTORE destination key1 [key2..]</code> 在SUNION的基础上，存储结果到及和张。覆盖</li><li><code>SSCAN KEY [MATCH pattern] [COUNT count]</code> 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4(integer) 4127.0.0.1:6379&gt; SCARD myset # 获取集合的成员数目(integer) 4127.0.0.1:6379&gt; smembers myset # 获取集合中所有成员&quot;m4&quot;&quot;m3&quot;&quot;m2&quot;&quot;m1&quot;127.0.0.1:6379&gt; SISMEMBER myset m5 # 查询m5是否是myset的成员(integer) 0 # 不是，返回0127.0.0.1:6379&gt; SISMEMBER myset m2(integer) 1 # 是，返回1127.0.0.1:6379&gt; SISMEMBER myset m3(integer) 1---------------------SRANDMEMBER--SPOP----------------------------------127.0.0.1:6379&gt; SRANDMEMBER myset 3 # 随机返回3个成员&quot;m2&quot;&quot;m3&quot;&quot;m4&quot;127.0.0.1:6379&gt; SRANDMEMBER myset # 随机返回1个成员&quot;m3&quot;127.0.0.1:6379&gt; SPOP myset 2 # 随机移除并返回2个成员&quot;m1&quot;&quot;m4&quot;将set还原到&#123;m1,m2,m3,m4&#125;---------------------SMOVE--SREM----------------------------------------127.0.0.1:6379&gt; SMOVE myset newset m3 # 将myset中m3成员移动到newset集合(integer) 1127.0.0.1:6379&gt; SMEMBERS myset&quot;m4&quot;&quot;m2&quot;&quot;m1&quot;127.0.0.1:6379&gt; SMEMBERS newset&quot;m3&quot;127.0.0.1:6379&gt; SREM newset m3 # 从newset中移除m3元素(integer) 1127.0.0.1:6379&gt; SMEMBERS newset(empty list or set)下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算setx=&gt;&#123;m1,m2,m4,m6&#125;, sety=&gt;&#123;m2,m5,m6&#125;, setz=&gt;&#123;m1,m3,m6&#125;-----------------------------SDIFF------------------------------------127.0.0.1:6379&gt; SDIFF setx sety setz # 等价于setx-sety-setz&quot;m4&quot;127.0.0.1:6379&gt; SDIFF setx sety # setx - sety&quot;m4&quot;&quot;m1&quot;127.0.0.1:6379&gt; SDIFF sety setx # sety - setx&quot;m5&quot;-------------------------SINTER---------------------------------------共同关注（交集）127.0.0.1:6379&gt; SINTER setx sety setz # 求 setx、sety、setx的交集&quot;m6&quot;127.0.0.1:6379&gt; SINTER setx sety # 求setx sety的交集&quot;m2&quot;&quot;m6&quot;-------------------------SUNION---------------------------------------127.0.0.1:6379&gt; SUNION setx sety setz # setx sety setz的并集&quot;m4&quot;&quot;m6&quot;&quot;m3&quot;&quot;m2&quot;&quot;m1&quot;&quot;m5&quot;127.0.0.1:6379&gt; SUNION setx sety # setx sety 并集&quot;m4&quot;&quot;m6&quot;&quot;m2&quot;&quot;m1&quot;&quot;m5&quot;</code></pre></div><h3 id="3-4-Hash"><a href="#3-4-Hash" class="headerlink" title="3.4 Hash"></a>3.4 Hash</h3><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p><ul><li><code>HSET key field value</code> 将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</li><li><code>HMSET key field1 value1 [field2 value2..]</code> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</li><li><code>HSETNX key field value</code> 只有在字段 field 不存在时，设置哈希表字段的值。</li><li><code>HEXISTS key field</code> 查看哈希表 key 中，指定的字段是否存在。</li><li><code>HGET key field value</code> 获取存储在哈希表中指定字段的值</li><li><code>HMGET key field1 [field2..]</code> 获取所有给定字段的值</li><li><code>HGETALL key</code> 获取在哈希表key 的所有字段和值</li><li><code>HKEYS key</code> 获取哈希表key中所有的字段</li><li><code>HLEN key</code> 获取哈希表中字段的数量</li><li><code>HVALS key</code> 获取哈希表中所有值</li><li><code>HDEL key field1 [field2..]</code> 删除哈希表key中一个/多个field字段</li><li><code>HINCRBY key field n</code> 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</li><li><code>HINCRBYFLOAT key field n</code> 为哈希表 key 中的指定字段的浮点数值加上增量 n。</li><li><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code> 迭代哈希表中的键值对。</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">------------------------HSET--HMSET--HSETNX----------------127.0.0.1:6379&gt; HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura(integer) 1127.0.0.1:6379&gt; HSET studentx name gyc # 重复设置field进行覆盖，并返回0(integer) 0127.0.0.1:6379&gt; HSET studentx age 20 # 设置studentx的age为20(integer) 1127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886OK127.0.0.1:6379&gt; HSETNX studentx name gyc # HSETNX 设置已存在的field(integer) 0 # 失败127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com(integer) 1 # 成功----------------------HEXISTS--------------------------------127.0.0.1:6379&gt; HEXISTS studentx name # name字段在studentx中是否存在(integer) 1 # 存在127.0.0.1:6379&gt; HEXISTS studentx addr(integer) 0 # 不存在-------------------HGET--HMGET--HGETALL-----------127.0.0.1:6379&gt; HGET studentx name # 获取studentx中name字段的value&quot;gyc&quot;127.0.0.1:6379&gt; HMGET studentx name age tel # 获取studentx中name、age、tel字段的value&quot;gyc&quot;&quot;20&quot;&quot;15623667886&quot;127.0.0.1:6379&gt; HGETALL studentx # 获取studentx中所有的field及其value&quot;name&quot;&quot;gyc&quot;&quot;age&quot;&quot;20&quot;&quot;sex&quot;&quot;1&quot;&quot;tel&quot;&quot;15623667886&quot;&quot;email&quot;&quot;12345@qq.com&quot;--------------------HKEYS--HLEN--HVALS--------------127.0.0.1:6379&gt; HKEYS studentx # 查看studentx中所有的field&quot;name&quot;&quot;age&quot;&quot;sex&quot;&quot;tel&quot;&quot;email&quot;127.0.0.1:6379&gt; HLEN studentx # 查看studentx中的字段数量(integer) 5127.0.0.1:6379&gt; HVALS studentx # 查看studentx中所有的value&quot;gyc&quot;&quot;20&quot;&quot;1&quot;&quot;15623667886&quot;&quot;12345@qq.com&quot;-------------------------HDEL--------------------------127.0.0.1:6379&gt; HDEL studentx sex tel # 删除studentx 中的sex、tel字段(integer) 2127.0.0.1:6379&gt; HKEYS studentx&quot;name&quot;&quot;age&quot;&quot;email&quot;-------------HINCRBY--HINCRBYFLOAT------------------------127.0.0.1:6379&gt; HINCRBY studentx age 1 # studentx的age字段数值+1(integer) 21127.0.0.1:6379&gt; HINCRBY studentx name 1 # 非整数字型字段不可用(error) ERR hash value is not an integer127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6&quot;90.8&quot;</code></pre></div><p> Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！</p><h3 id="3-5-Zset-有序集合"><a href="#3-5-Zset-有序集合" class="headerlink" title="3.5 Zset(有序集合)"></a>3.5 Zset(有序集合)</h3><p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>score相同：按字典顺序排序</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><ul><li><code>ZADD key score member1 [score2 member2]</code> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</li><li><code>ZCARD key</code> 获取有序集合的成员数</li><li><code>ZCOUNT key min max</code> 计算在有序集合中指定区间score的成员数</li><li><code>ZINCRBY key n member</code> 有序集合中对指定成员的分数加上增量 n</li><li><code>ZSCORE key member</code> 返回有序集中，成员的分数值</li><li><code>ZRANK key member</code> 返回有序集合中指定成员的索引</li><li><code>ZRANGE key start end</code> 通过索引区间返回有序集合成指定区间内的成员</li><li><code>ZRANGEBYLEX key min max</code> 通过字典区间返回有序集合的成员</li><li><code>ZRANGEBYSCORE key min max</code> 通过分数返回有序集合指定区间内的成员 <strong>-inf 和 +inf</strong>分别表示最小最大值，只支持开区间() </li><li><code>ZLEXCOUNT key min max</code> 在有序集合中计算指定字典区间内成员数量</li><li><code>ZREM key member1 [member2..]</code> 移除有序集合中一个/多个成员</li><li><code>ZREMRANGEBYLEX key min max</code> 移除有序集合中给定的字典区间的所有成员</li><li><code>ZREMRANGEBYRANK key start stop</code> 移除有序集合中给定的排名区间的所有成员</li><li><code>ZREMRANGEBYSCORE key min max</code> 移除有序集合中给定的分数区间的所有成员</li><li><code>ZREVRANGE key start end</code> 返回有序集中指定区间内的成员，通过索引，分数从高到底</li><li><code>ZREVRANGEBYSCORRE key max min</code> 返回有序集中指定分数区间内的成员，分数从高到低排序</li><li><code>ZREVRANGEBYLEX key max min</code> 返回有序集中指定字典区间内的成员，按字典顺序倒序</li><li><code>ZREVRANK key member</code> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</li><li><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</li><li><code>ZUNIONSTORE destination numkeys key1 [key2..]</code> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</li><li><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code> 迭代有序集合中的元素（包括元素成员和元素分值）</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">-------------------ZADD--ZCARD--ZCOUNT--------------127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2..(integer) 2127.0.0.1:6379&gt; ZCARD myzset # 获取有序集合的成员数(integer) 2127.0.0.1:6379&gt; ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量(integer) 1127.0.0.1:6379&gt; ZCOUNT myzset 0 2(integer) 2----------------ZINCRBY--ZSCORE--------------------------127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 # 将成员m2的score +5&quot;7&quot;127.0.0.1:6379&gt; ZSCORE myzset m1 # 获取成员m1的score&quot;1&quot;127.0.0.1:6379&gt; ZSCORE myzset m2&quot;7&quot;--------------ZRANK--ZRANGE-----------------------------------127.0.0.1:6379&gt; ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加(integer) 0127.0.0.1:6379&gt; ZRANK myzset m2(integer) 2127.0.0.1:6379&gt; ZRANGE myzset 0 1 # 获取索引在 0~1的成员&quot;m1&quot;&quot;m3&quot;127.0.0.1:6379&gt; ZRANGE myzset 0 -1 # 获取全部成员&quot;m1&quot;&quot;m3&quot;&quot;m2&quot;testset=&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0------------------ZRANGEBYLEX---------------------------------127.0.0.1:6379&gt; ZRANGEBYLEX testset - + # 返回所有成员&quot;abc&quot;&quot;add&quot;&quot;amaze&quot;&quot;apple&quot;&quot;back&quot;&quot;java&quot;&quot;redis&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录&quot;abc&quot;&quot;add&quot;&quot;amaze&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录&quot;apple&quot;&quot;back&quot;&quot;java&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员&quot;abc&quot;&quot;add&quot;&quot;amaze&quot;&quot;apple&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员&quot;apple&quot;&quot;back&quot;&quot;java&quot;-----------------------ZRANGEBYSCORE---------------------127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员&quot;m1&quot;&quot;m3&quot;&quot;m2&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 5&quot;m1&quot;&quot;m3&quot;--------------------ZLEXCOUNT-----------------------------127.0.0.1:6379&gt; ZLEXCOUNT testset - +(integer) 7127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java(integer) 3------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------127.0.0.1:6379&gt; ZREM testset abc # 移除成员abc(integer) 1127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员(integer) 3127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员(integer) 2127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员(integer) 2testset=&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0myzset=&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3&quot;m9&quot;&quot;m7&quot;&quot;m4&quot;&quot;m3&quot;127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4&quot;m4&quot;&quot;m3&quot;&quot;m2&quot;127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员&quot;m4&quot;&quot;m3&quot;&quot;m2&quot;127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add # 按字典倒序 返回集合中(add,java]字典区间的成员&quot;java&quot;&quot;back&quot;&quot;apple&quot;&quot;amaze&quot;-------------------------ZREVRANK------------------------------127.0.0.1:6379&gt; ZREVRANK myzset m7 # 按score递减顺序，返回成员m7索引(integer) 1127.0.0.1:6379&gt; ZREVRANK myzset m2(integer) 4mathscore=&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩enscore=&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore # 将mathscore enscore进行合并 结果存放到sumscore(integer) 3127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores # 合并后的score是之前集合中所有score的和&quot;xm&quot;&quot;160&quot;&quot;xg&quot;&quot;177&quot;&quot;xh&quot;&quot;188&quot;127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN # 取两个集合的成员score最小值作为结果的(integer) 3127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores&quot;xm&quot;&quot;70&quot;&quot;xg&quot;&quot;87&quot;&quot;xh&quot;&quot;93&quot;</code></pre></div><p>应用案例：</p><ol><li>set排序 存储班级成绩表 工资表排序！</li><li>普通消息，1.重要消息 2.带权重进行判断</li><li>排行榜应用实现，取Top N测试</li></ol><h2 id="4-三种特殊的数据类型"><a href="#4-三种特殊的数据类型" class="headerlink" title="4 三种特殊的数据类型"></a>4 三种特殊的数据类型</h2><h3 id="4-1-Geospatial-地理位置"><a href="#4-1-Geospatial-地理位置" class="headerlink" title="4.1 Geospatial(地理位置)"></a>4.1 Geospatial(地理位置)</h3><p>使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用</p><ul><li><code>geoadd key longitud(经度) latitude(纬度) member [..]</code> 将具体经纬度的坐标存入一个有序集合</li><li><code>geopos key member [member..]</code> 获取集合中的一个/多个成员坐标</li><li><code>geodist key member1 member2 [unit]</code> 返回两个给定位置之间的距离。默认以米作为单位。</li><li><code>georadius key longitude latitude radius m|km|mi|ft [WITHCOORD][WITHDIST] [WITHHASH] [COUNT count]</code> 以给定的经纬度为中心， 返回集合包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</li><li><code>GEORADIUSBYMEMBER key member radius...</code> 功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</li><li><code>geohash key member1 [member2..]</code> 返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</li></ul><h4 id="有效经纬度"><a href="#有效经纬度" class="headerlink" title="有效经纬度"></a>有效经纬度</h4><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul><p><strong>指定单位的参数 unit 必须是以下单位的其中一个：</strong></p><ul><li>m 表示单位为米。</li></ul><ul><li>km 表示单位为千米。</li></ul><ul><li>mi 表示单位为英里。</li></ul><ul><li>ft 表示单位为英尺。</li></ul><h4 id="关于GEORADIUS的参数"><a href="#关于GEORADIUS的参数" class="headerlink" title="关于GEORADIUS的参数"></a>关于GEORADIUS的参数</h4><ul><li>通过georadius就可以完成 附近的人功能</li></ul><ul><li>withcoord:带上坐标</li></ul><ul><li>withdist:带上距离，单位与半径单位相同</li></ul><ul><li>COUNT n : 只显示前n个(按距离递增排序)</li></ul><div class="code-wrapper"><pre><code class="hljs shell">----------------georadius---------------------127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员1) 1) &quot;hangzhou&quot;   2) &quot;29.4151&quot;   3) 1) &quot;120.20000249147415&quot;      2) &quot;30.199999888333501&quot;2) 1) &quot;shanghai&quot;   2) &quot;205.3611&quot;   3) 1) &quot;121.40000134706497&quot;      2) &quot;31.400000253193539&quot;------------geohash---------------------------127.0.0.1:6379&gt; geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示&quot;wmrjwbr5250&quot;&quot;wtw6ds0y300&quot;</code></pre></div><h3 id="4-2-Hyperloglog-基数统计"><a href="#4-2-Hyperloglog-基数统计" class="headerlink" title="4.2 Hyperloglog(基数统计)"></a>4.2 Hyperloglog(基数统计)</h3><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>其底层使用string数据类型。</p><h4 id="什么是基数？"><a href="#什么是基数？" class="headerlink" title="什么是基数？"></a>什么是基数？</h4><p>数据集中不重复的元素的个数。</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p><p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。</p><ul><li><code>PFADD key element1 [elememt2..]</code> 添加指定元素到 HyperLogLog中</li><li><code>PFCOUNT key [key]</code> 返回给定 HyperLogLog 的基数估算值。</li><li><code>PFMERGE destkey sourcekey [sourcekey..]</code> 将多个 HyperLogLog 合并为一个 HyperLogLog</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">----------PFADD--PFCOUNT---------------------127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k # 添加元素(integer) 1127.0.0.1:6379&gt; type myelemx # hyperloglog底层使用Stringstring127.0.0.1:6379&gt; PFCOUNT myelemx # 估算myelemx的基数(integer) 11127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s(integer) 1127.0.0.1:6379&gt; PFCOUNT myelemy(integer) 11----------------PFMERGE-----------------------127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemzOK127.0.0.1:6379&gt; PFCOUNT myelemz # 估算基数(integer) 17</code></pre></div><h3 id="4-3-BitMaps-位图"><a href="#4-3-BitMaps-位图" class="headerlink" title="4.3 BitMaps(位图)"></a>4.3 BitMaps(位图)</h3><p>使用位存储，信息状态只有 0 和 1</p><p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p><p>应用场景: 签到统计、状态统计</p><ul><li><code>setbit key offset value</code> 为指定key的offset位设置值</li><li><code>getbit key offset</code> 获取offset位的值</li><li><code>bitcount key [start end]</code> 统计字符串被设置为1的bit数，也可以指定统计范围按字节</li><li><code>bitop operration destkey key[key..]</code> 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</li><li><code>BITPOS key bit [start] [end]</code> 返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</li></ul><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs shell">------------setbit--getbit--------------127.0.0.1:6379&gt; setbit sign 0 1 # 设置sign的第0位为 1 (integer) 0127.0.0.1:6379&gt; setbit sign 2 1 # 设置sign的第2位为 1  不设置默认 是0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 1(integer) 0127.0.0.1:6379&gt; type signstring127.0.0.1:6379&gt; getbit sign 2 # 获取第2位的数值(integer) 1127.0.0.1:6379&gt; getbit sign 3(integer) 1127.0.0.1:6379&gt; getbit sign 4 # 未设置默认是0(integer) 0-----------bitcount----------------------------127.0.0.1:6379&gt; BITCOUNT sign # 统计sign中为1的位数(integer) 4</code></pre></div><h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5 事务"></a>5 事务</h2><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p><div class="code-wrapper"><pre><code class="hljs shell">Redis事务本质：一组命令的集合。----------------- 队列 set set set 执行 -------------------事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。一次性顺序性排他性Redis事务没有隔离级别的概念Redis单条命令是保证原子性的，但是事务不保证原子性！</code></pre></div><p>Redis事务操作过程</p><ul><li>开启事务（multi）</li><li>命令入队</li><li>执行事务（exec）</li></ul><p>所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p><h3 id="5-1-正常执行"><a href="#5-1-正常执行" class="headerlink" title="5.1 正常执行"></a>5.1 正常执行</h3><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379&gt; set k1 v1 # 命令入队QUEUED127.0.0.1:6379&gt; set k2 v2 # ..QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; keys *QUEUED127.0.0.1:6379&gt; exec # 事务执行1) OK2) OK3) &quot;v1&quot;4) OK5) 1) &quot;k3&quot;   2) &quot;k2&quot;   3) &quot;k1&quot;</code></pre></div><h3 id="5-2-取消事务-discurd"><a href="#5-2-取消事务-discurd" class="headerlink" title="5.2 取消事务(discurd)"></a>5.2 取消事务(discurd)</h3><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; DISCARD # 放弃事务OK127.0.0.1:6379&gt; EXEC (error) ERR EXEC without MULTI # 当前未开启事务127.0.0.1:6379&gt; get k1 # 被放弃事务中命令并未执行(nil)</code></pre></div><h3 id="5-3-事务错误"><a href="#5-3-事务错误" class="headerlink" title="5.3 事务错误"></a>5.3 事务错误</h3><blockquote><p>  代码语法错误（编译时异常）所有的命令都不执行</p></blockquote><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; error k1 # 这是一条语法错误命令(error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; EXEC(error) EXECABORT Transaction discarded because of previous errors. # 执行报错127.0.0.1:6379&gt; get k1 (nil) # 其他命令并没有被执行</code></pre></div><blockquote><p>  代码逻辑错误 (运行时异常) *<em>其他命令可以正常执行 *</em> &gt;&gt;&gt; 所以不保证事务原子性</p></blockquote><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; INCR k1 # 这条命令逻辑错误（对字符串进行增量）QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; exec1) OK2) OK3) (error) ERR value is not an integer or out of range # 运行时报错4) &quot;v2&quot; # 其他命令正常执行虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</code></pre></div><h3 id="5-4-监控"><a href="#5-4-监控" class="headerlink" title="5.4 监控"></a>5.4 监控</h3><p>悲观锁：</p><ul><li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li></ul><p>乐观锁：</p><ul><li>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><p>使用watch key监控指定数据，相当于乐观锁加锁。</p><blockquote><p>  正常执行</p></blockquote><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; set money 100 # 设置余额:100OK127.0.0.1:6379&gt; set use 0 # 支出使用:0OK127.0.0.1:6379&gt; watch money # 监视money (上锁)OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; DECRBY money 20QUEUED127.0.0.1:6379&gt; INCRBY use 20QUEUED127.0.0.1:6379&gt; exec # 监视值没有被中途修改，事务正常执行1) (integer) 802) (integer) 20</code></pre></div><p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）</p><p>我们启动另外一个客户端模拟插队线程。</p><p>线程1：</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; watch money # money上锁OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; DECRBY money 20QUEUED127.0.0.1:6379&gt; INCRBY use 20QUEUED127.0.0.1:6379&gt;     # 此时事务并没有执行</code></pre></div><p>模拟线程插队，线程2：</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; INCRBY money 500 # 修改了线程一中监视的money(integer) 600</code></pre></div><p>回到线程1，执行事务：</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败(nil) # 没有结果，说明事务执行失败127.0.0.1:6379&gt; get money # 线程2 修改生效&quot;600&quot;127.0.0.1:6379&gt; get use # 线程1事务执行失败，数值没有被修改&quot;0&quot;</code></pre></div><p>解锁获取最新值，然后再加锁进行事务。</p><p>unwatch进行解锁。</p><p>注意：每次提交执行exec后都会自动释放锁，不管是否成功</p><h2 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6 Jedis"></a>6 Jedis</h2><p>使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。</p><p>1.导入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入jredis的包--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--fastjson--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.70<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2.编码测试</p><blockquote><p>  连接数据库<br>  操作命令<br>  断开连接</p></blockquote><p>代码示例</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPing</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.xx.xxx&quot;</span>, <span class="hljs-number">6379</span>);        jedis.auth(<span class="hljs-string">&quot;p&quot;</span>);        String response = jedis.ping();        System.out.println(response); <span class="hljs-comment">// PONG</span>    &#125;&#125;</code></pre></div><p>输出PONG</p><h3 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h3><p>string、list、set、hash、zset</p><p>所有的api命令，就是我们对应的上面学习的指令，一个都没有变化！</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTX</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);        jedis.flushDB();        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();        jsonObject.put(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);        jsonObject.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;kuangshen&quot;</span>);        <span class="hljs-comment">// 开启事务</span>        Transaction multi = jedis.multi();        String result = jsonObject.toJSONString();        <span class="hljs-comment">// jedis.watch(result)</span>        <span class="hljs-keyword">try</span> &#123;            multi.set(<span class="hljs-string">&quot;user1&quot;</span>,result);            multi.set(<span class="hljs-string">&quot;user2&quot;</span>,result);            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span> ; <span class="hljs-comment">// 代码抛出异常事务，执行失败！</span>            multi.exec(); <span class="hljs-comment">// 执行事务！</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            multi.discard(); <span class="hljs-comment">// 放弃事务</span>            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(jedis.get(<span class="hljs-string">&quot;user1&quot;</span>));            System.out.println(jedis.get(<span class="hljs-string">&quot;user2&quot;</span>));            jedis.close(); <span class="hljs-comment">// 关闭连接</span>        &#125;    &#125;&#125;</code></pre></div><h2 id="7-SpringBoot整合"><a href="#7-SpringBoot整合" class="headerlink" title="7 SpringBoot整合"></a>7 SpringBoot整合</h2><p>SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！</p><p>SpringData 也是和 SpringBoot 齐名的项目！</p><p>说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?</p><p>jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式</p><p>lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式</p><p>源码分析：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span> <span class="hljs-comment">// 我们可以自己定义一个redisTemplate来替换这个默认的！</span><span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;<span class="hljs-comment">// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！</span><span class="hljs-comment">// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt;</span>    RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();    template.setConnectionFactory(redisConnectionFactory);    <span class="hljs-keyword">return</span> template;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">// 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！</span><span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;    StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();    template.setConnectionFactory(redisConnectionFactory);    <span class="hljs-keyword">return</span> template;&#125;</code></pre></div><h3 id="整合测试"><a href="#整合测试" class="headerlink" title="整合测试"></a>整合测试</h3><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1 导入依赖"></a>1 导入依赖</h4><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。</p><p>jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式</p><p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p><p>我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214531573.png" alt></p><p>那么就一定还存在一个RedisProperties类<img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214607475.png" alt></p><p>@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的</p><p>然后再看Lettuce：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214618179.png" alt></p><p>完美生效。</p><p>现在我们回到RedisAutoConfiguratio</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321462777.png" alt></p><p>只有两个简单的Bean</p><ul><li>RedisTemplate</li><li>StringRedisTemplate</li></ul><p>当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。</p><p>在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的</p><p>说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214638238.png" alt></p><p>这是一些基本的配置属性。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214649380.png" alt></p><p>还有一些连接池相关的配置。注意使用时一定使用<strong>Lettuce</strong>的连接池。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214700372.png" alt></p><h4 id="2-编写配置文件"><a href="#2-编写配置文件" class="headerlink" title="2 编写配置文件"></a>2 编写配置文件</h4><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 配置redis</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">39.99.xxx.xx</span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span></code></pre></div><h4 id="3-使用RedisTemplate"><a href="#3-使用RedisTemplate" class="headerlink" title="3 使用RedisTemplate"></a>3 使用RedisTemplate</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis02SpringbootApplicationTests</span> </span>&#123;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span>    <span class="hljs-comment">// opsForValue 操作字符串 类似String</span>    <span class="hljs-comment">// opsForList 操作List 类似List</span>    <span class="hljs-comment">// opsForSet</span>    <span class="hljs-comment">// opsForHash</span>    <span class="hljs-comment">// opsForZSet</span>    <span class="hljs-comment">// opsForGeo</span>    <span class="hljs-comment">// opsForHyperLog</span>    <span class="hljs-comment">// 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD</span>    <span class="hljs-comment">// 获取连接对象</span>    <span class="hljs-comment">//RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span>    <span class="hljs-comment">//connection.flushDb();</span>    <span class="hljs-comment">//connection.flushAll();</span>    redisTemplate.opsForValue().set(&amp;quot;mykey&amp;quot;,&amp;quot;kuangshen&amp;quot;);    System.out.println(redisTemplate.opsForValue().get(&amp;quot;mykey&amp;quot;));&#125;&#125;</code></pre></div><h4 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4 测试结果"></a>4 测试结果</h4><p>此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出。这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。</p><p>RedisTemplate内部的序列化配置是这样的</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214746506.png" alt></p><p>默认的序列化器是采用JDK序列化器</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B0.jpg" alt></p><p>后续我们定制RedisTemplate就可以对其进行修改。</p><p>RedisSerializer提供了多种序列化方案：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214818682.png" alt></p><p>我们来编写一个自己的 RedisTemplete</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.config;<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<span class="hljs-comment">// 这是我给大家写好的一个固定模板，大家在企业中，拿去就可以直接使用！</span><span class="hljs-comment">// 自己定义了一个 RedisTemplate</span><span class="hljs-meta">@Bean</span><span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<span class="hljs-comment">// 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span>RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;String,Object&gt;();template.setConnectionFactory(factory);<span class="hljs-comment">// Json序列化配置</span>Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span>Jackson2JsonRedisSerializer(Object.class);ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);jackson2JsonRedisSerializer.setObjectMapper(om);<span class="hljs-comment">// String 的序列化</span>StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<span class="hljs-comment">// key采用String的序列化方式</span>template.setKeySerializer(stringRedisSerializer);<span class="hljs-comment">// hash的key也采用String的序列化方式</span>template.setHashKeySerializer(stringRedisSerializer);<span class="hljs-comment">// value序列化方式采用jackson</span>template.setValueSerializer(jackson2JsonRedisSerializer);<span class="hljs-comment">// hash的value序列化方式采用jackson</span>template.setHashValueSerializer(jackson2JsonRedisSerializer);template.afterPropertiesSet();<span class="hljs-keyword">return</span> template;&#125;&#125;</code></pre></div><p>所有的redis操作，其实对于java开发人员来说，十分的简单，更重要是要去理解redis的思想和每一种数据结构的用处和作用场景！</p><h2 id="8-Redis-conf"><a href="#8-Redis-conf" class="headerlink" title="8 Redis.conf"></a>8 Redis.conf</h2><ul><li><p>容量单位不区分大小写，G和GB有区别</p></li><li><p>可以使用 include 组合多个配置问题</p></li></ul><h3 id="8-1-网络配置"><a href="#8-1-网络配置" class="headerlink" title="8.1 网络配置"></a>8.1 网络配置</h3><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513214912813.png" alt></p><h3 id="8-2-日志"><a href="#8-2-日志" class="headerlink" title="8.2 日志"></a>8.2 日志</h3><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># 日志</span><span class="hljs-comment"># Specify the server verbosity level.</span><span class="hljs-comment"># This can be one of:</span><span class="hljs-comment"># debug (a lot of information, useful for development/testing)</span><span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><span class="hljs-comment"># notice (moderately verbose, what you want in production probably) 生产环境</span><span class="hljs-comment"># warning (only very important / critical messages are logged)</span>loglevel noticelogfile &quot;&quot; # 日志的文件位置名databases 16 # 数据库的数量，默认是 16 个数据库always-show-logo yes # 是否总是显示LOGO</code></pre></div><p>日志输出级别</p><ul><li>debug</li><li>verbose</li><li>notice</li><li>waring</li></ul><h3 id="8-3-持久化规则"><a href="#8-3-持久化规则" class="headerlink" title="8.3 持久化规则"></a>8.3 持久化规则</h3><p>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof redis 是内存数据库，如果没有持久化，那么数据断电及失！</p><p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p><p>持久化方式：</p><ul><li>RDB</li><li>AOF</li></ul><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span>save 900 1<span class="hljs-comment"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span>save 300 10<span class="hljs-comment"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</span>save 60 10000<span class="hljs-comment"># 我们之后学习持久化，会自己定义这个测试！</span>stop-writes-on-bgsave-error yes # 持久化如果出错，是否还需要继续工作！rdbcompression yes # 是否压缩 rdb 文件，需要消耗一些cpu资源！rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验！dir ./ # rdb 文件保存的目录！</code></pre></div><h3 id="8-4-SECURITY-安全"><a href="#8-4-SECURITY-安全" class="headerlink" title="8.4 SECURITY 安全"></a>8.4 SECURITY 安全</h3><p>可以在这里设置redis的密码，默认是没有密码！</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; config get requirepass # 获取redis的密码1) &quot;requirepass&quot;2) &quot;&quot;127.0.0.1:6379&gt; config set requirepass &quot;123456&quot; # 设置redis的密码OK127.0.0.1:6379&gt; config get requirepass # 发现所有的命令都没有权限了(error) NOAUTH Authentication required.127.0.0.1:6379&gt; ping(error) NOAUTH Authentication required.127.0.0.1:6379&gt; auth 123456 # 使用密码进行登录！OK127.0.0.1:6379&gt; config get requirepass1) &quot;requirepass&quot;2) &quot;123456&quot;</code></pre></div><h3 id="8-6-限制-CLIENTS（客户端连接相关）"><a href="#8-6-限制-CLIENTS（客户端连接相关）" class="headerlink" title="8.6 限制 CLIENTS（客户端连接相关）"></a>8.6 限制 CLIENTS（客户端连接相关）</h3><div class="code-wrapper"><pre><code class="hljs ini">maxclients 10000 # 设置能连接上redis的最大客户端的数量maxmemory &lt;bytes&gt; # redis 配置最大的内存容量maxmemory-policy noeviction # 内存到达上限之后的处理策略1、volatile-lru：只对设置了过期时间的key进行LRU（默认值）2、allkeys-lru ： 删除lru算法的key3、volatile-random：随机删除即将过期key4、allkeys-random：随机删除5、volatile-ttl ： 删除即将过期的6、noeviction ： 永不过期，返回错误</code></pre></div><h3 id="8-7-APPEND-ONLY-模式-aof配置"><a href="#8-7-APPEND-ONLY-模式-aof配置" class="headerlink" title="8.7 APPEND ONLY 模式 aof配置"></a>8.7 APPEND ONLY 模式 aof配置</h3><div class="code-wrapper"><pre><code class="hljs ini">appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字<span class="hljs-comment"># appendfsync always # 每次修改都会 sync。消耗性能</span>appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！<span class="hljs-comment"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，</span></code></pre></div><h2 id="9-Redis持久化——RDB"><a href="#9-Redis持久化——RDB" class="headerlink" title="9 Redis持久化——RDB"></a>9 Redis持久化——RDB</h2><p>面试和工作，持久化都是重点！<br>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p><h3 id="9-1-什么是RDB（Redis-DataBase）"><a href="#9-1-什么是RDB（Redis-DataBase）" class="headerlink" title="9.1 什么是RDB（Redis DataBase）"></a>9.1 什么是RDB（Redis DataBase）</h3><blockquote><p>  在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；<br>  默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p></blockquote><ul><li>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</li><li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。</li><li>这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！ 有时候在生产环境我们会将这个文件进行备份！</li><li>rdb保存的文件是dump.rdb 都是在我们的配置文件中快照中进行配置的！</li></ul><h3 id="9-2-工作原理"><a href="#9-2-工作原理" class="headerlink" title="9.2 工作原理"></a>9.2 工作原理</h3><p>在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作；</p><ol><li>Redis 调用forks。同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p><h3 id="9-3-触发机制"><a href="#9-3-触发机制" class="headerlink" title="9.3 触发机制"></a>9.3 触发机制</h3><ol><li>save的规则满足的情况下，会自动触发rdb原则</li><li>执行flushall命令，也会触发我们的rdb原则</li><li>退出redis，也会自动产生rdb文件</li></ol><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 save 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p><blockquote><p>  由于 save 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求。</p></blockquote><p>示意图</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215150892.jpg" alt></p><h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><p>flushall 命令也会触发持久化 ；</p><p>触发持久化规则<br>满足配置条件中的触发条件 ；</p><blockquote><p>  可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</p></blockquote><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215205970.png" alt></p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215220858.jpg" alt></p><h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p>bgsave 是异步进行，进行持久化的时候，redis 还可以将继续响应客户端请求 ；</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321523151.jpg" alt></p><p>bgsave和save对比</p><table><thead><tr><th align="left">命令</th><th align="left">save</th><th align="left">bgsave</th></tr></thead><tbody><tr><td align="left">IO类型</td><td align="left">同步</td><td align="left">异步</td></tr><tr><td align="left">阻塞</td><td align="left">是</td><td align="left">是（阻塞发生在fock()，通常非常快）</td></tr><tr><td align="left">复杂度</td><td align="left">O(n)</td><td align="left">O(n)</td></tr><tr><td align="left">优点</td><td align="left">不会消耗额外的内存</td><td align="left">不阻塞客户端命令</td></tr><tr><td align="left">缺点</td><td align="left">阻塞客户端命令</td><td align="left">需要fock子进程，消耗内存</td></tr></tbody></table><h4 id="如果恢复rdb文件！"><a href="#如果恢复rdb文件！" class="headerlink" title="如果恢复rdb文件！"></a>如果恢复rdb文件！</h4><ol><li>只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！</li><li>查看需要存在的位置</li></ol><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; config get dir<span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;dir&quot;</span><span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;/usr/local/bin&quot;</span> # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</code></pre></div><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote><p>  优点：</p></blockquote><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><blockquote><p>  缺点：</p></blockquote><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li><li>fork进程的时候，会占用一定的内容空间。</li></ol><h2 id="10-Redis持久化——AOF"><a href="#10-Redis持久化——AOF" class="headerlink" title="10 Redis持久化——AOF"></a>10 Redis持久化——AOF</h2><p>Append Only File</p><p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍[<img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B005.jpg" alt></p><p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h3 id="10-1-什么是AOF"><a href="#10-1-什么是AOF" class="headerlink" title="10.1 什么是AOF"></a>10.1 什么是AOF</h3><p> 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>appendonly no yes则表示启用AOF</p><p>默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</p><p>如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件</p><p>redis给我们提供了一个工具redis-check-aof –fix</p><div class="code-wrapper"><pre><code class="hljs ini">appendonly yes  # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用appendfilename &quot;appendonly.aof&quot;appendfsync always # 每次修改都会sync 消耗性能appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快</code></pre></div><h3 id="10-2-优缺点"><a href="#10-2-优缺点" class="headerlink" title="10.2 优缺点"></a>10.2 优缺点</h3><p><strong>优点</strong></p><ol><li>每一次修改都会同步，文件的完整性会更加好</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><p><strong>缺点</strong></p><ol><li>相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h3 id="10-3-扩展"><a href="#10-3-扩展" class="headerlink" title="10.3 扩展"></a>10.3 扩展</h3><ol><li>RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li><li>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</li><li>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</li><li>同时开启两种持久化方式<ul><li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li><li>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</li></ul></li><li>性能建议<ul><li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。</li><li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li><li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li></ul></li></ol><h3 id="10-4-如何选择使用哪种持久化方式？"><a href="#10-4-如何选择使用哪种持久化方式？" class="headerlink" title="10.4 如何选择使用哪种持久化方式？"></a>10.4 如何选择使用哪种持久化方式？</h3><ul><li><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p></li><li><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p></li><li><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p></li></ul><h2 id="11-Redis发布订阅"><a href="#11-Redis发布订阅" class="headerlink" title="11 Redis发布订阅"></a>11 Redis发布订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、 微博、关注系统！ Redis 客户端可以订阅任意数量的频道。 订阅/发布消息图： 第一个：消息发送者， 第二个：频道 第三个：消息订阅者！</p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215523258.png" alt></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321553483.png" alt></p><h3 id="11-1-命令"><a href="#11-1-命令" class="headerlink" title="11. 1 命令"></a>11. 1 命令</h3><ul><li><code>PSUBSCRIBE pattern [pattern..]</code> 订阅一个或多个符合给定模式的频道。</li><li><code>PUNSUBSCRIBE pattern [pattern..]</code> 退订一个或多个符合给定模式的频道。</li><li><code>PUBSUB subcommand [argument[argument]]</code> 查看订阅与发布系统状态。</li><li><code>PUBLISH channel message</code> 向指定频道发布消息</li><li><code>SUBSCRIBE channel [channel..]</code> 订阅给定的一个或多个频道。</li><li><code>UNSUBSCRIBE channel [channel..]</code> 退订一个或多个频道</li></ul><p><strong>代码示例</strong></p><div class="code-wrapper"><pre><code class="hljs shell">------------订阅端----------------------127.0.0.1:6379&gt; SUBSCRIBE pncalbl # 订阅sakura频道Reading messages... (press Ctrl-C to quit) # 等待接收消息1) &quot;subscribe&quot; # 订阅成功的消息2) &quot;sakura&quot;3) (integer) 11) &quot;message&quot; # 接收到来自sakura频道的消息 &quot;hello world&quot;2) &quot;sakura&quot;3) &quot;hello world&quot;1) &quot;message&quot; # 接收到来自sakura频道的消息 &quot;hello i am sakura&quot;2) &quot;sakura&quot;3) &quot;hello i am sakura&quot;--------------消息发布端-------------------127.0.0.1:6379&gt; PUBLISH pncalbl &quot;hello world&quot; # 发布消息到sakura频道(integer) 1127.0.0.1:6379&gt; PUBLISH pncalbl &quot;hello i am pncalbl&quot; # 发布消息(integer) 1-----------------查看活跃的频道------------127.0.0.1:6379&gt; PUBSUB channels&quot;sakura&quot;</code></pre></div><h3 id="11-2-原理"><a href="#11-2-原理" class="headerlink" title="11.2 原理"></a>11.2 原理</h3><p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，借此加深对 Redis 的理解。</p><p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/2020051321554964.png" alt></p><p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p><h3 id="11-2-缺点"><a href="#11-2-缺点" class="headerlink" title="11.2 缺点"></a>11.2 缺点</h3><ol><li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li><li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</li></ol><h3 id="11-3-应用"><a href="#11-3-应用" class="headerlink" title="11.3 应用"></a>11.3 应用</h3><ol><li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li><li>多人在线聊天室。</li></ol><p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p><h2 id="12-Redis主从复制"><a href="#12-Redis主从复制" class="headerlink" title="12 Redis主从复制"></a>12 Redis主从复制</h2><h3 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h3><ul><li><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p></li><li><p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p></li></ul><h3 id="12-2-作用"><a href="#12-2-作用" class="headerlink" title="12.2 作用"></a>12.2 作用</h3><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li><li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li><li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li></ol><h3 id="12-3-为什么使用集群"><a href="#12-3-为什么使用集群" class="headerlink" title="12.3 为什么使用集群"></a>12.3 为什么使用集群</h3><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p><ol><li><p>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</p></li><li><p>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。</p></li></ol><p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p><p>对于这种场景，我们可以使如下这种架构：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B007.jpg" alt></p><p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！</p><p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</p><p><strong>总结</strong></p><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限。</li></ol><h3 id="12-4-环境配置"><a href="#12-4-环境配置" class="headerlink" title="12.4 环境配置"></a>12.4 环境配置</h3><p>只配置从库，不用配置主库！</p><div class="code-wrapper"><pre><code class="hljs ini">127.0.0.1:6379&gt; info replication<span class="hljs-comment"># Replication</span>role:master # 角色connected_slaves:0 # 从机数量master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcffmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0</code></pre></div><p>复制3个配置文件，然后修改对应的信息</p><ol><li>端口</li><li>pid名字</li><li>log文件名</li><li>dump.rdb名字</li></ol><p>启动单机多服务集群：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215610163.png" alt></p><h4 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h4><p>默认情况下，每台Redis服务器都是主节点；我们一般情况下只用配置从机就好了！</p><p>认老大！一主（79）二从（80，81）</p><p>使用SLAVEOF host port就可以为从机配置主机了。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215637483.png" alt></p><p><strong>说明</strong></p><ul><li><code>SLAVEOF host 6379</code> 找谁当自己的老大！</li><li><code>role:slave</code> # 当前角色是从机</li><li><code>master_host:127.0.0.1</code> # 可以的看到主机的信息</li><li>如果主机有密码，需要设置主机密码</li></ul><p>然后主机上也能看到从机的状态：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215645778.png" alt></p><p><strong>说明</strong></p><ul><li><code>connected_slaves:1</code> # 多了从机的配置</li><li><code>slave0:ip=127.0.0.1,port=6380,state=online,offset=42,lag=1</code> # 多了从机的配置</li></ul><p>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！</p><h3 id="12-5-使用规则"><a href="#12-5-使用规则" class="headerlink" title="12.5 使用规则"></a>12.5 使用规则</h3><ol><li><p>从机只能读，不能写，主机可读可写但是多用于写。</p><div class="code-wrapper"><pre><code class="hljs shell">127.0.0.1:6381&gt; set name sakura # 从机6381写入失败(error) READONLY You can&#x27;t write against a read only replica.127.0.0.1:6380&gt; set name sakura # 从机6380写入失败(error) READONLY You can&#x27;t write against a read only replica.127.0.0.1:6379&gt; set name sakuraOK127.0.0.1:6379&gt; get name&quot;sakura&quot;</code></pre></div></li><li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p></li><li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p></li><li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p><ul><li>从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机</li><li>使用哨兵模式（自动选举）</li></ul></li><li><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p></li><li><p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么就重新连接！</p></li></ol><h3 id="12-6-复制原理"><a href="#12-6-复制原理" class="headerlink" title="12.6 复制原理"></a>12.6 复制原理</h3><p>Slave 启动成功连接到 master 后会发送一个sync同步命令</p><p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><p><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p><p><strong>增量复制</strong>：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p><p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！</p><h2 id="13-哨兵模式"><a href="#13-哨兵模式" class="headerlink" title="13 哨兵模式"></a>13 哨兵模式</h2><p>（自动选举老大的模式）</p><h3 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h3><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。<strong>能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</strong></p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/%E7%8B%82%E7%A5%9E%E8%AF%B4Redis%E7%AC%94%E8%AE%B008.jpg" alt></p><p>哨兵的作用：</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了<strong>多哨兵模式</strong>。</p><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p><h3 id="13-2-测试"><a href="#13-2-测试" class="headerlink" title="13.2 测试"></a>13.2 测试</h3><ol><li><p>配置哨兵配置文件 sentinel.conf</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># sentinel monitor 被监控的名称 host port 1</span>sentinel monitor myredis 127.0.0.1 6379 1</code></pre></div><p>后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！</p></li><li><p>启动哨兵！</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215752444.png" alt></p></li><li><p>此时哨兵监视着我们的主机6379，当我们断开主机后：</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215806972.png" alt></p></li></ol><h3 id="13-3-哨兵模式优缺点"><a href="#13-3-哨兵模式优缺点" class="headerlink" title="13.3 哨兵模式优缺点"></a>13.3 哨兵模式优缺点</h3><p>优点：</p><ol><li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li><li>主从可以切换，故障可以转移，系统的可用性更好</li><li>哨兵模式是主从模式的升级，手动到自动，更加健壮 缺点：</li><li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li></ol><h3 id="13-4-哨兵模式的全部配置"><a href="#13-4-哨兵模式的全部配置" class="headerlink" title="13.4 哨兵模式的全部配置"></a>13.4 哨兵模式的全部配置</h3><p>完整的哨兵模式配置文件 sentinel.conf</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># Example sentinel.conf</span>哨兵sentinel实例运行的端口 默认26379port 26379哨兵sentinel的工作目录dir /tmp哨兵sentinel监控的redis主节点的 ip portmaster-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;sentinel monitor mymaster 127.0.0.1 6379 1当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass mymaster MySUPER--secret-0123passw0rd指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;sentinel down-after-milliseconds mymaster 30000这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;sentinel parallel-syncs mymaster 1故障转移的超时时间 failover-timeout 可以用在以下这些方面：1. 同一个sentinel对同一个master两次failover之间的间隔时间。2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。3.当想要取消一个正在进行的failover所需要的时间。4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了默认三分钟sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;sentinel failover-timeout mymaster 180000SCRIPTS EXECUTION配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。对于脚本的运行结果有以下规则：若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。通知脚本sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;sentinel notification-script mymaster /var/redis/notify.sh客户端重新配置主节点参数脚本当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。以下参数将会在调用脚本时传给脚本:&lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;目前&lt;state&gt;总是“failover”,&lt;role&gt;是“leader”或者“observer”中的一个。参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的这个脚本应该是通用的，能被多次调用，不是针对性的。sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</code></pre></div><h2 id="14-缓存穿透与雪崩"><a href="#14-缓存穿透与雪崩" class="headerlink" title="14 缓存穿透与雪崩"></a>14 缓存穿透与雪崩</h2><h3 id="14-1-缓存穿透（即查询不到）"><a href="#14-1-缓存穿透（即查询不到）" class="headerlink" title="14.1 缓存穿透（即查询不到）"></a>14.1 缓存穿透（即查询不到）</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h4><p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p><h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2 解决方案"></a>2 解决方案</h4><h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215824722.jpg" alt></p><h5 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a><strong>缓存空对象</strong></h5><p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215836317.jpg" alt></p><p>这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p><p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h3 id="14-2-缓存击穿（即量太大，缓存过期）"><a href="#14-2-缓存击穿（即量太大，缓存过期）" class="headerlink" title="14.2 缓存击穿（即量太大，缓存过期）"></a>14.2 缓存击穿（即量太大，缓存过期）</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1 概念"></a>1 概念</h4><ul><li><p>相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p></li><li><p>比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p></li></ul><h4 id="2-解决方案-1"><a href="#2-解决方案-1" class="headerlink" title="2 解决方案"></a>2 解决方案</h4><ol><li><p>设置热点数据永不过期</p><p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p></li><li><p>加互斥锁(分布式锁)</p><p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p></li></ol><h3 id="14-3-缓存雪崩"><a href="#14-3-缓存雪崩" class="headerlink" title="14.3 缓存雪崩"></a>14.3 缓存雪崩</h3><h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1 概念"></a>1 概念</h4><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！</p><p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src="/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/20200513215850428.jpeg" alt></p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p><h4 id="2-解决方案-2"><a href="#2-解决方案-2" class="headerlink" title="2 解决方案"></a>2 解决方案</h4><blockquote><p>  redis高可用</p></blockquote><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p><blockquote><p>  限流降级</p></blockquote><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><blockquote><p>  数据预热</p></blockquote><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/DB/">DB</category>
      
      
      
      <comments>https://pncalbl.github.io/2021/05/08/Redis%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MongoDB 学习</title>
      <link>https://pncalbl.github.io/2021/05/01/MongoDB%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/01/MongoDB%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 30 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;MongoDB-学习&quot;&gt;&lt;a href=&quot;#MongoDB-学习&quot; class=&quot;headerlink&quot; title=&quot;MongoDB 学习&quot;&gt;&lt;/a&gt;MongoDB 学习&lt;/h1&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="MongoDB-学习"><a href="#MongoDB-学习" class="headerlink" title="MongoDB 学习"></a>MongoDB 学习</h1>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/DB/">DB</category>
      
      
      <category domain="https://pncalbl.github.io/tags/MongoDB/">MongoDB</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/01/MongoDB%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>WSL和VM不兼容</title>
      <link>https://pncalbl.github.io/2021/05/01/WSL%E5%92%8CVM/</link>
      <guid>https://pncalbl.github.io/2021/05/01/WSL%E5%92%8CVM/</guid>
      <pubDate>Fri, 30 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭&quot;&gt;&lt;a href=&quot;#WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭&quot; class=&quot;headerlink&quot; title=&quot;WSL依赖于hyper-v必须开启，而VMw</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭"><a href="#WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭" class="headerlink" title="WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭"></a>WSL依赖于hyper-v必须开启，而VMware不依赖这个，必须关闭</h3><ul><li>CMD管理员模式启动，输入</li></ul><div class="code-wrapper"><pre><code class="hljs arduino">bcdedit /set hypervisorlaunchtype <span class="hljs-keyword">auto</span></code></pre></div><ul><li>开启，则可以使用WSL</li></ul><ul><li>CMD管理员模式启动，输入</li></ul><div class="code-wrapper"><pre><code class="hljs cmake">bcdedit /<span class="hljs-keyword">set</span> hypervisorlaunchtype <span class="hljs-keyword">off</span></code></pre></div><ul><li>关闭，则可以使用VMware</li></ul><p>注意：不管是开还是关都需要重启电脑</p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Linux/">Linux</category>
      
      
      <category domain="https://pncalbl.github.io/tags/WSL/">WSL</category>
      
      <category domain="https://pncalbl.github.io/tags/VM/">VM</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/01/WSL%E5%92%8CVM/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Dubbo 学习</title>
      <link>https://pncalbl.github.io/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 30 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Dubbo-学习&quot;&gt;&lt;a href=&quot;#Dubbo-学习&quot; class=&quot;headerlink&quot; title=&quot;Dubbo 学习&quot;&gt;&lt;/a&gt;Dubbo 学习&lt;/h1&gt;&lt;h2 id=&quot;1-分布式简要说明&quot;&gt;&lt;a href=&quot;#1-分布式简要说明&quot; class=&quot;he</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Dubbo-学习"><a href="#Dubbo-学习" class="headerlink" title="Dubbo 学习"></a>Dubbo 学习</h1><h2 id="1-分布式简要说明"><a href="#1-分布式简要说明" class="headerlink" title="1 分布式简要说明"></a>1 分布式简要说明</h2><h3 id="1-1-什么是分布式？"><a href="#1-1-什么是分布式？" class="headerlink" title="1.1 什么是分布式？"></a>1.1 什么是分布式？</h3><ul><li><p>Dubbo是用于分布式系统的框架所以我们要先了解什么是分布式<br>分布式系统是若干独立 计算机的集合，这些计算机对于用户来说就像单个相关系统。</p></li><li><p>老式系统(单一应用架构)就是把一个系统，统一放到一个服务器当中然后每一个服务器上放一个系统，如果说要更新代码的话，每一个服务器上的系统都要重新去部署十分的麻烦。</p></li></ul><ul><li>而分布式系统就是将一个完整的系统拆分成多个不同的服务，然后在将每一个服务单独的放到一个服务器当中。(三个臭皮匠赛过诸葛亮)</li></ul><h3 id="1-2-RPC-简介"><a href="#1-2-RPC-简介" class="headerlink" title="1.2 RPC 简介"></a>1.2 RPC 简介</h3><ul><li><p><strong>分布式应用架构(远程过程调用)</strong>：当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</p></li><li><p>什么叫RPC</p><ul><li>RPC [ Remote Procedure Call]是指远程过程调用，是一种进程问通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间(通常是共享网络的另一台机器上)的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</li><li>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</li></ul></li><li><p><strong>RPC工作原理</strong></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/2020061015260046.png" alt="img"></p><ol><li>Client像调用本地服务似的调用远程服务；</li><li>Client stub接收到调用后，将方法、参数序列化</li><li>客户端通过sockets将消息发送到服务端</li><li>Server stub 收到消息后进行解码（将消息对象反序列化）</li><li>Server stub 根据解码结果调用本地的服务</li><li>本地服务执行(对于服务端来说是本地执行)并将结果返回给Server stub</li><li>Server stub将返回结果打包成消息（将结果消息对象序列化）</li><li>服务端通过sockets将消息发送到客户端</li><li>Client stub接收到结果消息，并进行解码（将结果消息发序列化）</li><li>客户端得到最终结果。</li></ol></li><li><p><strong>RPC 调用分以下两种：</strong></p><ul><li><strong>同步调用</strong>：客户方等待调用执行完成并返回结果。</li><li><strong>异步调用</strong>：客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。</li></ul></li><li><p><strong>RPC步骤解析</strong></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610174636250.png" alt="在这里插入图片描述"></p></li><li><p><strong>SOA</strong><br><strong>流动计算架构</strong>：在分布式应用架构的基础上增加了一个<strong>调度、治理中心</strong>基于访问压力实时管理集群容量、提高集群的利用率，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键 <strong>(不浪费计算机资源)</strong></p></li></ul><h2 id="2-Dubbo核心概念"><a href="#2-Dubbo核心概念" class="headerlink" title="2 Dubbo核心概念"></a>2 Dubbo核心概念</h2><p>Dubbo官网: <a href="http://dubbo.apache.org/en-us/index.html">http://dubbo.apache.org/en-us/index.html</a></p><p>Dubbo 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，服务自动注册和发现。分布式系统是将一个系统拆分为多个不同的服务。</p><h2 id="3-Dubbo特性一览"><a href="#3-Dubbo特性一览" class="headerlink" title="3 Dubbo特性一览"></a>3 Dubbo特性一览</h2><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610170234620.png" alt="img"></p><h3 id="Dubbo设计架构"><a href="#Dubbo设计架构" class="headerlink" title="Dubbo设计架构"></a>Dubbo设计架构</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610170317960.png" alt="在这里插入图片描述"></p><p>该图来自Dubbo官网，描述了服务注册中心、服务提供方、服务消费方、服务监控中心之间的调用关系。</p><ul><li><strong>服务提供者</strong>（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</li><li><strong>服务消费者</strong>（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li><strong>注册中心</strong>（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li><strong>监控中心</strong>（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><h2 id="4-Dubbo的特性解析"><a href="#4-Dubbo的特性解析" class="headerlink" title="4 Dubbo的特性解析"></a>4 Dubbo的特性解析</h2><ul><li><p>服务注册中心</p><ul><li>相比Hessian类RPC框架，Dubbo有自己的服务中心， 写好的服务可以注册到服务中心， 客户端从服务中心寻找服务，然后再到相应的服务提供者机器获取服务。通过服务中心可以实现集群、负载均衡、高可用(容错) 等重要功能。</li><li>服务中心一般使用zookeeper实现，也有redis和其他一些方式。以使用zookeeper作为服务中心为例，服务提供者启动后会在zookeeper的/dubbo节点下创建提供的服务节点，包含服务提供者ip、port等信息。服务提供者关闭时会从zookeeper中移除对应的服务。</li><li>服务使用者会从注册中心zookeeper中寻找服务，同一个服务可能会有多个提供者，Dubbo会帮我们找到合适的服务提供者，也就是针对服务提供者的负载均衡。</li></ul></li><li><p>负载均衡</p><p>当同一个服务有多个提供者在提供服务时，客户端如何正确的选择提供者实 现负载均衡呢？dubbo也给我们提供了几种方案：</p><ul><li>random 随机选提供者，并可以给提供者设置权重</li><li>roundrobin 轮询选择提供者</li><li>leastactive 最少活跃调用数，相同活跃数的随机，活跃数：指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li><li>consistenthash 一致性hash，相同参数的请求发到同一台机器上。</li></ul></li><li><p>简化测试，允许直连提供者<br>在开发阶段为了方便测试，通常系统客户端能指定调用某个服务提供者，那么可以在引用服务时加一个url参数去指定服务提供者。 配置如下</p><div class="code-wrapper"><pre><code class="hljs dubbo">&lt;dubbo:reference id&#x3D;&quot;xxxService&quot;interface&#x3D;&quot;com.alibaba.xxx.XxxService&quot;url&#x3D;&quot;dubbo:&#x2F;&#x2F;localhost:20890&quot;&#x2F;&gt;</code></pre></div></li><li><p>服务版本，服务分组<br>在Dubbo配置文件中可以通过制定版本实现连接制定提供者，也就是通过服务版本可以控制服务的不兼容升级；当同一个服务有多种实现时，可以使用服务分组进行区分。</p></li></ul><h2 id="5-Dubbo-Zookeeper"><a href="#5-Dubbo-Zookeeper" class="headerlink" title="5 Dubbo + Zookeeper"></a>5 Dubbo + Zookeeper</h2><h3 id="5-1-搭建zookeeper注册中心环境"><a href="#5-1-搭建zookeeper注册中心环境" class="headerlink" title="5.1 搭建zookeeper注册中心环境"></a>5.1 搭建zookeeper注册中心环境</h3><p>Dubbo官方文档: <a href="http://dubbo.apache.org/en-us/docs/user/quick-start.html">http://dubbo.apache.org/en-us/docs/user/quick-start.html</a><br>在zookeeper官网下载zookeeper<br><a href="http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/">http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/</a></p><ul><li>在bin文件下，启动zkServer.cmd会有报错，处理需要在condif文件中将zoo_sample.cfg文件复制一份，将名字改为zoo.cfg。<br>在zookeeper的文件夹下创建data文件夹，打开zoo.cfg，修改datadir，将dataDir数据保存为我们自定义的文件中(此步骤可省略)</li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610173149263.png" alt="img"></p><ul><li>配置完毕后，我们再次在conf下启动zkServer.cmd，这次可以成功启动</li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610173356318.png" alt="img"></p><ul><li>继续运行zkCli.cmd，可以连接到zookeeper的服务器。</li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610173644649.png" alt="img"></p><ul><li>此时，我们zookeeper的注册中心及环境以及搭建完毕。</li></ul><h3 id="5-2-zookeeper监控中心的配置"><a href="#5-2-zookeeper监控中心的配置" class="headerlink" title="5.2 zookeeper监控中心的配置"></a>5.2 zookeeper监控中心的配置</h3><ul><li><p>下载dubbo-admin</p><p>dubbo-admin下载地址 ：<a href="https://github.com/apache/dubbo-admin/tree/master">https://github.com/apache/dubbo-admin/tree/master</a></p></li><li><p>解压后进入目录修改指定zookeeper地址<br>进入如下地址：dubbo-admin-master\dubbo-admin\src\main\resources\application.properties”<br>将zookeeper的监控中心的地址配置为本地端口</p><div class="code-wrapper"><pre><code class="hljs dubbo">#注册中心的地址dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181</code></pre></div><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610175513207.png" alt="在这里插入图片描述"></p></li><li><p>配置完毕后，我们在dubo-zookeeper\dubbo-admin-master\dubbo-admin文件夹下cmd打包测试下。</p><div class="code-wrapper"><pre><code class="hljs dubbo">mvn clean package</code></pre></div><p>在target文件中打包完成的jar包</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610175909584.png" alt="img"></p></li></ul><ul><li><p>cmd命令 <code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</code>运行打包好的jar包<br>启动成功后，可以看到一个7001的端口</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610180201513-1620378376190.png" alt="在这里插入图片描述"></p></li><li><p>此时我们的zookeeper的服务都为启动状态，在浏览器中访问 localhost:7001，访问到注册中心，输入账号密码root。</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610180358177.png" alt="img"></p></li></ul><blockquote><p>  此时，我们zookeeper监控中心的配置完成。注意，要访问到监控中心，一定要启动zookeeper注册中心的启动类</p></blockquote><h2 id="6-Dubbo环境搭建，创建提供者、消费者项目"><a href="#6-Dubbo环境搭建，创建提供者、消费者项目" class="headerlink" title="6 Dubbo环境搭建，创建提供者、消费者项目"></a>6 Dubbo环境搭建，创建提供者、消费者项目</h2><p>基于以下图实现服务 提供者、消费者</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200610195718980.png" alt="在这里插入图片描述"></p><h3 id="6-1-Dubbo服务提供者和消费者接口搭建"><a href="#6-1-Dubbo服务提供者和消费者接口搭建" class="headerlink" title="6.1 Dubbo服务提供者和消费者接口搭建"></a>6.1 Dubbo服务提供者和消费者接口搭建</h3><p><strong>创建Maven项目=&gt; <code>user-service-provider</code> 服务提供者</strong></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509014131477.png" alt="image-20210509014131477"></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509014149815.png" alt="image-20210509014149815"></p><ul><li><p><strong>UserAddress</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAddress</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String userAddress; <span class="hljs-comment">//用户地址</span>    <span class="hljs-keyword">private</span> String userId; <span class="hljs-comment">//用户id</span>    <span class="hljs-keyword">private</span> String consignee; <span class="hljs-comment">//收货人</span>    <span class="hljs-keyword">private</span> String phoneNum; <span class="hljs-comment">//电话号码</span>    <span class="hljs-keyword">private</span> String isDefault; <span class="hljs-comment">//是否为默认地址    Y-是     N-否</span>    <span class="hljs-comment">//get     set </span>    <span class="hljs-comment">//有参构造  无参构造</span>  &#125;</code></pre></div></li><li><p><strong>UserService</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//用户服务</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 按照用户id返回所有的收货地址</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> userId</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span></span>;&#125;</code></pre></div></li><li><p><strong>UserServiceImpl</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span> </span>&#123;UserAddress address1 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;河南省郑州巩义市宋陵大厦2F&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;安然&quot;</span>, <span class="hljs-string">&quot;150360313x&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>);UserAddress address2 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;北京市昌平区沙河镇沙阳路&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;情话&quot;</span>, <span class="hljs-string">&quot;1766666395x&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>);<span class="hljs-keyword">return</span> Arrays.asList(address1,address2);&#125;&#125;</code></pre></div></li></ul><p><strong>创建Maven项目=&gt; <code>order-service-consumer</code> 服务消费者(订单服务)</strong></p><ul><li><p><strong>OrderService</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化订单</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userID</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span></span>;&#125;</code></pre></div></li><li><p><strong>OrderServiceImpl</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span> </span>&#123;        <span class="hljs-comment">//查询用户的收货地址</span>    &#125;&#125;</code></pre></div></li></ul><p><strong>因服务消费者要拿到提供者的方法</strong></p><p>将服务提供者中的实体类及 UserService 复制到当前消费者同级文件中。</p><ul><li><p><strong>OrderServiceImpl</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-keyword">public</span> UserService userService;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span> </span>&#123;        <span class="hljs-comment">//查询用户的收货地址</span>        List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList(userID);        System.out.println(userAddressList);    &#125;&#125;</code></pre></div></li></ul><p>此时我们调用 userservice 肯定是要报错的。这种面向接口的方式，我们这里只是调到了接口，而接口实际是在另外一个项目中，如果我们两个项目工程都创建共同的实体类，太过于麻烦了，我们可以将服务接口，服务模型等单独放在一个项目中，更为方便调用。</p><p><strong>创建Maven项目=&gt; gmail-interface 用于存放共同的服务接口</strong></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200611154037439.png" alt="在这里插入图片描述"></p><p>将 提供者 和 消费者 项目中的所有实体类复制到当前相关的文件包下，删除原有的实体类包及service包，也就是将实体类及service放在了当前公共的项目中。</p><p>把服务提供者和消费者项目中引入以下依赖，引入后项目不在报错.</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lemon.gmail<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmail-interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="6-2-服务提供者配置及测试"><a href="#6-2-服务提供者配置及测试" class="headerlink" title="6.2 服务提供者配置及测试"></a>6.2 服务提供者配置及测试</h3><p>在 <code>user-service-provider</code> 服务提供者项目中引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--注册中心是 zookeeper，引入zookeeper客户端--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>在<code>resource</code>文件中创建<code>provider.xml</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user-service-provider&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- 2、指定注册中心的位置 --&gt;</span><span class="hljs-comment">&lt;!-- &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt; --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;zookeeper&quot;</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20882&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--4、暴露服务 让别人调用 ref指向服务的真正实现对象--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.lemon.gmail.service.UserService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span>    <span class="hljs-comment">&lt;!--服务的实现--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userServiceImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.lemon.gmail.service.impl.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>编写一个<code>ProviderApplication</code>启动类程序，运行测试配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        ClassPathXmlApplicationContext applicationContext= <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;provider.xml&quot;</span>);        applicationContext.start();        System.inread();    &#125;&#125;</code></pre></div><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509015143656.png" alt="image-20210509015143656"></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210509015205821.png" alt="image-20210509015205821"></p><h3 id="6-3-服务消费者配置及测试"><a href="#6-3-服务消费者配置及测试" class="headerlink" title="6.3 服务消费者配置及测试"></a>6.3 服务消费者配置及测试</h3><p>在 <code>order-service-consumer</code> 服务消费者项目中引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--注册中心是 zookeeper，引入zookeeper客户端--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>创建<code>consumer.xml</code></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.pnca.gmall&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order-service-consumer&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.pnca.gmall.service.UserService&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div><p>把当前<code>OrderServiceImpl</code>实现类中加上注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">public</span> UserService userService;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initOrder</span><span class="hljs-params">(String userID)</span> </span>&#123;        <span class="hljs-comment">//查询用户的收货地址</span>        List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList(userID);                <span class="hljs-comment">//为了直观的看到得到的数据，以下内容也可不写</span>        System.out.println(<span class="hljs-string">&quot;当前接收到的userId=&gt; &quot;</span>+userID);        System.out.println(<span class="hljs-string">&quot;**********&quot;</span>);        System.out.println(<span class="hljs-string">&quot;查询到的所有地址为：&quot;</span>);        <span class="hljs-keyword">for</span> (UserAddress userAddress : userAddressList) &#123;            <span class="hljs-comment">//打印远程服务地址的信息</span>            System.out.println(userAddress.getUserAddress());        &#125;            &#125;&#125;</code></pre></div><p>编写一个<code>ConsumerApplication</code>启动类程序，运行测试配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ClassPathXmlApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;consumer.xml&quot;</span>);        OrderService orderService = applicationContext.getBean(OrderService.class);        <span class="hljs-comment">//调用方法查询出数据</span>        orderService.initOrder(<span class="hljs-string">&quot;1&quot;</span>);        System.out.println(<span class="hljs-string">&quot;调用完成...&quot;</span>);    System.in.read();    &#125;&#125;</code></pre></div><p>注意：消费者的运行测试需要先启动提供者。<br>启动服务提供者、消费者。及zookeeper的和dubbo-admin，查看监控信息。<br>localhost:7001</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512202425183.png" alt="image-20210512202425183"></p><h2 id="7-dubbo-monitor-simple-简易监控中心"><a href="#7-dubbo-monitor-simple-简易监控中心" class="headerlink" title="7 dubbo-monitor-simple 简易监控中心"></a>7 dubbo-monitor-simple 简易监控中心</h2><ul><li><p>进入dubbo-monitor-simple文件，执行cmd命令，mvn package打包成jar包</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612083732691.png" alt="在这里插入图片描述"></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200612084630745.png" alt="在这里插入图片描述"></p><ul><li><p>将 <code>dubbo-monitor-simple-2.0.0-assembly.tar.gz</code> 压缩包解压至当前文件夹，解压后config文件查看properties的配置是否是本地的zookeeper。</p></li><li><p>打开解压后的 <code>assembly.bin</code> 文件，<code>start.bat</code> 启动<code>dubbo-monitor-simple监控中心</code></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512203200864.png" alt="image-20210512203200864"></p><p>在浏览器 <code>localhost:8080</code> ，可以看到一个监控中心。<br>在服务提供者和消费者的xml中配置以下内容，再次启动服务提供和消费者启动类。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo-monitor-simple监控中心发现的配置--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:monitor</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;registry&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:monitor</span>&gt;</span><span class="hljs-comment">&lt;!--&lt;dubbo:monitor address=&quot;127.0.0.1:7070&quot;&gt;&lt;/dubbo:monitor&gt;--&gt;</span></code></pre></div><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512203449002.png" alt="image-20210512203449002"></p></li></ul><h2 id="8-Dubbo-与-springboot-整合"><a href="#8-Dubbo-与-springboot-整合" class="headerlink" title="8 Dubbo 与 springboot 整合"></a>8 Dubbo 与 springboot 整合</h2><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612152443622.png" alt="在这里插入图片描述"></p><h3 id="8-1-boot-user-service-provider-服务提供者"><a href="#8-1-boot-user-service-provider-服务提供者" class="headerlink" title="8.1 boot-user-service-provider 服务提供者"></a>8.1 boot-user-service-provider 服务提供者</h3><ul><li><p><strong>创建 springboot 项目 <code>boot-user-service-provider</code></strong> 服务提供者</p></li><li><p>导入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca.gmall<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmall_interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>把 <code>user-service-provider</code> 中的 service 拿到此项目中。注意，以此方法为返回的需要更改 interface 包中的 void为 List<UserAddress></UserAddress></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>    <span class="hljs-comment">// dubbo暴露服务</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">&quot;UserServiceImpl..3.....&quot;</span>);UserAddress address1 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;北京市昌平区宏福科技园综合楼3层&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;李老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>);UserAddress address2 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;深圳市宝安区西部硅谷大厦B座3层（深圳分校）&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;王老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>);<span class="hljs-keyword">return</span> Arrays.asList(address1, address2);&#125;&#125;</code></pre></div></li><li><p>配置 <code>application.properties</code></p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">boot_user_service_provider</span><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">127.0.0.1:2181</span><span class="hljs-meta">dubbo.registry.protocol</span>=<span class="hljs-string">zookeeper</span><span class="hljs-meta">dubbo.protocol.name</span>=<span class="hljs-string">dubbo</span><span class="hljs-meta">dubbo.protocol.port</span>=<span class="hljs-string">20880</span><span class="hljs-comment">#连接监控中心</span><span class="hljs-meta">dubbo.monitor.protocol</span>=<span class="hljs-string">registry</span></code></pre></div></li><li><p>BootUserServiceProviderApplication启动类配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableDubbo</span>    <span class="hljs-comment">//开启基于注解的dubbo功能</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootUserServiceProviderApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(BootUserServiceProviderApplication.class, args);&#125;&#125;</code></pre></div></li><li><p>启动注册中心，启动当前服务提供者，可以在浏览器看到一个服务提供者。</p></li></ul><h3 id="8-2-boot-order-service-consumer-服务消费者"><a href="#8-2-boot-order-service-consumer-服务消费者" class="headerlink" title="8.2 boot-order-service-consumer 服务消费者"></a>8.2 boot-order-service-consumer 服务消费者</h3><ul><li><p><strong>创建springboot项目 <code>boot-order-service-consumer</code></strong> 服务消费者</p></li><li><p>导入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.pnca.gmall<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gmall_interface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>把 <code>order-service-consumer</code> 中的 service 拿到此项目中。注意，以此方法为返回的需要更改 interface 包中的 void 为 List<UserAddress></UserAddress></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;<span class="hljs-comment">// @Autowired</span><span class="hljs-meta">@Reference</span>UserService userService;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">initOrder</span><span class="hljs-params">(String userId)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">&quot;用户id：&quot;</span> + userId);<span class="hljs-comment">//1、查询用户的收货地址</span>List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId);<span class="hljs-keyword">for</span> (UserAddress userAddress : addressList) &#123;System.out.println(userAddress);&#125;<span class="hljs-keyword">return</span> addressList;&#125;&#125;</code></pre></div></li><li><p>创建 OrderController 控制器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;<span class="hljs-meta">@Autowired</span>OrderService orderService;<span class="hljs-meta">@ResponseBody</span><span class="hljs-meta">@RequestMapping(&quot;/initOrder&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">initOrder</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;uid&quot;)</span> String userId)</span> </span>&#123;<span class="hljs-keyword">return</span> orderService.initOrder(userId);&#125;&#125;</code></pre></div></li><li><p>配置 <code>application.properties</code></p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">boot_order_service_consumer</span><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">zookeeper://127.0.0.1:2181</span><span class="hljs-meta">dubbo.registry.protocol</span>=<span class="hljs-string">zookeeper</span><span class="hljs-comment">#连接监控中心</span><span class="hljs-meta">dubbo.monitor.protocol</span>=<span class="hljs-string">registry</span></code></pre></div></li><li><p>BootOrderServiceConsumerApplication启动类配置</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableDubbo</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootOrderServiceConsumerApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(BootOrderServiceConsumerApplication.class, args);&#125;&#125;</code></pre></div></li><li><p>配置完毕，此时启动zookeeper注册中心及监控。<br>启动springboot配置的服务提供者和消费者<br>在浏览器输入 localhost:7001 查看结果</p></li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512215907361.png" alt="image-20210512215907361"></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210512215927876.png" alt="image-20210512215927876"></p><p>duboo的springboot整合配置完成。</p><h2 id="9-Dubbo-配置"><a href="#9-Dubbo-配置" class="headerlink" title="9 Dubbo 配置"></a>9 Dubbo 配置</h2><p>dubbo配置官网参考：<a href="http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html">http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html</a></p><h3 id="9-1-配置原则"><a href="#9-1-配置原则" class="headerlink" title="9.1 配置原则"></a>9.1 配置原则</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612152343133.png" alt="在这里插入图片描述"></p><ul><li>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</li><li>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</li><li>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</li></ul><h3 id="9-2-启动时检查"><a href="#9-2-启动时检查" class="headerlink" title="9.2 启动时检查"></a>9.2 启动时检查</h3><ul><li>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=“true”。</li></ul><ul><li>可以通过 check=“false” 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</li></ul><ul><li><p>另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=“false”，总是会返回引用，当服务恢复时，能自动连上。</p></li><li><p>以<code>order-service-consumer</code>消费者为例，在consumer.xml中添加配置</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置当前消费者的统一规则,当前所有的服务都不启动时检查--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:consumer</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:consumer</span>&gt;</span></code></pre></div></li><li><p>添加后，即使服务提供者不启动，启动当前的消费者，也不会出现错误。</p></li></ul><h3 id="9-3-全局超时配置"><a href="#9-3-全局超时配置" class="headerlink" title="9.3 全局超时配置"></a>9.3 全局超时配置</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--全局超时配置--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:provider</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span> /&gt;</span>指定接口以及特定方法超时配置<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:provider</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.foo.BarService&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;2000&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sayHello&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;3000&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:provider</span>&gt;</span></code></pre></div><p><strong>配置原则</strong></p><p>dubbo推荐在Provider上尽量多配置Consumer端属性</p><div class="code-wrapper"><pre><code class="hljs plain">1、作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等2、在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的</code></pre></div><p>配置的覆盖规则：</p><ul><li><p>方法级配置别优于接口级别，即小Scope优先</p></li><li><p>Consumer端配置 优于 Provider配置 优于 全局配置，</p></li><li><p>最后是Dubbo Hard Code的配置值（见配置文档）</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612160853853.png" alt="在这里插入图片描述"></p><p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html">http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html</a><br>在服务提供者中复制多个impl。起不同的名字</p></li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612163440781.png" alt="在这里插入图片描述"></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612163456305.png" alt="在这里插入图片描述"></p><p>配置多个文件的路径及信息。<br>服务消费者调用时，可自由配置版本</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612163603598.png" alt="在这里插入图片描述"></p><h3 id="9-4-dubbo与springboot整合的三种方式"><a href="#9-4-dubbo与springboot整合的三种方式" class="headerlink" title="9.4 dubbo与springboot整合的三种方式"></a>9.4 dubbo与springboot整合的三种方式</h3><ul><li><p>将服务提供者注册到注册中心(如何暴露服务)</p><ul><li>导入Dubbo的依赖 和 zookeeper 客户端</li></ul></li><li><p>让服务消费者去注册中心订阅服务提供者的服务地址<br>Springboot与Dubbo整合的三种方式</p><ol><li><p>导入dubbo-starter。在application.properties配置属性，使用@Service【暴露服务】，使用@Reference【引用服务】</p></li><li><p>保留Dubbo 相关的xml配置文件</p><p> 导入dubbo-starter，使用@ImportResource导入Dubbo的xml配置文件</p></li><li><p>使用 注解API的方式</p><p>将每一个组件手动配置到容器中,让dubbo来扫描其他的组件</p></li></ol></li></ul><h2 id="10-高可用"><a href="#10-高可用" class="headerlink" title="10 高可用"></a>10 高可用</h2><p>zookeeper宕机与dubbo直连<br>现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。<br>原因：</p><p>健壮性</p><ul><li>监控中心宕掉不影响使用，只是丢失部分采样数据</li><li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li><li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li><li>高可用：通过设计，减少系统不能提供服务的时间；</li></ul><h3 id="集群下dubbo负载均衡配置"><a href="#集群下dubbo负载均衡配置" class="headerlink" title="集群下dubbo负载均衡配置"></a>集群下dubbo负载均衡配置</h3><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p><p><strong>负载均衡策略如下</strong></p><ul><li><p><strong>Random LoadBalance 基于权重的随机负载均衡机制</strong></p><p>随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p></li></ul><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612180908789.png" alt="在这里插入图片描述"></p><ul><li><p><strong>RoundRobin LoadBalance 基于权重的轮询负载均衡机制</strong></p><p>轮循，按公约后的权重设置轮循比率。 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612180928170.png" alt="在这里插入图片描述"></p></li></ul><ul><li><p><strong>LeastActive LoadBalance最少活跃数负载均衡机制</strong></p><p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200612180951468.png" alt="在这里插入图片描述"></p></li></ul><ul><li><p><strong>ConsistentHash LoadBalance一致性hash 负载均衡机制</strong></p><ul><li>一致性 Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li><li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a> </li><li>缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=”hash.arguments” value=”0,1” /&gt; 缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=”hash.nodes” value=”320” /&gt;</li></ul></li></ul><div class="code-wrapper"><pre><code>![在这里插入图片描述](Dubbo学习/20200612181007825.png)</code></pre></div><h2 id="11-整合-hystrix-，服务熔断与降级处理"><a href="#11-整合-hystrix-，服务熔断与降级处理" class="headerlink" title="11 整合 hystrix ，服务熔断与降级处理"></a>11 整合 hystrix ，服务熔断与降级处理</h2><h3 id="11-1-服务降级"><a href="#11-1-服务降级" class="headerlink" title="11.1 服务降级"></a>11.1 服务降级</h3><p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</strong><br>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。<br>向注册中心写入动态配置覆盖规则：</p><div class="code-wrapper"><pre><code class="hljs java">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="hljs-string">&quot;zookeeper://10.20.153.10:2181&quot;</span>));registry.register(URL.valueOf(<span class="hljs-string">&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;</span>));</code></pre></div><p>其中：<br>mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时，对调用方的影响。<br>还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时，对调用方的影响。</p><h3 id="11-2-集群容错"><a href="#11-2-集群容错" class="headerlink" title="11.2 集群容错"></a>11.2 集群容错</h3><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><ul><li><p><strong>集群容错模式</strong></p><ul><li><p><strong>Failover Cluster</strong><br>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。</p><p>重试次数配置如下：<br>&lt;dubbo:service retries=“2” /&gt;<br>或<br>&lt;dubbo:reference retries=“2” /&gt;<br>或<br>dubbo:reference<br>&lt;dubbo:method name=“findFoo” retries=“2” /&gt;<br></p></li><li><p><strong>Failfast Cluster</strong><br>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p></li><li><p><strong>Failsafe Cluster</strong><br>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p></li><li><p><strong>Failback Cluster</strong><br>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p></li><li><p><strong>Forking Cluster</strong><br>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</p></li><li><p><strong>Broadcast Cluster</strong><br>广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p></li></ul></li><li><p><strong>集群模式配置</strong><br>按照以下示例在服务提供方和消费方配置集群模式<br>&lt;dubbo:service cluster=“failsafe” /&gt;<br>或<br>&lt;dubbo:reference cluster=“failsafe” /&gt;</p></li></ul><h3 id="11-3-整合hystrix"><a href="#11-3-整合hystrix" class="headerlink" title="11.3 整合hystrix"></a>11.3 整合hystrix</h3><p>服务熔断错处理配置参考=&gt; <a href="https://www.cnblogs.com/xc-xinxue/p/12459861.html">https://www.cnblogs.com/xc-xinxue/p/12459861.html</a></p><p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能</p><ul><li><p><strong>配置spring-cloud-starter-netflix-hystrix</strong></p></li><li><p>spring boot官方提供了对<strong>hystrix</strong>的集成，直接在pom.xml里加入依赖：</p><div class="code-wrapper"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>然后在Application类上增加<strong>@EnableHystrix</strong>来启用hystrix starter：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableHystrix</span> <span class="hljs-comment">//开启服务容错功能</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderApplication</span> </span>&#123;...启动方法&#125;</code></pre></div></li><li><p><strong>配置Provider端</strong></p><p>在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>    <span class="hljs-comment">// dubbo暴露服务</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<span class="hljs-meta">@HystrixCommand</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserAddress&gt; <span class="hljs-title">getUserAddressList</span><span class="hljs-params">(String userId)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">&quot;UserServiceImpl..3.....&quot;</span>);UserAddress address1 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;北京市昌平区宏福科技园综合楼3层&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;李老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>);UserAddress address2 = <span class="hljs-keyword">new</span> UserAddress(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;深圳市宝安区西部硅谷大厦B座3层（深圳分校）&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;王老师&quot;</span>, <span class="hljs-string">&quot;010-56253825&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>);<span class="hljs-keyword">if</span> (Math.random() &gt; <span class="hljs-number">0.5</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();&#125;<span class="hljs-keyword">return</span> Arrays.asList(address1, address2);&#125;&#125;</code></pre></div></li><li><p><strong>配置Consumer端</strong><br>对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod = “reliable”的调用里。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Reference(version = &quot;1.0.0&quot;)</span>    <span class="hljs-keyword">private</span> HelloService demoService;    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;reliable&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doSayHello</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> demoService.sayHello(name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reliable</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hystrix fallback value&quot;</span>;    &#125;</code></pre></div></li><li><p>测试</p><ul><li><p>失败<img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210523011440767.png" alt="image-20210523011440767"></p></li><li><p>成功</p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/image-20210523011523532.png" alt="image-20210523011523532"></p></li></ul></li></ul><h2 id="12-RPC-和-netty-原理分析"><a href="#12-RPC-和-netty-原理分析" class="headerlink" title="12 RPC 和 netty 原理分析"></a>12 RPC 和 netty 原理分析</h2><h3 id="12-1-RPC-原理"><a href="#12-1-RPC-原理" class="headerlink" title="12.1 RPC 原理"></a>12.1 RPC 原理</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613170846919.png" alt="在这里插入图片描述"></p><p>一次完整的RPC调用流程（同步调用，异步另说）如下：</p><ol><li><strong>服务消费方（client）调用以本地调用方式调用服务；</strong></li><li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li><li>client stub找到服务地址，并将消息发送到服务端；</li><li>server stub收到消息后进行解码；</li><li>server stub根据解码结果调用本地的服务；</li><li>本地服务执行并将结果返回给server stub；</li><li>server stub将返回结果打包成消息并发送至消费方；</li><li>client stub接收到消息，并进行解码；</li><li><strong>服务消费方得到最终结果。</strong></li></ol><p>dubbo只用了两步1和8，中间的过程是透明的看不到的。RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</p><h3 id="12-2-netty-通信原理"><a href="#12-2-netty-通信原理" class="headerlink" title="12.2 netty 通信原理"></a>12.2 netty 通信原理</h3><p>Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p><p><strong>BIO：(Blocking IO)</strong></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171108394.png" alt="在这里插入图片描述"></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171138127.png" alt="在这里插入图片描述"></p><p>Selector 一般称 为选择器 ，也可以翻译为 多路复用器，<br>Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）</p><p><strong>Netty基本原理：</strong><br>netty基本原理，可参考<a href="https://www.sohu.com/a/272879207_463994">https://www.sohu.com/a/272879207_463994</a></p><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171217369.png" alt="在这里插入图片描述"></p><h2 id="12-3-dubbo-原理"><a href="#12-3-dubbo-原理" class="headerlink" title="12.3 dubbo 原理"></a>12.3 dubbo 原理</h2><h3 id="1-dubbo原理-框架设计"><a href="#1-dubbo原理-框架设计" class="headerlink" title="1. dubbo原理 - 框架设计"></a>1. dubbo原理 - 框架设计</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171327533.png" alt="在这里插入图片描述"></p><ul><li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li><li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li><li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li><li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li><li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li><li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li><li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li><li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li><li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li></ul><h3 id="2-dubbo原理-启动解析、加载配置信息"><a href="#2-dubbo原理-启动解析、加载配置信息" class="headerlink" title="2.dubbo原理 - 启动解析、加载配置信息"></a>2.dubbo原理 - 启动解析、加载配置信息</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171545504.png" alt="在这里插入图片描述"></p><h3 id="3-dubbo原理-服务暴露"><a href="#3-dubbo原理-服务暴露" class="headerlink" title="3.dubbo原理 - 服务暴露"></a>3.dubbo原理 - 服务暴露</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171614614.png" alt="在这里插入图片描述"></p><h3 id="4-dubbo原理-服务引用"><a href="#4-dubbo原理-服务引用" class="headerlink" title="4.dubbo原理 - 服务引用"></a>4.dubbo原理 - 服务引用</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171741579.png" alt="在这里插入图片描述"></p><h3 id="5-dubbo原理-服务调用"><a href="#5-dubbo原理-服务调用" class="headerlink" title="5.dubbo原理 - 服务调用"></a>5.dubbo原理 - 服务调用</h3><p><img src="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/20200613171806762.png" alt="在这里插入图片描述"></p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Distributed/">Distributed</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Dubbo/">Dubbo</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker 学习</title>
      <link>https://pncalbl.github.io/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/</link>
      <guid>https://pncalbl.github.io/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 30 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Docker-学习&quot;&gt;&lt;a href=&quot;#Docker-学习&quot; class=&quot;headerlink&quot; title=&quot;Docker 学习&quot;&gt;&lt;/a&gt;Docker 学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  弱小和无知不是生存的障碍，傲慢才是。&lt;/p&gt;
&lt;/bl</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Docker-学习"><a href="#Docker-学习" class="headerlink" title="Docker 学习"></a>Docker 学习</h1><blockquote><p>  弱小和无知不是生存的障碍，傲慢才是。</p></blockquote><h2 id="1-Docker-概述"><a href="#1-Docker-概述" class="headerlink" title="1 Docker 概述"></a>1 Docker 概述</h2><h3 id="1-1-Docker-为什么出现"><a href="#1-1-Docker-为什么出现" class="headerlink" title="1.1 Docker 为什么出现?"></a>1.1 Docker 为什么出现?</h3><p>一款产品： 开发–上线 两套环境！应用环境，应用配置！</p><p>开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？</p><p>环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。</p><p>发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！</p><p>之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。</p><p>开发环境Windows，最后发布到Linux！</p><p>传统：开发jar，运维来做！</p><p>现在：开发打包部署上线，一套流程做完！</p><p>安卓流程：java — apk —发布（应用商店）一 张三使用apk一安装即可用！</p><p>docker流程： java-jar（环境） — 打包项目帯上环境（镜像） — ( Docker仓库：商店）—–</p><p>Docker给以上的问题，提出了解决方案!</p><p>Docker的思想就来自于集装箱！</p><p>JRE – 多个应用(端口冲突) – 原来都是交叉的！<br>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p><p>Docker通过隔离机制，可以将服务器利用到极致！</p><p>本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！</p><h3 id="1-2-Docker-历史"><a href="#1-2-Docker-历史" class="headerlink" title="1.2 Docker 历史"></a>1.2 Docker 历史</h3><p>2010年，几个的年轻人，就在美国成立了一家公司 dotcloud</p><p>做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！</p><p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p><p>他们将自己的技术（容器化技术）命名就是 Docker<br>Docker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！</p><blockquote><p>  开源</p></blockquote><p>2013年，Docker开源！</p><p>越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！</p><p>2014年4月9日，Docker1.0发布！</p><p>docker为什么这么火？十分的轻巧！</p><p>在容器技术出来之前，我们都是使用虚拟机技术！</p><p>虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！</p><p>虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！</p><div class="code-wrapper"><pre><code class="hljs dockerfile">VMware : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟docker: 隔离，镜像（最核心的环境 <span class="hljs-number">4</span>m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！</code></pre></div><p>Docker基于Go语言开发的！开源项目！</p><p>docker官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a> Docker的文档是超级详细的！</p><p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>比较Docker和虚拟机技术的不同：</p><p>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</p><p>容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</p><p>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响</p><p>应用更快速的交付和部署</p><p>传统：一对帮助文档，安装程序。</p><p>Docker：打包镜像发布测试一键运行。</p><p>更便捷的升级和扩缩容</p><p>使用了 Docker之后，我们部署应用就和搭积木一样<br>项目打包为一个镜像，扩展服务器A！服务器B</p><p>更简单的系统运维<br>在容器化之后，我们的开发，测试环境都是高度一致的</p><p>更高效的计算资源利用</p><p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</p><h2 id="2-Docker-安装"><a href="#2-Docker-安装" class="headerlink" title="2 Docker 安装"></a>2 Docker 安装</h2><h3 id="2-1-Docker-的基本组成"><a href="#2-1-Docker-的基本组成" class="headerlink" title="2.1 Docker 的基本组成"></a>2.1 Docker 的基本组成</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDE5NTgwNTQwMC5wbmc" alt="image-20200514195805400"></p><ul><li><p>镜像（image)：</p><p>docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像 ==&gt; run ==&gt; 容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p></li><li><p>容器(container)：</p><p>Docker 利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.<br>启动，停止，删除，基本命令<br>目前就可以把这个容器理解为就是一个简易的 Linux系统。</p></li><li><p>仓库(repository)：</p><p>仓库就是存放镜像的地方！<br>仓库分为公有仓库和私有仓库。(很类似git)<br>Docker Hub是国外的。<br>阿里云…都有容器服务器(配置镜像加速!)</p></li></ul><h3 id="2-2-安装-Docker"><a href="#2-2-安装-Docker" class="headerlink" title="2.2 安装 Docker"></a>2.2 安装 Docker</h3><blockquote><p>  环境准备</p></blockquote><ol><li>Linux要求内核3.0以上</li><li>CentOS 7</li></ol><div class="code-wrapper"><pre><code class="hljs xml">[root@iZwz9chr22v1g8swsrgdagZ ~]# uname -r3.10.0-1127.19.1.el7.x86_64[root@iZwz9chr22v1g8swsrgdagZ ~]# cat /etc/os-release NAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</code></pre></div><blockquote><p>  安装</p></blockquote><p>帮助文档：<a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a><br>卸载与安装</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.卸载旧版本</span>yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine<span class="hljs-meta">#</span><span class="bash"> 2.需要的安装包</span>yum install -y yum-utils<span class="hljs-meta">#</span><span class="bash"> 3.设置镜像的仓库</span>yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo<span class="hljs-meta">#</span><span class="bash">上述方法默认是从国外的，不推荐</span><span class="hljs-meta">#</span><span class="bash">推荐使用国内的</span>yum-config-manager \    --add-repo \    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo    <span class="hljs-meta">#</span><span class="bash">更新yum软件包索引</span>yum makecache fast<span class="hljs-meta">#</span><span class="bash"> 4.安装docker相关的 docker-ce 社区版 而ee是企业版</span>yum install docker-ce docker-ce-cli containerd.io # 这里我们使用社区版即可 安装最新版sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io-&lt;VERSION_STRING&gt; # 安装固定版本sudo yum install docker-ce-18.09.1 docker-ce-cli-18.09.1 containerd.io-18.09.1&gt; # 安装固定版本<span class="hljs-meta">#</span><span class="bash"> 5.设置开机启动并启动docker</span>systemctl enable docker &amp;&amp; systemctl start dockery<span class="hljs-meta">#</span><span class="bash"> 6. 使用docker version查看是否按照成功</span>docker version</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195237759.png" alt="image-20210509195237759"></p><div class="code-wrapper"><pre><code class="hljs xml"># 7. 测试docker run hello-world# 8.不要忘记配置阿里云镜像加速</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195535948.png" alt="image-20210509195535948"></p><div class="code-wrapper"><pre><code class="hljs xml">#8.查看已经下载的镜像(从这里可以查看已有镜像的id)docker images</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195629675.png" alt="image-20210509195629675"></p><blockquote><p>  卸载docker</p></blockquote><div class="code-wrapper"><pre><code class="hljs xml">#1. 卸载依赖yum remove docker-ce docker-ce-cli containerd.io#2. 删除资源rm -rf /var/lib/docker# /var/lib/docker 是docker的默认工作路径！</code></pre></div><h3 id="2-3-阿里云镜像加速"><a href="#2-3-阿里云镜像加速" class="headerlink" title="2.3 阿里云镜像加速"></a>2.3 阿里云镜像加速</h3><ol><li><p>登录阿里云找到容器服务</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509212735155.png" alt="image-20210509212735155"></p></li><li><p>找到镜像加速器</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509212755335.png" alt="image-20210509212755335"></p></li><li><p>配置使用</p><div class="code-wrapper"><pre><code class="hljs xml">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://kdx6iqr6.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre></div></li></ol><h3 id="2-4-回顾HelloWorld流程"><a href="#2-4-回顾HelloWorld流程" class="headerlink" title="2.4 回顾HelloWorld流程"></a>2.4 回顾HelloWorld流程</h3><ul><li><p>docker run 流程图</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjYzNzI0Ni5wbmc" alt="image-20200515102637246"></p></li><li><p>底层原理</p><p>Docker<strong>是怎么工作的</strong>？</p><p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</p><p>Docker-Server接收到Docker-Client的指令，就会执行这个命令！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjk0OTU1OC5wbmc" alt="image-20200515102949558"></p></li><li><p>为什么Docker比Vm快</p><p>1、docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>2、docker利用的是宿主机的内核,而不需要Guest OS。</p><div class="code-wrapper"><pre><code class="hljs xml">GuestOS： VM（虚拟机）里的的系统（OS）HostOS：物理机里的系统（OS）</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwNDExNzMyOS5wbmc" alt="image-20200515104117329"></p><p>因此,当新建一个 容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。因而避免引导、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了这个复杂的过程,因此新建一个docker容器只需要几秒钟。</p></li></ul><h2 id="3-Docker-命令"><a href="#3-Docker-命令" class="headerlink" title="3 Docker 命令"></a>3 Docker 命令</h2><h3 id="3-1-帮助命令"><a href="#3-1-帮助命令" class="headerlink" title="3.1 帮助命令"></a>3.1 帮助命令</h3><div class="code-wrapper"><pre><code class="hljs dockerfile">docker version    <span class="hljs-comment">#显示docker的版本信息。</span>docker info       <span class="hljs-comment">#显示docker的系统信息，包括镜像和容器的数量</span>docker 命令 --help <span class="hljs-comment">#帮助命令</span></code></pre></div><p>帮助文档的地址：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p><h3 id="3-2-镜像命令"><a href="#3-2-镜像命令" class="headerlink" title="3.2 镜像命令"></a>3.2 镜像命令</h3><div class="code-wrapper"><pre><code class="hljs dockerfile">docker images <span class="hljs-comment">#查看所有本地主机上的镜像 可以使用docker image ls代替</span>docker search <span class="hljs-comment">#搜索镜像</span>docker pull <span class="hljs-comment">#下载镜像 docker image pull</span>docker rmi <span class="hljs-comment">#删除镜像 docker image rm</span></code></pre></div><ul><li><p>docker images查看所有本地的主机上的镜像</p><div class="code-wrapper"><pre><code class="hljs clean">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker imagesREPOSITORY            TAG                 IMAGE ID            CREATED           SIZEhello-world           latest              bf756fb1ae65        <span class="hljs-number">4</span> months ago     <span class="hljs-number">13.3</span>kBmysql                 <span class="hljs-number">5.7</span>                 b84d68d0a7db        <span class="hljs-number">6</span> days ago       <span class="hljs-number">448</span>MB# 解释#REPOSITORY# 镜像的仓库源#TAG# 镜像的标签(版本)---lastest 表示最新版本#IMAGE ID# 镜像的id#CREATED# 镜像的创建时间#SIZE# 镜像的大小# 可选项Options:  -a, --all         Show all images (default hides intermediate images) #列出所有镜像  -q, --quiet       Only show numeric IDs # 只显示镜像的id  [root@iz2zeak7sgj6i7hrb2g862z ~]# docker images -a  #列出所有镜像详细信息[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images -aq #列出所有镜像的idd5f28a0bb0d0f19c56ce92a8<span class="hljs-number">1</span>b6b1fe7261e<span class="hljs-number">1</span>b6b1fe7261e</code></pre></div></li><li><p>docker search 搜索镜像</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210512223558303.png" alt="image-20210512223558303"></p><div class="code-wrapper"><pre><code class="hljs dockerfile">[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker search mysql</span><span class="hljs-comment"># --filter=STARS=3000 #过滤，搜索出来的镜像收藏STARS数量大于3000的</span>Options:  -f, --filter filter   Filter output based on conditions provided      --format string   Pretty-print search using a Go template      --limit int       Max number of search results (default <span class="hljs-number">25</span>)      --no-trunc        Don<span class="hljs-string">&#x27;t truncate output</span><span class="hljs-string">      </span><span class="hljs-string">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker search mysql --filter=STARS=3000</span><span class="hljs-string">NAME        DESCRIPTION         STARS            OFFICIAL        AUTOMATED</span><span class="hljs-string">mysql       MySQL IS ...        9520             [OK]                </span><span class="hljs-string">mariadb     MariaDB IS ...      3456             [OK]   </span></code></pre></div></li><li><p>docker pull 下载镜像</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 下载镜像 docker pull 镜像名[:tag]</span>[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker pull tomcat:8</span><span class="hljs-number">8</span>: Pulling <span class="hljs-keyword">from</span> library/tomcat <span class="hljs-comment">#如果不写tag，默认就是latest</span><span class="hljs-number">90</span>fe46dd8199: Already exists   <span class="hljs-comment">#分层下载： docker image 的核心 联合文件系统</span><span class="hljs-number">35</span>a4f1977689: Already exists bbc37f14aded: Already exists <span class="hljs-number">74</span>e27dc593d4: Already exists <span class="hljs-number">93</span>a01fbfad7f: Already exists <span class="hljs-number">1478</span>df405869: Pull complete <span class="hljs-number">64</span>f0dd11682b: Pull complete <span class="hljs-number">68</span>ff4e050d11: Pull complete f576086003cf: Pull complete <span class="hljs-number">3</span>b72593ce10e: Pull complete Digest: sha256:<span class="hljs-number">0</span>c6234e7ec9d10ab32c06423ab829b32e3183ba5bf2620ee66de866df <span class="hljs-comment"># 签名防伪</span>Status: Downloaded newer image for tomcat:<span class="hljs-number">8</span>docker.io/library/tomcat:<span class="hljs-number">8</span> <span class="hljs-comment">#真实地址</span><span class="hljs-comment">#等价于</span>docker pull tomcat:<span class="hljs-number">8</span>docker pull docker.io/library/tomcat:<span class="hljs-number">8</span></code></pre></div></li><li><p>docker rmi 删除镜像</p><div class="code-wrapper"><pre><code class="hljs dockerfile">docker rmi -f 镜像id <span class="hljs-comment">#删除指定id的镜像</span>[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker rmi -f f19c56ce92a8</span>docker rmi -f $(docker images -aq) <span class="hljs-comment">#删除全部的镜像</span>[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker stop $(docker ps -a -q)</span></code></pre></div></li></ul><h3 id="3-3-容器命令"><a href="#3-3-容器命令" class="headerlink" title="3.3 容器命令"></a>3.3 容器命令</h3><ul><li><p>镜像下载</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment">#docker中下载centos</span>docker pull centos</code></pre></div><div class="code-wrapper"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> 镜像id <span class="hljs-comment">#新建容器并启动</span></span>docker ps 列出所有运行的容器 docker container listdocker rm 容器id <span class="hljs-comment">#删除指定容器</span>docker start 容器id<span class="hljs-comment">#启动容器</span>docker restart 容器id<span class="hljs-comment">#重启容器</span>docker stop 容器id<span class="hljs-comment">#停止当前正在运行的容器</span>docker kill 容器id<span class="hljs-comment">#强制停止当前容器</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs dockerfile">[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker container list  #h和docker ps相同</span></code></pre></div></li><li><p>新建容器并启动</p><div class="code-wrapper"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> [可选参数] image | docker container run [可选参数] image </span><span class="hljs-comment">#参书说明</span>--name=<span class="hljs-string">&quot;Name&quot;</span><span class="hljs-comment">#容器名字 tomcat01 tomcat02 用来区分容器</span>-d<span class="hljs-comment">#后台方式运行</span>-it <span class="hljs-comment">#使用交互方式运行，进入容器查看内容</span>-p<span class="hljs-comment">#指定容器的端口 -p 8080(宿主机):8080(容器)</span>-p ip:主机端口:容器端口-p 主机端口:容器端口(常用)-p 容器端口容器端口-P(大写) 随机指定端口<span class="hljs-comment"># 测试、启动并进入容器</span>[root@iz2zeak7sgj6i7hrb2g[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker run -it centos /bin/bash</span>[root@<span class="hljs-number">241</span>b5abce65e /]<span class="hljs-comment"># ls</span>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  <span class="hljs-keyword">run</span><span class="bash">  sbin  srv  sys  tmp  usr  var</span>[root@<span class="hljs-number">241</span>b5abce65e /]<span class="hljs-comment"># exit #从容器退回主机</span>exit</code></pre></div></li><li><p>列出所有运行的容器</p><div class="code-wrapper"><pre><code class="hljs dockerfile">docker ps 命令  <span class="hljs-comment">#列出当前正在运行的容器</span>  -a, --all      <span class="hljs-comment">#列出当前正在运行的容器 + 带出历史运行过的容器</span>  -n=?, --last int   <span class="hljs-comment">#列出最近创建的?个容器 ?为1则只列出最近创建的一个容器,为2则列出2个</span>  -q, --quiet        <span class="hljs-comment">#只列出容器的编号</span></code></pre></div></li><li><p>退出容器</p><div class="code-wrapper"><pre><code class="hljs dockerfile">exit <span class="hljs-comment">#容器直接退出</span>ctrl +P +Q  <span class="hljs-comment">#容器不停止退出 ---注意：这个很有用的操作</span></code></pre></div></li><li><p>删除容器</p><div class="code-wrapper"><pre><code class="hljs dockerfile">docker rm 容器id   <span class="hljs-comment">#删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -rf</span>docker rm -f $(docker ps -aq)   <span class="hljs-comment">#删除所有的容器</span>docker ps -a -q|xargs docker rm  <span class="hljs-comment">#删除所有的容器</span></code></pre></div></li><li><p>启动和停止容器的操作</p><div class="code-wrapper"><pre><code class="hljs dockerfile">docker start 容器id<span class="hljs-comment">#启动容器</span>docker restart 容器id<span class="hljs-comment">#重启容器</span>docker stop 容器id<span class="hljs-comment">#停止当前正在运行的容器</span>docker kill 容器id<span class="hljs-comment">#强制停止当前容器</span></code></pre></div></li></ul><h3 id="3-4-常用其他命令"><a href="#3-4-常用其他命令" class="headerlink" title="3.4 常用其他命令"></a>3.4 常用其他命令</h3><ul><li><p><strong>后台启动命令</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令 docker run -d 镜像名</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d centosa8f922c255859622ac45ce3a535b7a0e8253329be4756ed6e32265d2dd2fac6c[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps    CONTAINER ID      IMAGE       COMMAND    CREATED     STATUS   PORTS    NAMES<span class="hljs-meta">#</span><span class="bash"> 问题docker ps. 发现centos 停止了</span><span class="hljs-meta">#</span><span class="bash"> 常见的坑，docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止</span><span class="hljs-meta">#</span><span class="bash"> nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span></code></pre></div></li><li><p><strong>查看日志</strong></p><div class="code-wrapper"><pre><code class="hljs shell">docker logs --helpOptions:      --details        Show extra details provided to logs *  -f, --follow         Follow log output      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)*      --tail string    Number of lines to show from the end of the logs (default &quot;all&quot;)*  -t, --timestamps     Show timestamps      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)➜  ~ docker run -d centos /bin/sh -c &quot;while true;do echo 6666;sleep 1;done&quot; #模拟日志      <span class="hljs-meta">#</span><span class="bash">显示日志</span>-tf#显示日志信息（一直更新）--tail number #需要显示日志条数docker logs -t --tail n 容器id #查看n行日志docker logs -ft 容器id #跟着日志</code></pre></div></li><li><p><strong>查看容器中进程信息ps</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令 docker top 容器id</span></code></pre></div></li><li><p><strong>查看镜像的元数据</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令</span>docker inspect 容器id<span class="hljs-meta">#</span><span class="bash">测试</span>➜  ~ docker inspect 55321bcae33d[    &#123;        &quot;Id&quot;: &quot;55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066&quot;,        &quot;Created&quot;: &quot;2020-05-15T05:22:05.515909071Z&quot;,        &quot;Path&quot;: &quot;/bin/sh&quot;,        &quot;Args&quot;: [            &quot;-c&quot;,            &quot;while true;do echo 6666;sleep 1;done&quot;        ],        &quot;State&quot;: &#123;            &quot;Status&quot;: &quot;running&quot;,            &quot;Running&quot;: true,            &quot;Paused&quot;: false,            &quot;Restarting&quot;: false,            &quot;OOMKilled&quot;: false,            &quot;Dead&quot;: false,            &quot;Pid&quot;: 22973,            &quot;ExitCode&quot;: 0,            &quot;Error&quot;: &quot;&quot;,            &quot;StartedAt&quot;: &quot;2020-05-15T05:22:06.165904633Z&quot;,            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;        &#125;,        &quot;Image&quot;: &quot;sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee&quot;,        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/resolv.conf&quot;,        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/hostname&quot;,        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/hosts&quot;,........</code></pre></div></li><li><p><strong>进入当前正在运行的容器</strong></p><p>我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</p><ul><li><p>docker exec -it 容器id bashshell</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">测试</span>➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES55321bcae33d centos “/bin/sh -c &#x27;while t…” 10 minutes ago Up 10 minutes bold_bella7215824a4db centos “/bin/sh -c &#x27;while t…” 13 minutes ago Up 13 minutes zen_kepler55a31b3f8613 centos “/bin/bash” 15 minutes ago Up 15 minutes lucid_clarke➜ ~ docker exec -it 55321bcae33d /bin/bash[root@55321bcae33d /]#</code></pre></div></li><li><p>方法2</p><div class="code-wrapper"><pre><code class="hljs shell">docker attach 容器id<span class="hljs-meta">#</span><span class="bash">测试</span>docker attach 55321bcae33d 正在执行当前的代码...区别<span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> <span class="hljs-comment">#进入当前容器后开启一个新的终端，可以在里面操作。（常用）</span></span><span class="hljs-meta">#</span><span class="bash">docker attach <span class="hljs-comment"># 进入容器正在执行的终端</span></span></code></pre></div></li></ul></li><li><p><strong>从容器内拷贝到主机上</strong></p><div class="code-wrapper"><pre><code class="hljs shell">docker cp 容器id:容器内路径  主机目的路径[root@iz2zeak7sgj6i7hrb2g862z ~]# docker psCONTAINER ID     IMAGE    COMMAND     CREATED         STATUS       PORTS      NAMES56a5583b25b4     centos   &quot;/bin/bash&quot; 7seconds ago    Up 6 seconds      <span class="hljs-meta">#</span><span class="bash">1. 进入docker容器内部</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 56a5583b25b4 /bin/bash[root@55321bcae33d /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span class="hljs-meta">#</span><span class="bash">新建一个文件</span>[root@55321bcae33d /]# echo &quot;hello&quot; &gt; java.java[root@55321bcae33d /]# cat hello.java hello[root@55321bcae33d /]# exitexit<span class="hljs-meta">#</span><span class="bash">hello.java拷贝到home文件加下</span>[root@iz2zeak7sgj6i7hrb2g862z /]# docker cp 56a5583b25b4:/hello.java /home [root@iz2zeak7sgj6i7hrb2g862z /]# cd /home[root@iz2zeak7sgj6i7hrb2g862z home]# ls -l#可以看见java.java存在total 8-rw-r--r-- 1 root root    0 May 19 22:09 haust.java-rw-r--r-- 1 root root    6 May 22 11:12 java.javadrwx------ 3 www  www  4096 May  8 12:14 www</code></pre></div></li></ul><p>学习方式：将我的所有笔记敲一遍，自己记录笔记！</p><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDIxNDMxMzk2Mi5wbmc" alt="image-20200514214313962"></p><h3 id="3-6-命令大全"><a href="#3-6-命令大全" class="headerlink" title="3.6 命令大全"></a>3.6 <strong>命令大全</strong></h3><div class="code-wrapper"><pre><code class="hljs shell">attach      Attach local standard input, output, and error streams to a running container<span class="hljs-meta">#</span><span class="bash">当前shell下 attach连接指定运行的镜像</span>build       Build an image from a Dockerfile # 通过Dockerfile定制镜像commit      Create a new image from a container&#x27;s changes #提交当前容器为新的镜像cp          Copy files/folders between a container and the local filesystem #拷贝文件create      Create a new container #创建一个新的容器diff        Inspect changes to files or directories on a container&#x27;s filesystem #查看docker容器的变化events      Get real time events from the server # 从服务获取容器实时时间exec        Run a command in a running container # 在运行中的容器上运行命令export      Export a container&#x27;s filesystem as a tar archive #导出容器文件系统作为一个tar归档文件[对应import]history     Show the history of an image # 展示一个镜像形成历史images      List images #列出系统当前的镜像import      Import the contents from a tarball to create a filesystem image #从tar包中导入内容创建一个文件系统镜像info        Display system-wide information # 显示全系统信息inspect     Return low-level information on Docker objects #查看容器详细信息kill        Kill one or more running containers # kill指定docker容器load        Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载一个镜像[对应save]login       Log in to a Docker registry #logout      Log out from a Docker registrylogs        Fetch the logs of a containerpause       Pause all processes within one or more containersport        List port mappings or a specific mapping for the containerps          List containerspull        Pull an image or a repository from a registrypush        Push an image or a repository to a registryrename      Rename a containerrestart     Restart one or more containersrm          Remove one or more containersrmi         Remove one or more imagesrun         Run a command in a new containersave        Save one or more images to a tar archive (streamed to STDOUT by default)search      Search the Docker Hub for imagesstart       Start one or more stopped containersstats       Display a live stream of container(s) resource usage statisticsstop        Stop one or more running containerstag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGEtop         Display the running processes of a containerunpause     Unpause all processes within one or more containersupdate      Update configuration of one or more containersversion     Show the Docker version informationwait        Block until one or more containers stop, then print their exit codes</code></pre></div><h2 id="4-Docker-服务安装"><a href="#4-Docker-服务安装" class="headerlink" title="4 Docker 服务安装"></a>4 Docker 服务安装</h2><h3 id="4-1-安装-Nginx"><a href="#4-1-安装-Nginx" class="headerlink" title="4.1 安装 Nginx"></a>4.1 安装 Nginx</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">1. 搜索镜像 search 建议大家去docker搜索，可以看到帮助文档</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker search nginx<span class="hljs-meta">#</span><span class="bash">2. 拉取下载镜像 pull</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull nginx<span class="hljs-meta">#</span><span class="bash">3. 查看是否下载成功镜像</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images<span class="hljs-meta">#</span><span class="bash">3. 运行测试</span><span class="hljs-meta">#</span><span class="bash"> -d 后台运行</span><span class="hljs-meta">#</span><span class="bash"> --name 给容器命名</span><span class="hljs-meta">#</span><span class="bash"> -p 宿主机端口：容器内部端口</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name nginx01 -p 3344:80 nginxaa664b0c8ed98f532453ce1c599be823bcc1f3c9209e5078615af416ccb454c2<span class="hljs-meta">#</span><span class="bash">4. 查看正在启动的镜像</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES75943663c116        nginx               &quot;nginx -g &#x27;daemon of…&quot;   41 seconds ago      Up 40 seconds       0.0.0.0:82-&gt;80/tcp   nginx00<span class="hljs-meta">#</span><span class="bash">5. 进入容器</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it nginx01 /bin/bash #进入root@aa664b0c8ed9:/# whereis nginx#找到nginx位置nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginxroot@aa664b0c8ed9:/# cd /etc/nginx/root@aa664b0c8ed9:/etc/nginx# lsconf.dfastcgi_paramskoi-utf  koi-win  mime.types  modules  nginx.conf  scgi_paramsuwsgi_params  win-utf<span class="hljs-meta">#</span><span class="bash">6. 退出容器</span>root@aa664b0c8ed9:/etc/nginx# exitexit<span class="hljs-meta">#</span><span class="bash">7. 停止容器</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMESaa664b0c8ed9        nginx               &quot;nginx -g &#x27;daemon of…&quot;   10 minutes ago      Up 10 minutes       0.0.0.0:3344-&gt;80/tcp   nginx01[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop aa664b0c8ed9</code></pre></div><p><strong>宿主机端口</strong> 和 <strong>容器内部端口</strong> 以及端口暴露：</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDIxNTkxNTY1MC5wbmc" alt="img"></p><p><strong>问题：</strong>我们每次改动nginx配置文件，都需要进入容器内部？十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器外部修改文件名，容器内部就可以自动修改？-v 数据卷 技术！</p><h3 id="4-3-安装-Tomcat"><a href="#4-3-安装-Tomcat" class="headerlink" title="4.3 安装 Tomcat"></a>4.3 安装 Tomcat</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载 tomcat9.0</span><span class="hljs-meta">#</span><span class="bash"> 之前的启动都是后台，停止了容器，容器还是可以查到， docker run -it --rm 镜像名 一般是用来测试，用完就删除</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -it --rm tomcat:9.0--rm       Automatically remove the container when it exits 用完即删<span class="hljs-meta">#</span><span class="bash">下载 最新版</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull tomcat<span class="hljs-meta">#</span><span class="bash">查看下载的镜像</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images<span class="hljs-meta">#</span><span class="bash">以后台方式，暴露端口方式，启动运行</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 --name tomcat01 tomcat<span class="hljs-meta">#</span><span class="bash">测试访问有没有问题</span>curl localhost:8080<span class="hljs-meta">#</span><span class="bash">根据容器id进入tomcat容器</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 645596565d3f /bin/bashroot@645596565d3f:/usr/local/tomcat# <span class="hljs-meta">#</span><span class="bash">查看tomcat容器内部内容：</span>root@645596565d3f:/usr/local/tomcat# ls -ltotal 152-rw-r--r-- 1 root root 18982 May  5 20:40 BUILDING.txt-rw-r--r-- 1 root root  5409 May  5 20:40 CONTRIBUTING.md-rw-r--r-- 1 root root 57092 May  5 20:40 LICENSE-rw-r--r-- 1 root root  2333 May  5 20:40 NOTICE-rw-r--r-- 1 root root  3255 May  5 20:40 README.md-rw-r--r-- 1 root root  6898 May  5 20:40 RELEASE-NOTES-rw-r--r-- 1 root root 16262 May  5 20:40 RUNNING.txtdrwxr-xr-x 2 root root  4096 May 16 12:05 bindrwxr-xr-x 1 root root  4096 May 21 11:04 confdrwxr-xr-x 2 root root  4096 May 16 12:05 libdrwxrwxrwx 1 root root  4096 May 21 11:04 logsdrwxr-xr-x 2 root root  4096 May 16 12:05 native-jni-libdrwxrwxrwx 2 root root  4096 May 16 12:05 tempdrwxr-xr-x 2 root root  4096 May 16 12:05 webappsdrwxr-xr-x 7 root root  4096 May  5 20:37 webapps.distdrwxrwxrwx 2 root root  4096 May  5 20:36 workroot@645596565d3f:/usr/local/tomcat# <span class="hljs-meta">#</span><span class="bash">进入webapps目录</span>root@645596565d3f:/usr/local/tomcat# cd webappsroot@645596565d3f:/usr/local/tomcat/webapps# lsroot@645596565d3f:/usr/local/tomcat/webapps# <span class="hljs-meta">#</span><span class="bash"> 发现问题：1、linux命令少了。 2.webapps目录为空</span> <span class="hljs-meta">#</span><span class="bash"> 原因：阿里云镜像的原因，阿里云默认是最小的镜像，所以不必要的都剔除掉</span><span class="hljs-meta">#</span><span class="bash"> 保证最小可运行的环境！</span><span class="hljs-meta">#</span><span class="bash"> 解决方案：</span><span class="hljs-meta">#</span><span class="bash"> 将webapps.dist下的文件都拷贝到webapps下即可</span>root@645596565d3f:/usr/local/tomcat# ls 找到webapps.distBUILDING.txt LICENSE  README.md RUNNING.txt  conf  logs  temp     webapps.distCONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin   lib   native-jni-lib  webapps  workroot@645596565d3f:/usr/local/tomcat# cd webapps.dist/ # 进入webapps.dist root@645596565d3f:/usr/local/tomcat/webapps.dist# ls # 查看内容ROOT  docs  examples  host-manager  managerroot@645596565d3f:/usr/local/tomcat/webapps.dist# cd ..root@645596565d3f:/usr/local/tomcat# cp -r webapps.dist/* webapps # 拷贝webapps.dist 内容给webappsroot@645596565d3f:/usr/local/tomcat# cd webapps #进入webappsroot@645596565d3f:/usr/local/tomcat/webapps# ls #查看拷贝结果ROOT  docs  examples  host-manager  manager</code></pre></div><p>这样docker部署tomcat就可以访问了</p><p><strong>问题</strong>:我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？要是可以在容器外部提供一个映射路径，比如webapps，我们在外部放置项目，就自动同步内部就好了！</p><h3 id="4-3-部署elasticsearch-kibana"><a href="#4-3-部署elasticsearch-kibana" class="headerlink" title="4.3 部署elasticsearch+kibana"></a>4.3 部署elasticsearch+kibana</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> es 暴露的端口很多！</span><span class="hljs-meta">#</span><span class="bash"> es 十分耗内存</span><span class="hljs-meta">#</span><span class="bash"> es 的数据一般需要放置到安全目录！挂载</span><span class="hljs-meta">#</span><span class="bash"> --net somenetwork ? 网络配置</span><span class="hljs-meta">#</span><span class="bash"> 启动elasticsearch</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2<span class="hljs-meta">#</span><span class="bash"> 测试一下es是否成功启动</span>➜  ~ curl localhost:9200&#123;  &quot;name&quot; : &quot;d73ad2f22dd3&quot;,  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,  &quot;cluster_uuid&quot; : &quot;atFKgANxS8CzgIyCB8PGxA&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;7.6.2&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;docker&quot;,    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.4.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;<span class="hljs-meta">#</span><span class="bash">测试成功就关掉elasticSearch，防止耗内存</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop d834ce2bd306d834ce2bd306[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stats  # 查看docker容器使用内存情况<span class="hljs-meta">#</span><span class="bash"> 限制最大内存</span>docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;Xms2m -Xmx512m&quot; elasticsearch:7.6.2</code></pre></div><h3 id="4-4-Portainer-可视化面板安装"><a href="#4-4-Portainer-可视化面板安装" class="headerlink" title="4.4 Portainer 可视化面板安装"></a>4.4 Portainer 可视化面板安装</h3><ul><li><p>portainer(先用这个)</p><div class="code-wrapper"><pre><code class="hljs shell">docker run -d -p 8080:9000 \--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre></div></li><li><p>Rancher(CI/CD再用)<br><strong>什么是portainer？</strong></p><p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装命令</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:9000 \<span class="hljs-meta">&gt;</span><span class="bash"> --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="hljs-literal">true</span> portainer/portainer</span>Unable to find image &#x27;portainer/portainer:latest&#x27; locallylatest: Pulling from portainer/portainerd1e017099d17: Pull complete a7dca5b5a9e8: Pull complete Digest: sha256:4ae7f14330b56ffc8728e63d355bc4bc7381417fa45ba0597e5dd32682901080Status: Downloaded newer image for portainer/portainer:latest81753869c4fd438cec0e31659cbed0d112ad22bbcfcb9605483b126ee8ff306d</code></pre></div><p>测试访问： 外网：8080 ：<a href="http://123.56.247.59:8080/">http://123.56.247.59:8080/</a></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE1NTAwNjA3OS5wbmc" alt></p><p>进入之后的面板</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210526004802841.png" alt></p></li></ul><h2 id="5-Docker-镜像讲解"><a href="#5-Docker-镜像讲解" class="headerlink" title="5 Docker 镜像讲解"></a>5 Docker 镜像讲解</h2><h3 id="5-1-镜像原理之联合文件系统"><a href="#5-1-镜像原理之联合文件系统" class="headerlink" title="5.1  镜像原理之联合文件系统"></a>5.1  镜像原理之联合文件系统</h3><h4 id="5-1-1-镜像是什么"><a href="#5-1-1-镜像是什么" class="headerlink" title="5.1.1 镜像是什么"></a>5.1.1 镜像是什么</h4><ul><li><p>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p></li><li><p>所有应用，直接打包docker镜像，就可以直接跑起来！</p></li></ul><h4 id="5-1-2-如何得到镜像"><a href="#5-1-2-如何得到镜像" class="headerlink" title="5.1.2 如何得到镜像"></a>5.1.2 如何得到镜像</h4><ul><li>从远程仓库下载</li><li>别人拷贝给你</li><li>自己制作一个镜像 DockerFile</li></ul><h3 id="5-2-Docker镜像加载原理"><a href="#5-2-Docker镜像加载原理" class="headerlink" title="5.2 Docker镜像加载原理"></a>5.2 Docker镜像加载原理</h3><blockquote><p>  UnionFs （联合文件系统）</p></blockquote><ul><li>UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像</li><li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</li></ul><blockquote><p>  Docker镜像加载原理</p></blockquote><ul><li>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</li><li>boots(boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。</li><li>rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。</li></ul><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzA0OTk1OS5wbmc" alt></p><ul><li>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</li></ul><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzE0MDU1OS5wbmc" alt></p><ul><li>对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs.</li></ul><ul><li>虚拟机是分钟级别，容器是秒级！</li></ul><h3 id="5-3-分层理解"><a href="#5-3-分层理解" class="headerlink" title="5.3 分层理解"></a>5.3 分层理解</h3><blockquote><p>  分层的镜像</p></blockquote><ul><li><p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzgzOTE4MC5wbmc" alt="img"></p></li></ul><p>思考：为什么Docker镜像要采用这种分层的结构呢？</p><ul><li>最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</li></ul><ul><li><p>查看镜像分层的方式可以通过docker image inspect 命令。</p><div class="code-wrapper"><pre><code class="hljs shell">➜  / docker image inspect redis          [    &#123;        &quot;Id&quot;: &quot;sha256:f9b9909726890b00d2098081642edf32e5211b7ab53563929a47f250bcdc1d7c&quot;,        &quot;RepoTags&quot;: [            &quot;redis:latest&quot;        ],        &quot;RepoDigests&quot;: [            &quot;redis@sha256:399a9b17b8522e24fbe2fd3b42474d4bb668d3994153c4b5d38c3dafd5903e32&quot;        ],        &quot;Parent&quot;: &quot;&quot;,        &quot;Comment&quot;: &quot;&quot;,        &quot;Created&quot;: &quot;2020-05-02T01:40:19.112130797Z&quot;,        &quot;Container&quot;: &quot;d30c0bcea88561bc5139821227d2199bb027eeba9083f90c701891b4affce3bc&quot;,        &quot;ContainerConfig&quot;: &#123;            &quot;Hostname&quot;: &quot;d30c0bcea885&quot;,            &quot;Domainname&quot;: &quot;&quot;,            &quot;User&quot;: &quot;&quot;,            &quot;AttachStdin&quot;: false,            &quot;AttachStdout&quot;: false,            &quot;AttachStderr&quot;: false,            &quot;ExposedPorts&quot;: &#123;                &quot;6379/tcp&quot;: &#123;&#125;            &#125;,            &quot;Tty&quot;: false,            &quot;OpenStdin&quot;: false,            &quot;StdinOnce&quot;: false,            &quot;Env&quot;: [                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,                &quot;GOSU_VERSION=1.12&quot;,                &quot;REDIS_VERSION=6.0.1&quot;,                ] .......</code></pre></div></li><li><p><strong>理解：</strong></p><ul><li><p>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p></li><li><p>举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，<br>就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含3个镜像层，如下图所示</p></li><li><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合.</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTIzNDI3NC5wbmc" alt></p></li><li><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NDk1ODkzMi5wbmc" alt></p></li><li><p>上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件</p></li><li><p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTE0ODAwMi5wbmc" alt></p></li><li><p>在这种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中</p></li><li><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统</p></li><li><p>Linux上可用的存储引擎有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的<br>件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。</p></li><li><p>Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW 。</p></li><li><p>下图展示了与系统显示相同的三层镜像。所有镜像层堆并合井，对外提供统一的视图。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTU1NzgwNy5wbmc" alt></p></li></ul></li></ul><blockquote><p>  特点</p></blockquote><ul><li><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！</p></li><li><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MTUwNTg5Ny5wbmc" alt></p></li></ul><blockquote><p>  commit镜像</p></blockquote><div class="code-wrapper"><pre><code class="hljs routeros">docker commit 提交容器成为一个新的副本<span class="hljs-comment"># 命令和git原理类似</span>docker commit <span class="hljs-attribute">-m</span>=<span class="hljs-string">&quot;描述信息&quot;</span> <span class="hljs-attribute">-a</span>=<span class="hljs-string">&quot;作者&quot;</span> 容器id 目标镜像名:[版本TAG]</code></pre></div><p>实战测试</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、启动一个默认的tomcat</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 tomcatde57d0ace5716d27d0e3a7341503d07ed4695ffc266aef78e0a855b270c4064e<span class="hljs-meta">#</span><span class="bash"> 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！</span><span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> -it 容器id /bin/bash</span>[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it de57d0ace571 /bin/bashroot@de57d0ace571:/usr/local/tomcat# <span class="hljs-meta">#</span><span class="bash"> 3、从webapps.dist拷贝文件进去webapp</span>root@de57d0ace571:/usr/local/tomcat# cp -r webapps.dist/* webappsroot@de57d0ace571:/usr/local/tomcat# cd webappsroot@de57d0ace571:/usr/local/tomcat/webapps# lsROOT  docs  examples  host-manager  manager<span class="hljs-meta">#</span><span class="bash"> 4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，而不需要每次都重新拷贝webapps.dist下的文件到webapps了，这就是我们自己的一个修改的镜像。</span>docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]docker commit -a=&quot;pncalbl&quot; -m=&quot;add webapps app&quot; 6c5381bbe865 tomcat02:1.0[root@iz2zeak7sgj6i7hrb2g862z ~]# docker commit -a=&quot;csp提交的&quot; -m=&quot;add webapps app&quot; de57d0ace571 tomcat02.1.0sha256:d5f28a0bb0d0b6522fdcb56f100d11298377b2b7c51b9a9e621379b01cf1487e[root@iz2zeak7sgj6i7hrb2g862z ~]# docker imagesREPOSITORY            TAG                 IMAGE ID            CREATED             SIZEtomcat02.1.0          latest              d5f28a0bb0d0        14 seconds ago      652MBtomcat                latest              1b6b1fe7261e        5 days ago          647MBnginx                 latest              9beeba249f3e        5 days ago          127MBmysql                 5.7                 b84d68d0a7db        5 days ago          448MBelasticsearch         7.6.2               f29a1ee41030        8 weeks ago         791MBportainer/portainer   latest              2869fc110bf7        2 months ago        78.6MBcentos                latest              470671670cac        4 months ago        237MBhello-world           latest              bf756fb1ae65        4 months ago        13.3kB</code></pre></div><h2 id="5-容器数据卷"><a href="#5-容器数据卷" class="headerlink" title="5 容器数据卷"></a>5 容器数据卷</h2><h3 id="5-1-什么是容器数据卷"><a href="#5-1-什么是容器数据卷" class="headerlink" title="5.1 什么是容器数据卷"></a>5.1 什么是容器数据卷</h3><p>将应用和环境打包成一个镜像！</p><p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p><p>MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！</p><p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p><p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEwNTI1ODQ1Ni5wbmc" alt></p><p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p><h3 id="5-2-使用数据卷"><a href="#5-2-使用数据卷" class="headerlink" title="5.2 使用数据卷"></a>5.2 使用数据卷</h3><blockquote><p>  方式一 ：直接使用命令挂载 -v</p></blockquote><div class="code-wrapper"><pre><code class="hljs shell">-v, --volume list                    Bind mount a volumedocker run -it -v 主机目录:容器内目录  -p 主机端口:容器内端口<span class="hljs-meta">#</span><span class="bash"> /home/ceshi：主机home目录下的ceshi文件夹  映射：centos容器中的/home</span>[root@iz2zeak7 home]# docker run -it -v /home/ceshi:/home centos /bin/bash<span class="hljs-meta">#</span><span class="bash">这时候主机的/home/ceshi文件夹就和容器的/home文件夹关联了,二者可以实现文件或数据同步了</span><span class="hljs-meta">#</span><span class="bash">通过 docker inspect 容器id 查看</span>[root@iz2zeak7sgj6i7hrb2g862z home]# docker inspect 6064c490c371</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601210704586.png" alt></p><p>测试文件的同步</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601210829068.png" alt="image-20210601210829068"></p><p>再来测试！</p><p>1、停止容器</p><p>2、宿主机修改文件</p><p>3、启动容器</p><p>4、容器内的数据依旧是同步的</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMDg1MDQzMS5wbmc" alt></p><p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p><h3 id="5-3-实战：安装MySQL"><a href="#5-3-实战：安装MySQL" class="headerlink" title="5.3 实战：安装MySQL"></a>5.3 实战：安装MySQL</h3><p><strong>思考：MySQL的数据持久化的问题</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 获取mysql镜像</span>[root@iz2zeak7sgj6i7hrb2g862z home]# docker pull mysql:5.7<span class="hljs-meta">#</span><span class="bash"> 运行容器,需要做数据挂载 <span class="hljs-comment">#安装启动mysql，需要配置密码的，这是要注意点！</span></span><span class="hljs-meta">#</span><span class="bash"> 参考官网hub</span> docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag<span class="hljs-meta">#</span><span class="bash">启动我们得</span>-d 后台运行-p 端口映射-v 卷挂载-e 环境配置-- name 容器名字docker run -p 3306:3306 --name docker-mysql-v /usr/local/workspace/docker/mysql/conf:/etc/mysql-v /usr/local/workspace/docker/mysql/data:/var/lib/mysql-e MYSQL_ROOT_PASSWORD=12345678 -d mysql:5.6<span class="hljs-meta">#</span><span class="bash"> 启动成功之后，我们在本地使用sqlyog来测试一下</span><span class="hljs-meta">#</span><span class="bash"> sqlyog-连接到服务器的3306--和容器内的3306映射</span> <span class="hljs-meta">#</span><span class="bash"> 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！</span></code></pre></div><p><strong>测试连接</strong>：注意3310端口要在阿里云服务器的安全组中打开，否则无法连接。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601212226538.png" alt></p><p>当我们在本地用Navicat新建名称为test的数据库时候，容器容器也会创建</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601212456348.png" alt="image-20210601212456348"></p><p>假设我们将包含mysql的容器删除时，</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMjUzMjk1MC5wbmc" alt></p><p>发现，<strong>我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能</strong>。</p><h3 id="5-4-具名和匿名挂载"><a href="#5-4-具名和匿名挂载" class="headerlink" title="5.4 具名和匿名挂载"></a>5.4 具名和匿名挂载</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 匿名挂载</span>-v 容器内路径!<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx01 -v /etc/nginx nginx</span><span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span><span class="hljs-meta">$</span><span class="bash"> docker volume ls</span>    DRIVER              VOLUME NAME # 容器内的卷名(匿名卷挂载)local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c         <span class="hljs-meta">#</span><span class="bash"> 这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路径！</span><span class="hljs-meta">#</span><span class="bash"> 具名挂载 -P:表示随机映射端口</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span>9663cfcb1e5a9a1548867481bfddab9fd7824a6dc4c778bf438a040fe891f0ee<span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span><span class="hljs-meta">$</span><span class="bash"> docker volume ls</span>                  DRIVER              VOLUME NAMElocal               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802clocal               juming-nginx #多了一个名字<span class="hljs-meta">#</span><span class="bash"> 通过 -v 卷名：查看容器内路径</span><span class="hljs-meta">#</span><span class="bash"> 查看一下这个卷</span><span class="hljs-meta">$</span><span class="bash"> docker volume inspect juming-nginx</span>[    &#123;        &quot;CreatedAt&quot;: &quot;2020-05-23T13:55:34+08:00&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: null,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;, #默认目录        &quot;Name&quot;: &quot;juming-nginx&quot;,        &quot;Options&quot;: null,        &quot;Scope&quot;: &quot;local&quot;    &#125;]</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMzU0NTc0Ni5wbmc" alt></p><p>所有的docker容器内的卷，没有指定目录的情况下都是在<strong>/var/lib/docker/volumes/自定义的卷名/_data</strong>下，<strong>如果指定了目录，docker volume ls 是查看不到的</strong>。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExNDIzMTQzNS5wbmc" alt></p><p><strong>区分三种挂载方式</strong></p><div class="code-wrapper"><pre><code class="hljs haml"># 三种挂载： 匿名挂载、具名挂载、指定路径挂载-<span class="ruby">v 容器内路径<span class="hljs-comment">#匿名挂载</span></span><span class="ruby">-v 卷名：容器内路径  <span class="hljs-comment">#具名挂载</span></span><span class="ruby">-v /宿主机路径：容器内路径 <span class="hljs-comment">#指定路径挂载 docker volume ls 是查看不到的</span></span></code></pre></div><p>拓展：</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过 -v 容器内路径： ro rw 改变读写权限</span>ro #readonly 只读rw #readwrite 可读可写<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span><span class="hljs-meta">#</span><span class="bash"> ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</span></code></pre></div><h2 id="6-DockerFile"><a href="#6-DockerFile" class="headerlink" title="6 DockerFile"></a>6 DockerFile</h2><h3 id="6-1-初始Dockerfile"><a href="#6-1-初始Dockerfile" class="headerlink" title="6.1 初始Dockerfile"></a>6.1 初始Dockerfile</h3><p><strong>Dockerfile 就是用来构建docker镜像的构建文件</strong>！命令脚本！先体验一下！</p><p>通过这个<strong>脚本可以生成镜像</strong>，镜像是一层一层的，脚本是一个个的命令，每个命令都是一层！</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建一个dockerfile文件，名字可以随便 建议Dockerfile</span><span class="hljs-meta">#</span><span class="bash"> 文件中的内容： 指令(大写) + 参数</span><span class="hljs-meta">$</span><span class="bash"> vim dockerfile1</span>    FROM centos # 当前这个镜像是以centos为基础的    VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] # 挂载卷的卷目录列表(多个目录)    CMD echo &quot;-----end-----&quot;# 输出一下用于测试    CMD /bin/bash# 默认走bash控制台<span class="hljs-meta">#</span><span class="bash"> 这里的每个命令，就是镜像的一层！</span><span class="hljs-meta">#</span><span class="bash"> 构建出这个镜像</span> -f dockerfile1 # f代表file，指这个当前文件的地址(这里是当前目录下的dockerfile1)-t caoshipeng/centos # t就代表target，指目标目录(注意caoshipeng镜像名前不能加斜杠‘/’). # 表示生成在当前目录下<span class="hljs-meta">$</span><span class="bash"> docker build -f dockerfile1 -t caoshipeng/centos .</span>Sending build context to Docker daemon   2.56kBStep 1/4 : FROM centoslatest: Pulling from library/centos8a29a15cefae: Already exists Digest: sha256:fe8d824220415eed5477b63addf40fb06c3b049404242b31982106ac204f6700Status: Downloaded newer image for centos:latest<span class="hljs-meta"> ---&gt;</span><span class="bash"> 470671670cac</span>Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] # 卷名列表<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> c18eefc2c233</span>Removing intermediate container c18eefc2c233<span class="hljs-meta"> ---&gt;</span><span class="bash"> 623ae1d40fb8</span>Step 3/4 : CMD echo &quot;-----end-----&quot;# 输出 脚本命令<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 70e403669f3c</span>Removing intermediate container 70e403669f3c<span class="hljs-meta"> ---&gt;</span><span class="bash"> 0eba1989c4e6</span>Step 4/4 : CMD /bin/bash<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 4342feb3a05b</span>Removing intermediate container 4342feb3a05b<span class="hljs-meta"> ---&gt;</span><span class="bash"> f4a6b0d4d948</span>Successfully built f4a6b0d4d948Successfully tagged caoshipeng/centos:latest<span class="hljs-meta">#</span><span class="bash"> 查看自己构建的镜像</span><span class="hljs-meta">$</span><span class="bash"> docker images</span>REPOSITORY          TAG          IMAGE ID            CREATED              SIZEcaoshipeng/centos   latest       f4a6b0d4d948        About a minute ago   237MB</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203148651.png" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203222615.png" alt></p><p><strong>启动自己写的容器镜像</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -it f4a6b0d4d948 /bin/bash<span class="hljs-comment"># 运行自己写的镜像</span></span><span class="hljs-meta">$</span><span class="bash"> ls -l <span class="hljs-comment"># 查看目录</span></span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTQ1OTAyNi5wbmc" alt></p><p>这个卷和外部一定有一个同步的目录</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTUzMTYyNi5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker inspect 容器id</span><span class="hljs-meta">$</span><span class="bash"> docker inspect ca3b45913df5</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTYzMDI5NS5wbmc" alt></p><p>测试一下刚才的文件是否同步出去了！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203814945.png" alt></p><p>这种方式使用的十分多，因为我们通常会构建自己的镜像！</p><p>假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名：容器内路径！</p><h3 id="6-2-数据卷容器"><a href="#6-2-数据卷容器" class="headerlink" title="6.2 数据卷容器"></a>6.2 数据卷容器</h3><h4 id="1-多个MySQL同步数据"><a href="#1-多个MySQL同步数据" class="headerlink" title="1 多个MySQL同步数据"></a>1 多个MySQL同步数据</h4><p>命名的容器挂载数据卷！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154518325.png" alt></p><div class="code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># 测试 启动3个容器，通过刚才自己写的镜像启动</span><span class="hljs-comment"># 创建docker01：因为我本机是最新版，故这里用latest，狂神老师用的是1.0如下图</span>$ docker run -it --name docker01 pnca/centos:latest<span class="hljs-comment"># 查看容器docekr01内容</span>$ lsbin  home   lost+foundopt   run   sys  vardev  lib    media<span class="hljs-keyword">proc</span><span class="hljs-title">  sbin</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> volume01</span><span class="hljs-title">etc</span> <span class="hljs-title"> lib64</span> <span class="hljs-title"> mnt</span><span class="hljs-title">root</span> <span class="hljs-title"> srv</span> <span class="hljs-title">  usr</span> <span class="hljs-title"> volume02</span><span class="hljs-title"></span><span class="hljs-title">#</span> 不关闭该容器退出CTRL +<span class="hljs-title"> Q</span> +<span class="hljs-title"> P</span>  # 创建docker02: 并且让docker02 继承<span class="hljs-title"> docker01</span><span class="hljs-title">$</span> docker<span class="hljs-title"> run</span> -it --name<span class="hljs-title"> docker02</span> --volumes-from<span class="hljs-title"> docker01</span> pnca/centos:latest# 查看容器docker02内容$<span class="hljs-title"> ls</span><span class="hljs-title">bin</span> <span class="hljs-title"> home</span> <span class="hljs-title">  lost+found</span>opt<span class="hljs-title">   run</span> <span class="hljs-title">  sys</span> <span class="hljs-title"> var</span><span class="hljs-title">dev</span> <span class="hljs-title"> lib</span> <span class="hljs-title">   media</span><span class="hljs-keyword">proc</span><span class="hljs-title">  sbin</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> volume01</span><span class="hljs-title">etc</span> <span class="hljs-title"> lib64</span> <span class="hljs-title"> mnt</span><span class="hljs-title">root</span> <span class="hljs-title"> srv</span> <span class="hljs-title">  usr</span> <span class="hljs-title"> volume02</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMzAyMDA1MC5wbmc" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154539606.png" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 再新建一个docker03同样继承docker01</span><span class="hljs-meta">$</span><span class="bash"> docker run -it --name docker03 --volumes-from docker01 caoshipeng/centos:latest</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> volume01<span class="hljs-comment">#进入volume01 查看是否也同步docker01的数据</span></span><span class="hljs-meta">$</span><span class="bash"> ls</span> docker01.txt<span class="hljs-meta">#</span><span class="bash"> 测试：可以删除docker01，查看一下docker02和docker03是否可以访问这个文件</span><span class="hljs-meta">#</span><span class="bash"> 测试发现：数据依旧保留在docker02和docker03中没有被删除</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMzM1NTAzNC5wbmc" alt></p><h4 id="2-多个mysql实现数据共享"><a href="#2-多个mysql实现数据共享" class="headerlink" title="2 多个mysql实现数据共享"></a>2 多个mysql实现数据共享</h4><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01  mysql:5.7</span><span class="hljs-meta">#</span><span class="bash"> 这个时候，可以实现两个容器数据同步！</span></code></pre></div><p>结论：</p><p><strong>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止</strong>。</p><p><strong>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的</strong>！</p><h3 id="6-3-DockerFile-具体使用"><a href="#6-3-DockerFile-具体使用" class="headerlink" title="6.3 DockerFile 具体使用"></a>6.3 DockerFile 具体使用</h3><h4 id="1-DockerFile介绍"><a href="#1-DockerFile介绍" class="headerlink" title="1 DockerFile介绍"></a>1 DockerFile介绍</h4><p>dockerfile是用来构建docker镜像的文件！命令参数脚本！</p><p>构建步骤：</p><ol><li>编写一个dockerfile文件</li><li>docker build 构建称为一个镜像</li><li>docker run运行镜像</li><li>docker push发布镜像（DockerHub 、阿里云仓库)</li></ol><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205738956.png" alt></p><p>点击后跳到一个Dockerfile</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205655544.png" alt></p><p>很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！</p><p>官方既然可以制作镜像，那我们也可以！</p><h4 id="2-DockerFile-构建过程"><a href="#2-DockerFile-构建过程" class="headerlink" title="2 DockerFile 构建过程"></a>2 DockerFile 构建过程</h4><p><strong>基础知识</strong>：</p><ol><li>每个保留关键字(指令）都是必须是大写字母</li><li>执行从上到下顺序</li><li>#表示注释</li><li>每一个指令都会创建提交一个新的镜像层，并提交！</li></ol><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEzMTc1Njk5Ny5wbmc" alt></p><ul><li>Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</li></ul><ul><li>Docker镜像逐渐成企业交付的标准，必须要掌握！</li></ul><ul><li>DockerFile：构建文件，定义了一切的步骤，源代码</li></ul><ul><li>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。</li></ul><ul><li>Docker容器：容器就是镜像运行起来提供服务。</li></ul><h4 id="3-DockerFile的指令"><a href="#3-DockerFile的指令" class="headerlink" title="3 DockerFile的指令"></a>3 DockerFile的指令</h4><div class="code-wrapper"><pre><code class="hljs shell">FROM# from:基础镜像，一切从这里开始构建MAINTAINER# maintainer:镜像是谁写的， 姓名+邮箱RUN# run:镜像构建的时候需要运行的命令ADD# add:步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录WORKDIR# workdir:镜像的工作目录VOLUME# volume:挂载的目录EXPOSE# expose:保留端口配置CMD# cmd:指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代ENTRYPOINT# entrypoint:指定这个容器启动的时候要运行的命令，可以追加命令ONBUILD# onbuild:当构建一个被继承DockerFile这个时候就会运行onbuild的指令，触发指令COPY# copy:类似ADD，将我们文件拷贝到镜像中ENV# env:构建的时候设置环境变量！</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154609624.png" alt></p><h4 id="4-实战测试"><a href="#4-实战测试" class="headerlink" title="4 实战测试"></a>4 实战测试</h4><p>scratch镜像</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> scratch<span class="hljs-keyword">ADD</span><span class="bash"> centos-7-x86_64-docker.tar.xz /</span><span class="hljs-keyword">LABEL</span><span class="bash"> \</span><span class="bash">    org.label-schema.schema-version=<span class="hljs-string">&quot;1.0&quot;</span> \</span><span class="bash">    org.label-schema.name=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \</span><span class="bash">    org.label-schema.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \</span><span class="bash">    org.label-schema.license=<span class="hljs-string">&quot;GPLv2&quot;</span> \</span><span class="bash">    org.label-schema.build-date=<span class="hljs-string">&quot;20201113&quot;</span> \</span><span class="bash">    org.opencontainers.image.title=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \</span><span class="bash">    org.opencontainers.image.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \</span><span class="bash">    org.opencontainers.image.licenses=<span class="hljs-string">&quot;GPL-2.0-only&quot;</span> \</span><span class="bash">    org.opencontainers.image.created=<span class="hljs-string">&quot;2020-11-13 00:00:00+00:00&quot;</span></span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>]</span></code></pre></div><p><strong>Docker Hub 中 99%的镜像都是从这个基础镜像过来的 FROM scratch</strong>，然后配置需要的软件和配置来进行构建。</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205655544.png" alt></p><p>创建一个自己的centos</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1./home下新建dockerfile目录</span><span class="hljs-meta">$</span><span class="bash"> mkdir dockerfile</span><span class="hljs-meta">#</span><span class="bash"> 2. dockerfile目录下新建mydockerfile-centos文件</span><span class="hljs-meta">$</span><span class="bash"> vim mydockerfile-centos</span><span class="hljs-meta">#</span><span class="bash"> 3.编写Dockerfile配置文件</span>FROM centos# 基础镜像是官方原生的centosMAINTAINER pncalbl&lt;pncalbl@qq.com&gt; # 作者ENV MYPATH /usr/local# 配置环境变量的目录 WORKDIR $MYPATH# 将工作目录设置为 MYPATHRUN yum -y install vim# 给官方原生的centos 增加 vim指令RUN yum -y install net-tools# 给官方原生的centos 增加 ifconfig命令EXPOSE 80# 暴露端口号为80CMD echo $MYPATH# 输出下 MYPATH 路径CMD echo &quot;-----end----&quot;CMD /bin/bash# 启动后进入 /bin/bash<span class="hljs-meta">#</span><span class="bash"> 4.通过这个文件构建镜像</span><span class="hljs-meta">#</span><span class="bash"> 命令： docker build -f 文件路径 -t 镜像名:[tag] .</span><span class="hljs-meta">$</span><span class="bash"> docker build -f mydockerfile-centos -t mycentos:0.1 .</span><span class="hljs-meta">#</span><span class="bash"> 5.出现下图后则构建成功</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MDgzMTQ2NC5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker images</span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEmycentos            0.1                 cbf5110a646d        2 minutes ago       311MB<span class="hljs-meta">#</span><span class="bash"> 6.测试运行</span><span class="hljs-meta">$</span><span class="bash"> docker run -it mycentos:0.1 <span class="hljs-comment"># 注意带上版本号，否则每次都回去找最新版latest</span></span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">pwd</span></span>/usr/local# 与Dockerfile文件中 WORKDIR 设置的 MYPATH 一致<span class="hljs-meta">$</span><span class="bash"> vim<span class="hljs-comment"># vim 指令可以使用</span></span><span class="hljs-meta">$</span><span class="bash"> ifconfig     <span class="hljs-comment"># ifconfig 指令可以使用</span></span><span class="hljs-meta">#</span><span class="bash"> docker <span class="hljs-built_in">history</span> 镜像id 查看镜像构建历史步骤</span><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">history</span> 镜像id</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MTYyOTU4My5wbmc" alt></p><p>我们可以列出本地进行的变更历史</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MTg0MDcwNi5wbmc" alt></p><p>我们平时拿到一个镜像，可以用 “docker history 镜像id” 研究一下是什么做的</p><h4 id="5-CMD-和-ENTRYPOINT区别"><a href="#5-CMD-和-ENTRYPOINT区别" class="headerlink" title="5 CMD 和 ENTRYPOINT区别"></a>5 CMD 和 ENTRYPOINT区别</h4><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="bash"><span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span></span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"><span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，可以追加命令</span></span></code></pre></div><p><strong>测试cmd</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编写dockerfile文件</span><span class="hljs-meta">$</span><span class="bash"> vim dockerfile-test-cmd</span>FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]# 启动后执行 ls -a 命令<span class="hljs-meta">#</span><span class="bash"> 构建镜像</span><span class="hljs-meta">$</span><span class="bash"> docker build  -f dockerfile-test-cmd -t cmd-test:0.1 .</span><span class="hljs-meta">#</span><span class="bash"> 运行镜像</span><span class="hljs-meta">$</span><span class="bash"> docker run cmd-test:0.1<span class="hljs-comment"># 由结果可得，运行后就执行了 ls -a 命令</span></span>....dockerenvbindevetchome<span class="hljs-meta">#</span><span class="bash"> 想追加一个命令  -l 成为ls -dockersal：展示列表详细数据</span><span class="hljs-meta">$</span><span class="bash"> docker run cmd-tesclet:0.1 -l</span>docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused &quot;exec: \&quot;-l\&quot;:executable file not found in $PATH&quot;: unknown.ERRO[0000] error waiting for container: context canceled <span class="hljs-meta">#</span><span class="bash"> cmd的情况下 -l 替换了CMD[<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-l&quot;</span>] 而 -l  不是命令所以报错</span></code></pre></div><p><strong>测试ENTRYPOINT</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编写dockerfile文件</span><span class="hljs-meta">$</span><span class="bash"> vim dockerfile-test-entrypoint</span>FROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]<span class="hljs-meta">#</span><span class="bash"> 构建镜像</span><span class="hljs-meta">$</span><span class="bash"> docker build  -f dockerfile-test-entrypoint -t entrypoint-test:0.1 .</span><span class="hljs-meta">#</span><span class="bash"> 运行镜像</span><span class="hljs-meta">$</span><span class="bash"> docker run entrypoint-test:0.1</span>....dockerenvbindevetchomeliblib64lost+found ...<span class="hljs-meta">#</span><span class="bash"> 我们的命令，是直接拼接在我们得ENTRYPOINT命令后面的</span><span class="hljs-meta">$</span><span class="bash"> docker run entrypoint-test:0.1 -l</span>total 56cleadrwxr-xr-x   1 root root 4096 May 16 06:32 .drwxr-xr-x   1 root root 4096 May 16 06:32 ..-rwxr-xr-x   1 root root    0 May 16 06:32 .dockerenvlrwxrwxrwx   1 root root    7 May 11  2019 bin -&gt; usr/bindrwxr-xr-x   5 root root  340 May 16 06:32 devdrwxr-xr-x   1 root root 4096 May 16 06:32 etcdrwxr-xr-x   2 root root 4096 May 11  2019 homelrwxrwxrwx   1 root root    7 May 11  2019 lib -&gt; usr/liblrwxrwxrwx   1 root root    9 May 11  2019 lib64 -&gt; usr/lib64 ....</code></pre></div><p>Dockerfile中很多命令都十分的相似，我们需要了解它们的区别，我们最好的学习就是对比他们然后测试效果！</p><h4 id="6-实战：Tomcat镜像"><a href="#6-实战：Tomcat镜像" class="headerlink" title="6 实战：Tomcat镜像"></a>6 实战：Tomcat镜像</h4><h5 id="6-1-准备镜像文件"><a href="#6-1-准备镜像文件" class="headerlink" title="6.1 准备镜像文件"></a>6.1 准备镜像文件</h5><div class="code-wrapper"><pre><code class="hljs mipsasm">准备tomcat 和 <span class="hljs-keyword">jdk </span>到当前目录，编写好README</code></pre></div><h5 id="6-2-编写-dokerfile"><a href="#6-2-编写-dokerfile" class="headerlink" title="6.2 编写 dokerfile"></a>6.2 编写 dokerfile</h5><div class="code-wrapper"><pre><code class="hljs dockerfile">$ vim dockerfile<span class="hljs-keyword">FROM</span> centos <span class="hljs-comment"># 基础镜像centos</span><span class="hljs-keyword">MAINTAINER</span> pncalbl&lt;pncalbl@qq.com&gt;<span class="hljs-comment"># 作者</span><span class="hljs-keyword">COPY</span><span class="bash"> README /usr/<span class="hljs-built_in">local</span>/README <span class="hljs-comment"># 复制README文件</span></span><span class="hljs-keyword">ADD</span><span class="bash"> jdk-8u231-linux-x64.tar.gz /usr/<span class="hljs-built_in">local</span>/ <span class="hljs-comment"># 添加jdk，ADD 命令会自动解压</span></span><span class="hljs-keyword">ADD</span><span class="bash"> apache-tomcat-9.0.35.tar.gz /usr/<span class="hljs-built_in">local</span>/ <span class="hljs-comment"># 添加tomcat，ADD 命令会自动解压</span></span><span class="hljs-keyword">RUN</span><span class="bash"> yum -y install vim<span class="hljs-comment"># 安装 vim 命令</span></span><span class="hljs-keyword">ENV</span> MYPATH /usr/local <span class="hljs-comment"># 环境变量设置 工作目录</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> <span class="hljs-variable">$MYPATH</span></span><span class="hljs-keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="hljs-number">8.0</span>_231 <span class="hljs-comment"># 环境变量： JAVA_HOME环境变量</span><span class="hljs-keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<span class="hljs-keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">35</span> <span class="hljs-comment"># 环境变量： tomcat环境变量</span><span class="hljs-keyword">ENV</span> CATALINA_BASH /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">35</span><span class="hljs-comment"># 设置环境变量 分隔符是：</span><span class="hljs-keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin <span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 设置暴露的端口</span><span class="hljs-keyword">CMD</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/<span class="hljs-built_in">local</span>/apache-tomcat-9.0.35/logs/catalina.out <span class="hljs-comment"># 设置默认命令</span></span></code></pre></div><h5 id="6-3-构建镜像"><a href="#6-3-构建镜像" class="headerlink" title="6.3 构建镜像"></a>6.3 构建镜像</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 因为dockerfile命名使用默认命名 因此不用使用-f 指定文件</span><span class="hljs-meta">$</span><span class="bash"> docker build -t mytomcat:0.1 .</span></code></pre></div><h5 id="6-4-run镜像"><a href="#6-4-run镜像" class="headerlink" title="6.4 run镜像"></a>6.4 run镜像</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> -d:后台运行 -p:暴露端口 --name:别名 -v:绑定路径</span> <span class="hljs-meta">$</span><span class="bash"> docker run -d -p 8080:8080 --name tomcat01</span> -v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test -v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.35/logs</code></pre></div><h5 id="6-5-访问测试"><a href="#6-5-访问测试" class="headerlink" title="6.5 访问测试"></a>6.5 访问测试</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it 自定义容器的id /bin/bash</span><span class="hljs-meta">$</span><span class="bash"> cul localhost:8080</span></code></pre></div><h5 id="6-6-发布项目"><a href="#6-6-发布项目" class="headerlink" title="6.6 发布项目"></a>6.6 发布项目</h5><p>(由于做了卷挂载，我们直接在本地编写项目就可以发布了！)</p><p>发现：项目部署成功，可以直接访问！</p><p>我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！</p><h4 id="7-发布自己的镜像"><a href="#7-发布自己的镜像" class="headerlink" title="7 发布自己的镜像"></a>7 发布自己的镜像</h4><p><strong>发布到 Docker Hub</strong></p><ol><li><p>地址 <a href="https://hub.docker.com/">https://hub.docker.com/</a></p></li><li><p>确定这个账号可以登录</p></li><li><p>登录</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker login --<span class="hljs-built_in">help</span></span>Usage:  docker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options:  -p, --password string   Password      --password-stdin    Take the password from stdin  -u, --username string   Username<span class="hljs-meta">$</span><span class="bash"> docker login -u 你的用户名 -p 你的密码</span></code></pre></div></li><li><p>提交 push镜像</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE2NDQzNDA0Mi5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 会发现push不上去，因为如果没有前缀的话默认是push到 官方的library</span><span class="hljs-meta">#</span><span class="bash"> 解决方法：</span><span class="hljs-meta">#</span><span class="bash"> 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了</span><span class="hljs-meta">$</span><span class="bash"> docker build -t kuangshen/mytomcat:0.1 .</span><span class="hljs-meta">#</span><span class="bash"> 第二种 使用docker tag <span class="hljs-comment">#然后再次push</span></span><span class="hljs-meta">$</span><span class="bash"> docker tag jid kuangshen/mytomcat:1.0 <span class="hljs-comment">#然后再次push</span></span><span class="hljs-meta">$</span><span class="bash"> docker push kuangshen/mytomcat:1.0</span></code></pre></div><p><strong>发布到 阿里云镜像服务上</strong></p><p>看官网 很详细<a href="https://cr.console.aliyun.com/repository/">https://cr.console.aliyun.com/repository/</a></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo docker login --username=zchengx registry.cn-shenzhen.aliyuncs.com</span><span class="hljs-meta">$</span><span class="bash"> sudo docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像版本号]</span><span class="hljs-meta">#</span><span class="bash"> 修改id 和 版本</span>sudo docker tag a5ef1f32aaae registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:1.0<span class="hljs-meta">#</span><span class="bash"> 修改版本</span><span class="hljs-meta">$</span><span class="bash"> sudo docker push registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像版本号]</span></code></pre></div></li></ol><h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8 小结"></a>8 小结</h4><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MTE1NTY2Ny5wbmc" alt></p><h2 id="7-Docker-网络原理"><a href="#7-Docker-网络原理" class="headerlink" title="7 Docker 网络原理"></a>7 Docker 网络原理</h2><h3 id="7-1-理解Docker-0"><a href="#7-1-理解Docker-0" class="headerlink" title="7.1 理解Docker 0"></a>7.1 理解Docker 0</h3><p>学习之前<strong>清空下前面的docker 镜像、容器</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除全部容器</span><span class="hljs-meta">$</span><span class="bash"> docker rm -f $(docker ps -aq)</span><span class="hljs-meta">#</span><span class="bash"> 删除全部镜像</span><span class="hljs-meta">$</span><span class="bash"> docker rmi -f $(docker images -aq)</span></code></pre></div><blockquote><p>  测试</p></blockquote><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTIyMzIzNjc3Mi5wbmc" alt></p><h4 id="1-三个网络"><a href="#1-三个网络" class="headerlink" title="1 三个网络"></a>1 三个网络</h4><blockquote><p>  问题： docker 是如果处理容器网络访问的？</p></blockquote><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MjA0MTk4NS5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试  运行一个tomcat</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span><span class="hljs-meta">#</span><span class="bash"> 查看容器内部网络地址</span><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it 容器id ip addr</span><span class="hljs-meta">#</span><span class="bash"> 发现容器启动的时候会得到一个 eth0@if91 ip地址，docker分配！</span><span class="hljs-meta">$</span><span class="bash"> ip addr</span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever261: eth0@if91: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0       valid_lft forever preferred_lft forever       <span class="hljs-meta">#</span><span class="bash"> 思考？ linux能不能ping通容器内部！ 可以 容器内部可以ping通外界吗？ 可以！</span><span class="hljs-meta">$</span><span class="bash"> ping 172.18.0.2</span>PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.069 ms64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.074 ms</code></pre></div><blockquote><p>  原理</p></blockquote><ol><li><p>我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个docker0桥接模式，使用的技术是veth-pair技术！</p><p><a href="https://www.cnblogs.com/bakari/p/10613710.html">https://www.cnblogs.com/bakari/p/10613710.html</a></p><p>再次测试 ip addr</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTIyNDAzNjg4My5wbmc" alt></p></li><li><p>再启动一个容器测试，发现又多了一对网络</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MzI1OTQ1OC5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 我们发现这个容器带来网卡，都是一对对的</span><span class="hljs-meta">#</span><span class="bash"> veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连</span><span class="hljs-meta">#</span><span class="bash"> 正因为有这个特性 veth-pair 充当一个桥梁，连接各种虚拟网络设备的</span><span class="hljs-meta">#</span><span class="bash"> OpenStac, Docker容器之间的连接，OVS的连接，都是使用evth-pair技术</span></code></pre></div></li><li><p>我们来测试下tomcat01和tomcat02是否可以ping通</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 获取tomcat01的ip 172.17.0.2</span><span class="hljs-meta">$</span><span class="bash"> docker-tomcat docker <span class="hljs-built_in">exec</span> -it tomcat01 ip addr</span>  550: eth0@if551: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever       <span class="hljs-meta">#</span><span class="bash"> 让tomcat02 ping tomcat01</span>       <span class="hljs-meta">$</span><span class="bash"> docker-tomcat docker <span class="hljs-built_in">exec</span> -it tomcat02 ping 172.17.0.2</span>PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.098 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.071 ms<span class="hljs-meta">#</span><span class="bash"> 结论：容器和容器之间是可以互相ping通</span></code></pre></div></li></ol><h4 id="2-网络模型图"><a href="#2-网络模型图" class="headerlink" title="2 网络模型图"></a>2 网络模型图</h4><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NDI0ODYyNi5wbmc" alt></p><p>结论：tomcat01和tomcat02公用一个路由器，docker0。</p><p>所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip。</p><blockquote><p>  小结</p></blockquote><p>Docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥 docker0</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NDcwMTA2My5wbmc" alt></p><p>Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件）</p><p>只要容器删除，对应的网桥一对就没了！</p><p><strong>思考一个场景：我们编写了一个微服务，database url=ip: 项目不重启，数据ip换了，我们希望可以处理这个问题，可以通过名字来进行访问容器</strong>？</p><h3 id="7-2-容器互联-–link"><a href="#7-2-容器互联-–link" class="headerlink" title="7.2  容器互联 –link"></a>7.2  容器互联 –link</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it tomcat02 ping tomca01   <span class="hljs-comment"># ping不通</span></span>ping: tomca01: Name or service not known<span class="hljs-meta">#</span><span class="bash"> 运行一个tomcat03 --link tomcat02</span> <span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat03 --link tomcat02 tomcat</span>5f9331566980a9e92bc54681caaac14e9fc993f14ad13d98534026c08c0a9aef<span class="hljs-meta">#</span><span class="bash"> 3连接2</span><span class="hljs-meta">#</span><span class="bash"> 用tomcat03 ping tomcat02 可以ping通</span><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it tomcat03 ping tomcat02</span>PING tomcat02 (172.17.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.115 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.080 ms<span class="hljs-meta">#</span><span class="bash"> 2连接3</span><span class="hljs-meta">#</span><span class="bash"> 用tomcat02 ping tomcat03 ping不通</span></code></pre></div><p><strong>探究：</strong></p><p>docker network inspect 网络id 网段相同</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NTkwNDU1MS5wbmc" alt></p><p>docker inspect tomcat03</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE4MDMwODUzMC5wbmc" alt></p><p>查看tomcat03里面的/etc/hosts发现有tomcat02的配置</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE4MDYyOTAxMi5wbmc" alt></p><p>–link 本质就是在hosts配置中添加映射</p><p>现在使用Docker已经不建议使用–link了！</p><p>自定义网络，不适用docker0！</p><p>docker0问题：不支持容器名连接访问！</p><h3 id="7-3-自定义网络"><a href="#7-3-自定义网络" class="headerlink" title="7.3 自定义网络"></a>7.3 自定义网络</h3><div class="code-wrapper"><pre><code class="hljs shell">docker networkconnect     -- Connect a container to a networkcreate      -- Creates a new network with a name specified by thedisconnect  -- Disconnects a container from a networkinspect     -- Displays detailed information on a networkls          -- Lists all the networks created by the userprune       -- Remove all unused networksrm          -- Deletes one or more networks</code></pre></div><blockquote><p>  查看所有的docker网络</p></blockquote><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MDMxNjA3My5wbmc" alt></p><p><strong>网络模式</strong></p><p>bridge ：桥接 docker（默认，自己创建也是用bridge模式）</p><p>none ：不配置网络，一般不用</p><p>host ：和所主机共享网络</p><p>container ：容器网络连通（用得少！局限很大）</p><p>测试</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 我们直接启动的命令 --net bridge,而这个就是我们得docker0</span><span class="hljs-meta">#</span><span class="bash"> bridge就是docker0</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span>等价于 =&gt; docker run -d -P --name tomcat01 --net bridge tomcat<span class="hljs-meta">#</span><span class="bash"> docker0，特点：默认，域名不能访问。 --link可以打通连接，但是很麻烦！</span><span class="hljs-meta">#</span><span class="bash"> 我们可以 自定义一个网络</span><span class="hljs-meta">$</span><span class="bash"> docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTEzOTk0NC5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker network inspect mynet</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTQwNzA2NS5wbmc" alt></p><p>启动两个tomcat,再次查看网络情况</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTg0NDI0MC5wbmc" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MjAwNzM3MS5wbmc" alt></p><p>在自定义的网络下，服务可以互相ping通，不用使用 –link</p><p>我们自定义的网络docker当我们维护好了对应的关系，推荐我们平时这样使用网络！</p><p>好处：</p><ul><li><p>redis -不同的集群使用不同的网络，保证集群是安全和健康的</p></li><li><p>mysql-不同的集群使用不同的网络，保证集群是安全和健康的</p></li></ul><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MjUwNDM2Ny5wbmc" alt></p><h3 id="7-4-网络连通"><a href="#7-4-网络连通" class="headerlink" title="7.4 网络连通"></a>7.4 网络连通</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzI0MzE0Ni5wbmc" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzI1OTE4NS5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试两个不同的网络连通  再启动两个tomcat 使用默认网络，即docker0</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat02 tomcat</span><span class="hljs-meta">#</span><span class="bash"> 此时ping不通</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzU1NDkzMS5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 要将tomcat01 连通 tomcat—net-01 ，连通就是将 tomcat01加到 mynet网络</span><span class="hljs-meta">#</span><span class="bash"> 一个容器两个ip（tomcat01）</span></code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5Mzg0ODMzNy5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 01连通 ，加入后此时，已经可以tomcat01 和 tomcat-01-net ping通了</span><span class="hljs-meta">#</span><span class="bash"> 02是依旧不通的</span></code></pre></div><p>结论：假设要跨网络操作别人，就需要使用docker network connect 连通！</p><h2 id="8-实战：部署Redis集群"><a href="#8-实战：部署Redis集群" class="headerlink" title="8 实战：部署Redis集群"></a>8 实战：部署Redis集群</h2><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5NDQxOTQ3MS5wbmc" alt></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建网卡</span>docker network create redis --subnet 172.38.0.0/16<span class="hljs-meta">#</span><span class="bash"> 通过脚本创建六个redis配置</span>for port in $(seq 1 6);\do \mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;&gt; /mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdone<span class="hljs-meta">#</span><span class="bash"> 通过脚本运行六个redis</span>for port in $(seq 1 6);\docker run -p 637$&#123;port&#125;:6379 -p 1667$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \-v /mydata/redis/node-$&#123;port&#125;/data:/data \-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span class="hljs-meta">#</span><span class="bash"> 单个启动</span>docker run -p 6376:6379 -p 16376:16379 --name redis-6 \    -v /mydata/redis/node-6/data:/data \    -v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \    -d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf    <span class="hljs-meta">#</span><span class="bash"> 配置集群</span>docker exec -it redis-1 /bin/sh #redis默认没有bashredis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379  --cluster-replicas 1</code></pre></div><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjIwMjkwMjI0MS5wbmc" alt></p><p>docker搭建redis集群完成！</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjIwMzMyMzk3MS5wbmc" alt></p><p>我们使用docker之后，所有的技术都会慢慢变得简单起来！</p><h2 id="9-IDEA整合Docker"><a href="#9-IDEA整合Docker" class="headerlink" title="9 IDEA整合Docker"></a>9 IDEA整合Docker</h2><ol><li><p>构建SpringBoot项目</p></li><li><p>打包运行</p><div class="code-wrapper"><pre><code class="hljs shell">mvn package</code></pre></div></li><li><p>编写dockerfile</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><span class="hljs-keyword">COPY</span><span class="bash"> *.jar /app.jar</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;--server.port=8080&quot;</span>]</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;app.jar&quot;</span>]</span></code></pre></div></li><li><p>构建镜像</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.复制jar和DockerFIle到服务器</span><span class="hljs-meta">#</span><span class="bash"> 2.构建镜像</span><span class="hljs-meta">$</span><span class="bash"> docker build -t xxxxx:xx  .</span></code></pre></div></li><li><p>发布运行</p><p>以后我们使用了Docker之后，给别人交付就是一个镜像即可！</p></li></ol><h2 id="10-Docker-compose"><a href="#10-Docker-compose" class="headerlink" title="10 Docker compose"></a>10 Docker compose</h2><h3 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173610891.png" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173621230.png" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/2020120517363870.png" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173652461.png" alt></p><h3 id="10-2-安装"><a href="#10-2-安装" class="headerlink" title="10.2 安装"></a>10.2 安装</h3><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173738412.png" alt></p><ul><li><p>下载</p><div class="code-wrapper"><pre><code class="hljs shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></pre></div></li><li><p>授权</p><div class="code-wrapper"><pre><code class="hljs shell">sudo chmod +x docker-compose</code></pre></div></li><li><p>查看版本</p><div class="code-wrapper"><pre><code class="hljs shell">docker-compose version</code></pre></div></li></ul><h3 id="10-3-体验"><a href="#10-3-体验" class="headerlink" title="10.3 体验"></a>10.3 体验</h3><p>官方文档：<a href="https://docs.docker.com/compose/gettingstarted/">https://docs.docker.com/compose/gettingstarted/</a></p><ol><li><p>创建文件夹 composetest</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir composetest</span><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> composetest</span></code></pre></div></li><li><p>创建 app.py</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim app.py</span>import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)def get_hit_count():    retries = 5    while True:        try:            return cache.incr(&#x27;hits&#x27;)        except redis.exceptions.ConnectionError as exc:            if retries == 0:                raise exc            retries -= 1            time.sleep(0.5)@app.route(&#x27;/&#x27;)def hello():    count = get_hit_count()    return &#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;.format(count)</code></pre></div></li><li><p>创建 requirements.txt</p><div class="code-wrapper"><pre><code class="hljs txt">$ vim requirements.txtflaskredis</code></pre></div></li><li><p>创建 Dockerfile</p><div class="code-wrapper"><pre><code class="hljs dockerfile">$ vim Dockerfile<span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>-alpine<span class="hljs-keyword">RUN</span><span class="bash"> sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories </span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /code</span><span class="hljs-keyword">ENV</span> FLASK_APP=app.py<span class="hljs-keyword">ENV</span> FLASK_RUN_HOST=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><span class="hljs-keyword">RUN</span><span class="bash"> apk add --no-cache gcc musl-dev linux-headers</span><span class="hljs-keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span><span class="hljs-keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span><span class="hljs-keyword">COPY</span><span class="bash"> . .</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;flask&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span></code></pre></div></li><li><p>创建 docker-compose.yml</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim docker-compose.yml</span>version: &quot;3.8&quot;services:  web:    build: .    ports:      - &quot;5000:5000&quot;  redis:    image: &quot;redis:alpine&quot;</code></pre></div></li><li><p>启动</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker-compose build</span><span class="hljs-meta">$</span><span class="bash"> docker-compose up</span></code></pre></div></li><li><p>停止</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161110869.png" alt></p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161121213.png" alt></p></li><li><p>小结</p><p><img src="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161135882.png" alt></p></li></ol><h3 id="10-4-yaml-规则"><a href="#10-4-yaml-规则" class="headerlink" title="10.4 yaml 规则"></a>10.4 yaml 规则</h3><p><strong>docker-compose.yaml 核心！</strong><br>官方文档：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><h3 id="10-5-开源项目-博客"><a href="#10-5-开源项目-博客" class="headerlink" title="10.5 开源项目 - 博客"></a>10.5 开源项目 - 博客</h3><h2 id="11-Docker-Swarm"><a href="#11-Docker-Swarm" class="headerlink" title="11 Docker Swarm"></a>11 Docker Swarm</h2><h3 id="11-1-什么是Docker-Swarm"><a href="#11-1-什么是Docker-Swarm" class="headerlink" title="11.1 什么是Docker Swarm"></a>11.1 什么是Docker Swarm</h3><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181018165124850-1417419249.png" alt="img"></p><ul><li><p>Swarm是Docker公司推出的用来管理docker集群的平台，几乎全部用GO语言来完成的开发的，代码开源在<a href="https://github.com/docker/swarm，">https://github.com/docker/swarm，</a> 它是将一群Docker宿主机变成一个单一的虚拟主机，Swarm使用标准的Docker API接口作为其前端的访问入口，换言之，各种形式的Docker</p></li><li><p>Client(compose,docker-py等)均可以直接与Swarm通信，甚至Docker本身都可以很容易的与Swarm集成，这大大方便了用户将原本基于单节点的系统移植到Swarm上，同时Swarm内置了对Docker网络插件的支持，用户也很容易的部署跨主机的容器集群服务。</p></li><li><p>Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。</p></li><li><p>从 Docker 1.12.0 版本开始，Docker Swarm 已经包含在 Docker 引擎中（docker swarm），并且已经内置了服务发现工具，我们就不需要像之前一样，再配置 Etcd 或者 Consul 来进行服务发现配置了。</p></li><li><p>Swarm deamon只是一个调度器(Scheduler)加路由器(router),Swarm自己不运行容器，它只是接受Docker客户端发来的请求，调度适合的节点来运行容器，这就意味着，即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，放Swarm重新恢复运行之后，他会收集重建集群信息。</p></li></ul><h3 id="11-2-Docker-Swarm-基本结构图"><a href="#11-2-Docker-Swarm-基本结构图" class="headerlink" title="11.2 Docker Swarm 基本结构图"></a>11.2 Docker Swarm 基本结构图</h3><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181018163339198-1499005562.png" alt="img"></p><p>在结构图可以看出 Docker Client使用Swarm对 集群(Cluster)进行调度使用。</p><p>上图可以看出，Swarm是典型的master-slave结构，通过发现服务来选举manager。manager是中心管理节点，各个node上运行agent接受manager的统一管理，集群会自动通过Raft协议分布式选举出manager节点，无需额外的发现服务支持，避免了单点的瓶颈问题，同时也内置了DNS的负载均衡和对外部负载均衡机制的集成支持</p><h3 id="11-3-Swarm的几个关键概念"><a href="#11-3-Swarm的几个关键概念" class="headerlink" title="11.3 Swarm的几个关键概念"></a>11.3 Swarm的几个关键概念</h3><h4 id="1-Swarm"><a href="#1-Swarm" class="headerlink" title="1 Swarm"></a>1 Swarm</h4><p>集群的管理和编排是使用嵌入docker引擎的SwarmKit，可以在docker初始化时启动swarm模式或者加入已存在的swarm</p><h4 id="2-Node"><a href="#2-Node" class="headerlink" title="2 Node"></a>2 Node</h4><ul><li>一个节点是docker引擎集群的一个实例。您还可以将其视为Docker节点。您可以在单个物理计算机或云服务器上运行一个或多个节点，但生产群集部署通常包括分布在多个物理和云计算机上的Docker节点。</li><li>要将应用程序部署到swarm，请将服务定义提交给 管理器节点。管理器节点将称为任务的工作单元分派 给工作节点。</li><li>Manager节点还执行维护所需群集状态所需的编排和集群管理功能。Manager节点选择单个领导者来执行编排任务。</li><li>工作节点接收并执行从管理器节点分派的任务。默认情况下，管理器节点还将服务作为工作节点运行，但您可以将它们配置为仅运行管理器任务并且是仅管理器节点。代理程序在每个工作程序节点上运行，并报告分配给它的任务。工作节点向管理器节点通知其分配的任务的当前状态，以便管理器可以维持每个工作者的期望状态。</li></ul><h4 id="3-Service"><a href="#3-Service" class="headerlink" title="3 Service"></a>3 Service</h4><p>一个服务是任务的定义，管理机或工作节点上执行。它是群体系统的中心结构，是用户与群体交互的主要根源。创建服务时，你需要指定要使用的容器镜像。</p><h4 id="4-Task"><a href="#4-Task" class="headerlink" title="4 Task"></a>4 Task</h4><p>任务是在docekr容器中执行的命令，Manager节点根据指定数量的任务副本分配任务给worker节点</p><h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>docker swarm：集群管理，子命令有init, join, leave, update。（docker swarm –help查看帮助）<br>docker service：服务创建，子命令有create, inspect, update, remove, tasks。（docker service–help查看帮助）<br>docker node：节点管理，子命令有accept, promote, demote, inspect, update, tasks, ls, rm。（docker node –help查看帮助）</p><p>node是加入到swarm集群中的一个docker引擎实体，可以在一台物理机上运行多个node，node分为：<br>manager nodes，也就是管理节点<br>worker nodes，也就是工作节点</p><ul><li>manager node管理节点：执行集群的管理功能，维护集群的状态，选举一个leader节点去执行调度任务。</li><li>worker node工作节点：接收和执行任务。参与容器集群负载调度，仅用于承载task。</li><li>service服务：一个服务是工作节点上执行任务的定义。创建一个服务，指定了容器所使用的镜像和容器运行的命令。<ul><li>service是运行在worker nodes上的task的描述，service的描述包括使用哪个docker 镜像，以及在使用该镜像的容器中执行什么命令。</li></ul></li><li>task任务：一个任务包含了一个容器及其运行的命令。task是service的执行实体，task启动docker容器并在容器中执行任务。</li></ul><h3 id="11-4-Swarm的工作模式"><a href="#11-4-Swarm的工作模式" class="headerlink" title="11.4 Swarm的工作模式"></a>11.4 Swarm的工作模式</h3><ol><li>Node</li></ol><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220250190-271703054.png" alt="img"></p><ol start="2"><li>Service</li></ol><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220303428-146351236.png" alt="img"></p><ol start="3"><li>任务与调度</li></ol><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220312417-120406041.png" alt="img"></p><ol start="4"><li>服务副本与全局服务</li></ol><p><img src="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220320789-1157117261.png" alt="img"></p><h3 id="11-5-Swarm的调度策略"><a href="#11-5-Swarm的调度策略" class="headerlink" title="11.5 Swarm的调度策略"></a>11.5 Swarm的调度策略</h3><p>Swarm在调度(scheduler)节点（leader节点）运行容器的时候，会根据指定的策略来计算最适合运行容器的节点，目前支持的策略有：spread, binpack, random.</p><ul><li><p>Random<br>顾名思义，就是随机选择一个Node来运行容器，一般用作调试用，spread和binpack策略会根据各个节点的可用的CPU, RAM以及正在运<br>行的容器的数量来计算应该运行容器的节点。</p></li><li><p>Spread<br>在同等条件下，Spread策略会选择运行容器最少的那台节点来运行新的容器，binpack策略会选择运行容器最集中的那台机器来运行新的节点。<br>使用Spread策略会使得容器会均衡的分布在集群中的各个节点上运行，一旦一个节点挂掉了只会损失少部分的容器。</p></li><li><p>Binpack<br>Binpack策略最大化的避免容器碎片化，就是说binpack策略尽可能的把还未使用的节点留给需要更大空间的容器运行，尽可能的把容器运行在<br>一个节点上面。</p></li></ul><h3 id="11-6-Swarm-Cluster模式特性"><a href="#11-6-Swarm-Cluster模式特性" class="headerlink" title="11.6 Swarm Cluster模式特性"></a>11.6 Swarm Cluster模式特性</h3><h4 id="1-批量创建服务"><a href="#1-批量创建服务" class="headerlink" title="1 批量创建服务"></a>1 批量创建服务</h4><p>建立容器之前先创建一个overlay的网络，用来保证在不同主机上的容器网络互通的网络模式</p><h4 id="2-强大的集群的容错性"><a href="#2-强大的集群的容错性" class="headerlink" title="2 强大的集群的容错性"></a>2 强大的集群的容错性</h4><p>当容器副本中的其中某一个或某几个节点宕机后，cluster会根据自己的服务注册发现机制，以及之前设定的值–replicas n，<br>在集群中剩余的空闲节点上，重新拉起容器副本。整个副本迁移的过程无需人工干预，迁移后原本的集群的load balance依旧好使！<br>不难看出，docker service其实不仅仅是批量启动服务这么简单，而是在集群中定义了一种状态。Cluster会持续检测服务的健康状态<br>并维护集群的高可用性。</p><h4 id="3-服务节点的可扩展性"><a href="#3-服务节点的可扩展性" class="headerlink" title="3 服务节点的可扩展性"></a>3 服务节点的可扩展性</h4><p>Swarm Cluster不光只是提供了优秀的高可用性，同时也提供了节点弹性扩展或缩减的功能。当容器组想动态扩展时，只需通过scale<br>参数即可复制出新的副本出来。</p><ul><li><p>仔细观察的话，可以发现所有扩展出来的容器副本都run在原先的节点下面，如果有需求想在每台节点上都run一个相同的副本，方法<br>其实很简单，只需要在命令中将”–replicas n”更换成”–mode=global”即可！</p></li><li><p>复制服务（–replicas n）<br>将一系列复制任务分发至各节点当中，具体取决于您所需要的设置状态，例如“–replicas 3”。</p></li><li><p>全局服务（–mode=global）<br>适用于集群内全部可用节点上的服务任务，例如“–mode global”。如果大家在 Swarm 集群中设有 7 台 Docker 节点，则全部节点之上都将存在对应容器。</p></li></ul><h4 id="4-调度机制"><a href="#4-调度机制" class="headerlink" title="4 调度机制"></a>4 调度机制</h4><p>所谓的调度其主要功能是cluster的server端去选择在哪个服务器节点上创建并启动一个容器实例的动作。它是由一个装箱算法和过滤器<br>组合而成。每次通过过滤器（constraint）启动容器的时候，swarm cluster 都会调用调度机制筛选出匹配约束条件的服务器，并在这上面运行容器。</p><h4 id="5-Swarm-cluster的创建过程包含以下三个步骤"><a href="#5-Swarm-cluster的创建过程包含以下三个步骤" class="headerlink" title="5 Swarm cluster的创建过程包含以下三个步骤-"></a>5 Swarm cluster的创建过程包含以下三个步骤-</h4><ul><li>发现Docker集群中的各个节点，收集节点状态、角色信息，并监视节点状态的变化</li><li>初始化内部调度（scheduler）模块</li><li>创建并启动API监听服务模块</li></ul><p>一旦创建好这个cluster，就可以用命令docker service批量对集群内的容器进行操作，非常方便！</p><p>在启动容器后，docker 会根据当前每个swarm节点的负载判断，在负载最优的节点运行这个task任务，用”docker service ls” 和”docker service ps + taskID”<br>可以看到任务运行在哪个节点上。容器启动后，有时需要等待一段时间才能完成容器创建。</p><h2 id="11-CI-CD-Jenkins"><a href="#11-CI-CD-Jenkins" class="headerlink" title="11 CI\CD Jenkins"></a>11 CI\CD Jenkins</h2>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Technical/">Technical</category>
      
      <category domain="https://pncalbl.github.io/categories/Technical/Distributed/">Distributed</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Docker/">Docker</category>
      
      
      <comments>https://pncalbl.github.io/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Liunx 配置静态IP</title>
      <link>https://pncalbl.github.io/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/</link>
      <guid>https://pncalbl.github.io/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/</guid>
      <pubDate>Thu, 29 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Liunx-配置静态IP-基于CentOS-7&quot;&gt;&lt;a href=&quot;#Liunx-配置静态IP-基于CentOS-7&quot; class=&quot;headerlink&quot; title=&quot;Liunx 配置静态IP (基于CentOS  7)&quot;&gt;&lt;/a&gt;Liunx 配置静态IP (</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Liunx-配置静态IP-基于CentOS-7"><a href="#Liunx-配置静态IP-基于CentOS-7" class="headerlink" title="Liunx 配置静态IP (基于CentOS  7)"></a>Liunx 配置静态IP (基于CentOS  7)</h1><blockquote><p>  只要Vmware的虚拟网络编辑器配置好, 其他liunx系统配置基本一样, 只是有些命令不同而已</p></blockquote><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1 原理"></a>1 原理</h2><ul><li>先看看虚拟机和主机连接的条件：</li></ul><ul><li>需要主机的Vmware8的ip、Vmware8网关ip、虚拟机(centOs)网卡eth0的ip在同一网段下，如图（都是192.168.145.x）：</li></ul><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/20201201012406421.png" alt="img"></p><p>图片来自网络, 侵权请联系<a href="pncalbl@qq.com">author</a>删除</p><ul><li>一般地，如果虚拟机与主机通信走的是虚线，访问外网则走的实线，其控制程序在虚拟机网关设备中实现</li></ul><ul><li>但是，一般由于工作环境的变化，导致网络的改变，有时候会导致虚拟机网段改变，从而与主机连不通，在CentOs下使用ifconfig发现ens33 ip不再192.168.145这个段上，这时，重置eth0的ip即可，方法：ifconfig ens33 192.168.145.xxx</li></ul><h2 id="2-修改虚拟机网络编辑器"><a href="#2-修改虚拟机网络编辑器" class="headerlink" title="2 修改虚拟机网络编辑器"></a>2 修改虚拟机网络编辑器</h2><ul><li><p>点击 编辑-&gt;虚拟机网络编辑器</p><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430180711181.png" alt="image-20210430180711181"></p><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430181747517.png" alt="image-20210430181747517"></p></li></ul><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430181845286.png" alt="image-20210430181845286"></p><ul><li><p>如果子网不对, 可以还原默认设置</p><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430182036414.png" alt="image-20210430182036414"></p></li></ul><h2 id="3-更改网络适配器"><a href="#3-更改网络适配器" class="headerlink" title="3 更改网络适配器"></a>3 更改网络适配器</h2><blockquote><p>  VMware Virtual Ethernet Adapter for VMnet8 (NAT)</p></blockquote><ul><li><p>点击IPv4</p><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430190450485.png" alt="image-20210430190450485"></p></li><li><p>修改</p><p><img src="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/image-20210430190551654.png" alt="image-20210430190551654"></p></li></ul><h2 id="4-修改ens33"><a href="#4-修改ens33" class="headerlink" title="4 修改ens33"></a>4 修改ens33</h2><ul><li><p>进入 网卡配置</p><ul><li><p>centOS</p><div class="code-wrapper"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>sysconfig<span class="hljs-regexp">/network-scripts/i</span>fcfg-ens33</code></pre></div></li><li><p>ubunto</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">gedit</span> /etc/netplan/<span class="hljs-number">01</span>-network-manager-<span class="hljs-literal">all</span>.yaml</code></pre></div></li></ul></li><li><p>修改参数</p><ul><li><p>centOS</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">HWADDR</span>=<span class="hljs-number">00</span>:<span class="hljs-number">0</span>C:<span class="hljs-number">29</span>:<span class="hljs-number">0</span>D:<span class="hljs-number">73</span>:CF<span class="hljs-attr">TYPE</span>=Ethernet<span class="hljs-attr">PROXY_METHOD</span>=none<span class="hljs-attr">BROWSER_ONLY</span>=<span class="hljs-literal">no</span><span class="hljs-attr">BOOTPROTO</span>=static<span class="hljs-comment"># 静态IP</span><span class="hljs-attr">DEFROUTE</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><span class="hljs-attr">IPV6_ADDR_GEN_MODE</span>=stable-privacy<span class="hljs-attr">NAME</span>=ens33<span class="hljs-attr">UUID</span>=<span class="hljs-number">13000</span>fee-<span class="hljs-number">503</span>a-<span class="hljs-number">350</span>c-<span class="hljs-number">9462</span>-d70dd1ede195<span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span><span class="hljs-comment">#开机启用本配置</span><span class="hljs-attr">AUTOCONNECT_PRIORITY</span>=-<span class="hljs-number">999</span><span class="hljs-attr">IPADDR</span>=ipv4<span class="hljs-comment">#ipv4</span><span class="hljs-attr">PREFIX</span>=<span class="hljs-number">24</span><span class="hljs-attr">GATEWAY</span>=网关 <span class="hljs-comment">#网关</span><span class="hljs-attr">DNS1</span>=<span class="hljs-number">119.29</span>.<span class="hljs-number">29.29</span><span class="hljs-comment"># 域名解析</span></code></pre></div></li><li><p>ubunto</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>  <span class="hljs-attr">renderer:</span> <span class="hljs-string">NetworkManager</span>  <span class="hljs-attr">ethernets:</span>          <span class="hljs-attr">ens33:</span>                  <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span>                  <span class="hljs-attr">dhcp6:</span> <span class="hljs-literal">no</span>                  <span class="hljs-attr">addresses:</span> [<span class="hljs-string">ipv4</span>]                  <span class="hljs-attr">gateway4:</span> <span class="hljs-string">网关</span>                  <span class="hljs-attr">nameservers:</span>                          <span class="hljs-attr">addresses:</span> [<span class="hljs-number">119.29</span><span class="hljs-number">.29</span><span class="hljs-number">.29</span>, <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>]</code></pre></div></li></ul></li><li><p>重启网络服务</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">service network restart</span></code></pre></div></li><li><p>查看ip</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ifconfig</span></code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre><code class="hljs autoit"><span class="hljs-built_in">ping</span> www.baidu.com</code></pre></div></li></ul>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Linux/">Linux</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Linux/">Linux</category>
      
      <category domain="https://pncalbl.github.io/tags/%E9%9D%99%E6%80%81IP/">静态IP</category>
      
      
      <comments>https://pncalbl.github.io/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>常见的压缩文件压缩和解压缩</title>
      <link>https://pncalbl.github.io/2021/04/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9/</link>
      <guid>https://pncalbl.github.io/2021/04/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9/</guid>
      <pubDate>Thu, 22 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;常见的压缩文件压缩和解压缩&quot;&gt;&lt;a href=&quot;#常见的压缩文件压缩和解压缩&quot; class=&quot;headerlink&quot; title=&quot;常见的压缩文件压缩和解压缩&quot;&gt;&lt;/a&gt;常见的压缩文件压缩和解压缩&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件后缀</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="常见的压缩文件压缩和解压缩"><a href="#常见的压缩文件压缩和解压缩" class="headerlink" title="常见的压缩文件压缩和解压缩"></a>常见的压缩文件压缩和解压缩</h2><table><thead><tr><th>文件后缀名</th><th>说明</th><th>压缩</th><th>解压缩</th></tr></thead><tbody><tr><td>*.zip</td><td>zip 程序打包压缩的文件</td><td>zip fileName.zip dirName</td><td>unzip fileName.zip</td></tr><tr><td>*.rar</td><td>rar 程序压缩的文件</td><td>rar a fileName.rar dirName</td><td>rar x fileName.rar</td></tr><tr><td>*.7z</td><td>7zip 程序压缩的文件</td><td>7z a fileName.7z dirName</td><td>7z x fileName.7z</td></tr><tr><td>*.tar</td><td>tar 程序打包，未压缩的文件</td><td>tar cvf fileName.tar dirName</td><td>tar xvf fileName.tar</td></tr><tr><td>*.gz</td><td>gzip 程序 (GNU zip) 压缩的文件</td><td>gzip fileName</td><td>gzip -d fileName.gz</td></tr><tr><td>*.bz2</td><td>tar 打包，gzip 程序压缩的文件</td><td>bzip2 -z FileName</td><td>bzip2 -d FileName.bz2</td></tr><tr><td>*.tar.gz</td><td>tar打包，gzip程序压缩的文件</td><td>tar zcvf FileName.tar.gz dirName</td><td>tar zxvf FileName.tar.gz</td></tr><tr><td>*.tar.xz</td><td>tar打包，xz程序压缩的文件</td><td>tar cvJf fileName.tar.xz dirName</td><td>tar -xvJf fileName.tar.xz</td></tr><tr><td>*.tar.bz2</td><td>tar打包，bzip2程序压缩的文件</td><td>tar jcvf FileName.tar.bz2 dirName</td><td>tar jxvf FileName.tar.bz2</td></tr><tr><td>*.Z</td><td>compress命令解压缩rar文件</td><td>compress fileName</td><td>uncompress fileName.Z</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Linux/">Linux</category>
      
      
      
      <comments>https://pncalbl.github.io/2021/04/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>虚拟机 Ubuntu 安装 Tensorflow</title>
      <link>https://pncalbl.github.io/2021/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%AE%89%E8%A3%85Tensorflow/</link>
      <guid>https://pncalbl.github.io/2021/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%AE%89%E8%A3%85Tensorflow/</guid>
      <pubDate>Thu, 22 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1-软件环境&quot;&gt;&lt;a href=&quot;#1-软件环境&quot; class=&quot;headerlink&quot; title=&quot;1 软件环境&quot;&gt;&lt;/a&gt;1 软件环境&lt;/h2&gt;&lt;h5 id=&quot;1-1-ubuntu-18-04-desktop-amd64-iso&quot;&gt;&lt;a href=&quot;#1-1</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-软件环境"><a href="#1-软件环境" class="headerlink" title="1 软件环境"></a>1 软件环境</h2><h5 id="1-1-ubuntu-18-04-desktop-amd64-iso"><a href="#1-1-ubuntu-18-04-desktop-amd64-iso" class="headerlink" title="1.1 ubuntu-18.04-desktop-amd64.iso"></a>1.1 <a href="https://releases.ubuntu.com/18.04/ubuntu-18.04.5-desktop-amd64.iso">ubuntu-18.04-desktop-amd64.iso</a></h5><h5 id="1-2-python3-7-10"><a href="#1-2-python3-7-10" class="headerlink" title="1.2 python3.7.10"></a>1.2 <a href="https://www.python.org/ftp/python/3.7.10/Python-3.7.10.tgz">python3.7.10</a></h5><h2 id="2-安装-ubuntu"><a href="#2-安装-ubuntu" class="headerlink" title="2 安装 ubuntu"></a>2 安装 ubuntu</h2><h5 id="2-1-由于存在简易安装，所以基本上都是傻瓜式操作"><a href="#2-1-由于存在简易安装，所以基本上都是傻瓜式操作" class="headerlink" title="2.1 由于存在简易安装，所以基本上都是傻瓜式操作"></a>2.1 由于存在简易安装，所以基本上都是傻瓜式操作</h5><h5 id="2-2-配置国内源"><a href="#2-2-配置国内源" class="headerlink" title="2.2 配置国内源"></a>2.2 配置国内源</h5><ul><li><p>国内源</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 阿里云源</span>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<span class="hljs-comment">##測試版源</span>deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<span class="hljs-comment"># 源碼</span>deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<span class="hljs-comment">##測試版源</span>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<span class="hljs-comment"># 清华大学源</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse<span class="hljs-comment">##測試版源</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse<span class="hljs-comment"># 源碼</span>deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse<span class="hljs-comment">##測試版源</span>deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre></div></li></ul><ul><li><p>Ubuntu 的源存放在在 /etc/apt/ 目录下的 sources.list 文件中，修改前我们先备份，在终端中执行以下命令：</p><div class="code-wrapper"><pre><code class="hljs python">sudo cp /etc/apt/sources.<span class="hljs-built_in">list</span> /etc/apt/sources.<span class="hljs-built_in">list</span>.bcakup</code></pre></div></li></ul><ul><li><p>然后执行下面的命令打开 sources.list 文件，清空里面的内容，把上面阿里云与清华大学的 Ubuntu 源复制进去，保存后退出。</p><div class="code-wrapper"><pre><code class="hljs python">sudo gedit /etc/apt/sources.<span class="hljs-built_in">list</span></code></pre></div></li><li><p>接着在终端上执行以下命令更新软件列表，检测出可以更新的软件：</p><div class="code-wrapper"><pre><code class="hljs python">sudo apt-get update</code></pre></div></li><li><p>最后在终端上执行以下命令进行软件更新：</p><div class="code-wrapper"><pre><code class="hljs python">sudo apt-get upgrade</code></pre></div></li></ul><h2 id="3-安装-python"><a href="#3-安装-python" class="headerlink" title="3 安装 python"></a>3 安装 python</h2><ul><li><p>ubuntu 本身带有python 2.7 和 python 3.6，如果没有可以执行以下命令</p><div class="code-wrapper"><pre><code class="hljs python">sudo apt-get updatesudo apt-get install python2<span class="hljs-number">.7</span>sudo apt-get updatesudo apt-get install python3<span class="hljs-number">.6</span></code></pre></div></li></ul><h2 id="4-切换-python-版本"><a href="#4-切换-python-版本" class="headerlink" title="4 切换 python 版本"></a>4 切换 python 版本</h2><ul><li><p>我们可以使用 update-alternatives 来为整个系统更改Python 版本。以 root 身份登录，首先罗列出所有可用的python 替代版本信息：</p><div class="code-wrapper"><pre><code class="hljs python">update-alternatives --<span class="hljs-built_in">list</span> pythonupdate-alternatives: error: no alternatives <span class="hljs-keyword">for</span> python</code></pre></div></li><li><p>如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被update-alternatives 命令识别。想解决这个问题，我们需要更新一下替代列表，将python2.7 和 python3.6放入其中。</p><div class="code-wrapper"><pre><code class="hljs python">sudo update-alternatives --install /usr/<span class="hljs-built_in">bin</span>/python python /usr/<span class="hljs-built_in">bin</span>/python2<span class="hljs-number">.7</span> <span class="hljs-number">1</span>sudo update-alternatives --install /usr/<span class="hljs-built_in">bin</span>/python python /usr/<span class="hljs-built_in">bin</span>/python3<span class="hljs-number">.6</span> <span class="hljs-number">2</span></code></pre></div></li><li><p>–install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先 级的选项就会被选中。这个例子中，我们为/usr/bin/python3.6 设置的优先级为2，所以update-alternatives 命 令会自动将它设置为默认 Python 版本。</p><div class="code-wrapper"><pre><code class="hljs python">python --versionPython <span class="hljs-number">3.6</span><span class="hljs-number">.9</span></code></pre></div></li><li><p>接下来，我们再次列出可用的 Python 替代版本。</p><div class="code-wrapper"><pre><code class="hljs python">update-alternatives --<span class="hljs-built_in">list</span> python/usr/<span class="hljs-built_in">bin</span>/python2<span class="hljs-number">.7</span>/usr/<span class="hljs-built_in">bin</span>/python3<span class="hljs-number">.6</span></code></pre></div></li><li><p>现在开始，我们就可以使用下方的命令随时在列出的 Python 替代版本中任意切换了。（这一步是最关键的）</p><div class="code-wrapper"><pre><code class="hljs python">update-alternatives --config python</code></pre></div></li><li><p>以后我们就可以用 python 代替 python3</p></li></ul><h2 id="5-设置pip"><a href="#5-设置pip" class="headerlink" title="5 设置pip"></a>5 设置pip</h2><h3 id="5-1-安装pip3"><a href="#5-1-安装pip3" class="headerlink" title="5.1 安装pip3"></a>5.1 安装pip3</h3><ul><li><p>由于 ubuntu pip有问题，在导mian包有问题，网上的教程也没用，所以使用pip3</p><div class="code-wrapper"><pre><code class="hljs python">sudo apt-get install python3-pip</code></pre></div></li><li><p>查看pip3版本</p><div class="code-wrapper"><pre><code class="hljs python">pip3 --versionpip <span class="hljs-number">9.0</span><span class="hljs-number">.1</span> <span class="hljs-keyword">from</span> /usr/lib/python3/dist-packages (python <span class="hljs-number">3.6</span>)</code></pre></div></li><li><p>升级 pip 为最新版本，不然下载包的会出问题</p><div class="code-wrapper"><pre><code class="hljs python">sudo pip3 install --upgrade pip</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">root@pncalbl-pc:/home/pncalbl<span class="hljs-comment"># pip -V</span>pip <span class="hljs-number">21.0</span><span class="hljs-number">.1</span> <span class="hljs-keyword">from</span> /usr/local/lib/python3<span class="hljs-number">.6</span>/dist-packages/pip (python <span class="hljs-number">3.6</span>)root@pncalbl-pc:/home/pncalbl<span class="hljs-comment"># pip3 -V</span>pip <span class="hljs-number">21.0</span><span class="hljs-number">.1</span> <span class="hljs-keyword">from</span> /usr/local/lib/python3<span class="hljs-number">.6</span>/dist-packages/pip (python <span class="hljs-number">3.6</span>)</code></pre></div></li><li><p>如果系统只安装了一个 pip3， 可以通pip来直接使用 pip3，而不是 pip3</p></li></ul><h3 id="5-2-更换pip源"><a href="#5-2-更换pip源" class="headerlink" title="5.2 更换pip源"></a>5.2 更换pip源</h3><ul><li><p>创建目录：</p><div class="code-wrapper"><pre><code class="hljs python">sudo mkdir ~/.pip</code></pre></div></li><li><p>创建文件：</p><div class="code-wrapper"><pre><code class="hljs python">sudo gedit ~/.pip/pip.conf</code></pre></div></li><li><p>将以下内容保存到文件中，建议使用清华的源</p><div class="code-wrapper"><pre><code class="hljs python">[<span class="hljs-keyword">global</span>]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install] trusted-host=pypi.tuna.tsinghua.edu.cn</code></pre></div></li></ul><h3 id="5-3-pip-install"><a href="#5-3-pip-install" class="headerlink" title="5.3 pip install"></a>5.3 pip install</h3><p><code>可能出现的问题</code></p><ul><li><p>hostname</p><p>可能是配置了系统代理,此时我们可以暂时关闭代理</p></li></ul><h2 id="6-安装-Tensorflow"><a href="#6-安装-Tensorflow" class="headerlink" title="6  安装 Tensorflow"></a>6  安装 Tensorflow</h2><p>这里使用 <strong>douban</strong> 的源，是因为他下载 <strong>tensorflow</strong> 比较快，不影响我们之前配pip源</p><ul><li><p>由于之前已经配好了 <strong>pip</strong> 的源，所以只需要进行下载即可</p><div class="code-wrapper"><pre><code class="hljs python">pip install tensorflow-cpu==<span class="hljs-number">2.4</span><span class="hljs-number">.0</span> -i https://pypi.douban.com/simple/</code></pre></div></li><li><p>安装中可能会有1~2个包，安装失败，我们可以手动安装</p><div class="code-wrapper"><pre><code class="hljs python">python -m pip install launchpadlib</code></pre></div></li><li><p>继续安装 <strong>matplotlib</strong> 和 <strong>notebook</strong>（matplotlib是Python 的绘图库，jupyter notebook是基于网页的用于交互计算的应用程序）</p><div class="code-wrapper"><pre><code class="hljs python">pip install matplotlib notebook -i https://pypi.douban.com/simple/</code></pre></div></li><li><p>在安装 <strong>notebook</strong>中，会出现一些问题<br><strong>Running as root is not recommended. Use –allow-root to bypass.</strong></p><ul><li><p>首先查看配置文件位置，</p><div class="code-wrapper"><pre><code class="hljs python">jupyter notebook --generate-config --allow-root</code></pre></div></li><li><p>接下来打开配置文件：</p><div class="code-wrapper"><pre><code class="hljs python">gedit /root/.jupyter/jupyter_notebook_config.py</code></pre></div></li><li><p>找到”#c.NotebookApp.allow_root = False “;去掉#，并修改成True即可解决root权限运行的问题</p><div class="code-wrapper"><pre><code class="hljs python">c.NotebookApp.allow_root =<span class="hljs-literal">True</span>jupyter notebook <span class="hljs-comment"># 保存，重新运行程序:</span></code></pre></div></li></ul></li><li><p>设置访问密码, 打开 <strong>ipython</strong> 输入</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> notebook.auth <span class="hljs-keyword">import</span> passwdpasswd()然后根据提示输入<span class="hljs-number">2</span>次密码Enter password: ········Verify password: ········</code></pre></div><ul><li><p>ipthon需要自己安装</p><div class="code-wrapper"><pre><code class="hljs python">apt-get install ipython3</code></pre></div></li></ul></li><li><p>复制密码，粘贴至配置文件（记得去掉 #）</p><div class="code-wrapper"><pre><code class="hljs python">c.NotebookApp.password = <span class="hljs-string">u&#x27;sha1:f5*****************************&#x27;</span></code></pre></div></li><li><p>更多设置</p><div class="code-wrapper"><pre><code class="hljs python">c.NotebookApp.ip = ‘localhost’c.NotebookApp.open_browser = <span class="hljs-literal">True</span>（<span class="hljs-literal">True</span>：启动时自动打开浏览器，<span class="hljs-literal">False</span>：需手动打开浏览器访问http://localhost:<span class="hljs-number">8888</span>/tree）c.NotebookApp.port = <span class="hljs-number">8888</span>（端口设置）</code></pre></div></li></ul><h2 id="7-测试-Tensorflow"><a href="#7-测试-Tensorflow" class="headerlink" title="7 测试 Tensorflow"></a>7 测试 Tensorflow</h2><p>安装成功后，执行jupyter notebook命令进入网页界面，界面如下：</p><p><img src="/2021/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%AE%89%E8%A3%85Tensorflow/image-20210423154621327.png" alt="image-20210423154621327"></p><p>新建1个界面，可以输入如下来验证，如下图：</p><p><img src="/2021/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%AE%89%E8%A3%85Tensorflow/image-20210423154640279.png" alt="image-20210423154640279"></p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Linux/">Linux</category>
      
      
      <category domain="https://pncalbl.github.io/tags/Deep-learning/">Deep learning</category>
      
      <category domain="https://pncalbl.github.io/tags/Tensorflow/">Tensorflow</category>
      
      <category domain="https://pncalbl.github.io/tags/Ubuntu/">Ubuntu</category>
      
      
      <comments>https://pncalbl.github.io/2021/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E5%AE%89%E8%A3%85Tensorflow/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Stm32CubeMx + Clion环境搭建</title>
      <link>https://pncalbl.github.io/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <guid>https://pncalbl.github.io/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <pubDate>Tue, 20 Apr 2021 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;环境和所需工具&quot;&gt;&lt;a href=&quot;#环境和所需工具&quot; class=&quot;headerlink&quot; title=&quot;环境和所需工具&quot;&gt;&lt;/a&gt;环境和所需工具&lt;/h1&gt;&lt;h2 id=&quot;一，-软件环境&quot;&gt;&lt;a href=&quot;#一，-软件环境&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="环境和所需工具"><a href="#环境和所需工具" class="headerlink" title="环境和所需工具"></a>环境和所需工具</h1><h2 id="一，-软件环境"><a href="#一，-软件环境" class="headerlink" title="一， 软件环境"></a>一， 软件环境</h2><h3 id="1-Windows-10"><a href="#1-Windows-10" class="headerlink" title="1. Windows 10"></a>1. Windows 10</h3><h3 id="2-stm32cubemx"><a href="#2-stm32cubemx" class="headerlink" title="2. stm32cubemx"></a>2. <a href="https://www.st.com/en/development-tools/stm32cubemx.html">stm32cubemx</a></h3><h3 id="3-CLion-2020"><a href="#3-CLion-2020" class="headerlink" title="3. CLion-2020"></a>3. <a href="https://www.jetbrains.com/clion/">CLion-2020</a></h3><h3 id="4-MinGW"><a href="#4-MinGW" class="headerlink" title="4. MinGW"></a>4. <a href="http://www.mingw-w64.org/doku.php">MinGW</a></h3><h3 id="5-arm-none-eabi-gcc"><a href="#5-arm-none-eabi-gcc" class="headerlink" title="5. arm-none-eabi-gcc"></a>5. <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">arm-none-eabi-gcc</a></h3><h3 id="6-openOCD"><a href="#6-openOCD" class="headerlink" title="6. openOCD"></a>6. <a href="https://gnutoolchains.com/arm-eabi/openocd/">openOCD</a></h3><h3 id="7-stlink-v2"><a href="#7-stlink-v2" class="headerlink" title="7. stlink-v2"></a>7. <a href="https://www.st.com/en/development-tools/st-link-v2.html">stlink-v2</a></h3><h2 id="二，硬件环境"><a href="#二，硬件环境" class="headerlink" title="二，硬件环境"></a>二，硬件环境</h2><h3 id="1-单片机：正点原子STM32F103RCT6"><a href="#1-单片机：正点原子STM32F103RCT6" class="headerlink" title="1. 单片机：正点原子STM32F103RCT6"></a>1. 单片机：正点原子STM32F103RCT6</h3><h3 id="2-下载器：-StLink-V2"><a href="#2-下载器：-StLink-V2" class="headerlink" title="2. 下载器： StLink-V2"></a>2. 下载器： StLink-V2</h3><h2 id="三，工具安装"><a href="#三，工具安装" class="headerlink" title="三，工具安装"></a>三，工具安装</h2><p>工具安装部分正常安装就好了，注意安装目录的选择，尽量不要出现中文。</p><h3 id="1，STM32CubeMX"><a href="#1，STM32CubeMX" class="headerlink" title="1，STM32CubeMX"></a>1，STM32CubeMX</h3><p>直接去官网下在就可以，安装之前需要安装Java运行环境</p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421142019511.png" alt="image-20210421142019511"></p><h3 id="2，CLion"><a href="#2，CLion" class="headerlink" title="2，CLion"></a>2，CLion</h3><p>官网下载2019以后的版本</p><h3 id="3，MinGW"><a href="#3，MinGW" class="headerlink" title="3，MinGW"></a>3，MinGW</h3><p>Clion是基于CMake来管理项目的，所以首选需要配置好预设的MinGW和CMake环境。</p><p>检查是否配置好环境</p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421142250730.png" alt="image-20210421142250730"></p><h3 id="4，arm-none-eabi-gcc4"><a href="#4，arm-none-eabi-gcc4" class="headerlink" title="4，arm-none-eabi-gcc4"></a>4，arm-none-eabi-gcc4</h3><p>需要编译arm架构的程序，所以编译工具使用这个。</p><p>检查是否配置好环境</p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421142358791.png" alt="image-20210421142358791"></p><h3 id="5，openOCD"><a href="#5，openOCD" class="headerlink" title="5，openOCD"></a>5，openOCD</h3><p>OpenOCD是用于对STM32进行下载仿真的工具，是一个开源软件包，Windows版本下从这里下载，下载好解压到一个目录就行。</p><p>注意，添加环境变量</p><h3 id="6，CLion配置"><a href="#6，CLion配置" class="headerlink" title="6，CLion配置"></a>6，CLion配置</h3><p><strong>【重点】</strong></p><p>Clion是基于CMake来管理项目的，所以首选我们需要配置好预设的MinGW和CMake环境。</p><p>打开File-Settings-Build,Execution,Deployment选项卡，在Toolchains下面添加一个MinGW环境：</p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421192108480.png" alt="image-20210421192108480"></p><p>打开CMake选项栏查看工具链是否正确</p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421192217660.png" alt="image-20210421192217660"></p><p>至此Clion环境配置完成，可以创建STM32项目了。</p><h2 id="四，CLion使用"><a href="#四，CLion使用" class="headerlink" title="四，CLion使用"></a>四，CLion使用</h2><h3 id="1，STM32CubeMX创建工程模板"><a href="#1，STM32CubeMX创建工程模板" class="headerlink" title="1，STM32CubeMX创建工程模板"></a>1，STM32CubeMX创建工程模板</h3><p>这里创建一个普通的STM32Cube工程。</p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421192506773.png" alt="image-20210421192506773"></p><p>接下来由于 OpenOCD 报错 Error: init mode failed (unable to connect to the target)</p><hr><p>** OpenOCD init failed **</p><p>解决方法：这里是由于PA13和PA14被错误配置导致的。首先修复STM32CubeMX中的SYS设置，在SYS-Debug中选择Serial Wire。然后拉高Boot0和Boot1烧写一个正常固件，然后拉低他们，就能正常烧写了。</p><p>所以需要在MX中设置SYS</p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421192911551.png" alt="image-20210421192911551"></p><p>修改项目名称和Toolchain /IDE </p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193052041.png" alt="image-20210421193052041"></p><p>然后创建完成</p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193114717.png" alt="image-20210421193114717"></p><h3 id="2，通过CLion导入工程"><a href="#2，通过CLion导入工程" class="headerlink" title="2，通过CLion导入工程"></a>2，通过CLion导入工程</h3><p>通过CLion 导入此项目，直接Open打开即可</p><p>第一次进入，需要设置对应的单片机设置</p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193243099.png" alt="image-20210421193243099"></p><p>根据自己的单片机，选择最接近的型号</p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193312527.png" alt="image-20210421193312527"></p><p>然后 Copy to Project &amp; Use</p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193345457.png" alt="image-20210421193345457"></p><p>其中的内容原本为</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment"># This is an ST NUCLEO F103RB board with a single STM32F103RBT6 chip.</span><span class="hljs-comment"># http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF259875</span>source [<span class="hljs-builtin-name">find</span> interface/stlink.cfg]transport select hla_swdsource [<span class="hljs-builtin-name">find</span> target/stm32f1x.cfg]reset_config srst_only</code></pre></div><p>修改为</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment"># This is an ST NUCLEO F103RB board with a single STM32F103RBT6 chip.</span><span class="hljs-comment"># http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF259875</span>source [<span class="hljs-builtin-name">find</span> interface/stlink-v2.cfg]transport select hla_swdsource [<span class="hljs-builtin-name">find</span> target/stm32f1x.cfg]<span class="hljs-comment"># reset_config srst_only </span></code></pre></div><h3 id="3，调试"><a href="#3，调试" class="headerlink" title="3，调试"></a>3，调试</h3><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193854055.png" alt="image-20210421193854055"></p><p><img src="/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210421193935417.png" alt="image-20210421193935417"></p><p>出现** Programming Finished ** 就表示下载到开发板上了，不用管那些警告，只要不报错就OK！</p>]]></content:encoded>
      
      
      <category domain="https://pncalbl.github.io/categories/Help/">Help</category>
      
      <category domain="https://pncalbl.github.io/categories/Help/Win/">Win</category>
      
      
      
      <comments>https://pncalbl.github.io/2021/04/21/stm32cubemx+clion%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
