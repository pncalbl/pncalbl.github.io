

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon-t.png">
  <link rel="icon" href="/img/favicon-t.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="pncalbl">
  <meta name="keywords" content="计算机,开发,编程,代码,博客,技术">
  
  <title>Java 面试 - pncalbl</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"pncalbl.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/rss2.xml" title="pncalbl" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>pncalbl</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java 面试">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      pncalbl
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-30 00:00" pubdate>
        2021年7月30日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      49.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      608
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java 面试</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：12 天前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="第一部分-Java-并发编程"><a href="#第一部分-Java-并发编程" class="headerlink" title="第一部分 Java 并发编程"></a>第一部分 Java 并发编程</h1><h1 id="第1章-谈谈Volatile"><a href="#第1章-谈谈Volatile" class="headerlink" title="第1章 谈谈Volatile"></a>第1章 谈谈Volatile</h1><h2 id="1-Volatile和JMM内存模型的可见性"><a href="#1-Volatile和JMM内存模型的可见性" class="headerlink" title="1 Volatile和JMM内存模型的可见性"></a>1 Volatile和JMM内存模型的可见性</h2><ul>
<li>JUC（java.util.concurrent）<ul>
<li>进程和线程<ul>
<li>进程：后台运行的程序（我们打开的一个软件，就是进程）</li>
<li>线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）</li>
</ul>
</li>
<li>并发和并行<ul>
<li>并发：同时访问某个东西，就是并发</li>
<li>并行：一起做某些事情，就是并行</li>
</ul>
</li>
</ul>
</li>
<li>JUC下的三个包<ul>
<li>java.util.concurrent<ul>
<li>java.util.concurrent.atomic</li>
<li>java.util.concurrent.locks</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Volatile在日常的单线程环境是应用不到的</p>
<ul>
<li>Volatile是Java虚拟机提供的<code>轻量级</code>的同步机制（三大特性）<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ul>
</li>
</ul>
<h3 id="1-1-谈谈对Volatile的理解"><a href="#1-1-谈谈对Volatile的理解" class="headerlink" title="1.1 谈谈对Volatile的理解"></a>1.1 谈谈对Volatile的理解</h3><h3 id="1-2-JMM是什么"><a href="#1-2-JMM是什么" class="headerlink" title="1.2 JMM是什么"></a>1.2 JMM是什么</h3><p>JMM是Java内存模型，也就是Java Memory Model，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p>
<p>JMM关于同步的规定：</p>
<ul>
<li>线程解锁前，必须把共享变量的值刷新回主内存</li>
<li>线程加锁前，必须读取主内存的最新值，到自己的工作内存</li>
<li>加锁和解锁是同一把锁</li>
</ul>
<p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，<code>但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存</code>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309153225758.png" alt="image-20200309153225758"></p>
<p>数据传输速率：硬盘 &lt; 内存 &lt; &lt; cache &lt; CPU   </p>
<p>上面提到了两个概念：主内存  和 工作内存</p>
<ul>
<li><p>主内存：就是计算机的内存，也就是经常提到的8G内存，16G内存</p>
</li>
<li><p>工作内存：但我们实例化 new student，那么 age = 25 也是存储在主内存中</p>
<ul>
<li>当同时有三个线程同时访问 student中的age变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了变量的拷贝</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309154435933.png" alt="image-20200309154435933"></p>
</li>
</ul>
<p>即：JMM内存模型的可见性，指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p>
<h3 id="1-3-缓存一致性"><a href="#1-3-缓存一致性" class="headerlink" title="1.3 缓存一致性"></a>1.3 缓存一致性</h3><p>为什么这里主线程中某个值被更改后，其它线程能马上知晓呢？其实这里是用到了总线嗅探技术</p>
<p>在说嗅探技术之前，首先谈谈缓存一致性的问题，就是当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一。</p>
<p>为了解决缓存一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，这类协议主要有MSI、MESI等等。</p>
<h4 id="1-MESI"><a href="#1-MESI" class="headerlink" title="1 MESI"></a>1 MESI</h4><p>当CPU写数据时，如果发现操作的变量是共享变量，即在其它CPU中也存在该变量的副本，会发出信号通知其它CPU将该内存变量的缓存行设置为无效，因此当其它CPU读取这个变量的时，发现自己缓存该变量的缓存行是无效的，那么它就会从内存中重新读取。</p>
<h4 id="2-总线嗅探"><a href="#2-总线嗅探" class="headerlink" title="2 总线嗅探"></a>2 总线嗅探</h4><p>那么是如何发现数据是否失效呢？</p>
<p>这里是用到了总线嗅探技术，就是每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中。</p>
<h4 id="3-总线风暴"><a href="#3-总线风暴" class="headerlink" title="3 总线风暴"></a>3 总线风暴</h4><p>总线嗅探技术有哪些缺点？</p>
<p>由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和CAS循环，无效的交互会导致总线带宽达到峰值。因此不要大量使用volatile关键字，至于什么时候使用volatile、什么时候用锁以及Syschonized都是需要根据实际场景的。</p>
<h3 id="1-4-JMM的特性"><a href="#1-4-JMM的特性" class="headerlink" title="1.4 JMM的特性"></a>1.4 JMM的特性</h3><p>JMM的三大特性，volatile只保证了两个，即可见性和有序性，不满足原子性</p>
<ul>
<li>可见性</li>
<li>原子性</li>
<li>有序性</li>
</ul>
<h3 id="1-5-可见性代码验证"><a href="#1-5-可见性代码验证" class="headerlink" title="1.5 可见性代码验证"></a>1.5 可见性代码验证</h3><p>但我们对于成员变量没有添加任何修饰时，是无法感知其它线程修改后的值</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.moxi.interview.study.thread;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Volatile Java虚拟机提供的轻量级同步机制</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 可见性（及时通知）</span>
<span class="hljs-comment"> * 不保证原子性</span>
<span class="hljs-comment"> * 禁止指令重排</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 假设是主物理内存</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;

    <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 验证volatile的可见性</span>
<span class="hljs-comment"> * 1. 假设int number = 0， number变量之前没有添加volatile关键字修饰</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args [])</span> </span>&#123;

        <span class="hljs-comment">// 资源类</span>
        MyData myData = <span class="hljs-keyword">new</span> MyData();

        <span class="hljs-comment">// AAA线程 实现了Runnable接口的，lambda表达式</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in&quot;</span>);

            <span class="hljs-comment">// 线程睡眠3秒，假设在进行运算</span>
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-comment">// 修改number的值</span>
            myData.addTo60();

            <span class="hljs-comment">// 输出修改后的值</span>
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t update number value:&quot;</span> + myData.number);

        &#125;, <span class="hljs-string">&quot;AAA&quot;</span>).start();

        <span class="hljs-keyword">while</span>(myData.number == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// main线程就一直在这里等待循环，直到number的值不等于零</span>
        &#125;

        <span class="hljs-comment">// 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环</span>
        <span class="hljs-comment">// 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了</span>
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t mission is over&quot;</span>);

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 最后输出结果：</span>
<span class="hljs-comment">         * AAA	 come in</span>
<span class="hljs-comment">         * AAA	 update number value:60</span>
<span class="hljs-comment">         * 最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</span>
<span class="hljs-comment">         */</span>

    &#125;
&#125;</code></pre></div>

<p>输出结果为</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309162154191-1628001500488100.png" alt="image-20200309162154191">    </p>
<p>最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</p>
<p>当我们修改MyData类中的成员变量时，并且添加volatile关键字修饰</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 假设是主物理内存</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;
    &#125;
&#125;</code></pre></div>

<p>最后输出的结果为：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309162154191.png" alt="image-20200309162154191"></p>
<p>主线程也执行完毕了，说明volatile修饰的变量，是具备JVM轻量级同步机制的，能够感知其它线程的修改后的值。</p>
<h2 id="2-Volatile不保证原子性"><a href="#2-Volatile不保证原子性" class="headerlink" title="2 Volatile不保证原子性"></a>2 Volatile不保证原子性</h2><h3 id="2-1-前言"><a href="#2-1-前言" class="headerlink" title="2.1 前言"></a>2.1 前言</h3><p>通过前面对JMM的介绍，我们知道，各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后在写回到主内存中的。</p>
<p>这就可能存在一个线程AAA修改了共享变量X的值，但是还未写入主内存时，另外一个线程BBB又对主内存中同一共享变量X进行操作，但此时A线程工作内存中共享变量X对线程B来说是不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题。</p>
<h3 id="2-2-原子性"><a href="#2-2-原子性" class="headerlink" title="2.2 原子性"></a>2.2 原子性</h3><p>不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要具体完成，要么同时成功，要么同时失败。</p>
<p>数据库也经常提到事务具备原子性</p>
<h3 id="2-3-代码测试"><a href="#2-3-代码测试" class="headerlink" title="2.3 代码测试"></a>2.3 代码测试</h3><p>为了测试volatile是否保证原子性，我们创建了20个线程，然后每个线程分别循环1000次，来调用number++的方法</p>
<div class="code-wrapper"><pre><code class="hljs java">MyData myData = <span class="hljs-keyword">new</span> MyData();

<span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-comment">// 里面</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;
            myData.addPlusPlus();
        &#125;
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>最后通过 Thread.activeCount()，来感知20个线程是否执行完毕，这里判断线程数是否大于2，为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span>
<span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123;
    <span class="hljs-comment">// yield表示不执行</span>
    Thread.yield();
&#125;</code></pre></div>

<p>然后在线程执行完毕后，我们在查看number的值，假设volatile保证原子性的话，那么最后输出的值应该是</p>
<p>20 * 1000 = 20000,</p>
<p>完整代码如下所示：</p>
<div class="code-wrapper"><pre><code class="hljs java">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Volatile Java虚拟机提供的轻量级同步机制</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 可见性（及时通知）</span>
<span class="hljs-comment"> * 不保证原子性</span>
<span class="hljs-comment"> * 禁止指令重排</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 假设是主物理内存</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span> </span>&#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTo60</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.number = <span class="hljs-number">60</span>;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 注意，此时number 前面是加了volatile修饰</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;
        number ++;
    &#125;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 验证volatile的可见性</span>
<span class="hljs-comment"> * 1、 假设int number = 0， number变量之前没有添加volatile关键字修饰</span>
<span class="hljs-comment"> * 2、添加了volatile，可以解决可见性问题</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 验证volatile不保证原子性</span>
<span class="hljs-comment"> * 1、原子性指的是什么意思？</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args [])</span> </span>&#123;

        MyData myData = <span class="hljs-keyword">new</span> MyData();

        <span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                <span class="hljs-comment">// 里面</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;
                    myData.addPlusPlus();
                &#125;
            &#125;, String.valueOf(i)).start();
        &#125;

        <span class="hljs-comment">// 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span>
        <span class="hljs-comment">// 这里判断线程数是否大于2，为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</span>
        <span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123;
            <span class="hljs-comment">// yield表示不执行</span>
            Thread.yield();
        &#125;

        <span class="hljs-comment">// 查看最终的值</span>
        <span class="hljs-comment">// 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000</span>
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally number value: &quot;</span> + myData.number);

    &#125;
&#125;</code></pre></div>

<p>最终结果我们会发现，number输出的值并没有20000，而且是每次运行的结果都不一致的，这说明了volatile修饰的变量不保证原子性</p>
<p>第一次：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309172900462.png" alt="image-20200309172900462"></p>
<p>第二次：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309172919295.png" alt="image-20200309172919295"></p>
<p>第三次：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309172929820.png" alt="image-20200309172929820"></p>
<h3 id="2-4-为什么出现数值丢失"><a href="#2-4-为什么出现数值丢失" class="headerlink" title="2.4 为什么出现数值丢失"></a>2.4 为什么出现数值丢失</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309174220675.png" alt="image-20200309174220675"></p>
<p>各自线程在写入主内存的时候，出现了数据的丢失，而引起的数值缺失的问题</p>
<p>下面我们将一个简单的number++操作，转换为字节码文件一探究竟</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span> </span>&#123;
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;
        n++;
    &#125;
&#125;</code></pre></div>

<p>转换后的字节码文件</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">moxi</span>.<span class="hljs-title">interview</span>.<span class="hljs-title">study</span>.<span class="hljs-title">thread</span>.<span class="hljs-title">T1</span> </span>&#123;
  <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> n;

  <span class="hljs-keyword">public</span> com.moxi.interview.study.thread.T1();
    Code:
       <span class="hljs-number">0</span>: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
       <span class="hljs-number">4</span>: aload_0
       <span class="hljs-number">5</span>: iconst_0
       6: putfield      #2                  // Field n:I
       <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span>

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;
    Code:
       <span class="hljs-number">0</span>: aload_0
       <span class="hljs-number">1</span>: dup
       2: getfield      #2                  // Field n:I
       <span class="hljs-number">5</span>: iconst_1
       <span class="hljs-number">6</span>: iadd
       7: putfield      #2                  // Field n:I
      <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span>
&#125;</code></pre></div>

<p>这里查看字节码的操作，是用到了IDEA的javap命令</p>
<p>我们首先，使用IDEA提供的External Tools，来扩展javap命令</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309183026329.png" alt="image-20200309183026329"></p>
<p>完成上述操作后，我们在需要查看字节码的文件下，右键选择 External Tools即可</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309183115613.png" alt="image-20200309183115613"></p>
<p>如果出现了找不到指定类，那是因为我们创建的是spring boot的maven项目，我们之前需要执行mvn package命令，进行打包操作，将其编译成class文件</p>
<p>移动到底部，有一份字节码指令对照表，方便我们进行阅读</p>
<p>下面我们就针对 add() 这个方法的字节码文件进行分析</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;
  Code:
     <span class="hljs-number">0</span>: aload_0
     <span class="hljs-number">1</span>: dup
     2: getfield      #2    // Field n:I
     <span class="hljs-number">5</span>: iconst_1
     <span class="hljs-number">6</span>: iadd
     7: putfield      #2    // Field n:I
    <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span></code></pre></div>

<p>我们能够发现 n++这条命令，被拆分成了3个指令</p>
<ul>
<li>执行<code>getfield</code> 从主内存拿到原始n</li>
<li>执行<code>iadd</code> 进行加1操作</li>
<li>执行<code>putfileld</code> 把累加后的值写回主内存 </li>
</ul>
<p>假设我们没有加 <code>synchronized</code>那么第一步就可能存在着，三个线程同时通过getfield命令，拿到主存中的 n值，然后三个线程，各自在自己的工作内存中进行加1操作，但他们并发进行  <code>iadd</code> 命令的时候，因为只能一个进行写，所以其它操作会被挂起，假设1线程，先进行了写操作，在写完后，volatile的可见性，应该需要告诉其它两个线程，主内存的值已经被修改了，但是因为太快了，其它两个线程，陆续执行 <code>iadd</code>命令，进行写入操作，这就造成了其他线程没有接受到主内存n的改变，从而覆盖了原来的值，出现写丢失，这样也就让最终的结果少于20000</p>
<h3 id="2-5-如何解决"><a href="#2-5-如何解决" class="headerlink" title="2.5 如何解决"></a>2.5 如何解决</h3><p>因此这也说明，在多线程环境下 number ++ 在多线程环境下是非线程安全的，解决的方法有哪些呢？</p>
<ul>
<li>在方法上加入 synchronized</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPlusPlus</span><span class="hljs-params">()</span> </span>&#123;
	number ++;
&#125;</code></pre></div>

<p>运行结果：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309173315294.png" alt="image-20200309173315294"></p>
<p>我们能够发现引入synchronized关键字后，保证了该方法每次只能够一个线程进行访问和操作，最终输出的结果也就为20000</p>
<h3 id="2-6-其它解决方法"><a href="#2-6-其它解决方法" class="headerlink" title="2.6  其它解决方法"></a>2.6  其它解决方法</h3><p>上面的方法引入synchronized，虽然能够保证原子性，但是为了解决number++，而引入重量级的同步机制，有种 杀鸡焉用牛刀</p>
<p>除了引用synchronized关键字外，还可以使用JUC下面的原子包装类，即刚刚的int类型的number，可以使用AtomicInteger来代替</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">     *  创建一个原子Integer包装类，默认为0</span>
<span class="hljs-comment">      */</span>
AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtomic</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// 相当于 atomicInter ++</span>
    atomicInteger.getAndIncrement();
&#125;</code></pre></div>

<p>然后同理，继续刚刚的操作</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建10个线程，线程里面进行1000次循环</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        <span class="hljs-comment">// 里面</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;
            myData.addPlusPlus();
            myData.addAtomic();
        &#125;
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>最后输出</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000</span>
System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally number value: &quot;</span> + myData.number);
System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t finally atomicNumber value: &quot;</span> + myData.atomicInteger);</code></pre></div>

<p>下面的结果，一个是引入synchronized，一个是使用了原子包装类AtomicInteger</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200309205242622.png" alt="image-20200309205242622"></p>
<h2 id="3-Volatile禁止指令重排"><a href="#3-Volatile禁止指令重排" class="headerlink" title="3 Volatile禁止指令重排"></a>3 Volatile禁止指令重排</h2><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令重排，一般分为以下三种：</p>
<div class="code-wrapper"><pre><code class="hljs clean">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</code></pre></div>

<p>单线程环境里面确保最终执行结果和代码顺序的结果一致</p>
<p>处理器在进行重排序时，必须要考虑指令之间的<code>数据依赖性</code></p>
<p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p>
<h3 id="3-1-指令重排-example-1"><a href="#3-1-指令重排-example-1" class="headerlink" title="3.1 指令重排 - example 1"></a>3.1 指令重排 - example 1</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mySort</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">11</span>;
	<span class="hljs-keyword">int</span> y = <span class="hljs-number">12</span>;
	x = x + <span class="hljs-number">5</span>;
	y = x * x;
&#125;</code></pre></div>

<p>按照正常单线程环境，执行顺序是 1 2 3 4</p>
<p>但是在多线程环境下，可能出现以下的顺序：</p>
<ul>
<li>2 1 3 4</li>
<li>1 3 2 4 </li>
</ul>
<p>上述的过程就可以当做是指令的重排，即内部执行顺序，和我们的代码顺序不一样</p>
<p>但是指令重排也是有限制的，即不会出现下面的顺序</p>
<ul>
<li>4 3 2 1</li>
</ul>
<p>因为处理器在进行重排时候，必须考虑到指令之间的数据依赖性</p>
<p>因为步骤 4：需要依赖于 y的申明，以及x的申明，故因为存在数据依赖，无法首先执行</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>int a,b,x,y = 0</p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>x = a;</td>
<td>y = b;</td>
</tr>
<tr>
<td>b = 1;</td>
<td>a = 2;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>x = 0;  y = 0</td>
<td></td>
</tr>
</tbody></table>
<p>因为上面的代码，不存在数据的依赖性，因此编译器可能对数据进行重排</p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody><tr>
<td>b = 1;</td>
<td>a = 2;</td>
</tr>
<tr>
<td>x = a;</td>
<td>y = b;</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>x = 2;  y = 1</td>
<td></td>
</tr>
</tbody></table>
<p>这样造成的结果，和最开始的就不一致了，这就是导致重排后，结果和最开始的不一样，因此为了防止这种结果出现，volatile就规定禁止指令重排，为了保证数据的一致性</p>
<h3 id="3-2-指令重排-example-2"><a href="#3-2-指令重排-example-2" class="headerlink" title="3.2 指令重排 - example 2"></a>3.2 指令重排 - example 2</h3><p>比如下面这段代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * ResortSeqDemo</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResortSeqDemo</span> </span>&#123;
    <span class="hljs-keyword">int</span> a= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method01</span><span class="hljs-params">()</span> </span>&#123;
        a = <span class="hljs-number">1</span>;
        flag = <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method02</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(flag) &#123;
            a = a + <span class="hljs-number">5</span>;
            System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>我们按照正常的顺序，分别调用method01()  和 method02() 那么，最终输出就是 a = 6</p>
<p>但是如果在多线程环境下，因为方法1 和 方法2，他们之间不能存在数据依赖的问题，因此原先的顺序可能是</p>
<div class="code-wrapper"><pre><code class="hljs java">a = <span class="hljs-number">1</span>;
flag = <span class="hljs-keyword">true</span>;

a = a + <span class="hljs-number">5</span>;
System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);</code></pre></div>

<p>但是在经过编译器，指令，或者内存的重排后，可能会出现这样的情况</p>
<div class="code-wrapper"><pre><code class="hljs java">flag = <span class="hljs-keyword">true</span>;

a = a + <span class="hljs-number">5</span>;
System.out.println(<span class="hljs-string">&quot;reValue:&quot;</span> + a);

a = <span class="hljs-number">1</span>;</code></pre></div>

<p>也就是先执行 flag = true后，另外一个线程马上调用方法2，满足 flag的判断，最终让a + 5，结果为5，这样同样出现了数据不一致的问题</p>
<p>为什么会出现这个结果：多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p>
<p>这样就需要通过volatile来修饰，来保证线程安全性</p>
<h3 id="3-3-Volatile针对指令重排做了啥"><a href="#3-3-Volatile针对指令重排做了啥" class="headerlink" title="3.3 Volatile针对指令重排做了啥"></a>3.3 Volatile针对指令重排做了啥</h3><p>Volatile实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象</p>
<p>首先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：</p>
<ul>
<li>保证特定操作的顺序</li>
<li>保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</li>
</ul>
<p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说 <code>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</code>。 内存屏障另外一个作用是刷新出各种CPU的缓存数，因此任何CPU上的线程都能读取到这些数据的最新版本。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310162654437.png" alt="image-20200310162654437"></p>
<p>也就是过在Volatile的写 和 读的时候，加入屏障，防止出现指令重排的</p>
<h3 id="3-4-线程安全获得保证"><a href="#3-4-线程安全获得保证" class="headerlink" title="3.4 线程安全获得保证"></a>3.4 线程安全获得保证</h3><p>工作内存与主内存同步延迟现象导致的可见性问题</p>
<ul>
<li>可通过synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见</li>
</ul>
<p>对于指令重排导致的可见性问题和有序性问题</p>
<ul>
<li>可以使用volatile关键字解决，因为volatile关键字的另一个作用就是禁止重排序优化</li>
</ul>
<h3 id="3-5-总线嗅探"><a href="#3-5-总线嗅探" class="headerlink" title="3.5 总线嗅探"></a>3.5 总线嗅探</h3><h2 id="4-Volatile的应用"><a href="#4-Volatile的应用" class="headerlink" title="4 Volatile的应用"></a>4 Volatile的应用</h2><h3 id="单例模式DCL代码"><a href="#单例模式DCL代码" class="headerlink" title="单例模式DCL代码"></a>单例模式DCL代码</h3><p>首先回顾一下，单线程下的单例模式代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * SingletonDemo（单例模式）</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            instance = <span class="hljs-keyword">new</span> SingletonDemo();
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 这里的 == 是比较内存地址</span>
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());
    &#125;
&#125;</code></pre></div>

<p>最后输出的结果</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310164513408.png" alt="image-20200310164513408"></p>
<p>但是在多线程的环境下，我们的单例模式是否还是同一个对象了</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * SingletonDemo（单例模式）</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            instance = <span class="hljs-keyword">new</span> SingletonDemo();
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                SingletonDemo.getInstance();
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>从下面的结果我们可以看出，我们通过SingletonDemo.getInstance() 获取到的对象，并不是同一个，而是被下面几个线程都进行了创建，那么在多线程环境下，单例模式如何保证呢？</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310164720940.png" alt="image-20200310164720940"></p>
<h4 id="1-解决方法1"><a href="#1-解决方法1" class="headerlink" title="1 解决方法1"></a>1 解决方法1</h4><p>引入synchronized关键字</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
        instance = <span class="hljs-keyword">new</span> SingletonDemo();
    &#125;
    <span class="hljs-keyword">return</span> instance;
&#125;</code></pre></div>

<p>输出结果</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310164946940.png" alt="image-20200310164946940"></p>
<p>我们能够发现，通过引入Synchronized关键字，能够解决高并发环境下的单例模式问题</p>
<p>但是synchronized属于重量级的同步机制，它只允许一个线程同时访问获取实例的方法，但是为了保证数据一致性，而减低了并发性，因此采用的比较少</p>
<h4 id="2-解决方法2"><a href="#2-解决方法2" class="headerlink" title="2 解决方法2"></a>2 解决方法2</h4><p>通过引入DCL   Double Check Lock   双端检锁机制</p>
<p>就是在进来和出去的时候，进行检测</p>
<div class="code-wrapper"><pre><code class="hljs smali">public<span class="hljs-keyword"> static</span> SingletonDemo getInstance() &#123;
    if(instance == null) &#123;
        // 同步代码段的时候，进行检测
        synchronized (SingletonDemo.class) &#123;
            if(instance == null) &#123;
               <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>SingletonDemo();
            &#125;
        &#125;
    &#125;
   <span class="hljs-built_in"> return </span>instance;
&#125;</code></pre></div>

<p>最后输出的结果为：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310165703190.png" alt="image-20200310165703190"></p>
<p>从输出结果来看，确实能够保证单例模式的正确性，但是上面的方法还是存在问题的</p>
<p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入volatile可以禁止指令重排</p>
<p>原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象可能没有完成实例化。因为 instance = new SingletonDemo()；可以分为以下三步进行完成：</p>
<ul>
<li>memory = allocate();   // 1、分配对象内存空间</li>
<li>instance(memory);   // 2、初始化对象</li>
<li>instance = memory;  // 3、设置instance指向刚刚分配的内存地址，此时instance != null</li>
</ul>
<p>但是我们通过上面的三个步骤，能够发现，步骤2 和 步骤3之间不存在 数据依赖关系，而且无论重排前 还是重排后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。</p>
<ul>
<li>memory = allocate();   // 1、分配对象内存空间</li>
<li>instance = memory;  // 3、设置instance指向刚刚分配的内存地址，此时instance != null，但是对象还没有初始化完成</li>
<li>instance(memory);   // 2、初始化对象</li>
</ul>
<p>这样就会造成什么问题呢？</p>
<p>也就是当我们执行到重排后的步骤2，试图获取instance的时候，会得到null，因为对象的初始化还没有完成，而是在重排后的步骤3才完成，因此执行单例模式的代码时候，就会重新在创建一个instance实例</p>
<p><code>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</code></p>
<p>所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，这就造成了线程安全的问题</p>
<p>所以需要引入volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;</code></pre></div>

<h4 id="3-最终代码"><a href="#3-最终代码" class="headerlink" title="3 最终代码"></a>3 最终代码</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * SingletonDemo（单例模式）</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo instance = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span> <span class="hljs-params">()</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// a 双重检查加锁多线程情况下会出现某个线程虽然这里已经为空，但是另外一个线程已经执行到d处</span>
            <span class="hljs-keyword">synchronized</span> (SingletonDemo.class) <span class="hljs-comment">//b</span>
            &#123; 
           <span class="hljs-comment">//c不加volitale关键字的话有可能会出现尚未完全初始化就获取到的情况。原因是内存模型允许无序写入</span>
                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123; 
                	<span class="hljs-comment">// d 此时才开始初始化</span>
                    instance = <span class="hljs-keyword">new</span> SingletonDemo();
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> instance;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
<span class="hljs-comment">//        // 这里的 == 是比较内存地址</span>
<span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span>
<span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span>
<span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span>
<span class="hljs-comment">//        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                SingletonDemo.getInstance();
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<h1 id="第2章-CAS底层原理"><a href="#第2章-CAS底层原理" class="headerlink" title="第2章 CAS底层原理"></a>第2章 CAS底层原理</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>CAS的全称是Compare-And-Swap，它是CPU并发原语</p>
<p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的</p>
<p>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的。</p>
<h2 id="2-代码使用"><a href="#2-代码使用" class="headerlink" title="2 代码使用"></a>2 代码使用</h2><p>首先调用AtomicInteger创建了一个实例， 并初始化为5</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个原子类</span>
AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);</code></pre></div>

<p>然后调用CAS方法，企图更新成2019，这里有两个参数，一个是5，表示期望值，第二个就是我们要更新的值</p>
<div class="code-wrapper"><pre><code class="hljs java">atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>)</code></pre></div>

<p>然后再次使用了一个方法，同样将值改成1024</p>
<div class="code-wrapper"><pre><code class="hljs java">atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">1024</span>)</code></pre></div>

<p>完整代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * CASDemo</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 比较并交换：compareAndSet</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 创建一个原子类</span>
        AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span>
<span class="hljs-comment">         * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span>
<span class="hljs-comment">         */</span>
        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());

        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>, <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;\t current data: &quot;</span> + atomicInteger.get());
    &#125;
&#125;</code></pre></div>

<p>上面代码的执行结果为</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310201327734.png" alt="image-20200310201327734"></p>
<p>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，但是第二次后，主内存的值已经修改成了2019，不满足期望值，因此返回了false，本次写入失败</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310201311367.png" alt="image-20200310201311367"></p>
<p>这个就类似于SVN或者Git的版本号，如果没有人更改过，就能够正常提交，否者需要先将代码pull下来，合并代码后，然后提交</p>
<h2 id="3-CAS底层原理"><a href="#3-CAS底层原理" class="headerlink" title="3 CAS底层原理"></a>3 CAS底层原理</h2><p>首先我们先看看 atomicInteger.getAndIncrement()方法的源码</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310203030720-162800144543982.png" alt="image-20200310203030720"></p>
<p>从这里能够看到，底层又调用了一个unsafe类的getAndAddInt方法</p>
<h3 id="3-1-unsafe类"><a href="#3-1-unsafe类" class="headerlink" title="3.1 unsafe类"></a>3.1 unsafe类</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310203350122.png" alt="image-20200310203350122"></p>
<p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe类存在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中的CAS操作的执行依赖于Unsafe类的方法。</p>
<p><code>注意Unsafe类的所有方法都是native修饰的，也就是说unsafe类中的方法都直接调用操作系统底层资源执行相应的任务</code></p>
<p>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</p>
<h3 id="3-2-变量valueOffset"><a href="#3-2-变量valueOffset" class="headerlink" title="3.2 变量valueOffset"></a>3.2 变量valueOffset</h3><p>表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310203030720.png" alt="image-20200310203030720"></p>
<p>从这里我们能够看到，通过valueOffset，直接通过内存地址，获取到值，然后进行加1的操作</p>
<h3 id="3-3-变量value用volatile修饰"><a href="#3-3-变量value用volatile修饰" class="headerlink" title="3.3 变量value用volatile修饰"></a>3.3 变量value用volatile修饰</h3><p>保证了多线程之间的内存可见性</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200310210701761.png" alt="image-20200310210701761"></p>
<p>var5：就是我们从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值到自己的本地内存，然后执行compareAndSwapInt()在再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)</p>
<p>那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较</p>
<p>假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p>
<ul>
<li>val1：AtomicInteger对象本身</li>
<li>var2：该对象值得引用地址</li>
<li>var4：需要变动的数量</li>
<li>var5：用var1和var2找到的内存中的真实值<ul>
<li>用该对象当前的值与var5比较</li>
<li>如果相同，更新var5 + var4 并返回true</li>
<li>如果不同，继续取值然后再比较，直到更新完成</li>
</ul>
</li>
</ul>
<p>这里没有用synchronized，而用CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。</p>
<p>假设线程A和线程B同时执行getAndInt操作（分别跑在不同的CPU上）</p>
<ol>
<li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</li>
<li>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是线程A被挂起（该线程失去CPU执行权）</li>
<li>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B没有被挂起，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</li>
<li>这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4不一致，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行do while</li>
<li>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</li>
</ol>
<p>Unsafe类 + CAS思想： 也就是自旋，自我旋转</p>
<h2 id="4-底层汇编"><a href="#4-底层汇编" class="headerlink" title="4 底层汇编"></a>4 底层汇编</h2><p>Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于unsafe.cpp中</p>
<ul>
<li>先想办法拿到变量value在内存中的地址</li>
<li>通过Atomic::cmpxchg实现比较替换，其中参数X是即将更新的值，参数e是原内存的值</li>
</ul>
<h2 id="5-CAS缺点"><a href="#5-CAS缺点" class="headerlink" title="5 CAS缺点"></a>5 CAS缺点</h2><p>CAS不加锁，保证一次性，但是需要多次比较</p>
<ul>
<li>循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会无限循环）</li>
<li>只能保证一个共享变量的原子操作<ul>
<li>当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作</li>
<li>但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性</li>
</ul>
</li>
<li>引出来ABA问题？</li>
</ul>
<h2 id="6-ABA问题"><a href="#6-ABA问题" class="headerlink" title="6 ABA问题"></a>6 ABA问题</h2><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><h3 id="7-1-CAS"><a href="#7-1-CAS" class="headerlink" title="7.1 CAS"></a>7.1 CAS</h3><p>CAS是compareAndSwap，比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止</p>
<h3 id="7-2-CAS应用"><a href="#7-2-CAS应用" class="headerlink" title="7.2 CAS应用"></a>7.2 CAS应用</h3><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否者什么都不做</p>
<h1 id="第3章-原子类AtomicInteger的ABA问题"><a href="#第3章-原子类AtomicInteger的ABA问题" class="headerlink" title="第3章 原子类AtomicInteger的ABA问题"></a>第3章 原子类AtomicInteger的ABA问题</h1><h2 id="1-连环套路"><a href="#1-连环套路" class="headerlink" title="1 连环套路"></a>1 连环套路</h2><p>从AtomicInteger引出下面的问题</p>
<p>CAS -&gt; Unsafe -&gt; CAS底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避ABA问题</p>
<h2 id="2-ABA问题是什么"><a href="#2-ABA问题是什么" class="headerlink" title="2 ABA问题是什么"></a>2 ABA问题是什么</h2><p>狸猫换太子</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200311212442057.png" alt="image-20200311212442057"></p>
<p>假设现在有两个线程，分别是T1 和 T2，然后T1执行某个操作的时间为10秒，T2执行某个时间的操作是2秒，最开始AB两个线程，分别从主内存中获取A值，但是因为B的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了狸猫换太子。</p>
<p>所以ABA问题就是，在进行获取主内存值的时候，该内存值在我们写入主内存的时候，已经被修改了N次，但是最终又改成原来的值了</p>
<h2 id="3-CAS导致ABA问题"><a href="#3-CAS导致ABA问题" class="headerlink" title="3 CAS导致ABA问题"></a>3 CAS导致ABA问题</h2><p>CAS算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p>
<p>比如说一个线程one从内存位置V中取出A，这时候另外一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功</p>
<p><code>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的</code></p>
<h2 id="4-ABA问题"><a href="#4-ABA问题" class="headerlink" title="4 ABA问题"></a>4 ABA问题</h2><p>CAS只管开头和结尾，也就是头和尾是一样，那就修改成功，中间的这个过程，可能会被人修改过</p>
<h2 id="5-原子引用"><a href="#5-原子引用" class="headerlink" title="5 原子引用"></a>5 原子引用</h2><p>原子引用其实和原子包装类是差不多的概念，就是将一个java类，用原子引用类进行包装起来，那么这个类就具备了原子性</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 原子引用</span>
<span class="hljs-comment"> */</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;
    String userName;
    <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String userName, <span class="hljs-keyword">int</span> age)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.userName = userName;
        <span class="hljs-keyword">this</span>.age = age;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUserName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> userName;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserName</span><span class="hljs-params">(String userName)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.userName = userName;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> age;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.age = age;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +
                <span class="hljs-string">&quot;userName=&#x27;&quot;</span> + userName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, age=&quot;</span> + age +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReferenceDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        User z3 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;z3&quot;</span>, <span class="hljs-number">22</span>);

        User l4 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;l4&quot;</span>, <span class="hljs-number">25</span>);

        <span class="hljs-comment">// 创建原子引用包装类</span>
        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();

        <span class="hljs-comment">// 现在主物理内存的共享变量，为z3</span>
        atomicReference.set(z3);

        <span class="hljs-comment">// 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span>
        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());

        <span class="hljs-comment">// 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span>
        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="hljs-string">&quot;\t &quot;</span> + atomicReference.get().toString());
    &#125;
&#125;</code></pre></div>

<h3 id="5-1-基于原子引用的ABA问题"><a href="#5-1-基于原子引用的ABA问题" class="headerlink" title="5.1 基于原子引用的ABA问题"></a>5.1 基于原子引用的ABA问题</h3><p>我们首先创建了两个线程，然后T1线程，执行一次ABA的操作，T2线程在一秒后修改主内存的值</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * ABA问题的解决，AtomicStampedReference</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABADemo</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 普通的原子引用包装类</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);
            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());

        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p>我们发现，它能够成功的修改，这就是ABA问题</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312154752973.png" alt="image-20200312154752973"></p>
<h2 id="6-解决ABA问题"><a href="#6-解决ABA问题" class="headerlink" title="6 解决ABA问题"></a>6 解决ABA问题</h2><p>新增一种机制，也就是修改版本号，类似于时间戳的概念</p>
<p>T1：  100 1                      2019 2</p>
<p>T2：  100 1     101 2       100  3</p>
<p>如果T1修改的时候，版本号为2，落后于现在的版本号3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路</p>
<h2 id="7-AtomicStampedReference"><a href="#7-AtomicStampedReference" class="headerlink" title="7 AtomicStampedReference"></a>7 AtomicStampedReference</h2><p>时间戳原子引用，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及期望版本号和当前版本号</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * ABA问题的解决，AtomicStampedReference</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABADemo</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 普通的原子引用包装类</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">100</span>);

    <span class="hljs-comment">// 传递两个值，一个是初始值，一个是初始版本号</span>
    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的产生==========&quot;</span>);

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>);
            atomicReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>);
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 睡眠一秒，保证t1线程，完成了ABA操作</span>
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            <span class="hljs-comment">// 把100 改成 101 然后在改成100，也就是ABA</span>
            System.out.println(atomicReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>) + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.get());

        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();

        System.out.println(<span class="hljs-string">&quot;============以下是ABA问题的解决==========&quot;</span>);

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            <span class="hljs-comment">// 获取版本号</span>
            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);

            <span class="hljs-comment">// 暂停t3一秒钟</span>
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            <span class="hljs-comment">// 传入4个值，期望值，更新值，期望版本号，更新版本号</span>
            atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第二次版本号&quot;</span> + atomicStampedReference.getStamp());

            atomicStampedReference.compareAndSet(<span class="hljs-number">101</span>, <span class="hljs-number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+<span class="hljs-number">1</span>);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第三次版本号&quot;</span> + atomicStampedReference.getStamp());

        &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            <span class="hljs-comment">// 获取版本号</span>
            <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 第一次版本号&quot;</span> + stamp);

            <span class="hljs-comment">// 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span>
            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            <span class="hljs-keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="hljs-number">100</span>, <span class="hljs-number">2019</span>, stamp, stamp+<span class="hljs-number">1</span>);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 修改成功否：&quot;</span> + result + <span class="hljs-string">&quot;\t 当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 当前实际最新值&quot;</span> + atomicStampedReference.getReference());


        &#125;, <span class="hljs-string">&quot;t4&quot;</span>).start();

    &#125;
&#125;</code></pre></div>

<p>运行结果为：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312200434776.png" alt="image-20200312200434776"></p>
<p>我们能够发现，线程t3，在进行ABA操作后，版本号变更成了3，而线程t4在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样</p>
<h2 id="8-LongAdder（CAS机制优化）"><a href="#8-LongAdder（CAS机制优化）" class="headerlink" title="8 LongAdder（CAS机制优化）"></a>8 LongAdder（CAS机制优化）</h2><p>LongAdder是java8为我们提供的新的类，跟AtomicLong有相同的效果。是对CAS机制的优化</p>
<div class="code-wrapper"><pre><code class="hljs axapta">LongAdder：
<span class="hljs-comment">//变量声明</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LongAdder <span class="hljs-keyword">count</span> = <span class="hljs-keyword">new</span> LongAdder();
<span class="hljs-comment">//变量操作</span>
<span class="hljs-keyword">count</span>.increment();
<span class="hljs-comment">//变量取值</span>
<span class="hljs-keyword">count</span></code></pre></div>

<h3 id="为什么有了AtomicLong还要新增一个LongAdder呢"><a href="#为什么有了AtomicLong还要新增一个LongAdder呢" class="headerlink" title="为什么有了AtomicLong还要新增一个LongAdder呢"></a>为什么有了AtomicLong还要新增一个LongAdder呢</h3><p>原因是：CAS底层实现是在一个死循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功率很高，否则失败率很高。在失败的时候，这些重复的原子性操作会耗费性能。（不停的<strong>自旋</strong>，进入一个无限重复的循环中）</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429085540554.png" alt="image-20200429085540554"></p>
<p><strong>核心思想：将热点数据分离。</strong></p>
<p>比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。这相当于将AtomicLong的单点的更新压力分担到各个节点上。在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。而在高并发的时候通过分散提高了性能。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;
    add(<span class="hljs-number">1L</span>);
&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;
    Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;
    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;
        <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||
            (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||
            !(uncontended = a.cas(v = a.value, v + x)))
            longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);
    &#125;
&#125;</code></pre></div>

<p>但是这个CAS有没有问题呢？肯定是有的。比如说大量的线程同时并发修改一个AtomicInteger，可能有<strong>很多线程会不停的自旋</strong>，进入一个无限重复的循环中。</p>
<p>这些线程不停地获取值，然后发起CAS操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起CAS操作又失败了，再次进入下一个循环。</p>
<p>在大量线程高并发更新AtomicInteger的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。</p>
<p>于是，当当当当，Java 8推出了一个新的类，<strong>LongAdder</strong>，他就是尝试使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能！</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429085141487.png" alt="image-20200429085141487"></p>
<p>在LongAdder的底层实现中，首先有一个base值，刚开始多线程来不停的累加数值，都是对base进行累加的，比如刚开始累加成了base = 5。</p>
<p>接着如果发现并发更新的线程数量过多，在发生竞争的情况下，会有一个Cell数组用于将不同线程的操作离散到不同的节点上去 ==(会根据需要扩容，最大为CPU核）==就会开始施行<strong>分段CAS的机制</strong>，也就是内部会搞一个Cell数组，每个数组是一个数值分段。</p>
<p>这时，让大量的线程分别去对不同Cell内部的value值进行CAS累加操作，这样就把CAS计算压力分散到了不同的Cell分段数值中了！</p>
<p>这样就可以大幅度的降低多线程并发更新同一个数值时出现的无限循环的问题，大幅度提升了多线程并发更新数值的性能和效率！</p>
<p>而且他内部实现了<strong>自动分段迁移的机制</strong>，也就是如果某个Cell的value执行CAS失败了，那么就会自动去找另外一个Cell分段内的value值进行CAS操作。</p>
<p>这样也解决了线程空旋转、自旋不停等待执行CAS操作的问题，让一个线程过来执行CAS时可以尽快的完成这个操作。</p>
<p>最后，如果你要从LongAdder中获取当前累加的总值，就会把base值和所有Cell分段数值加起来返回给你。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429085957778.png" alt="image-20200429085957778"></p>
<p>如上图所示，LongAdder则是内部维护多个Cell变量，每个Cell里面有一个初始值为0的long型变量，在同等并发量的情况下，争夺单个变量的线程会减少，这是变相的减少了争夺共享资源的并发量，另外多个线程在争夺同一个原子变量时候，</p>
<p>如果失败并不是自旋CAS重试，而是尝试获取其他原子变量的锁，最后当获取当前值时候是把所有变量的值累加后再加上base的值返回的。</p>
<p>LongAdder维护了要给延迟初始化的原子性更新数组和一个基值变量base数组的大小保持是2的N次方大小，数组表的下标使用每个线程的hashcode值的掩码表示，数组里面的变量实体是Cell类型。</p>
<p>Cell 类型是Atomic的一个改进，用来减少缓存的争用，对于大多数原子操作字节填充是浪费的，因为原子操作都是无规律的分散在内存中进行的，多个原子性操作彼此之间是没有接触的，但是原子性数组元素彼此相邻存放将能经常共享缓存行，也就是<strong>伪共享</strong>。所以这在性能上是一个提升。（补充：可以看到Cell类用Contended注解修饰，这里主要是解决false sharing(伪共享的问题)，不过个人认为伪共享翻译的不是很好，或者应该是错误的共享，比如两个volatile变量被分配到了同一个缓存行，但是这两个的更新在高并发下会竞争，比如线程A去更新变量a，线程B去更新变量b，但是这两个变量被分配到了同一个缓存行，因此会造成每个线程都去争抢缓存行的所有权，例如A获取了所有权然后执行更新这时由于volatile的语义会造成其刷新到主存，但是由于变量b也被缓存到同一个缓存行，因此就会造成cache miss，这样就会造成极大的性能损失）<br><strong>LongAdder的add操作图</strong></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429090249633.png" alt="image-20200429090249633"></p>
<p>可以看到，只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。<br>如果Cell[]数组未初始化，会调用父类的longAccumelate去初始化Cell[]，如果Cell[]已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对Cell[]扩容了。<br><strong>另外由于Cells占用内存是相对比较大的，所以一开始并不创建，而是在需要时候再创建，也就是惰性加载，当一开始没有空间时候，所有的更新都是操作base变量。</strong></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429090556928.png" alt="image-20200429090556928"></p>
<p>如上图代码：<br>例如32、64位操作系统的缓存行大小不一样，因此JAVA8中就增加了一个注<code>@sun.misc.Contended</code>解用于解决这个问题,由JVM去插入这些变量，<a target="_blank" rel="noopener" href="http://xn--openjdk-hc5k25at0ntqhnpa7548b.java.net/jeps/142">具体可以参考openjdk.java.net/jeps/142</a> ，但是通常来说对象是不规则的分配到内存中的，但是数组由于是连续的内存，因此可能会共享缓存行，因此这里加一个Contended注解以防cells数组发生伪共享的情况。</p>
<p>为了降低高并发下多线程对一个变量CAS争夺失败后大量线程会自旋而造成降低并发性能问题，LongAdder内部通过根据并发请求量来维护多个Cell元素(一个动态的Cell数组)来分担对单个变量进行争夺资源。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200429090713078.png" alt="image-20200429090713078"></p>
<p>可以看到LongAdder继承自Striped64类，Striped64内部维护着三个变量，LongAdder的真实值其实就是base的值与Cell数组里面所有Cell元素值的累加，base是个基础值，默认是0，cellBusy用来实现自旋锁，当创建Cell元素或者扩容Cell数组时候用来进行线程间的同步。</p>
<p>在无竞争下直接更新base，类似AtomicLong高并发下，会将每个线程的操作hash到不同的cells数组中，从而将AtomicLong中更新一个value的行为优化之后，分散到多个value中<br>从而降低更新热点，而需要得到当前值的时候，直接 将所有cell中的value与base相加即可，但是跟AtomicLong(compare and change -&gt; xadd)的CAS不同，incrementAndGet操作及其变种可以返回更新后的值，而LongAdder返回的是void。</p>
<p>由于Cell相对来说比较占内存，因此这里采用懒加载的方式，在无竞争的情况下直接更新base域，在第一次发生竞争的时候(CAS失败)就会创建一个大小为2的cells数组，每次扩容都是加倍，只到达到CPU核数。同时我们知道扩容数组等行为需要只能有一个线程同时执行，因此需要一个锁，这里通过CAS更新cellsBusy来实现一个简单的spin lock。</p>
<p>数组访问索引是通过Thread里的threadLocalRandomProbe域取模实现的，这个域是ThreadLocalRandom更新的，cells的数组大小被限制为CPU的核数，因为即使有超过核数个线程去更新，但是每个线程也只会和一个CPU绑定，更新的时候顶多会有cpu核数个线程，因此我们只需要通过hash将不同线程的更新行为离散到不同的slot即可。<br>我们知道线程、线程池会被关闭或销毁，这个时候可能这个线程之前占用的slot就会变成没人用的，但我们也不能清除掉，因为一般web应用都是长时间运行的，线程通常也会动态创建、销毁，很可能一段时间后又会被其他线程占用，而对于短时间运行的，例如单元测试，清除掉有啥意义呢？</p>
<h1 id="第4章-Collection线程不安全的举例"><a href="#第4章-Collection线程不安全的举例" class="headerlink" title="第4章 Collection线程不安全的举例"></a>第4章 Collection线程不安全的举例</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>1、当我们执行下面语句的时候，底层进行了什么操作</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</code></pre></div>

<p>底层创建了一个空的数组，伴随着初始值为10</p>
<p>当执行add方法后，如果超过了10，那么会进行扩容，扩容的大小为原值的一半，也就是5个，使用下列方法扩容</p>
<div class="code-wrapper"><pre><code class="hljs java">Arrays.copyOf(elementData, netCapacity)</code></pre></div>

<h2 id="2-单线程环境下"><a href="#2-单线程环境下" class="headerlink" title="2 单线程环境下"></a>2 单线程环境下</h2><p>单线程环境的ArrayList是不会有问题的</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        list.add(<span class="hljs-string">&quot;a&quot;</span>);
        list.add(<span class="hljs-string">&quot;b&quot;</span>);
        list.add(<span class="hljs-string">&quot;c&quot;</span>);

        <span class="hljs-keyword">for</span>(String element : list) &#123;
            System.out.println(element);
        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="3-多线程环境"><a href="#3-多线程环境" class="headerlink" title="3 多线程环境"></a>3 多线程环境</h2><p>为什么ArrayList是线程不安全的？因为在进行写操作的时候，方法上为了保证并发性，是没有添加synchronized修饰，所以并发写的时候，就会出现问题</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312202720715.png" alt="image-20200312202720715"></p>
<p>当我们同时启动30个线程去操作List的时候</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 集合类线程不安全举例</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListNotSafeDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));
                System.out.println(list);
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>这个时候出现了错误，也就是java.util.ConcurrentModificationException</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312205142763.png" alt="image-20200312205142763"></p>
<p>这个异常是 并发修改的异常</p>
<h2 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5 解决方案"></a>5 解决方案</h2><h3 id="5-1-方案一：Vector"><a href="#5-1-方案一：Vector" class="headerlink" title="5.1 方案一：Vector"></a>5.1 方案一：Vector</h3><p>第一种方法，就是不用ArrayList这种不安全的List实现类，而采用Vector，线程安全的</p>
<p>关于Vector如何实现线程安全的，而是在方法上加了锁，即synchronized</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312210401865.png" alt="image-20200312210401865"></p>
<p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，导致并发性基于下降</p>
<h3 id="5-2-方案二：Collections-synchronized"><a href="#5-2-方案二：Collections-synchronized" class="headerlink" title="5.2 方案二：Collections.synchronized()"></a>5.2 方案二：Collections.synchronized()</h3><div class="code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list = Collections.synchronizedList(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());</code></pre></div>

<p>采用Collections集合工具类，在ArrayList外面包装一层 同步 机制</p>
<h3 id="5-3-方案三：采用JUC里面的方法"><a href="#5-3-方案三：采用JUC里面的方法" class="headerlink" title="5.3 方案三：采用JUC里面的方法"></a>5.3 方案三：采用JUC里面的方法</h3><p>CopyOnWriteArrayList：写时复制，主要是一种读写分离的思想</p>
<p>写时复制，CopyOnWrite容器即写时复制的容器，往一个容器中添加元素的时候，不直接往当前容器Object[]添加，而是先将Object[]进行copy，复制出一个新的容器object[] newElements，然后新的容器Object[] newElements里添加原始，添加元素完后，在将原容器的引用指向新的容器 setArray(newElements)；这样做的好处是可以对copyOnWrite容器进行并发的读 ，而不需要加锁，因为当前容器不需要添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p>
<p>就是写的时候，把ArrayList扩容一个出来，然后把值填写上去，在通知其他的线程，ArrayList的引用指向扩容后的</p>
<p>查看底层add方法源码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        Object[] elements = getArray();
        <span class="hljs-keyword">int</span> len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);
        newElements[len] = e;
        setArray(newElements);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;</code></pre></div>

<p>首先需要加锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
lock.lock();</code></pre></div>

<p>然后在末尾扩容一个单位</p>
<div class="code-wrapper"><pre><code class="hljs java">Object[] elements = getArray();
<span class="hljs-keyword">int</span> len = elements.length;
Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);</code></pre></div>

<p>然后在把扩容后的空间，填写上需要add的内容</p>
<div class="code-wrapper"><pre><code class="hljs java">newElements[len] = e;</code></pre></div>

<p>最后把内容set到Array中</p>
<h2 id="6-HashSet线程不安全"><a href="#6-HashSet线程不安全" class="headerlink" title="6 HashSet线程不安全"></a>6 HashSet线程不安全</h2><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>底层还是使用CopyOnWriteArrayList进行实例化</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312221602095.png" alt="image-20200312221602095"></p>
<h3 id="HashSet底层结构"><a href="#HashSet底层结构" class="headerlink" title="HashSet底层结构"></a>HashSet底层结构</h3><p>同理HashSet的底层结构就是HashMap</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200312221735178.png" alt="image-20200312221735178"></p>
<p>但是为什么我调用 HashSet.add()的方法，只需要传递一个元素，而HashMap是需要传递key-value键值对？</p>
<p>首先我们查看hashSet的add方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;
	<span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;
&#125;</code></pre></div>

<p>我们能发现但我们调用add的时候，存储一个值进入map中，只是作为key进行存储，而value存储的是一个Object类型的常量，也就是说HashSet只关心key，而不关心value</p>
<h2 id="7-HashMap线程不安全"><a href="#7-HashMap线程不安全" class="headerlink" title="7 HashMap线程不安全"></a>7 HashMap线程不安全</h2><p>同理HashMap在多线程环境下，也是不安全的</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));
            System.out.println(map);
        &#125;, String.valueOf(i)).start();
    &#125;
&#125;</code></pre></div>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>1、使用Collections.synchronizedMap(new HashMap&lt;&gt;());</p>
<p>2、使用 ConcurrentHashMap</p>
<div class="code-wrapper"><pre><code class="hljs java">Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();</code></pre></div>

<h1 id="第5章-值传递和引用传递"><a href="#第5章-值传递和引用传递" class="headerlink" title="第5章 值传递和引用传递"></a>第5章 值传递和引用传递</h1><h2 id="1-举例"><a href="#1-举例" class="headerlink" title="1 举例"></a>1 举例</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 值传递和引用传递</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">private</span> Integer id;
    <span class="hljs-keyword">private</span> String personName;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String personName)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.personName = personName;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferValueDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;
        age = <span class="hljs-number">30</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue2</span><span class="hljs-params">(Person person)</span> </span>&#123;
        person.setPersonName(<span class="hljs-string">&quot;XXXX&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeValue3</span><span class="hljs-params">(String str)</span> </span>&#123;
        str = <span class="hljs-string">&quot;XXX&quot;</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        TransferValueDemo test = <span class="hljs-keyword">new</span> TransferValueDemo();

        <span class="hljs-comment">// 定义基本数据类型</span>
        <span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;
        test.changeValue1(age);
        System.out.println(<span class="hljs-string">&quot;age ----&quot;</span> + age);

        <span class="hljs-comment">// 实例化person类</span>
        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;abc&quot;</span>);
        test.changeValue2(person);
        System.out.println(<span class="hljs-string">&quot;personName-----&quot;</span> + person.getPersonName());

        <span class="hljs-comment">// String</span>
        String str = <span class="hljs-string">&quot;abc&quot;</span>;
        test.changeValue3(str);
        System.out.println(<span class="hljs-string">&quot;string-----&quot;</span> + str);

    &#125;
&#125;</code></pre></div>

<p>最后输出结果</p>
<div class="code-wrapper"><pre><code class="hljs shell">age ----20
personName-----XXXX
string-----abc</code></pre></div>

<h2 id="2-changeValue1的执行过程"><a href="#2-changeValue1的执行过程" class="headerlink" title="2 changeValue1的执行过程"></a>2 changeValue1的执行过程</h2><p>八种基本数据类型，在栈里面分配内存，属于值传递</p>
<p><code>栈管运行，堆管存储</code></p>
<p>当们执行 changeValue1的时候，因为int是基本数据类型，所以传递的是int = 20这个值，相当于传递的是一个副本，main方法里面的age并没有改变，因此输出的结果 age还是20，属于值传递</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200314185317851.png" alt="image-20200314185317851"></p>
<h2 id="3-changeValue2的执行过程"><a href="#3-changeValue2的执行过程" class="headerlink" title="3 changeValue2的执行过程"></a>3 changeValue2的执行过程</h2><p>因为Person是属于对象，传递的是内存地址，当执行changeValue2的时候，会改变内存中的Person的值，属于引用传递，两个指针都是指向同一个地址</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200314185528034.png" alt="image-20200314185528034"></p>
<h2 id="4-changeValue3的执行过程"><a href="#4-changeValue3的执行过程" class="headerlink" title="4 changeValue3的执行过程"></a>4 changeValue3的执行过程</h2><p>String不属于基本数据类型，但是为什么执行完成后，还是abc呢？</p>
<p>这是因为String的特殊性，当我们执行String str = “abc”的时候，它会把 <code>abc</code> 放入常量池中</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200314190021466.png" alt="image-20200314190021466"></p>
<p>当我们执行changeValue3的时候，会重新新建一个xxx，并没有销毁abc，然后指向xxx，然后最后我们输出的是main中的引用，还是指向的abc，因此最后输出结果还是abc</p>
<h1 id="第6章-Lock"><a href="#第6章-Lock" class="headerlink" title="第6章 Lock"></a>第6章 Lock</h1><h2 id="1-Java锁之公平锁和非公平锁"><a href="#1-Java锁之公平锁和非公平锁" class="headerlink" title="1 Java锁之公平锁和非公平锁"></a>1 Java锁之公平锁和非公平锁</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列</p>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）</p>
<h3 id="1-2-如何创建"><a href="#1-2-如何创建" class="headerlink" title="1.2 如何创建"></a>1.2 如何创建</h3><p>并发包中ReentrantLock的创建可以指定析构函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span>
<span class="hljs-comment">*/</span>
Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);</code></pre></div>

<h3 id="1-3-两者区别"><a href="#1-3-两者区别" class="headerlink" title="1.3 两者区别"></a>1.3 两者区别</h3><p><strong>公平锁</strong>：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后安装FIFO的规则从队列中取到自己</p>
<p><strong>非公平锁：</strong> 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p>
<h3 id="1-4-题外话"><a href="#1-4-题外话" class="headerlink" title="1.4 题外话"></a>1.4 题外话</h3><p>Java ReenttrantLock通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于吞吐量比公平锁大，<code>对于synchronized而言，也是一种非公平锁</code></p>
<h2 id="2-可重入锁和递归锁ReentrantLock"><a href="#2-可重入锁和递归锁ReentrantLock" class="headerlink" title="2 可重入锁和递归锁ReentrantLock"></a>2 可重入锁和递归锁ReentrantLock</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>可重入锁就是递归锁</p>
<p>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</p>
<p>也就是说：<code>线程可以进入任何一个它已经拥有的锁所同步的代码块</code></p>
<p>ReentrantLock / Synchronized 就是一个典型的可重入锁</p>
<h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><p>可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是同一把锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;
	method2();
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;

&#125;</code></pre></div>

<p>也就是说我们只需要进入method1后，那么它也能直接进入method2方法，因为他们所拥有的锁，是同一把。</p>
<h3 id="2-3-作用"><a href="#2-3-作用" class="headerlink" title="2.3 作用"></a>2.3 作用</h3><p>可重入锁的最大作用就是避免死锁</p>
<h3 id="2-4-可重入锁验证"><a href="#2-4-可重入锁验证" class="headerlink" title="2.4 可重入锁验证"></a>2.4 可重入锁验证</h3><h4 id="证明Synchronized"><a href="#证明Synchronized" class="headerlink" title="证明Synchronized"></a>证明Synchronized</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 可重入锁（也叫递归锁）</span>
<span class="hljs-comment"> * 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 也就是说：`线程可以进入任何一个它已经拥有的锁所同步的代码块`</span>
<span class="hljs-comment"> */</span>

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 发送短信</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSMS</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t invoked sendSMS()&quot;</span>);

        <span class="hljs-comment">// 在同步方法中，调用另外一个同步方法</span>
        sendEmail();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 发邮件</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendEmail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        System.out.println(Thread.currentThread().getId() + <span class="hljs-string">&quot;\t invoked sendEmail()&quot;</span>);
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Phone phone = <span class="hljs-keyword">new</span> Phone();

        <span class="hljs-comment">// 两个线程操作资源列</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                phone.sendSMS();
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                phone.sendSMS();
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p>在这里，我们编写了一个资源类phone，拥有两个加了synchronized的同步方法，分别是sendSMS 和 sendEmail，我们在sendSMS方法中，调用sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：</p>
<div class="code-wrapper"><pre><code class="hljs shell">t1	 invoked sendSMS()
t1	 invoked sendEmail()
t2	 invoked sendSMS()
t2	 invoked sendEmail()</code></pre></div>

<p>这就说明当 t1 线程进入sendSMS的时候，拥有了一把锁，同时t2线程无法进入，直到t1线程拿着锁，执行了sendEmail 方法后，才释放锁，这样t2才能够进入</p>
<div class="code-wrapper"><pre><code class="hljs shell">t1	 invoked sendSMS()      t1线程在外层方法获取锁的时候
t1	 invoked sendEmail()    t1在进入内层方法会自动获取锁

t2	 invoked sendSMS()      t2线程在外层方法获取锁的时候
t2	 invoked sendEmail()    t2在进入内层方法会自动获取锁</code></pre></div>

<h4 id="证明ReentrantLock"><a href="#证明ReentrantLock" class="headerlink" title="证明ReentrantLock"></a>证明ReentrantLock</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;

    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * set进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);
            setLock();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLock</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t set Lock&quot;</span>);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        getLock();
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenterLockDemo</span> </span>&#123;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Phone phone = <span class="hljs-keyword">new</span> Phone();

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 因为Phone实现了Runnable接口</span>
<span class="hljs-comment">         */</span>
        Thread t3 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t3&quot;</span>);
        Thread t4 = <span class="hljs-keyword">new</span> Thread(phone, <span class="hljs-string">&quot;t4&quot;</span>);
        t3.start();
        t4.start();
    &#125;
&#125;
</code></pre></div>

<p>现在我们使用ReentrantLock进行验证，首先资源类实现了Runnable接口，重写Run方法，里面调用get方法，get方法在进入的时候，就加了锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);
        setLock();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;</code></pre></div>

<p>然后在方法里面，又调用另外一个加了锁的setLock方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLock</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t set Lock&quot;</span>);
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;</code></pre></div>

<p>最后输出结果我们能发现，结果和加synchronized方法是一致的，都是在外层的方法获取锁之后，线程能够直接进入里层</p>
<div class="code-wrapper"><pre><code class="hljs shell">t3	 get Lock
t3	 set Lock
t4	 get Lock
t4	 set Lock</code></pre></div>

<p><strong>当我们在getLock方法加两把锁会是什么情况呢？</strong>  (阿里面试)</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);
        setLock();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
        lock.unlock();
    &#125;
&#125;</code></pre></div>

<p>最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是同一把锁，也就是说用同一个钥匙都能够打开</p>
<p><strong>当我们在getLock方法加两把锁，但是只解一把锁会出现什么情况呢？</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);
        setLock();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
        lock.unlock();
    &#125;
&#125;</code></pre></div>
<p>得到结果</p>
<div class="code-wrapper"><pre><code class="hljs pgsql">t3	 <span class="hljs-keyword">get</span> <span class="hljs-keyword">Lock</span>
t3	 <span class="hljs-keyword">set</span> <span class="hljs-keyword">Lock</span></code></pre></div>

<p>也就是说程序直接卡死，线程不能出来，也就说明我们申请几把锁，最后需要解除几把锁</p>
<p><strong>当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢？</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLock</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t get Lock&quot;</span>);
        setLock();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
        lock.unlock();
    &#125;
&#125;</code></pre></div>

<p>这个时候，运行程序会直接报错</p>
<div class="code-wrapper"><pre><code class="hljs shell">t3	 get Lock
t3	 set Lock
t4	 get Lock
t4	 set Lock
Exception in thread &quot;t3&quot; Exception in thread &quot;t4&quot; java.lang.IllegalMonitorStateException
	at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)
	at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)
	at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)
	at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)
	at java.lang.Thread.run(Thread.java:745)
java.lang.IllegalMonitorStateException
	at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)
	at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)
	at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)
	at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)
	at java.lang.Thread.run(Thread.java:745)</code></pre></div>

<h2 id="3-Java锁之自旋锁"><a href="#3-Java锁之自旋锁" class="headerlink" title="3 Java锁之自旋锁"></a>3 Java锁之自旋锁</h2><p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>
<p>原来提到的比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200315154143781.png" alt="image-20200315154143781"></p>
<h3 id="3-1-优缺点"><a href="#3-1-优缺点" class="headerlink" title="3.1 优缺点"></a>3.1 优缺点</h3><p>优点：循环比较获取直到成功为止，没有类似于wait的阻塞</p>
<p>缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源</p>
<h3 id="3-2-手写自旋锁"><a href="#3-2-手写自旋锁" class="headerlink" title="3.2 手写自旋锁"></a>3.2 手写自旋锁</h3><p>通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到</p>
<div class="code-wrapper"><pre><code class="hljs java">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 手写一个自旋锁</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 循环比较获取直到成功为止，没有类似于wait的阻塞</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLockDemo</span> </span>&#123;

    <span class="hljs-comment">// 现在的泛型装的是Thread，原子引用线程</span>
    AtomicReference&lt;Thread&gt;  atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myLock</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 获取当前进来的线程</span>
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in &quot;</span>);

        <span class="hljs-comment">// 开始自旋，期望值是null，更新值是当前线程，如果是null，则更新为当前线程，否者自旋</span>
        <span class="hljs-keyword">while</span>(!atomicReference.compareAndSet(<span class="hljs-keyword">null</span>, thread)) &#123;

        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 解锁</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myUnLock</span><span class="hljs-params">()</span> </span>&#123;

        <span class="hljs-comment">// 获取当前进来的线程</span>
        Thread thread = Thread.currentThread();

        <span class="hljs-comment">// 自己用完了后，把atomicReference变成null</span>
        atomicReference.compareAndSet(thread, <span class="hljs-keyword">null</span>);

        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t invoked myUnlock()&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        SpinLockDemo spinLockDemo = <span class="hljs-keyword">new</span> SpinLockDemo();

        <span class="hljs-comment">// 启动t1线程，开始操作</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            <span class="hljs-comment">// 开始占有锁</span>
            spinLockDemo.myLock();


            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            <span class="hljs-comment">// 开始释放锁</span>
            spinLockDemo.myUnLock();

        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();


        <span class="hljs-comment">// 让main线程暂停1秒，使得t1线程，先执行</span>
        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        <span class="hljs-comment">// 1秒后，启动t2线程，开始占用这个锁</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            <span class="hljs-comment">// 开始占有锁</span>
            spinLockDemo.myLock();
            <span class="hljs-comment">// 开始释放锁</span>
            spinLockDemo.myUnLock();

        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();

    &#125;
&#125;</code></pre></div>

<p>最后输出结果</p>
<div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">t1</span> <span class="hljs-variable">come</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span>
.....一秒后.....
<span class="hljs-variable">t2</span> <span class="hljs-variable">come</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span>
.....五秒后.....
<span class="hljs-variable">t1</span> <span class="hljs-variable">invoked</span> <span class="hljs-function"><span class="hljs-title">myUnlock</span>()</span>
<span class="hljs-variable">t2</span> <span class="hljs-variable">invoked</span> <span class="hljs-function"><span class="hljs-title">myUnlock</span>()</span></code></pre></div>

<p>首先输出的是 t1     come in </p>
<p>然后1秒后，t2线程启动，发现锁被t1占有，所有不断的执行 compareAndSet方法，来进行比较，直到t1释放锁后，也就是5秒后，t2成功获取到锁，然后释放</p>
<h2 id="4-独占锁（写锁）-共享锁（读锁）-互斥锁"><a href="#4-独占锁（写锁）-共享锁（读锁）-互斥锁" class="headerlink" title="4 独占锁（写锁） / 共享锁（读锁） / 互斥锁"></a>4 独占锁（写锁） / 共享锁（读锁） / 互斥锁</h2><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁</p>
<p>共享锁：指该锁可以被多个线程锁持有</p>
<p>对ReentrantReadWriteLock其读锁是共享，其写锁是独占</p>
<p>写的时候只能一个人写，但是读的时候，可以多个人同时读</p>
<h3 id="4-2-为什么会有写锁和读锁"><a href="#4-2-为什么会有写锁和读锁" class="headerlink" title="4.2 为什么会有写锁和读锁"></a>4.2 为什么会有写锁和读锁</h3><p>原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读</p>
<div class="code-wrapper"><pre><code class="hljs plain">多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</code></pre></div>

<p>读-读：能共存</p>
<p>读-写：不能共存</p>
<p>写-写：不能共存</p>
<h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><p>实现一个读写缓存的操作，假设开始没有加锁的时候，会出现什么情况</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 读写锁</span>
<span class="hljs-comment"> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span>
<span class="hljs-comment"> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-comment">// private Lock lock = null;</span>

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 定义写操作</span>
<span class="hljs-comment">     * 满足：原子 + 独占</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        Object value = map.get(key);
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);
    &#125;


&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();
        <span class="hljs-comment">// 线程操作资源类，5个线程写</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            <span class="hljs-comment">// lambda表达式内部必须是final</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);
            &#125;, String.valueOf(i)).start();
        &#125;
        <span class="hljs-comment">// 线程操作资源类， 5个线程读</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            <span class="hljs-comment">// lambda表达式内部必须是final</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>我们分别创建5个线程写入缓存</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 线程操作资源类，5个线程写</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
    <span class="hljs-comment">// lambda表达式内部必须是final</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>5个线程读取缓存，</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 线程操作资源类， 5个线程读</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
    <span class="hljs-comment">// lambda表达式内部必须是final</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>最后运行结果：</p>
<div class="code-wrapper"><pre><code class="hljs 1c"><span class="hljs-number">0</span>	 正在写入：<span class="hljs-number">0</span>
<span class="hljs-number">4</span>	 正在写入：<span class="hljs-number">4</span>
<span class="hljs-number">3</span>	 正在写入：<span class="hljs-number">3</span>
<span class="hljs-number">1</span>	 正在写入：<span class="hljs-number">1</span>
<span class="hljs-number">2</span>	 正在写入：<span class="hljs-number">2</span>
<span class="hljs-number">0</span>	 正在读取:
<span class="hljs-number">1</span>	 正在读取:
<span class="hljs-number">2</span>	 正在读取:
<span class="hljs-number">3</span>	 正在读取:
<span class="hljs-number">4</span>	 正在读取:
<span class="hljs-number">2</span>	 写入完成
<span class="hljs-number">4</span>	 写入完成
<span class="hljs-number">4</span>	 读取完成：<span class="hljs-literal">null</span>
<span class="hljs-number">0</span>	 写入完成
<span class="hljs-number">3</span>	 读取完成：<span class="hljs-literal">null</span>
<span class="hljs-number">0</span>	 读取完成：<span class="hljs-literal">null</span>
<span class="hljs-number">1</span>	 写入完成
<span class="hljs-number">3</span>	 写入完成
<span class="hljs-number">1</span>	 读取完成：<span class="hljs-literal">null</span>
<span class="hljs-number">2</span>	 读取完成：<span class="hljs-literal">null</span></code></pre></div>

<p>我们可以看到，在写入的时候，写操作都没其它线程打断了，这就造成了，还没写完，其它线程又开始写，这样就造成数据不一致</p>
<h3 id="4-4-解决方法"><a href="#4-4-解决方法" class="headerlink" title="4.4 解决方法"></a>4.4 解决方法</h3><p>上面的代码是没有加锁的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到读写锁来解决了</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 创建一个读写锁</span>
<span class="hljs-comment">* 它是一个读写融为一体的锁，在使用的时候，需要转换</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">private</span> ReentrantReadWriteLock rwLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();</code></pre></div>

<p>当我们在进行写操作的时候，就需要转换成写锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个写锁</span>
rwLock.writeLock().lock();

<span class="hljs-comment">// 写锁 释放</span>
rwLock.writeLock().unlock();</code></pre></div>

<p>当们在进行读操作的时候，在转换成读锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个读锁</span>
rwLock.readLock().lock();

<span class="hljs-comment">// 读锁 释放</span>
rwLock.readLock().unlock();</code></pre></div>

<p>这里的读锁和写锁的区别在于，写锁一次只能一个线程进入，执行写操作，而读锁是多个线程能够同时进入，进行读取的操作</p>
<p>完整代码：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 读写锁</span>
<span class="hljs-comment"> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span>
<span class="hljs-comment"> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 缓存中的东西，必须保持可见性，因此使用volatile修饰</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 创建一个读写锁</span>
<span class="hljs-comment">     * 它是一个读写融为一体的锁，在使用的时候，需要转换</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> ReentrantReadWriteLock rwLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 定义写操作</span>
<span class="hljs-comment">     * 满足：原子 + 独占</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;

        <span class="hljs-comment">// 创建一个写锁</span>
        rwLock.writeLock().lock();

        <span class="hljs-keyword">try</span> &#123;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在写入：&quot;</span> + key);

            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            map.put(key, value);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 写入完成&quot;</span>);

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// 写锁 释放</span>
            rwLock.writeLock().unlock();
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 获取</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;

        <span class="hljs-comment">// 读锁</span>
        rwLock.readLock().lock();
        <span class="hljs-keyword">try</span> &#123;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 正在读取:&quot;</span>);

            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 模拟网络拥堵，延迟0.3秒</span>
                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            Object value = map.get(key);

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 读取完成：&quot;</span> + value);

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// 读锁释放</span>
            rwLock.readLock().unlock();
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 清空缓存</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;
        map.clear();
    &#125;


&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        MyCache myCache = <span class="hljs-keyword">new</span> MyCache();

        <span class="hljs-comment">// 线程操作资源类，5个线程写</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;
            <span class="hljs-comment">// lambda表达式内部必须是final</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                myCache.put(tempInt + <span class="hljs-string">&quot;&quot;</span>, tempInt +  <span class="hljs-string">&quot;&quot;</span>);
            &#125;, String.valueOf(i)).start();
        &#125;

        <span class="hljs-comment">// 线程操作资源类， 5个线程读</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;
            <span class="hljs-comment">// lambda表达式内部必须是final</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                myCache.get(tempInt + <span class="hljs-string">&quot;&quot;</span>);
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>运行结果：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>	 正在写入：<span class="hljs-number">1</span>
<span class="hljs-attribute">1</span>	 写入完成
<span class="hljs-attribute">2</span>	 正在写入：<span class="hljs-number">2</span>
<span class="hljs-attribute">2</span>	 写入完成
<span class="hljs-attribute">3</span>	 正在写入：<span class="hljs-number">3</span>
<span class="hljs-attribute">3</span>	 写入完成
<span class="hljs-attribute">4</span>	 正在写入：<span class="hljs-number">4</span>
<span class="hljs-attribute">4</span>	 写入完成
<span class="hljs-attribute">5</span>	 正在写入：<span class="hljs-number">5</span>
<span class="hljs-attribute">5</span>	 写入完成
<span class="hljs-attribute">2</span>	 正在读取:
<span class="hljs-attribute">3</span>	 正在读取:
<span class="hljs-attribute">1</span>	 正在读取:
<span class="hljs-attribute">4</span>	 正在读取:
<span class="hljs-attribute">5</span>	 正在读取:
<span class="hljs-attribute">2</span>	 读取完成：<span class="hljs-number">2</span>
<span class="hljs-attribute">1</span>	 读取完成：<span class="hljs-number">1</span>
<span class="hljs-attribute">4</span>	 读取完成：<span class="hljs-number">4</span>
<span class="hljs-attribute">3</span>	 读取完成：<span class="hljs-number">3</span>
<span class="hljs-attribute">5</span>	 读取完成：<span class="hljs-number">5</span></code></pre></div>

<p>从运行结果我们可以看出，写入操作是一个一个线程进行执行的，并且中间不会被打断，而读操作的时候，是同时5个线程进入，然后并发读取操作</p>
<h2 id="5-为什么Synchronized无法禁止指令重排，却能保证有序性"><a href="#5-为什么Synchronized无法禁止指令重排，却能保证有序性" class="headerlink" title="5 为什么Synchronized无法禁止指令重排，却能保证有序性"></a>5 为什么Synchronized无法禁止指令重排，却能保证有序性</h2><h3 id="5-1-前言"><a href="#5-1-前言" class="headerlink" title="5.1 前言"></a>5.1 前言</h3><p>首先我们要分析下这道题，这简单的一个问题，其实里面还是包含了很多信息的，要想回答好这个问题，面试者至少要知道一下概念：</p>
<ul>
<li>Java内存模型</li>
<li>并发编程有序性问题</li>
<li>指令重排</li>
<li>synchronized锁</li>
<li>可重入锁</li>
<li>排它锁</li>
<li>as-if-serial语义</li>
<li>单线程&amp;多线程</li>
</ul>
<h3 id="5-2-标准解答"><a href="#5-2-标准解答" class="headerlink" title="5.2 标准解答"></a>5.2 标准解答</h3><p>为了进一步提升计算机各方面能力，在硬件层面做了很多优化，如处理器优化和指令重排等，但是这些技术的引入就会导致有序性问题。</p>
<blockquote>
<p>先解释什么是有序性问题，也知道是什么原因导致的有序性问题</p>
</blockquote>
<p>我们也知道，最好的解决有序性问题的办法，就是禁止处理器优化和指令重排，就像volatile中使用内存屏障一样。</p>
<blockquote>
<p>表明你知道啥是指令重排，也知道他的实现原理</p>
</blockquote>
<p>但是，虽然很多硬件都会为了优化做一些重排，但是在Java中，不管怎么排序，都不能影响单线程程序的执行结果。这就是as-if-serial语义，所有硬件优化的前提都是必须遵守as-if-serial语义。</p>
<p>as-if-serial语义把<strong>单线程</strong>程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会 干扰他们，也无需担心内存可见性问题。</p>
<blockquote>
<p>重点！解释下什么是as-if-serial语义，因为这是这道题的第一个关键词，答上来就对了一半了</p>
</blockquote>
<p>再说下synchronized，他是Java提供的锁，可以通过他对Java中的对象加锁，并且他是一种排他的、可重入的锁。</p>
<p>所以，当某个线程执行到一段被synchronized修饰的代码之前，会先进行加锁，执行完之后再进行解锁。在加锁之后，解锁之前，其他线程是无法再次获得锁的，只有这条加锁线程可以重复获得该锁。</p>
<blockquote>
<p>介绍synchronized的原理，这是本题的第二个关键点，到这里基本就可以拿满分了。</p>
</blockquote>
<p>synchronized通过排他锁的方式就保证了同一时间内，被synchronized修饰的代码是单线程执行的。所以呢，这就满足了as-if-serial语义的一个关键前提，那就是<strong>单线程</strong>，因为有as-if-serial语义保证，单线程的有序性就天然存在了。</p>
<h1 id="第7章-计时器和信号量"><a href="#第7章-计时器和信号量" class="headerlink" title="第7章 计时器和信号量"></a>第7章 计时器和信号量</h1><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1 CountDownLatch"></a>1 CountDownLatch</h2><h3 id="1-1-概念-1"><a href="#1-1-概念-1" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p>
<p>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程就会被阻塞。其它线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会被阻塞），当计数器的值变成零时，因调用await方法被阻塞的线程会被唤醒，继续执行</p>
<h3 id="1-2-场景"><a href="#1-2-场景" class="headerlink" title="1.2 场景"></a>1.2 场景</h3><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p>
<h3 id="1-3-解决方案"><a href="#1-3-解决方案" class="headerlink" title="1.3 解决方案"></a>1.3 解决方案</h3><p>这个时候就用到了CountDownLatch，计数器了。我们一共创建6个线程，然后计数器的值也设置成6</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 计数器</span>
CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);</code></pre></div>

<p>然后每次学生线程执行完，就让计数器的值减1</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 上完自习，离开教室&quot;</span>);
        countDownLatch.countDown();
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是一道墙，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p>
<div class="code-wrapper"><pre><code class="hljs java">countDownLatch.await();

System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 班长最后关门&quot;</span>);</code></pre></div>

<p>不加CountDownLatch的执行结果，我们发现main线程提前已经执行完成了</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>	 上完自习，离开教室
<span class="hljs-number">0</span>	 上完自习，离开教室
<span class="hljs-selector-tag">main</span>	 班长最后关门
<span class="hljs-number">2</span>	 上完自习，离开教室
<span class="hljs-number">3</span>	 上完自习，离开教室
<span class="hljs-number">4</span>	 上完自习，离开教室
<span class="hljs-number">5</span>	 上完自习，离开教室
<span class="hljs-number">6</span>	 上完自习，离开教室</code></pre></div>

<p>引入CountDownLatch后的执行结果，我们能够控制住main方法的执行，这样能够保证前提任务的执行</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">0</span>	 上完自习，离开教室
<span class="hljs-number">2</span>	 上完自习，离开教室
<span class="hljs-number">4</span>	 上完自习，离开教室
<span class="hljs-number">1</span>	 上完自习，离开教室
<span class="hljs-number">5</span>	 上完自习，离开教室
<span class="hljs-number">6</span>	 上完自习，离开教室
<span class="hljs-number">3</span>	 上完自习，离开教室
<span class="hljs-selector-tag">main</span>	 班长最后关门</code></pre></div>

<h3 id="1-4-完整代码"><a href="#1-4-完整代码" class="headerlink" title="1.4 完整代码"></a>1.4 完整代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.moxi.interview.study.thread;

<span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;

        <span class="hljs-comment">// 计数器</span>
        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 上完自习，离开教室&quot;</span>);
                countDownLatch.countDown();
            &#125;, String.valueOf(i)).start();
        &#125;

        countDownLatch.await();

        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 班长最后关门&quot;</span>);
    &#125;
&#125;</code></pre></div>

<h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2 CyclicBarrier"></a>2 CyclicBarrier</h2><h3 id="2-1-概念-1"><a href="#2-1-概念-1" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>和CountDownLatch相反，需要集齐七颗龙珠，召唤神龙。也就是做加法，开始是0，加到某个值的时候就执行</p>
<p>CyclicBarrier的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法</p>
<h3 id="2-2-案例"><a href="#2-2-案例" class="headerlink" title="2.2 案例"></a>2.2 案例</h3><p>集齐7个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span>
<span class="hljs-comment">*/</span>
CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">7</span>, () -&gt; &#123;
	System.out.println(<span class="hljs-string">&quot;召唤神龙&quot;</span>);
&#125;);</code></pre></div>

<p>然后同时编写七个线程，进行龙珠收集，但一个线程收集到了的时候，我们需要让他执行await方法，等待到7个线程全部执行完毕后，我们就执行原来定义好的方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;
    <span class="hljs-keyword">final</span> Integer tempInt = i;
    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="hljs-string">&quot;颗龙珠&quot;</span>);

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span>
            cyclicBarrier.await();
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<p>完整代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * CyclicBarrier循环屏障</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierDemo</span> </span>&#123;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span>
<span class="hljs-comment">         */</span>
        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">7</span>, () -&gt; &#123;
            System.out.println(<span class="hljs-string">&quot;召唤神龙&quot;</span>);
        &#125;);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;
            <span class="hljs-keyword">final</span> Integer tempInt = i;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 收集到 第&quot;</span> + tempInt + <span class="hljs-string">&quot;颗龙珠&quot;</span>);

                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span>
                    cyclicBarrier.await();
                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="3-Semaphore：信号量"><a href="#3-Semaphore：信号量" class="headerlink" title="3 Semaphore：信号量"></a>3 Semaphore：信号量</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p>信号量主要用于两个目的</p>
<ul>
<li>一个是用于共享资源的互斥使用</li>
<li>另一个用于并发线程数的控制</li>
</ul>
<h3 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2 代码"></a>3.2 代码</h3><p>我们模拟一个抢车位的场景，假设一共有6个车，3个停车位</p>
<p>那么我们首先需要定义信号量为3，也就是3个停车位</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span>
<span class="hljs-comment">*/</span>
Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>, <span class="hljs-keyword">false</span>);</code></pre></div>

<p>然后我们模拟6辆车同时并发抢占停车位，但第一个车辆抢占到停车位后，信号量需要减1</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 代表一辆车，已经占用了该车位</span>
semaphore.acquire(); <span class="hljs-comment">// 抢占</span></code></pre></div>

<p>同时车辆假设需要等待3秒后，释放信号量</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 每个车停3秒</span>
<span class="hljs-keyword">try</span> &#123;
	TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
	e.printStackTrace();
&#125;</code></pre></div>

<p>最后车辆离开，释放信号量</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 释放停车位</span>
semaphore.release();</code></pre></div>

<h3 id="3-3-完整代码"><a href="#3-3-完整代码" class="headerlink" title="3.3 完整代码"></a>3.3 完整代码</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 信号量Demo</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-03-16-15:01</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span>
<span class="hljs-comment">         */</span>
        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>, <span class="hljs-keyword">false</span>);

        <span class="hljs-comment">// 模拟6部车</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-comment">// 代表一辆车，已经占用了该车位</span>
                    semaphore.acquire(); <span class="hljs-comment">// 抢占</span>

                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 抢到车位&quot;</span>);

                    <span class="hljs-comment">// 每个车停3秒</span>
                    <span class="hljs-keyword">try</span> &#123;
                        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);
                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;

                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 离开车位&quot;</span>);

                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-comment">// 释放停车位</span>
                    semaphore.release();
                &#125;
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>运行结果</p>
<div class="code-wrapper"><pre><code class="hljs plain">0	 抢到车位
2	 抢到车位
1	 抢到车位
2	 离开车位
1	 离开车位
3	 抢到车位
0	 离开车位
4	 抢到车位
5	 抢到车位
4	 离开车位
3	 离开车位
5	 离开车位</code></pre></div>

<p>看运行结果能够发现，0 2 1 车辆首先抢占到了停车位，然后等待3秒后，离开，然后后面 3 4 5 又抢到了车位</p>
<h1 id="第8章阻塞队列"><a href="#第8章阻塞队列" class="headerlink" title="第8章阻塞队列"></a>第8章阻塞队列</h1><h2 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-队列"><a href="#1-1-队列" class="headerlink" title="1.1 队列"></a>1.1 队列</h3><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭</p>
<h3 id="1-2-阻塞队列"><a href="#1-2-阻塞队列" class="headerlink" title="1.2 阻塞队列"></a>1.2 阻塞队列</h3><p>BlockingQueue   阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200316152120272.png" alt="image-20200316152120272"></p>
<p>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素</p>
<ul>
<li><p><code>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</code></p>
<ul>
<li>当蛋糕店的柜子空的时候，无法从柜子里面获取蛋糕</li>
</ul>
</li>
<li><p><code>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</code></p>
<ul>
<li>当蛋糕店的柜子满的时候，无法继续向柜子里面添加蛋糕了</li>
</ul>
</li>
</ul>
<p>也就是说 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素</p>
<p>同理，试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增</p>
<h2 id="2-为什么要用？"><a href="#2-为什么要用？" class="headerlink" title="2 为什么要用？"></a>2 为什么要用？</h2><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞</p>
<p>在多线程领域：所谓的阻塞，在某些清空下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒</p>
<h3 id="为什么需要BlockingQueue"><a href="#为什么需要BlockingQueue" class="headerlink" title="为什么需要BlockingQueue"></a>为什么需要BlockingQueue</h3><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都帮你一手包办了</p>
<p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<h2 id="3-架构"><a href="#3-架构" class="headerlink" title="3 架构"></a>3 架构</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 你用过List集合类</span>

<span class="hljs-comment">// ArrayList集合类熟悉么？</span>

<span class="hljs-comment">// 还用过 CopyOnWriteList  和 BlockingQueue</span></code></pre></div>

<p>BlockingQueue阻塞队列是属于一个接口，底下有七个实现类</p>
<ul>
<li>ArrayBlockQueue：由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列<ul>
<li>有界，但是界限非常大，相当于无界，可以当成无界</li>
</ul>
</li>
<li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li>
<li>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列<ul>
<li>生产一个，消费一个，不存储元素，不消费不生产</li>
</ul>
</li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li>
</ul>
<p>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p>
<h2 id="4-BlockingQueue核心方法"><a href="#4-BlockingQueue核心方法" class="headerlink" title="4 BlockingQueue核心方法"></a>4 BlockingQueue核心方法</h2><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200316154442756.png" alt="image-20200316154442756"></p>
<table>
<thead>
<tr>
<th>抛出异常</th>
<th>当阻塞队列满时：在往队列中add插入元素会抛出 IIIegalStateException：Queue full                      当阻塞队列空时：再往队列中remove移除元素，会抛出NoSuchException</th>
</tr>
</thead>
<tbody><tr>
<td>特殊性</td>
<td>插入方法，成功true，失败false       移除方法：成功返回出队列元素，队列没有就返回空</td>
</tr>
<tr>
<td>一直阻塞</td>
<td>当阻塞队列满时，生产者继续往队列里put元素，队列会一直阻塞生产线程直到put数据or响应中断退出， 当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用。</td>
</tr>
<tr>
<td>超时退出</td>
<td>当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td>
</tr>
</tbody></table>
<h3 id="4-1-抛出异常组"><a href="#4-1-抛出异常组" class="headerlink" title="4.1 抛出异常组"></a>4.1 抛出异常组</h3><p>但执行add方法，向已经满的ArrayBlockingQueue中添加元素时候，会抛出异常</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞队列，需要填入默认值</span>
BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);

System.out.println(blockingQueue.add(<span class="hljs-string">&quot;a&quot;</span>));
System.out.println(blockingQueue.add(<span class="hljs-string">&quot;b&quot;</span>));
System.out.println(blockingQueue.add(<span class="hljs-string">&quot;c&quot;</span>));

System.out.println(blockingQueue.add(<span class="hljs-string">&quot;XXX&quot;</span>));</code></pre></div>

<p>运行后：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">true</span>
<span class="hljs-keyword">true</span>
<span class="hljs-keyword">true</span>
Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalStateException: Queue full
	at java.util.AbstractQueue.add(AbstractQueue.java:<span class="hljs-number">98</span>)
	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:<span class="hljs-number">312</span>)
	at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:<span class="hljs-number">25</span>)</code></pre></div>

<p>同时如果我们多取出元素的时候，也会抛出异常，我们假设只存储了3个值，但是取的时候，取了四次</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞队列，需要填入默认值</span>
BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);
System.out.println(blockingQueue.add(<span class="hljs-string">&quot;a&quot;</span>));
System.out.println(blockingQueue.add(<span class="hljs-string">&quot;b&quot;</span>));
System.out.println(blockingQueue.add(<span class="hljs-string">&quot;c&quot;</span>));

System.out.println(blockingQueue.remove());
System.out.println(blockingQueue.remove());
System.out.println(blockingQueue.remove());
System.out.println(blockingQueue.remove());</code></pre></div>

<p>那么出现异常</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">true</span>
<span class="hljs-keyword">true</span>
<span class="hljs-keyword">true</span>
a
b
c
Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.NoSuchElementException
	at java.util.AbstractQueue.remove(AbstractQueue.java:<span class="hljs-number">117</span>)
	at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:<span class="hljs-number">30</span>)</code></pre></div>

<h3 id="4-2-布尔类型组"><a href="#4-2-布尔类型组" class="headerlink" title="4.2 布尔类型组"></a>4.2 布尔类型组</h3><p>我们使用 offer的方法，添加元素时候，如果阻塞队列满了后，会返回false，否者返回true</p>
<p>同时在取的时候，如果队列已空，那么会返回null</p>
<div class="code-wrapper"><pre><code class="hljs java">BlockingQueue blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue(<span class="hljs-number">3</span>);

System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;a&quot;</span>));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;b&quot;</span>));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;c&quot;</span>));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;d&quot;</span>));

System.out.println(blockingQueue.poll());
System.out.println(blockingQueue.poll());
System.out.println(blockingQueue.poll());
System.out.println(blockingQueue.poll());</code></pre></div>

<p>运行结果</p>
<div class="code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">true</span>
<span class="hljs-literal">false</span>
<span class="hljs-keyword">a</span>
b
c
<span class="hljs-literal">null</span></code></pre></div>

<h3 id="4-3-阻塞队列组"><a href="#4-3-阻塞队列组" class="headerlink" title="4.3 阻塞队列组"></a>4.3 阻塞队列组</h3><p>我们使用 put的方法，添加元素时候，如果阻塞队列满了后，添加消息的线程，会一直阻塞，直到队列元素减少，会被清空，才会唤醒</p>
<p>一般在消息中间件，比如RabbitMQ中会使用到，因为需要保证消息百分百不丢失，因此只有让它阻塞</p>
<div class="code-wrapper"><pre><code class="hljs abnf">BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>)<span class="hljs-comment">;</span>
blockingQueue.put(<span class="hljs-string">&quot;a&quot;</span>)<span class="hljs-comment">;</span>
blockingQueue.put(<span class="hljs-string">&quot;b&quot;</span>)<span class="hljs-comment">;</span>
blockingQueue.put(<span class="hljs-string">&quot;c&quot;</span>)<span class="hljs-comment">;</span>
System.out.println(<span class="hljs-string">&quot;================&quot;</span>)<span class="hljs-comment">;</span>

blockingQueue.take()<span class="hljs-comment">;</span>
blockingQueue.take()<span class="hljs-comment">;</span>
blockingQueue.take()<span class="hljs-comment">;</span>
blockingQueue.take()<span class="hljs-comment">;</span></code></pre></div>

<p>同时使用take取消息的时候，如果内容不存在的时候，也会被阻塞</p>
<h3 id="4-4-不见不散组"><a href="#4-4-不见不散组" class="headerlink" title="4.4 不见不散组"></a>4.4 不见不散组</h3><p>offer( )  ， poll 加时间</p>
<p>使用offer插入的时候，需要指定时间，如果2秒还没有插入，那么就放弃插入</p>
<div class="code-wrapper"><pre><code class="hljs java">BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.offer(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-number">2L</span>, TimeUnit.SECONDS));</code></pre></div>

<p>同时取的时候也进行判断</p>
<div class="code-wrapper"><pre><code class="hljs java">System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));
System.out.println(blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS));</code></pre></div>

<p>如果2秒内取不出来，那么就返回null</p>
<h2 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5 SynchronousQueue"></a>5 SynchronousQueue</h2><p>SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储的BlockingQueue，每一个put操作必须等待一个take操作，否者不能继续添加元素</p>
<p>下面我们测试SynchronousQueue添加元素的过程</p>
<p>首先我们创建了两个线程，一个线程用于生产，一个线程用于消费</p>
<p>生产的线程分别put了 A、B、C这三个字段</p>
<div class="code-wrapper"><pre><code class="hljs java">BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;();

<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
    <span class="hljs-keyword">try</span> &#123;       
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put A &quot;</span>);
        blockingQueue.put(<span class="hljs-string">&quot;A&quot;</span>);
       
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put B &quot;</span>);
        blockingQueue.put(<span class="hljs-string">&quot;B&quot;</span>);        
        
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t put C &quot;</span>);
        blockingQueue.put(<span class="hljs-string">&quot;C&quot;</span>);        
        
    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();</code></pre></div>

<p>消费线程使用take，消费阻塞队列中的内容，并且每次消费前，都等待5秒</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
    <span class="hljs-keyword">try</span> &#123;

        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        blockingQueue.take();
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take A &quot;</span>);

        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        blockingQueue.take();
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take B &quot;</span>);

        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        blockingQueue.take();
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t take C &quot;</span>);

    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();</code></pre></div>

<p>最后结果输出为：</p>
<div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-built_in">t1</span>	 put A 
<span class="hljs-built_in">t2</span>	 take A 

<span class="hljs-number">5</span>秒后...

<span class="hljs-built_in">t1</span>	 put <span class="hljs-keyword">B </span>
<span class="hljs-built_in">t2</span>	 take <span class="hljs-keyword">B </span>

<span class="hljs-number">5</span>秒后...

<span class="hljs-built_in">t1</span>	 put C 
<span class="hljs-built_in">t2</span>	 take C</code></pre></div>

<p>我们从最后的运行结果可以看出，每次t1线程向队列中添加阻塞队列添加元素后，t1输入线程就会等待 t2消费线程，t2消费后，t2处于挂起状态，等待t1在存入，从而周而复始，形成 一存一取的状态</p>
<h2 id="6-阻塞队列的用处"><a href="#6-阻塞队列的用处" class="headerlink" title="6 阻塞队列的用处"></a>6 阻塞队列的用处</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p>一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮</p>
<p>关于多线程的操作，我们需要记住下面几句</p>
<ul>
<li>线程 操作 资源类</li>
<li>判断 干活 通知</li>
<li>防止虚假唤醒机制</li>
</ul>
<p>我们下面实现一个简单的生产者消费者模式，首先有资源类ShareData</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareData</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        <span class="hljs-comment">// 同步代码块，加锁</span>
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// 等待不能生产</span>
                condition.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            number++;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);

            <span class="hljs-comment">// 通知 唤醒</span>
            condition.signalAll();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        <span class="hljs-comment">// 同步代码块，加锁</span>
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// 等待不能消费</span>
                condition.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            number--;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);

            <span class="hljs-comment">// 通知 唤醒</span>
            condition.signalAll();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

&#125;</code></pre></div>

<p>里面有一个number变量，同时提供了increment 和 decrement的方法，分别让number 加1和减1</p>
<p>但是我们在进行判断的时候，为了防止出现虚假唤醒机制，不能使用if来进行判断，而应该使用while</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 判断</span>
<span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">// 等待不能生产</span>
    condition.await();
&#125;</code></pre></div>

<p>不能使用 if判断</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 判断</span>
<span class="hljs-keyword">if</span>(number != <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">// 等待不能生产</span>
    condition.await();
&#125;</code></pre></div>

<p>完整代码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 生产者消费者 传统版</span>
<span class="hljs-comment"> * 题目：一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮</span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 线程 操作 资源类</span>
<span class="hljs-comment"> * 判断 干活 通知</span>
<span class="hljs-comment"> * 防止虚假唤醒机制</span>
<span class="hljs-comment"> */</span>

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareData</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        <span class="hljs-comment">// 同步代码块，加锁</span>
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// 等待不能生产</span>
                condition.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            number++;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);

            <span class="hljs-comment">// 通知 唤醒</span>
            condition.signalAll();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        <span class="hljs-comment">// 同步代码块，加锁</span>
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number == <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// 等待不能消费</span>
                condition.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            number--;

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number);

            <span class="hljs-comment">// 通知 唤醒</span>
            condition.signalAll();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProdConsumerTraditionDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 高内聚，低耦合    内聚指的是，一个空调，自身带有调节温度高低的方法</span>

        ShareData shareData = <span class="hljs-keyword">new</span> ShareData();

        <span class="hljs-comment">// t1线程，生产</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    shareData.increment();
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-comment">// t2线程，消费</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    shareData.decrement();
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p>最后运行成功后，我们一个进行生产，一个进行消费</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">t1</span>	 <span class="hljs-number">1</span>
<span class="hljs-attribute">t2</span>	 <span class="hljs-number">0</span>
<span class="hljs-attribute">t1</span>	 <span class="hljs-number">1</span>
<span class="hljs-attribute">t2</span>	 <span class="hljs-number">0</span>
<span class="hljs-attribute">t1</span>	 <span class="hljs-number">1</span>
<span class="hljs-attribute">t2</span>	 <span class="hljs-number">0</span>
<span class="hljs-attribute">t1</span>	 <span class="hljs-number">1</span>
<span class="hljs-attribute">t2</span>	 <span class="hljs-number">0</span>
<span class="hljs-attribute">t1</span>	 <span class="hljs-number">1</span>
<span class="hljs-attribute">t2</span>	 <span class="hljs-number">0</span></code></pre></div>

<h2 id="7-生成者和消费者3-0"><a href="#7-生成者和消费者3-0" class="headerlink" title="7 生成者和消费者3.0"></a>7 生成者和消费者3.0</h2><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，则这会给我们的程序带来不小的时间复杂度</p>
<p>现在我们使用新版的阻塞队列版生产者和消费者，使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 生产者消费者  阻塞队列版</span>
<span class="hljs-comment"> * 使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</span>
<span class="hljs-comment"> */</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> </span>&#123;
    <span class="hljs-comment">// 默认开启，进行生产消费</span>
    <span class="hljs-comment">// 这里用到了volatile是为了保持数据的可见性，也就是当TLAG修改时，要马上通知其它线程进行修改</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> FLAG = <span class="hljs-keyword">true</span>;

    <span class="hljs-comment">// 使用原子包装类，而不用number++</span>
    <span class="hljs-keyword">private</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();

    <span class="hljs-comment">// 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue</span>
    BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">// 而应该采用依赖注入里面的，构造注入方法传入</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyResource</span><span class="hljs-params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.blockingQueue = blockingQueue;
        <span class="hljs-comment">// 查询出传入的class是什么</span>
        System.out.println(blockingQueue.getClass().getName());
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 生产</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myProd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        String data = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">boolean</span> retValue;
        <span class="hljs-comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span>
        <span class="hljs-comment">// 当FLAG为true的时候，开始生产</span>
        <span class="hljs-keyword">while</span>(FLAG) &#123;
            data = atomicInteger.incrementAndGet() + <span class="hljs-string">&quot;&quot;</span>;

            <span class="hljs-comment">// 2秒存入1个data</span>
            retValue = blockingQueue.offer(data, <span class="hljs-number">2L</span>, TimeUnit.SECONDS);
            <span class="hljs-keyword">if</span>(retValue) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 插入队列:&quot;</span> + data  + <span class="hljs-string">&quot;成功&quot;</span> );
            &#125; <span class="hljs-keyword">else</span> &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 插入队列:&quot;</span> + data  + <span class="hljs-string">&quot;失败&quot;</span> );
            &#125;

            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 停止生产，表示FLAG=false，生产介绍&quot;</span>);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 消费</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myConsumer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
        String retValue;
        <span class="hljs-comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span>
        <span class="hljs-comment">// 当FLAG为true的时候，开始生产</span>
        <span class="hljs-keyword">while</span>(FLAG) &#123;
            <span class="hljs-comment">// 2秒存入1个data</span>
            retValue = blockingQueue.poll(<span class="hljs-number">2L</span>, TimeUnit.SECONDS);
            <span class="hljs-keyword">if</span>(retValue != <span class="hljs-keyword">null</span> &amp;&amp; retValue != <span class="hljs-string">&quot;&quot;</span>) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费队列:&quot;</span> + retValue  + <span class="hljs-string">&quot;成功&quot;</span> );
            &#125; <span class="hljs-keyword">else</span> &#123;
                FLAG = <span class="hljs-keyword">false</span>;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费失败，队列中已为空，退出&quot;</span> );

                <span class="hljs-comment">// 退出消费队列</span>
                <span class="hljs-keyword">return</span>;
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 停止生产的判断</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.FLAG = <span class="hljs-keyword">false</span>;
    &#125;

&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProdConsumerBlockingQueueDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 传入具体的实现类， ArrayBlockingQueue</span>
        MyResource myResource = <span class="hljs-keyword">new</span> MyResource(<span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="hljs-number">10</span>));

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 生产线程启动&quot;</span>);
            System.out.println(<span class="hljs-string">&quot;&quot;</span>);
            System.out.println(<span class="hljs-string">&quot;&quot;</span>);
            <span class="hljs-keyword">try</span> &#123;
                myResource.myProd();
                System.out.println(<span class="hljs-string">&quot;&quot;</span>);
                System.out.println(<span class="hljs-string">&quot;&quot;</span>);
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;prod&quot;</span>).start();


        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 消费线程启动&quot;</span>);

            <span class="hljs-keyword">try</span> &#123;
                myResource.myConsumer();
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, <span class="hljs-string">&quot;consumer&quot;</span>).start();

        <span class="hljs-comment">// 5秒后，停止生产和消费</span>
        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        System.out.println(<span class="hljs-string">&quot;&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;5秒中后，生产和消费线程停止，线程结束&quot;</span>);
        myResource.stop();
    &#125;
&#125;</code></pre></div>

<p>最后运行结果</p>
<div class="code-wrapper"><pre><code class="hljs java">java.util.concurrent.ArrayBlockingQueue
prod	 生产线程启动


consumer	 消费线程启动
prod	 插入队列:<span class="hljs-number">1</span>成功
consumer	 消费队列:<span class="hljs-number">1</span>成功
prod	 插入队列:<span class="hljs-number">2</span>成功
consumer	 消费队列:<span class="hljs-number">2</span>成功
prod	 插入队列:<span class="hljs-number">3</span>成功
consumer	 消费队列:<span class="hljs-number">3</span>成功
prod	 插入队列:<span class="hljs-number">4</span>成功
consumer	 消费队列:<span class="hljs-number">4</span>成功
prod	 插入队列:<span class="hljs-number">5</span>成功
consumer	 消费队列:<span class="hljs-number">5</span>成功


<span class="hljs-number">5</span>秒中后，生产和消费线程停止，线程结束
prod	 停止生产，表示FLAG=<span class="hljs-keyword">false</span>，生产介绍</code></pre></div>

<h1 id="第9章-Synchronized和Lock的区别"><a href="#第9章-Synchronized和Lock的区别" class="headerlink" title="第9章 Synchronized和Lock的区别"></a>第9章 Synchronized和Lock的区别</h1><h2 id="1-前言-1"><a href="#1-前言-1" class="headerlink" title="1 前言"></a>1 前言</h2><p>早期的时候我们对线程的主要操作为：</p>
<ul>
<li>synchronized wait  notify</li>
</ul>
<p>然后后面出现了替代方案</p>
<ul>
<li>lock await  signal</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317101210376.png" alt="image-20200317101210376"></p>
<h2 id="2-问题"><a href="#2-问题" class="headerlink" title="2 问题"></a>2 问题</h2><h3 id="synchronized-和-lock-有什么区别？用新的lock有什么好处？举例说明"><a href="#synchronized-和-lock-有什么区别？用新的lock有什么好处？举例说明" class="headerlink" title="synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明"></a>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</h3><ul>
<li>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</li>
</ul>
<p>1）synchronized属于JVM层面，属于java的关键字</p>
<ul>
<li>monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象 只能在同步块或者方法中才能调用 wait/ notify等方法）</li>
<li>Lock是具体类（java.util.concurrent.locks.Lock）是api层面的锁</li>
</ul>
<p>2）使用方法：</p>
<ul>
<li><p>synchronized：不需要用户去手动释放锁，当synchronized代码执行后，系统会自动让线程释放对锁的占用</p>
</li>
<li><p>ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要lock() 和 unlock() 配置try catch语句来完成</p>
</li>
</ul>
<p>3）等待是否中断</p>
<ul>
<li>synchronized：不可中断，除非抛出异常或者正常运行完成</li>
<li>ReentrantLock：可中断，可以设置超时方法<ul>
<li>设置超时方法，trylock(long timeout, TimeUnit unit)</li>
<li>lockInterrupible() 放代码块中，调用interrupt() 方法可以中断</li>
</ul>
</li>
</ul>
<p>4）加锁是否公平</p>
<ul>
<li>synchronized：非公平锁</li>
<li>ReentrantLock：默认非公平锁，构造函数可以传递boolean值，true为公平锁，false为非公平锁</li>
</ul>
<p>5）锁绑定多个条件Condition</p>
<ul>
<li>synchronized：没有，要么随机，要么全部唤醒</li>
<li>ReentrantLock：用来实现分组唤醒需要唤醒的线程，可以精确唤醒，而不是像synchronized那样，要么随机，要么全部唤醒</li>
</ul>
<h2 id="3-举例"><a href="#3-举例" class="headerlink" title="3 举例"></a>3 举例</h2><p>针对刚刚提到的区别的第5条，我们有下面这样的一个场景</p>
<div class="code-wrapper"><pre><code class="hljs java">题目：多线程之间按顺序调用，实现 A-&gt; B -&gt; C 三个线程启动，要求如下：
AA打印<span class="hljs-number">5</span>次，BB打印<span class="hljs-number">10</span>次，CC打印<span class="hljs-number">15</span>次
紧接着
AA打印<span class="hljs-number">5</span>次，BB打印<span class="hljs-number">10</span>次，CC打印<span class="hljs-number">15</span>次
..
来<span class="hljs-number">10</span>轮</code></pre></div>

<p>我们会发现，这样的场景在使用synchronized来完成的话，会非常的困难，但是使用lock就非常方便了</p>
<p>也就是我们需要实现一个链式唤醒的操作</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317105121435.png" alt="image-20200317105121435"></p>
<p>当A线程执行完后，B线程才能执行，然后B线程执行完成后，C线程才执行</p>
<p>首先我们需要创建一个重入锁</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个重入锁</span>
<span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();</code></pre></div>

<p>然后定义三个条件，也可以称为锁的钥匙，通过它就可以获取到锁，进入到方法里面</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 这三个相当于备用钥匙</span>
<span class="hljs-keyword">private</span> Condition condition1 = lock.newCondition();
<span class="hljs-keyword">private</span> Condition condition2 = lock.newCondition();
<span class="hljs-keyword">private</span> Condition condition3 = lock.newCondition();</code></pre></div>

<p>然后开始记住锁的三部曲： 判断   干活  唤醒</p>
<p>这里的判断，为了避免虚假唤醒，一定要采用  while</p>
<p>干活就是把需要的内容，打印出来</p>
<p>唤醒的话，就是修改资源类的值，然后精准唤醒线程进行干活：这里A 唤醒B， B唤醒C，C又唤醒A</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print5</span><span class="hljs-params">()</span> </span>&#123;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 判断</span>
        <span class="hljs-keyword">while</span>(number != <span class="hljs-number">1</span>) &#123;
            <span class="hljs-comment">// 不等于1，需要等待</span>
            condition1.await();
        &#125;

        <span class="hljs-comment">// 干活</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);
        &#125;

        <span class="hljs-comment">// 唤醒 （干完活后，需要通知B线程执行）</span>
        number = <span class="hljs-number">2</span>;
        <span class="hljs-comment">// 通知2号去干活了</span>
        condition2.signal();

    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        e.printStackTrace();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Synchronized 和 Lock的区别</span>
<span class="hljs-comment"> */</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareResource</span> </span>&#123;
    <span class="hljs-comment">// A 1   B 2   c 3</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;
    <span class="hljs-comment">// 创建一个重入锁</span>
    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-comment">// 这三个相当于备用钥匙</span>
    <span class="hljs-keyword">private</span> Condition condition1 = lock.newCondition();
    <span class="hljs-keyword">private</span> Condition condition2 = lock.newCondition();
    <span class="hljs-keyword">private</span> Condition condition3 = lock.newCondition();


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print5</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">1</span>) &#123;
                <span class="hljs-comment">// 不等于1，需要等待</span>
                condition1.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);
            &#125;

            <span class="hljs-comment">// 唤醒 （干完活后，需要通知B线程执行）</span>
            number = <span class="hljs-number">2</span>;
            <span class="hljs-comment">// 通知2号去干活了</span>
            condition2.signal();

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print10</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">2</span>) &#123;
                <span class="hljs-comment">// 不等于2，需要等待</span>
                condition2.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);
            &#125;

            <span class="hljs-comment">// 唤醒 （干完活后，需要通知C线程执行）</span>
            number = <span class="hljs-number">3</span>;
            <span class="hljs-comment">// 通知2号去干活了</span>
            condition3.signal();

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print15</span><span class="hljs-params">()</span> </span>&#123;
        lock.lock();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 判断</span>
            <span class="hljs-keyword">while</span>(number != <span class="hljs-number">3</span>) &#123;
                <span class="hljs-comment">// 不等于3，需要等待</span>
                condition3.await();
            &#125;

            <span class="hljs-comment">// 干活</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t &quot;</span> + number + <span class="hljs-string">&quot;\t&quot;</span> + i);
            &#125;

            <span class="hljs-comment">// 唤醒 （干完活后，需要通知C线程执行）</span>
            number = <span class="hljs-number">1</span>;
            <span class="hljs-comment">// 通知1号去干活了</span>
            condition1.signal();

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncAndReentrantLockDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        ShareResource shareResource = <span class="hljs-keyword">new</span> ShareResource();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                    shareResource.print5();
            &#125;
        &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                shareResource.print10();
            &#125;
        &#125;, <span class="hljs-string">&quot;B&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                shareResource.print15();
            &#125;
        &#125;, <span class="hljs-string">&quot;C&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<h1 id="第10章线程池"><a href="#第10章线程池" class="headerlink" title="第10章线程池"></a>第10章线程池</h1><h2 id="1-前言-2"><a href="#1-前言-2" class="headerlink" title="1 前言"></a>1 前言</h2><p>获取多线程的方法，我们都知道有三种，还有一种是实现Callable接口</p>
<ul>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>实例化Thread类</li>
<li>使用线程池获取</li>
</ul>
<h2 id="2-Callable接口"><a href="#2-Callable接口" class="headerlink" title="2 Callable接口"></a>2 Callable接口</h2><p>Callable接口，是一种让线程执行完成后，能够返回结果的</p>
<p>在说到Callable接口的时候，我们不得不提到Runnable接口</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 实现Runnable接口</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;

    &#125;
&#125;</code></pre></div>

<p>我们知道，实现Runnable接口的时候，需要重写run方法，也就是线程在启动的时候，会自动调用的方法</p>
<p>同理，我们实现Callable接口，也需要实现call方法，但是这个时候我们还需要有返回值，这个Callable接口的应用场景一般就在于批处理业务，比如转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Callable有返回值</span>
<span class="hljs-comment"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;come in Callable&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;
    &#125;
&#125;</code></pre></div>

<p>最后我们需要做的就是通过Thread线程， 将MyThread2实现Callable接口的类包装起来</p>
<p>这里需要用到的是FutureTask类，他实现了Runnable接口，并且还需要传递一个实现Callable接口的类作为构造函数</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// FutureTask：实现了Runnable接口，构造函数又需要传入 Callable接口</span>
<span class="hljs-comment">// 这里通过了FutureTask接触了Callable接口</span>
FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());</code></pre></div>

<p>然后在用Thread进行实例化，传入实现Runnabnle接口的FutureTask的类</p>
<div class="code-wrapper"><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;aaa&quot;</span>);
t1.start();</code></pre></div>

<p>最后通过 futureTask.get() 获取到返回值</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 输出FutureTask的返回值</span>
System.out.println(<span class="hljs-string">&quot;result FutureTask &quot;</span> + futureTask.get());</code></pre></div>

<p>这就相当于原来我们的方式是main方法一条龙之心，后面在引入Callable后，对于执行比较久的线程，可以单独新开一个线程进行执行，最后在进行汇总输出</p>
<p>最后需要注意的是 要求获得Callable线程的计算结果，如果没有计算完成就要去强求，会导致阻塞，直到计算完成</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317152541284.png" alt="image-20200317152541284"></p>
<p>也就是说 futureTask.get() 需要放在最后执行，这样不会导致主线程阻塞</p>
<p>也可以使用下面算法，使用类似于自旋锁的方式来进行判断是否运行完毕</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 判断futureTask是否计算完成</span>
<span class="hljs-keyword">while</span>(!futureTask.isDone()) &#123;

&#125;</code></pre></div>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>多个线程执行 一个FutureTask的时候，只会计算一次</p>
<div class="code-wrapper"><pre><code class="hljs java">FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());

<span class="hljs-comment">// 开启两个线程计算futureTask</span>
<span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;AAA&quot;</span>).start();
<span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;BBB&quot;</span>).start();</code></pre></div>

<p>如果我们要两个线程同时计算任务的话，那么需要这样写，需要定义两个futureTask</p>
<div class="code-wrapper"><pre><code class="hljs java">FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());
FutureTask&lt;Integer&gt; futureTask2 = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread2());

<span class="hljs-comment">// 开启两个线程计算futureTask</span>
<span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;AAA&quot;</span>).start();

<span class="hljs-keyword">new</span> Thread(futureTask2, <span class="hljs-string">&quot;BBB&quot;</span>).start();</code></pre></div>

<h2 id="3-ThreadPoolExecutor"><a href="#3-ThreadPoolExecutor" class="headerlink" title="3 ThreadPoolExecutor"></a>3 ThreadPoolExecutor</h2><h3 id="3-1-为什么用线程池"><a href="#3-1-为什么用线程池" class="headerlink" title="3.1 为什么用线程池"></a>3.1 为什么用线程池</h3><p>线程池做的主要工作就是控制运行的线程的数量，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p>
<p>它的主要特点为：线程复用、控制最大并发数、管理线程</p>
<p>线程池中的任务是放入到阻塞队列中的</p>
<h3 id="3-2-线程池的好处"><a href="#3-2-线程池的好处" class="headerlink" title="3.2 线程池的好处"></a>3.2 线程池的好处</h3><p>多核处理的好处是：省略的上下文的切换开销</p>
<p>原来我们实例化对象的时候，是使用 new关键字进行创建，到了Spring后，我们学了IOC依赖注入，发现Spring帮我们将对象已经加载到了Spring容器中，只需要通过@Autowrite注解，就能够自动注入，从而使用</p>
<p>因此使用多线程有下列的好处</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就立即执行</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<h3 id="3-3-架构说明"><a href="#3-3-架构说明" class="headerlink" title="3.3 架构说明"></a>3.3 架构说明</h3><p>Java中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors（代表工具类），ExecutorService，ThreadPoolExecutor这几个类。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317175202647.png" alt="image-20200317175202647"></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317175241007.png" alt="image-20200317175241007"></p>
<h3 id="3-4-创建线程池"><a href="#3-4-创建线程池" class="headerlink" title="3.4 创建线程池"></a>3.4 创建线程池</h3><ul>
<li>Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池<ul>
<li>执行长期的任务，性能好很多</li>
<li>创建一个定长线程池，可控制线程数最大并发数，超出的线程会在队列中等待</li>
</ul>
</li>
<li>Executors.newSingleThreadExecutor：创建一个只有1个线程的 单线程池<ul>
<li>一个任务一个任务执行的场景</li>
<li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li>
</ul>
</li>
<li>Executors.newCacheThreadPool();  创建一个可扩容的线程池<ul>
<li>执行很多短期异步的小程序或者负载教轻的服务器</li>
<li>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程</li>
</ul>
</li>
<li>Executors.newScheduledThreadPool(int corePoolSize)：线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</li>
</ul>
<p>具体使用，首先我们需要使用Executors工具类，进行创建线程池，这里创建了一个拥有5个线程的线程池</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span>
ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);

<span class="hljs-comment">// 创建一个只有一个线程的线程池</span>
ExecutorService threadPool = Executors.newSingleThreadExecutor();

<span class="hljs-comment">// 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span>
ExecutorService threadPool = Executors.newCacheThreadPool();</code></pre></div>

<p>然后我们执行下面的的应用场景</p>
<div class="code-wrapper"><pre><code class="hljs plain">模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</code></pre></div>

<p>我们需要使用 threadPool.execute执行业务，execute需要传入一个实现了Runnable接口的线程</p>
<div class="code-wrapper"><pre><code class="hljs java">threadPool.execute(() -&gt; &#123;
	System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户办理业务&quot;</span>);
&#125;);</code></pre></div>

<p>然后我们使用完毕后关闭线程池</p>
<div class="code-wrapper"><pre><code class="hljs java">threadPool.shutdown();</code></pre></div>

<p>完整代码为：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 第四种获取 / 使用 Java多线程的方式，通过线程池</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadPoolDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// Array  Arrays(辅助工具类)</span>
        <span class="hljs-comment">// Collection Collections(辅助工具类)</span>
        <span class="hljs-comment">// Executor Executors(辅助工具类)</span>


        <span class="hljs-comment">// 一池5个处理线程（用池化技术，一定要记得关闭）</span>
        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);

        <span class="hljs-comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span>
        <span class="hljs-keyword">try</span> &#123;

            <span class="hljs-comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
                threadPool.execute(() -&gt; &#123;
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="hljs-string">&quot; 办理业务&quot;</span>);
                &#125;);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            threadPool.shutdown();
        &#125;

    &#125;
&#125;</code></pre></div>

<p>最后结果：</p>
<div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">0</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">4</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">5</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">3</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">1</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">2</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">9</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">8</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">7</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">6</span> 办理业务</code></pre></div>

<p>我们能够看到，一共有5个线程，在给10个用户办理业务</p>
<h3 id="3-5-创建周期性执行任务的线程池"><a href="#3-5-创建周期性执行任务的线程池" class="headerlink" title="3.5  创建周期性执行任务的线程池"></a>3.5  创建周期性执行任务的线程池</h3><p>Executors.newScheduledThreadPool(int corePoolSize)：</p>
<p><strong>线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池</strong></p>
<p>底层使用 ScheduledThreadPoolExecutor 来实现 ScheduledThreadPoolExecutor 为ThreadPoolExecutor子类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,
              <span class="hljs-keyword">new</span> DelayedWorkQueue());
&#125;</code></pre></div>

<h4 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h4><div class="code-wrapper"><pre><code class="hljs java">  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">   * command：执行的任务 Callable或Runnable接口实现类</span>
<span class="hljs-comment">* delay：延时执行任务的时间</span>
<span class="hljs-comment">* unit：延迟时间单位</span>
<span class="hljs-comment">   */</span>
  <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,
                                     <span class="hljs-keyword">long</span> delay,
                                     TimeUnit unit)</code></pre></div>



<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException   &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * command：执行的任务 Callable或Runnable接口实现类</span>
<span class="hljs-comment">	 * initialDelay 第一次执行任务延迟时间</span>
<span class="hljs-comment">	 * period 连续执行任务之间的周期，从上一个任务开始执行时计算延迟多少开始执行下一个任务，但是还会等上一个任务结束之后。</span>
<span class="hljs-comment">	 * unit：延迟时间单位</span>
<span class="hljs-comment">     */</span>
<span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">long</span> period, TimeUnit unit)</code></pre></div>



<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException   &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span>
<span class="hljs-comment">     * command：执行的任务 Callable或Runnable接口实现类</span>
<span class="hljs-comment">	 * initialDelay 第一次执行任务延迟时间</span>
<span class="hljs-comment">	 * delay：连续执行任务之间的周期，从上一个任务全部执行完成时计算延迟多少开始执行下一个任务</span>
<span class="hljs-comment">	 * unit：延迟时间单位</span>
<span class="hljs-comment">     */</span>
<span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">long</span> delay, TimeUnit unit)</code></pre></div>

<h2 id="4-底层实现"><a href="#4-底层实现" class="headerlink" title="4 底层实现"></a>4 底层实现</h2><p>我们通过查看源码，点击了Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool能够发现底层都是使用了ThreadPoolExecutor</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317182004293.png" alt="image-20200317182004293"></p>
<p>我们可以看到线程池的内部，还使用到了LinkedBlockingQueue 链表阻塞队列</p>
<p>同时在查看Executors.newCacheThreadPool 看到底层用的是 SynchronousBlockingQueue阻塞队列</p>
<p>最后查看一下，完整的三个创建线程的方法</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317183202992.png" alt="image-20200317183202992"></p>
<h2 id="5-线程池的重要参数"><a href="#5-线程池的重要参数" class="headerlink" title="5 线程池的重要参数"></a>5 线程池的重要参数</h2><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317183600957.png" alt="image-20200317183600957"></p>
<p>线程池在创建的时候，一共有7大参数</p>
<ul>
<li>corePoolSize：核心线程数，线程池中的常驻核心线程数<ul>
<li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li>
<li>当线程池中的线程数目达到corePoolSize后，就会把到达的队列放到缓存队列中</li>
</ul>
</li>
<li>maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1、<ul>
<li>相当有扩容后的线程数，这个线程池能容纳的最多线程数</li>
</ul>
</li>
<li>keepAliveTime：多余的空闲线程存活时间<ul>
<li>当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的空闲线程会被销毁，直到只剩下corePoolSize个线程为止</li>
<li>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</li>
</ul>
</li>
<li>unit：keepAliveTime的单位</li>
<li>workQueue：任务队列，被提交的但未被执行的任务（类似于银行里面的候客区）<ul>
<li>LinkedBlockingQueue：链表阻塞队列</li>
<li>SynchronousBlockingQueue：同步阻塞队列</li>
</ul>
</li>
<li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程池 一般用默认即可</li>
<li>handler：拒绝策略，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的Runnable的策略</li>
</ul>
<p>当营业窗口和阻塞队列中都满了时候，就需要设置拒绝策略</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200317201150197.png" alt="image-20200317201150197"></p>
<h2 id="6-拒绝策略"><a href="#6-拒绝策略" class="headerlink" title="6 拒绝策略"></a>6 拒绝策略</h2><p>以下所有拒绝策略都实现了RejectedExecutionHandler接口</p>
<ul>
<li>AbortPolicy：默认，直接抛出RejectedExcutionException异常，阻止系统正常运行</li>
<li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li>
<li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者</li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li>
</ul>
<h2 id="7-线程池底层工作原理"><a href="#7-线程池底层工作原理" class="headerlink" title="7 线程池底层工作原理"></a>7 线程池底层工作原理</h2><h3 id="线程池运行架构图"><a href="#线程池运行架构图" class="headerlink" title="线程池运行架构图"></a>线程池运行架构图</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318154414717.png" alt="image-20200318154414717"></p>
<p>文字说明</p>
<ol>
<li><p>在创建了线程池后，等待提交过来的任务请求</p>
</li>
<li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断</p>
<ol>
<li>如果正在运行的线程池数量小于corePoolSize，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列</li>
<li>如果这时候队列满了，并且正在运行的线程数量还小于maximumPoolSize，那么还是创建非核心线程like运行这个任务；</li>
<li>如果队列满了并且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</li>
</ol>
</li>
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p>
</li>
<li><p>当一个线程无事可做操作一定的时间(keepAliveTime)时，线程池会判断：</p>
<ol>
<li>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉</li>
<li>所以线程池的所有任务完成后，它会最终收缩到corePoolSize的大小</li>
</ol>
</li>
</ol>
<p>以顾客去银行办理业务为例，谈谈线程池的底层工作原理</p>
<ol>
<li>最开始假设来了两个顾客，因为corePoolSize为2，因此这两个顾客直接能够去窗口办理</li>
<li>后面又来了三个顾客，因为corePool已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待</li>
<li>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li>
<li>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略</li>
<li>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</li>
</ol>
<h2 id="8-为什么不用默认创建的线程池？"><a href="#8-为什么不用默认创建的线程池？" class="headerlink" title="8 为什么不用默认创建的线程池？"></a>8 为什么不用默认创建的线程池？</h2><p>线程池创建的方法有：固定数的，单一的，可变的，那么在实际开发中，应该使用哪个？</p>
<p>我们一个都不用，在生产环境中是使用自己自定义的</p>
<p>为什么不用 Executors 中JDK提供的？</p>
<p>根据阿里巴巴手册：并发控制这章</p>
<ul>
<li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程<ul>
<li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</li>
</ul>
</li>
<li>线程池不允许使用Executors去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险<ul>
<li>Executors返回的线程池对象弊端如下：<ul>
<li>FixedThreadPool和SingleThreadPool：<ul>
<li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li>
</ul>
</li>
<li>CacheThreadPool和ScheduledThreadPool<ul>
<li>运行的请求队列长度为：Integer.MAX_VALUE，线程数上限太大导致oom</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="9-手写线程池"><a href="#9-手写线程池" class="headerlink" title="9 手写线程池"></a>9 手写线程池</h2><h3 id="9-1-采用默认拒绝策略"><a href="#9-1-采用默认拒绝策略" class="headerlink" title="9.1 采用默认拒绝策略"></a>9.1 采用默认拒绝策略</h3><p>从上面我们知道，因为默认的Executors创建的线程池，底层都是使用LinkBlockingQueue作为阻塞队列的，而LinkBlockingQueue虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有20多亿，可以相当是无界的了，因此我们要使用ThreadPoolExecutor自己手动创建线程池，然后指定阻塞队列的大小</p>
<p>下面我们创建了一个 核心线程数为2，最大线程数为5，并且阻塞队列数为3的线程池</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 手写线程池</span>
<span class="hljs-keyword">final</span> Integer corePoolSize = <span class="hljs-number">2</span>;
<span class="hljs-keyword">final</span> Integer maximumPoolSize = <span class="hljs-number">5</span>;
<span class="hljs-keyword">final</span> Long keepAliveTime = <span class="hljs-number">1L</span>;

<span class="hljs-comment">// 自定义线程池，只改变了LinkBlockingQueue的队列大小</span>
ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(
    corePoolSize,
    maximumPoolSize,
    keepAliveTime,
    TimeUnit.SECONDS,
    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>),
    Executors.defaultThreadFactory(),
    <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());</code></pre></div>

<p>然后使用for循环，模拟10个用户来进行请求</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span>
<span class="hljs-keyword">try</span> &#123;

    <span class="hljs-comment">// 循环十次，模拟业务办理，让5个线程处理这10个请求</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tempInt = i;
        executorService.execute(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 给用户:&quot;</span> + tempInt + <span class="hljs-string">&quot; 办理业务&quot;</span>);
        &#125;);
    &#125;
&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
    e.printStackTrace();
&#125; <span class="hljs-keyword">finally</span> &#123;
    executorService.shutdown();
&#125;</code></pre></div>

<p>但是在用户执行到第九个的时候，触发了异常，程序中断</p>
<div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">0</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">6</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">5</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">1</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">4</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">7</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">2</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">3</span> 办理业务
java.util.concurrent.RejectedExecutionException: Task com.moxi.interview.study.thread.MyThreadPoolDemo$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">1747585824</span>@4dd8dc3 rejected from java.util.concurrent.ThreadPoolExecutor@6d03e736[Running, pool size = <span class="hljs-number">5</span>, active threads = <span class="hljs-number">3</span>, queued tasks = <span class="hljs-number">0</span>, completed tasks = <span class="hljs-number">5</span>]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="hljs-number">2047</span>)
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="hljs-number">823</span>)
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="hljs-number">1369</span>)
	at com.moxi.interview.study.thread.MyThreadPoolDemo.main(MyThreadPoolDemo.java:<span class="hljs-number">34</span>)</code></pre></div>

<p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的AbortPolicy，也就是抛异常的</p>
<p>触发条件是，请求的线程大于 阻塞队列大小 + 最大线程数 = 8 的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p>
<h3 id="9-2-采用CallerRunsPolicy拒绝策略"><a href="#9-2-采用CallerRunsPolicy拒绝策略" class="headerlink" title="9.2 采用CallerRunsPolicy拒绝策略"></a>9.2 采用CallerRunsPolicy拒绝策略</h3><p>当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为回退策略，就是把任务丢回原来的请求开启线程着，我们看运行结果</p>
<div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">0</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">7</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">6</span> 办理业务
main	 给用户:<span class="hljs-number">8</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">5</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">1</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">9</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">4</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">3</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">2</span> 办理业务</code></pre></div>

<p>我们发现，输出的结果里面出现了main线程，因为线程池出发了拒绝策略，把任务回退到main线程，然后main线程对任务进行处理</p>
<h3 id="9-3-采用-DiscardPolicy-拒绝策略"><a href="#9-3-采用-DiscardPolicy-拒绝策略" class="headerlink" title="9.3 采用 DiscardPolicy 拒绝策略"></a>9.3 采用 DiscardPolicy 拒绝策略</h3><div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">0</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">5</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">2</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">1</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">4</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">7</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">6</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">3</span> 办理业务</code></pre></div>

<p>采用DiscardPolicy拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</p>
<h3 id="9-4-采用DiscardOldestPolicy拒绝策略"><a href="#9-4-采用DiscardOldestPolicy拒绝策略" class="headerlink" title="9.4 采用DiscardOldestPolicy拒绝策略"></a>9.4 采用DiscardOldestPolicy拒绝策略</h3><div class="code-wrapper"><pre><code class="hljs java">pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">0</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">6</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">4</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>	 给用户:<span class="hljs-number">5</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>	 给用户:<span class="hljs-number">1</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>	 给用户:<span class="hljs-number">9</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>	 给用户:<span class="hljs-number">8</span> 办理业务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>	 给用户:<span class="hljs-number">7</span> 办理业务</code></pre></div>

<p>这个策略和刚刚差不多，会把最久的队列中的任务替换掉</p>
<h2 id="10-线程池的合理参数"><a href="#10-线程池的合理参数" class="headerlink" title="10 线程池的合理参数"></a>10 线程池的合理参数</h2><p>生产环境中如何配置 corePoolSize 和 maximumPoolSize</p>
<p>这个是根据具体业务来配置的，分为CPU密集型和IO密集型</p>
<ul>
<li>CPU密集型</li>
</ul>
<p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p>
<p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p>
<p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</p>
<p>CPU密集型任务配置尽可能少的线程数量：</p>
<p>一般公式：CPU核数 + 1个线程数</p>
<ul>
<li>IO密集型</li>
</ul>
<p>由于IO密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p>
<p>IO密集型，即该任务需要大量的IO操作，即大量的阻塞</p>
<p>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力花费在等待上</p>
<p>所以IO密集型任务中使用多线程可以大大的加速程序的运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p>
<p>IO密集时，大部分线程都被阻塞，故需要多配置线程数：</p>
<p>参考公式：CPU核数 / (1 - 阻塞系数)      阻塞系数在0.8 ~ 0.9左右</p>
<p>例如：8核CPU：8/ (1 - 0.9) = 80个线程数</p>
<h1 id="第11章-死锁编码及定位分析"><a href="#第11章-死锁编码及定位分析" class="headerlink" title="第11章 死锁编码及定位分析"></a>第11章 死锁编码及定位分析</h1><h2 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1 概念"></a>1 概念</h2><p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象，若无外力干涉那他们都将无法推进下去。如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318175441578.png" alt="image-20200318175441578"></p>
<h2 id="2-产生死锁的原因"><a href="#2-产生死锁的原因" class="headerlink" title="2 产生死锁的原因"></a>2 产生死锁的原因</h2><ul>
<li>系统资源不足</li>
<li>进程运行推进的顺序不对</li>
<li>资源分配不当</li>
</ul>
<h2 id="3-死锁产生的四个必要条件"><a href="#3-死锁产生的四个必要条件" class="headerlink" title="3 死锁产生的四个必要条件"></a>3 死锁产生的四个必要条件</h2><ul>
<li>互斥<ul>
<li>解决方法：把互斥的共享资源封装成可同时访问</li>
</ul>
</li>
<li>占有且等待<ul>
<li>解决方法：进程请求资源时，要求它不占有任何其它资源，也就是它必须一次性申请到所有的资源，这种方式会导致资源效率低。</li>
</ul>
</li>
<li>非抢占式<ul>
<li>解决方法：如果进程不能立即分配资源，要求它不占有任何其他资源，也就是只能够同时获得所有需要资源时，才执行分配操作</li>
</ul>
</li>
<li>循环等待<ul>
<li>解决方法：对资源进行排序，要求进程按顺序请求资源。</li>
</ul>
</li>
</ul>
<h2 id="4-死锁代码"><a href="#4-死锁代码" class="headerlink" title="4 死锁代码"></a>4 死锁代码</h2><p>我们创建了一个资源类，然后让两个线程分别持有自己的锁，同时在尝试获取别人的，就会出现死锁现象</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 死锁小Demo</span>
<span class="hljs-comment"> * 死锁是指两个或多个以上的进程在执行过程中，</span>
<span class="hljs-comment"> * 因争夺资源而造成一种互相等待的现象，</span>
<span class="hljs-comment"> * 若无外力干涉那他们都将无法推进下去</span>
<span class="hljs-comment"> */</span>

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 资源类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HoldLockThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;

    <span class="hljs-keyword">private</span> String lockA;
    <span class="hljs-keyword">private</span> String lockB;

    <span class="hljs-comment">// 持有自己的锁，还想得到别人的锁</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HoldLockThread</span><span class="hljs-params">(String lockA, String lockB)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.lockA = lockA;
        <span class="hljs-keyword">this</span>.lockB = lockB;
    &#125;


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">synchronized</span> (lockA) &#123;
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 自己持有&quot;</span> + lockA + <span class="hljs-string">&quot;\t 尝试获取：&quot;</span> + lockB);

            <span class="hljs-keyword">try</span> &#123;
                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

            <span class="hljs-keyword">synchronized</span> (lockB) &#123;
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 自己持有&quot;</span> + lockB + <span class="hljs-string">&quot;\t 尝试获取：&quot;</span> + lockA);
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        String lockA = <span class="hljs-string">&quot;lockA&quot;</span>;
        String lockB = <span class="hljs-string">&quot;lockB&quot;</span>;

        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> HoldLockThread(lockA, lockB), <span class="hljs-string">&quot;t1&quot;</span>).start();

        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> HoldLockThread(lockB, lockA), <span class="hljs-string">&quot;t2&quot;</span>).start();
    &#125;
&#125;</code></pre></div>

<p>运行结果，main线程无法结束</p>
<div class="code-wrapper"><pre><code class="hljs java">t1	 自己持有lockA	 尝试获取：lockB
t2	 自己持有lockB	 尝试获取：lockA</code></pre></div>

<h2 id="5-如何排查死锁"><a href="#5-如何排查死锁" class="headerlink" title="5 如何排查死锁"></a>5 如何排查死锁</h2><p>当我们出现死锁的时候，首先需要使用jps命令查看运行的程序</p>
<div class="code-wrapper"><pre><code class="hljs java">jps -l</code></pre></div>

<p>我们能看到DeadLockDemo这个类，一直在运行</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318181504703.png" alt="image-20200318181504703"></p>
<p>在使用jstack查看堆栈信息</p>
<div class="code-wrapper"><pre><code class="hljs java">jstack  7560   # 后面参数是 jps输出的该类的pid</code></pre></div>

<p>得到的结果</p>
<div class="code-wrapper"><pre><code class="hljs java">Found one Java-level deadlock:
=============================
<span class="hljs-string">&quot;t2&quot;</span>:
  waiting to lock monitor <span class="hljs-number">0x000000001cfc0de8</span> (object <span class="hljs-number">0x000000076b696e80</span>, a java.lang.String),
  which is held by <span class="hljs-string">&quot;t1&quot;</span>
<span class="hljs-string">&quot;t1&quot;</span>:
  waiting to lock monitor <span class="hljs-number">0x000000001cfc3728</span> (object <span class="hljs-number">0x000000076b696eb8</span>, a java.lang.String),
  which is held by <span class="hljs-string">&quot;t2&quot;</span>

Java stack information <span class="hljs-keyword">for</span> the threads listed above:
===================================================
<span class="hljs-string">&quot;t2&quot;</span>:
        at com.moxi.interview.study.Lock.HoldLockThread.run(DeadLockDemo.java:<span class="hljs-number">42</span>)
        - waiting to lock &lt;<span class="hljs-number">0x000000076b696e80</span>&gt; (a java.lang.String)
        - locked &lt;<span class="hljs-number">0x000000076b696eb8</span>&gt; (a java.lang.String)
        at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)
<span class="hljs-string">&quot;t1&quot;</span>:
        at com.moxi.interview.study.Lock.HoldLockThread.run(DeadLockDemo.java:<span class="hljs-number">42</span>)
        - waiting to lock &lt;<span class="hljs-number">0x000000076b696eb8</span>&gt; (a java.lang.String)
        - locked &lt;<span class="hljs-number">0x000000076b696e80</span>&gt; (a java.lang.String)
        at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)

Found <span class="hljs-number">1</span> deadlock.</code></pre></div>

<p>通过查看最后一行，我们看到  Found 1 deadlock，即存在一个死锁</p>
<h1 id="第二部分-JVM"><a href="#第二部分-JVM" class="headerlink" title="第二部分 JVM"></a>第二部分 JVM</h1><h1 id="第-12-章-JVM"><a href="#第-12-章-JVM" class="headerlink" title="第 12 章 JVM"></a>第 12 章 JVM</h1><h2 id="1-JVM体系结构"><a href="#1-JVM体系结构" class="headerlink" title="1 JVM体系结构"></a>1 JVM体系结构</h2><h3 id="1-1-概览"><a href="#1-1-概览" class="headerlink" title="1.1 概览"></a>1.1 概览</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318182540332.png" alt="image-20200318182540332"></p>
<p>java gc 主要回收的是 方法区 和 堆中的内容</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318184401133.png" alt="image-20200318184401133"></p>
<h3 id="1-2-类加载器"><a href="#1-2-类加载器" class="headerlink" title="1.2 类加载器"></a>1.2 类加载器</h3><ul>
<li>类加载器是什么</li>
<li>双亲委派机制</li>
<li>Java类加载的沙箱安全机制</li>
</ul>
<h3 id="1-3-常见的垃圾回收算法"><a href="#1-3-常见的垃圾回收算法" class="headerlink" title="1.3 常见的垃圾回收算法"></a>1.3 常见的垃圾回收算法</h3><ul>
<li>引用计数</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318184508982.png" alt="image-20200318184508982"></p>
<p>在双端循环，互相引用的时候，容易报错，目前很少使用这种方式了</p>
<ul>
<li>复制</li>
</ul>
<p>复制算法在年轻代的时候，进行使用，复制时候有交换</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318184759295.png" alt="image-20200318184759295"></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="images/image-20200318184820787.png" alt="image-20200318184820787"></p>
<p>优点：没有产生内存碎片</p>
<ul>
<li>标记清除</li>
</ul>
<p>先标记，后清除，缺点是会产生内存碎片，用于老年代多一些</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318184944878.png" alt="image-20200318184944878"></p>
<ul>
<li>标记整理</li>
</ul>
<p>标记清除整理</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318185100936.png" alt="image-20200318185100936"></p>
<p>但是需要付出代价，因为移动对象需要成本</p>
<h2 id="2-JVM-面试题"><a href="#2-JVM-面试题" class="headerlink" title="2 JVM 面试题"></a>2 JVM 面试题</h2><h3 id="2-1-是么是-GCRoots-能做什么"><a href="#2-1-是么是-GCRoots-能做什么" class="headerlink" title="2.1 是么是 GCRoots 能做什么"></a>2.1 是么是 GCRoots 能做什么</h3><h4 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1 什么是垃圾"></a>1 什么是垃圾</h4><p>简单来说就是内存中已经不再被使用的空间就是垃圾</p>
<h4 id="2-如何判断一个对象是否可以被回收"><a href="#2-如何判断一个对象是否可以被回收" class="headerlink" title="2 如何判断一个对象是否可以被回收"></a>2 如何判断一个对象是否可以被回收</h4><h5 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h5><p>Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。</p>
<p>因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器</p>
<p>每当有一个地方引用它，计数器值加1</p>
<p>每当有一个引用失效，计数器值减1</p>
<p>任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。</p>
<p>那么为什么主流的Java虚拟机里面都没有选用这个方法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
<p>该算法存在但目前无人用了，解决不了循环引用的问题，了解即可。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200318213301603.png" alt="image-20200318213301603"></p>
<h5 id="2-2-枚举根节点做可达性分析"><a href="#2-2-枚举根节点做可达性分析" class="headerlink" title="2.2 枚举根节点做可达性分析"></a>2.2 枚举根节点做可达性分析</h5><p>根搜索路径算法</p>
<p>为了解决引用计数法的循环引用个问题，Java使用了可达性分析的方法：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200319113611244.png" alt="image-20200319113611244"></p>
<p>所谓 GC Roots 或者说 Tracing Roots的“根集合” 就是一组必须活跃的引用</p>
<p>基本思路就是通过一系列名为 GC Roots的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的对象就被判定为死亡</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200319114526625.png" alt="image-20200319114526625"></p>
<p>必须从GC Roots对象开始，这个类似于linux的 /  也就是根目录</p>
<p>蓝色部分是从GC Roots出发，能够循环可达</p>
<p>而白色部分，从GC Roots出发，无法到达</p>
<h5 id="2-3-一句话理解GC-Roots"><a href="#2-3-一句话理解GC-Roots" class="headerlink" title="2.3 一句话理解GC Roots"></a>2.3 一句话理解GC Roots</h5><p>假设我们现在有三个实体，分别是 人，狗，毛衣</p>
<p>然后他们之间的关系是：人 牵着 狗，狗穿着毛衣，他们之间是强连接的关系</p>
<p>有一天人消失了，只剩下狗狗 和 毛衣，这个时候，把人想象成 GC Roots，因为 人 和 狗之间失去了绳子连接，</p>
<p>那么狗可能被回收，也就是被警察抓起来，被送到流浪狗寄养所</p>
<p>假设狗和人有强连接的时候，狗狗就不会被当成是流浪狗</p>
<h5 id="2-4-那些对象可以当做GC-Roots"><a href="#2-4-那些对象可以当做GC-Roots" class="headerlink" title="2.4 那些对象可以当做GC Roots"></a>2.4 那些对象可以当做GC Roots</h5><ul>
<li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中的JNI（Native方法）的引用对象</li>
</ul>
<h5 id="2-5-代码说明"><a href="#2-5-代码说明" class="headerlink" title="2.5 代码说明"></a>2.5 代码说明</h5><div class="code-wrapper"><pre><code class="hljs java">
<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 在Java中，可以作为GC Roots的对象有：</span>
<span class="hljs-comment"> * - 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</span>
<span class="hljs-comment"> * - 方法区中的类静态属性引用的对象</span>
<span class="hljs-comment"> * - 方法区中常量引用的对象</span>
<span class="hljs-comment"> * - 本地方法栈中的JNI（Native方法）的引用对象</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCRootDemo</span> </span>&#123;


    <span class="hljs-comment">// 方法区中的类静态属性引用的对象</span>
    <span class="hljs-comment">// private static GCRootDemo2 t2;</span>

    <span class="hljs-comment">// 方法区中的常量引用，GC Roots 也会以这个为起点，进行遍历</span>
    <span class="hljs-comment">// private static final GCRootDemo3 t3 = new GCRootDemo3(8);</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 第一种，虚拟机栈中的引用对象</span>
        GCRootDemo t1 = <span class="hljs-keyword">new</span> GCRootDemo();
        System.gc();
        System.out.println(<span class="hljs-string">&quot;第一次GC完成&quot;</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        m1();
    &#125;
&#125;</code></pre></div>

<h3 id="2-2-JVM参数调优"><a href="#2-2-JVM参数调优" class="headerlink" title="2.2  JVM参数调优"></a>2.2  JVM参数调优</h3><h4 id="1-前言-3"><a href="#1-前言-3" class="headerlink" title="1 前言"></a>1 前言</h4><p>你说你做过JVM调优和参数配置，请问如何盘点查看JVM系统默认值</p>
<p>使用jps和jinfo进行查看</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms：初始堆空间</span>
<span class="hljs-deletion">-Xmx：堆最大值</span>
<span class="hljs-deletion">-Xss：栈空间</span></code></pre></div>

<p>-Xms 和 -Xmx最好调整一致，防止JVM频繁进行收集和回收</p>
<h4 id="2-JVM参数类型"><a href="#2-JVM参数类型" class="headerlink" title="2 JVM参数类型"></a>2 JVM参数类型</h4><ul>
<li>标配参数（从JDK1.0 - Java12都在，很稳定）<ul>
<li>-version</li>
<li>-help</li>
<li>java -showversion</li>
</ul>
</li>
<li>X参数（了解）<ul>
<li>-Xint：解释执行</li>
<li>-Xcomp：第一次使用就编译成本地代码</li>
<li>-Xmixed：混合模式</li>
</ul>
</li>
<li>XX参数（重点）<ul>
<li>Boolean类型<ul>
<li>公式：-XX:+ 或者-某个属性   + 表示开启，-表示关闭</li>
<li>Case：-XX:-PrintGCDetails：表示关闭了GC详情输出</li>
</ul>
</li>
<li>key-value类型<ul>
<li>公式：-XX:属性key=属性value</li>
<li>不满意初始值，可以通过下列命令调整</li>
<li>case：如何：-XX:MetaspaceSize=21807104：查看Java元空间的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-查看运行的Java程序，JVM参数是否开启，具体值为多少？"><a href="#3-查看运行的Java程序，JVM参数是否开启，具体值为多少？" class="headerlink" title="3 查看运行的Java程序，JVM参数是否开启，具体值为多少？"></a>3 查看运行的Java程序，JVM参数是否开启，具体值为多少？</h4><p>首先我们运行一个HelloGC的java程序</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloGC</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        System.out.println(<span class="hljs-string">&quot;hello GC&quot;</span>);
        Thread.sleep(Integer.MAX_VALUE);
    &#125;
&#125;</code></pre></div>

<p>然后使用下列命令查看它的默认参数</p>
<div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps：查看java的后台进程</span>
<span class="hljs-keyword">jinfo：查看正在运行的java程序</span></code></pre></div>

<p>具体使用：</p>
<div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps </span>-l得到进程号</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-number">12608</span> com.moxi.interview.study.GC.HelloGC
<span class="hljs-number">15200</span> sun.tools.jps.Jps
<span class="hljs-number">15296</span> org.jetbrains.idea.maven.server.RemoteMavenServer36
<span class="hljs-number">4528</span>
<span class="hljs-number">12216</span> org.jetbrains.jps.cmdline.Launcher
<span class="hljs-number">9772</span> org.jetbrains.kotlin.daemon.KotlinCompileDaemon</code></pre></div>

<p>查看到HelloGC的进程号为：12608</p>
<p>我们使用jinfo -flag 然后查看是否开启PrintGCDetails这个参数</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">jinfo</span> -flag PrintGCDetails <span class="hljs-number">12608</span></code></pre></div>

<p>得到的内容为</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:-PrintGCDetails</span></code></pre></div>

<p>上面提到了，-号表示关闭，即没有开启PrintGCDetails这个参数</p>
<p>下面我们需要在启动HelloGC的时候，增加 PrintGCDetails这个参数，需要在运行程序的时候配置JVM参数</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200319122922264.png" alt="image-20200319122922264"></p>
<p>然后在VM Options中加入下面的代码，现在+号表示开启</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+PrintGCDetails</span></code></pre></div>

<p>然后在使用jinfo查看我们的配置</p>
<div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jps </span>-l
<span class="hljs-keyword">jinfo </span>-flag PrintGCDetails <span class="hljs-number">13540</span></code></pre></div>

<p>得到的结果为</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+PrintGCDetails</span></code></pre></div>

<p>我们看到原来的-号变成了+号，说明我们通过 VM Options配置的JVM参数已经生效了</p>
<p>使用下列命令，会把jvm的全部默认参数输出</p>
<div class="code-wrapper"><pre><code class="hljs asciidoc">jinfo -flags <span class="hljs-strong">***</span></code></pre></div>

<h4 id="4-题外话（坑题）"><a href="#4-题外话（坑题）" class="headerlink" title="4 题外话（坑题）"></a>4 题外话（坑题）</h4><p>两个经典参数：-Xms  和 -Xmx，这两个参数 如何解释</p>
<p>这两个参数，还是属于XX参数，因为取了别名</p>
<ul>
<li>-Xms  等价于 -XX:InitialHeapSize  ：初始化堆内存（默认只会用最大物理内存的64分1）</li>
<li>-Xmx 等价于 -XX:MaxHeapSize    ：最大堆内存（默认只会用最大物理内存的4分1）</li>
</ul>
<h4 id="5-查看JVM默认参数"><a href="#5-查看JVM默认参数" class="headerlink" title="5 查看JVM默认参数"></a>5 查看JVM默认参数</h4><ul>
<li><p>-XX:+PrintFlagsInitial</p>
<ul>
<li>主要是查看初始默认值</li>
<li>公式<ul>
<li>java -XX:+PrintFlagsInitial -version</li>
<li>java -XX:+PrintFlagsInitial（重要参数）</li>
</ul>
</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200320212256284.png" alt="image-20200320212256284">   </p>
</li>
<li><p>-XX:+PrintFlagsFinal：表示修改以后，最终的值</p>
<div class="code-wrapper"><pre><code>会将JVM的各个结果都进行打印

如果有  := 表示修改过的， = 表示没有修改过的</code></pre></div></li>
</ul>
<h4 id="6-工作中常用的JVM基本配置参数"><a href="#6-工作中常用的JVM基本配置参数" class="headerlink" title="6 工作中常用的JVM基本配置参数"></a>6 工作中常用的JVM基本配置参数</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200322163252777.png" alt="image-20200322163252777"></p>
<h5 id="6-1-查看堆内存"><a href="#6-1-查看堆内存" class="headerlink" title="6.1 查看堆内存"></a>6.1 查看堆内存</h5><p>查看JVM的初始化堆内存 -Xms 和最大堆内存 Xmx</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloGC</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-comment">// 返回Java虚拟机中内存的总量</span>
        <span class="hljs-keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();

        <span class="hljs-comment">// 返回Java虚拟机中试图使用的最大内存量</span>
        <span class="hljs-keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();

        System.out.println(<span class="hljs-string">&quot;TOTAL_MEMORY(-Xms) = &quot;</span> + totalMemory + <span class="hljs-string">&quot;(字节)、&quot;</span> + (totalMemory / (<span class="hljs-keyword">double</span>)<span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;MAX_MEMORY(-Xmx) = &quot;</span> + maxMemory + <span class="hljs-string">&quot;(字节)、&quot;</span> + (maxMemory / (<span class="hljs-keyword">double</span>)<span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);

    &#125;
&#125;</code></pre></div>

<p>运行结果为：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">TOTAL_MEMORY</span>(-Xms) = <span class="hljs-number">257425408</span>(字节)、<span class="hljs-number">245</span>.<span class="hljs-number">5</span>MB
<span class="hljs-attribute">MAX_MEMORY</span>(-Xmx) = <span class="hljs-number">3790077952</span>(字节)、<span class="hljs-number">3614</span>.<span class="hljs-number">5</span>MB</code></pre></div>

<p>-Xms 初始堆内存为：物理内存的1/64          -Xmx 最大堆内存为：系统物理内存的 1/4</p>
<h5 id="6-2-打印JVM默认参数"><a href="#6-2-打印JVM默认参数" class="headerlink" title="6.2 打印JVM默认参数"></a>6.2 打印JVM默认参数</h5><p>使用 <code>-XX:+PrintCommandLineFlags</code> 打印出JVM的默认的简单初始化参数</p>
<p>比如我的机器输出为：</p>
<div class="code-wrapper"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">InitialHeapSize</span>=266376000 -XX:<span class="hljs-attribute">MaxHeapSize</span>=4262016000 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</code></pre></div>

<h5 id="6-3-生活常用调优参数"><a href="#6-3-生活常用调优参数" class="headerlink" title="6.3 生活常用调优参数"></a>6.3 生活常用调优参数</h5><ul>
<li>-Xms：初始化堆内存，默认为物理内存的1/64，等价于 -XX:initialHeapSize</li>
<li>-Xmx：最大堆内存，默认为物理内存的1/4，等价于-XX:MaxHeapSize</li>
<li>-Xss：设计单个线程栈的大小，一般默认为512K~1024K，等价于 -XX:ThreadStackSize<ul>
<li>使用 jinfo -flag ThreadStackSize   会发现 -XX:ThreadStackSize = 0</li>
<li>这个值的大小是取决于平台的</li>
<li>Linux/x64:1024KB</li>
<li>OS X：1024KB</li>
<li>Oracle Solaris：1024KB</li>
<li>Windows：取决于虚拟内存的大小</li>
</ul>
</li>
<li>-Xmn：设置年轻代大小</li>
<li>-XX:MetaspaceSize：设置元空间大小<ul>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制。</li>
<li>-Xms10m -Xmx10m -XX:MetaspaceSize=1024m  -XX:+PrintFlagsFinal</li>
<li>但是默认的元空间大小：只有20多M</li>
<li>为了防止在频繁的实例化对象的时候，让元空间出现OOM，因此可以把元空间设置的大一些</li>
</ul>
</li>
<li>-XX:PrintGCDetails：输出详细GC收集日志信息<ul>
<li>GC</li>
<li>Full GC</li>
</ul>
</li>
</ul>
<p>GC日志收集流程图</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200322185639902.png" alt="image-20200322185639902"></p>
<p>我们使用一段代码，制造出垃圾回收的过程</p>
<p>首先我们设置一下程序的启动配置:  设置初始堆内存为10M，最大堆内存为10M</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:+PrintGCDetails</span></code></pre></div>

<p>然后用下列代码，创建一个 非常大空间的byte类型数组</p>
<div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">byte</span> [] byteArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">50</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];</code></pre></div>

<p>运行后，发现会出现下列错误，这就是OOM：java内存溢出，也就是堆空间不足</p>
<div class="code-wrapper"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>: Java heap space
	at com<span class="hljs-selector-class">.moxi</span><span class="hljs-selector-class">.interview</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.GC</span><span class="hljs-selector-class">.HelloGC</span><span class="hljs-selector-class">.main</span>(HelloGC<span class="hljs-selector-class">.java</span>:<span class="hljs-number">22</span>)</code></pre></div>

<p>同时还打印出了GC垃圾回收时候的详情</p>
<div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">1972</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">504</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">1972</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">740</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0156109</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.03</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">504</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">480</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">740</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">772</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0007815</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">480</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">292</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">772</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0080505</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0003035</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">630</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">630</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058502</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-variable">Heap</span>
 <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">80</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">2048</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">3</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd143d8</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fff80000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span>
 <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">630</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span>
  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">8</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff600000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff69dbd0</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ffd00000</span><span class="hljs-punctuation">)</span>
 <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3510</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4500</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span>
  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">389</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">392</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span></code></pre></div>

<p>问题发生的原因：</p>
<p>因为们通过 -Xms10m  和 -Xmx10m 只给Java堆栈设置了10M的空间，但是创建了50M的对象，因此就会出现空间不足，而导致出错</p>
<p>同时在垃圾收集的时候，我们看到有两个对象：GC 和 Full GC</p>
<h5 id="6-4-GC垃圾收集"><a href="#6-4-GC垃圾收集" class="headerlink" title="6.4 GC垃圾收集"></a>6.4 GC垃圾收集</h5><p>GC在新生区</p>
<div class="code-wrapper"><pre><code class="hljs json">[GC (Allocation Failure) [PSYoungGen: <span class="hljs-number">1972</span>K-&gt;<span class="hljs-number">504</span>K(<span class="hljs-number">2560</span>K)] <span class="hljs-number">1972</span>K-&gt;<span class="hljs-number">740</span>K(<span class="hljs-number">9728</span>K), <span class="hljs-number">0.0156109</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.03</span> secs]</code></pre></div>

<p>GC (Allocation Failure)：表示分配失败，那么就需要触发年轻代空间中的内容被回收</p>
<div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">1972</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">504</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">1972</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">740</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0156109</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span></code></pre></div>

<p>参数对应的图为：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200323124000865.png" alt="image-20200323124000865"></p>
<h5 id="6-6-Full-GC垃圾回收"><a href="#6-6-Full-GC垃圾回收" class="headerlink" title="6.6 Full GC垃圾回收"></a>6.6 Full GC垃圾回收</h5><p>Full GC大部分发生在养老区</p>
<div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">2560</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">630</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">7168</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">648</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">630</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">9728</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3467</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0058502</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200323125839653.png" alt="image-20200323125839653"></p>
<p>规律：</p>
<div class="code-wrapper"><pre><code class="hljs clojure">[名称： GC前内存占用 -&gt; GC后内存占用 (该区内存总大小)]</code></pre></div>

<p>当我们出现了老年代都扛不住的时候，就会出现OOM异常</p>
<h5 id="6-7-XX-SurvivorRatio"><a href="#6-7-XX-SurvivorRatio" class="headerlink" title="6.7 -XX:SurvivorRatio"></a>6.7 -XX:SurvivorRatio</h5><p>调节新生代中 eden 和 S0、S1的空间比例，默认为 -XX:SuriviorRatio=8，Eden:S0:S1 = 8:1:1</p>
<p>加入设置成 -XX:SurvivorRatio=4，则为 Eden:S0:S1 = 4:1:1</p>
<p>SurvivorRatio值就是设置eden区的比例占多少，S0和S1相同</p>
<p>Java堆从GC的角度还可以细分为：新生代（Eden区，From Survivor区合To Survivor区）和老年代</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200323130442088.png" alt="image-20200323130442088"></p>
<ul>
<li>eden、SurvivorFrom复制到SurvivorTo，年龄 + 1</li>
</ul>
<p>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom去，当Eden区再次触发GC的时候会扫描Eden区合From区域，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到To区域（如果对象的年龄已经到达老年的标准，则赋值到老年代区），通知把这些对象的年龄 + 1</p>
<ul>
<li>清空eden、SurvivorFrom</li>
</ul>
<p>然后，清空eden，SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</p>
<ul>
<li>SurvivorTo和SurvivorFrom互换</li>
</ul>
<p>最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200323150946414.png" alt="image-20200323150946414"></p>
<h5 id="6-8-XX-NewRatio（了解）"><a href="#6-8-XX-NewRatio（了解）" class="headerlink" title="6.8 -XX:NewRatio（了解）"></a>6.8 -XX:NewRatio（了解）</h5><p>配置年轻代new 和老年代old 在堆结构的占比</p>
<p>默认： -XX:NewRatio=2 新生代占1，老年代2，年轻代占整个堆的1/3</p>
<p>-XX:NewRatio=4：新生代占1，老年代占4，年轻代占整个堆的1/5，NewRadio值就是设置老年代的占比，剩下的1个新生代</p>
<p>新生代特别小，会造成频繁的进行GC收集</p>
<h5 id="6-9-XX-MaxTenuringThreshold"><a href="#6-9-XX-MaxTenuringThreshold" class="headerlink" title="6.9 -XX:MaxTenuringThreshold"></a>6.9 -XX:MaxTenuringThreshold</h5><p>设置垃圾最大年龄，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代</p>
<p>这里就是调整这个次数的，默认是15，并且设置的值 在 0~15之间</p>
<p>查看默认进入老年代年龄：jinfo -flag MaxTenuringThreshold 17344</p>
<p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过Survivor区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概念</p>
<h3 id="2-3-Java中的引用"><a href="#2-3-Java中的引用" class="headerlink" title="2.3 Java中的引用"></a>2.3 Java中的引用</h3><h4 id="1-前言-4"><a href="#1-前言-4" class="headerlink" title="1 前言"></a>1 前言</h4><p>在原来的时候，我们谈到一个类的实例化</p>
<div class="code-wrapper"><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Person()</code></pre></div>

<p>在等号的左边，就是一个对象的引用，存储在栈中</p>
<p>而等号右边，就是实例化的对象，存储在堆中</p>
<p>其实这样的一个引用关系，就被称为强引用</p>
<h4 id="2-整体架构"><a href="#2-整体架构" class="headerlink" title="2 整体架构"></a>2 整体架构</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200323155120778.png" alt="image-20200323155120778"></p>
<h4 id="3-强引用"><a href="#3-强引用" class="headerlink" title="3 强引用"></a>3 强引用</h4><p>当内存不足的时候，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，打死也不回收~！</p>
<p>强引用是我们最常见的普通对象引用，只要还有一个强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收，因此强引用是造成Java内存泄漏的主要原因之一。</p>
<p>对于一个普通的对象，如果没有其它的引用关系，只要超过了引用的作用于或者显示地将相应（强）引用赋值为null，一般可以认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾回收策略）</p>
<p>强引用小例子：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 强引用</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrongReferenceDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 这样定义的默认就是强应用</span>
        Object obj1 = <span class="hljs-keyword">new</span> Object();

        <span class="hljs-comment">// 使用第二个引用，指向刚刚创建的Object对象</span>
        Object obj2 = obj1;

        <span class="hljs-comment">// 置空</span>
        obj1 = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// 垃圾回收</span>
        System.gc();

        System.out.println(obj1);

        System.out.println(obj2);
    &#125;
&#125;</code></pre></div>

<p>输出结果我们能够发现，即使 obj1 被设置成了null，然后调用gc进行回收，但是也没有回收实例出来的对象，obj2还是能够指向该地址，也就是说垃圾回收器，并没有将该对象进行垃圾回收</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">null</span>
java.lang.Object@14ae5a5</code></pre></div>

<h4 id="4-软引用"><a href="#4-软引用" class="headerlink" title="4 软引用"></a>4 软引用</h4><p>软引用是一种相对弱化了一些的引用，需要用Java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集，对于只有软引用的对象来讲：</p>
<ul>
<li>当系统内存充足时，它不会被回收</li>
<li>当系统内存不足时，它会被回收</li>
</ul>
<p>软引用通常在对内存敏感的程序中，比如高速缓存就用到了软引用，内存够用 的时候就保留，不够用就回收</p>
<p>具体使用</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 软引用</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SoftReferenceDemo</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 内存够用的时候</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">softRefMemoryEnough</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 创建一个强应用</span>
        Object o1 = <span class="hljs-keyword">new</span> Object();
        <span class="hljs-comment">// 创建一个软引用</span>
        SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(o1);
        System.out.println(o1);
        System.out.println(softReference.get());

        o1 = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 手动GC</span>
        System.gc();

        System.out.println(o1);
        System.out.println(softReference.get());
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * JVM配置，故意产生大对象并配置小的内存，让它的内存不够用了导致OOM，看软引用的回收情况</span>
<span class="hljs-comment">     * -Xms5m -Xmx5m -XX:+PrintGCDetails</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">softRefMemoryNoEnough</span><span class="hljs-params">()</span> </span>&#123;

        System.out.println(<span class="hljs-string">&quot;========================&quot;</span>);
        <span class="hljs-comment">// 创建一个强应用</span>
        Object o1 = <span class="hljs-keyword">new</span> Object();
        <span class="hljs-comment">// 创建一个软引用</span>
        SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(o1);
        System.out.println(o1);
        System.out.println(softReference.get());

        o1 = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// 模拟OOM自动GC</span>
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 创建30M的大对象</span>
            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">30</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            System.out.println(o1);
            System.out.println(softReference.get());
        &#125;

    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        softRefMemoryEnough();

        softRefMemoryNoEnough();
    &#125;
&#125;
</code></pre></div>

<p>我们写了两个方法，一个是内存够用的时候，一个是内存不够用的时候</p>
<p>我们首先查看内存够用的时候，首先输出的是 o1 和 软引用的 softReference，我们都能够看到值</p>
<p>然后我们把o1设置为null，执行手动GC后，我们发现softReference的值还存在，说明内存充足的时候，软引用的对象不会被回收</p>
<div class="code-wrapper"><pre><code class="hljs java">java.lang.Object@14ae5a5
java.lang.Object@14ae5a5

[GC (System.gc()) [PSYoungGen: 1396K-&gt;504K(1536K)] 1504K-&gt;732K(5632K), <span class="hljs-number">0.0007842</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] 
[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 504K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(1536K)</span>] [ParOldGen: 228K-&gt;651<span class="hljs-title">K</span><span class="hljs-params">(4096K)</span>] 732K-&gt;651<span class="hljs-title">K</span><span class="hljs-params">(5632K)</span>, [Metaspace: 3480K-&gt;3480<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0058450 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] 

<span class="hljs-keyword">null</span>
java.lang.Object@14ae5a5</code></pre></div>

<p>下面我们看当内存不够的时候，我们使用了JVM启动参数配置，给初始化堆内存为5M</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms5m -Xmx5m -XX:+PrintGCDetails</span></code></pre></div>

<p>但是在创建对象的时候，我们创建了一个30M的大对象</p>
<div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">// 创建30M的大对象</span>
<span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">30</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];</code></pre></div>

<p>这就必然会触发垃圾回收机制，这也是中间出现的垃圾回收过程，最后看结果我们发现，o1 和 softReference都被回收了，因此说明，软引用在内存不足的时候，会自动回收</p>
<div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">Object</span><span class="hljs-operator">@</span><span class="hljs-number">7</span><span class="hljs-variable">f31245a</span>
<span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">Object</span><span class="hljs-operator">@</span><span class="hljs-number">7</span><span class="hljs-variable">f31245a</span>

<span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">31</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">160</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1536</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">682</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">811</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">5632</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0003603</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">160</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">96</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1536</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">811</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">747</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">5632</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0006385</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">96</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1536</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">651</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4096</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">747</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">5632</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3488</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3488</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0067976</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.02</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1536</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">5632</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0004024</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1536</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">627</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">4096</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">627</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">5632</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3488</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3488</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0065506</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 

<span class="hljs-variable">null</span>
<span class="hljs-variable">null</span></code></pre></div>

<h4 id="5-弱引用"><a href="#5-弱引用" class="headerlink" title="5 弱引用"></a>5 弱引用</h4><p>不管内存是否够，只要有GC操作就会进行回收</p>
<p>弱引用需要用 <code>java.lang.ref.WeakReference</code> 类来实现，它比软引用生存期更短</p>
<p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的空间。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 弱引用</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeakReferenceDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Object o1 = <span class="hljs-keyword">new</span> Object();
        WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(o1);
        System.out.println(o1);
        System.out.println(weakReference.get());
        o1 = <span class="hljs-keyword">null</span>;
        System.gc();
        System.out.println(o1);
        System.out.println(weakReference.get());
    &#125;
&#125;</code></pre></div>

<p>我们看结果，能够发现，我们并没有制造出OOM内存溢出，而只是调用了一下GC操作，垃圾回收就把它给收集了</p>
<div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">Object</span><span class="hljs-operator">@</span><span class="hljs-number">14</span><span class="hljs-variable">ae5a5</span>
<span class="hljs-variable">java</span><span class="hljs-operator">.</span><span class="hljs-variable">lang</span><span class="hljs-operator">.</span><span class="hljs-variable">Object</span><span class="hljs-operator">@</span><span class="hljs-number">14</span><span class="hljs-variable">ae5a5</span>

<span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">5246</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">5246</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0008236</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 
<span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">8</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">675</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">675</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3494</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3494</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0035953</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> 

<span class="hljs-variable">null</span>
<span class="hljs-variable">null</span></code></pre></div>

<h4 id="6-软引用和弱引用的使用场景"><a href="#6-软引用和弱引用的使用场景" class="headerlink" title="6 软引用和弱引用的使用场景"></a>6 软引用和弱引用的使用场景</h4><p>场景：假如有一个应用需要读取大量的本地图片</p>
<ul>
<li>如果每次读取图片都从硬盘读取则会严重影响性能</li>
<li>如果一次性全部加载到内存中，又可能造成内存溢出</li>
</ul>
<p>此时使用软引用可以解决这个问题</p>
<p>设计思路：使用HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占的空间，从而有效地避免了OOM的问题</p>
<div class="code-wrapper"><pre><code class="hljs java">Map&lt;String, SoftReference&lt;String&gt;&gt; imageCache = <span class="hljs-keyword">new</span> HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</code></pre></div>

<h5 id="WeakHashMap是什么？"><a href="#WeakHashMap是什么？" class="headerlink" title="WeakHashMap是什么？"></a>WeakHashMap是什么？</h5><p>比如一些常常和底层打交道的，mybatis等，底层都应用到了WeakHashMap</p>
<p>WeakHashMap和HashMap类似，只不过它的Key是使用了弱引用的，也就是说，当执行GC的时候，HashMap中的key会进行回收，下面我们使用例子来测试一下</p>
<p>我们使用了两个方法，一个是普通的HashMap方法</p>
<p>我们输入一个Key-Value键值对，然后让它的key置空，然后在查看结果</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myHashMap</span><span class="hljs-params">()</span> </span>&#123;
    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    Integer key = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);
    String value = <span class="hljs-string">&quot;HashMap&quot;</span>;

    map.put(key, value);
    System.out.println(map);

    key = <span class="hljs-keyword">null</span>;

    System.gc();

    System.out.println(map);
&#125;</code></pre></div>

<p>第二个是使用了WeakHashMap，完整代码如下</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * WeakHashMap</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeakHashMapDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        myHashMap();
        System.out.println(<span class="hljs-string">&quot;==========&quot;</span>);
        myWeakHashMap();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myHashMap</span><span class="hljs-params">()</span> </span>&#123;
        Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        Integer key = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);
        String value = <span class="hljs-string">&quot;HashMap&quot;</span>;

        map.put(key, value);
        System.out.println(map);

        key = <span class="hljs-keyword">null</span>;

        System.gc();

        System.out.println(map);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myWeakHashMap</span><span class="hljs-params">()</span> </span>&#123;
        Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;();
        Integer key = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);
        String value = <span class="hljs-string">&quot;WeakHashMap&quot;</span>;

        map.put(key, value);
        System.out.println(map);

        key = <span class="hljs-keyword">null</span>;

        System.gc();

        System.out.println(map);
    &#125;
&#125;</code></pre></div>

<p>最后输出结果为：</p>
<div class="code-wrapper"><pre><code class="hljs java">&#123;<span class="hljs-number">1</span>=HashMap&#125;
&#123;<span class="hljs-number">1</span>=HashMap&#125;
==========
&#123;<span class="hljs-number">1</span>=WeakHashMap&#125;
&#123;&#125;</code></pre></div>

<p>从这里我们看到，对于普通的HashMap来说，key置空并不会影响，HashMap的键值对，因为这个属于强引用，不会被垃圾回收。</p>
<p>但是WeakHashMap，在进行GC操作后，弱引用的就会被回收</p>
<h4 id="7-虚引用"><a href="#7-虚引用" class="headerlink" title="7 虚引用"></a>7 虚引用</h4><h5 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 概念</h5><p>虚引用又称为幽灵引用，需要<code>java.lang.ref.PhantomReference</code> 类来实现</p>
<p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p>
<p>如果一个对象持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列ReferenceQueue联合使用。</p>
<p>虚引用的主要作用和跟踪对象被垃圾回收的状态，仅仅是提供一种确保对象被finalize以后，做某些事情的机制。</p>
<p>PhantomReference的get方法总是返回null，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p>
<p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候，收到一个系统通知或者后续添加进一步的处理，Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前，做必要的清理工作</p>
<p>这个就相当于Spring AOP里面的后置通知</p>
<h5 id="7-2-场景"><a href="#7-2-场景" class="headerlink" title="7.2 场景"></a>7.2 场景</h5><p>一般用于在回收时候做通知相关操作</p>
<h4 id="8-引用队列-ReferenceQueue"><a href="#8-引用队列-ReferenceQueue" class="headerlink" title="8 引用队列 ReferenceQueue"></a>8 引用队列 ReferenceQueue</h4><p>软引用，弱引用，虚引用在回收之前，需要在引用队列保存一下</p>
<p>我们在初始化的弱引用或者虚引用的时候，可以传入一个引用队列</p>
<div class="code-wrapper"><pre><code class="hljs java">Object o1 = <span class="hljs-keyword">new</span> Object();

<span class="hljs-comment">// 创建引用队列</span>
ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();

<span class="hljs-comment">// 创建一个弱引用</span>
WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(o1, referenceQueue);</code></pre></div>

<p>那么在进行GC回收的时候，弱引用和虚引用的对象都会被回收，但是在回收之前，它会被送至引用队列中</p>
<p>完整代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 虚引用</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhantomReferenceDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        Object o1 = <span class="hljs-keyword">new</span> Object();

        <span class="hljs-comment">// 创建引用队列</span>
        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();

        <span class="hljs-comment">// 创建一个弱引用</span>
        WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(o1, referenceQueue);

        <span class="hljs-comment">// 创建一个弱引用</span>
<span class="hljs-comment">//        PhantomReference&lt;Object&gt; weakReference = new PhantomReference&lt;&gt;(o1, referenceQueue);</span>

        System.out.println(o1);
        System.out.println(weakReference.get());
        <span class="hljs-comment">// 取队列中的内容</span>
        System.out.println(referenceQueue.poll());

        o1 = <span class="hljs-keyword">null</span>;
        System.gc();
        System.out.println(<span class="hljs-string">&quot;执行GC操作&quot;</span>);

        <span class="hljs-keyword">try</span> &#123;
            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);
        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        System.out.println(o1);
        System.out.println(weakReference.get());
        <span class="hljs-comment">// 取队列中的内容</span>
        System.out.println(referenceQueue.poll());

    &#125;
&#125;</code></pre></div>

<p>运行结果</p>
<div class="code-wrapper"><pre><code class="hljs angelscript">java.lang.<span class="hljs-symbol">Object@</span><span class="hljs-number">14</span>ae5a5
java.lang.<span class="hljs-symbol">Object@</span><span class="hljs-number">14</span>ae5a5
<span class="hljs-literal">null</span>
执行GC操作
<span class="hljs-literal">null</span>
<span class="hljs-literal">null</span>
java.lang.<span class="hljs-built_in">ref</span>.<span class="hljs-symbol">WeakReference@</span><span class="hljs-number">7f</span>3124</code></pre></div>

<p>从这里我们能看到，在进行垃圾回收后，我们弱引用对象，也被设置成null，但是在队列中还能够导出该引用的实例，这就说明在回收之前，该弱引用的实例被放置引用队列中了，我们可以通过引用队列进行一些后置操作</p>
<h4 id="9-GCRoots和四大引用小总结"><a href="#9-GCRoots和四大引用小总结" class="headerlink" title="9 GCRoots和四大引用小总结"></a>9 GCRoots和四大引用小总结</h4><ul>
<li><p>红色部分在垃圾回收之外，也就是强引用的</p>
</li>
<li><p>蓝色部分：属于软引用，在内存不够的时候，才回收</p>
</li>
<li><p>虚引用和弱引用：每次垃圾回收的时候，都会被干掉，但是它在干掉之前还会存在引用队列中，我们可以通过引用队列进行一些通知机制</p>
</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200324123829937.png" alt="image-20200324123829937"></p>
<h3 id="2-4-Java内存溢出OOM"><a href="#2-4-Java内存溢出OOM" class="headerlink" title="2.4 Java内存溢出OOM"></a>2.4 Java内存溢出OOM</h3><h4 id="1-经典错误"><a href="#1-经典错误" class="headerlink" title="1 经典错误"></a>1 经典错误</h4><p>JVM中常见的两个错误</p>
<p>StackoverFlowError ：栈溢出</p>
<p>OutofMemoryError: java heap space：堆溢出</p>
<p>除此之外，还有以下的错误</p>
<ul>
<li>java.lang.StackOverflowError</li>
<li>java.lang.OutOfMemoryError：java heap space</li>
<li>java.lang.OutOfMemoryError：GC overhead limit exceeeded</li>
<li>java.lang.OutOfMemoryError：Direct buffer memory</li>
<li>java.lang.OutOfMemoryError：unable to create new native thread</li>
<li>java.lang.OutOfMemoryError：Metaspace</li>
</ul>
<h4 id="2-架构"><a href="#2-架构" class="headerlink" title="2 架构"></a>2 架构</h4><p>OutOfMemoryError和StackOverflowError是属于Error，不是Exception</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200324144802828.png" alt="image-20200324144802828"></p>
<h4 id="3-StackoverFlowError"><a href="#3-StackoverFlowError" class="headerlink" title="3 StackoverFlowError"></a>3 StackoverFlowError</h4><p>堆栈溢出，我们有最简单的一个递归调用，就会造成堆栈溢出，也就是深度的方法调用</p>
<p>栈一般是512K，不断的深度调用，直到栈被撑破</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackOverflowErrorDemo</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        stackOverflowError();
    &#125;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 栈一般是512K，不断的深度调用，直到栈被撑破</span>
<span class="hljs-comment">     * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stackOverflowError</span><span class="hljs-params">()</span> </span>&#123;
        stackOverflowError();
    &#125;
&#125;</code></pre></div>

<p>运行结果</p>
<div class="code-wrapper"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowError
	at com.moxi.interview.study.oom.StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:<span class="hljs-number">17</span>)</code></pre></div>

<h4 id="4-OutOfMemoryError"><a href="#4-OutOfMemoryError" class="headerlink" title="4 OutOfMemoryError"></a>4 OutOfMemoryError</h4><h5 id="4-1-java-heap-space"><a href="#4-1-java-heap-space" class="headerlink" title="4.1 java heap space"></a>4.1 java heap space</h5><p>创建了很多对象，导致堆空间不够存储</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Java堆内存不足</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaHeapSpaceDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 堆空间的大小 -Xms10m -Xmx10m</span>
        <span class="hljs-comment">// 创建一个 80M的字节数组</span>
        <span class="hljs-keyword">byte</span> [] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">80</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];
    &#125;
&#125;</code></pre></div>

<p>我们创建一个80M的数组，会直接出现Java heap space</p>
<div class="code-wrapper"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</code></pre></div>

<h5 id="4-2-GC-overhead-limit-exceeded"><a href="#4-2-GC-overhead-limit-exceeded" class="headerlink" title="4.2 GC overhead limit exceeded"></a>4.2 GC overhead limit exceeded</h5><p>GC回收时间过长时会抛出OutOfMemoryError，过长的定义是，超过了98%的时间用来做GC，并且回收了不到2%的堆内存</p>
<p>连续多次GC都只回收了不到2%的极端情况下，才会抛出。假设不抛出GC overhead limit 错误会造成什么情况呢？</p>
<p>那就是GC清理的这点内存很快会再次被填满，迫使GC再次执行，这样就形成了恶性循环，CPU的使用率一直都是100%，而GC却没有任何成果。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200324150646260.png" alt="image-20200324150646260"></p>
<p>代码演示：</p>
<p>为了更快的达到效果，我们首先需要设置JVM启动参数</p>
<div class="code-wrapper"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code></pre></div>

<p>这个异常出现的步骤就是，我们不断的像list中插入String对象，直到启动GC回收</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * GC 回收超时</span>
<span class="hljs-comment"> * JVM参数配置: -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCOverheadLimitDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;
                list.add(String.valueOf(++i).intern());
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            System.out.println(<span class="hljs-string">&quot;***************i:&quot;</span> + i);
            e.printStackTrace();
            <span class="hljs-keyword">throw</span> e;
        &#125; <span class="hljs-keyword">finally</span> &#123;

        &#125;

    &#125;
&#125;</code></pre></div>

<p>运行结果</p>
<div class="code-wrapper"><pre><code class="hljs java">[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;2047<span class="hljs-title">K</span><span class="hljs-params">(2560K)</span>] [ParOldGen: 7106K-&gt;7106<span class="hljs-title">K</span><span class="hljs-params">(7168K)</span>] 9154K-&gt;9154<span class="hljs-title">K</span><span class="hljs-params">(9728K)</span>, [Metaspace: 3504K-&gt;3504<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0311093 secs] [Times: user</span>=<span class="hljs-number">0.13</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.03</span> secs] 
[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Ergonomics)</span> [PSYoungGen: 2047K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(2560K)</span>] [ParOldGen: 7136K-&gt;667<span class="hljs-title">K</span><span class="hljs-params">(7168K)</span>] 9184K-&gt;667<span class="hljs-title">K</span><span class="hljs-params">(9728K)</span>, [Metaspace: 3540K-&gt;3540<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0058093 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] 
Heap
 PSYoungGen      total 2560K, used 114K [<span class="hljs-number">0x00000000ffd00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)
  eden space 2048K, <span class="hljs-number">5</span>% used [<span class="hljs-number">0x00000000ffd00000</span>,<span class="hljs-number">0x00000000ffd1c878</span>,<span class="hljs-number">0x00000000fff00000</span>)
  from space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x0000000100000000</span>)
  to   space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff80000</span>)
 ParOldGen       total 7168K, used 667K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ffd00000</span>, <span class="hljs-number">0x00000000ffd00000</span>)
  object space 7168K, <span class="hljs-number">9</span>% used [<span class="hljs-number">0x00000000ff600000</span>,<span class="hljs-number">0x00000000ff6a6ff8</span>,<span class="hljs-number">0x00000000ffd00000</span>)
 Metaspace       used 3605K, capacity 4540K, committed 4864K, reserved 1056768K
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 399<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 428<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span>
<span class="hljs-class">  </span>
<span class="hljs-class"> </span>
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded
	at java.lang.Integer.toString(Integer.java:<span class="hljs-number">403</span>)
	at java.lang.String.valueOf(String.java:<span class="hljs-number">3099</span>)
	at com.moxi.interview.study.oom.GCOverheadLimitDemo.main(GCOverheadLimitDemo.java:<span class="hljs-number">18</span>)</code></pre></div>

<p>我们能够看到 多次Full GC，并没有清理出空间，在多次执行GC操作后，就抛出异常 GC overhead limit</p>
<h5 id="4-3-Direct-buffer-memory"><a href="#4-3-Direct-buffer-memory" class="headerlink" title="4.3 Direct buffer memory"></a>4.3 Direct buffer memory</h5><p>Netty + NIO：这是由于NIO引起的</p>
<p>写NIO程序的时候经常会使用ByteBuffer来读取或写入数据，这是一种基于通道(Channel) 与 缓冲区(Buffer)的I/O方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<p>ByteBuffer.allocate(capability)：第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢</p>
<p>ByteBuffer.allocteDirect(capability)：第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存的拷贝，所以速度相对较快</p>
<p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会被回收，这时候怼内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那么程序就奔溃了。</p>
<p>一句话说：本地内存不足，但是堆内存充足的时候，就会出现这个问题</p>
<p>我们使用 -XX:MaxDirectMemorySize=5m 配置能使用的堆外物理内存为5M</p>
<div class="code-wrapper"><pre><code class="hljs java">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code></pre></div>

<p>然后我们申请一个6M的空间</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 只设置了5M的物理内存使用，但是却分配 6M的空间</span>
ByteBuffer bb = ByteBuffer.allocateDirect(<span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);</code></pre></div>

<p>这个时候，运行就会出现问题了</p>
<div class="code-wrapper"><pre><code class="hljs java">配置的maxDirectMemory：<span class="hljs-number">5.</span>0MB
[GC (System.gc()) [PSYoungGen: 2030K-&gt;488K(2560K)] 2030K-&gt;796K(9728K), <span class="hljs-number">0.0008326</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] 
[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 488K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(2560K)</span>] [ParOldGen: 308K-&gt;712<span class="hljs-title">K</span><span class="hljs-params">(7168K)</span>] 796K-&gt;712<span class="hljs-title">K</span><span class="hljs-params">(9728K)</span>, [Metaspace: 3512K-&gt;3512<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0052052 secs] [Times: user</span>=<span class="hljs-number">0.09</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] 
Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memory
	at java.nio.Bits.reserveMemory(Bits.java:<span class="hljs-number">693</span>)
	at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="hljs-number">123</span>)
	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="hljs-number">311</span>)
	at com.moxi.interview.study.oom.DIrectBufferMemoryDemo.main(DIrectBufferMemoryDemo.java:<span class="hljs-number">19</span>)</code></pre></div>

<h5 id="4-4-unable-to-create-new-native-thread"><a href="#4-4-unable-to-create-new-native-thread" class="headerlink" title="4.4 unable to create new native thread"></a>4.4 unable to create new native thread</h5><p>不能够创建更多的新的线程了，也就是说创建线程的上限达到了</p>
<p>在高并发场景的时候，会应用到</p>
<p>高并发请求服务器时，经常会出现如下异常<code>java.lang.OutOfMemoryError:unable to create new native thread</code>，准确说该native thread异常与对应的平台有关</p>
<p>导致原因：</p>
<ul>
<li>应用创建了太多线程，一个应用进程创建多个线程，超过系统承载极限</li>
<li>服务器并不允许你的应用程序创建这么多线程，linux系统默认运行单个进程可以创建的线程为1024个，如果应用创建超过这个数量，就会报 <code>java.lang.OutOfMemoryError:unable to create new native thread</code></li>
</ul>
<p>解决方法：</p>
<ol>
<li>想办法降低你应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低</li>
<li>对于有的应用，确实需要创建很多线程，远超过linux系统默认1024个线程限制，可以通过修改linux服务器配置，扩大linux默认限制</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 无法创建更多的线程</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnableCreateNewThreadDemo</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;
            System.out.println(<span class="hljs-string">&quot;************** i = &quot;</span> + i);
            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;
                <span class="hljs-keyword">try</span> &#123;
                    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);
                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>这个时候，就会出现下列的错误，线程数大概在 900多个</p>
<div class="code-wrapper"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: unable to cerate <span class="hljs-keyword">new</span> <span class="hljs-keyword">native</span> thread</code></pre></div>

<p>如何查看线程数</p>
<div class="code-wrapper"><pre><code class="hljs java">ulimit -u</code></pre></div>

<h5 id="4-5-Metaspace"><a href="#4-5-Metaspace" class="headerlink" title="4.5 Metaspace"></a>4.5 Metaspace</h5><p>元空间内存不足，Matespace元空间应用的是本地内存</p>
<p><code>-XX:MetaspaceSize</code> 的处理化大小为20M</p>
<h6 id="元空间是什么"><a href="#元空间是什么" class="headerlink" title="元空间是什么"></a>元空间是什么</h6><p>元空间就是我们的方法区，存放的是类模板，类信息，常量池等</p>
<p>Metaspace是方法区HotSpot中的实现，它与持久代最大的区别在于：Metaspace并不在虚拟内存中，而是使用本地内存，也即在java8中，class metadata（the virtual machines internal presentation of Java class），被存储在叫做Matespace的native memory</p>
<p>永久代（java8后背元空间Metaspace取代了）存放了以下信息：</p>
<ul>
<li>虚拟机加载的类信息</li>
<li>常量池</li>
<li>静态变量</li>
<li>即时编译后的代码</li>
</ul>
<p>模拟Metaspace空间溢出，我们不断生成类 往元空间里灌输，类占据的空间总会超过Metaspace指定的空间大小</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><p>在模拟异常生成时候，因为初始化的元空间为20M，因此我们使用JVM参数调整元空间的大小，为了更好的效果</p>
<div class="code-wrapper"><pre><code class="hljs java">-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</code></pre></div>

<p>代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 元空间溢出</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MetaspaceOutOfMemoryDemo</span> </span>&#123;

    <span class="hljs-comment">// 静态类</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMTest</span> </span>&#123;

    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 模拟计数多少次以后发生异常</span>
        <span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                i++;
                <span class="hljs-comment">// 使用Spring的动态字节码技术</span>
                Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();
                enhancer.setSuperclass(OOMTest.class);
                enhancer.setUseCache(<span class="hljs-keyword">false</span>);
                enhancer.setCallback(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;
                        <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o, args);
                    &#125;
                &#125;);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            System.out.println(<span class="hljs-string">&quot;发生异常的次数:&quot;</span> + i);
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;

        &#125;

    &#125;
&#125;</code></pre></div>

<p>会出现以下错误：</p>
<div class="code-wrapper"><pre><code class="hljs java">发生异常的次数: <span class="hljs-number">201</span>
java.lang.OutOfMemoryError:Metaspace</code></pre></div>

<h3 id="2-5-垃圾收集器"><a href="#2-5-垃圾收集器" class="headerlink" title="2.5 垃圾收集器"></a>2.5 垃圾收集器</h3><h4 id="1-GC垃圾回收算法和垃圾收集器关系"><a href="#1-GC垃圾回收算法和垃圾收集器关系" class="headerlink" title="1 GC垃圾回收算法和垃圾收集器关系"></a>1 GC垃圾回收算法和垃圾收集器关系</h4><blockquote>
<p>天上飞的理念，要有落地的实现（垃圾收集器就是GC垃圾回收算法的实现）</p>
<p>GC算法是内存回收的方法论，垃圾收集器就是算法的落地实现</p>
</blockquote>
<p>GC算法主要有以下几种</p>
<ul>
<li>引用计数（几乎不用，无法解决循环引用的问题）</li>
<li>复制拷贝（用于新生代）</li>
<li>标记清除（用于老年代）</li>
<li>标记整理（用于老年代）</li>
</ul>
<p>因为目前为止还没有完美的收集器出现，更没有万能的收集器，只是针对具体应用最合适的收集器，进行分代收集（那个代用什么收集器）</p>
<h4 id="2-四种主要的垃圾收集器"><a href="#2-四种主要的垃圾收集器" class="headerlink" title="2 四种主要的垃圾收集器"></a>2 四种主要的垃圾收集器</h4><ul>
<li>Serial：串行回收  <code>-XX:+UseSeriallGC</code></li>
<li>Parallel：并行回收  <code>-XX:+UseParallelGC</code></li>
<li>CMS：并发标记清除</li>
<li>G1</li>
<li>ZGC：（java 11 出现的）</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325084453631.png" alt="image-20200325084453631"></p>
<h5 id="2-1-Serial"><a href="#2-1-Serial" class="headerlink" title="2.1 Serial"></a>2.1 Serial</h5><p>串行垃圾回收器，它为单线程环境设计且值使用一个线程进行垃圾收集，会暂停所有的用户线程，只有当垃圾回收完成时，才会重新唤醒主线程继续执行。所以不适合服务器环境</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325085320683.png" alt="image-20200325085320683"></p>
<h5 id="2-2-Parallel"><a href="#2-2-Parallel" class="headerlink" title="2.2 Parallel"></a>2.2 Parallel</h5><p>并行垃圾收集器，多个垃圾收集线程并行工作，此时用户线程也是阻塞的，适用于科学计算 / 大数据处理等弱交互场景，也就是说Serial 和 Parallel其实是类似的，不过是多了几个线程进行垃圾收集，但是主线程都会被暂停，但是并行垃圾收集器处理时间，肯定比串行的垃圾收集器要更短</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325085729428.png" alt="image-20200325085729428"></p>
<h5 id="2-3-CMS"><a href="#2-3-CMS" class="headerlink" title="2.3 CMS"></a>2.3 CMS</h5><p>并发标记清除，用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），不需要停顿用户线程，互联网公司都在使用，适用于响应时间有要求的场景。并发是可以有交互的，也就是说可以一边进行收集，一边执行应用程序。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325090858921.png" alt="image-20200325090858921"></p>
<h5 id="2-4-G1"><a href="#2-4-G1" class="headerlink" title="2.4 G1"></a>2.4 G1</h5><p>G1垃圾回收器将堆内存分割成不同区域，然后并发的进行垃圾回收</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325093222711.png" alt="image-20200325093222711"></p>
<h4 id="3-垃圾收集器总结"><a href="#3-垃圾收集器总结" class="headerlink" title="3 垃圾收集器总结"></a>3 垃圾收集器总结</h4><p>注意：并行垃圾回收在单核CPU下可能会更慢</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325091619082.png" alt="image-20200325091619082"></p>
<h4 id="4-查看默认垃圾收集器"><a href="#4-查看默认垃圾收集器" class="headerlink" title="4 查看默认垃圾收集器"></a>4 查看默认垃圾收集器</h4><p>使用下面JVM命令，查看配置的初始参数</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+PrintCommandLineFlags</span></code></pre></div>

<p>然后运行一个程序后，能够看到它的一些初始配置信息</p>
<div class="code-wrapper"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">InitialHeapSize</span>=266376000 -XX:<span class="hljs-attribute">MaxHeapSize</span>=4262016000 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</code></pre></div>

<p>移动到最后一句，就能看到 <code>-XX:+UseParallelGC</code> 说明使用的是并行垃圾回收</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+UseParallelGC</span></code></pre></div>

<h4 id="5-默认垃圾收集器有哪些"><a href="#5-默认垃圾收集器有哪些" class="headerlink" title="5 默认垃圾收集器有哪些"></a>5 默认垃圾收集器有哪些</h4><p>Java中一共有7大垃圾收集器</p>
<ul>
<li>UserSerialGC：串行垃圾收集器</li>
<li>UserParallelGC：并行垃圾收集器</li>
<li>UseConcMarkSweepGC：（CMS）并发标记清除</li>
<li>UseParNewGC：年轻代的并行垃圾回收器</li>
<li>UseParallelOldGC：老年代的并行垃圾回收器</li>
<li>UseG1GC：G1垃圾收集器</li>
<li>UserSerialOldGC：串行老年代垃圾收集器（已经被移除）</li>
</ul>
<p>底层源码</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325100653829-16280006180638.png" alt="image-20200325100653829"></p>
<h4 id="6-各垃圾收集器的使用范围"><a href="#6-各垃圾收集器的使用范围" class="headerlink" title="6 各垃圾收集器的使用范围"></a>6 各垃圾收集器的使用范围</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325101451849.png" alt="image-20200325101451849"></p>
<p>新生代使用的：</p>
<ul>
<li>Serial Copying： UserSerialGC，串行垃圾回收器</li>
<li>Parallel Scavenge：UserParallelGC，并行垃圾收集器</li>
<li>ParNew：UserParNewGC，新生代并行垃圾收集器</li>
</ul>
<p>老年区使用的：</p>
<ul>
<li>Serial Old：UseSerialOldGC，老年代串行垃圾收集器</li>
<li>Parallel Compacting（Parallel Old）：UseParallelOldGC，老年代并行垃圾收集器</li>
<li>CMS：UseConcMarkSwepp，并行标记清除垃圾收集器</li>
</ul>
<p>各区都能使用的：</p>
<p>G1：UseG1GC，G1垃圾收集器</p>
<p>垃圾收集器就来具体实现这些GC算法并实现内存回收，不同厂商，不同版本的虚拟机实现差别很大，HotSpot中包含的收集器如下图所示：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325102329216.png" alt="image-20200325102329216"></p>
<h4 id="7-部分参数说明"><a href="#7-部分参数说明" class="headerlink" title="7 部分参数说明"></a>7 部分参数说明</h4><ul>
<li>DefNew：Default New Generation</li>
<li>Tenured：Old</li>
<li>ParNew：Parallel New Generation</li>
<li>PSYoungGen：Parallel Scavenge</li>
<li>ParOldGen：Parallel Old Generation</li>
</ul>
<h4 id="8-Java中的Server和Client模式"><a href="#8-Java中的Server和Client模式" class="headerlink" title="8  Java中的Server和Client模式"></a>8  Java中的Server和Client模式</h4><p>使用范围：一般使用Server模式，Client模式基本不会使用</p>
<p>操作系统</p>
<ul>
<li>32位的Window操作系统，不论硬件如何都默认使用Client的JVM模式</li>
<li>32位的其它操作系统，2G内存同时有2个cpu以上用Server模式，低于该配置还是Client模式</li>
<li>64位只有Server模式</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325175208231.png" alt="image-20200325175208231"></p>
<h4 id="9-新生代下的垃圾收集器"><a href="#9-新生代下的垃圾收集器" class="headerlink" title="9 新生代下的垃圾收集器"></a>9 新生代下的垃圾收集器</h4><h5 id="9-1-串行GC-Serial"><a href="#9-1-串行GC-Serial" class="headerlink" title="9.1 串行GC(Serial)"></a>9.1 串行GC(Serial)</h5><p>串行GC（Serial）（Serial Copying）</p>
<p>是一个单线程单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325175704604.png" alt="image-20200325175704604"></p>
<p>串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在垃圾收集过程中可能会产生较长的停顿(Stop-The-World 状态)。 虽然在收集垃圾过程中需要暂停所有其它的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是Java虚拟机运行在Client模式下默认的新生代垃圾收集器</p>
<p>对应JVM参数是：-XX:+UseSerialGC</p>
<p>开启后会使用：Serial(Young区用) + Serial Old(Old区用) 的收集器组合</p>
<p>表示：新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialGC</span></code></pre></div>

<h5 id="9-2-并行GC-ParNew"><a href="#9-2-并行GC-ParNew" class="headerlink" title="9.2 并行GC(ParNew)"></a>9.2 并行GC(ParNew)</h5><p>并行收集器，使用多线程进行垃圾回收，在垃圾收集，会Stop-the-World暂停其他所有的工作线程直到它收集结束</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325191328733.png" alt="image-20200325191328733"></p>
<p>ParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景时配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。它是很多Java虚拟机运行在Server模式下新生代的默认垃圾收集器。</p>
<p>常见对应JVM参数：-XX:+UseParNewGC     启动ParNew收集器，只影响新生代的收集，不影响老年代</p>
<p>开启上述参数后，会使用：ParNew（Young区用） + Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParNewGC</span></code></pre></div>

<p>但是会出现警告，即 ParNew 和 Serial Old 这样搭配，Java8已经不再被推荐</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325194316660.png" alt="image-20200325194316660"></p>
<p>备注： -XX:ParallelGCThreads   限制线程数量，默认开启和CPU数目相同的线程数</p>
<h5 id="9-3-并行回收GC（Parallel）-（Parallel-Scavenge）"><a href="#9-3-并行回收GC（Parallel）-（Parallel-Scavenge）" class="headerlink" title="9.3 并行回收GC（Parallel）/ （Parallel Scavenge）"></a>9.3 并行回收GC（Parallel）/ （Parallel Scavenge）</h5><p>因为Serial 和 ParNew都不推荐使用了，因此现在新生代默认使用的是Parallel Scavenge，也就是新生代和老年代都是使用并行</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325204437678.png" alt="image-20200325204437678"></p>
<p>Parallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。一句话：串行收集器在新生代和老年代的并行化</p>
<p>它关注的重点是：</p>
<p>可控制的吞吐量（Thoughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) ），也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%。高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。</p>
<p>自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间( -XX:MaxGCPauseMills)）或最大的吞吐量。</p>
<p>常用JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC（可互相激活）使用Parallel Scanvenge收集器</p>
<p>开启该参数后：新生代使用复制算法，老年代使用标记-整理算法</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelGC</span></code></pre></div>

<h4 id="10-老年代下的垃圾收集器"><a href="#10-老年代下的垃圾收集器" class="headerlink" title="10 老年代下的垃圾收集器"></a>10 老年代下的垃圾收集器</h4><h5 id="10-1-串行GC（Serial-Old）-Serial-MSC"><a href="#10-1-串行GC（Serial-Old）-Serial-MSC" class="headerlink" title="10.1 串行GC（Serial Old） / (Serial MSC)"></a>10.1 串行GC（Serial Old） / (Serial MSC)</h5><p>Serial Old是Serial垃圾收集器老年代版本，它同样是一个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的Java虚拟机中默认的老年代垃圾收集器</p>
<p>在Server模式下，主要有两个用途（了解，版本已经到8及以后）</p>
<ul>
<li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用（Parallel Scavenge + Serial Old）</li>
<li>作为老年代版中使用CMS收集器的后备垃圾收集方案。</li>
</ul>
<p>配置方法：</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialOldlGC</span></code></pre></div>

<p>该垃圾收集器，目前已经不推荐使用了</p>
<h5 id="10-2-并行GC（Parallel-Old）-（Parallel-MSC）"><a href="#10-2-并行GC（Parallel-Old）-（Parallel-MSC）" class="headerlink" title="10.2 并行GC（Parallel Old）/ （Parallel MSC）"></a>10.2 并行GC（Parallel Old）/ （Parallel MSC）</h5><p>Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。</p>
<p>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6以前(Parallel Scavenge + Serial Old)</p>
<p>Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8后可以考虑新生代Parallel Scavenge和老年代Parallel Old 收集器的搭配策略。在JDK1.8及后（Parallel Scavenge + Parallel Old）</p>
<p>JVM常用参数：</p>
<div class="code-wrapper"><pre><code class="hljs oxygene">-XX +UseParallelOldGC：使用<span class="hljs-keyword">Parallel</span> <span class="hljs-keyword">Old</span>收集器，设置该参数后，新生代<span class="hljs-keyword">Parallel</span>+老年代 <span class="hljs-keyword">Parallel</span> <span class="hljs-keyword">Old</span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325211525152.png" alt="image-20200325211525152"></p>
<p>使用老年代并行收集器：</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelOldlGC</span></code></pre></div>

<h5 id="10-3-并发标记清除GC（CMS）"><a href="#10-3-并发标记清除GC（CMS）" class="headerlink" title="10.3 并发标记清除GC（CMS）"></a>10.3 并发标记清除GC（CMS）</h5><p>CMS收集器（Concurrent Mark Sweep：并发标记清除）是一种以最短回收停顿时间为目标的收集器</p>
<p>适合应用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。</p>
<p>CMS非常适合堆内存大，CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325212836441.png" alt="image-20200325212836441"></p>
<p>Concurrent Mark Sweep：并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行</p>
<p>开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC  开启该参数后，会自动将 -XX:+UseParNewGC打开，开启该参数后，使用ParNew(young 区用）+ CMS（Old 区用） + Serial Old 的收集器组合，Serial Old将作为CMS出错的后备收集器</p>
<div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC</span></code></pre></div>

<h6 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h6><ul>
<li>初始标记（CMS initial mark）<ul>
<li>只是标记一个GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程</li>
</ul>
</li>
<li>并发标记（CMS concurrent mark）和用户线程一起<ul>
<li>进行GC Roots跟踪过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象</li>
</ul>
</li>
<li>重新标记（CMS remark）<ul>
<li>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程，由于并发标记时，用户线程依然运行，因此在正式清理前，在做修正</li>
</ul>
</li>
<li>并发清除（CMS concurrent sweep）和用户线程一起<ul>
<li>清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象，由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</li>
</ul>
</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200325215401981-162800094846319.png" alt="image-20200325215401981"></p>
<p>优点：并发收集低停顿</p>
<p>缺点：并发执行，对CPU资源压力大，采用的标记清除算法会导致大量碎片</p>
<p>由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS必须在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW方式进行一次GC，从而造成较大的停顿时间</p>
<p>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩，CMS也提供了参数 -XX:CMSFullGCSBeForeCompaction（默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC</p>
<h4 id="11-为什么新生代采用复制算法，老年代采用标整算法"><a href="#11-为什么新生代采用复制算法，老年代采用标整算法" class="headerlink" title="11 为什么新生代采用复制算法，老年代采用标整算法"></a>11 为什么新生代采用复制算法，老年代采用标整算法</h4><h5 id="11-1-新生代使用复制算法"><a href="#11-1-新生代使用复制算法" class="headerlink" title="11.1 新生代使用复制算法"></a>11.1 新生代使用复制算法</h5><p>因为新生代对象的生存时间比较短，80%的都要回收的对象，采用标记-清除算法则内存碎片化比较严重，采用复制算法可以灵活高效，且便与整理空间。</p>
<h5 id="11-2-老年代采用标记整理"><a href="#11-2-老年代采用标记整理" class="headerlink" title="11.2 老年代采用标记整理"></a>11.2 老年代采用标记整理</h5><p>标记整理算法主要是为了解决标记清除算法存在内存碎片的问题，又解决了复制算法两个Survivor区的问题，因为老年代的空间比较大，不可能采用复制算法，特别占用内存空间</p>
<h4 id="12-垃圾收集器如何选择"><a href="#12-垃圾收集器如何选择" class="headerlink" title="12 垃圾收集器如何选择"></a>12 垃圾收集器如何选择</h4><h5 id="组合的选择"><a href="#组合的选择" class="headerlink" title="组合的选择"></a>组合的选择</h5><ul>
<li>单CPU或者小内存，单机程序<ul>
<li>-XX:+UseSerialGC</li>
</ul>
</li>
<li>多CPU，需要最大的吞吐量，如后台计算型应用<ul>
<li>-XX:+UseParallelGC（这两个相互激活）</li>
<li>-XX:+UseParallelOldGC</li>
</ul>
</li>
<li>多CPU，追求低停顿时间，需要快速响应如互联网应用<ul>
<li>-XX:+UseConcMarkSweepGC</li>
<li>-XX:+ParNewGC</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">新生代垃圾收集器</th>
<th align="center">新生代算法</th>
<th align="center">老年代垃圾收集器</th>
<th align="center">老年代算法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-XX:+UseSerialGC</td>
<td align="center">SerialGC</td>
<td align="center">复制</td>
<td align="center">SerialOldGC</td>
<td align="center">标记整理</td>
</tr>
<tr>
<td align="center">-XX:+UseParNewGC</td>
<td align="center">ParNew</td>
<td align="center">复制</td>
<td align="center">SerialOldGC</td>
<td align="center">标记整理</td>
</tr>
<tr>
<td align="center">-XX:+UseParallelGC</td>
<td align="center">Parallel [Scavenge]</td>
<td align="center">复制</td>
<td align="center">Parallel Old</td>
<td align="center">标记整理</td>
</tr>
<tr>
<td align="center">-XX:+UseConcMarkSweepGC</td>
<td align="center">ParNew</td>
<td align="center">复制</td>
<td align="center">CMS + Serial Old的收集器组合，Serial Old作为CMS出错的后备收集器</td>
<td align="center">标记清除</td>
</tr>
<tr>
<td align="center">-XX:+UseG1GC</td>
<td align="center">G1整体上采用标记整理算法</td>
<td align="center">局部复制</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="13-G1垃圾收集器"><a href="#13-G1垃圾收集器" class="headerlink" title="13 G1垃圾收集器"></a>13 G1垃圾收集器</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326115120405.png" alt="image-20200326115120405"></p>
<h5 id="13-1-开启G1垃圾收集器"><a href="#13-1-开启G1垃圾收集器" class="headerlink" title="13.1 开启G1垃圾收集器"></a>13.1 开启G1垃圾收集器</h5><div class="code-wrapper"><pre><code class="hljs diff"><span class="hljs-deletion">-XX:+UseG1GC</span></code></pre></div>

<h5 id="13-2-以前收集器的特点"><a href="#13-2-以前收集器的特点" class="headerlink" title="13.2 以前收集器的特点"></a>13.2 以前收集器的特点</h5><ul>
<li>年轻代和老年代是各自独立且连续的内存块</li>
<li>年轻代收集使用单eden + S0 + S1 进行复制算法</li>
<li>老年代收集必须扫描珍整个老年代区域</li>
<li>都是以尽可能少而快速地执行GC为设计原则</li>
</ul>
<h5 id="13-3-G1是什么"><a href="#13-3-G1是什么" class="headerlink" title="13.3 G1是什么"></a>13.3 G1是什么</h5><p>G1：Garbage-First 收集器，是一款面向服务端应用的收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能满足垃圾收集暂停时间的要求。另外，它还具有一下特征：</p>
<ul>
<li>像CMS收集器一样，能与应用程序并发执行</li>
<li>整理空闲空间更快</li>
<li>需要更多的时间来预测GC停顿时间</li>
<li>不希望牺牲大量的吞吐量性能</li>
<li>不需要更大的Java Heap</li>
</ul>
<p>G1收集器设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色</p>
<ul>
<li>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。</li>
<li>G1的Stop The World（STW）更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</li>
</ul>
<p>CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器-G1垃圾收集器</p>
<p>G1是在2012奶奶才在JDK1.7中可用，Oracle官方计划在JDK9中将G1变成默认的垃圾收集器以替代CMS，它是一款面向服务端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换Java8以前的CMS收集器</p>
<p>主要改变时：Eden，Survivor和Tenured等内存区域不再是连续了，而是变成一个个大小一样的region，每个region从1M到32M不等。一个region有可能属于Eden，Survivor或者Tenured内存区域。</p>
<h5 id="13-4-特点"><a href="#13-4-特点" class="headerlink" title="13.4 特点"></a>13.4 特点</h5><ul>
<li>G1能充分利用多CPU，多核环境硬件优势，尽量缩短STW</li>
<li>G1整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片</li>
<li>宏观上看G1之中不再区分年轻代和老年代。把内存划分成多个独立的子区域（Region），可以近似理解为一个围棋的棋盘</li>
<li>G1收集器里面将整个内存区域都混合在一起了，但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代，但他们不再是物理隔离的，而是通过一部分Region的集合且不需要Region是连续的，也就是说依然会采取不同的GC方式来处理不同的区域</li>
<li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代和老年代的区别，也不需要完全独立的Survivor（to space）堆做复制准备，G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换。</li>
</ul>
<h5 id="13-5-底层原理"><a href="#13-5-底层原理" class="headerlink" title="13.5 底层原理"></a>13.5 底层原理</h5><p>Region区域化垃圾收集器，化整为零，打破了原来新生区和老年区的壁垒，避免了全内存扫描，只需要按照区域来进行扫描即可。</p>
<p>区域化内存划片Region，整体遍为了一些列不连续的内存区域，避免了全内存区的GC操作。</p>
<p>核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动时会自动设置子区域大小</p>
<p>在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code> 可指定分区大小（1MB~32MB，且必须是2的幂），默认将整堆划分为2048个分区。</p>
<p>大小范围在1MB~32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048 = 64G内存</p>
<p>Region区域化垃圾收集器</p>
<h5 id="13-6-Region区域化垃圾收集器"><a href="#13-6-Region区域化垃圾收集器" class="headerlink" title="13.6 Region区域化垃圾收集器"></a>13.6 Region区域化垃圾收集器</h5><p>G1将新生代、老年代的物理空间划分取消了</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326120105859.png" alt="image-20200326120105859"></p>
<p>同时对内存进行了区域划分</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326120130427.png" alt="image-20200326120130427"></p>
<p>G1算法将堆划分为若干个区域（Reign），它仍然属于分代收集器，这些Region的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间</p>
<p>这些Region的一部分包含老年代，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片的问题存在了。</p>
<p>在G1中，还有一种特殊的区域，叫做Humongous（巨大的）区域，如果一个对象占用了空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象，这些巨型对象默认直接分配在老年代，但是如果他是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响，为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H区来存储，为了能找到连续的H区，有时候不得不启动Full GC。</p>
<h5 id="13-7-回收步骤"><a href="#13-7-回收步骤" class="headerlink" title="13.7 回收步骤"></a>13.7 回收步骤</h5><p>针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集 + 形成连续的内存块，避免内碎片</p>
<ul>
<li>Eden区的数据移动到Survivor区，加入出现Survivor区空间不够，Eden区数据会晋升到Old区</li>
<li>Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区</li>
<li>最后Eden区收拾干净了，GC结束，用户的应用程序继续执行</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326121409237.png" alt="image-20200326121409237"></p>
<p>回收完成后</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326121622208.png" alt="image-20200326121622208"></p>
<p>小区域收集 + 形成连续的内存块，最后在收集完成后，就会形成连续的内存空间，这样就解决了内存碎片的问题</p>
<h5 id="13-8-四步过程"><a href="#13-8-四步过程" class="headerlink" title="13.8 四步过程"></a>13.8 四步过程</h5><ul>
<li>初始标记：只标记GC Roots能直接关联到的对象</li>
<li>并发标记：进行GC Roots Tracing（链路扫描）的过程</li>
<li>最终标记：修正并发标记期间，因为程序运行导致标记发生变化的那一部分对象</li>
<li>筛选回收：根据时间来进行价值最大化回收</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326121914326.png" alt="image-20200326121914326"></p>
<h5 id="13-9-参数配置"><a href="#13-9-参数配置" class="headerlink" title="13.9 参数配置"></a>13.9 参数配置</h5><p>开发人员仅仅需要申明以下参数即可</p>
<p>三步归纳：<code>-XX:+UseG1GC  -Xmx32G  -XX:MaxGCPauseMillis=100</code></p>
<p>-XX:MaxGCPauseMillis=n：最大GC停顿时间单位毫秒，这是个软目标，JVM尽可能停顿小于这个时间</p>
<h5 id="13-10-G1和CMS比较"><a href="#13-10-G1和CMS比较" class="headerlink" title="13.10 G1和CMS比较"></a>13.10 G1和CMS比较</h5><ul>
<li>G1不会产生内碎片</li>
<li>是可以精准控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间去收集垃圾最多的区域。</li>
</ul>
<h4 id="14SpringBoot结合JVMGC"><a href="#14SpringBoot结合JVMGC" class="headerlink" title="14SpringBoot结合JVMGC"></a>14SpringBoot结合JVMGC</h4><p>启动微服务时候，就可以带上JVM和GC的参数</p>
<ul>
<li>IDEA开发完微服务工程</li>
<li>maven进行clean package</li>
<li>要求微服务启动的时候，同时配置我们的JVM/GC的调优参数<ul>
<li>我们就可以根据具体的业务配置我们启动的JVM参数</li>
</ul>
</li>
</ul>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -Xms<span class="hljs-number">1024</span>m -Xmx<span class="hljs-number">1024</span> -XX:UseG<span class="hljs-number">1</span>GC -jar   xxx.jar</code></pre></div>

<h1 id="第-13-章-Linux诊断原因"><a href="#第-13-章-Linux诊断原因" class="headerlink" title="第 13 章 Linux诊断原因"></a>第 13 章 Linux诊断原因</h1><h3 id="1-整机：top，查看整机系统性能"><a href="#1-整机：top，查看整机系统性能" class="headerlink" title="1 整机：top，查看整机系统性能"></a>1 整机：top，查看整机系统性能</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326162329550.png" alt="image-20200326162329550"></p>
<p>使用top命令的话，重点关注的是 %CPU、%MEM 、load average 三个指标</p>
<ul>
<li>load average三个指标：分别代表1、5、15分钟的负载情况</li>
</ul>
<p>在这个命令下，按1的话，可以看到每个CPU的占用情况</p>
<p>uptime：系统性能命令的精简版</p>
<h3 id="2-CPU：vmstat"><a href="#2-CPU：vmstat" class="headerlink" title="2 CPU：vmstat"></a>2 CPU：vmstat</h3><ul>
<li>查看CPU（包含但是不限于）</li>
<li>查看额外<ul>
<li>查看所有CPU核信息：mpstat -p ALL 2</li>
<li>每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号</li>
</ul>
</li>
</ul>
<p>命令格式：<code>vmstat -n 2 3</code></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326162803165.png" alt="image-20200326162803165"></p>
<p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是残阳的时间间隔数（单位秒），第二个参数是采样的次数</p>
<p><strong>procs</strong></p>
<div class="code-wrapper"><pre><code>r：运行和等待的CPU时间片的进程数，原则上1核的CPU的运行队列不要超过2，整个系统的运行队列不超过总核数的2倍，否则代表系统压力过大，我们看蘑菇博客测试服务器，能发现都超过了2，说明现在压力过大

b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等</code></pre></div><p><strong>cpu</strong></p>
<div class="code-wrapper"><pre><code>us：用户进程消耗CPU时间百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，优化程序

sy：内核进程消耗的CPU时间百分比</code></pre></div><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326164521263.png" alt="image-20200326164521263"></p>
<div class="code-wrapper"><pre><code>us + sy 参考值为80%，如果us + sy 大于80%，说明可能存在CPU不足，从上面的图片可以看出，us + sy还没有超过百分80，因此说明蘑菇博客的CPU消耗不是很高

id：处于空闲的CPU百分比

wa：系统等待IO的CPU时间百分比

st：来自于一个虚拟机偷取的CPU时间比</code></pre></div><h3 id="3-内存：free"><a href="#3-内存：free" class="headerlink" title="3 内存：free"></a>3 内存：free</h3><ul>
<li><p>应用程序可用内存数：free -m</p>
</li>
<li><p>应用程序可用内存/系统物理内存 &gt; 70% 内存充足</p>
</li>
<li><p>应用程序可用内存/系统物理内存 &lt; 20% 内存不足，需要增加内存</p>
</li>
<li><p>20% &lt;  应用程序可用内存/系统物理内存 &lt; 70%，表示内存基本够用</p>
</li>
</ul>
<p>free -h：以人类能看懂的方式查看物理内存</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326170217637.png" alt="image-20200326170217637"></p>
<p>free -m：以MB为单位，查看物理内存</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326165815071.png" alt="image-20200326165815071"></p>
<p>free -g：以GB为单位，查看物理内存</p>
<h3 id="4-硬盘：df"><a href="#4-硬盘：df" class="headerlink" title="4 硬盘：df"></a>4 硬盘：df</h3><p>格式：<code>df -h  /</code>  (-h：human，表示以人类能看到的方式换算)</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326170318733.png" alt="image-20200326170318733"></p>
<ul>
<li>硬盘IO：iostat</li>
</ul>
<p>系统慢有两种原因引起的，一个是CPU高，一个是大量IO操作</p>
<p>格式：<code>iostat -xdk 2 3</code></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326170522559.png" alt="image-20200326170522559"></p>
<p>磁盘块设备分布：</p>
<p>rkB /s：每秒读取数据量kB；</p>
<p>wkB/s：每秒写入数据量kB；</p>
<p>svctm I/O：请求的平均服务时间，单位毫秒</p>
<p>await I/O：请求的平均等待时间，单位毫秒，值越小，性能越好</p>
<p>util：一秒钟有百分几的时间用于I/O操作。接近100%时，表示磁盘带宽跑满，需要优化程序或者增加磁盘；</p>
<p>rkB/s，wkB/s根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据读写，肯定不正常，需要优化程序读取。</p>
<p>svctm的值与await的值很接近，表示几乎没有I/O等待，磁盘性能好，如果await的值远高于svctm的值，则表示I/O队列等待太长，需要优化程序或更换更快磁盘</p>
<h3 id="5-网络IO：ifstat"><a href="#5-网络IO：ifstat" class="headerlink" title="5 网络IO：ifstat"></a>5 网络IO：ifstat</h3><ul>
<li>默认本地没有，下载ifstat</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326171559406.png" alt="image-20200326171559406"></p>
<h3 id="6-生产环境服务器变慢，诊断思路和性能评估"><a href="#6-生产环境服务器变慢，诊断思路和性能评估" class="headerlink" title="6 生产环境服务器变慢，诊断思路和性能评估"></a>6 生产环境服务器变慢，诊断思路和性能评估</h3><p>记一次印象深刻的故障？</p>
<p>结合Linux 和 JDK命令一起分析，步骤如下</p>
<ul>
<li><p>使用top命令找出CPU占比最高的</p>
</li>
<li><p>ps -ef 或者 jps 进一步定位，得知是一个怎么样的后台程序出的问题</p>
</li>
<li><p>定位到具体线程或者代码</p>
<ul>
<li>ps -mp 进程  -o THREAD，tid，time</li>
<li>参数解释<ul>
<li>-m：显示所有的线程</li>
<li>-p：pid进程使用CPU的时间</li>
<li>-o：该参数后是用户自定义格式</li>
</ul>
</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326173656164.png" alt="image-20200326173656164"></p>
</li>
<li><p>将需要的线程ID转换为16进制格式（英文小写格式）</p>
<ul>
<li>printf “%x\n” 有问题的线程ID</li>
</ul>
</li>
<li><p>jstack 进程ID | grep tid（16进制线程ID小写英文） -A60</p>
<p>精准定位到错误的地方</p>
</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326174107444.png" alt="image-20200326174107444"></p>
<h1 id="第-14-章-Github-使用"><a href="#第-14-章-Github-使用" class="headerlink" title="第 14 章 Github 使用"></a>第 14 章 Github 使用</h1><p>使用Github优秀框架 + 源码 提升自己</p>
<h2 id="1-常用词含义"><a href="#1-常用词含义" class="headerlink" title="1 常用词含义"></a>1 常用词含义</h2><ul>
<li><p>watch：会持续收到该项目的动态</p>
</li>
<li><p>fork：复制某个仓库到自己的Github仓库中</p>
</li>
<li><p>star：可以理解为点赞</p>
</li>
<li><p>clone：将项目下载至本地</p>
</li>
<li><p>follow：关注你感兴趣的作者，会收到他们的动态</p>
<p>in关键字限制搜索范围</p>
</li>
<li><p>公式：<code>XXX关键字 in:name 或 description 或 readme</code></p>
</li>
<li><p>xxx in:name   项目名称含有XXX的</p>
</li>
<li><p>xxx in:description   项目描述含有XXX的</p>
</li>
<li><p>xxx in:readme   项目的readme文件中包含XXX的</p>
</li>
<li><p>组合使用</p>
<ul>
<li>xxx   in:name,readme    项目的名称和readme中包含xxx的</li>
</ul>
</li>
</ul>
<h2 id="2-stars或fork数量关键字查找"><a href="#2-stars或fork数量关键字查找" class="headerlink" title="2 stars或fork数量关键字查找"></a>2 stars或fork数量关键字查找</h2><ul>
<li>公式：<ul>
<li><code>xxx关键字  stars 通配符</code>  :&gt;  或者 :&gt;=</li>
<li>区间范围数字：  <code>stars:数字1..数字2</code></li>
</ul>
</li>
<li>案例<ul>
<li>查找stars数大于等于5000的Springboot项目：springboot  stars:&gt;=5000</li>
<li>查找forks数在1000~2000之间的springboot项目：springboot forks:1000..5000</li>
</ul>
</li>
<li>组合使用<ul>
<li>查找star大于1000，fork数在500到1000：<code>springboot stars:&gt;1000 forks:500..1000</code></li>
</ul>
</li>
</ul>
<h2 id="3-awesome加强搜索"><a href="#3-awesome加强搜索" class="headerlink" title="3 awesome加强搜索"></a>3 awesome加强搜索</h2><ul>
<li>公式：<code>awesome 关键字</code>：awesome系列，一般用来收集学习、工具、书籍类相关的项目</li>
<li>搜索优秀的redis相关的项目，包括框架，教程等  awesome redis</li>
</ul>
<h2 id="4-高亮显示某行代码"><a href="#4-高亮显示某行代码" class="headerlink" title="4 高亮显示某行代码"></a>4 高亮显示某行代码</h2><ul>
<li>一行：地址后面紧跟  #L10<ul>
<li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13</code></li>
</ul>
</li>
<li>多行：地址后面紧跟 #Lx - #Ln<ul>
<li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13-L30</code></li>
</ul>
</li>
</ul>
<h2 id="5-项目内搜索"><a href="#5-项目内搜索" class="headerlink" title="5 项目内搜索"></a>5 项目内搜索</h2><ul>
<li>使用英文字母 <code>t</code> ,开启项目内搜索</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200326212650322.png" alt="image-20200326212650322"></p>
<h2 id="6-搜索某个地区内的大佬"><a href="#6-搜索某个地区内的大佬" class="headerlink" title="6 搜索某个地区内的大佬"></a>6 搜索某个地区内的大佬</h2><ul>
<li>location：地区</li>
<li>language：语言</li>
<li>例如：<code>location:beijing language:java</code></li>
</ul>
<h1 id="第-15-章-乐观锁和悲观锁"><a href="#第-15-章-乐观锁和悲观锁" class="headerlink" title="第 15 章 乐观锁和悲观锁"></a>第 15 章 乐观锁和悲观锁</h1><h2 id="1-乐观锁"><a href="#1-乐观锁" class="headerlink" title="1 乐观锁"></a>1 乐观锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>乐观锁：顾名思义，就是十分乐观，它总是认为不会出现问题，无论干什么都不去上锁~，如果出现了问题，再次更新值测试，这里使用了version字段。</p>
<p>也就是每次更新的时候同时维护一个version字段</p>
<h3 id="乐观锁实现方式"><a href="#乐观锁实现方式" class="headerlink" title="乐观锁实现方式"></a>乐观锁实现方式</h3><ul>
<li>取出记录时，获取当前的version</li>
<li>更新时，带上这个version</li>
<li>执行更新时，set version = newVersion where version = oldVersion</li>
<li>如果version不对，就更新失败</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs shell">乐观锁：1：先查询，获得版本号 version =1

-- A 线程
update user set name = &quot;陌溪&quot;, version = version + 1 
where id = 2 and version = 1

-- B 线程抢先完成，这个时候Version = 2，导致A修改失败
update user set name = &quot;陌溪&quot;, version = version + 1 
where id = 2 and version = 1</code></pre></div>

<h2 id="2-MybatisPlus使用乐观锁"><a href="#2-MybatisPlus使用乐观锁" class="headerlink" title="2 MybatisPlus使用乐观锁"></a>2 MybatisPlus使用乐观锁</h2><p>首先需要在数据库增加version字典，默认为1</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200329172158610.png" alt="image-20200329172158610"></p>
<p>然后在实体类增加对应的字段</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 乐观锁Version注解</span>
<span class="hljs-meta">@Version</span>
<span class="hljs-keyword">private</span> Integer version;</code></pre></div>

<p>注册组件，在MybatisPlusConfig中配置</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 注册乐观锁</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> OptimisticLockerInterceptor <span class="hljs-title">optimisticLockerInterceptor</span><span class="hljs-params">()</span> </span>&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OptimisticLockerInterceptor();
&#125;</code></pre></div>

<h2 id="3-悲观锁"><a href="#3-悲观锁" class="headerlink" title="3 悲观锁"></a>3 悲观锁</h2><p>顾名思义，就是十分悲观，它总是认为什么时候都会出现问题，无论什么操作都会上锁，再次操作</p>
<h1 id="第3部分-框架"><a href="#第3部分-框架" class="headerlink" title="第3部分 框架"></a>第3部分 框架</h1><h1 id="第16-章-Spring-源码"><a href="#第16-章-Spring-源码" class="headerlink" title="第16 章 Spring 源码"></a>第16 章 Spring 源码</h1><h2 id="1-Spring源码方面的知识"><a href="#1-Spring源码方面的知识" class="headerlink" title="1 Spring源码方面的知识"></a>1 Spring源码方面的知识</h2><ul>
<li>Spring bean的生命周期</li>
<li>Spring 工厂，Spring容器，上下文 </li>
<li>Spring BeanPostprocessor</li>
<li>Spring 和 主流框架的源码</li>
<li>Spring BeanFactory 和 FactoryBean的区别</li>
</ul>
<h2 id="2-谈谈你对Spring的理解"><a href="#2-谈谈你对Spring的理解" class="headerlink" title="2 谈谈你对Spring的理解"></a>2 谈谈你对Spring的理解</h2><p>IOC、AOP只是作为Spring Framework里面一部分，同时还有还有events，resources，i18n，validation，data binding，type conversion，SpEL</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402092317669.png" alt="image-20200402092317669"></p>
<h2 id="3-Spring上下文"><a href="#3-Spring上下文" class="headerlink" title="3 Spring上下文"></a>3 Spring上下文</h2><p>从代码级别来说，就是指Spring Context</p>
<p>从源码级别，但我们初始化Spring Context的时候，一堆的Spring组件围绕在一起，使其能够正常工作，这个状态就被称为Spring环境</p>
<h2 id="4-Spring初始化"><a href="#4-Spring初始化" class="headerlink" title="4 Spring初始化"></a>4 Spring初始化</h2><p>首先需要引入Spring的依赖，因为我们暂时只是初始化过程，只需要用到IOC</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>为了更加了解Spring初始化的过程，我们需要定义三个类</p>
<p>1、AppConfig.java，可以当成是扫描类，也就是配置我们需要扫描的目录</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(&quot;com.pnca.interview.study.spring&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;
&#125;
</code></pre></div>

<p>2、BeanTest.java，我们需要被扫描到的Bean</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanTest</span> </span>&#123;
&#125;</code></pre></div>

<p>3、Test.java，启动测试类</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 初始化</span>
        AnnotationConfigApplicationContext annotationConfigApplicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);

        System.out.println(annotationConfigApplicationContext.getBean(BeanTest.class));
    &#125;
&#125;</code></pre></div>

<p>最后我们通过注解的方式，来获取Spring IOC扫描到的Bean，最后打印出来</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402091642787.png" alt="image-20200402091642787"></p>
<p>tip：IDEA点击进去的源码目录，其实是IDEA反编译得到的，和原来的源码会存在一些出入，是IDEA专门优化过的，因此如果你需要修改源码的话，还是需要在官网下载对应的源码包</p>
<div class="code-wrapper"><pre><code class="hljs http">https://github.com/spring-projects/spring-framework</code></pre></div>

<h2 id="5-SpringBean的生命周期"><a href="#5-SpringBean的生命周期" class="headerlink" title="5 SpringBean的生命周期"></a>5 SpringBean的生命周期</h2><p>Spring中的Bean不可能是直接new关键字创建出来的</p>
<ul>
<li>把类扫描出来（扫描出来后做了什么？）</li>
<li>把Bean实例化</li>
</ul>
<p>初始化Spring环境有两种方法，一种是通过注解的方式，一个是通过XML的方式</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 方式1，目前用的比较多</span>
AnnotationConfigApplicationContext annotationConfigApplicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class)</code></pre></div>

<p>同时在这个方法的内部，使用了this()</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402100813001.png" alt="image-20200402100813001"></p>
<p>调用AnnotationConfigApplicationContext无参构造方法，同时因为该类又继承了一个父类 GenericApplicationContext，子类在初始化的时候，还会调用父类的无参构造方法，在父类中，我们能够看到它初始化了一个BeanFactory，这就是我们经常提到的Spring工厂</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402100434794-16295172680416.png" alt="image-20200402100434794"></p>
<p>这个工厂最重要的功能就是产生Bean</p>
<p>同时在AnnotationConfigApplication方法的最后，还有一个refresh()方法，这个方法是整个Spring最核心的方法，这个方法的内部，同时调用了十多个方法，其中最重要的是 invokeBeanFactoryPostProcessors()</p>
<div class="code-wrapper"><pre><code class="hljs java">invokeBeanFactoryPostProcessors() &#123;
	<span class="hljs-comment">// 扫描类：</span>
	<span class="hljs-comment">// 处理了各种import：例如@import(&quot;xxx.xml&quot;), @MapperScanner, @CompoentScanner ..... </span>
&#125;</code></pre></div>

<h3 id="普通类的实例化"><a href="#普通类的实例化" class="headerlink" title="普通类的实例化"></a>普通类的实例化</h3><p>普通类的实例化，就是通过javac编译成xxx.class文件，然后某一天通过new关键字进行实例化，JVM就会把这个class类加载到JVM内存中，这里面就涉及到了方法区，堆栈存储等。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402101551621.png" alt="image-20200402101551621"></p>
<h3 id="Spring-Bean实例化过程"><a href="#Spring-Bean实例化过程" class="headerlink" title="Spring Bean实例化过程"></a>Spring Bean实例化过程</h3><ul>
<li><p>首先Spring会将全部的Class类，通过classLoader加载到JVM中</p>
</li>
<li><p>然后在通过扫描，创建很多BeanDefinition，我们通过反射将对应Class的信息填充到BeanDefinition中</p>
<ul>
<li><p>这里的BeanDefinition是用来描述Bean的，也就是Bean的一些信息存储</p>
<div class="code-wrapper"><pre><code class="hljs java">RootBeanDefinition rootBeanDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition();
rootBeanDefinition.setBeanClassName(<span class="hljs-string">&quot;BeanTest&quot;</span>);
rootBeanDefinition.setBeanClass(BeanTest.class);
rootBeanDefinition.setScope(<span class="hljs-string">&quot;prototype&quot;</span>);
rootBeanDefinition.setLazyInit();</code></pre></div>



</li>
</ul>
</li>
</ul>
<ul>
<li>然后在把填充好的BeanDefinition一个个放入到Map中，Spring扫描了几个类，Map中就有几个类，这个Map被称为 BeanDefinitionMap</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402102958645.png" alt="image-20200402102958645"></p>
<ul>
<li>最后我们将这个BeanDefinationMap放入了Spring单例池中</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402104318234.png" alt="image-20200402104318234"></p>
<p>完整的加载图，左边红色部分就是Spring的加载过程，然后开放的原则，它还提供了很多扩展接口，让你可以干扰到Sring的加载过程，使得</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/07/30/Java%E9%9D%A2%E8%AF%95/image-20200402104306006.png" alt="image-20200402104306006"></p>
<p>例如，很多需要对Spring进行扩展的，例如Mybatis，其实都是实现了 BeanFactoryPostProcessor接口</p>
<p>在执行扫描的时候，它会扫描Spring 提供的 BeanFactoryPostProcessor，以及程序员扩展的</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;

    &#125;
&#125;</code></pre></div>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/Tool/">Tool</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/09/02/Effective%20Debugging%20Note/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Effective Debugging Note</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/22/K8s%E5%AD%A6%E4%B9%A0/">
                        <span class="hidden-mobile">K8s 学习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=a;var i=n.imageLazyLoadSetting.isSPA,o=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function a(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var a=0;a<r.length;a++)t=r[a],0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight*o||document.documentElement.clientHeight*o)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}();var t,e}a(),n.addEventListener("scroll",function(){var t,e;t=a,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>
