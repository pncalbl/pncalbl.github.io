

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon-t.png">
  <link rel="icon" href="/img/favicon-t.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="pncalbl">
  <meta name="keywords" content="计算机,开发,编程,代码,博客,技术">
  
  <title>Docker 学习 - pncalbl</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"pncalbl.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/rss2.xml" title="pncalbl" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>pncalbl</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Docker 学习">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      pncalbl
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-01 00:00" pubdate>
        2021年5月1日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      227
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Docker 学习</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：7 天前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="Docker-学习"><a href="#Docker-学习" class="headerlink" title="Docker 学习"></a>Docker 学习</h1><blockquote>
<p>  弱小和无知不是生存的障碍，傲慢才是。</p>
</blockquote>
<h2 id="1-Docker-概述"><a href="#1-Docker-概述" class="headerlink" title="1 Docker 概述"></a>1 Docker 概述</h2><h3 id="1-1-Docker-为什么出现"><a href="#1-1-Docker-为什么出现" class="headerlink" title="1.1 Docker 为什么出现?"></a>1.1 Docker 为什么出现?</h3><p>一款产品： 开发–上线 两套环境！应用环境，应用配置！</p>
<p>开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？</p>
<p>环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。</p>
<p>发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！</p>
<p>之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。</p>
<p>开发环境Windows，最后发布到Linux！</p>
<p>传统：开发jar，运维来做！</p>
<p>现在：开发打包部署上线，一套流程做完！</p>
<p>安卓流程：java — apk —发布（应用商店）一 张三使用apk一安装即可用！</p>
<p>docker流程： java-jar（环境） — 打包项目帯上环境（镜像） — ( Docker仓库：商店）—–</p>
<p>Docker给以上的问题，提出了解决方案!</p>
<p>Docker的思想就来自于集装箱！</p>
<p>JRE – 多个应用(端口冲突) – 原来都是交叉的！<br>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p>
<p>Docker通过隔离机制，可以将服务器利用到极致！</p>
<p>本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！</p>
<h3 id="1-2-Docker-历史"><a href="#1-2-Docker-历史" class="headerlink" title="1.2 Docker 历史"></a>1.2 Docker 历史</h3><p>2010年，几个的年轻人，就在美国成立了一家公司 dotcloud</p>
<p>做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！</p>
<p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p>
<p>他们将自己的技术（容器化技术）命名就是 Docker<br>Docker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！</p>
<blockquote>
<p>  开源</p>
</blockquote>
<p>2013年，Docker开源！</p>
<p>越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！</p>
<p>2014年4月9日，Docker1.0发布！</p>
<p>docker为什么这么火？十分的轻巧！</p>
<p>在容器技术出来之前，我们都是使用虚拟机技术！</p>
<p>虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！</p>
<p>虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">VMware : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟
docker: 隔离，镜像（最核心的环境 <span class="hljs-number">4</span>m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！</code></pre></div>

<p>Docker基于Go语言开发的！开源项目！</p>
<p>docker官网：<a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/">https://docs.docker.com/</a> Docker的文档是超级详细的！</p>
<p>仓库：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>比较Docker和虚拟机技术的不同：</p>
<p>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</p>
<p>容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</p>
<p>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响</p>
<p>应用更快速的交付和部署</p>
<p>传统：一对帮助文档，安装程序。</p>
<p>Docker：打包镜像发布测试一键运行。</p>
<p>更便捷的升级和扩缩容</p>
<p>使用了 Docker之后，我们部署应用就和搭积木一样<br>项目打包为一个镜像，扩展服务器A！服务器B</p>
<p>更简单的系统运维<br>在容器化之后，我们的开发，测试环境都是高度一致的</p>
<p>更高效的计算资源利用</p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</p>
<h2 id="2-Docker-安装"><a href="#2-Docker-安装" class="headerlink" title="2 Docker 安装"></a>2 Docker 安装</h2><h3 id="2-1-Docker-的基本组成"><a href="#2-1-Docker-的基本组成" class="headerlink" title="2.1 Docker 的基本组成"></a>2.1 Docker 的基本组成</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDE5NTgwNTQwMC5wbmc" alt="image-20200514195805400"></p>
<ul>
<li><p>镜像（image)：</p>
<p>docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像 ==&gt; run ==&gt; 容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p>
</li>
<li><p>容器(container)：</p>
<p>Docker 利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.<br>启动，停止，删除，基本命令<br>目前就可以把这个容器理解为就是一个简易的 Linux系统。</p>
</li>
<li><p>仓库(repository)：</p>
<p>仓库就是存放镜像的地方！<br>仓库分为公有仓库和私有仓库。(很类似git)<br>Docker Hub是国外的。<br>阿里云…都有容器服务器(配置镜像加速!)</p>
</li>
</ul>
<h3 id="2-2-安装-Docker"><a href="#2-2-安装-Docker" class="headerlink" title="2.2 安装 Docker"></a>2.2 安装 Docker</h3><blockquote>
<p>  环境准备</p>
</blockquote>
<ol>
<li>Linux要求内核3.0以上</li>
<li>CentOS 7</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs xml">[root@iZwz9chr22v1g8swsrgdagZ ~]# uname -r
3.10.0-1127.19.1.el7.x86_64
[root@iZwz9chr22v1g8swsrgdagZ ~]# cat /etc/os-release 
NAME=&quot;CentOS Linux&quot;
VERSION=&quot;7 (Core)&quot;
ID=&quot;centos&quot;
ID_LIKE=&quot;rhel fedora&quot;
VERSION_ID=&quot;7&quot;
PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;
ANSI_COLOR=&quot;0;31&quot;
CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;
HOME_URL=&quot;https://www.centos.org/&quot;
BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;

CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;
CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;
REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;
REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</code></pre></div>

<blockquote>
<p>  安装</p>
</blockquote>
<p>帮助文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a><br>卸载与安装</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.卸载旧版本</span>
yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
<span class="hljs-meta">#</span><span class="bash"> 2.需要的安装包</span>
yum install -y yum-utils

<span class="hljs-meta">#</span><span class="bash"> 3.设置镜像的仓库</span>
yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
<span class="hljs-meta">#</span><span class="bash">上述方法默认是从国外的，不推荐</span>

<span class="hljs-meta">#</span><span class="bash">推荐使用国内的</span>
yum-config-manager \
    --add-repo \
    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
    
<span class="hljs-meta">#</span><span class="bash">更新yum软件包索引</span>
yum makecache fast

<span class="hljs-meta">#</span><span class="bash"> 4.安装docker相关的 docker-ce 社区版 而ee是企业版</span>
yum install docker-ce docker-ce-cli containerd.io # 这里我们使用社区版即可 安装最新版
sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io-&lt;VERSION_STRING&gt; # 安装固定版本
sudo yum install docker-ce-18.09.1 docker-ce-cli-18.09.1 containerd.io-18.09.1 # 安装固定版本

<span class="hljs-meta">#</span><span class="bash"> 5.设置开机启动并启动docker</span>

systemctl enable docker &amp;&amp; systemctl start docker
y
<span class="hljs-meta">#</span><span class="bash"> 6. 使用docker version查看是否按照成功</span>
docker version</code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195237759.png" alt="image-20210509195237759"></p>
<div class="code-wrapper"><pre><code class="hljs xml"># 7. 测试
docker run hello-world
# 8.不要忘记配置阿里云镜像加速</code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195535948.png" alt="image-20210509195535948"></p>
<div class="code-wrapper"><pre><code class="hljs xml">#8.查看已经下载的镜像(从这里可以查看已有镜像的id)
docker images</code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509195629675.png" alt="image-20210509195629675"></p>
<blockquote>
<p>  卸载docker</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs xml">#1. 卸载依赖
yum remove docker-ce docker-ce-cli containerd.io
#2. 删除资源
rm -rf /var/lib/docker
# /var/lib/docker 是docker的默认工作路径！</code></pre></div>

<h3 id="2-3-阿里云镜像加速"><a href="#2-3-阿里云镜像加速" class="headerlink" title="2.3 阿里云镜像加速"></a>2.3 阿里云镜像加速</h3><ol>
<li><p>登录阿里云找到容器服务</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509212735155.png" alt="image-20210509212735155"></p>
</li>
<li><p>找到镜像加速器</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210509212755335.png" alt="image-20210509212755335"></p>
</li>
<li><p>配置使用</p>
<div class="code-wrapper"><pre><code class="hljs xml">sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;
&#123;
  &quot;registry-mirrors&quot;: [&quot;https://kdx6iqr6.mirror.aliyuncs.com&quot;]
&#125;
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker</code></pre></div>



</li>
</ol>
<h3 id="2-4-回顾HelloWorld流程"><a href="#2-4-回顾HelloWorld流程" class="headerlink" title="2.4 回顾HelloWorld流程"></a>2.4 回顾HelloWorld流程</h3><ul>
<li><p>docker run 流程图</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjYzNzI0Ni5wbmc" alt="image-20200515102637246"></p>
</li>
<li><p>底层原理</p>
<p>Docker<strong>是怎么工作的</strong>？</p>
<p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</p>
<p>Docker-Server接收到Docker-Client的指令，就会执行这个命令！</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjk0OTU1OC5wbmc" alt="image-20200515102949558"></p>
</li>
<li><p>为什么Docker比Vm快</p>
<p>1、docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>2、docker利用的是宿主机的内核,而不需要Guest OS。</p>
<div class="code-wrapper"><pre><code class="hljs xml">GuestOS： VM（虚拟机）里的的系统（OS）

HostOS：物理机里的系统（OS）</code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwNDExNzMyOS5wbmc" alt="image-20200515104117329"></p>
<p>因此,当新建一个 容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。因而避免引导、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了这个复杂的过程,因此新建一个docker容器只需要几秒钟。</p>
</li>
</ul>
<h3 id="2-5-注意非-root-用户的权限问题"><a href="#2-5-注意非-root-用户的权限问题" class="headerlink" title="2.5 注意非 root 用户的权限问题"></a>2.5 注意非 root 用户的权限问题</h3><p>在用户权限下docker 命令需要 sudo 否则出现以下问题</p>
<div class="code-wrapper"><pre><code class="hljs shell">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get &quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.40/version&quot;: dial unix /var/run/docker.sock: connect: permission denied</code></pre></div>

<p>通过将用户添加到docker用户组可以将sudo去掉，命令如下</p>
<div class="code-wrapper"><pre><code class="hljs shell">sudo groupadd docker #添加docker用户组

sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中

newgrp docker #更新用户组</code></pre></div>

<h2 id="3-Docker-命令"><a href="#3-Docker-命令" class="headerlink" title="3 Docker 命令"></a>3 Docker 命令</h2><h3 id="3-1-帮助命令"><a href="#3-1-帮助命令" class="headerlink" title="3.1 帮助命令"></a>3.1 帮助命令</h3><div class="code-wrapper"><pre><code class="hljs dockerfile">docker version    <span class="hljs-comment">#显示docker的版本信息。</span>
docker info       <span class="hljs-comment">#显示docker的系统信息，包括镜像和容器的数量</span>
docker 命令 --help <span class="hljs-comment">#帮助命令</span></code></pre></div>

<p>帮助文档的地址：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p>
<h3 id="3-2-镜像命令"><a href="#3-2-镜像命令" class="headerlink" title="3.2 镜像命令"></a>3.2 镜像命令</h3><div class="code-wrapper"><pre><code class="hljs dockerfile">docker images <span class="hljs-comment">#查看所有本地主机上的镜像 可以使用docker image ls代替</span>

docker search <span class="hljs-comment">#搜索镜像</span>

docker pull <span class="hljs-comment">#下载镜像 docker image pull</span>

docker rmi <span class="hljs-comment">#删除镜像 docker image rm</span></code></pre></div>

<ul>
<li><p>docker images查看所有本地的主机上的镜像</p>
<div class="code-wrapper"><pre><code class="hljs clean">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images
REPOSITORY            TAG                 IMAGE ID            CREATED           SIZE
hello-world           latest              bf756fb1ae65        <span class="hljs-number">4</span> months ago     <span class="hljs-number">13.3</span>kB
mysql                 <span class="hljs-number">5.7</span>                 b84d68d0a7db        <span class="hljs-number">6</span> days ago       <span class="hljs-number">448</span>MB

# 解释
#REPOSITORY			# 镜像的仓库源
#TAG				# 镜像的标签(版本)		---lastest 表示最新版本
#IMAGE ID			# 镜像的id
#CREATED			# 镜像的创建时间
#SIZE				# 镜像的大小

# 可选项
Options:
  -a, --all         Show all images (default hides intermediate images) #列出所有镜像
  -q, --quiet       Only show numeric IDs # 只显示镜像的id
  
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images -a  #列出所有镜像详细信息
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images -aq #列出所有镜像的id
d5f28a0bb0d0
f19c56ce92a8
<span class="hljs-number">1</span>b6b1fe7261e
<span class="hljs-number">1</span>b6b1fe7261e</code></pre></div>
</li>
<li><p>docker search 搜索镜像</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210512223558303.png" alt="image-20210512223558303"></p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker search mysql</span>

<span class="hljs-comment"># --filter=STARS=3000 #过滤，搜索出来的镜像收藏STARS数量大于3000的</span>
Options:
  -f, --filter filter   Filter output based on conditions provided
      --format string   Pretty-print search using a Go template
      --limit int       Max number of search results (default <span class="hljs-number">25</span>)
      --no-trunc        Don<span class="hljs-string">&#x27;t truncate output</span>
<span class="hljs-string">      </span>
<span class="hljs-string">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker search mysql --filter=STARS=3000</span>
<span class="hljs-string">NAME        DESCRIPTION         STARS            OFFICIAL        AUTOMATED</span>
<span class="hljs-string">mysql       MySQL IS ...        9520             [OK]                </span>
<span class="hljs-string">mariadb     MariaDB IS ...      3456             [OK]   </span></code></pre></div>
</li>
<li><p>docker pull 下载镜像</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 下载镜像 docker pull 镜像名[:tag]</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker pull tomcat:8</span>
<span class="hljs-number">8</span>: Pulling <span class="hljs-keyword">from</span> library/tomcat <span class="hljs-comment">#如果不写tag，默认就是latest</span>
<span class="hljs-number">90</span>fe46dd8199: Already exists   <span class="hljs-comment">#分层下载： docker image 的核心 联合文件系统</span>
<span class="hljs-number">35</span>a4f1977689: Already exists 
bbc37f14aded: Already exists 
<span class="hljs-number">74</span>e27dc593d4: Already exists 
<span class="hljs-number">93</span>a01fbfad7f: Already exists 
<span class="hljs-number">1478</span>df405869: Pull complete 
<span class="hljs-number">64</span>f0dd11682b: Pull complete 
<span class="hljs-number">68</span>ff4e050d11: Pull complete 
f576086003cf: Pull complete 
<span class="hljs-number">3</span>b72593ce10e: Pull complete 
Digest: sha256:<span class="hljs-number">0</span>c6234e7ec9d10ab32c06423ab829b32e3183ba5bf2620ee66de866df <span class="hljs-comment"># 签名防伪</span>
Status: Downloaded newer image for tomcat:<span class="hljs-number">8</span>
docker.io/library/tomcat:<span class="hljs-number">8</span> <span class="hljs-comment">#真实地址</span>

<span class="hljs-comment">#等价于</span>
docker pull tomcat:<span class="hljs-number">8</span>
docker pull docker.io/library/tomcat:<span class="hljs-number">8</span></code></pre></div>
</li>
<li><p>docker rmi 删除镜像</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">docker rmi -f 镜像id <span class="hljs-comment">#删除指定id的镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker rmi -f f19c56ce92a8</span>

docker rmi -f $(docker images -aq) <span class="hljs-comment">#删除全部的镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker stop $(docker ps -a -q)</span></code></pre></div>

</li>
</ul>
<h3 id="3-3-容器命令"><a href="#3-3-容器命令" class="headerlink" title="3.3 容器命令"></a>3.3 容器命令</h3><ul>
<li><p>镜像下载</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment">#docker中下载centos</span>
docker pull centos</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> 镜像id <span class="hljs-comment">#新建容器并启动</span></span>

docker ps 列出所有运行的容器 docker container list

docker rm 容器id <span class="hljs-comment">#删除指定容器</span>

docker start 容器id	<span class="hljs-comment">#启动容器</span>
docker restart 容器id	<span class="hljs-comment">#重启容器</span>
docker stop 容器id	<span class="hljs-comment">#停止当前正在运行的容器</span>
docker kill 容器id	<span class="hljs-comment">#强制停止当前容器</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs dockerfile">[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker container list  #h和docker ps相同</span></code></pre></div>
</li>
<li><p>新建容器并启动</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> [可选参数] image | docker container run [可选参数] image </span>
<span class="hljs-comment">#参书说明</span>
--name=<span class="hljs-string">&quot;Name&quot;</span>		<span class="hljs-comment">#容器名字 tomcat01 tomcat02 用来区分容器</span>
-d					<span class="hljs-comment">#后台方式运行</span>
-it 				<span class="hljs-comment">#使用交互方式运行，进入容器查看内容</span>
-p					<span class="hljs-comment">#指定容器的端口 -p 8080(宿主机):8080(容器)</span>
		-p ip:主机端口:容器端口
		-p 主机端口:容器端口(常用)
		-p 容器端口
		容器端口
-P(大写) 				随机指定端口

<span class="hljs-comment"># 测试、启动并进入容器</span>
[root@iz2zeak7sgj6i7hrb2g
[root@iz2zeak7sgj6i7hrb2g862z ~]<span class="hljs-comment"># docker run -it centos /bin/bash</span>
[root@<span class="hljs-number">241</span>b5abce65e /]<span class="hljs-comment"># ls</span>
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  <span class="hljs-keyword">run</span><span class="bash">  sbin  srv  sys  tmp  usr  var</span>
[root@<span class="hljs-number">241</span>b5abce65e /]<span class="hljs-comment"># exit #从容器退回主机</span>
exit</code></pre></div>
</li>
<li><p>列出所有运行的容器</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">docker ps 命令  		<span class="hljs-comment">#列出当前正在运行的容器</span>
  -a, --all     	 <span class="hljs-comment">#列出当前正在运行的容器 + 带出历史运行过的容器</span>
  -n=?, --last int   <span class="hljs-comment">#列出最近创建的?个容器 ?为1则只列出最近创建的一个容器,为2则列出2个</span>
  -q, --quiet        <span class="hljs-comment">#只列出容器的编号</span></code></pre></div>
</li>
<li><p>退出容器</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">exit 		<span class="hljs-comment">#容器直接退出</span>
ctrl +P +Q  <span class="hljs-comment">#容器不停止退出 	---注意：这个很有用的操作</span></code></pre></div>
</li>
<li><p>删除容器</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">docker rm 容器id   				<span class="hljs-comment">#删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -rf</span>
docker rm -f $(docker ps -aq)  	 <span class="hljs-comment">#删除所有的容器</span>
docker ps -a -q|xargs docker rm  <span class="hljs-comment">#删除所有的容器</span></code></pre></div>
</li>
<li><p>启动和停止容器的操作</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">docker start 容器id	<span class="hljs-comment">#启动容器</span>
docker restart 容器id	<span class="hljs-comment">#重启容器</span>
docker stop 容器id	<span class="hljs-comment">#停止当前正在运行的容器</span>
docker kill 容器id	<span class="hljs-comment">#强制停止当前容器</span></code></pre></div>


</li>
</ul>
<h3 id="3-4-常用其他命令"><a href="#3-4-常用其他命令" class="headerlink" title="3.4 常用其他命令"></a>3.4 常用其他命令</h3><ul>
<li><p><strong>后台启动命令</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令 docker run -d 镜像名</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d centos
a8f922c255859622ac45ce3a535b7a0e8253329be4756ed6e32265d2dd2fac6c

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps    
CONTAINER ID      IMAGE       COMMAND    CREATED     STATUS   PORTS    NAMES
<span class="hljs-meta">#</span><span class="bash"> 问题docker ps. 发现centos 停止了</span>
<span class="hljs-meta">#</span><span class="bash"> 常见的坑，docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止</span>
<span class="hljs-meta">#</span><span class="bash"> nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span></code></pre></div>
</li>
<li><p><strong>查看日志</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell">docker logs --help
Options:
      --details        Show extra details provided to logs 
*  -f, --follow         Follow log output
      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)
*      --tail string    Number of lines to show from the end of the logs (default &quot;all&quot;)
*  -t, --timestamps     Show timestamps
      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)
➜  ~ docker run -d centos /bin/sh -c &quot;while true;do echo 6666;sleep 1;done&quot; #模拟日志      
<span class="hljs-meta">#</span><span class="bash">显示日志</span>
-tf		#显示日志信息（一直更新）
--tail number #需要显示日志条数
docker logs -t --tail n 容器id #查看n行日志
docker logs -ft 容器id #跟着日志</code></pre></div>
</li>
<li><p><strong>查看容器中进程信息ps</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令 docker top 容器id</span></code></pre></div>
</li>
<li><p><strong>查看镜像的元数据</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令</span>
docker inspect 容器id

<span class="hljs-meta">#</span><span class="bash">测试</span>
➜  ~ docker inspect 55321bcae33d
[
    &#123;
        &quot;Id&quot;: &quot;55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066&quot;,
        &quot;Created&quot;: &quot;2020-05-15T05:22:05.515909071Z&quot;,
        &quot;Path&quot;: &quot;/bin/sh&quot;,
        &quot;Args&quot;: [
            &quot;-c&quot;,
            &quot;while true;do echo 6666;sleep 1;done&quot;
        ],
        &quot;State&quot;: &#123;
            &quot;Status&quot;: &quot;running&quot;,
            &quot;Running&quot;: true,
            &quot;Paused&quot;: false,
            &quot;Restarting&quot;: false,
            &quot;OOMKilled&quot;: false,
            &quot;Dead&quot;: false,
            &quot;Pid&quot;: 22973,
            &quot;ExitCode&quot;: 0,
            &quot;Error&quot;: &quot;&quot;,
            &quot;StartedAt&quot;: &quot;2020-05-15T05:22:06.165904633Z&quot;,
            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;
        &#125;,
        &quot;Image&quot;: &quot;sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee&quot;,
        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/resolv.conf&quot;,
        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/hostname&quot;,
        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/55321bcae33d15da8280bcac1d2bc1141d213bcc8f8e792edfd832ff61ae5066/hosts&quot;,
........</code></pre></div>
</li>
<li><p><strong>进入当前正在运行的容器</strong></p>
<p>我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</p>
<ul>
<li><p>docker exec -it 容器id bashshell</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">测试</span>
➜ ~ docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
55321bcae33d centos “/bin/sh -c &#x27;while t…” 10 minutes ago Up 10 minutes bold_bell
a7215824a4db centos “/bin/sh -c &#x27;while t…” 13 minutes ago Up 13 minutes zen_kepler
55a31b3f8613 centos “/bin/bash” 15 minutes ago Up 15 minutes lucid_clarke
➜ ~ docker exec -it 55321bcae33d /bin/bash
[root@55321bcae33d /]#</code></pre></div>
</li>
<li><p>方法2</p>
<div class="code-wrapper"><pre><code class="hljs shell">docker attach 容器id
<span class="hljs-meta">#</span><span class="bash">测试</span>
docker attach 55321bcae33d 
正在执行当前的代码...
区别
<span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> <span class="hljs-comment">#进入当前容器后开启一个新的终端，可以在里面操作。（常用）</span></span>
<span class="hljs-meta">#</span><span class="bash">docker attach <span class="hljs-comment"># 进入容器正在执行的终端</span></span></code></pre></div>
</li>
</ul>
</li>
<li><p><strong>从容器内拷贝到主机上</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell">docker cp 容器id:容器内路径  主机目的路径

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps
CONTAINER ID     IMAGE    COMMAND     CREATED         STATUS       PORTS      NAMES
56a5583b25b4     centos   &quot;/bin/bash&quot; 7seconds ago    Up 6 seconds      

<span class="hljs-meta">#</span><span class="bash">1. 进入docker容器内部</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 56a5583b25b4 /bin/bash
[root@55321bcae33d /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

<span class="hljs-meta">#</span><span class="bash">新建一个文件</span>
[root@55321bcae33d /]# echo &quot;hello&quot; &gt; java.java
[root@55321bcae33d /]# cat hello.java 
hello
[root@55321bcae33d /]# exit
exit

<span class="hljs-meta">#</span><span class="bash">hello.java拷贝到home文件加下</span>
[root@iz2zeak7sgj6i7hrb2g862z /]# docker cp 56a5583b25b4:/hello.java /home 
[root@iz2zeak7sgj6i7hrb2g862z /]# cd /home
[root@iz2zeak7sgj6i7hrb2g862z home]# ls -l	#可以看见java.java存在
total 8
-rw-r--r-- 1 root root    0 May 19 22:09 haust.java
-rw-r--r-- 1 root root    6 May 22 11:12 java.java
drwx------ 3 www  www  4096 May  8 12:14 www</code></pre></div>

</li>
</ul>
<p>学习方式：将我的所有笔记敲一遍，自己记录笔记！</p>
<h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDIxNDMxMzk2Mi5wbmc" alt="image-20200514214313962"></p>
<h3 id="3-6-命令大全"><a href="#3-6-命令大全" class="headerlink" title="3.6 命令大全"></a>3.6 <strong>命令大全</strong></h3><div class="code-wrapper"><pre><code class="hljs shell">attach      Attach local standard input, output, and error streams to a running container
<span class="hljs-meta">#</span><span class="bash">当前shell下 attach连接指定运行的镜像</span>
build       Build an image from a Dockerfile # 通过Dockerfile定制镜像
commit      Create a new image from a container&#x27;s changes #提交当前容器为新的镜像
cp          Copy files/folders between a container and the local filesystem #拷贝文件
create      Create a new container #创建一个新的容器
diff        Inspect changes to files or directories on a container&#x27;s filesystem #查看docker容器的变化
events      Get real time events from the server # 从服务获取容器实时时间
exec        Run a command in a running container # 在运行中的容器上运行命令
export      Export a container&#x27;s filesystem as a tar archive #导出容器文件系统作为一个tar归档文件[对应import]
history     Show the history of an image # 展示一个镜像形成历史
images      List images #列出系统当前的镜像
import      Import the contents from a tarball to create a filesystem image #从tar包中导入内容创建一个文件系统镜像
info        Display system-wide information # 显示全系统信息
inspect     Return low-level information on Docker objects #查看容器详细信息
kill        Kill one or more running containers # kill指定docker容器
load        Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载一个镜像[对应save]
login       Log in to a Docker registry #
logout      Log out from a Docker registry
logs        Fetch the logs of a container
pause       Pause all processes within one or more containers
port        List port mappings or a specific mapping for the container
ps          List containers
pull        Pull an image or a repository from a registry
push        Push an image or a repository to a registry
rename      Rename a container
restart     Restart one or more containers
rm          Remove one or more containers
rmi         Remove one or more images
run         Run a command in a new container
save        Save one or more images to a tar archive (streamed to STDOUT by default)
search      Search the Docker Hub for images
start       Start one or more stopped containers
stats       Display a live stream of container(s) resource usage statistics
stop        Stop one or more running containers
tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
top         Display the running processes of a container
unpause     Unpause all processes within one or more containers
update      Update configuration of one or more containers
version     Show the Docker version information
wait        Block until one or more containers stop, then print their exit codes</code></pre></div>



<h2 id="4-Docker-服务安装"><a href="#4-Docker-服务安装" class="headerlink" title="4 Docker 服务安装"></a>4 Docker 服务安装</h2><h3 id="4-1-安装-Nginx"><a href="#4-1-安装-Nginx" class="headerlink" title="4.1 安装 Nginx"></a>4.1 安装 Nginx</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">1. 搜索镜像 search 建议大家去docker搜索，可以看到帮助文档</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker search nginx

<span class="hljs-meta">#</span><span class="bash">2. 拉取下载镜像 pull</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull nginx

<span class="hljs-meta">#</span><span class="bash">3. 查看是否下载成功镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images

<span class="hljs-meta">#</span><span class="bash">3. 运行测试</span>
<span class="hljs-meta">#</span><span class="bash"> -d 后台运行</span>
<span class="hljs-meta">#</span><span class="bash"> --name 给容器命名</span>
<span class="hljs-meta">#</span><span class="bash"> -p 宿主机端口：容器内部端口</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name nginx01 -p 3344:80 nginx
aa664b0c8ed98f532453ce1c599be823bcc1f3c9209e5078615af416ccb454c2

<span class="hljs-meta">#</span><span class="bash">4. 查看正在启动的镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
75943663c116        nginx               &quot;nginx -g &#x27;daemon of…&quot;   41 seconds ago      Up 40 seconds       0.0.0.0:82-&gt;80/tcp   nginx00

<span class="hljs-meta">#</span><span class="bash">5. 进入容器</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it nginx01 /bin/bash #进入
root@aa664b0c8ed9:/# whereis nginx	#找到nginx位置
nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
root@aa664b0c8ed9:/# cd /etc/nginx/
root@aa664b0c8ed9:/etc/nginx# ls
conf.d	fastcgi_params	koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params	uwsgi_params  win-utf

<span class="hljs-meta">#</span><span class="bash">6. 退出容器</span>
root@aa664b0c8ed9:/etc/nginx# exit
exit

<span class="hljs-meta">#</span><span class="bash">7. 停止容器</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
aa664b0c8ed9        nginx               &quot;nginx -g &#x27;daemon of…&quot;   10 minutes ago      Up 10 minutes       0.0.0.0:3344-&gt;80/tcp   nginx01
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop aa664b0c8ed9</code></pre></div>

<p><strong>宿主机端口</strong> 和 <strong>容器内部端口</strong> 以及端口暴露：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDIxNTkxNTY1MC5wbmc" alt="img"></p>
<p><strong>问题：</strong>我们每次改动nginx配置文件，都需要进入容器内部？十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器外部修改文件名，容器内部就可以自动修改？-v 数据卷 技术！</p>
<h3 id="4-3-安装-Tomcat"><a href="#4-3-安装-Tomcat" class="headerlink" title="4.3 安装 Tomcat"></a>4.3 安装 Tomcat</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载 tomcat9.0</span>
<span class="hljs-meta">#</span><span class="bash"> 之前的启动都是后台，停止了容器，容器还是可以查到， docker run -it --rm 镜像名 一般是用来测试，用完就删除</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -it --rm tomcat:9.0

--rm       Automatically remove the container when it exits 用完即删

<span class="hljs-meta">#</span><span class="bash">下载 最新版</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull tomcat

<span class="hljs-meta">#</span><span class="bash">查看下载的镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images

<span class="hljs-meta">#</span><span class="bash">以后台方式，暴露端口方式，启动运行</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 --name tomcat01 tomcat

<span class="hljs-meta">#</span><span class="bash">测试访问有没有问题</span>
curl localhost:8080

<span class="hljs-meta">#</span><span class="bash">根据容器id进入tomcat容器</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 645596565d3f /bin/bash
root@645596565d3f:/usr/local/tomcat# 
<span class="hljs-meta">#</span><span class="bash">查看tomcat容器内部内容：</span>
root@645596565d3f:/usr/local/tomcat# ls -l
total 152
-rw-r--r-- 1 root root 18982 May  5 20:40 BUILDING.txt
-rw-r--r-- 1 root root  5409 May  5 20:40 CONTRIBUTING.md
-rw-r--r-- 1 root root 57092 May  5 20:40 LICENSE
-rw-r--r-- 1 root root  2333 May  5 20:40 NOTICE
-rw-r--r-- 1 root root  3255 May  5 20:40 README.md
-rw-r--r-- 1 root root  6898 May  5 20:40 RELEASE-NOTES
-rw-r--r-- 1 root root 16262 May  5 20:40 RUNNING.txt
drwxr-xr-x 2 root root  4096 May 16 12:05 bin
drwxr-xr-x 1 root root  4096 May 21 11:04 conf
drwxr-xr-x 2 root root  4096 May 16 12:05 lib
drwxrwxrwx 1 root root  4096 May 21 11:04 logs
drwxr-xr-x 2 root root  4096 May 16 12:05 native-jni-lib
drwxrwxrwx 2 root root  4096 May 16 12:05 temp
drwxr-xr-x 2 root root  4096 May 16 12:05 webapps
drwxr-xr-x 7 root root  4096 May  5 20:37 webapps.dist
drwxrwxrwx 2 root root  4096 May  5 20:36 work
root@645596565d3f:/usr/local/tomcat# 
<span class="hljs-meta">#</span><span class="bash">进入webapps目录</span>
root@645596565d3f:/usr/local/tomcat# cd webapps
root@645596565d3f:/usr/local/tomcat/webapps# ls
root@645596565d3f:/usr/local/tomcat/webapps# 
<span class="hljs-meta">#</span><span class="bash"> 发现问题：1、linux命令少了。 2.webapps目录为空</span> 
<span class="hljs-meta">#</span><span class="bash"> 原因：阿里云镜像的原因，阿里云默认是最小的镜像，所以不必要的都剔除掉</span>
<span class="hljs-meta">#</span><span class="bash"> 保证最小可运行的环境！</span>
<span class="hljs-meta">#</span><span class="bash"> 解决方案：</span>
<span class="hljs-meta">#</span><span class="bash"> 将webapps.dist下的文件都拷贝到webapps下即可</span>
root@645596565d3f:/usr/local/tomcat# ls 找到webapps.dist
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs  temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin   lib   native-jni-lib  webapps  work

root@645596565d3f:/usr/local/tomcat# cd webapps.dist/ # 进入webapps.dist 
root@645596565d3f:/usr/local/tomcat/webapps.dist# ls # 查看内容
ROOT  docs  examples  host-manager  manager

root@645596565d3f:/usr/local/tomcat/webapps.dist# cd ..
root@645596565d3f:/usr/local/tomcat# cp -r webapps.dist/* webapps # 拷贝webapps.dist 内容给webapps
root@645596565d3f:/usr/local/tomcat# cd webapps #进入webapps
root@645596565d3f:/usr/local/tomcat/webapps# ls #查看拷贝结果
ROOT  docs  examples  host-manager  manager</code></pre></div>

<p>这样docker部署tomcat就可以访问了</p>
<p><strong>问题</strong>:我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？要是可以在容器外部提供一个映射路径，比如webapps，我们在外部放置项目，就自动同步内部就好了！</p>
<h3 id="4-3-部署elasticsearch-kibana"><a href="#4-3-部署elasticsearch-kibana" class="headerlink" title="4.3 部署elasticsearch+kibana"></a>4.3 部署elasticsearch+kibana</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> es 暴露的端口很多！</span>
<span class="hljs-meta">#</span><span class="bash"> es 十分耗内存</span>
<span class="hljs-meta">#</span><span class="bash"> es 的数据一般需要放置到安全目录！挂载</span>
<span class="hljs-meta">#</span><span class="bash"> --net somenetwork ? 网络配置</span>

<span class="hljs-meta">#</span><span class="bash"> 启动elasticsearch</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2

<span class="hljs-meta">#</span><span class="bash"> 测试一下es是否成功启动</span>
➜  ~ curl localhost:9200
&#123;
  &quot;name&quot; : &quot;d73ad2f22dd3&quot;,
  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,
  &quot;cluster_uuid&quot; : &quot;atFKgANxS8CzgIyCB8PGxA&quot;,
  &quot;version&quot; : &#123;
    &quot;number&quot; : &quot;7.6.2&quot;,
    &quot;build_flavor&quot; : &quot;default&quot;,
    &quot;build_type&quot; : &quot;docker&quot;,
    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,
    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;8.4.0&quot;,
    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,
    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;
  &#125;,
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
&#125;

<span class="hljs-meta">#</span><span class="bash">测试成功就关掉elasticSearch，防止耗内存</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop d834ce2bd306
d834ce2bd306

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stats  # 查看docker容器使用内存情况

<span class="hljs-meta">#</span><span class="bash"> 限制最大内存</span>
docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;Xms2m -Xmx512m&quot; elasticsearch:7.6.2
</code></pre></div>

<h3 id="4-4-Portainer-可视化面板安装"><a href="#4-4-Portainer-可视化面板安装" class="headerlink" title="4.4 Portainer 可视化面板安装"></a>4.4 Portainer 可视化面板安装</h3><ul>
<li><p>portainer(先用这个)</p>
<div class="code-wrapper"><pre><code class="hljs shell">docker run -d -p 8080:9000 \
--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre></div>
</li>
<li><p>Rancher(CI/CD再用)<br><strong>什么是portainer？</strong></p>
<p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装命令</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:9000 \
<span class="hljs-meta">&gt;</span><span class="bash"> --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="hljs-literal">true</span> portainer/portainer</span>

Unable to find image &#x27;portainer/portainer:latest&#x27; locally
latest: Pulling from portainer/portainer
d1e017099d17: Pull complete 
a7dca5b5a9e8: Pull complete 
Digest: sha256:4ae7f14330b56ffc8728e63d355bc4bc7381417fa45ba0597e5dd32682901080
Status: Downloaded newer image for portainer/portainer:latest
81753869c4fd438cec0e31659cbed0d112ad22bbcfcb9605483b126ee8ff306d</code></pre></div>

<p>测试访问： 外网：8080 ：<a target="_blank" rel="noopener" href="http://123.56.247.59:8080/">http://123.56.247.59:8080/</a></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE1NTAwNjA3OS5wbmc" alt></p>
<p>进入之后的面板</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210526004802841.png" alt></p>
</li>
</ul>
<h2 id="5-Docker-镜像讲解"><a href="#5-Docker-镜像讲解" class="headerlink" title="5 Docker 镜像讲解"></a>5 Docker 镜像讲解</h2><h3 id="5-1-镜像原理之联合文件系统"><a href="#5-1-镜像原理之联合文件系统" class="headerlink" title="5.1  镜像原理之联合文件系统"></a>5.1  镜像原理之联合文件系统</h3><h4 id="5-1-1-镜像是什么"><a href="#5-1-1-镜像是什么" class="headerlink" title="5.1.1 镜像是什么"></a>5.1.1 镜像是什么</h4><ul>
<li><p>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p>
</li>
<li><p>所有应用，直接打包docker镜像，就可以直接跑起来！</p>
</li>
</ul>
<h4 id="5-1-2-如何得到镜像"><a href="#5-1-2-如何得到镜像" class="headerlink" title="5.1.2 如何得到镜像"></a>5.1.2 如何得到镜像</h4><ul>
<li>从远程仓库下载</li>
<li>别人拷贝给你</li>
<li>自己制作一个镜像 DockerFile</li>
</ul>
<h3 id="5-2-Docker镜像加载原理"><a href="#5-2-Docker镜像加载原理" class="headerlink" title="5.2 Docker镜像加载原理"></a>5.2 Docker镜像加载原理</h3><blockquote>
<p>  UnionFs （联合文件系统）</p>
</blockquote>
<ul>
<li>UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像</li>
<li>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</li>
</ul>
<blockquote>
<p>  Docker镜像加载原理</p>
</blockquote>
<ul>
<li>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</li>
<li>boots(boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。</li>
<li>rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzA0OTk1OS5wbmc" alt></p>
<ul>
<li>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzE0MDU1OS5wbmc" alt></p>
<ul>
<li>对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs.</li>
</ul>
<ul>
<li>虚拟机是分钟级别，容器是秒级！</li>
</ul>
<h3 id="5-3-分层理解"><a href="#5-3-分层理解" class="headerlink" title="5.3 分层理解"></a>5.3 分层理解</h3><blockquote>
<p>  分层的镜像</p>
</blockquote>
<ul>
<li><p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzgzOTE4MC5wbmc" alt="img"></p>
</li>
</ul>
<p>思考：为什么Docker镜像要采用这种分层的结构呢？</p>
<ul>
<li>最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</li>
</ul>
<ul>
<li><p>查看镜像分层的方式可以通过docker image inspect 命令。</p>
<div class="code-wrapper"><pre><code class="hljs shell">➜  / docker image inspect redis          
[
    &#123;
        &quot;Id&quot;: &quot;sha256:f9b9909726890b00d2098081642edf32e5211b7ab53563929a47f250bcdc1d7c&quot;,
        &quot;RepoTags&quot;: [
            &quot;redis:latest&quot;
        ],
        &quot;RepoDigests&quot;: [
            &quot;redis@sha256:399a9b17b8522e24fbe2fd3b42474d4bb668d3994153c4b5d38c3dafd5903e32&quot;
        ],
        &quot;Parent&quot;: &quot;&quot;,
        &quot;Comment&quot;: &quot;&quot;,
        &quot;Created&quot;: &quot;2020-05-02T01:40:19.112130797Z&quot;,
        &quot;Container&quot;: &quot;d30c0bcea88561bc5139821227d2199bb027eeba9083f90c701891b4affce3bc&quot;,
        &quot;ContainerConfig&quot;: &#123;
            &quot;Hostname&quot;: &quot;d30c0bcea885&quot;,
            &quot;Domainname&quot;: &quot;&quot;,
            &quot;User&quot;: &quot;&quot;,
            &quot;AttachStdin&quot;: false,
            &quot;AttachStdout&quot;: false,
            &quot;AttachStderr&quot;: false,
            &quot;ExposedPorts&quot;: &#123;
                &quot;6379/tcp&quot;: &#123;&#125;
            &#125;,
            &quot;Tty&quot;: false,
            &quot;OpenStdin&quot;: false,
            &quot;StdinOnce&quot;: false,
            &quot;Env&quot;: [
                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,
                &quot;GOSU_VERSION=1.12&quot;,
                &quot;REDIS_VERSION=6.0.1&quot;,
                ]
 .......</code></pre></div>
</li>
<li><p><strong>理解：</strong></p>
<ul>
<li><p>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p>
</li>
<li><p>举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，<br>就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含3个镜像层，如下图所示</p>
</li>
<li><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合.</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTIzNDI3NC5wbmc" alt></p>
</li>
<li><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NDk1ODkzMi5wbmc" alt></p>
</li>
<li><p>上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件</p>
</li>
<li><p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTE0ODAwMi5wbmc" alt></p>
</li>
<li><p>在这种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中</p>
</li>
<li><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统</p>
</li>
<li><p>Linux上可用的存储引擎有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的<br>件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。</p>
</li>
<li><p>Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW 。</p>
</li>
<li><p>下图展示了与系统显示相同的三层镜像。所有镜像层堆并合井，对外提供统一的视图。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTU1NzgwNy5wbmc" alt></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>  特点</p>
</blockquote>
<ul>
<li><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！</p>
</li>
<li><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MTUwNTg5Ny5wbmc" alt></p>
</li>
</ul>
<blockquote>
<p>  commit镜像</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs routeros">docker commit 提交容器成为一个新的副本

<span class="hljs-comment"># 命令和git原理类似</span>
docker commit <span class="hljs-attribute">-m</span>=<span class="hljs-string">&quot;描述信息&quot;</span> <span class="hljs-attribute">-a</span>=<span class="hljs-string">&quot;作者&quot;</span> 容器id 目标镜像名:[版本TAG]</code></pre></div>

<p>实战测试</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、启动一个默认的tomcat</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 tomcat
de57d0ace5716d27d0e3a7341503d07ed4695ffc266aef78e0a855b270c4064e

<span class="hljs-meta">#</span><span class="bash"> 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！</span>
<span class="hljs-meta">#</span><span class="bash">docker <span class="hljs-built_in">exec</span> -it 容器id /bin/bash</span>
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it de57d0ace571 /bin/bash
root@de57d0ace571:/usr/local/tomcat# 

<span class="hljs-meta">#</span><span class="bash"> 3、从webapps.dist拷贝文件进去webapp</span>
root@de57d0ace571:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@de57d0ace571:/usr/local/tomcat# cd webapps
root@de57d0ace571:/usr/local/tomcat/webapps# ls
ROOT  docs  examples  host-manager  manager

<span class="hljs-meta">#</span><span class="bash"> 4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，而不需要每次都重新拷贝webapps.dist下的文件到webapps了，这就是我们自己的一个修改的镜像。</span>
docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]
docker commit -a=&quot;pncalbl&quot; -m=&quot;add webapps app&quot; 6c5381bbe865 tomcat02:1.0

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker commit -a=&quot;csp提交的&quot; -m=&quot;add webapps app&quot; de57d0ace571 tomcat02.1.0
sha256:d5f28a0bb0d0b6522fdcb56f100d11298377b2b7c51b9a9e621379b01cf1487e

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
tomcat02.1.0          latest              d5f28a0bb0d0        14 seconds ago      652MB
tomcat                latest              1b6b1fe7261e        5 days ago          647MB
nginx                 latest              9beeba249f3e        5 days ago          127MB
mysql                 5.7                 b84d68d0a7db        5 days ago          448MB
elasticsearch         7.6.2               f29a1ee41030        8 weeks ago         791MB
portainer/portainer   latest              2869fc110bf7        2 months ago        78.6MB
centos                latest              470671670cac        4 months ago        237MB
hello-world           latest              bf756fb1ae65        4 months ago        13.3kB</code></pre></div>

<h2 id="5-容器数据卷"><a href="#5-容器数据卷" class="headerlink" title="5 容器数据卷"></a>5 容器数据卷</h2><h3 id="5-1-什么是容器数据卷"><a href="#5-1-什么是容器数据卷" class="headerlink" title="5.1 什么是容器数据卷"></a>5.1 什么是容器数据卷</h3><p>将应用和环境打包成一个镜像！</p>
<p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p>
<p>MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！</p>
<p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p>
<p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEwNTI1ODQ1Ni5wbmc" alt></p>
<p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p>
<h3 id="5-2-使用数据卷"><a href="#5-2-使用数据卷" class="headerlink" title="5.2 使用数据卷"></a>5.2 使用数据卷</h3><blockquote>
<p>  方式一 ：直接使用命令挂载 -v</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs shell">-v, --volume list                    Bind mount a volume

docker run -it -v 主机目录:容器内目录  -p 主机端口:容器内端口
<span class="hljs-meta">#</span><span class="bash"> /home/ceshi：主机home目录下的ceshi文件夹  映射：centos容器中的/home</span>
[root@iz2zeak7 home]# docker run -it -v /home/ceshi:/home centos /bin/bash
<span class="hljs-meta">#</span><span class="bash">这时候主机的/home/ceshi文件夹就和容器的/home文件夹关联了,二者可以实现文件或数据同步了</span>

<span class="hljs-meta">#</span><span class="bash">通过 docker inspect 容器id 查看</span>
[root@iz2zeak7sgj6i7hrb2g862z home]# docker inspect 6064c490c371</code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601210704586.png" alt></p>
<p>测试文件的同步</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601210829068.png" alt="image-20210601210829068"></p>
<p>再来测试！</p>
<p>1、停止容器</p>
<p>2、宿主机修改文件</p>
<p>3、启动容器</p>
<p>4、容器内的数据依旧是同步的</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMDg1MDQzMS5wbmc" alt></p>
<p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p>
<h3 id="5-3-实战：安装MySQL"><a href="#5-3-实战：安装MySQL" class="headerlink" title="5.3 实战：安装MySQL"></a>5.3 实战：安装MySQL</h3><p><strong>思考：MySQL的数据持久化的问题</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 获取mysql镜像</span>
[root@iz2zeak7sgj6i7hrb2g862z home]# docker pull mysql:5.7

<span class="hljs-meta">#</span><span class="bash"> 运行容器,需要做数据挂载 <span class="hljs-comment">#安装启动mysql，需要配置密码的，这是要注意点！</span></span>
<span class="hljs-meta">#</span><span class="bash"> 参考官网hub</span> 
docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag

<span class="hljs-meta">#</span><span class="bash">启动我们得</span>
-d 后台运行
-p 端口映射
-v 卷挂载
-e 环境配置
-- name 容器名字

docker run -p 3306:3306 --name docker-mysql
-v /usr/local/workspace/docker/mysql/conf:/etc/mysql
-v /usr/local/workspace/docker/mysql/data:/var/lib/mysql
-e MYSQL_ROOT_PASSWORD=12345678 -d mysql:5.6

<span class="hljs-meta">#</span><span class="bash"> 启动成功之后，我们在本地使用sqlyog来测试一下</span>
<span class="hljs-meta">#</span><span class="bash"> sqlyog-连接到服务器的3306--和容器内的3306映射</span> 

<span class="hljs-meta">#</span><span class="bash"> 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！</span></code></pre></div>

<p><strong>测试连接</strong>：注意3310端口要在阿里云服务器的安全组中打开，否则无法连接。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601212226538.png" alt></p>
<p>当我们在本地用Navicat新建名称为test的数据库时候，容器容器也会创建</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210601212456348.png" alt="image-20210601212456348"></p>
<p>假设我们将包含mysql的容器删除时，</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMjUzMjk1MC5wbmc" alt></p>
<p>发现，<strong>我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能</strong>。</p>
<h3 id="5-4-具名和匿名挂载"><a href="#5-4-具名和匿名挂载" class="headerlink" title="5.4 具名和匿名挂载"></a>5.4 具名和匿名挂载</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 匿名挂载</span>
-v 容器内路径!
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx01 -v /etc/nginx nginx</span>

<span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span>
<span class="hljs-meta">$</span><span class="bash"> docker volume ls</span>    
DRIVER              VOLUME NAME # 容器内的卷名(匿名卷挂载)
local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0
local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c
         
<span class="hljs-meta">#</span><span class="bash"> 这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路径！</span>

<span class="hljs-meta">#</span><span class="bash"> 具名挂载 -P:表示随机映射端口</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span>
9663cfcb1e5a9a1548867481bfddab9fd7824a6dc4c778bf438a040fe891f0ee

<span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span>
<span class="hljs-meta">$</span><span class="bash"> docker volume ls</span>                  
DRIVER              VOLUME NAME
local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0
local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c
local               juming-nginx #多了一个名字


<span class="hljs-meta">#</span><span class="bash"> 通过 -v 卷名：查看容器内路径</span>
<span class="hljs-meta">#</span><span class="bash"> 查看一下这个卷</span>
<span class="hljs-meta">$</span><span class="bash"> docker volume inspect juming-nginx</span>
[
    &#123;
        &quot;CreatedAt&quot;: &quot;2020-05-23T13:55:34+08:00&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: null,
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;, #默认目录
        &quot;Name&quot;: &quot;juming-nginx&quot;,
        &quot;Options&quot;: null,
        &quot;Scope&quot;: &quot;local&quot;
    &#125;
]</code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExMzU0NTc0Ni5wbmc" alt></p>
<p>所有的docker容器内的卷，没有指定目录的情况下都是在<strong>/var/lib/docker/volumes/自定义的卷名/_data</strong>下，<strong>如果指定了目录，docker volume ls 是查看不到的</strong>。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExNDIzMTQzNS5wbmc" alt></p>
<p><strong>区分三种挂载方式</strong></p>
<div class="code-wrapper"><pre><code class="hljs haml"># 三种挂载： 匿名挂载、具名挂载、指定路径挂载
-<span class="ruby">v 容器内路径			<span class="hljs-comment">#匿名挂载</span></span>
<span class="ruby">-v 卷名：容器内路径		  <span class="hljs-comment">#具名挂载</span></span>
<span class="ruby">-v /宿主机路径：容器内路径 <span class="hljs-comment">#指定路径挂载 docker volume ls 是查看不到的</span></span></code></pre></div>

<p>拓展：</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过 -v 容器内路径： ro rw 改变读写权限</span>
ro #readonly 只读
rw #readwrite 可读可写
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span>

<span class="hljs-meta">#</span><span class="bash"> ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</span></code></pre></div>

<h2 id="6-DockerFile"><a href="#6-DockerFile" class="headerlink" title="6 DockerFile"></a>6 DockerFile</h2><h3 id="6-1-初始Dockerfile"><a href="#6-1-初始Dockerfile" class="headerlink" title="6.1 初始Dockerfile"></a>6.1 初始Dockerfile</h3><p><strong>Dockerfile 就是用来构建docker镜像的构建文件</strong>！命令脚本！先体验一下！</p>
<p>通过这个<strong>脚本可以生成镜像</strong>，镜像是一层一层的，脚本是一个个的命令，每个命令都是一层！</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建一个dockerfile文件，名字可以随便 建议Dockerfile</span>
<span class="hljs-meta">#</span><span class="bash"> 文件中的内容： 指令(大写) + 参数</span>
<span class="hljs-meta">$</span><span class="bash"> vim dockerfile1</span>
    FROM centos 					# 当前这个镜像是以centos为基础的

    VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] 	# 挂载卷的卷目录列表(多个目录)

    CMD echo &quot;-----end-----&quot;		# 输出一下用于测试
    CMD /bin/bash					# 默认走bash控制台

<span class="hljs-meta">#</span><span class="bash"> 这里的每个命令，就是镜像的一层！</span>
<span class="hljs-meta">#</span><span class="bash"> 构建出这个镜像</span> 
-f dockerfile1 			# f代表file，指这个当前文件的地址(这里是当前目录下的dockerfile1)
-t caoshipeng/centos 	# t就代表target，指目标目录(注意caoshipeng镜像名前不能加斜杠‘/’)
. 						# 表示生成在当前目录下
<span class="hljs-meta">$</span><span class="bash"> docker build -f dockerfile1 -t caoshipeng/centos .</span>
Sending build context to Docker daemon   2.56kB
Step 1/4 : FROM centos
latest: Pulling from library/centos
8a29a15cefae: Already exists 
Digest: sha256:fe8d824220415eed5477b63addf40fb06c3b049404242b31982106ac204f6700
Status: Downloaded newer image for centos:latest
<span class="hljs-meta"> ---&gt;</span><span class="bash"> 470671670cac</span>
Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] 			# 卷名列表
<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> c18eefc2c233</span>
Removing intermediate container c18eefc2c233
<span class="hljs-meta"> ---&gt;</span><span class="bash"> 623ae1d40fb8</span>
Step 3/4 : CMD echo &quot;-----end-----&quot;					# 输出 脚本命令
<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 70e403669f3c</span>
Removing intermediate container 70e403669f3c
<span class="hljs-meta"> ---&gt;</span><span class="bash"> 0eba1989c4e6</span>
Step 4/4 : CMD /bin/bash
<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 4342feb3a05b</span>
Removing intermediate container 4342feb3a05b
<span class="hljs-meta"> ---&gt;</span><span class="bash"> f4a6b0d4d948</span>
Successfully built f4a6b0d4d948
Successfully tagged caoshipeng/centos:latest

<span class="hljs-meta">#</span><span class="bash"> 查看自己构建的镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker images</span>
REPOSITORY          TAG          IMAGE ID            CREATED              SIZE
caoshipeng/centos   latest       f4a6b0d4d948        About a minute ago   237MB</code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203148651.png" alt></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203222615.png" alt></p>
<p><strong>启动自己写的容器镜像</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -it f4a6b0d4d948 /bin/bash	<span class="hljs-comment"># 运行自己写的镜像</span></span>
<span class="hljs-meta">$</span><span class="bash"> ls -l 								<span class="hljs-comment"># 查看目录</span></span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTQ1OTAyNi5wbmc" alt></p>
<p>这个卷和外部一定有一个同步的目录</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTUzMTYyNi5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker inspect 容器id</span>
<span class="hljs-meta">$</span><span class="bash"> docker inspect ca3b45913df5</span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTYzMDI5NS5wbmc" alt></p>
<p>测试一下刚才的文件是否同步出去了！</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603203814945.png" alt></p>
<p>这种方式使用的十分多，因为我们通常会构建自己的镜像！</p>
<p>假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名：容器内路径！</p>
<h3 id="6-2-数据卷容器"><a href="#6-2-数据卷容器" class="headerlink" title="6.2 数据卷容器"></a>6.2 数据卷容器</h3><h4 id="1-多个MySQL同步数据"><a href="#1-多个MySQL同步数据" class="headerlink" title="1 多个MySQL同步数据"></a>1 多个MySQL同步数据</h4><p>命名的容器挂载数据卷！</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154518325.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># 测试 启动3个容器，通过刚才自己写的镜像启动</span>
<span class="hljs-comment"># 创建docker01：因为我本机是最新版，故这里用latest，狂神老师用的是1.0如下图</span>
$ docker run -it --name docker01 pnca/centos:latest

<span class="hljs-comment"># 查看容器docekr01内容</span>
$ ls
bin  home   lost+found	opt   run   sys  var
dev  lib    media	<span class="hljs-keyword">proc</span><span class="hljs-title">  sbin</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> volume01</span>
<span class="hljs-title">etc</span> <span class="hljs-title"> lib64</span> <span class="hljs-title"> mnt</span>	<span class="hljs-title">	root</span> <span class="hljs-title"> srv</span> <span class="hljs-title">  usr</span> <span class="hljs-title"> volume02</span>
<span class="hljs-title"></span>
<span class="hljs-title">#</span> 不关闭该容器退出
CTRL +<span class="hljs-title"> Q</span> +<span class="hljs-title"> P</span>  

# 创建docker02: 并且让docker02 继承<span class="hljs-title"> docker01</span>
<span class="hljs-title">$</span> docker<span class="hljs-title"> run</span> -it --name<span class="hljs-title"> docker02</span> --volumes-from<span class="hljs-title"> docker01</span> pnca/centos:latest

# 查看容器docker02内容
$<span class="hljs-title"> ls</span>
<span class="hljs-title">bin</span> <span class="hljs-title"> home</span> <span class="hljs-title">  lost+found</span>	opt<span class="hljs-title">   run</span> <span class="hljs-title">  sys</span> <span class="hljs-title"> var</span>
<span class="hljs-title">dev</span> <span class="hljs-title"> lib</span> <span class="hljs-title">   media</span>	<span class="hljs-keyword">proc</span><span class="hljs-title">  sbin</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> volume01</span>
<span class="hljs-title">etc</span> <span class="hljs-title"> lib64</span> <span class="hljs-title"> mnt</span>	<span class="hljs-title">	root</span> <span class="hljs-title"> srv</span> <span class="hljs-title">  usr</span> <span class="hljs-title"> volume02</span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMzAyMDA1MC5wbmc" alt></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154539606.png" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 再新建一个docker03同样继承docker01</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -it --name docker03 --volumes-from docker01 caoshipeng/centos:latest</span>
<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> volume01	<span class="hljs-comment">#进入volume01 查看是否也同步docker01的数据</span></span>
<span class="hljs-meta">$</span><span class="bash"> ls</span> 
docker01.txt

<span class="hljs-meta">#</span><span class="bash"> 测试：可以删除docker01，查看一下docker02和docker03是否可以访问这个文件</span>
<span class="hljs-meta">#</span><span class="bash"> 测试发现：数据依旧保留在docker02和docker03中没有被删除</span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMzM1NTAzNC5wbmc" alt></p>
<h4 id="2-多个mysql实现数据共享"><a href="#2-多个mysql实现数据共享" class="headerlink" title="2 多个mysql实现数据共享"></a>2 多个mysql实现数据共享</h4><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span>

<span class="hljs-meta">$</span><span class="bash"> docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01  mysql:5.7</span>

<span class="hljs-meta">#</span><span class="bash"> 这个时候，可以实现两个容器数据同步！</span></code></pre></div>

<p>结论：</p>
<p><strong>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止</strong>。</p>
<p><strong>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的</strong>！</p>
<h3 id="6-3-DockerFile-具体使用"><a href="#6-3-DockerFile-具体使用" class="headerlink" title="6.3 DockerFile 具体使用"></a>6.3 DockerFile 具体使用</h3><h4 id="1-DockerFile介绍"><a href="#1-DockerFile介绍" class="headerlink" title="1 DockerFile介绍"></a>1 DockerFile介绍</h4><p>dockerfile是用来构建docker镜像的文件！命令参数脚本！</p>
<p>构建步骤：</p>
<ol>
<li>编写一个dockerfile文件</li>
<li>docker build 构建称为一个镜像</li>
<li>docker run运行镜像</li>
<li>docker push发布镜像（DockerHub 、阿里云仓库)</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205738956.png" alt></p>
<p>点击后跳到一个Dockerfile</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205655544.png" alt></p>
<p>很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！</p>
<p>官方既然可以制作镜像，那我们也可以！</p>
<h4 id="2-DockerFile-构建过程"><a href="#2-DockerFile-构建过程" class="headerlink" title="2 DockerFile 构建过程"></a>2 DockerFile 构建过程</h4><p><strong>基础知识</strong>：</p>
<ol>
<li>每个保留关键字(指令）都是必须是大写字母</li>
<li>执行从上到下顺序</li>
<li>#表示注释</li>
<li>每一个指令都会创建提交一个新的镜像层，并提交！</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEzMTc1Njk5Ny5wbmc" alt></p>
<ul>
<li>Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</li>
</ul>
<ul>
<li>Docker镜像逐渐成企业交付的标准，必须要掌握！</li>
</ul>
<ul>
<li>DockerFile：构建文件，定义了一切的步骤，源代码</li>
</ul>
<ul>
<li>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。</li>
</ul>
<ul>
<li>Docker容器：容器就是镜像运行起来提供服务。</li>
</ul>
<h4 id="3-DockerFile的指令"><a href="#3-DockerFile的指令" class="headerlink" title="3 DockerFile的指令"></a>3 DockerFile的指令</h4><div class="code-wrapper"><pre><code class="hljs shell">FROM				# from:基础镜像，一切从这里开始构建
MAINTAINER			# maintainer:镜像是谁写的， 姓名+邮箱
RUN					# run:镜像构建的时候需要运行的命令
ADD					# add:步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录
WORKDIR				# workdir:镜像的工作目录
VOLUME				# volume:挂载的目录
EXPOSE				# expose:保留端口配置
CMD					# cmd:指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代
ENTRYPOINT			# entrypoint:指定这个容器启动的时候要运行的命令，可以追加命令
ONBUILD				# onbuild:当构建一个被继承DockerFile这个时候就会运行onbuild的指令，触发指令
COPY				# copy:类似ADD，将我们文件拷贝到镜像中
ENV					# env:构建的时候设置环境变量！</code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20200524154609624.png" alt></p>
<h4 id="4-实战测试"><a href="#4-实战测试" class="headerlink" title="4 实战测试"></a>4 实战测试</h4><p>scratch镜像</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> scratch
<span class="hljs-keyword">ADD</span><span class="bash"> centos-7-x86_64-docker.tar.xz /</span>

<span class="hljs-keyword">LABEL</span><span class="bash"> \</span>
<span class="bash">    org.label-schema.schema-version=<span class="hljs-string">&quot;1.0&quot;</span> \</span>
<span class="bash">    org.label-schema.name=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \</span>
<span class="bash">    org.label-schema.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \</span>
<span class="bash">    org.label-schema.license=<span class="hljs-string">&quot;GPLv2&quot;</span> \</span>
<span class="bash">    org.label-schema.build-date=<span class="hljs-string">&quot;20201113&quot;</span> \</span>
<span class="bash">    org.opencontainers.image.title=<span class="hljs-string">&quot;CentOS Base Image&quot;</span> \</span>
<span class="bash">    org.opencontainers.image.vendor=<span class="hljs-string">&quot;CentOS&quot;</span> \</span>
<span class="bash">    org.opencontainers.image.licenses=<span class="hljs-string">&quot;GPL-2.0-only&quot;</span> \</span>
<span class="bash">    org.opencontainers.image.created=<span class="hljs-string">&quot;2020-11-13 00:00:00+00:00&quot;</span></span>

<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>]</span></code></pre></div>

<p><strong>Docker Hub 中 99%的镜像都是从这个基础镜像过来的 FROM scratch</strong>，然后配置需要的软件和配置来进行构建。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/image-20210603205655544.png" alt></p>
<p>创建一个自己的centos</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1./home下新建dockerfile目录</span>
<span class="hljs-meta">$</span><span class="bash"> mkdir dockerfile</span>

<span class="hljs-meta">#</span><span class="bash"> 2. dockerfile目录下新建mydockerfile-centos文件</span>
<span class="hljs-meta">$</span><span class="bash"> vim mydockerfile-centos</span>

<span class="hljs-meta">#</span><span class="bash"> 3.编写Dockerfile配置文件</span>
FROM centos							# 基础镜像是官方原生的centos
MAINTAINER pncalbl&lt;pncalbl@qq.com&gt; 	# 作者

ENV MYPATH /usr/local				# 配置环境变量的目录 
WORKDIR $MYPATH						# 将工作目录设置为 MYPATH

RUN yum -y install vim				# 给官方原生的centos 增加 vim指令
RUN yum -y install net-tools		# 给官方原生的centos 增加 ifconfig命令

EXPOSE 80							# 暴露端口号为80

CMD echo $MYPATH					# 输出下 MYPATH 路径
CMD echo &quot;-----end----&quot;				
CMD /bin/bash						# 启动后进入 /bin/bash

<span class="hljs-meta">#</span><span class="bash"> 4.通过这个文件构建镜像</span>
<span class="hljs-meta">#</span><span class="bash"> 命令： docker build -f 文件路径 -t 镜像名:[tag] .</span>
<span class="hljs-meta">$</span><span class="bash"> docker build -f mydockerfile-centos -t mycentos:0.1 .</span>

<span class="hljs-meta">#</span><span class="bash"> 5.出现下图后则构建成功</span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MDgzMTQ2NC5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker images</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mycentos            0.1                 cbf5110a646d        2 minutes ago       311MB

<span class="hljs-meta">#</span><span class="bash"> 6.测试运行</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -it mycentos:0.1 		<span class="hljs-comment"># 注意带上版本号，否则每次都回去找最新版latest</span></span>

<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">pwd</span></span>	
/usr/local							# 与Dockerfile文件中 WORKDIR 设置的 MYPATH 一致
<span class="hljs-meta">$</span><span class="bash"> vim								<span class="hljs-comment"># vim 指令可以使用</span></span>
<span class="hljs-meta">$</span><span class="bash"> ifconfig     						<span class="hljs-comment"># ifconfig 指令可以使用</span></span>

<span class="hljs-meta">#</span><span class="bash"> docker <span class="hljs-built_in">history</span> 镜像id 查看镜像构建历史步骤</span>
<span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">history</span> 镜像id</span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MTYyOTU4My5wbmc" alt></p>
<p>我们可以列出本地进行的变更历史</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE0MTg0MDcwNi5wbmc" alt></p>
<p>我们平时拿到一个镜像，可以用 “docker history 镜像id” 研究一下是什么做的</p>
<h4 id="5-CMD-和-ENTRYPOINT区别"><a href="#5-CMD-和-ENTRYPOINT区别" class="headerlink" title="5 CMD 和 ENTRYPOINT区别"></a>5 CMD 和 ENTRYPOINT区别</h4><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="bash">					<span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span></span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="bash">			<span class="hljs-comment"># 指定这个容器启动的时候要运行的命令，可以追加命令</span></span></code></pre></div>

<p><strong>测试cmd</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编写dockerfile文件</span>
<span class="hljs-meta">$</span><span class="bash"> vim dockerfile-test-cmd</span>
FROM centos
CMD [&quot;ls&quot;,&quot;-a&quot;]					# 启动后执行 ls -a 命令

<span class="hljs-meta">#</span><span class="bash"> 构建镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker build  -f dockerfile-test-cmd -t cmd-test:0.1 .</span>

<span class="hljs-meta">#</span><span class="bash"> 运行镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker run cmd-test:0.1		<span class="hljs-comment"># 由结果可得，运行后就执行了 ls -a 命令</span></span>
.
..
.dockerenv
bin
dev
etc
home

<span class="hljs-meta">#</span><span class="bash"> 想追加一个命令  -l 成为ls -dockersal：展示列表详细数据</span>
<span class="hljs-meta">$</span><span class="bash"> docker run cmd-tesclet:0.1 -l</span>
docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused &quot;exec: \&quot;-l\&quot;:
executable file not found in $PATH&quot;: unknown.
ERRO[0000] error waiting for container: context canceled 

<span class="hljs-meta">#</span><span class="bash"> cmd的情况下 -l 替换了CMD[<span class="hljs-string">&quot;ls&quot;</span>,<span class="hljs-string">&quot;-l&quot;</span>] 而 -l  不是命令所以报错</span></code></pre></div>

<p><strong>测试ENTRYPOINT</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编写dockerfile文件</span>
<span class="hljs-meta">$</span><span class="bash"> vim dockerfile-test-entrypoint</span>
FROM centos
ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]

<span class="hljs-meta">#</span><span class="bash"> 构建镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker build  -f dockerfile-test-entrypoint -t entrypoint-test:0.1 .</span>

<span class="hljs-meta">#</span><span class="bash"> 运行镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker run entrypoint-test:0.1</span>
.
..
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found ...

<span class="hljs-meta">#</span><span class="bash"> 我们的命令，是直接拼接在我们得ENTRYPOINT命令后面的</span>
<span class="hljs-meta">$</span><span class="bash"> docker run entrypoint-test:0.1 -l</span>
total 56clea
drwxr-xr-x   1 root root 4096 May 16 06:32 .
drwxr-xr-x   1 root root 4096 May 16 06:32 ..
-rwxr-xr-x   1 root root    0 May 16 06:32 .dockerenv
lrwxrwxrwx   1 root root    7 May 11  2019 bin -&gt; usr/bin
drwxr-xr-x   5 root root  340 May 16 06:32 dev
drwxr-xr-x   1 root root 4096 May 16 06:32 etc
drwxr-xr-x   2 root root 4096 May 11  2019 home
lrwxrwxrwx   1 root root    7 May 11  2019 lib -&gt; usr/lib
lrwxrwxrwx   1 root root    9 May 11  2019 lib64 -&gt; usr/lib64 ....</code></pre></div>

<p>Dockerfile中很多命令都十分的相似，我们需要了解它们的区别，我们最好的学习就是对比他们然后测试效果！</p>
<h4 id="6-实战：Tomcat镜像"><a href="#6-实战：Tomcat镜像" class="headerlink" title="6 实战：Tomcat镜像"></a>6 实战：Tomcat镜像</h4><h5 id="6-1-准备镜像文件"><a href="#6-1-准备镜像文件" class="headerlink" title="6.1 准备镜像文件"></a>6.1 准备镜像文件</h5><div class="code-wrapper"><pre><code class="hljs mipsasm">准备tomcat 和 <span class="hljs-keyword">jdk </span>到当前目录，编写好README</code></pre></div>

<h5 id="6-2-编写-dokerfile"><a href="#6-2-编写-dokerfile" class="headerlink" title="6.2 编写 dokerfile"></a>6.2 编写 dokerfile</h5><div class="code-wrapper"><pre><code class="hljs dockerfile">$ vim dockerfile
<span class="hljs-keyword">FROM</span> centos 										<span class="hljs-comment"># 基础镜像centos</span>
<span class="hljs-keyword">MAINTAINER</span> pncalbl&lt;pncalbl@qq.com&gt;					<span class="hljs-comment"># 作者</span>
<span class="hljs-keyword">COPY</span><span class="bash"> README /usr/<span class="hljs-built_in">local</span>/README 						<span class="hljs-comment"># 复制README文件</span></span>
<span class="hljs-keyword">ADD</span><span class="bash"> jdk-8u231-linux-x64.tar.gz /usr/<span class="hljs-built_in">local</span>/ 			<span class="hljs-comment"># 添加jdk，ADD 命令会自动解压</span></span>
<span class="hljs-keyword">ADD</span><span class="bash"> apache-tomcat-9.0.35.tar.gz /usr/<span class="hljs-built_in">local</span>/ 		<span class="hljs-comment"># 添加tomcat，ADD 命令会自动解压</span></span>
<span class="hljs-keyword">RUN</span><span class="bash"> yum -y install vim								<span class="hljs-comment"># 安装 vim 命令</span></span>
<span class="hljs-keyword">ENV</span> MYPATH /usr/local 								<span class="hljs-comment"># 环境变量设置 工作目录</span>
<span class="hljs-keyword">WORKDIR</span><span class="bash"> <span class="hljs-variable">$MYPATH</span></span>

<span class="hljs-keyword">ENV</span> JAVA_HOME /usr/local/jdk1.<span class="hljs-number">8.0</span>_231 				<span class="hljs-comment"># 环境变量： JAVA_HOME环境变量</span>
<span class="hljs-keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar

<span class="hljs-keyword">ENV</span> CATALINA_HOME /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">35</span> 	<span class="hljs-comment"># 环境变量： tomcat环境变量</span>
<span class="hljs-keyword">ENV</span> CATALINA_BASH /usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">35</span>

<span class="hljs-comment"># 设置环境变量 分隔符是：</span>
<span class="hljs-keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin 	

<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span> 										<span class="hljs-comment"># 设置暴露的端口</span>

<span class="hljs-keyword">CMD</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/<span class="hljs-built_in">local</span>/apache-tomcat-9.0.35/logs/catalina.out 					<span class="hljs-comment"># 设置默认命令</span></span></code></pre></div>

<h5 id="6-3-构建镜像"><a href="#6-3-构建镜像" class="headerlink" title="6.3 构建镜像"></a>6.3 构建镜像</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 因为dockerfile命名使用默认命名 因此不用使用-f 指定文件</span>
<span class="hljs-meta">$</span><span class="bash"> docker build -t mytomcat:0.1 .</span></code></pre></div>

<h5 id="6-4-run镜像"><a href="#6-4-run镜像" class="headerlink" title="6.4 run镜像"></a>6.4 run镜像</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> -d:后台运行 -p:暴露端口 --name:别名 -v:绑定路径</span> 
<span class="hljs-meta">$</span><span class="bash"> docker run -d -p 8080:8080 --name tomcat01</span> 
-v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test 
-v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.35/logs</code></pre></div>

<h5 id="6-5-访问测试"><a href="#6-5-访问测试" class="headerlink" title="6.5 访问测试"></a>6.5 访问测试</h5><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it 自定义容器的id /bin/bash</span>

<span class="hljs-meta">$</span><span class="bash"> cul localhost:8080</span></code></pre></div>

<h5 id="6-6-发布项目"><a href="#6-6-发布项目" class="headerlink" title="6.6 发布项目"></a>6.6 发布项目</h5><p>(由于做了卷挂载，我们直接在本地编写项目就可以发布了！)</p>
<p>发现：项目部署成功，可以直接访问！</p>
<p>我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！</p>
<h4 id="7-发布自己的镜像"><a href="#7-发布自己的镜像" class="headerlink" title="7 发布自己的镜像"></a>7 发布自己的镜像</h4><p><strong>发布到 Docker Hub</strong></p>
<ol>
<li><p>地址 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
</li>
<li><p>确定这个账号可以登录</p>
</li>
<li><p>登录</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker login --<span class="hljs-built_in">help</span></span>
Usage:  docker login [OPTIONS] [SERVER]

Log in to a Docker registry.
If no server is specified, the default is defined by the daemon.

Options:
  -p, --password string   Password
      --password-stdin    Take the password from stdin
  -u, --username string   Username

<span class="hljs-meta">$</span><span class="bash"> docker login -u 你的用户名 -p 你的密码</span></code></pre></div>
</li>
<li><p>提交 push镜像</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE2NDQzNDA0Mi5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 会发现push不上去，因为如果没有前缀的话默认是push到 官方的library</span>
<span class="hljs-meta">#</span><span class="bash"> 解决方法：</span>
<span class="hljs-meta">#</span><span class="bash"> 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了</span>
<span class="hljs-meta">$</span><span class="bash"> docker build -t kuangshen/mytomcat:0.1 .</span>

<span class="hljs-meta">#</span><span class="bash"> 第二种 使用docker tag <span class="hljs-comment">#然后再次push</span></span>
<span class="hljs-meta">$</span><span class="bash"> docker tag jid kuangshen/mytomcat:1.0 <span class="hljs-comment">#然后再次push</span></span>
<span class="hljs-meta">$</span><span class="bash"> docker push kuangshen/mytomcat:1.0</span></code></pre></div>

<p><strong>发布到 阿里云镜像服务上</strong></p>
<p>看官网 很详细<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/repository/">https://cr.console.aliyun.com/repository/</a></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo docker login --username=zchengx registry.cn-shenzhen.aliyuncs.com</span>
<span class="hljs-meta">$</span><span class="bash"> sudo docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像版本号]</span>

<span class="hljs-meta">#</span><span class="bash"> 修改id 和 版本</span>
sudo docker tag a5ef1f32aaae registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:1.0
<span class="hljs-meta">#</span><span class="bash"> 修改版本</span>
<span class="hljs-meta">$</span><span class="bash"> sudo docker push registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像版本号]</span></code></pre></div>

</li>
</ol>
<h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8 小结"></a>8 小结</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MTE1NTY2Ny5wbmc" alt></p>
<h2 id="7-Docker-网络原理"><a href="#7-Docker-网络原理" class="headerlink" title="7 Docker 网络原理"></a>7 Docker 网络原理</h2><h3 id="7-1-理解Docker-0"><a href="#7-1-理解Docker-0" class="headerlink" title="7.1 理解Docker 0"></a>7.1 理解Docker 0</h3><p>学习之前<strong>清空下前面的docker 镜像、容器</strong></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除全部容器</span>
<span class="hljs-meta">$</span><span class="bash"> docker rm -f $(docker ps -aq)</span>

<span class="hljs-meta">#</span><span class="bash"> 删除全部镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker rmi -f $(docker images -aq)</span></code></pre></div>

<blockquote>
<p>  测试</p>
</blockquote>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTIyMzIzNjc3Mi5wbmc" alt></p>
<h4 id="1-三个网络"><a href="#1-三个网络" class="headerlink" title="1 三个网络"></a>1 三个网络</h4><blockquote>
<p>  问题： docker 是如果处理容器网络访问的？</p>
</blockquote>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MjA0MTk4NS5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试  运行一个tomcat</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span>

<span class="hljs-meta">#</span><span class="bash"> 查看容器内部网络地址</span>
<span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it 容器id ip addr</span>

<span class="hljs-meta">#</span><span class="bash"> 发现容器启动的时候会得到一个 eth0@if91 ip地址，docker分配！</span>
<span class="hljs-meta">$</span><span class="bash"> ip addr</span>
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
261: eth0@if91: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0
       valid_lft forever preferred_lft forever

       
<span class="hljs-meta">#</span><span class="bash"> 思考？ linux能不能ping通容器内部！ 可以 容器内部可以ping通外界吗？ 可以！</span>
<span class="hljs-meta">$</span><span class="bash"> ping 172.18.0.2</span>
PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.
64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.069 ms
64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.074 ms</code></pre></div>

<blockquote>
<p>  原理</p>
</blockquote>
<ol>
<li><p>我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个docker0桥接模式，使用的技术是veth-pair技术！</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bakari/p/10613710.html">https://www.cnblogs.com/bakari/p/10613710.html</a></p>
<p>再次测试 ip addr</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTIyNDAzNjg4My5wbmc" alt></p>
</li>
<li><p>再启动一个容器测试，发现又多了一对网络</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MzI1OTQ1OC5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 我们发现这个容器带来网卡，都是一对对的</span>
<span class="hljs-meta">#</span><span class="bash"> veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连</span>
<span class="hljs-meta">#</span><span class="bash"> 正因为有这个特性 veth-pair 充当一个桥梁，连接各种虚拟网络设备的</span>
<span class="hljs-meta">#</span><span class="bash"> OpenStac, Docker容器之间的连接，OVS的连接，都是使用evth-pair技术</span></code></pre></div>
</li>
<li><p>我们来测试下tomcat01和tomcat02是否可以ping通</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 获取tomcat01的ip 172.17.0.2</span>
<span class="hljs-meta">$</span><span class="bash"> docker-tomcat docker <span class="hljs-built_in">exec</span> -it tomcat01 ip addr</span>  
550: eth0@if551: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
       
<span class="hljs-meta">#</span><span class="bash"> 让tomcat02 ping tomcat01</span>       
<span class="hljs-meta">$</span><span class="bash"> docker-tomcat docker <span class="hljs-built_in">exec</span> -it tomcat02 ping 172.17.0.2</span>
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.098 ms
64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.071 ms

<span class="hljs-meta">#</span><span class="bash"> 结论：容器和容器之间是可以互相ping通</span></code></pre></div>

</li>
</ol>
<h4 id="2-网络模型图"><a href="#2-网络模型图" class="headerlink" title="2 网络模型图"></a>2 网络模型图</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NDI0ODYyNi5wbmc" alt></p>
<p>结论：tomcat01和tomcat02公用一个路由器，docker0。</p>
<p>所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip。</p>
<blockquote>
<p>  小结</p>
</blockquote>
<p>Docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥 docker0</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NDcwMTA2My5wbmc" alt></p>
<p>Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件）</p>
<p>只要容器删除，对应的网桥一对就没了！</p>
<p><strong>思考一个场景：我们编写了一个微服务，database url=ip: 项目不重启，数据ip换了，我们希望可以处理这个问题，可以通过名字来进行访问容器</strong>？</p>
<h3 id="7-2-容器互联-–link"><a href="#7-2-容器互联-–link" class="headerlink" title="7.2  容器互联 –link"></a>7.2  容器互联 –link</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it tomcat02 ping tomca01   <span class="hljs-comment"># ping不通</span></span>
ping: tomca01: Name or service not known

<span class="hljs-meta">#</span><span class="bash"> 运行一个tomcat03 --link tomcat02</span> 
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat03 --link tomcat02 tomcat</span>
5f9331566980a9e92bc54681caaac14e9fc993f14ad13d98534026c08c0a9aef

<span class="hljs-meta">#</span><span class="bash"> 3连接2</span>
<span class="hljs-meta">#</span><span class="bash"> 用tomcat03 ping tomcat02 可以ping通</span>
<span class="hljs-meta">$</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it tomcat03 ping tomcat02</span>
PING tomcat02 (172.17.0.3) 56(84) bytes of data.
64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.115 ms
64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.080 ms

<span class="hljs-meta">#</span><span class="bash"> 2连接3</span>
<span class="hljs-meta">#</span><span class="bash"> 用tomcat02 ping tomcat03 ping不通</span></code></pre></div>

<p><strong>探究：</strong></p>
<p>docker network inspect 网络id 网段相同</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3NTkwNDU1MS5wbmc" alt></p>
<p>docker inspect tomcat03</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE4MDMwODUzMC5wbmc" alt></p>
<p>查看tomcat03里面的/etc/hosts发现有tomcat02的配置</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE4MDYyOTAxMi5wbmc" alt></p>
<p>–link 本质就是在hosts配置中添加映射</p>
<p>现在使用Docker已经不建议使用–link了！</p>
<p>自定义网络，不适用docker0！</p>
<p>docker0问题：不支持容器名连接访问！</p>
<h3 id="7-3-自定义网络"><a href="#7-3-自定义网络" class="headerlink" title="7.3 自定义网络"></a>7.3 自定义网络</h3><div class="code-wrapper"><pre><code class="hljs shell">docker network
connect     -- Connect a container to a network
create      -- Creates a new network with a name specified by the
disconnect  -- Disconnects a container from a network
inspect     -- Displays detailed information on a network
ls          -- Lists all the networks created by the user
prune       -- Remove all unused networks
rm          -- Deletes one or more networks</code></pre></div>

<blockquote>
<p>  查看所有的docker网络</p>
</blockquote>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MDMxNjA3My5wbmc" alt></p>
<p><strong>网络模式</strong></p>
<p>bridge ：桥接 docker（默认，自己创建也是用bridge模式）</p>
<p>none ：不配置网络，一般不用</p>
<p>host ：和所主机共享网络</p>
<p>container ：容器网络连通（用得少！局限很大）</p>
<p>测试</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 我们直接启动的命令 --net bridge,而这个就是我们得docker0</span>
<span class="hljs-meta">#</span><span class="bash"> bridge就是docker0</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span>
等价于 =&gt; docker run -d -P --name tomcat01 --net bridge tomcat

<span class="hljs-meta">#</span><span class="bash"> docker0，特点：默认，域名不能访问。 --link可以打通连接，但是很麻烦！</span>
<span class="hljs-meta">#</span><span class="bash"> 我们可以 自定义一个网络</span>
<span class="hljs-meta">$</span><span class="bash"> docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTEzOTk0NC5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker network inspect mynet</span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTQwNzA2NS5wbmc" alt></p>
<p>启动两个tomcat,再次查看网络情况</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTg0NDI0MC5wbmc" alt></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MjAwNzM3MS5wbmc" alt></p>
<p>在自定义的网络下，服务可以互相ping通，不用使用 –link</p>
<p>我们自定义的网络docker当我们维护好了对应的关系，推荐我们平时这样使用网络！</p>
<p>好处：</p>
<ul>
<li><p>redis -不同的集群使用不同的网络，保证集群是安全和健康的</p>
</li>
<li><p>mysql-不同的集群使用不同的网络，保证集群是安全和健康的</p>
</li>
</ul>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MjUwNDM2Ny5wbmc" alt></p>
<h3 id="7-4-网络连通"><a href="#7-4-网络连通" class="headerlink" title="7.4 网络连通"></a>7.4 网络连通</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzI0MzE0Ni5wbmc" alt></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzI1OTE4NS5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 测试两个不同的网络连通  再启动两个tomcat 使用默认网络，即docker0</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat01 tomcat</span>
<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name tomcat02 tomcat</span>
<span class="hljs-meta">#</span><span class="bash"> 此时ping不通</span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzU1NDkzMS5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 要将tomcat01 连通 tomcat—net-01 ，连通就是将 tomcat01加到 mynet网络</span>
<span class="hljs-meta">#</span><span class="bash"> 一个容器两个ip（tomcat01）</span></code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5Mzg0ODMzNy5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 01连通 ，加入后此时，已经可以tomcat01 和 tomcat-01-net ping通了</span>
<span class="hljs-meta">#</span><span class="bash"> 02是依旧不通的</span></code></pre></div>

<p>结论：假设要跨网络操作别人，就需要使用docker network connect 连通！</p>
<h2 id="8-实战：部署Redis集群"><a href="#8-实战：部署Redis集群" class="headerlink" title="8 实战：部署Redis集群"></a>8 实战：部署Redis集群</h2><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5NDQxOTQ3MS5wbmc" alt></p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建网卡</span>
docker network create redis --subnet 172.38.0.0/16
<span class="hljs-meta">#</span><span class="bash"> 通过脚本创建六个redis配置</span>
for port in $(seq 1 6);\
do \
mkdir -p /mydata/redis/node-$&#123;port&#125;/conf
touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf
cat &lt;&lt; EOF &gt;&gt; /mydata/redis/node-$&#123;port&#125;/conf/redis.conf
port 6379
bind 0.0.0.0
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.38.0.1$&#123;port&#125;
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes
EOF
done

<span class="hljs-meta">#</span><span class="bash"> 通过脚本运行六个redis</span>
for port in $(seq 1 6);\
docker run -p 637$&#123;port&#125;:6379 -p 1667$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \
-v /mydata/redis/node-$&#123;port&#125;/data:/data \
-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf

<span class="hljs-meta">#</span><span class="bash"> 单个启动</span>
docker run -p 6376:6379 -p 16376:16379 --name redis-6 \
    -v /mydata/redis/node-6/data:/data \
    -v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \
    -d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
    
<span class="hljs-meta">#</span><span class="bash"> 配置集群</span>
docker exec -it redis-1 /bin/sh #redis默认没有bash
redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379  --cluster-replicas 1
</code></pre></div>

<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjIwMjkwMjI0MS5wbmc" alt></p>
<p>docker搭建redis集群完成！</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjIwMzMyMzk3MS5wbmc" alt></p>
<p>我们使用docker之后，所有的技术都会慢慢变得简单起来！</p>
<h2 id="9-IDEA整合Docker"><a href="#9-IDEA整合Docker" class="headerlink" title="9 IDEA整合Docker"></a>9 IDEA整合Docker</h2><ol>
<li><p>构建SpringBoot项目</p>
</li>
<li><p>打包运行</p>
<div class="code-wrapper"><pre><code class="hljs shell">mvn package</code></pre></div>
</li>
<li><p>编写dockerfile</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span>
<span class="hljs-keyword">COPY</span><span class="bash"> *.jar /app.jar</span>
<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;--server.port=8080&quot;</span>]</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;app.jar&quot;</span>]</span></code></pre></div>
</li>
<li><p>构建镜像</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.复制jar和DockerFIle到服务器</span>
<span class="hljs-meta">#</span><span class="bash"> 2.构建镜像</span>
<span class="hljs-meta">$</span><span class="bash"> docker build -t xxxxx:xx  .</span></code></pre></div>
</li>
<li><p>发布运行</p>
<p>以后我们使用了Docker之后，给别人交付就是一个镜像即可！</p>
</li>
</ol>
<h2 id="10-Docker-compose"><a href="#10-Docker-compose" class="headerlink" title="10 Docker compose"></a>10 Docker compose</h2><h3 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173610891.png" alt></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173621230.png" alt></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/2020120517363870.png" alt></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173652461.png" alt></p>
<h3 id="10-2-安装"><a href="#10-2-安装" class="headerlink" title="10.2 安装"></a>10.2 安装</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201205173738412.png" alt></p>
<ul>
<li><p>下载</p>
<div class="code-wrapper"><pre><code class="hljs shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></pre></div>
</li>
<li><p>授权</p>
<div class="code-wrapper"><pre><code class="hljs shell">sudo chmod +x /usr/local/bin/docker-compose</code></pre></div>
</li>
<li><p>查看版本</p>
<div class="code-wrapper"><pre><code class="hljs shell">docker-compose version</code></pre></div>

</li>
</ul>
<h3 id="10-3-体验"><a href="#10-3-体验" class="headerlink" title="10.3 体验"></a>10.3 体验</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/gettingstarted/">https://docs.docker.com/compose/gettingstarted/</a></p>
<ol>
<li><p>创建文件夹 composetest</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir composetest</span>
<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> composetest</span></code></pre></div>
</li>
<li><p>创建 app.py</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim app.py</span>

import time

import redis
from flask import Flask

app = Flask(__name__)
cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)

def get_hit_count():
    retries = 5
    while True:
        try:
            return cache.incr(&#x27;hits&#x27;)
        except redis.exceptions.ConnectionError as exc:
            if retries == 0:
                raise exc
            retries -= 1
            time.sleep(0.5)

@app.route(&#x27;/&#x27;)
def hello():
    count = get_hit_count()
    return &#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;.format(count)</code></pre></div>
</li>
<li><p>创建 requirements.txt</p>
<div class="code-wrapper"><pre><code class="hljs txt">$ vim requirements.txt

flask
redis</code></pre></div>
</li>
<li><p>创建 Dockerfile</p>
<div class="code-wrapper"><pre><code class="hljs dockerfile">$ vim Dockerfile

<span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>-alpine
<span class="hljs-keyword">RUN</span><span class="bash"> sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories </span>
<span class="hljs-keyword">WORKDIR</span><span class="bash"> /code</span>
<span class="hljs-keyword">ENV</span> FLASK_APP=app.py
<span class="hljs-keyword">ENV</span> FLASK_RUN_HOST=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>
<span class="hljs-keyword">RUN</span><span class="bash"> apk add --no-cache gcc musl-dev linux-headers</span>
<span class="hljs-keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span>
<span class="hljs-keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span>
<span class="hljs-keyword">COPY</span><span class="bash"> . .</span>
<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;flask&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span></code></pre></div>
</li>
<li><p>创建 docker-compose.yml</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim docker-compose.yml</span>

version: &quot;3.8&quot;
services:
  web:
    build: .
    ports:
      - &quot;5000:5000&quot;
  redis:
    image: &quot;redis:alpine&quot;</code></pre></div>
</li>
<li><p>启动</p>
<div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker-compose build</span>
<span class="hljs-meta">$</span><span class="bash"> docker-compose up</span></code></pre></div>
</li>
<li><p>停止</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161110869.png" alt></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161121213.png" alt></p>
</li>
<li><p>小结</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/01/Docker%E5%AD%A6%E4%B9%A0/20201206161135882.png" alt></p>
</li>
</ol>
<h3 id="10-4-yaml-规则"><a href="#10-4-yaml-规则" class="headerlink" title="10.4 yaml 规则"></a>10.4 yaml 规则</h3><p><strong>docker-compose.yaml 核心！</strong><br>官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<h3 id="10-5-开源项目-博客"><a href="#10-5-开源项目-博客" class="headerlink" title="10.5 开源项目 - 博客"></a>10.5 开源项目 - 博客</h3><h2 id="11-Docker-Swarm"><a href="#11-Docker-Swarm" class="headerlink" title="11 Docker Swarm"></a>11 Docker Swarm</h2><h3 id="11-1-什么是Docker-Swarm"><a href="#11-1-什么是Docker-Swarm" class="headerlink" title="11.1 什么是Docker Swarm"></a>11.1 什么是Docker Swarm</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181018165124850-1417419249.png" alt="img"></p>
<ul>
<li><p>Swarm是Docker公司推出的用来管理docker集群的平台，几乎全部用GO语言来完成的开发的，代码开源在<a target="_blank" rel="noopener" href="https://github.com/docker/swarm，">https://github.com/docker/swarm，</a> 它是将一群Docker宿主机变成一个单一的虚拟主机，Swarm使用标准的Docker API接口作为其前端的访问入口，换言之，各种形式的Docker</p>
</li>
<li><p>Client(compose,docker-py等)均可以直接与Swarm通信，甚至Docker本身都可以很容易的与Swarm集成，这大大方便了用户将原本基于单节点的系统移植到Swarm上，同时Swarm内置了对Docker网络插件的支持，用户也很容易的部署跨主机的容器集群服务。</p>
</li>
<li><p>Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。</p>
</li>
<li><p>从 Docker 1.12.0 版本开始，Docker Swarm 已经包含在 Docker 引擎中（docker swarm），并且已经内置了服务发现工具，我们就不需要像之前一样，再配置 Etcd 或者 Consul 来进行服务发现配置了。</p>
</li>
<li><p>Swarm deamon只是一个调度器(Scheduler)加路由器(router),Swarm自己不运行容器，它只是接受Docker客户端发来的请求，调度适合的节点来运行容器，这就意味着，即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，放Swarm重新恢复运行之后，他会收集重建集群信息。</p>
</li>
</ul>
<h3 id="11-2-Docker-Swarm-基本结构图"><a href="#11-2-Docker-Swarm-基本结构图" class="headerlink" title="11.2 Docker Swarm 基本结构图"></a>11.2 Docker Swarm 基本结构图</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181018163339198-1499005562.png" alt="img"></p>
<p>在结构图可以看出 Docker Client使用Swarm对 集群(Cluster)进行调度使用。</p>
<p>上图可以看出，Swarm是典型的master-slave结构，通过发现服务来选举manager。manager是中心管理节点，各个node上运行agent接受manager的统一管理，集群会自动通过Raft协议分布式选举出manager节点，无需额外的发现服务支持，避免了单点的瓶颈问题，同时也内置了DNS的负载均衡和对外部负载均衡机制的集成支持</p>
<h3 id="11-3-Swarm的几个关键概念"><a href="#11-3-Swarm的几个关键概念" class="headerlink" title="11.3 Swarm的几个关键概念"></a>11.3 Swarm的几个关键概念</h3><h4 id="1-Swarm"><a href="#1-Swarm" class="headerlink" title="1 Swarm"></a>1 Swarm</h4><p>集群的管理和编排是使用嵌入docker引擎的SwarmKit，可以在docker初始化时启动swarm模式或者加入已存在的swarm</p>
<h4 id="2-Node"><a href="#2-Node" class="headerlink" title="2 Node"></a>2 Node</h4><ul>
<li>一个节点是docker引擎集群的一个实例。您还可以将其视为Docker节点。您可以在单个物理计算机或云服务器上运行一个或多个节点，但生产群集部署通常包括分布在多个物理和云计算机上的Docker节点。</li>
<li>要将应用程序部署到swarm，请将服务定义提交给 管理器节点。管理器节点将称为任务的工作单元分派 给工作节点。</li>
<li>Manager节点还执行维护所需群集状态所需的编排和集群管理功能。Manager节点选择单个领导者来执行编排任务。</li>
<li>工作节点接收并执行从管理器节点分派的任务。默认情况下，管理器节点还将服务作为工作节点运行，但您可以将它们配置为仅运行管理器任务并且是仅管理器节点。代理程序在每个工作程序节点上运行，并报告分配给它的任务。工作节点向管理器节点通知其分配的任务的当前状态，以便管理器可以维持每个工作者的期望状态。</li>
</ul>
<h4 id="3-Service"><a href="#3-Service" class="headerlink" title="3 Service"></a>3 Service</h4><p>一个服务是任务的定义，管理机或工作节点上执行。它是群体系统的中心结构，是用户与群体交互的主要根源。创建服务时，你需要指定要使用的容器镜像。</p>
<h4 id="4-Task"><a href="#4-Task" class="headerlink" title="4 Task"></a>4 Task</h4><p>任务是在docekr容器中执行的命令，Manager节点根据指定数量的任务副本分配任务给worker节点</p>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>docker swarm：集群管理，子命令有init, join, leave, update。（docker swarm –help查看帮助）<br>docker service：服务创建，子命令有create, inspect, update, remove, tasks。（docker service–help查看帮助）<br>docker node：节点管理，子命令有accept, promote, demote, inspect, update, tasks, ls, rm。（docker node –help查看帮助）</p>
<p>node是加入到swarm集群中的一个docker引擎实体，可以在一台物理机上运行多个node，node分为：<br>manager nodes，也就是管理节点<br>worker nodes，也就是工作节点</p>
<ul>
<li>manager node管理节点：执行集群的管理功能，维护集群的状态，选举一个leader节点去执行调度任务。</li>
<li>worker node工作节点：接收和执行任务。参与容器集群负载调度，仅用于承载task。</li>
<li>service服务：一个服务是工作节点上执行任务的定义。创建一个服务，指定了容器所使用的镜像和容器运行的命令。<ul>
<li>service是运行在worker nodes上的task的描述，service的描述包括使用哪个docker 镜像，以及在使用该镜像的容器中执行什么命令。</li>
</ul>
</li>
<li>task任务：一个任务包含了一个容器及其运行的命令。task是service的执行实体，task启动docker容器并在容器中执行任务。</li>
</ul>
<h3 id="11-4-Swarm的工作模式"><a href="#11-4-Swarm的工作模式" class="headerlink" title="11.4 Swarm的工作模式"></a>11.4 Swarm的工作模式</h3><ol>
<li>Node</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220250190-271703054.png" alt="img"></p>
<ol start="2">
<li>Service</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220303428-146351236.png" alt="img"></p>
<ol start="3">
<li>任务与调度</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220312417-120406041.png" alt="img"></p>
<ol start="4">
<li>服务副本与全局服务</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://img2018.cnblogs.com/blog/1479220/201810/1479220-20181020220320789-1157117261.png" alt="img"></p>
<h3 id="11-5-Swarm的调度策略"><a href="#11-5-Swarm的调度策略" class="headerlink" title="11.5 Swarm的调度策略"></a>11.5 Swarm的调度策略</h3><p>Swarm在调度(scheduler)节点（leader节点）运行容器的时候，会根据指定的策略来计算最适合运行容器的节点，目前支持的策略有：spread, binpack, random.</p>
<ul>
<li><p>Random<br>顾名思义，就是随机选择一个Node来运行容器，一般用作调试用，spread和binpack策略会根据各个节点的可用的CPU, RAM以及正在运<br>行的容器的数量来计算应该运行容器的节点。</p>
</li>
<li><p>Spread<br>在同等条件下，Spread策略会选择运行容器最少的那台节点来运行新的容器，binpack策略会选择运行容器最集中的那台机器来运行新的节点。<br>使用Spread策略会使得容器会均衡的分布在集群中的各个节点上运行，一旦一个节点挂掉了只会损失少部分的容器。</p>
</li>
<li><p>Binpack<br>Binpack策略最大化的避免容器碎片化，就是说binpack策略尽可能的把还未使用的节点留给需要更大空间的容器运行，尽可能的把容器运行在<br>一个节点上面。</p>
</li>
</ul>
<h3 id="11-6-Swarm-Cluster模式特性"><a href="#11-6-Swarm-Cluster模式特性" class="headerlink" title="11.6 Swarm Cluster模式特性"></a>11.6 Swarm Cluster模式特性</h3><h4 id="1-批量创建服务"><a href="#1-批量创建服务" class="headerlink" title="1 批量创建服务"></a>1 批量创建服务</h4><p>建立容器之前先创建一个overlay的网络，用来保证在不同主机上的容器网络互通的网络模式</p>
<h4 id="2-强大的集群的容错性"><a href="#2-强大的集群的容错性" class="headerlink" title="2 强大的集群的容错性"></a>2 强大的集群的容错性</h4><p>当容器副本中的其中某一个或某几个节点宕机后，cluster会根据自己的服务注册发现机制，以及之前设定的值–replicas n，<br>在集群中剩余的空闲节点上，重新拉起容器副本。整个副本迁移的过程无需人工干预，迁移后原本的集群的load balance依旧好使！<br>不难看出，docker service其实不仅仅是批量启动服务这么简单，而是在集群中定义了一种状态。Cluster会持续检测服务的健康状态<br>并维护集群的高可用性。</p>
<h4 id="3-服务节点的可扩展性"><a href="#3-服务节点的可扩展性" class="headerlink" title="3 服务节点的可扩展性"></a>3 服务节点的可扩展性</h4><p>Swarm Cluster不光只是提供了优秀的高可用性，同时也提供了节点弹性扩展或缩减的功能。当容器组想动态扩展时，只需通过scale<br>参数即可复制出新的副本出来。</p>
<ul>
<li><p>仔细观察的话，可以发现所有扩展出来的容器副本都run在原先的节点下面，如果有需求想在每台节点上都run一个相同的副本，方法<br>其实很简单，只需要在命令中将”–replicas n”更换成”–mode=global”即可！</p>
</li>
<li><p>复制服务（–replicas n）<br>将一系列复制任务分发至各节点当中，具体取决于您所需要的设置状态，例如“–replicas 3”。</p>
</li>
<li><p>全局服务（–mode=global）<br>适用于集群内全部可用节点上的服务任务，例如“–mode global”。如果大家在 Swarm 集群中设有 7 台 Docker 节点，则全部节点之上都将存在对应容器。</p>
</li>
</ul>
<h4 id="4-调度机制"><a href="#4-调度机制" class="headerlink" title="4 调度机制"></a>4 调度机制</h4><p>所谓的调度其主要功能是cluster的server端去选择在哪个服务器节点上创建并启动一个容器实例的动作。它是由一个装箱算法和过滤器<br>组合而成。每次通过过滤器（constraint）启动容器的时候，swarm cluster 都会调用调度机制筛选出匹配约束条件的服务器，并在这上面运行容器。</p>
<h4 id="5-Swarm-cluster的创建过程包含以下三个步骤"><a href="#5-Swarm-cluster的创建过程包含以下三个步骤" class="headerlink" title="5 Swarm cluster的创建过程包含以下三个步骤-"></a>5 Swarm cluster的创建过程包含以下三个步骤-</h4><ul>
<li>发现Docker集群中的各个节点，收集节点状态、角色信息，并监视节点状态的变化</li>
<li>初始化内部调度（scheduler）模块</li>
<li>创建并启动API监听服务模块</li>
</ul>
<p>一旦创建好这个cluster，就可以用命令docker service批量对集群内的容器进行操作，非常方便！</p>
<p>在启动容器后，docker 会根据当前每个swarm节点的负载判断，在负载最优的节点运行这个task任务，用”docker service ls” 和”docker service ps + taskID”<br>可以看到任务运行在哪个节点上。容器启动后，有时需要等待一段时间才能完成容器创建。</p>
<h2 id="11-CI-CD-Jenkins"><a href="#11-CI-CD-Jenkins" class="headerlink" title="11 CI\CD Jenkins"></a>11 CI\CD Jenkins</h2>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Technical/">Technical</a>
                    
                      <a class="hover-with-bg" href="/categories/Technical/Distributed/">Distributed</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Docker/">Docker</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/05/01/Dubbo%E5%AD%A6%E4%B9%A0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Dubbo 学习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/30/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/">
                        <span class="hidden-mobile">Liunx 配置静态IP</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=a;var i=n.imageLazyLoadSetting.isSPA,o=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function a(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var a=0;a<r.length;a++)t=r[a],0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight*o||document.documentElement.clientHeight*o)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}();var t,e}a(),n.addEventListener("scroll",function(){var t,e;t=a,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>
