

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon-t.png">
  <link rel="icon" href="/img/favicon-t.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="pncalbl">
  <meta name="keywords" content="计算机,开发,编程,代码,博客,技术">
  
  <title>Netty 学习 - pncalbl</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"pncalbl.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/rss2.xml" title="pncalbl" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>pncalbl</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Netty 学习">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      pncalbl
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-22 00:00" pubdate>
        2021年5月22日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      40.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      553
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Netty 学习</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：16 天前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="Netty-学习"><a href="#Netty-学习" class="headerlink" title="Netty 学习"></a>Netty 学习</h1><h2 id="1-Netty-介绍和应用场景"><a href="#1-Netty-介绍和应用场景" class="headerlink" title="1 Netty 介绍和应用场景"></a>1 Netty 介绍和应用场景</h2><h3 id="1-1-本课程的学习要求"><a href="#1-1-本课程的学习要求" class="headerlink" title="1.1 本课程的学习要求"></a>1.1 本课程的学习要求</h3><ol>
<li>本课程不适用于 <code>0</code> 基础的学员。</li>
<li>要求已经掌握了 <code>Java</code> 编程，主要技术构成：<code>Java OOP</code> 编程、<code>Java</code> 多线程编程、<code>Java IO</code> 编程、<code>Java</code> 网络编程、常用的 <code>Java</code> 设计模式（比如观察者模式，命令模式，职责链模式）、常用的数据结构（比如链表）。</li>
<li>本课程的《<code>Netty</code> 核心源码剖析章节》要求学员最好有项目开发和阅读源码的经历。</li>
</ol>
<h3 id="1-2-Netty-的介绍"><a href="#1-2-Netty-的介绍" class="headerlink" title="1.2 Netty 的介绍"></a>1.2 Netty 的介绍</h3><ol>
<li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li>
<li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li>
<li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li>
<li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li>
<li>要透彻理解 <code>Netty</code>，需要先学习 <code>NIO</code>，这样我们才能阅读 <code>Netty</code> 的源码。</li>
</ol>
<h3 id="1-3-Netty-的应用场景"><a href="#1-3-Netty-的应用场景" class="headerlink" title="1.3 Netty 的应用场景"></a>1.3 Netty 的应用场景</h3><h4 id="1-3-1-互联网行业"><a href="#1-3-1-互联网行业" class="headerlink" title="1.3.1 互联网行业"></a>1.3.1 互联网行业</h4><ol>
<li><p>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <code>RPC</code> 框架必不可少，<code>Netty</code> 作为异步高性能的通信框架，往往作为基础通信组件被这些 <code>RPC</code> 框架使用。</p>
</li>
<li><p>典型的应用有：阿里分布式服务框架 <code>Dubbo</code> 的 <code>RPC</code> 框 架使用 <code>Dubbo</code> 协议进行节点间通信，<code>Dubbo</code> 协议默认使用 <code>Netty</code> 作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_01.png" alt></p>
</li>
</ol>
<h4 id="1-3-2-游戏行业"><a href="#1-3-2-游戏行业" class="headerlink" title="1.3.2 游戏行业"></a>1.3.2 游戏行业</h4><ol>
<li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用。</li>
<li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器。</li>
<li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信。</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_02.png" alt></p>
<p>​                    <img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_03.png" alt></p>
<h4 id="1-3-3-大数据领域"><a href="#1-3-3-大数据领域" class="headerlink" title="1.3.3 大数据领域"></a>1.3.3 大数据领域</h4><ol>
<li>经典的 <code>Hadoop</code> 的高性能通信和序列化组件 <code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信。</li>
<li>它的 <code>NettyService</code> 基于 <code>Netty</code> 框架二次封装实现。</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_04.png" alt></p>
<h4 id="1-3-4-其他开源项目使用到-Netty"><a href="#1-3-4-其他开源项目使用到-Netty" class="headerlink" title="1.3.4 其他开源项目使用到 Netty"></a>1.3.4 其他开源项目使用到 Netty</h4><p>网址：<a target="_blank" rel="noopener" href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter01_05.png" alt></p>
<h3 id="1-4-Netty-的学习资料的参考"><a href="#1-4-Netty-的学习资料的参考" class="headerlink" title="1.4 Netty 的学习资料的参考"></a>1.4 Netty 的学习资料的参考</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/59141c1dN7a93c127.jpg" alt></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/555080b2Ne6cbf9e3.jpg" alt></p>
<h2 id="2-Java-BIO-编程"><a href="#2-Java-BIO-编程" class="headerlink" title="2 Java BIO 编程"></a>2 Java BIO 编程</h2><h3 id="2-1-I-O-模型"><a href="#2-1-I-O-模型" class="headerlink" title="2.1 I/O 模型"></a>2.1 I/O 模型</h3><h4 id="2-1-1-模型基本说明"><a href="#2-1-1-模型基本说明" class="headerlink" title="2.1.1 模型基本说明"></a>2.1.1 模型基本说明</h4><ol>
<li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li>
<li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li>
<li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_01.png" alt></p>
<ol start="4">
<li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_02.png" alt></p>
<ol start="5">
<li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li>
</ol>
<h3 id="2-2-BIO、NIO、AIO-使用场景分析"><a href="#2-2-BIO、NIO、AIO-使用场景分析" class="headerlink" title="2.2  BIO、NIO、AIO 使用场景分析"></a>2.2  BIO、NIO、AIO 使用场景分析</h3><ol>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li>
<li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li>
<li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li>
</ol>
<h3 id="2-3-Java-BIO-的基本介绍"><a href="#2-3-Java-BIO-的基本介绍" class="headerlink" title="2.3 Java BIO 的基本介绍"></a>2.3 Java BIO 的基本介绍</h3><ol>
<li><code>Java BIO</code>就是传统的<code>Java I/O</code>编程，其相关的类和接口在<code>java.io</code>。</li>
<li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户端连接服务器）。</li>
<li><code>BIO</code>方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code>以前的唯一选择，程序简易理解。</li>
</ol>
<h3 id="2-4-Java-BIO-的工作机制"><a href="#2-4-Java-BIO-的工作机制" class="headerlink" title="2.4 Java BIO 的工作机制"></a>2.4 Java BIO 的工作机制</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter02_03.png" alt></p>
<p>对<code>BIO</code>编程流程的梳理</p>
<ol>
<li>服务器端启动一个<code>ServerSocket</code>。</li>
<li>客户端启动<code>Socket</code>对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通信。</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li>
<li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li>
</ol>
<h3 id="2-5-Java-BIO-应用实例"><a href="#2-5-Java-BIO-应用实例" class="headerlink" title="2.5 Java BIO 应用实例"></a>2.5 Java BIO 应用实例</h3><p>实例说明：</p>
<ol>
<li><p>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</p>
</li>
<li><p>要求使用线程池机制改善，可以连接多个客户端。</p>
</li>
<li><p>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</p>
</li>
<li><p>代码演示</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.bio;

<span class="hljs-keyword">import</span> java.io.InputStream;
<span class="hljs-keyword">import</span> java.net.ServerSocket;
<span class="hljs-keyword">import</span> java.net.Socket;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIOServer</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// 线程池机制</span>
        <span class="hljs-comment">// 思路</span>
        <span class="hljs-comment">// 1. 创建一个线程池</span>
        <span class="hljs-comment">// 2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span>
        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();
        <span class="hljs-comment">// 创建 ServerSocket</span>
        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);
        System.out.println(<span class="hljs-string">&quot;服务器启动了&quot;</span>);
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());
            <span class="hljs-comment">// 监听，等待客户端连接</span>
            System.out.println(<span class="hljs-string">&quot;等待连接....&quot;</span>);
            <span class="hljs-keyword">final</span> Socket socket = serverSocket.accept();
            System.out.println(<span class="hljs-string">&quot;连接到一个客户端&quot;</span>);
            <span class="hljs-comment">// 就创建一个线程，与之通讯(单独写一个方法)</span>
            newCachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 我们重写</span>
                    <span class="hljs-comment">// 可以和客户端通讯</span>
                    handler(socket);
                &#125;
            &#125;);
        &#125;
    &#125;

    <span class="hljs-comment">// 编写一个handler方法，和客户端通讯</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Socket socket)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());
            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];
            <span class="hljs-comment">// 通过socket获取输入流</span>
            InputStream inputStream = socket.getInputStream();
            <span class="hljs-comment">// 循环的读取客户端发送的数据</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                System.out.println(<span class="hljs-string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());
                System.out.println(<span class="hljs-string">&quot;read....&quot;</span>);
                <span class="hljs-keyword">int</span> read = inputStream.read(bytes);
                <span class="hljs-keyword">if</span> (read != -<span class="hljs-number">1</span>) &#123;
                    System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));<span class="hljs-comment">// 输出客户端发送的数据</span>
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            System.out.println(<span class="hljs-string">&quot;关闭和client的连接&quot;</span>);
            <span class="hljs-keyword">try</span> &#123;
                socket.close();
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

</li>
</ol>
<h3 id="2-6-Java-BIO-问题分析"><a href="#2-6-Java-BIO-问题分析" class="headerlink" title="2.6 Java BIO 问题分析"></a>2.6 Java BIO 问题分析</h3><ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li>
</ol>
<h2 id="3-Java-NIO-编程"><a href="#3-Java-NIO-编程" class="headerlink" title="3 Java NIO 编程"></a>3 Java NIO 编程</h2><h3 id="3-1-Java-NIO-基本介绍"><a href="#3-1-Java-NIO-基本介绍" class="headerlink" title="3.1 Java NIO 基本介绍"></a>3.1 Java NIO 基本介绍</h3><ol>
<li><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong>，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li>
<li><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li>
<li><code>NIO</code> 有三大核心部分：<strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</li>
<li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li>
<li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li>
<li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li>
<li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li>
<li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.nio.IntBuffer;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicBuffer</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">//举例说明 Buffer 的使用(简单说明)</span>
        <span class="hljs-comment">//创建一个 Buffer，大小为 5，即可以存放 5 个 int</span>
        IntBuffer intBuffer = IntBuffer.allocate(<span class="hljs-number">5</span>);

        <span class="hljs-comment">//向buffer存放数据</span>
        <span class="hljs-comment">//intBuffer.put(10);</span>
        <span class="hljs-comment">//intBuffer.put(11);</span>
        <span class="hljs-comment">//intBuffer.put(12);</span>
        <span class="hljs-comment">//intBuffer.put(13);</span>
        <span class="hljs-comment">//intBuffer.put(14);</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;
            intBuffer.put(i * <span class="hljs-number">2</span>);
        &#125;
        <span class="hljs-comment">//如何从 buffer 读取数据</span>
        <span class="hljs-comment">//将 buffer 转换，读写切换(!!!)</span>
        intBuffer.flip();
        <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;
            System.out.println(intBuffer.get());
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="3-2-NIO-和-BIO-的比较"><a href="#3-2-NIO-和-BIO-的比较" class="headerlink" title="3.2 NIO 和 BIO 的比较"></a>3.2 NIO 和 BIO 的比较</h3><ol>
<li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li>
<li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li>
<li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li>
</ol>
<h3 id="3-3-NIO-三大核心原理示意图"><a href="#3-3-NIO-三大核心原理示意图" class="headerlink" title="3.3 NIO 三大核心原理示意图"></a>3.3 NIO 三大核心原理示意图</h3><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p>
<h4 id="3-3-1-Selector、Channel-和-Buffer-关系图（简单版）"><a href="#3-3-1-Selector、Channel-和-Buffer-关系图（简单版）" class="headerlink" title="3.3.1 Selector、Channel 和 Buffer 关系图（简单版）"></a>3.3.1 Selector、Channel 和 Buffer 关系图（简单版）</h4><p>关系图的说明:</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_01.png" alt="img"></p>
<ol>
<li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li>
<li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li>
<li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li>
<li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li>
<li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li>
<li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li>
<li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li>
</ol>
<h3 id="3-4-缓冲区（Buffer）"><a href="#3-4-缓冲区（Buffer）" class="headerlink" title="3.4 缓冲区（Buffer）"></a>3.4 缓冲区（Buffer）</h3><h4 id="3-4-1-基本介绍"><a href="#3-4-1-基本介绍" class="headerlink" title="3.4.1 基本介绍"></a>3.4.1 基本介绍</h4><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_02.png" alt="img"></p>
<h4 id="3-4-2-Buffer-类及其子类"><a href="#3-4-2-Buffer-类及其子类" class="headerlink" title="3.4.2 Buffer 类及其子类"></a>3.4.2 Buffer 类及其子类</h4><ol>
<li>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_03.png" alt="img"></p>
<ol>
<li><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_05.png" alt="img"></p>
<ol>
<li><code>Buffer</code> 类相关方法一览</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_06.png" alt="img"></p>
<h4 id="3-4-3-ByteBuffer"><a href="#3-4-3-ByteBuffer" class="headerlink" title="3.4.3 ByteBuffer"></a>3.4.3 ByteBuffer</h4><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_07.png" alt="img"></p>
<h3 id="3-5-通道（Channel）"><a href="#3-5-通道（Channel）" class="headerlink" title="3.5 通道（Channel）"></a>3.5 通道（Channel）</h3><h4 id="3-5-0-基本介绍"><a href="#3-5-0-基本介绍" class="headerlink" title="3.5.0 基本介绍"></a>3.5.0 基本介绍</h4><ol>
<li><p><code>NIO</code> 的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
</li>
<li><p><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</p>
</li>
<li><p><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></p>
</li>
<li><p>常用的 <code>Channel</code> 类有：<strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong>。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</p>
</li>
<li><p><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</p>
</li>
<li><p>图示</p>
</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_08.png" alt="img"></p>
<h4 id="3-5-1-FileChannel-类"><a href="#3-5-1-FileChannel-类" class="headerlink" title="3.5.1 FileChannel 类"></a>3.5.1 FileChannel 类</h4><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p>
<ul>
<li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li>
<li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li>
<li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li>
<li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li>
</ul>
<h4 id="3-5-2-应用实例1-本地文件写数据"><a href="#3-5-2-应用实例1-本地文件写数据" class="headerlink" title="3.5.2 应用实例1 - 本地文件写数据"></a>3.5.2 应用实例1 - 本地文件写数据</h4><p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li>
<li>文件不存在就创建</li>
<li>代码演示</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.io.FileOutputStream;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel01</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        String str = <span class="hljs-string">&quot;hello,尚硅谷&quot;</span>;
        <span class="hljs-comment">//创建一个输出流 -&gt; channel</span>
        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d:\\file01.txt&quot;</span>);

        <span class="hljs-comment">//通过 fileOutputStream 获取对应的 FileChannel</span>
        <span class="hljs-comment">//这个 fileChannel 真实类型是 FileChannelImpl</span>
        FileChannel fileChannel = fileOutputStream.getChannel();

        <span class="hljs-comment">//创建一个缓冲区 ByteBuffer</span>
        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);

        <span class="hljs-comment">//将 str 放入 byteBuffer</span>
        byteBuffer.put(str.getBytes());

        <span class="hljs-comment">//对 byteBuffer 进行 flip</span>
        byteBuffer.flip();

        <span class="hljs-comment">//将 byteBuffer 数据写入到 fileChannel</span>
        fileChannel.write(byteBuffer);
        fileOutputStream.close();
    &#125;
&#125;</code></pre></div>

<h4 id="3-5-3-应用实例2-本地文件读数据"><a href="#3-5-3-应用实例2-本地文件读数据" class="headerlink" title="3.5.3 应用实例2 - 本地文件读数据"></a>3.5.3 应用实例2 - 本地文件读数据</h4><p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li>
<li>假定文件已经存在</li>
<li>代码演示</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel02</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//创建文件的输入流</span>
        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:\\file01.txt&quot;</span>);
        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);
        
        <span class="hljs-comment">//通过 fileInputStream 获取对应的 FileChannel -&gt; 实际类型 FileChannelImpl</span>
        FileChannel fileChannel = fileInputStream.getChannel();
        
        <span class="hljs-comment">//创建缓冲区</span>
        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="hljs-keyword">int</span>)file.length());
        
        <span class="hljs-comment">//将通道的数据读入到 Buffer</span>
        fileChannel.read(byteBuffer);
        
        <span class="hljs-comment">//将 byteBuffer 的字节数据转成 String</span>
        System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array()));
        fileInputStream.close();
    &#125;
&#125;</code></pre></div>

<h4 id="3-5-4-应用实例3-使用一个-Buffer-完成文件读取、写入"><a href="#3-5-4-应用实例3-使用一个-Buffer-完成文件读取、写入" class="headerlink" title="3.5.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入"></a>3.5.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入</h4><p>实例要求：</p>
<ol>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li>
<li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li>
<li>代码演示</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_09.png" alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.FileOutputStream;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel03</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;1.txt&quot;</span>);
        FileChannel fileChannel01 = fileInputStream.getChannel();
        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;2.txt&quot;</span>);
        FileChannel fileChannel02 = fileOutputStream.getChannel();

        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);
        
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123; <span class="hljs-comment">//循环读取</span>

            <span class="hljs-comment">//这里有一个重要的操作，一定不要忘了</span>
            <span class="hljs-comment">/*</span>
<span class="hljs-comment">            public final Buffer clear() &#123;</span>
<span class="hljs-comment">                position = 0;</span>
<span class="hljs-comment">                limit = capacity;</span>
<span class="hljs-comment">                mark = -1;</span>
<span class="hljs-comment">                return this;</span>
<span class="hljs-comment">            &#125;</span>
<span class="hljs-comment">            */</span>
            byteBuffer.clear(); <span class="hljs-comment">//清空 buffer</span>
            <span class="hljs-keyword">int</span> read = fileChannel01.read(byteBuffer);
            System.out.println(<span class="hljs-string">&quot;read = &quot;</span> + read);
            <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//表示读完</span>
                <span class="hljs-keyword">break</span>;
            &#125;

            <span class="hljs-comment">//将 buffer 中的数据写入到 fileChannel02--2.txt</span>
            byteBuffer.flip();
            fileChannel02.write(byteBuffer);
        &#125;

        <span class="hljs-comment">//关闭相关的流</span>
        fileInputStream.close();
        fileOutputStream.close();
    &#125;
&#125;</code></pre></div>

<h4 id="3-5-5-应用实例4-拷贝文件-transferFrom-方法"><a href="#3-5-5-应用实例4-拷贝文件-transferFrom-方法" class="headerlink" title="3.5.5 应用实例4 - 拷贝文件 transferFrom 方法"></a>3.5.5 应用实例4 - 拷贝文件 transferFrom 方法</h4><ol>
<li>实例要求：</li>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li>
<li>拷贝一张图片</li>
<li>代码演示</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.FileOutputStream;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel04</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//创建相关流</span>
        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\a.jpg&quot;</span>);
        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;d:\\a2.jpg&quot;</span>);
        
        <span class="hljs-comment">//获取各个流对应的 FileChannel</span>
        FileChannel sourceCh = fileInputStream.getChannel();
        FileChannel destCh = fileOutputStream.getChannel();

        <span class="hljs-comment">//使用 transferForm 完成拷贝</span>
        destCh.transferFrom(sourceCh, <span class="hljs-number">0</span>, sourceCh.size());

        <span class="hljs-comment">//关闭相关通道和流</span>
        sourceCh.close();
        destCh.close();
        fileInputStream.close();
        fileOutputStream.close();
    &#125;
&#125;</code></pre></div>

<h4 id="3-5-6-关于-Buffer-和-Channel-的注意事项和细节"><a href="#3-5-6-关于-Buffer-和-Channel-的注意事项和细节" class="headerlink" title="3.5.6 关于 Buffer 和 Channel 的注意事项和细节"></a>3.5.6 关于 Buffer 和 Channel 的注意事项和细节</h4><ol>
<li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.nio.ByteBuffer;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOByteBufferPutGet</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        
        <span class="hljs-comment">//创建一个 Buffer</span>
        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);

        <span class="hljs-comment">//类型化方式放入数据</span>
        buffer.putInt(<span class="hljs-number">100</span>);
        buffer.putLong(<span class="hljs-number">9</span>);
        buffer.putChar(<span class="hljs-string">&#x27;尚&#x27;</span>);
        buffer.putShort((<span class="hljs-keyword">short</span>) <span class="hljs-number">4</span>);

        <span class="hljs-comment">//取出</span>
        buffer.flip();
        
        System.out.println();
        
        System.out.println(buffer.getInt());
        System.out.println(buffer.getLong());
        System.out.println(buffer.getChar());
        System.out.println(buffer.getShort());
    &#125;
&#125;</code></pre></div>

<ol start="2">
<li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.nio.ByteBuffer;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadOnlyBuffer</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">//创建一个 buffer</span>
        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;
            buffer.put((<span class="hljs-keyword">byte</span>) i);
        &#125;

        <span class="hljs-comment">//读取</span>
        buffer.flip();

        <span class="hljs-comment">//得到一个只读的 Buffer</span>
        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();
        System.out.println(readOnlyBuffer.getClass());

        <span class="hljs-comment">//读取</span>
        <span class="hljs-keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123;
            System.out.println(readOnlyBuffer.get());
        &#125;

        readOnlyBuffer.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">100</span>); <span class="hljs-comment">//ReadOnlyBufferException</span>
    &#125;
&#125;</code></pre></div>

<ol start="3">
<li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.io.RandomAccessFile;
<span class="hljs-keyword">import</span> java.nio.MappedByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MappedByteBufferTest</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        RandomAccessFile randomAccessFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);
        <span class="hljs-comment">//获取对应的通道</span>
        FileChannel channel = randomAccessFile.getChannel();

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式</span>
<span class="hljs-comment">         * 参数 2：0：可以直接修改的起始位置</span>
<span class="hljs-comment">         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span>
<span class="hljs-comment">         * 可以直接修改的范围就是 0-5</span>
<span class="hljs-comment">         * 实际类型 DirectByteBuffer</span>
<span class="hljs-comment">         */</span>
        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);

        mappedByteBuffer.put(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;H&#x27;</span>);
        mappedByteBuffer.put(<span class="hljs-number">3</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;9&#x27;</span>);
        mappedByteBuffer.put(<span class="hljs-number">5</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">&#x27;Y&#x27;</span>);<span class="hljs-comment">//IndexOutOfBoundsException</span>

        randomAccessFile.close();
        System.out.println(<span class="hljs-string">&quot;修改成功~~&quot;</span>);
    &#125;
&#125;</code></pre></div>

<ol start="4">
<li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.pnca.nio;

<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;
<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;
<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]</span>
<span class="hljs-comment"> * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScatteringAndGatheringTest</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        
        <span class="hljs-comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span>
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7000</span>);

        <span class="hljs-comment">//绑定端口到 socket，并启动</span>
        serverSocketChannel.socket().bind(inetSocketAddress);

        <span class="hljs-comment">//创建 buffer 数组</span>
        ByteBuffer[] byteBuffers = <span class="hljs-keyword">new</span> ByteBuffer[<span class="hljs-number">2</span>];
        byteBuffers[<span class="hljs-number">0</span>] = ByteBuffer.allocate(<span class="hljs-number">5</span>);
        byteBuffers[<span class="hljs-number">1</span>] = ByteBuffer.allocate(<span class="hljs-number">3</span>);

        <span class="hljs-comment">//等客户端连接 (telnet)</span>
        SocketChannel socketChannel = serverSocketChannel.accept();

        <span class="hljs-keyword">int</span> messageLength = <span class="hljs-number">8</span>; <span class="hljs-comment">//假定从客户端接收 8 个字节</span>

        <span class="hljs-comment">//循环的读取</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            <span class="hljs-keyword">int</span> byteRead = <span class="hljs-number">0</span>;

            <span class="hljs-keyword">while</span> (byteRead &lt; messageLength) &#123;
                <span class="hljs-keyword">long</span> l = socketChannel.read(byteBuffers);
                byteRead += l; <span class="hljs-comment">//累计读取的字节数</span>
                System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead);
                <span class="hljs-comment">//使用流打印,看看当前的这个 buffer 的 position 和 limit</span>
                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="hljs-string">&quot;position = &quot;</span> + buffer.position() + <span class="hljs-string">&quot;, limit = &quot;</span> + buffer.limit()).forEach(System.out::println);
            &#125;

            <span class="hljs-comment">//将所有的 buffer 进行 flip</span>
            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());
            <span class="hljs-comment">//将数据读出显示到客户端</span>
            <span class="hljs-keyword">long</span> byteWirte = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (byteWirte &lt; messageLength) &#123;
                <span class="hljs-keyword">long</span> l = socketChannel.write(byteBuffers);<span class="hljs-comment">//</span>
                byteWirte += l;
            &#125;
            
            <span class="hljs-comment">//将所有的buffer进行clear</span>
            Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123;
                buffer.clear();
            &#125;);
            
            System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead + <span class="hljs-string">&quot;, byteWrite = &quot;</span> + byteWirte + <span class="hljs-string">&quot;, messagelength = &quot;</span> + messageLength);
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="3-6-Selector（选择器）"><a href="#3-6-Selector（选择器）" class="headerlink" title="3.6 Selector（选择器）"></a>3.6 Selector（选择器）</h3><h4 id="3-6-1-基本介绍"><a href="#3-6-1-基本介绍" class="headerlink" title="3.6.1 基本介绍"></a>3.6.1 基本介绍</h4><ol>
<li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li>
<li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</li>
<li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li>
<li>避免了多线程之间的上下文切换导致的开销。</li>
</ol>
<h4 id="3-6-2-Selector-示意图和特点说明"><a href="#3-6-2-Selector-示意图和特点说明" class="headerlink" title="3.6.2 Selector 示意图和特点说明"></a>3.6.2 Selector 示意图和特点说明</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_10.png" alt="img"></p>
<p>说明如下：</p>
<ol>
<li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li>
<li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li>
<li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li>
<li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li>
<li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li>
</ol>
<h4 id="3-6-3-Selector-类相关方法"><a href="#3-6-3-Selector-类相关方法" class="headerlink" title="3.6.3 Selector 类相关方法"></a>3.6.3 Selector 类相关方法</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_11.png" alt="img"></p>
<h4 id="3-6-4-注意事项"><a href="#3-6-4-注意事项" class="headerlink" title="3.6.4 注意事项"></a>3.6.4 注意事项</h4><ol>
<li><p><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</p>
</li>
<li><p><code>Selector</code> 相关方法说明</p>
<ul>
<li><code>selector.select();</code> //阻塞</li>
<li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li>
<li><code>selector.wakeup();</code> //唤醒 selector</li>
<li><code>selector.selectNow();</code> //不阻塞，立马返还</li>
</ul>
</li>
</ol>
<h3 id="3-7-NIO-非阻塞网络编程原理分析图"><a href="#3-7-NIO-非阻塞网络编程原理分析图" class="headerlink" title="3.7 NIO 非阻塞网络编程原理分析图"></a>3.7 NIO 非阻塞网络编程原理分析图</h3><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_22.png" alt="img"></p>
<p>对上图的说明：</p>
<ol>
<li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li>
<li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li>
<li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li>
<li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li>
<li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li>
<li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li>
<li>可以通过得到的 <code>channel</code>，完成业务处理。</li>
<li>代码撑腰。。。</li>
</ol>
<h3 id="3-8-NIO-非阻塞网络编程快速入门"><a href="#3-8-NIO-非阻塞网络编程快速入门" class="headerlink" title="3.8 NIO 非阻塞网络编程快速入门"></a>3.8 NIO 非阻塞网络编程快速入门</h3><p>案例要求：</p>
<ol>
<li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li>
<li>看老师代码演示</li>
</ol>
<h3 id="3-9-SelectionKey"><a href="#3-9-SelectionKey" class="headerlink" title="3.9 SelectionKey"></a>3.9 SelectionKey</h3><ol>
<li><code>SelectionKey</code>，表示 <code>Selector</code> 和网络通道的注册关系，共四种：<ul>
<li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li>
<li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li>
<li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li>
<li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li>
</ul>
</li>
</ol>
<p>源码中：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_READ = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_WRITE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_CONNECT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_ACCEPT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;</code></pre></div>

<ol start="2">
<li><code>SelectionKey</code> 相关方法</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_12.png" alt="img"></p>
<h3 id="3-10-ServerSocketChannel"><a href="#3-10-ServerSocketChannel" class="headerlink" title="3.10 ServerSocketChannel"></a>3.10 ServerSocketChannel</h3><ol>
<li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接</li>
<li>相关方法如下</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_13.png" alt="img"></p>
<h3 id="3-11-SocketChannel"><a href="#3-11-SocketChannel" class="headerlink" title="3.11 SocketChannel"></a>3.11 SocketChannel</h3><ol>
<li><code>SocketChannel</code>，网络 <code>IO</code> 通道，具体负责进行读写操作。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li>
<li>相关方法如下</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_14.png" alt="img"></p>
<h3 id="3-12-NIO-网络编程应用实例-群聊系统"><a href="#3-12-NIO-网络编程应用实例-群聊系统" class="headerlink" title="3.12 NIO 网络编程应用实例 - 群聊系统"></a>3.12 NIO 网络编程应用实例 - 群聊系统</h3><p>实例要求：</p>
<ol>
<li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
<li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li>
<li>示意图分析和代码</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_15.png" alt="img"></p>
<p>代码：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 服务端：</span>

<span class="hljs-keyword">package</span> com.atguigu.nio.groupchat;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.Channel;
<span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;
<span class="hljs-keyword">import</span> java.nio.channels.Selector;
<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;
<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;
<span class="hljs-keyword">import</span> java.util.Iterator;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>&#123;

    <span class="hljs-comment">//定义属性</span>
    <span class="hljs-keyword">private</span> Selector selector;
    <span class="hljs-keyword">private</span> ServerSocketChannel listenChannel;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;

    <span class="hljs-comment">//构造器</span>
    <span class="hljs-comment">//初始化工作</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//得到选择器</span>
            selector = Selector.open();
            <span class="hljs-comment">//ServerSocketChannel</span>
            listenChannel = ServerSocketChannel.open();
            <span class="hljs-comment">//绑定端口</span>
            listenChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(PORT));
            <span class="hljs-comment">//设置非阻塞模式</span>
            listenChannel.configureBlocking(<span class="hljs-keyword">false</span>);
            <span class="hljs-comment">//将该 listenChannel 注册到 selector</span>
            listenChannel.register(selector, SelectionKey.OP_ACCEPT);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//循环处理</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                <span class="hljs-keyword">int</span> count = selector.select();
                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//有事件处理</span>
                    <span class="hljs-comment">// 遍历得到 selectionKey 集合</span>
                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();
                    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
                        <span class="hljs-comment">//取出 selectionkey</span>
                        SelectionKey key = iterator.next();
                        <span class="hljs-comment">//监听到 accept</span>
                        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;
                            SocketChannel sc = listenChannel.accept();
                            sc.configureBlocking(<span class="hljs-keyword">false</span>);
                            <span class="hljs-comment">//将该 sc 注册到 seletor</span>
                            sc.register(selector, SelectionKey.OP_READ);
                            <span class="hljs-comment">//提示</span>
                            System.out.println(sc.getRemoteAddress() + <span class="hljs-string">&quot; 上线 &quot;</span>);
                        &#125;
                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<span class="hljs-comment">//通道发送read事件，即通道是可读的状态</span>
                            <span class="hljs-comment">// 处理读(专门写方法..)</span>
                            readData(key);
                        &#125;
                        <span class="hljs-comment">//当前的 key 删除，防止重复处理</span>
                        iterator.remove();
                    &#125;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    System.out.println(<span class="hljs-string">&quot;等待....&quot;</span>);
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">//发生异常处理....</span>
        &#125;
    &#125;

    <span class="hljs-comment">//读取客户端消息</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readData</span><span class="hljs-params">(SelectionKey key)</span> </span>&#123;
        SocketChannel channel = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//得到 channel</span>
            channel = (SocketChannel) key.channel();
            <span class="hljs-comment">//创建 buffer</span>
            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);
            <span class="hljs-keyword">int</span> count = channel.read(buffer);
            <span class="hljs-comment">//根据 count 的值做处理</span>
            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">//把缓存区的数据转成字符串</span>
                String msg = <span class="hljs-keyword">new</span> String(buffer.array());
                <span class="hljs-comment">//输出该消息</span>
                System.out.println(<span class="hljs-string">&quot;form客户端:&quot;</span> + msg);
                <span class="hljs-comment">//向其它的客户端转发消息(去掉自己),专门写一个方法来处理</span>
                sendInfoToOtherClients(msg, channel);
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            <span class="hljs-keyword">try</span> &#123;
                System.out.println(channel.getRemoteAddress() + <span class="hljs-string">&quot;离线了..&quot;</span>);
                <span class="hljs-comment">//取消注册</span>
                key.cancel();
                <span class="hljs-comment">//关闭通道</span>
                channel.close();
            &#125; <span class="hljs-keyword">catch</span> (IOException e2) &#123;
                e2.printStackTrace();
            &#125;
        &#125;
    &#125;

    <span class="hljs-comment">//转发消息给其它客户(通道)</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfoToOtherClients</span><span class="hljs-params">(String msg, SocketChannel self)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;

        System.out.println(<span class="hljs-string">&quot;服务器转发消息中...&quot;</span>);
        <span class="hljs-comment">//遍历所有注册到 selector 上的 SocketChannel,并排除 self</span>
        <span class="hljs-keyword">for</span> (SelectionKey key : selector.keys()) &#123;
            <span class="hljs-comment">//通过 key 取出对应的 SocketChannel</span>
            Channel targetChannel = key.channel();
            <span class="hljs-comment">//排除自己</span>
            <span class="hljs-keyword">if</span> (targetChannel <span class="hljs-keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;
                <span class="hljs-comment">//转型</span>
                SocketChannel dest = (SocketChannel) targetChannel;
                <span class="hljs-comment">//将 msg 存储到 buffer</span>
                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());
                <span class="hljs-comment">//将 buffer 的数据写入通道</span>
                dest.write(buffer);
            &#125;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//创建服务器对象</span>
        GroupChatServer groupChatServer = <span class="hljs-keyword">new</span> GroupChatServer();
        groupChatServer.listen();
    &#125;
&#125;

<span class="hljs-comment">// 客户端：</span>

<span class="hljs-keyword">package</span> com.atguigu.nio.groupchat;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.SelectionKey;
<span class="hljs-keyword">import</span> java.nio.channels.Selector;
<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>&#123;

    <span class="hljs-comment">//定义相关的属性</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<span class="hljs-comment">//服务器的ip</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;<span class="hljs-comment">//服务器端口</span>
    <span class="hljs-keyword">private</span> Selector selector;
    <span class="hljs-keyword">private</span> SocketChannel socketChannel;
    <span class="hljs-keyword">private</span> String username;

    <span class="hljs-comment">//构造器,完成初始化工作</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
        
        selector = Selector.open();
        <span class="hljs-comment">//连接服务器</span>
        socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(HOST, PORT));
        <span class="hljs-comment">//设置非阻塞</span>
        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);
        <span class="hljs-comment">//将 channel 注册到selector</span>
        socketChannel.register(selector, SelectionKey.OP_READ);
        <span class="hljs-comment">//得到 username</span>
        username = socketChannel.getLocalAddress().toString().substring(<span class="hljs-number">1</span>);
        System.out.println(username + <span class="hljs-string">&quot; is ok...&quot;</span>);
    &#125;

    <span class="hljs-comment">//向服务器发送消息</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfo</span><span class="hljs-params">(String info)</span> </span>&#123;
        info = username + <span class="hljs-string">&quot; 说：&quot;</span> + info;
        <span class="hljs-keyword">try</span> &#123;
            socketChannel.write(ByteBuffer.wrap(info.getBytes()));
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    <span class="hljs-comment">//读取从服务器端回复的消息</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readInfo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">int</span> readChannels = selector.select();
            <span class="hljs-keyword">if</span> (readChannels &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有可以用的通道</span>
                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();
                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
                    SelectionKey key = iterator.next();
                    <span class="hljs-keyword">if</span> (key.isReadable()) &#123;
                        <span class="hljs-comment">//得到相关的通道</span>
                        SocketChannel sc = (SocketChannel) key.channel();
                        <span class="hljs-comment">//得到一个 Buffer</span>
                        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);
                        <span class="hljs-comment">//读取</span>
                        sc.read(buffer);
                        <span class="hljs-comment">//把读到的缓冲区的数据转成字符串</span>
                        String msg = <span class="hljs-keyword">new</span> String(buffer.array());
                        System.out.println(msg.trim());
                    &#125;
                &#125;
                iterator.remove(); <span class="hljs-comment">//删除当前的 selectionKey,防止重复操作</span>
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span>
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//启动我们客户端</span>
        GroupChatClient chatClient = <span class="hljs-keyword">new</span> GroupChatClient();
        <span class="hljs-comment">//启动一个线程,每个 3 秒，读取从服务器发送数据</span>
        <span class="hljs-keyword">new</span> Thread() &#123;
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                    chatClient.readInfo();
                    <span class="hljs-keyword">try</span> &#123;
                        Thread.currentThread().sleep(<span class="hljs-number">3000</span>);
                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;.start();

        <span class="hljs-comment">//发送数据给服务器端</span>
        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);
        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;
            String s = scanner.nextLine();
            chatClient.sendInfo(s);
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="3-13-NIO-与零拷贝"><a href="#3-13-NIO-与零拷贝" class="headerlink" title="3.13 NIO 与零拷贝"></a>3.13 NIO 与零拷贝</h3><h4 id="3-13-1-零拷贝基本介绍"><a href="#3-13-1-零拷贝基本介绍" class="headerlink" title="3.13.1 零拷贝基本介绍"></a>3.13.1 零拷贝基本介绍</h4><ol>
<li>零拷贝是网络编程的关键，很多性能优化都离不开。</li>
<li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li>
<li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li>
</ol>
<h4 id="3-13-2-传统-IO-数据读写"><a href="#3-13-2-传统-IO-数据读写" class="headerlink" title="3.13.2 传统 IO 数据读写"></a>3.13.2 传统 IO 数据读写</h4><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p>
<div class="code-wrapper"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;test.txt&quot;</span>);
RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(file, <span class="hljs-string">&quot;rw&quot;</span>);

<span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) file.length()];
raf.read(arr);

Socket socket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>).accept();
socket.getOutputStream().write(arr);</code></pre></div>

<h4 id="3-13-3-传统-IO-模型"><a href="#3-13-3-传统-IO-模型" class="headerlink" title="3.13.3 传统 IO 模型"></a>3.13.3 传统 IO 模型</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_17.png" alt="img"></p>
<p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p>
<h4 id="3-13-4-mmap-优化"><a href="#3-13-4-mmap-优化" class="headerlink" title="3.13.4 mmap 优化"></a>3.13.4 mmap 优化</h4><ol>
<li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li>
<li><code>mmap</code> 示意图</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_18.png" alt="img"></p>
<h4 id="3-13-5-sendFile-优化"><a href="#3-13-5-sendFile-优化" class="headerlink" title="3.13.5 sendFile 优化"></a>3.13.5 sendFile 优化</h4><ol>
<li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li>
<li>示意图和小结</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_19.png" alt="img"></p>
<ol start="3">
<li><p>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</p>
</li>
<li><p><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</p>
</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter03_20.png" alt="img"></p>
<ol start="5">
<li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li>
</ol>
<h4 id="3-13-6-零拷贝的再次理解"><a href="#3-13-6-零拷贝的再次理解" class="headerlink" title="3.13.6 零拷贝的再次理解"></a>3.13.6 零拷贝的再次理解</h4><ol>
<li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li>
<li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li>
</ol>
<h4 id="3-13-7-mmap-和-sendFile-的区别"><a href="#3-13-7-mmap-和-sendFile-的区别" class="headerlink" title="3.13.7 mmap 和 sendFile 的区别"></a>3.13.7 mmap 和 sendFile 的区别</h4><ol>
<li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li>
<li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li>
<li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li>
</ol>
<h4 id="3-13-8-NIO-零拷贝案例"><a href="#3-13-8-NIO-零拷贝案例" class="headerlink" title="3.13.8 NIO 零拷贝案例"></a>3.13.8 NIO 零拷贝案例</h4><p>案例要求：</p>
<ol>
<li>使用传统的 <code>IO</code> 方法传递一个大文件</li>
<li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li>
<li>看看两种传递方式耗时时间分别是多少</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.nio.zerocopy;

<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.net.ServerSocket;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.ServerSocketChannel;
<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;

<span class="hljs-comment">//服务器</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOServer</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7001</span>);
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        ServerSocket serverSocket = serverSocketChannel.socket();
        serverSocket.bind(address);

        <span class="hljs-comment">//创建buffer</span>
        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">4096</span>);

        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
            SocketChannel socketChannel = serverSocketChannel.accept();
            <span class="hljs-keyword">int</span> readcount = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (-<span class="hljs-number">1</span> != readcount) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    readcount = socketChannel.read(byteBuffer);
                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;
                    <span class="hljs-comment">// ex.printStackTrace();</span>
                    <span class="hljs-keyword">break</span>;
                &#125;
                <span class="hljs-comment">//</span>
                byteBuffer.rewind(); <span class="hljs-comment">//倒带 position = 0 mark 作废</span>
            &#125;
        &#125;
    &#125;
&#125;



<span class="hljs-keyword">package</span> com.atguigu.nio.zerocopy;

<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.nio.channels.FileChannel;
<span class="hljs-keyword">import</span> java.nio.channels.SocketChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOClient</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        SocketChannel socketChannel = SocketChannel.open();
        socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">7001</span>));
        String filename = <span class="hljs-string">&quot;protoc-3.6.1-win32.zip&quot;</span>;
        <span class="hljs-comment">//得到一个文件channel</span>
        FileChannel fileChannel = <span class="hljs-keyword">new</span> FileInputStream(filename).getChannel();
        <span class="hljs-comment">//准备发送</span>
        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();
        <span class="hljs-comment">//在 linux 下一个 transferTo 方法就可以完成传输</span>
        <span class="hljs-comment">//在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要</span>
        <span class="hljs-comment">//传输时的位置=》课后思考...</span>
        <span class="hljs-comment">//transferTo 底层使用到零拷贝</span>
        <span class="hljs-keyword">long</span> transferCount = fileChannel.transferTo(<span class="hljs-number">0</span>, fileChannel.size(), socketChannel);
        System.out.println(<span class="hljs-string">&quot;发送的总的字节数 = &quot;</span> + transferCount + <span class="hljs-string">&quot; 耗时: &quot;</span> + (System.currentTimeMillis() - startTime));

        <span class="hljs-comment">//关闭</span>
        fileChannel.close();
    &#125;
&#125;</code></pre></div>

<h3 id="3-14-Java-AIO-基本介绍"><a href="#3-14-Java-AIO-基本介绍" class="headerlink" title="3.14 Java AIO 基本介绍"></a>3.14 Java AIO 基本介绍</h3><ol>
<li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li>
<li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
<li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a target="_blank" rel="noopener" href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li>
</ol>
<h3 id="3-15-BIO、NIO、AIO-对比表"><a href="#3-15-BIO、NIO、AIO-对比表" class="headerlink" title="3.15 BIO、NIO、AIO 对比表"></a>3.15 BIO、NIO、AIO 对比表</h3><table>
<thead>
<tr>
<th></th>
<th>BIO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody><tr>
<td>IO模型</td>
<td>同步阻塞</td>
<td>同步非阻塞（多路复用）</td>
<td>异步非阻塞</td>
</tr>
<tr>
<td>编程难度</td>
<td>简单</td>
<td>复杂</td>
<td>复杂</td>
</tr>
<tr>
<td>可靠性</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<p><strong>举例说明</strong></p>
<ol>
<li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li>
<li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li>
<li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li>
</ol>
<h2 id="4-Netty-概述"><a href="#4-Netty-概述" class="headerlink" title="4 Netty 概述"></a>4 Netty 概述</h2><h3 id="4-1-原生-NIO-存在的问题"><a href="#4-1-原生-NIO-存在的问题" class="headerlink" title="4.1 原生 NIO 存在的问题"></a>4.1 原生 NIO 存在的问题</h3><ol>
<li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li>
<li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li>
<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。4. <code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决。</li>
</ol>
<h3 id="4-2-Netty-官网说明"><a href="#4-2-Netty-官网说明" class="headerlink" title="4.2 Netty 官网说明"></a>4.2 Netty 官网说明</h3><p>官网：<a target="_blank" rel="noopener" href="https://netty.io/">https://netty.io/</a></p>
<p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter04_01.png" alt="img"></p>
<h3 id="4-3-Netty-的优点"><a href="#4-3-Netty-的优点" class="headerlink" title="4.3 Netty 的优点"></a>4.3 Netty 的优点</h3><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p>
<ol>
<li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li>
<li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li>
<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
<li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li>
<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li>
</ol>
<h3 id="4-4-Netty-版本说明"><a href="#4-4-Netty-版本说明" class="headerlink" title="4.4 Netty 版本说明"></a>4.4 Netty 版本说明</h3><ol>
<li><p><code>Netty</code> 版本分为 <code>Netty 3.x</code> 和 <code>Netty 4.x</code>、<code>Netty 5.x</code></p>
</li>
<li><p>因为 <code>Netty 5</code> 出现重大 <code>bug</code>，已经被官网废弃了，目前推荐使用的是 <code>Netty 4.x</code>的稳定版本</p>
</li>
<li><p>目前在官网可下载的版本 <code>Netty 3.x</code>、<code>Netty 4.0.x</code> 和 <code>Netty 4.1.x</code></p>
</li>
<li><p>在本套课程中，我们讲解 <code>Netty4.1.x</code> 版本</p>
</li>
<li><p><code>Netty</code> 下载地址：<a target="_blank" rel="noopener" href="https://bintray.com/netty/downloads/netty/">https://bintray.com/netty/downloads/netty/</a></p>
</li>
<li><p>maven</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.netty/netty-all --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.42.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

</li>
</ol>
<h2 id="5-Netty-高性能架构设计"><a href="#5-Netty-高性能架构设计" class="headerlink" title="5  Netty 高性能架构设计"></a>5  Netty 高性能架构设计</h2><h3 id="5-1-线程模型基本介绍"><a href="#5-1-线程模型基本介绍" class="headerlink" title="5.1 线程模型基本介绍"></a>5.1 线程模型基本介绍</h3><ol>
<li>不同的线程模式，对程序的性能有很大影响，为了搞清 <code>Netty</code> 线程模式，我们来系统的讲解下各个线程模式，最后看看 <code>Netty</code> 线程模型有什么优越性。</li>
<li>目前存在的线程模型有：传统阻塞 <code>I/O</code> 服务模型 <code>Reactor</code> 模式</li>
<li>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现单 <code>Reactor</code> 单线程；单 <code>Reactor</code>多线程；主从 <code>Reactor</code>多线程</li>
<li><code>Netty</code> 线程模式（<code>Netty</code> 主要基于主从 <code>Reactor</code> 多线程模型做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>）</li>
</ol>
<h3 id="5-2-传统阻塞-I-O-服务模型"><a href="#5-2-传统阻塞-I-O-服务模型" class="headerlink" title="5.2 传统阻塞 I/O 服务模型"></a>5.2 传统阻塞 I/O 服务模型</h3><h4 id="5-2-1-工作原理图"><a href="#5-2-1-工作原理图" class="headerlink" title="5.2.1 工作原理图"></a>5.2.1 工作原理图</h4><ol>
<li>黄色的框表示对象，蓝色的框表示线程</li>
<li>白色的框表示方法（<code>API</code>）</li>
</ol>
<h4 id="5-2-2-模型特点"><a href="#5-2-2-模型特点" class="headerlink" title="5.2.2 模型特点"></a>5.2.2 模型特点</h4><ol>
<li>采用阻塞 <code>IO</code> 模式获取输入的数据</li>
<li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li>
</ol>
<h4 id="5-2-3-问题分析"><a href="#5-2-3-问题分析" class="headerlink" title="5.2.3 问题分析"></a>5.2.3 问题分析</h4><ol>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 <code>read</code> 操作，造成线程资源浪费</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_01.png" alt="img"></p>
<h3 id="5-3-Reactor-模式"><a href="#5-3-Reactor-模式" class="headerlink" title="5.3 Reactor 模式"></a>5.3 Reactor 模式</h3><h4 id="5-3-1-针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案："><a href="#5-3-1-针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案：" class="headerlink" title="5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案："></a>5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</h4><ol>
<li>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理 <code>Reactor</code> 对应的叫法：<ol>
<li>反应器模式</li>
<li>分发者模式（Dispatcher）</li>
<li>通知者模式（notifier）</li>
</ol>
</li>
<li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_02.png" alt="img"></p>
<h4 id="5-3-2-I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图"><a href="#5-3-2-I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图" class="headerlink" title="5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图"></a>5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_03.png" alt="img"></p>
<p>对上图说明：</p>
<ol>
<li><code>Reactor</code> 模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li>
<li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 <code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式</li>
<li><code>Reactor</code> 模式使用 <code>IO</code> 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li>
</ol>
<h4 id="5-3-3-Reactor-模式中核心组成"><a href="#5-3-3-Reactor-模式中核心组成" class="headerlink" title="5.3.3 Reactor 模式中核心组成"></a>5.3.3 Reactor 模式中核心组成</h4><ol>
<li><code>Reactor</code>：<code>Reactor</code> 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 <code>IO</code> 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li>
<li><code>Handlers</code>：处理程序执行 <code>I/O</code> 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code> 通过调度适当的处理程序来响应 <code>I/O</code> 事件，处理程序执行非阻塞操作。</li>
</ol>
<h4 id="5-3-4-Reactor-模式分类"><a href="#5-3-4-Reactor-模式分类" class="headerlink" title="5.3.4 Reactor 模式分类"></a>5.3.4 Reactor 模式分类</h4><p>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现</p>
<ol>
<li>单 <code>Reactor</code> 单线程</li>
<li>单 <code>Reactor</code> 多线程</li>
<li>主从 <code>Reactor</code> 多线程</li>
</ol>
<h3 id="5-4-单-Reactor-单线程"><a href="#5-4-单-Reactor-单线程" class="headerlink" title="5.4 单 Reactor 单线程"></a>5.4 单 Reactor 单线程</h3><p>原理图，并使用 <code>NIO</code> 群聊系统验证</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter05_04.png" alt="img"></p>
<h4 id="5-4-1-方案说明"><a href="#5-4-1-方案说明" class="headerlink" title="5.4.1 方案说明"></a>5.4.1 方案说明</h4><ol>
<li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 <code>API</code>，可以实现应用程序通过一个阻塞对象监听多路连接请求</li>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li>
<li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li>
<li><code>Handler</code> 会完成 <code>Read</code> → 业务处理 → <code>Send</code> 的完整业务流程</li>
</ol>
<p>结合实例：服务器端用一个线程通过多路复用搞定所有的 <code>IO</code> 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 <code>NIO</code> 案例就属于这种模型。</p>
<h4 id="5-4-2-方案优缺点分析"><a href="#5-4-2-方案优缺点分析" class="headerlink" title="5.4.2 方案优缺点分析"></a>5.4.2 方案优缺点分析</h4><ol>
<li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
<li>缺点：性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
<li>使用场景：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code> 在业务处理的时间复杂度 <code>O(1)</code> 的情况</li>
</ol>
<h3 id="5-5-单-Reactor-多线程"><a href="#5-5-单-Reactor-多线程" class="headerlink" title="5.5 单 Reactor 多线程"></a>5.5 单 Reactor 多线程</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_05.png" alt="img"></p>
<h4 id="5-5-1-原理图"><a href="#5-5-1-原理图" class="headerlink" title="5.5.1 原理图"></a>5.5.1 原理图</h4><h4 id="5-5-2-对上图的小结"><a href="#5-5-2-对上图的小结" class="headerlink" title="5.5.2 对上图的小结"></a>5.5.2 对上图的小结</h4><ol>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后，通过 <code>Dispatch</code> 进行分发</li>
<li>如果建立连接请求，则右 <code>Acceptor</code> 通过 <code>accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理</li>
<li><code>handler</code> 只负责响应事件，不做具体的业务处理，通过 <code>read</code> 读取数据后，会分发给后面的 <code>worker</code> 线程池的某个线程处理业务</li>
<li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给 <code>handler</code></li>
<li><code>handler</code> 收到响应后，通过 <code>send</code> 将结果返回给 <code>client</code></li>
</ol>
<h4 id="5-5-3-方案优缺点分析"><a href="#5-5-3-方案优缺点分析" class="headerlink" title="5.5.3 方案优缺点分析"></a>5.5.3 方案优缺点分析</h4><ol>
<li>优点：可以充分的利用多核 <code>cpu</code> 的处理能力</li>
<li>缺点：多线程数据共享和访问比较复杂，<code>Reactor</code> 处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</li>
</ol>
<h3 id="5-6-主从-Reactor-多线程"><a href="#5-6-主从-Reactor-多线程" class="headerlink" title="5.6 主从 Reactor 多线程"></a>5.6 主从 Reactor 多线程</h3><h4 id="5-6-1-工作原理图"><a href="#5-6-1-工作原理图" class="headerlink" title="5.6.1 工作原理图"></a>5.6.1 工作原理图</h4><p>针对单 <code>Reactor</code> 多线程模型中，<code>Reactor</code> 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 <code>Reactor</code> 在多线程中运行</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_06.png" alt="img"></p>
<h4 id="5-6-2-上图的方案说明"><a href="#5-6-2-上图的方案说明" class="headerlink" title="5.6.2 上图的方案说明"></a>5.6.2 上图的方案说明</h4><ol>
<li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件</li>
<li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code></li>
<li><code>subreactor</code> 将连接加入到连接队列进行监听，并创建 <code>handler</code> 进行各种事件处理</li>
<li>当有新事件发生时，<code>subreactor</code> 就会调用对应的 <code>handler</code> 处理</li>
<li><code>handler</code> 通过 <code>read</code> 读取数据，分发给后面的 <code>worker</code> 线程处理</li>
<li><code>worker</code> 线程池分配独立的 <code>worker</code> 线程进行业务处理，并返回结果</li>
<li><code>handler</code> 收到响应的结果后，再通过 <code>send</code> 将结果返回给 <code>client</code></li>
<li><code>Reactor</code> 主线程可以对应多个 <code>Reactor</code> 子线程，即 <code>MainRecator</code> 可以关联多个 <code>SubReactor</code></li>
</ol>
<h4 id="5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解："><a href="#5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解：" class="headerlink" title="5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解："></a>5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解：</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_07.png" alt="img"></p>
<h4 id="5-6-4-方案优缺点说明"><a href="#5-6-4-方案优缺点说明" class="headerlink" title="5.6.4 方案优缺点说明"></a>5.6.4 方案优缺点说明</h4><ol>
<li>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li>
<li>优点：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据。</li>
<li>缺点：编程复杂度较高</li>
<li>结合实例：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li>
</ol>
<h3 id="5-7-Reactor-模式小结"><a href="#5-7-Reactor-模式小结" class="headerlink" title="5.7 Reactor 模式小结"></a>5.7 Reactor 模式小结</h3><h4 id="5-7-1-3-种模式用生活案例来理解"><a href="#5-7-1-3-种模式用生活案例来理解" class="headerlink" title="5.7.1 3 种模式用生活案例来理解"></a>5.7.1 3 种模式用生活案例来理解</h4><ol>
<li>单 <code>Reactor</code> 单线程，前台接待员和服务员是同一个人，全程为顾客服务</li>
<li>单 <code>Reactor</code> 多线程，<code>1</code> 个前台接待员，多个服务员，接待员只负责接待</li>
<li>主从 <code>Reactor</code> 多线程，多个前台接待员，多个服务生</li>
</ol>
<h4 id="5-7-2-Reactor-模式具有如下的优点"><a href="#5-7-2-Reactor-模式具有如下的优点" class="headerlink" title="5.7.2 Reactor 模式具有如下的优点"></a>5.7.2 Reactor 模式具有如下的优点</h4><ol>
<li>响应快，不必为单个同步时间所阻塞，虽然 <code>Reactor</code> 本身依然是同步的</li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li>
<li>扩展性好，可以方便的通过增加 <code>Reactor</code> 实例个数来充分利用 <code>CPU</code> 资源</li>
<li>复用性好，<code>Reactor</code> 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ol>
<h3 id="5-8-Netty-模型"><a href="#5-8-Netty-模型" class="headerlink" title="5.8 Netty 模型"></a>5.8 Netty 模型</h3><h4 id="5-8-1-工作原理示意图-简单版"><a href="#5-8-1-工作原理示意图-简单版" class="headerlink" title="5.8.1 工作原理示意图 - 简单版"></a>5.8.1 工作原理示意图 - 简单版</h4><p>Netty主要基于<code>主从 Reactors</code> 多线程模型（如图）做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 `Reactor</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_08.png" alt="img"></p>
<h4 id="5-8-2-对上图说明"><a href="#5-8-2-对上图说明" class="headerlink" title="5.8.2 对上图说明"></a>5.8.2 对上图说明</h4><ol>
<li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code></li>
<li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护</li>
<li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 <code>handler</code>），注意 <code>handler</code> 已经加入到通道</li>
</ol>
<h4 id="5-8-3-工作原理示意图-进阶版"><a href="#5-8-3-工作原理示意图-进阶版" class="headerlink" title="5.8.3 工作原理示意图 - 进阶版"></a>5.8.3 工作原理示意图 - 进阶版</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_09.png" alt="img"></p>
<h4 id="5-8-4-工作原理示意图-详细版"><a href="#5-8-4-工作原理示意图-详细版" class="headerlink" title="5.8.4 工作原理示意图 - 详细版"></a>5.8.4 工作原理示意图 - 详细版</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_10.png" alt="img"></p>
<h4 id="5-8-5-对上图的说明小结"><a href="#5-8-5-对上图的说明小结" class="headerlink" title="5.8.5 对上图的说明小结"></a>5.8.5 对上图的说明小结</h4><ol>
<li><p><code>Netty</code> 抽象出两组线程池 <code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</p>
</li>
<li><p><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code></p>
</li>
<li><p><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code></p>
</li>
<li><p><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</p>
</li>
<li><p><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code></p>
</li>
<li><p>每个 循环执行的步骤有 <code>BossNioEventLoop``3</code></p>
<ul>
<li>轮询 <code>accept</code> 事件</li>
<li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>worker</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li>
<li>处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li><p>每个 循环执行的步骤<code>Worker``NIOEventLoo</code></p>
<ul>
<li>轮询 <code>read</code>，<code>write</code> 事件</li>
<li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li>
<li>处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li><p>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器</p>
</li>
</ol>
<h4 id="5-8-6-Netty-快速入门实例-TCP-服务"><a href="#5-8-6-Netty-快速入门实例-TCP-服务" class="headerlink" title="5.8.6 Netty 快速入门实例 - TCP 服务"></a>5.8.6 Netty 快速入门实例 - TCP 服务</h4><p>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</p>
<ol>
<li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，客户端能发送消息给服务器”hello,服务器~”</li>
<li>服务器可以回复消息给客户端”hello,客户端~”</li>
<li>目的：对 <code>Netty</code> 线程模型有一个初步认识，便于理解 <code>Netty</code> 模型理论</li>
<li>看老师代码演示 5.1 编写服务端 5.2 编写客户端 5.3 对 <code>netty</code> 程序进行分析，看看 <code>netty</code> 模型特点 说明：创建 <code>Maven</code> 项目，并引入 <code>Netty</code> 包</li>
<li>代码如下</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java">NettyServer.java

<span class="hljs-keyword">package</span> com.atguigu.netty.simple;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFutureListener;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        
        <span class="hljs-comment">//创建BossGroup 和 WorkerGroup</span>
        <span class="hljs-comment">//说明</span>
        <span class="hljs-comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span>
        <span class="hljs-comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span>
        <span class="hljs-comment">//3. 两个都是无限循环</span>
        <span class="hljs-comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span>
        <span class="hljs-comment">//   默认实际 cpu核数 * 2</span>
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8</span>
        
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//创建服务器端的启动对象，配置参数</span>
            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();
            <span class="hljs-comment">//使用链式编程来进行设置</span>
            bootstrap.group(bossGroup, workerGroup) <span class="hljs-comment">//设置两个线程组</span>
                    .channel(NioServerSocketChannel.class) <span class="hljs-comment">//使用NioSocketChannel 作为服务器的通道实现</span>
                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>) <span class="hljs-comment">// 设置线程队列得到连接个数</span>
                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>) <span class="hljs-comment">//设置保持活动连接状态</span>
            <span class="hljs-comment">//          .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span>
                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="hljs-comment">//创建一个通道初始化对象(匿名对象)</span>
                        <span class="hljs-comment">//给pipeline 设置处理器</span>
                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                            System.out.println(<span class="hljs-string">&quot;客户socketchannel hashcode=&quot;</span> + ch.hashCode()); <span class="hljs-comment">//可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue</span>
                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());
                        &#125;
                    &#125;); <span class="hljs-comment">// 给我们的workerGroup 的 EventLoop 对应的管道设置处理器</span>

            System.out.println(<span class="hljs-string">&quot;.....服务器 is ready...&quot;</span>);

            <span class="hljs-comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span>
            <span class="hljs-comment">//启动服务器(并绑定端口)</span>
            ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();

            <span class="hljs-comment">//给cf 注册监听器，监控我们关心的事件</span>

            cf.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                    <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;
                        System.out.println(<span class="hljs-string">&quot;监听端口 6668 成功&quot;</span>);
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        System.out.println(<span class="hljs-string">&quot;监听端口 6668 失败&quot;</span>);
                    &#125;
                &#125;
            &#125;);

            <span class="hljs-comment">//对关闭通道进行监听</span>
            cf.channel().closeFuture().sync();
        &#125;<span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;

NettyServerHandler.java

<span class="hljs-keyword">package</span> com.atguigu.netty.simple;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.Channel;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 说明</span>
<span class="hljs-comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span>
<span class="hljs-comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span>
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span>
<span class="hljs-comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        
        System.out.println(<span class="hljs-string">&quot;服务器读取线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; channle =&quot;</span> + ctx.channel());
        System.out.println(<span class="hljs-string">&quot;server ctx =&quot;</span> + ctx);
        System.out.println(<span class="hljs-string">&quot;看看channel 和 pipeline的关系&quot;</span>);
        Channel channel = ctx.channel();
        ChannelPipeline pipeline = ctx.pipeline(); <span class="hljs-comment">//本质是一个双向链接, 出站入站</span>
        
        <span class="hljs-comment">//将 msg 转成一个 ByteBuf</span>
        <span class="hljs-comment">//ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span>
        ByteBuf buf = (ByteBuf) msg;
        System.out.println(<span class="hljs-string">&quot;客户端发送消息是:&quot;</span> + buf.toString(CharsetUtil.UTF_8));
        System.out.println(<span class="hljs-string">&quot;客户端地址:&quot;</span> + channel.remoteAddress());
    &#125;

    <span class="hljs-comment">//数据读取完毕</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//writeAndFlush 是 write + flush</span>
        <span class="hljs-comment">//将数据写入到缓存，并刷新</span>
        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span>
        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));
    &#125;
    
    <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ctx.close();
    &#125;
&#125;

NettyClient.java

<span class="hljs-keyword">package</span> com.atguigu.netty.simple;

<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//客户端需要一个事件循环组</span>
        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();
        <span class="hljs-keyword">try</span> &#123;
            
            <span class="hljs-comment">//创建客户端启动对象</span>
            <span class="hljs-comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span>
            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();
            <span class="hljs-comment">//设置相关参数</span>
            bootstrap.group(group) <span class="hljs-comment">//设置线程组</span>
                    .channel(NioSocketChannel.class) <span class="hljs-comment">// 设置客户端通道的实现类(反射)</span>
                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler()); <span class="hljs-comment">//加入自己的处理器</span>
                        &#125;
                    &#125;);
            
            System.out.println(<span class="hljs-string">&quot;客户端 ok..&quot;</span>);
            <span class="hljs-comment">//启动客户端去连接服务器端</span>
            <span class="hljs-comment">//关于 ChannelFuture 要分析，涉及到netty的异步模型</span>
            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6668</span>).sync();
            <span class="hljs-comment">//给关闭通道进行监听</span>
            channelFuture.channel().closeFuture().sync();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            group.shutdownGracefully();
        &#125;
    &#125;
&#125;

NettyClientHandler.java

<span class="hljs-keyword">package</span> com.atguigu.netty.simple;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;
<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;
    
    <span class="hljs-comment">//当通道就绪就会触发该方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;client &quot;</span> + ctx);
        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, server: (&gt;^ω^&lt;)喵&quot;</span>, CharsetUtil.UTF_8));
    &#125;

    <span class="hljs-comment">//当通道有读取事件时，会触发</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ByteBuf buf = (ByteBuf) msg;
        System.out.println(<span class="hljs-string">&quot;服务器回复的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));
        System.out.println(<span class="hljs-string">&quot;服务器的地址： &quot;</span> + ctx.channel().remoteAddress());
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        cause.printStackTrace();
        ctx.close();
    &#125;
&#125;</code></pre></div>

<h4 id="5-8-7-任务队列中的-Task-有-3-种典型使用场景"><a href="#5-8-7-任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="5.8.7 任务队列中的 Task 有 3 种典型使用场景"></a>5.8.7 任务队列中的 Task 有 3 种典型使用场景</h4><ol>
<li>用户程序自定义的普通任务【举例说明】</li>
<li>用户自定义定时任务</li>
<li>非当前 <code>Reactor</code> 线程调用 <code>Channel</code> 的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的 <code>Channel</code> 引用，然后调用 <code>Write</code> 类方法向该用户推送消息，就会进入到这种场景。最终的 <code>Write</code> 会提交到任务队列中后被异步消费</li>
<li>代码演示</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.simple;

<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;
<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 说明</span>
<span class="hljs-comment"> * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span>
<span class="hljs-comment"> * 2. 这时我们自定义一个Handler , 才能称为一个handler</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span>

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span>
<span class="hljs-comment">     * 2. Object msg: 就是客户端发送的数据 默认Object</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">// 比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的</span>
        <span class="hljs-comment">// NIOEventLoop 的 taskQueue中,</span>

        <span class="hljs-comment">// 解决方案1 用户程序自定义的普通任务</span>

        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;

                <span class="hljs-keyword">try</span> &#123;
                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);
                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;</span>, CharsetUtil.UTF_8));
                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());
                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;
                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());
                &#125;
            &#125;
        &#125;);

        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;

                <span class="hljs-keyword">try</span> &#123;
                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);
                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵3&quot;</span>, CharsetUtil.UTF_8));
                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());
                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;
                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());
                &#125;
            &#125;
        &#125;);

        <span class="hljs-comment">//解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中</span>

        ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;

                <span class="hljs-keyword">try</span> &#123;
                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);
                    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵4&quot;</span>, CharsetUtil.UTF_8));
                    System.out.println(<span class="hljs-string">&quot;channel code=&quot;</span> + ctx.channel().hashCode());
                &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;
                    System.out.println(<span class="hljs-string">&quot;发生异常&quot;</span> + ex.getMessage());
                &#125;
            &#125;
        &#125;, <span class="hljs-number">5</span>, TimeUnit.SECONDS);

        System.out.println(<span class="hljs-string">&quot;go on ...&quot;</span>);

<span class="hljs-comment">//        System.out.println(&quot;服务器读取线程 &quot; + Thread.currentThread().getName() + &quot; channle =&quot; + ctx.channel());</span>
<span class="hljs-comment">//        System.out.println(&quot;server ctx =&quot; + ctx);</span>
<span class="hljs-comment">//        System.out.println(&quot;看看channel 和 pipeline的关系&quot;);</span>
<span class="hljs-comment">//        Channel channel = ctx.channel();</span>
<span class="hljs-comment">//        ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站</span>
<span class="hljs-comment">//        </span>
<span class="hljs-comment">//        //将 msg 转成一个 ByteBuf</span>
<span class="hljs-comment">//        //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span>
<span class="hljs-comment">//        ByteBuf buf = (ByteBuf) msg;</span>
<span class="hljs-comment">//        System.out.println(&quot;客户端发送消息是:&quot; + buf.toString(CharsetUtil.UTF_8));</span>
<span class="hljs-comment">//        System.out.println(&quot;客户端地址:&quot; + channel.remoteAddress());</span>
    &#125;

    <span class="hljs-comment">//数据读取完毕</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//writeAndFlush 是 write + flush</span>
        <span class="hljs-comment">//将数据写入到缓存，并刷新</span>
        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span>
        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;</span>, CharsetUtil.UTF_8));
    &#125;

    <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ctx.close();
    &#125;
&#125;</code></pre></div>

<h4 id="5-8-8-方案再说明"><a href="#5-8-8-方案再说明" class="headerlink" title="5.8.8 方案再说明"></a>5.8.8 方案再说明</h4><ol>
<li><code>Netty</code> 抽象出两组线程池，<code>BossGroup</code> 专门负责接收客户端连接，<code>WorkerGroup</code> 专门负责网络读写操作。</li>
<li><code>NioEventLoop</code> 表示一个不断循环执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code>网络通道。</li>
<li><code>NioEventLoop</code> 内部采用串行化设计，从消息的 <strong>读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</strong>，始终由 <code>IO</code> 线程 <code>NioEventLoop</code> 负责<code>NioEventLoopGroup</code>下包含多个 <code>NioEventLoop</code></li>
</ol>
<ul>
<li>每个 <code>NioEventLoop</code> 中包含有一个 <code>Selector</code>，一个 <code>taskQueue</code></li>
<li>每个 <code>NioEventLoop</code> 的 <code>Selector</code> 上可以注册监听多个 <code>NioChannel</code></li>
<li>每个 <code>NioChannel</code> 只会绑定在唯一的 <code>NioEventLoop</code> 上</li>
<li>每个 <code>NioChannel</code> 都绑定有一个自己的 <code>ChannelPipeline</code></li>
</ul>
<h3 id="5-9-异步模型"><a href="#5-9-异步模型" class="headerlink" title="5.9 异步模型"></a>5.9 异步模型</h3><h4 id="5-9-1-基本介绍"><a href="#5-9-1-基本介绍" class="headerlink" title="5.9.1 基本介绍"></a>5.9.1 基本介绍</h4><ol>
<li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li>
<li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind、Write、Connect</code> 等操作会简单的返回一个 <code>ChannelFuture</code>。</li>
<li>调用者并不能立刻获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机制获得 <code>IO</code> 操作结果。</li>
<li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code> 返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code> 去监控方法 <code>fun</code> 的处理过程（即：<code>Future-Listener</code> 机制）</li>
</ol>
<h4 id="5-9-2-Future-说明"><a href="#5-9-2-Future-说明" class="headerlink" title="5.9.2 Future 说明"></a>5.9.2 Future 说明</h4><ol>
<li>表示异步的执行结果,可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</li>
<li><code>ChannelFuture</code> 是一个接口：<code>public interface ChannelFuture extends Future&lt;Void&gt;</code> 我们可以添加监听器，当监听的事件发生时，就会通知到监听器。案例说明</li>
</ol>
<h4 id="5-9-3-工作原理示意图"><a href="#5-9-3-工作原理示意图" class="headerlink" title="5.9.3 工作原理示意图"></a>5.9.3 工作原理示意图</h4><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_11.png" alt="img"></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_12.png" alt="img"></p>
<p>说明：</p>
<ol>
<li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用 <code>future</code> 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。</li>
<li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。</li>
</ol>
<h4 id="5-9-4-Future-Listener-机制"><a href="#5-9-4-Future-Listener-机制" class="headerlink" title="5.9.4 Future-Listener 机制"></a>5.9.4 Future-Listener 机制</h4><ol>
<li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li>
<li>常见有如下操作<ul>
<li>通过 <code>isDone</code> 方法来判断当前操作是否完成；</li>
<li>通过 <code>isSuccess</code> 方法来判断已完成的当前操作是否成功；</li>
<li>通过 <code>getCause</code> 方法来获取已完成的当前操作失败的原因；</li>
<li>通过 <code>isCancelled</code> 方法来判断已完成的当前操作是否被取消；</li>
<li>通过 <code>addListener</code> 方法来注册监听器，当操作已完成（<code>isDone</code>方法返回完成），将会通知指定的监听器；如果 <code>Future</code> 对象已完成，则通知指定的监听器</li>
</ul>
</li>
</ol>
<p>举例说明 演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//绑定一个端口并且同步,生成了一个ChannelFuture对象</span>
<span class="hljs-comment">//启动服务器(并绑定端口)</span>
ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();
<span class="hljs-comment">//给cf 注册监听器，监控我们关心的事件</span>
cf.addListener((ChannelFutureListener) future -&gt; &#123;
    <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;
        System.out.println(<span class="hljs-string">&quot;监听端口 6668 成功&quot;</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
        System.out.println(<span class="hljs-string">&quot;监听端口 6668 失败&quot;</span>);
    &#125;
&#125;);</code></pre></div>

<h3 id="5-10-快速入门实例-HTTP服务"><a href="#5-10-快速入门实例-HTTP服务" class="headerlink" title="5.10 快速入门实例 - HTTP服务"></a>5.10 快速入门实例 - HTTP服务</h3><ol>
<li>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</li>
<li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，浏览器发出请求 <code>http://localhost:6668/</code></li>
<li>服务器可以回复消息给客户端”Hello!我是服务器5”,并对特定请求资源进行过滤。</li>
<li>目的：<code>Netty</code> 可以做 <code>Http</code> 服务开发，并且理解 <code>Handler</code> 实例和客户端及其请求的关系。</li>
<li>看老师代码演示</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java">TestServer.java

<span class="hljs-keyword">package</span> com.atguigu.netty.http;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServer</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();

        <span class="hljs-keyword">try</span> &#123;
            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();

            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="hljs-keyword">new</span> TestServerInitializer());

            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">6668</span>).sync();

            channelFuture.channel().closeFuture().sync();

        &#125; <span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;

TestServerInitializer.java

<span class="hljs-keyword">package</span> com.atguigu.netty.http;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//向管道加入处理器</span>

        <span class="hljs-comment">//得到管道</span>
        ChannelPipeline pipeline = ch.pipeline();

        <span class="hljs-comment">//加入一个netty 提供的httpServerCodec codec =&gt;[coder - decoder]</span>
        <span class="hljs-comment">//HttpServerCodec 说明</span>
        <span class="hljs-comment">//1. HttpServerCodec 是netty 提供的处理http的 编-解码器</span>
        pipeline.addLast(<span class="hljs-string">&quot;MyHttpServerCodec&quot;</span>, <span class="hljs-keyword">new</span> HttpServerCodec());
        <span class="hljs-comment">//2. 增加一个自定义的handler</span>
        pipeline.addLast(<span class="hljs-string">&quot;MyTestHttpServerHandler&quot;</span>, <span class="hljs-keyword">new</span> TestHttpServerHandler());

        System.out.println(<span class="hljs-string">&quot;ok~~~~&quot;</span>);
    &#125;
&#125;

TestHttpServerHandler.java

<span class="hljs-keyword">package</span> com.atguigu.netty.http;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.*;
<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;

<span class="hljs-keyword">import</span> java.net.URI;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 说明</span>
<span class="hljs-comment"> * 1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter</span>
<span class="hljs-comment"> * 2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHttpServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">HttpObject</span>&gt; </span>&#123;

    <span class="hljs-comment">//channelRead0 读取客户端数据</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        System.out.println(<span class="hljs-string">&quot;对应的channel=&quot;</span> + ctx.channel() + <span class="hljs-string">&quot; pipeline=&quot;</span> + ctx
                .pipeline() + <span class="hljs-string">&quot; 通过pipeline获取channel&quot;</span> + ctx.pipeline().channel());

        System.out.println(<span class="hljs-string">&quot;当前ctx的handler=&quot;</span> + ctx.handler());

        <span class="hljs-comment">//判断 msg 是不是 httprequest请求</span>
        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> HttpRequest) &#123;

            System.out.println(<span class="hljs-string">&quot;ctx 类型=&quot;</span> + ctx.getClass());

            System.out.println(<span class="hljs-string">&quot;pipeline hashcode&quot;</span> + ctx.pipeline().hashCode() + <span class="hljs-string">&quot; TestHttpServerHandler hash=&quot;</span> + <span class="hljs-keyword">this</span>.hashCode());

            System.out.println(<span class="hljs-string">&quot;msg 类型=&quot;</span> + msg.getClass());
            System.out.println(<span class="hljs-string">&quot;客户端地址&quot;</span> + ctx.channel().remoteAddress());

            <span class="hljs-comment">//获取到</span>
            HttpRequest httpRequest = (HttpRequest) msg;
            <span class="hljs-comment">//获取uri, 过滤指定的资源</span>
            URI uri = <span class="hljs-keyword">new</span> URI(httpRequest.uri());
            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;
                System.out.println(<span class="hljs-string">&quot;请求了 favicon.ico, 不做响应&quot;</span>);
                <span class="hljs-keyword">return</span>;
            &#125;
            <span class="hljs-comment">//回复信息给浏览器 [http协议]</span>

            ByteBuf content = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello, 我是服务器&quot;</span>, CharsetUtil.UTF_8);

            <span class="hljs-comment">//构造一个http的相应，即 httpresponse</span>
            FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);

            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="hljs-string">&quot;text/plain&quot;</span>);
            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());

            <span class="hljs-comment">//将构建好 response返回</span>
            ctx.writeAndFlush(response);

        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="6-Netty-核心模块组件"><a href="#6-Netty-核心模块组件" class="headerlink" title="6 Netty 核心模块组件"></a>6 Netty 核心模块组件</h2><h3 id="6-1-Bootstrap、ServerBootstrap"><a href="#6-1-Bootstrap、ServerBootstrap" class="headerlink" title="6.1 Bootstrap、ServerBootstrap"></a>6.1 Bootstrap、ServerBootstrap</h3><ol>
<li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li>
<li>常见的方法有<ul>
<li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li>
<li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li>
<li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li>
<li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li>
<li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li>
<li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li>
<li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li>
<li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li>
</ul>
</li>
</ol>
<h3 id="6-2-Future、ChannelFuture"><a href="#6-2-Future、ChannelFuture" class="headerlink" title="6.2 Future、ChannelFuture"></a>6.2 Future、ChannelFuture</h3><p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p>
<p>常见的方法有</p>
<ul>
<li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li>
<li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li>
</ul>
<h3 id="6-3-Channel"><a href="#6-3-Channel" class="headerlink" title="6.3 Channel"></a>6.3 Channel</h3><ol>
<li><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</p>
</li>
<li><p>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</p>
</li>
<li><p>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</p>
</li>
<li><p><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</p>
</li>
<li><p>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</p>
</li>
<li><p>支持关联 <code>I/O</code> 操作与对应的处理程序</p>
</li>
<li><p>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code>类型与之对应，常用的<code>Channel</code>类型：</p>
<ul>
<li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li>
<li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li>
<li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li>
</ul>
</li>
</ol>
<h3 id="6-4-Selector"><a href="#6-4-Selector" class="headerlink" title="6.4 Selector"></a>6.4 Selector</h3><ol>
<li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li>
<li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li>
</ol>
<h3 id="6-5-ChannelHandler-及其实现类"><a href="#6-5-ChannelHandler-及其实现类" class="headerlink" title="6.5 ChannelHandler 及其实现类"></a>6.5 ChannelHandler 及其实现类</h3><ol>
<li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li>
<li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li>
<li><code>ChannelHandler</code> 及其实现类一览图（后）</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_01.png" alt="img"></p>
<ol>
<li>我们经常需要自定义一个 <code>Handler</code> 类去继承 <code>ChannelInboundHandlerAdapter</code>，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_02.png" alt="img"></p>
<h3 id="6-6-Pipeline-和-ChannelPipelin"><a href="#6-6-Pipeline-和-ChannelPipelin" class="headerlink" title="6.6 Pipeline 和 ChannelPipelin"></a>6.6 Pipeline 和 ChannelPipelin</h3><p><code>ChannelPipeline</code> 是一个重点：</p>
<ol>
<li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li>
<li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li>
<li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_03.png" alt="img"></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_04.png" alt="img"></p>
<ol>
<li>常用方法 <code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li>
</ol>
<h3 id="6-7-ChannelHandlerContext"><a href="#6-7-ChannelHandlerContext" class="headerlink" title="6.7 ChannelHandlerContext"></a>6.7 ChannelHandlerContext</h3><ol>
<li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li>
<li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</li>
<li>常用方法<ul>
<li><code>ChannelFuture close()</code>，关闭通道</li>
<li><code>ChannelOutboundInvoker flush()</code>，刷新</li>
<li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到</li>
<li><code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</li>
</ul>
</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_05.png" alt="img"></p>
<h3 id="6-8-ChannelOption"><a href="#6-8-ChannelOption" class="headerlink" title="6.8 ChannelOption"></a>6.8 ChannelOption</h3><ol>
<li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li>
<li><code>ChannelOption</code> 参数如下：</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_06.png" alt="img"></p>
<h3 id="6-9-EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#6-9-EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="6.9 EventLoopGroup 和其实现类 NioEventLoopGroup"></a>6.9 EventLoopGroup 和其实现类 NioEventLoopGroup</h3><ol>
<li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，<code>Netty</code> 为了更好的利用多核 <code>CPU</code> 资源，一般会有多个 <code>EventLoop</code> 同时工作，每个 <code>EventLoop</code> 维护着一个 <code>Selector</code> 实例。</li>
<li><code>EventLoopGroup</code> 提供 <code>next</code> 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code> 来处理任务。在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</li>
<li>通常一个服务端口即一个 <code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和一个 <code>EventLoop</code> 线程。<code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_07.png" alt="img"></p>
<ol>
<li>常用方法 <code>public NioEventLoopGroup()</code>，构造方法 <code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li>
</ol>
<h3 id="6-10-Unpooled-类"><a href="#6-10-Unpooled-类" class="headerlink" title="6.10 Unpooled 类"></a>6.10 Unpooled 类</h3><ol>
<li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li>
<li>常用方法如下所示</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_08.png" alt="img"></p>
<ol>
<li>举例说明 <code>Unpooled</code> 获取 <code>Netty</code> 的数据容器 <code>ByteBuf</code> 的基本使用【案例演示】</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_09.png" alt="img"></p>
<p>案例 1</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.buf;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyByteBuf01</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        
        <span class="hljs-comment">//创建一个ByteBuf</span>
        <span class="hljs-comment">//说明</span>
        <span class="hljs-comment">//1. 创建 对象，该对象包含一个数组arr , 是一个byte[10]</span>
        <span class="hljs-comment">//2. 在netty 的buffer中，不需要使用flip 进行反转</span>
        <span class="hljs-comment">//   底层维护了 readerindex 和 writerIndex</span>
        <span class="hljs-comment">//3. 通过 readerindex 和  writerIndex 和  capacity， 将buffer分成三个区域</span>
        <span class="hljs-comment">// 0---readerindex 已经读取的区域</span>
        <span class="hljs-comment">// readerindex---writerIndex ， 可读的区域</span>
        <span class="hljs-comment">// writerIndex -- capacity, 可写的区域</span>
        ByteBuf buffer = Unpooled.buffer(<span class="hljs-number">10</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            buffer.writeByte(i);
        &#125;

        System.out.println(<span class="hljs-string">&quot;capacity=&quot;</span> + buffer.capacity());<span class="hljs-comment">//10</span>
        <span class="hljs-comment">//输出</span>
<span class="hljs-comment">//        for(int i = 0; i&lt;buffer.capacity(); i++) &#123;</span>
<span class="hljs-comment">//            System.out.println(buffer.getByte(i));</span>
<span class="hljs-comment">//        &#125;</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.capacity(); i++) &#123;
            System.out.println(buffer.readByte());
        &#125;
        System.out.println(<span class="hljs-string">&quot;执行完毕&quot;</span>);
    &#125;
&#125;</code></pre></div>

<p>案例 2</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.buf;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;

<span class="hljs-keyword">import</span> java.nio.charset.Charset;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyByteBuf02</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">//创建ByteBuf</span>
        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello,world!&quot;</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));

        <span class="hljs-comment">//使用相关的方法</span>
        <span class="hljs-keyword">if</span> (byteBuf.hasArray()) &#123; <span class="hljs-comment">// true</span>

            <span class="hljs-keyword">byte</span>[] content = byteBuf.array();

            <span class="hljs-comment">//将 content 转成字符串</span>
            System.out.println(<span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));

            System.out.println(<span class="hljs-string">&quot;byteBuf=&quot;</span> + byteBuf);

            System.out.println(byteBuf.arrayOffset()); <span class="hljs-comment">// 0</span>
            System.out.println(byteBuf.readerIndex()); <span class="hljs-comment">// 0</span>
            System.out.println(byteBuf.writerIndex()); <span class="hljs-comment">// 12</span>
            System.out.println(byteBuf.capacity()); <span class="hljs-comment">// 36</span>

            <span class="hljs-comment">//System.out.println(byteBuf.readByte()); //</span>
            System.out.println(byteBuf.getByte(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 104</span>

            <span class="hljs-keyword">int</span> len = byteBuf.readableBytes(); <span class="hljs-comment">//可读的字节数  12</span>
            System.out.println(<span class="hljs-string">&quot;len=&quot;</span> + len);

            <span class="hljs-comment">//使用for取出各个字节</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;
                System.out.println((<span class="hljs-keyword">char</span>) byteBuf.getByte(i));
            &#125;

            <span class="hljs-comment">//按照某个范围读取</span>
            System.out.println(byteBuf.getCharSequence(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));
            System.out.println(byteBuf.getCharSequence(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="6-11-Netty-应用实例-群聊系统"><a href="#6-11-Netty-应用实例-群聊系统" class="headerlink" title="6.11 Netty 应用实例-群聊系统"></a>6.11 Netty 应用实例-群聊系统</h3><p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
<li>目的：进一步理解 <code>Netty</code> 非阻塞网络编程机制</li>
<li>看老师代码演示</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_10.png" alt="img"></p>
<p>代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.*;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port; <span class="hljs-comment">//监听端口</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.port = port;
    &#125;

    <span class="hljs-comment">//编写run方法，处理客户端的请求</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//创建两个线程组</span>
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>

        <span class="hljs-keyword">try</span> &#123;
            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();

            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)
                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)
                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;

                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

                            <span class="hljs-comment">//获取到pipeline</span>
                            ChannelPipeline pipeline = ch.pipeline();
                            <span class="hljs-comment">//向pipeline加入解码器</span>
                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> StringDecoder());
                            <span class="hljs-comment">//向pipeline加入编码器</span>
                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> StringEncoder());
                            <span class="hljs-comment">//加入自己的业务处理handler</span>
                            pipeline.addLast(<span class="hljs-keyword">new</span> GroupChatServerHandler());

                        &#125;
                    &#125;);

            System.out.println(<span class="hljs-string">&quot;netty 服务器启动&quot;</span>);
            ChannelFuture channelFuture = b.bind(port).sync();

            <span class="hljs-comment">//监听关闭</span>
            channelFuture.channel().closeFuture().sync();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-keyword">new</span> GroupChatServer(<span class="hljs-number">7000</span>).run();
    &#125;
&#125;


<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;

<span class="hljs-keyword">import</span> io.netty.channel.Channel;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;
<span class="hljs-keyword">import</span> io.netty.channel.group.ChannelGroup;
<span class="hljs-keyword">import</span> io.netty.channel.group.DefaultChannelGroup;
<span class="hljs-keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;

<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;

    <span class="hljs-comment">//public static List&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;();</span>

    <span class="hljs-comment">//使用一个hashmap 管理</span>
    <span class="hljs-comment">//public static Map&lt;String, Channel&gt; channels = new HashMap&lt;String,Channel&gt;();</span>

    <span class="hljs-comment">//定义一个channle 组，管理所有的channel</span>
    <span class="hljs-comment">//GlobalEventExecutor.INSTANCE) 是全局的事件执行器，是一个单例</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ChannelGroup channelGroup = <span class="hljs-keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);


    <span class="hljs-comment">//handlerAdded 表示连接建立，一旦连接，第一个被执行</span>
    <span class="hljs-comment">//将当前channel 加入到  channelGroup</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        Channel channel = ctx.channel();
        <span class="hljs-comment">//将该客户加入聊天的信息推送给其它在线的客户端</span>
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">        该方法会将 channelGroup 中所有的channel 遍历，并发送 消息，</span>
<span class="hljs-comment">        我们不需要自己遍历</span>
<span class="hljs-comment">         */</span>
        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 加入聊天&quot;</span> + sdf.format(<span class="hljs-keyword">new</span> java.util.Date()) + <span class="hljs-string">&quot; \n&quot;</span>);
        channelGroup.add(channel);


    &#125;

    <span class="hljs-comment">//断开连接, 将xx客户离开信息推送给当前在线的客户</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        Channel channel = ctx.channel();
        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[客户端]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 离开了\n&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;channelGroup size&quot;</span> + channelGroup.size());

    &#125;

    <span class="hljs-comment">//表示channel 处于活动状态, 提示 xx上线</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 上线了~&quot;</span>);
    &#125;

    <span class="hljs-comment">//表示channel 处于不活动状态, 提示 xx离线了</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 离线了~&quot;</span>);
    &#125;

    <span class="hljs-comment">//读取数据</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//获取到当前channel</span>
        Channel channel = ctx.channel();
        <span class="hljs-comment">//这时我们遍历channelGroup, 根据不同的情况，回送不同的消息</span>

        channelGroup.forEach(ch -&gt; &#123;
            <span class="hljs-keyword">if</span> (channel != ch) &#123; <span class="hljs-comment">//不是当前的channel,转发消息</span>
                ch.writeAndFlush(<span class="hljs-string">&quot;[客户]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 发送了消息&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//回显自己发送的消息给自己</span>
                ch.writeAndFlush(<span class="hljs-string">&quot;[自己]发送了消息&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);
            &#125;
        &#125;);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//关闭通道</span>
        ctx.close();
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;

<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.*;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;

<span class="hljs-keyword">import</span> java.util.Scanner;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>&#123;
    
    <span class="hljs-comment">//属性</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.host = host;
        <span class="hljs-keyword">this</span>.port = port;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();

        <span class="hljs-keyword">try</span> &#123;
            
            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap()
                    .group(group)
                    .channel(NioSocketChannel.class)
                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;

                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

                            <span class="hljs-comment">//得到pipeline</span>
                            ChannelPipeline pipeline = ch.pipeline();
                            <span class="hljs-comment">//加入相关handler</span>
                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> StringDecoder());
                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> StringEncoder());
                            <span class="hljs-comment">//加入自定义的handler</span>
                            pipeline.addLast(<span class="hljs-keyword">new</span> GroupChatClientHandler());
                        &#125;
                    &#125;);

            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();
            <span class="hljs-comment">//得到channel</span>
            Channel channel = channelFuture.channel();
            System.out.println(<span class="hljs-string">&quot;-------&quot;</span> + channel.localAddress() + <span class="hljs-string">&quot;--------&quot;</span>);
            <span class="hljs-comment">//客户端需要输入信息，创建一个扫描器</span>
            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);
            <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;
                String msg = scanner.nextLine();
                <span class="hljs-comment">//通过channel 发送到服务器端</span>
                channel.writeAndFlush(msg + <span class="hljs-string">&quot;\r\n&quot;</span>);
            &#125;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            group.shutdownGracefully();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">new</span> GroupChatClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>).run();
    &#125;
&#125;


<span class="hljs-keyword">package</span> com.atguigu.netty.groupchat;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(msg.trim());
    &#125;
&#125;</code></pre></div>

<h3 id="6-12-Netty-心跳检测机制案例"><a href="#6-12-Netty-心跳检测机制案例" class="headerlink" title="6.12 Netty 心跳检测机制案例"></a>6.12 Netty 心跳检测机制案例</h3><p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 心跳检测机制案例,当服务器超过 <code>3</code> 秒没有读时，就提示读空闲</li>
<li>当服务器超过 <code>5</code> 秒没有写操作时，就提示写空闲</li>
<li>实现当服务器超过 <code>7</code> 秒没有读或者写操作时，就提示读写空闲</li>
<li>代码如下：</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.heartbeat;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;
<span class="hljs-keyword">import</span> io.netty.handler.timeout.IdleStateHandler;

<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        
        <span class="hljs-comment">//创建两个线程组</span>
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>
        <span class="hljs-keyword">try</span> &#123;

            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();

            serverBootstrap.group(bossGroup, workerGroup);
            serverBootstrap.channel(NioServerSocketChannel.class);
            serverBootstrap.handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO));
            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;

                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                    ChannelPipeline pipeline = ch.pipeline();
                    <span class="hljs-comment">//加入一个netty 提供 IdleStateHandler</span>
                    <span class="hljs-comment">/*</span>
<span class="hljs-comment">                    说明</span>
<span class="hljs-comment">                    1. IdleStateHandler 是netty 提供的处理空闲状态的处理器</span>
<span class="hljs-comment">                    2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span>
<span class="hljs-comment">                    3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span>
<span class="hljs-comment">                    4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">                    5. 文档说明</span>
<span class="hljs-comment">                    triggers an &#123;@link IdleStateEvent&#125; when a &#123;@link Channel&#125; has not performed</span>
<span class="hljs-comment"> * read, write, or both operation for a while.</span>
<span class="hljs-comment"> *                  6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个handler去处理</span>
<span class="hljs-comment"> *                  通过调用(触发)下一个handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)</span>
<span class="hljs-comment">                     */</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">7000</span>, <span class="hljs-number">7000</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS));
                    <span class="hljs-comment">//加入一个对空闲检测进一步处理的handler(自定义)</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> MyServerHandler());
                &#125;
            &#125;);

            <span class="hljs-comment">//启动服务器</span>
            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();
            channelFuture.channel().closeFuture().sync();

        &#125; <span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;


<span class="hljs-keyword">package</span> com.atguigu.netty.heartbeat;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;
<span class="hljs-keyword">import</span> io.netty.handler.timeout.IdleStateEvent;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evt 事件</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;

            <span class="hljs-comment">//将  evt 向下转型 IdleStateEvent</span>
            IdleStateEvent event = (IdleStateEvent) evt;
            String eventType = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">switch</span> (event.state()) &#123;
                <span class="hljs-keyword">case</span> READER_IDLE:
                    eventType = <span class="hljs-string">&quot;读空闲&quot;</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> WRITER_IDLE:
                    eventType = <span class="hljs-string">&quot;写空闲&quot;</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> ALL_IDLE:
                    eventType = <span class="hljs-string">&quot;读写空闲&quot;</span>;
                    <span class="hljs-keyword">break</span>;
            &#125;
            System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot;--超时时间--&quot;</span> + eventType);
            System.out.println(<span class="hljs-string">&quot;服务器做相应处理..&quot;</span>);

            <span class="hljs-comment">//如果发生空闲，我们关闭通道</span>
            <span class="hljs-comment">// ctx.channel().close();</span>
        &#125;
    &#125;
&#125;</code></pre></div>

<h3 id="6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接"><a href="#6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接" class="headerlink" title="6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接"></a>6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接</h3><p>实例要求：</p>
<ol>
<li><code>Http</code> 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。</li>
<li>要求：实现基于 <code>WebSocket</code> 的长连接的全双工的交互</li>
<li>改变 <code>Http</code> 协议多次请求的约束，实现长连接了，服务器可以发送消息给浏览器</li>
<li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li>
<li>运行界面</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter06_11.png" alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.websocket;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;
<span class="hljs-keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//创建两个线程组</span>
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(); <span class="hljs-comment">//8个NioEventLoop</span>
        <span class="hljs-keyword">try</span> &#123;

            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();

            serverBootstrap.group(bossGroup, workerGroup);
            serverBootstrap.channel(NioServerSocketChannel.class);
            serverBootstrap.handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO));
            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;

                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                    ChannelPipeline pipeline = ch.pipeline();

                    <span class="hljs-comment">//因为基于http协议，使用http的编码和解码器</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> HttpServerCodec());
                    <span class="hljs-comment">//是以块方式写，添加ChunkedWriteHandler处理器</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler());

                    <span class="hljs-comment">/*</span>
<span class="hljs-comment">                    说明</span>
<span class="hljs-comment">                    1. http数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span>
<span class="hljs-comment">                    2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求</span>
<span class="hljs-comment">                     */</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">8192</span>));
                    <span class="hljs-comment">/*</span>
<span class="hljs-comment">                    说明</span>
<span class="hljs-comment">                    1. 对应websocket ，它的数据是以 帧(frame) 形式传递</span>
<span class="hljs-comment">                    2. 可以看到WebSocketFrame 下面有六个子类</span>
<span class="hljs-comment">                    3. 浏览器请求时 ws://localhost:7000/hello 表示请求的uri</span>
<span class="hljs-comment">                    4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws协议 , 保持长连接</span>
<span class="hljs-comment">                    5. 是通过一个 状态码 101</span>
<span class="hljs-comment">                     */</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">&quot;/hello2&quot;</span>));

                    <span class="hljs-comment">//自定义的handler ，处理业务逻辑</span>
                    pipeline.addLast(<span class="hljs-keyword">new</span> MyTextWebSocketFrameHandler());
                &#125;
            &#125;);

            <span class="hljs-comment">//启动服务器</span>
            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();
            channelFuture.channel().closeFuture().sync();

        &#125; <span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.websocket;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;

<span class="hljs-keyword">import</span> java.time.LocalDateTime;

<span class="hljs-comment">//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTextWebSocketFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        System.out.println(<span class="hljs-string">&quot;服务器收到消息 &quot;</span> + msg.text());

        <span class="hljs-comment">//回复消息</span>
        ctx.channel().writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">&quot;服务器时间&quot;</span> + LocalDateTime.now() + <span class="hljs-string">&quot; &quot;</span> + msg.text()));
    &#125;

    <span class="hljs-comment">//当web客户端连接后， 触发方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span>
        System.out.println(<span class="hljs-string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());
        System.out.println(<span class="hljs-string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asShortText());
    &#125;


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        System.out.println(<span class="hljs-string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;异常发生 &quot;</span> + cause.getMessage());
        ctx.close(); <span class="hljs-comment">//关闭连接</span>
    &#125;
&#125;</code></pre></div>

<p>hello.html</p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> socket;</span>
<span class="javascript">    <span class="hljs-comment">//判断当前浏览器是否支持websocket</span></span>
<span class="javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.WebSocket) &#123;</span>
<span class="javascript">        <span class="hljs-comment">//go on</span></span>
<span class="javascript">        socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://localhost:7000/hello2&quot;</span>);</span>
<span class="javascript">        <span class="hljs-comment">//相当于channelRead, ev 收到服务器端回送的消息</span></span>
<span class="javascript">        socket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span>
<span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span>
<span class="javascript">            rt.value = rt.value + <span class="hljs-string">&quot;\n&quot;</span> + ev.data;</span>
        &#125;

<span class="javascript">        <span class="hljs-comment">//相当于连接开启(感知到连接开启)</span></span>
<span class="javascript">        socket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span>
<span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span>
<span class="javascript">            rt.value = <span class="hljs-string">&quot;连接开启了..&quot;</span></span>
        &#125;

<span class="javascript">        <span class="hljs-comment">//相当于连接关闭(感知到连接关闭)</span></span>
<span class="javascript">        socket.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span>

<span class="javascript">            <span class="hljs-keyword">const</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;responseText&quot;</span>);</span>
<span class="javascript">            rt.value = rt.value + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;连接关闭了..&quot;</span></span>
        &#125;
<span class="javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span>
<span class="javascript">        alert(<span class="hljs-string">&quot;当前浏览器不支持websocket&quot;</span>)</span>
    &#125;

<span class="javascript">    <span class="hljs-comment">//发送消息到服务器</span></span>
<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params">message</span>) </span>&#123;</span>
<span class="javascript">        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.socket) &#123; <span class="hljs-comment">//先判断socket是否创建好</span></span>
<span class="javascript">            <span class="hljs-keyword">return</span>;</span>
        &#125;
        if (socket.readyState === WebSocket.OPEN) &#123;
<span class="javascript">            <span class="hljs-comment">//通过socket 发送消息</span></span>
            socket.send(message)
<span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span>
<span class="javascript">            alert(<span class="hljs-string">&quot;连接没有开启&quot;</span>);</span>
        &#125;
    &#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return false&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;发生消息&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send(this.form.message.value)&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;responseText&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;responseText&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;清空内容&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<h2 id="7-Google-Protobuf"><a href="#7-Google-Protobuf" class="headerlink" title="7 Google Protobuf"></a>7 Google Protobuf</h2><h3 id="7-1-编码和解码的基本介绍"><a href="#7-1-编码和解码的基本介绍" class="headerlink" title="7.1 编码和解码的基本介绍"></a>7.1 编码和解码的基本介绍</h3><ol>
<li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码[示意图]</li>
<li><code>codec</code>（编解码器）的组成部分有两个：<code>decoder</code>（解码器）和 <code>encoder</code>（编码器）。<code>encoder</code> 负责把业务数据转换成字节码数据，<code>decoder</code> 负责把字节码数据转换成业务数据</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_01.png" alt="img"></p>
<h3 id="7-2-Netty-本身的编码解码的机制和问题分析"><a href="#7-2-Netty-本身的编码解码的机制和问题分析" class="headerlink" title="7.2 Netty 本身的编码解码的机制和问题分析"></a>7.2 Netty 本身的编码解码的机制和问题分析</h3><ol>
<li><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)</li>
<li><code>Netty</code> 提供的编码器 <code>StringEncoder</code>，对字符串数据进行编码 <code>ObjectEncoder</code>，对Java对象进行编码…</li>
<li><code>Netty</code> 提供的解码器 <code>StringDecoder</code>,对字符串数据进行解码 <code>ObjectDecoder</code>，对 <code>Java</code> 对象进行解码…</li>
<li><code>Netty</code> 本身自带的 <code>ObjectDecoder</code> 和 <code>ObjectEncoder</code> 可以用来实现 <code>POJO</code> 对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，存在如下问题<ul>
<li>无法跨语言</li>
<li>序列化后的体积太大，是二进制编码的5倍多。</li>
<li>序列化性能太低</li>
</ul>
</li>
<li>=&gt;引出新的解决方案[<code>Google</code> 的 <code>Protobuf</code>]</li>
</ol>
<h3 id="7-3-Protobuf"><a href="#7-3-Protobuf" class="headerlink" title="7.3 Protobuf"></a>7.3 Protobuf</h3><ol>
<li><code>Protobuf</code> 基本介绍和使用示意图</li>
<li><code>Protobuf</code> 是 <code>Google</code> 发布的开源项目，全称 <code>Google Protocol Buffers</code>，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 <code>RPC</code> [远程过程调用 <code>remote procedure call</code> ]数据交换格式。目前很多公司 <code>http + json tcp + protobuf</code></li>
<li>参考文档：<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto">https://developers.google.com/protocol-buffers/docs/proto</a> 语言指南</li>
<li><code>Protobuf</code> 是以 <code>message</code> 的方式来管理数据的.</li>
<li>支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的]（支持目前绝大多数语言，例如 <code>C++</code>、<code>C#</code>、<code>Java</code>、<code>python</code> 等）</li>
<li>高性能，高可靠性</li>
<li>使用 <code>protobuf</code> 编译器能自动生成代码，<code>Protobuf</code> 是将类的定义使用 <code>.proto</code> 文件进行描述。说明，在 <code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.ptoto</code> 编写插件.可以让语法高亮。</li>
<li>然后通过 <code>protoc.exe</code> 编译器根据 <code>.proto</code> 自动生成 <code>.java</code> 文件</li>
<li><code>protobuf</code> 使用示意图</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_02.png" alt="img"></p>
<h3 id="7-4-Protobuf-快速入门实例"><a href="#7-4-Protobuf-快速入门实例" class="headerlink" title="7.4 Protobuf 快速入门实例"></a>7.4 Protobuf 快速入门实例</h3><p>编写程序，使用 <code>Protobuf</code> 完成如下功能</p>
<ol>
<li>客户端可以发送一个 <code>StudentPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li>
<li>服务端能接收 <code>StudentPoJo</code> 对象，并显示信息(通过 <code>Protobuf</code> 解码)</li>
<li>具体看老师演示步骤</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java">Student.proto

syntax = <span class="hljs-string">&quot;proto3&quot;</span>; <span class="hljs-comment">//版本</span>
option java_outer_classname = <span class="hljs-string">&quot;StudentPOJO&quot;</span>;<span class="hljs-comment">//生成的外部类名，同时也是文件名</span>
<span class="hljs-comment">//protobuf 使用message 管理数据</span>
message Student &#123; <span class="hljs-comment">//会在 StudentPOJO 外部类生成一个内部类 Student， 他是真正发送的POJO对象</span>
    int32 id = <span class="hljs-number">1</span>; <span class="hljs-comment">// Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值</span>
    string name = <span class="hljs-number">2</span>;
&#125;

编译
protoc.exe--java_out=.Student.proto
将生成的 StudentPOJO 放入到项目使用</code></pre></div>

<h3 id="7-5-Protobuf-快速入门实例-2"><a href="#7-5-Protobuf-快速入门实例-2" class="headerlink" title="7.5 Protobuf 快速入门实例 2"></a>7.5 Protobuf 快速入门实例 2</h3><ol>
<li>编写程序，使用 <code>Protobuf</code> 完成如下功能</li>
<li>客户端可以随机发送 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li>
<li>服务端能接收 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象(需要判断是哪种类型)，并显示信息(通过 <code>Protobuf</code> 解码)</li>
<li>具体看老师演示步骤</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java">Student.proto

syntax = <span class="hljs-string">&quot;proto3&quot;</span>;
option optimize_for = SPEED; <span class="hljs-comment">// 加快解析</span>
option java_package=<span class="hljs-string">&quot;com.atguigu.netty.codec2&quot;</span>;   <span class="hljs-comment">//指定生成到哪个包下</span>
option java_outer_classname=<span class="hljs-string">&quot;MyDataInfo&quot;</span>; <span class="hljs-comment">// 外部类名, 文件名</span>

<span class="hljs-comment">//protobuf 可以使用message 管理其他的message</span>
message MyMessage &#123;

    <span class="hljs-comment">//定义一个枚举类型</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DataType</span> </span>&#123;
        StudentType = <span class="hljs-number">0</span>; <span class="hljs-comment">//在proto3 要求enum的编号从0开始</span>
        WorkerType = <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-comment">//用data_type 来标识传的是哪一个枚举类型</span>
    DataType data_type = <span class="hljs-number">1</span>;

    <span class="hljs-comment">//表示每次枚举类型最多只能出现其中的一个, 节省空间</span>
    oneof dataBody &#123;
        Student student = <span class="hljs-number">2</span>;
        Worker worker = <span class="hljs-number">3</span>;
    &#125;

&#125;


message Student &#123;
    int32 id = <span class="hljs-number">1</span>;<span class="hljs-comment">//Student类的属性</span>
    string name = <span class="hljs-number">2</span>; <span class="hljs-comment">//</span>
&#125;
message Worker &#123;
    string name=<span class="hljs-number">1</span>;
    int32 age=<span class="hljs-number">2</span>;
&#125;</code></pre></div>

<h2 id="8-Netty-编解码器和-Handler-调用机制"><a href="#8-Netty-编解码器和-Handler-调用机制" class="headerlink" title="8 Netty 编解码器和 Handler 调用机制"></a>8 Netty 编解码器和 Handler 调用机制</h2><h3 id="8-1-基本说明"><a href="#8-1-基本说明" class="headerlink" title="8.1 基本说明"></a>8.1 基本说明</h3><ol>
<li><code>Netty</code> 的组件设计：<code>Netty</code> 的主要组件有 <code>Channel</code>、<code>EventLoop</code>、<code>ChannelFuture</code>、<code>ChannelHandler</code>、<code>ChannelPipe</code> 等</li>
<li><code>ChannelHandler</code> 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 <code>ChannelInboundHandler</code> 接口（或 <code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从 <code>ChannelInboundHandler</code> 冲刷数据。业务逻辑通常写在一个或者多个 <code>ChannelInboundHandler</code> 中。<code>ChannelOutboundHandler</code> 原理一样，只不过它是用来处理出站数据的</li>
<li><code>ChannelPipeline</code> 提供了 <code>ChannelHandler</code> 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 <code>pipeline</code> 中的一系列 <code>ChannelOutboundHandler</code>，并被这些 <code>Handler</code> 处理，反之则称为入站的</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_01.png" alt="img"></p>
<h3 id="8-2编码解码器"><a href="#8-2编码解码器" class="headerlink" title="8.2编码解码器"></a>8.2编码解码器</h3><ol>
<li>当 <code>Netty</code> 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 <code>java</code> 对象）；如果是出站消息，它会被编码成字节。</li>
<li><code>Netty</code> 提供一系列实用的编解码器，他们都实现了 <code>ChannelInboundHadnler</code> 或者 <code>ChannelOutboundHandler</code> 接口。在这些类中，<code>channelRead</code> 方法已经被重写了。以入站为例，对于每个从入站 <code>Channel</code> 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 <code>decode()</code> 方法进行解码，并将已经解码的字节转发给 <code>ChannelPipeline</code> 中的下一个 <code>ChannelInboundHandler</code>。</li>
</ol>
<h3 id="8-3-解码器-ByteToMessageDecoder"><a href="#8-3-解码器-ByteToMessageDecoder" class="headerlink" title="8.3 解码器 - ByteToMessageDecoder"></a>8.3 解码器 - ByteToMessageDecoder</h3><ol>
<li>关系继承图</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_02.png" alt="img"></p>
<ol>
<li>由于不可能知道远程节点是否会一次性发送一个完整的信息，<code>tcp</code> 有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理.</li>
<li>一个关于 <code>ByteToMessageDecoder</code> 实例分析</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_03.png" alt="img"></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_04.png" alt="img"></p>
<h3 id="8-4-Netty-的-handler-链的调用机制"><a href="#8-4-Netty-的-handler-链的调用机制" class="headerlink" title="8.4 Netty 的 handler 链的调用机制"></a>8.4 Netty 的 handler 链的调用机制</h3><p>实例要求:</p>
<ol>
<li>使用自定义的编码器和解码器来说明 <code>Netty</code> 的 <code>handler</code> 调用机制 客户端发送 <code>long</code> -&gt; 服务器 服务端发送 <code>long</code> -&gt; 客户端</li>
<li>案例演示</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_05.png" alt="img"></p>
<ol>
<li>结论<ul>
<li>不论解码器 <code>handler</code> 还是编码器 <code>handler</code> 即接收的消息类型必须与待处理的消息类型一致，否则该 <code>handler</code> 不会被执行</li>
<li>在解码器进行数据解码时，需要判断缓存区（<code>ByteBuf</code>）的数据是否足够，否则接收到的结果会期望结果可能不一致</li>
</ul>
</li>
</ol>
<h3 id="8-5-解码器-ReplayingDecoder"><a href="#8-5-解码器-ReplayingDecoder" class="headerlink" title="8.5 解码器 - ReplayingDecoder"></a>8.5 解码器 - ReplayingDecoder</h3><ol>
<li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></li>
<li><code>ReplayingDecoder</code> 扩展了 <code>ByteToMessageDecoder</code> 类，使用这个类，我们不必调用 <code>readableBytes()</code> 方法。参数 <code>S</code> 指定了用户状态管理的类型，其中 <code>Void</code> 代表不需要状态管理</li>
<li>应用实例：使用 <code>ReplayingDecoder</code> 编写解码器，对前面的案例进行简化[案例演示]</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.inboundhandlerandoutboundhandler;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyByteToLongDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyByteToLongDecoder2 被调用&quot;</span>);
        <span class="hljs-comment">//在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断</span>
        out.add(in.readLong());
    &#125;
&#125;</code></pre></div>

<ol start="4">
<li><code>ReplayingDecoder</code>使用方便，但它也有一些局限性：<ul>
<li>并不是所有的 <code>ByteBuf</code> 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>。</li>
<li><code>ReplayingDecoder</code> 在某些情况下可能稍慢于 <code>ByteToMessageDecoder</code>，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li>
</ul>
</li>
</ol>
<h3 id="8-6-其它编解码器"><a href="#8-6-其它编解码器" class="headerlink" title="8.6 其它编解码器"></a>8.6 其它编解码器</h3><p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter08_06.png" alt="img"></p>
<h4 id="8-6-1-其它解码器"><a href="#8-6-1-其它解码器" class="headerlink" title="8.6.1 其它解码器"></a>8.6.1 其它解码器</h4><ol>
<li><code>LineBasedFrameDecoder</code>：这个类在 <code>Netty</code> 内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</li>
<li><code>DelimiterBasedFrameDecoder</code>：使用自定义的特殊字符作为消息的分隔符。</li>
<li><code>HttpObjectDecoder</code>：一个 <code>HTTP</code> 数据的解码器</li>
<li><code>LengthFieldBasedFrameDecoder</code>：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li>
</ol>
<h4 id="8-6-2-其它编码器"><a href="#8-6-2-其它编码器" class="headerlink" title="8.6.2 其它编码器"></a>8.6.2 其它编码器</h4><h3 id="8-7-Log4j-整合到-Netty"><a href="#8-7-Log4j-整合到-Netty" class="headerlink" title="8.7 Log4j 整合到 Netty"></a>8.7 Log4j 整合到 Netty</h3><ol>
<li>在 <code>Maven</code> 中添加对 <code>Log4j</code> 的依赖在 <code>pom.xml</code></li>
</ol>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<ol>
<li>配置 <code>Log4j</code>，在 <code>resources/log4j.properties</code></li>
</ol>
<div class="code-wrapper"><pre><code class="hljs xml">log4j.rootLogger=DEBUG,stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=[%p]%C&#123;1&#125;-%m%n</code></pre></div>

<ol>
<li>演示整合</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_07.png" alt="img"></p>
<h2 id="9-TCP-粘包和拆包及解决方案"><a href="#9-TCP-粘包和拆包及解决方案" class="headerlink" title="9 TCP 粘包和拆包及解决方案"></a>9 TCP 粘包和拆包及解决方案</h2><h3 id="9-1-TCP-粘包和拆包基本介绍"><a href="#9-1-TCP-粘包和拆包基本介绍" class="headerlink" title="9.1 TCP 粘包和拆包基本介绍"></a>9.1 TCP 粘包和拆包基本介绍</h3><ol>
<li><code>TCP</code> 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 <code>socket</code>，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（<code>Nagle</code> 算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的</li>
<li>由于 <code>TCP</code> 无消息保护边界,需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题,看一张图</li>
<li>示意图 <code>TCP</code> 粘包、拆包图解</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter09_01.png" alt="img"></p>
<p>对图的说明: 假设客户端分别发送了两个数据包 <code>D1</code> 和 <code>D2</code> 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p>
<ol>
<li>服务端分两次读取到了两个独立的数据包，分别是 <code>D1</code> 和 <code>D2</code>，没有粘包和拆包</li>
<li>服务端一次接受到了两个数据包，<code>D1</code> 和 <code>D2</code> 粘合在一起，称之为 <code>TCP</code> 粘包</li>
<li>服务端分两次读取到了数据包，第一次读取到了完整的 <code>D1</code> 包和 <code>D2</code> 包的部分内容，第二次读取到了 <code>D2</code> 包的剩余内容，这称之为 <code>TCP</code> 拆包</li>
<li>服务端分两次读取到了数据包，第一次读取到了 <code>D1</code> 包的部分内容 <code>D1_1</code>，第二次读取到了 <code>D1</code> 包的剩余部分内容 <code>D1_2</code> 和完整的 <code>D2</code> 包。</li>
</ol>
<h3 id="9-2-TCP-粘包和拆包现象实例"><a href="#9-2-TCP-粘包和拆包现象实例" class="headerlink" title="9.2 TCP 粘包和拆包现象实例"></a>9.2 TCP 粘包和拆包现象实例</h3><p>在编写 <code>Netty</code> 程序时，如果没有做处理，就会发生粘包和拆包的问题</p>
<p>看一个具体的实例：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 核心代码</span>

MyClientHandler.java

<span class="hljs-keyword">package</span> com.atguigu.netty.tcp;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;

<span class="hljs-keyword">import</span> java.nio.charset.Charset;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//使用客户端发送10条数据 hello,server 编号</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;
            ByteBuf buffer = Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello,server &quot;</span> + i, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));
            ctx.writeAndFlush(buffer);
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[msg.readableBytes()];
        msg.readBytes(buffer);

        String message = <span class="hljs-keyword">new</span> String(buffer, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));
        System.out.println(<span class="hljs-string">&quot;客户端接收到消息=&quot;</span> + message);
        System.out.println(<span class="hljs-string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));

    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        cause.printStackTrace();
        ctx.close();
    &#125;
&#125;

MyServerHandler.java

<span class="hljs-keyword">package</span> com.atguigu.netty.tcp;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;

<span class="hljs-keyword">import</span> java.nio.charset.Charset;
<span class="hljs-keyword">import</span> java.util.UUID;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//cause.printStackTrace();</span>
        ctx.close();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[msg.readableBytes()];
        msg.readBytes(buffer);

        <span class="hljs-comment">//将buffer转成字符串</span>
        String message = <span class="hljs-keyword">new</span> String(buffer, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));

        System.out.println(<span class="hljs-string">&quot;服务器接收到数据 &quot;</span> + message);
        System.out.println(<span class="hljs-string">&quot;服务器接收到消息量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));

        <span class="hljs-comment">//服务器回送数据给客户端, 回送一个随机id ,</span>
        ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="hljs-string">&quot; &quot;</span>, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));
        ctx.writeAndFlush(responseByteBuf);

    &#125;
&#125;</code></pre></div>

<h3 id="9-3-TCP-粘包和拆包解决方案"><a href="#9-3-TCP-粘包和拆包解决方案" class="headerlink" title="9.3 TCP 粘包和拆包解决方案"></a>9.3 TCP 粘包和拆包解决方案</h3><ol>
<li>使用自定义协议+编解码器来解决</li>
<li>关键就是要解决服务器端每次读取数据长度的问题，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 <code>TCP</code> 粘包、拆包。</li>
</ol>
<h3 id="9-4-看一个具体的实例"><a href="#9-4-看一个具体的实例" class="headerlink" title="9.4 看一个具体的实例"></a>9.4 看一个具体的实例</h3><ol>
<li>要求客户端发送 <code>5</code> 个 <code>Message</code> 对象，客户端每次发送一个 <code>Message</code> 对象</li>
<li>服务器端每次接收一个 <code>Message</code>，分 <code>5</code> 次进行解码，每读取到一个 <code>Message</code>，会回复一个 <code>Message</code> 对象给客户端。</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter09_02.png" alt="img"></p>
<ol>
<li>代码演示，全部代码核心</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 核心</span>

<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;

<span class="hljs-comment">//协议包</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProtocol</span> </span>&#123;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> len; <span class="hljs-comment">//关键</span>
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] content;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> len;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.len = len;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getContent() &#123;
        <span class="hljs-keyword">return</span> content;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] content)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.content = content;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;

<span class="hljs-keyword">import</span> java.nio.charset.Charset;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//使用客户端发送10条数据 &quot;今天天气冷，吃火锅&quot; 编号</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;
            String mes = <span class="hljs-string">&quot;今天天气冷，吃火锅&quot;</span>;
            <span class="hljs-keyword">byte</span>[] content = mes.getBytes(Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>));
            <span class="hljs-keyword">int</span> length = mes.getBytes(Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)).length;

            <span class="hljs-comment">//创建协议包对象</span>
            MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();
            messageProtocol.setLen(length);
            messageProtocol.setContent(content);
            ctx.writeAndFlush(messageProtocol);
        &#125;
    &#125;

    <span class="hljs-comment">//    @Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-keyword">int</span> len = msg.getLen();
        <span class="hljs-keyword">byte</span>[] content = msg.getContent();

        System.out.println(<span class="hljs-string">&quot;客户端接收到消息如下&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + len);
        System.out.println(<span class="hljs-string">&quot;内容=&quot;</span> + <span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));

        System.out.println(<span class="hljs-string">&quot;客户端接收消息数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;异常消息=&quot;</span> + cause.getMessage());
        ctx.close();
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyMessageEncoder encode 方法被调用&quot;</span>);
        out.writeInt(msg.getLen());
        out.writeBytes(msg.getContent());
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;

<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot;MyMessageDecoder decode 被调用&quot;</span>);
        <span class="hljs-comment">//需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)</span>
        <span class="hljs-keyword">int</span> length = in.readInt();

        <span class="hljs-keyword">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];
        in.readBytes(content);

        <span class="hljs-comment">//封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理</span>
        MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();
        messageProtocol.setLen(length);
        messageProtocol.setContent(content);
        out.add(messageProtocol);
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.protocoltcp;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;

<span class="hljs-keyword">import</span> java.nio.charset.Charset;
<span class="hljs-keyword">import</span> java.util.UUID;


<span class="hljs-comment">//处理业务的handler</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>&#123;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//cause.printStackTrace();</span>
        ctx.close();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//接收到数据，并处理</span>
        <span class="hljs-keyword">int</span> len = msg.getLen();
        <span class="hljs-keyword">byte</span>[] content = msg.getContent();

        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println(<span class="hljs-string">&quot;服务器接收到信息如下&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + len);
        System.out.println(<span class="hljs-string">&quot;内容=&quot;</span> + <span class="hljs-keyword">new</span> String(content, Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>)));

        System.out.println(<span class="hljs-string">&quot;服务器接收到消息包数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));

        <span class="hljs-comment">//回复消息</span>
        String responseContent = UUID.randomUUID().toString();
        <span class="hljs-keyword">int</span> responseLen = responseContent.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>).length;
        <span class="hljs-keyword">byte</span>[] responseContent2 = responseContent.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);
        <span class="hljs-comment">//构建一个协议包</span>
        MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();
        messageProtocol.setLen(responseLen);
        messageProtocol.setContent(responseContent2);

        ctx.writeAndFlush(messageProtocol);
    &#125;
&#125;</code></pre></div>

<h2 id="10-Netty-核心源码剖析"><a href="#10-Netty-核心源码剖析" class="headerlink" title="10 Netty 核心源码剖析"></a>10 Netty 核心源码剖析</h2><h3 id="10-1-基本说明"><a href="#10-1-基本说明" class="headerlink" title="10.1 基本说明"></a>10.1 基本说明</h3><ol>
<li>只有看过 <code>Netty</code> 源码，才能说是真的掌握了 <code>Netty</code> 框架。</li>
<li>在 <code>io.netty.example</code> 包下，有很多 <code>Netty</code> 源码案例，可以用来分析。</li>
<li>源码分析章节是针对有 <code>Java</code> 项目经验，并且玩过框架源码的人员讲的，否则你听起来会有相当的难度。</li>
</ol>
<h3 id="10-2-Netty-启动过程源码剖析"><a href="#10-2-Netty-启动过程源码剖析" class="headerlink" title="10.2 Netty 启动过程源码剖析"></a>10.2 Netty 启动过程源码剖析</h3><h4 id="10-2-1-源码剖析目的"><a href="#10-2-1-源码剖析目的" class="headerlink" title="10.2.1 源码剖析目的"></a>10.2.1 源码剖析目的</h4><p>用源码分析的方式走一下 <code>Netty</code>（服务器）的启动过程，更好的理解 <code>Netty</code> 的整体设计和运行机制。</p>
<h4 id="10-2-2-源码剖析"><a href="#10-2-2-源码剖析" class="headerlink" title="10.2.2 源码剖析"></a>10.2.2 源码剖析</h4><p>说明：</p>
<ol>
<li>源码需要剖析到 <code>Netty</code> 调用 <code>doBind</code> 方法，追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>。</li>
<li>并且要 <code>Debug</code> 程序到 <code>NioEventLoop</code> 类的 <code>run</code> 代码，无限循环，在服务器端运行。</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_01.png" alt="img"></p>
<h4 id="10-2-3-源码剖析过程"><a href="#10-2-3-源码剖析过程" class="headerlink" title="10.2.3 源码剖析过程"></a>10.2.3 源码剖析过程</h4><p><strong>1. <code>demo</code> 源码的基本理解</strong></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 服务器启动类源码</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * Copyright 2012 The Netty Project</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * The Netty Project licenses this file to you under the Apache License,</span>
<span class="hljs-comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span>
<span class="hljs-comment"> * with the License. You may obtain a copy of the License at:</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="hljs-comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="hljs-comment"> * License for the specific language governing permissions and limitations</span>
<span class="hljs-comment"> * under the License.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">package</span> atguigu.netty.example.echo2;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LogLevel;
<span class="hljs-keyword">import</span> io.netty.handler.logging.LoggingHandler;
<span class="hljs-keyword">import</span> io.netty.handler.ssl.SslContext;
<span class="hljs-keyword">import</span> io.netty.handler.ssl.SslContextBuilder;
<span class="hljs-keyword">import</span> io.netty.handler.ssl.util.SelfSignedCertificate;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Echoes back any received data from a client.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> SSL = System.getProperty(<span class="hljs-string">&quot;ssl&quot;</span>) != <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>));

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">// Configure SSL.</span>
        <span class="hljs-keyword">final</span> SslContext sslCtx;
        <span class="hljs-keyword">if</span> (SSL) &#123;
            SelfSignedCertificate ssc = <span class="hljs-keyword">new</span> SelfSignedCertificate();
            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
        &#125; <span class="hljs-keyword">else</span> &#123;
            sslCtx = <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-comment">// Configure the server.</span>
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();
        <span class="hljs-keyword">try</span> &#123;
            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)
                    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))
                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                            ChannelPipeline p = ch.pipeline();
                            <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;
                                p.addLast(sslCtx.newHandler(ch.alloc()));
                            &#125;
                            <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>
                            p.addLast(<span class="hljs-keyword">new</span> EchoServerHandler());
                        &#125;
                    &#125;);

            <span class="hljs-comment">// Start the server.</span>
            ChannelFuture f = b.bind(PORT).sync();

            <span class="hljs-comment">// Wait until the server socket is closed.</span>
            f.channel().closeFuture().sync();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// Shut down all event loops to terminate all threads.</span>
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>说明：</p>
<ol>
<li>先看启动类：<code>main</code> 方法中，首先创建了关于 SSL 的配置类。</li>
<li>重点分析下创建了两个 <code>EventLoopGroup</code> 对象：</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java">EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();</code></pre></div>

<p>(1) 这两个对象是整个 <code>Netty</code> 的核心对象，可以说，整个 <code>Netty</code> 的运作都依赖于他们。<code>bossGroup</code> 用于接受 <code>TCP</code> 请求，他会将请求交给 <code>workerGroup</code>，<code>workerGroup</code> 会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作。</p>
<p>(2) <code>EventLoopGroup</code> 是事件循环组（线程组）含有多个 <code>EventLoop</code>，可以注册 <code>channel</code>，用于在事件循环中去进行选择（和选择器相关）。【debug看】</p>
<p>(3) <code>new NioEventLoopGroup(1);</code> 这个 <code>1</code> 表示 <code>bossGroup</code> 事件组有 <code>1</code> 个线程你可以指定，如果 <code>new NioEventLoopGroup()</code> 会含有默认个线程 <code>cpu核数 * 2</code>，即可以充分的利用多核的优势，【可以dubug一把】</p>
<div class="code-wrapper"><pre><code class="hljs java">DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));</code></pre></div>

<p>会创建 <code>EventExecutor</code> 数组 <code>children = new EventExecutor[nThreads];</code> // <code>debug</code> 一下每个元素的类型就是 <code>NIOEventLoop</code>，<code>NIOEventLoop</code> 实现了 <code>EventLoop</code> 接口和 <code>Executor</code> 接口 <code>try</code> 块中创建了一个 <code>ServerBootstrap</code> 对象，他是一个引导类，用于启动服务器和引导整个程序的初始化（看下源码 <code>allowseasybootstrapof&#123;@linkServerChannel&#125;</code>）。它和 <code>ServerChannel</code> 关联，而 <code>ServerChannel</code> 继承了 <code>Channel</code>，有一些方法 <code>remoteAddress</code> 等[可以Debug下]随后，变量 <code>b</code> 调用了 <code>group</code> 方法将两个 <code>group</code> 放入了自己的字段中，用于后期引导使用【<code>debug</code> 下 <code>group</code> 方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> *Set the &#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125; for the parent (acceptor) and the child (client) . These</span>
<span class="hljs-comment"> *&#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125;&#x27;s are used to handle all the events and IO for &#123;<span class="hljs-doctag">@link</span> ServerChannel&#125; and </span>
<span class="hljs-comment"> *&#123;<span class="hljs-doctag">@link</span> Channel&#125;&#x27;s.</span>
<span class="hljs-comment"> */</span></code></pre></div>

<p>】。</p>
<p>(4) 然后添加了一个 <code>channel</code>，其中参数一个 <code>Class</code> 对象，引导类将通过这个 <code>Class</code> 对象反射创建 <code>ChannelFactory</code>。然后添加了一些 <code>TCP</code> 的参数。【说明：<code>Channel</code> 的创建在 <code>bind</code> 方法，可以 <code>Debug</code> 下 <code>bind</code>，会找到 <code>channel = channelFactory.newChannel();</code> 】</p>
<p>(5) 再添加了一个服务器专属的日志处理器 <code>handler</code> 。</p>
<p>(6) 再添加一个 <code>SocketChannel</code>（不是 <code>ServerSocketChannel</code>）的 <code>handler</code>。</p>
<p>(7) 然后绑定端口并阻塞至连接成功。</p>
<p>(8) 最后 <code>main</code> 线程阻塞等待关闭。</p>
<p>(9) <code>finally</code> 块中的代码将在服务器关闭时优雅关闭所有资源。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> * Copyright 2012 The Netty Project</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * The Netty Project licenses this file to you under the Apache License,</span>
<span class="hljs-comment"> * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance</span>
<span class="hljs-comment"> * with the License. You may obtain a copy of the License at:</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="hljs-comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="hljs-comment"> * License for the specific language governing permissions and limitations</span>
<span class="hljs-comment"> * under the License.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">package</span> atguigu.netty.example.echo2;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandler.Sharable;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Handler implementation for the echo server.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Sharable</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;
        ctx.write(msg);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
        ctx.flush();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;
        <span class="hljs-comment">// Close the connection when an exception is raised.</span>
        cause.printStackTrace();
        ctx.close();
    &#125;
&#125;</code></pre></div>

<p>说明:</p>
<ol>
<li>这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端。</li>
<li>大致讲解了我们的 <code>demo</code> 源码的作用。后面的 <code>debug</code> 的时候会详细。</li>
</ol>
<p><strong>2. 分析 EventLoopGroup 的过程</strong></p>
<p>2.1 构造器方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123; 
    <span class="hljs-keyword">this</span>(nThreads, (Executor) <span class="hljs-keyword">null</span>);
&#125;</code></pre></div>

<p>2.2 上面的 <code>this(nThreads, (Executor) null);</code> 调用构造器（通过 <code>alt + d</code> 看即可）</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor)</span> </span>&#123;
    <span class="hljs-keyword">this</span>(nThreads, executor, SelectorProvider.provider());
&#125;</code></pre></div>

<p>2.3 上面的 <code>this(nThreads, executor, SelectorProvider.provider());</code> 调用下面构造器</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider)</span> </span>&#123;
    <span class="hljs-keyword">this</span>(nThreads, executor, selectorProvider,DefaultSelectStrategyFactory.INSTANCE);
&#125;</code></pre></div>

<p>2.4 上面的 <code>this()...</code> 调用构造器（<code>alt + d</code>）</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, <span class="hljs-keyword">final</span> SelectorProvider selectorProvider,<span class="hljs-keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;
    <span class="hljs-keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());
&#125;</code></pre></div>

<p>2.5 上面的 <code>super()..</code> 的方法是父类：<code>MultithreadEventLoopGroup</code></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventLoopGroup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor, Object...args)</span> </span>&#123;
    <span class="hljs-keyword">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
&#125;</code></pre></div>

<p>2.6 追踪到源码抽象类 <code>MultithreadEventExecutorGroup</code> 的构造器方法 <code>MultithreadEventExecutorGroup</code> 才是 <code>NioEventLoopGroup</code> 真正的构造方法，这里可以看成是一个模板方法，使用了设计模式的模板模式（可看我录制视频），所以，我们就需要好好分析 <code>MultithreadEventExecutorGroup</code> 方法了</p>
<p>2.7 分析 <code>MultithreadEventExecutorGroup</code></p>
<p>参数说明：</p>
<ul>
<li><code>@param nThreads</code> 使用的线程数，默认为 <code>core * 2</code>【可以追踪源码】</li>
<li><code>@param executor</code> 执行器:如果传入 <code>null</code>, 则采用 <code>Netty</code> 默认的线程工厂和默认的执行器 <code>ThreadPerTaskExecutor</code></li>
<li><code>@param chooserFactory</code> 单例 <code>new DefaultEventExecutorChooserFactory()</code></li>
<li><code>@param args args</code> 在创建执行器的时候传入固定参数</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, Executor executor,</span></span>
<span class="hljs-function"><span class="hljs-params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (nThreads &lt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));
    &#125;

    <span class="hljs-keyword">if</span> (executor == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果传入的执行器是空的则采用默认的线程工厂和默认的执行器</span>
        executor = <span class="hljs-keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());
    &#125;

    <span class="hljs-comment">// 创建指定线程数的执行器数组</span>
    children = <span class="hljs-keyword">new</span> EventExecutor[nThreads];

    <span class="hljs-comment">// 初始化线程数组</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;
        <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// 创建 new NioEventLoop</span>
            children[i] = newChild(executor, args);
            success = <span class="hljs-keyword">true</span>;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">// 如果创建失败，优雅关闭</span>
            <span class="hljs-keyword">if</span> (!success) &#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;
                    children[j].shutdownGracefully();
                &#125;

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;
                    EventExecutor e = children[j];
                    <span class="hljs-keyword">try</span> &#123;
                        <span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;
                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                        &#125;
                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;
                        <span class="hljs-comment">// Let the caller handle the interruption.</span>
                        Thread.currentThread().interrupt();
                        <span class="hljs-keyword">break</span>;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;

    chooser = chooserFactory.newChooser(children);

    <span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> FutureListener&lt;Object&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
            <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;
                terminationFuture.setSuccess(<span class="hljs-keyword">null</span>);
            &#125;
        &#125;
    &#125;;
    
    <span class="hljs-comment">// 为每一个单例线程池添加一个关闭监听器</span>
    <span class="hljs-keyword">for</span> (EventExecutor e: children) &#123;
        e.terminationFuture().addListener(terminationListener);
    &#125;

    Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);
    <span class="hljs-comment">//将所有的单例线程池添加到一个 HashSet 中。</span>
    Collections.addAll(childrenSet, children);
    readonlyChildren = Collections.unmodifiableSet(childrenSet);
&#125;</code></pre></div>

<p>说明：</p>
<ol>
<li>如果 <code>executor</code> 是 <code>null</code>，创建一个默认的 <code>ThreadPerTaskExecutor</code>，使用 <code>Netty</code> 默认的线程工厂。</li>
<li>根据传入的线程数（<code>CPU * 2</code>）创建一个线程池（单例线程池）数组。</li>
<li>循环填充数组中的元素。如果异常，则关闭所有的单例线程池。</li>
<li>根据线程选择工厂创建一个线程选择器。</li>
<li>为每一个单例线程池添加一个关闭监听器。</li>
<li>将所有的单例线程池添加到一个 <code>HashSet</code> 中。</li>
</ol>
<p><strong>3. ServerBootstrap 创建和构造过程</strong></p>
<p>3.1 <code>ServerBootstrap</code> 是个空构造，但是有默认的成员变量</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="hljs-keyword">new</span> LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();

<span class="hljs-comment">// config 对象，会在后面起很大作用</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerBootstrapConfig config = <span class="hljs-keyword">new</span> ServerBootstrapConfig(<span class="hljs-keyword">this</span>);
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> EventLoopGroup childGroup;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ChannelHandler childHandler;</code></pre></div>

<p>3.2 分析一下 <code>ServerBootstrap</code> 基本使用情况</p>
<div class="code-wrapper"><pre><code class="hljs java">ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();
b.group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)
        .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))
        .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                ChannelPipeline p = ch.pipeline();
                <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;
                    p.addLast(sslCtx.newHandler(ch.alloc()));
                &#125;
                <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>
                p.addLast(<span class="hljs-keyword">new</span> EchoServerHandler());
            &#125;
        &#125;);</code></pre></div>

<p>说明:</p>
<ol>
<li>链式调用：<code>group</code> 方法，将 <code>boss</code> 和 <code>worker</code> 传入，<code>boss</code> 赋值给 <code>parentGroup</code> 属性, <code>worker</code> 赋值给 <code>childGroup</code> 属性。</li>
<li><code>channel</code> 方法传入 <code>NioServerSocketChannelclass</code> 对象。会根据这个 <code>class</code> 创建 <code>channel</code> 对象。</li>
<li><code>option</code> 方法传入 <code>TCP</code> 参数，放在一个 <code>LinkedHashMap</code> 中。</li>
<li><code>handler</code> 方法传入一个 <code>handler</code> 中，这个 <code>hanlder</code> 只专属于 <code>ServerSocketChannel</code> 而不是 <code>SocketChannel</code>。</li>
<li><code>childHandler</code> 传入一个 <code>hanlder</code>，这个 <code>handler</code> 将会在每个客户端连接的时候调用。供 <code>SocketChannel</code> 使用。</li>
</ol>
<p><strong>4. 绑定端口的分析</strong></p>
<p>4.1 服务器就是在这个 <code>bind</code> 方法里启动完成的 4.2 <code>bind</code> 方法代码,追踪到创建了一个端口对象，并做了一些空判断，核心代码 <code>doBind</code>，我们看看</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;
    validate();
    <span class="hljs-keyword">if</span> (localAddress == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;localAddress&quot;</span>);
    &#125;
    <span class="hljs-keyword">return</span> doBind(localAddress);
&#125;</code></pre></div>

<p>4.3 <code>doBind</code> 源码剖析，核心是两个方法 <code>initAndRegister</code> 和 <code>doBind0</code></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> </span>&#123;
    <span class="hljs-keyword">final</span> ChannelFuture regFuture = initAndRegister();
    <span class="hljs-keyword">final</span> Channel channel = regFuture.channel();
    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">return</span> regFuture;
    &#125;

    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;
        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span>
        ChannelPromise promise = channel.newPromise();
        <span class="hljs-comment">//============================================</span>
        <span class="hljs-comment">//说明:执行doBind0方法，完成对端口的绑定</span>
        <span class="hljs-comment">//============================================</span>
        doBind0(regFuture, channel, localAddress, promise);
        <span class="hljs-keyword">return</span> promise;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span>
        <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);
        regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                Throwable cause = future.cause();
                <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span>
                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span>
                    promise.setFailure(cause);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span>
                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span>
                    promise.registered();

                    doBind0(regFuture, channel, localAddress, promise);
                &#125;
            &#125;
        &#125;);
        <span class="hljs-keyword">return</span> promise;
    &#125;
&#125;</code></pre></div>

<p>4.4 分析说明 <code>initAndRegister</code></p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">initAndRegister</span><span class="hljs-params">()</span> </span>&#123;
    Channel channel = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> &#123;
        channel = channelFactory.newChannel();

        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * 说明：channelFactory.newChannel() 方法的作用通过 ServerBootstrap 的通道工厂反射创建一个 NioServerSocketChannel,具体追踪源码可以得到下面结论</span>
<span class="hljs-comment">         * (1)通过 NIO 的 SelectorProvider 的 openServerSocketChannel 方法得到 JDK 的 channel。目的是让 Netty 包装 JDK 的 channel。</span>
<span class="hljs-comment">         * (2)创建了一个唯一的 ChannelId，创建了一个 NioMessageUnsafe，用于操作消息，创建了一个 DefaultChannelPipeline 管道，是个双向链表结构，用于过滤所有的进出的消息。</span>
<span class="hljs-comment">         * (3)创建了一个 NioServerSocketChannelConfig 对象，用于对外展示一些配置。 </span>
<span class="hljs-comment">         </span>
<span class="hljs-comment">         * channel = channelFactory.newChannel();//NioServerSocketChannel</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">         * 说明：init 初始化这个 NioServerSocketChannel，具体追踪源码可以得到如下结论</span>
<span class="hljs-comment">         * (1) init 方法，这是个抽象方法 (AbstractBootstrap类的），由ServerBootstrap实现（可以追一下源码//setChannelOptions(channel,options,logger);）。</span>
<span class="hljs-comment">         * (2)设置 NioServerSocketChannel 的 TCP 属性。</span>
<span class="hljs-comment">         * (3)由于 LinkedHashMap 是非线程安全的，使用同步进行处理。</span>
<span class="hljs-comment">         * (4)对 NioServerSocketChannel 的 ChannelPipeline 添加 ChannelInitializer 处理器。</span>
<span class="hljs-comment">         * (5)可以看出，init 的方法的核心作用在和 ChannelPipeline 相关。</span>
<span class="hljs-comment">         * (6)从 NioServerSocketChannel 的初始化过程中，我们知道，pipeline 是一个双向链表，并且，他本身就初始化了 head 和 tail，这里调用了他的 addLast 方法，也就是将整个 handler 插入到 tail 的前面，因为 tail 永远会在后面，需要做一些系统的固定工作。</span>
<span class="hljs-comment">         */</span>
        init(channel);
    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
        <span class="hljs-keyword">if</span> (channel != <span class="hljs-keyword">null</span>) &#123;
            channel.unsafe().closeForcibly();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    &#125;

    ChannelFuture regFuture = config().group().register(channel);
    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;
            channel.close();
        &#125; <span class="hljs-keyword">else</span> &#123;
            channel.unsafe().closeForcibly();
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> regFuture;
&#125;</code></pre></div>

<p>说明：</p>
<ol>
<li>基本说明：<code>initAndRegister()</code> 初始化 <code>NioServerSocketChannel</code> 通道并注册各个 <code>handler</code>，返回一个 <code>future</code>。</li>
<li>通过 <code>ServerBootstrap</code> 的通道工厂反射创建一个 <code>NioServerSocketChannel</code>。</li>
<li><code>init</code> 初始化这个 <code>NioServerSocketChannel</code>。</li>
<li><code>config().group().register(channel)</code> 通过 <code>ServerBootstrap</code> 的 <code>bossGroup</code> 注册 <code>NioServerSocketChannel</code>。</li>
<li>最后，返回这个异步执行的占位符即 <code>regFuture</code>。</li>
</ol>
<p>4.5 <code>init</code> 方法会调用 <code>addLast</code>，现在进入到 <code>addLast</code> 方法内查看</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;
    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
        checkMultiplicity(handler);
        newCtx = newContext(group, filterName(name, handler), handler);
        addLast0(newCtx);
        <span class="hljs-keyword">if</span> (!registered) &#123;
            newCtx.setAddPending();
            callHandlerCallbackLater(newCtx, <span class="hljs-keyword">true</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        &#125;
        EventExecutor executor = newCtx.executor();
        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;
            callHandlerAddedInEventLoop(newCtx, executor);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        &#125;
    &#125;
    callHandlerAdded0(newCtx);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre></div>

<p>说明：</p>
<ol>
<li><code>addLast</code> 方法，在 <code>DefaultChannelPipeline</code> 类中</li>
<li><code>addLast</code> 方法这就是 <code>pipeline</code> 方法的核心</li>
<li>检查该 <code>handler</code> 是否符合标准。</li>
<li>创建一个 <code>AbstractChannelHandlerContext</code> 对象，这里说一下，<code>ChannelHandlerContext</code> 对象是 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的关联，每当有 <code>ChannelHandler</code> 添加到 <code>Pipeline</code> 中时，都会创建 <code>Context</code>。<code>Context</code> 的主要功能是管理他所关联的 <code>Handler</code> 和同一个 <code>Pipeline</code> 中的其他 <code>Handler</code> 之间的交互。</li>
<li>将 <code>Context</code> 添加到链表中。也就是追加到 <code>tail</code> 节点的前面。</li>
<li>最后，同步或者异步或者晚点异步的调用 <code>callHandlerAdded0</code> 方法</li>
</ol>
<p>4.6 前面说了 <code>dobind</code> 方法有 <code>2</code> 个重要的步骤，<code>initAndRegister</code> 说完，接下来看 <code>doBind0</code> 方法，代码如下</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind0</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> ChannelFuture regFuture, <span class="hljs-keyword">final</span> Channel channel,</span></span>
<span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;

    <span class="hljs-comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span>
    <span class="hljs-comment">// the pipeline in its channelRegistered() implementation.</span>
    channel.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">if</span> (regFuture.isSuccess()) &#123;
                <span class="hljs-comment">//bind方法这里下断点，这里下断点，来玩!!</span>
                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            &#125; <span class="hljs-keyword">else</span> &#123;
                promise.setFailure(regFuture.cause());
            &#125;
        &#125;
    &#125;);
&#125;</code></pre></div>

<p>说明：</p>
<ol>
<li>该方法的参数为 <code>initAndRegister</code> 的 <code>future</code>，<code>NioServerSocketChannel</code>，端口地址，<code>NioServerSocketChannel</code> 的 <code>promise</code></li>
<li>这里就可以根据前面下的断点，一直 <code>debug</code>：</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 将调用 LoggingHandler 的 invokeBind 方法,最后会追到</span>
<span class="hljs-comment">// DefaultChannelPipeline 类的 bind</span>
<span class="hljs-comment">// 然后进入到 unsafe.bind 方法 debug，注意要追踪到</span>
<span class="hljs-comment">// unsafe.bind，要 debug 第二圈的时候，才能看到。</span>

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span> <span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    unsafe.bind(localAddress,promise);
&#125;

<span class="hljs-comment">// 继续追踪 AbstractChannel 的 </span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span> <span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;
    <span class="hljs-comment">//....</span>
    <span class="hljs-keyword">try</span>&#123;
        <span class="hljs-comment">//!!!! 小红旗可以看到，这里最终的方法就是 doBind 方法，执行成功后，执行通道的 fireChannelActive 方法，告诉所有的 handler，已经成功绑定。</span>
        doBind(localAddress);<span class="hljs-comment">//</span>
    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
        safeSetFailure(promise, t);
        closeIfClosed();
        <span class="hljs-keyword">return</span>;
    &#125;
&#125;</code></pre></div>

<ol>
<li>最终 <code>doBind</code> 就会追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>，说明 <code>Netty</code> 底层使用的是 <code>NIO</code></li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span> <span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;
        javaChannel().bind(localAddress, config.getBacklog());
    &#125; <span class="hljs-keyword">else</span> &#123;
        javaChannel().socket().bind(localAddress, config.getBacklog());
    &#125;
&#125;</code></pre></div>

<ol>
<li>回到 <code>bind</code> 方法（<code>alt + v</code>），最后一步：<code>safeSetSuccess(promise)</code>，告诉 <code>promise</code> 任务成功了。其可以执行监听器的方法了。到此整个启动过程已经结束了，ok 了</li>
<li>继续 <code>atl + v</code> 服务器就回进入到（<code>NioEventLoop</code> 类）一个循环代码，进行监听</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">for</span>(;;) &#123;
        <span class="hljs-keyword">try</span>&#123;

        &#125;
    &#125;
&#125;</code></pre></div>

<h4 id="10-2-4-Netty-启动过程梳理"><a href="#10-2-4-Netty-启动过程梳理" class="headerlink" title="10.2.4 Netty 启动过程梳理"></a>10.2.4 Netty 启动过程梳理</h4><ol>
<li>创建 <code>2</code> 个 <code>EventLoopGroup</code> 线程池数组。数组默认大小 <code>CPU * 2</code>，方便 <code>chooser</code> 选择线程池时提高性能</li>
<li><code>BootStrap</code> 将 <code>boss</code> 设置为 <code>group</code> 属性，将 <code>worker</code> 设置为 <code>childer</code> 属性</li>
<li>通过 <code>bind</code> 方法启动，内部重要方法为 <code>initAndRegister</code> 和 <code>dobind</code> 方法</li>
<li><code>initAndRegister</code> 方法会反射创建 <code>NioServerSocketChannel</code> 及其相关的 <code>NIO</code> 的对象，<code>pipeline</code>，<code>unsafe</code>，同时也为 <code>pipeline</code> 初始了 <code>head</code> 节点和 <code>tail</code> 节点。</li>
<li>在 <code>register0</code> 方法成功以后调用在 <code>dobind</code> 方法中调用 <code>doBind0</code> 方法，该方法会调用 <code>NioServerSocketChannel</code> 的 <code>doBind</code> 方法对 <code>JDK</code> 的 <code>channel</code> 和端口进行绑定，完成 <code>Netty</code> 服务器的所有启动，并开始监听连接事件。</li>
</ol>
<h3 id="10-3-Netty-接受请求过程源码剖析"><a href="#10-3-Netty-接受请求过程源码剖析" class="headerlink" title="10.3 Netty 接受请求过程源码剖析"></a>10.3 Netty 接受请求过程源码剖析</h3><h4 id="10-3-1-源码剖析目的"><a href="#10-3-1-源码剖析目的" class="headerlink" title="10.3.1 源码剖析目的"></a>10.3.1 源码剖析目的</h4><ol>
<li>服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，下面源码分析 <code>Netty</code> 在启动之后是如何接受客户端请求的</li>
<li>在 <code>io.netty.example</code> 包下</li>
</ol>
<h4 id="10-3-2-源码剖析"><a href="#10-3-2-源码剖析" class="headerlink" title="10.3.2 源码剖析"></a>10.3.2 源码剖析</h4><p>说明：</p>
<ol>
<li>从之前服务器启动的源码中，我们得知，服务器最终注册了一个 <code>Accept</code> 事件等待客户端的连接。我们也知道，<code>NioServerSocketChannel</code> 将自己注册到了 <code>boss</code> 单例线程池（<code>reactor</code> 线程）上，也就是 <code>EventLoop</code>。</li>
<li>先简单说下 <code>EventLoop</code> 的逻辑(后面我们详细讲解 <code>EventLoop</code>)</li>
</ol>
<p><code>EventLoop</code> 的作用是一个死循环，而这个循环中做 3 件事情：</p>
<ol>
<li><p>有条件的等待 <code>NIO</code> 事件。</p>
</li>
<li><p>处理 <code>NIO</code> 事件。</p>
</li>
<li><p>处理消息队列中的任务。</p>
</li>
<li><p>仍用前面的项目来分析：进入到 <code>NioEventLoop</code> 源码中后，在 <code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法开始调试最终我们要分析到 <code>AbstractNioChannel</code> 的 <code>doBeginRead</code> 方法，当到这个方法时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</p>
<p>源码分析过程</p>
</li>
<li><p>断点位置 <code>NioEventLoop</code> 的如下方法 <code>processSelectedKey</code></p>
</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;
    unsafe.read();<span class="hljs-comment">//断点位置</span>
&#125;</code></pre></div>

<ol>
<li>执行浏览器 <code>http://localhost:8007/</code> ，客户端发出请求</li>
<li>从的断点我们可以看到，<code>readyOps</code> 是 <code>16</code>，也就是 <code>Accept</code> 事件。说明浏览器的请求已经进来了。</li>
<li>这个 <code>unsafe</code> 是 <code>boss</code> 线程中 <code>NioServerSocketChannel</code> 的 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 对象。我们进入到 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 的 <code>read</code> 方法中</li>
<li><code>read</code> 方法代码并分析:</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;
    asserteventLoop().inEventLoop();
    <span class="hljs-keyword">final</span> ChannelConfig config = config();
    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();
    <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();
    allocHandle.reset(config);
    booleanclosed = <span class="hljs-keyword">false</span>;
    Throwable exception = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">do</span> &#123;
                <span class="hljs-keyword">int</span> localRead = doReadMessages(readBuf);
                <span class="hljs-keyword">if</span> (localRead == <span class="hljs-number">0</span>) &#123;
                    <span class="hljs-keyword">break</span>;
                &#125;
                <span class="hljs-keyword">if</span> (localRead &lt; <span class="hljs-number">0</span>) &#123;
                    closed = <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">break</span>;
                &#125;
                
                allocHandle.incMessagesRead(localRead);
            &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());
        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
            exception = t;
        &#125;
        
        <span class="hljs-keyword">int</span> size = readBuf.size();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;
            readPending = <span class="hljs-keyword">false</span>;
            pipeline.fireChannelRead(readBuf.get(i));
        &#125;
        readBuf.clear();
        allocHandle.readComplete();
        pipeline.fireChannelReadComplete();
        
        <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;
            closed = closeOnReadError(exception);

            pipeline.fireExceptionCaught(exception);
        &#125;
        
        <span class="hljs-keyword">if</span> (closed) &#123;
            inputShutdown = <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">if</span>(isOpen()) &#123;
                close(voidPromise());
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">//Check if there is a readPending which was not processed yet.</span>
        <span class="hljs-comment">//This could be for two reasons:</span>
        <span class="hljs-comment">//* The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span>
        <span class="hljs-comment">//* The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span>
        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;
            removeReadOp();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>说明： 1)检查该 <code>eventloop</code> 线程是否是当前线程。<code>asserteventLoop().inEventLoop()</code></p>
<p>2)执行 <code>doReadMessages</code> 方法，并传入一个 <code>readBuf</code> 变量，这个变量是一个 <code>List</code>，也就是容器。</p>
<p>3)循环容器，执行 <code>pipeline.fireChannelRead(readBuf.get(i));</code></p>
<p>4)<code>doReadMessages</code> 是读取 <code>boss</code> 线程中的 <code>NioServerSocketChannel</code> 接受到的请求。并把这些请求放进容器，一会我们 <code>debug</code> 下 <code>doReadMessages</code> 方法。</p>
<p>5)循环遍历容器中的所有请求，调用 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法，用于处理这些接受的请求或者其他事件，在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p>
<ol>
<li>追踪一下 <code>doReadMessages</code> 方法，就可以看得更清晰</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span> <span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    SocketChannel ch = SocketUtils.accept(javaChannel());
    buf.add(newNioSocketChannel(<span class="hljs-keyword">this</span>, ch));
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
&#125;</code></pre></div>

<p>说明： 1)通过工具类，调用 <code>NioServerSocketChannel</code> 内部封装的 <code>serverSocketChannel</code> 的 <code>accept</code> 方法，这是 <code>NIO</code> 做法。</p>
<p>2)获取到一个 <code>JDK</code> 的 <code>SocketChannel</code>，然后，使用 <code>NioSocketChannel</code> 进行封装。最后添加到容器中</p>
<p>3)这样容器 <code>buf</code> 中就有了 <code>NioSocketChannel</code> 【如果有兴趣可以追一下 <code>NioSocketChannel</code> 是如何创建的，我就不追了】</p>
<ol>
<li>回到 <code>read</code> 方法，继续分析循环执行 <code>pipeline.fireChannelRead</code> 方法</li>
</ol>
<p>1)前面分析 <code>doReadMessages</code> 方法的作用是通过 <code>ServerSocket</code> 的 <code>accept</code> 方法获取到 <code>TCP</code> 连接，然后封装成 <code>Netty</code> 的 <code>NioSocketChannel</code> 对象。最后添加到容器中</p>
<p>2)在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p>
<p>3)经过 <code>dubug</code>（多次），可以看到会反复执行多个 <code>handler</code> 的 <code>ChannelRead</code>，我们知道，<code>pipeline</code> 里面又 <code>4</code> 个 <code>handler</code>，分别是 <code>Head</code>，<code>LoggingHandler</code>，<code>ServerBootstrapAcceptor</code>，<code>Tail</code>。</p>
<p>4)我们重点看看 <code>ServerBootstrapAcceptor</code>。<code>debug</code> 之后，断点会进入到 <code>ServerBootstrapAcceptor</code> 中来。我们来看看 <code>ServerBootstrapAcceptor</code> 的 <code>channelRead</code> 方法（要多次 <code>debug</code> 才可以）</p>
<p>5)<code>channelRead</code> 方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span> <span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;
    <span class="hljs-keyword">final</span> Channelchild = (Channel)msg;
    child.pipeline().addLast(childHandler);
    setChannelOptions(child, childOptions, logger);
    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e : childAttrs) &#123;
        child.attr((AttributeKey&lt;Object&gt;)e.getKey()).set(e.getValue());
    &#125;
    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//将客户端连接注册到 worker 线程池</span>
        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuturefuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;
                    forceClose(child, future.cause());
                &#125;
            &#125;
        &#125;);
    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
        forceClose(child, t);
    &#125;
&#125;</code></pre></div>

<p>说明： 1)<code>msg</code> 强转成 <code>Channel</code>，实际上就是 <code>NioSocketChannel</code>。</p>
<p>2)添加 <code>NioSocketChannel</code> 的 <code>pipeline</code> 的 <code>handler</code>，就是我们 <code>main</code> 方法里面设置的 <code>childHandler</code> 方法里的。</p>
<p>3)设置 <code>NioSocketChannel</code> 的各种属性。</p>
<p>4)将该 <code>NioSocketChannel</code> 注册到 <code>childGroup</code> 中的一个 <code>EventLoop</code> 上，并添加一个监听器。</p>
<p>5)这个 <code>childGroup</code> 就是我们 <code>main</code> 方法创建的数组 <code>workerGroup</code>。</p>
<ol>
<li>进入 <code>register</code> 方法查看(步步追踪会到)</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span> <span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;
    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;
    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;
        register0(promise);
    &#125; <span class="hljs-keyword">else</span> &#123;
        eventLoop.execute(<span class="hljs-keyword">new</span> Runnable()&#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                register0(promise);<span class="hljs-comment">//进入到这里</span>
            &#125;
        &#125;);
    &#125;
&#125;
<span class="hljs-comment">// 继续进入到下面方法，执行管道中可能存在的任务,这里我们就不追了</span></code></pre></div>

<ol>
<li>最终会调用 <code>doBeginRead</code> 方法，也就是 <code>AbstractNioChannel</code> 类的方法</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-comment">//Channel.read() or ChannelHandlerContext.read() was called</span>
    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<span class="hljs-comment">//断点</span>
    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    readPending = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();
    <span class="hljs-keyword">if</span> ((interestOps&amp;readInterestOp) == <span class="hljs-number">0</span>) &#123;
        selectionKey.interestOps(interestOps | readInterestOp);
    &#125;
&#125;</code></pre></div>

<ol>
<li>这个地方调试时，请把前面的断点都去掉，然后启动服务器就会停止在 <code>doBeginRead</code>（需要先放过该断点，然后浏览器请求，才能看到效果）</li>
<li>执行到这里时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</li>
</ol>
<h4 id="10-3-3-Netty-接受请求过程梳理"><a href="#10-3-3-Netty-接受请求过程梳理" class="headerlink" title="10.3.3 Netty 接受请求过程梳理"></a>10.3.3 Netty 接受请求过程梳理</h4><p>总体流程：接受连接 –&gt; 创建一个新的 <code>NioSocketChannel</code> –&gt; 注册到一个 <code>workerEventLoop</code> 上 –&gt; 注册 <code>selecotRead</code> 事件。</p>
<ol>
<li>服务器轮询 <code>Accept</code> 事件，获取事件后调用 <code>unsafe</code> 的 <code>read</code> 方法，这个 <code>unsafe</code> 是 <code>ServerSocket</code> 的内部类，该方法内部由 <code>2</code> 部分组成</li>
<li><code>doReadMessages</code> 用于创建 <code>NioSocketChannel</code> 对象，该对象包装 <code>JDK</code> 的 <code>NioChannel</code> 客户端。该方法会像创建 <code>ServerSocketChanel</code> 类似创建相关的 <code>pipeline</code>，<code>unsafe</code>，<code>config</code></li>
<li>随后执行执行 <code>pipeline.fireChannelRead</code> 方法，并将自己绑定到一个 <code>chooser</code> 选择器选择的 <code>workerGroup</code> 中的一个 <code>EventLoop</code>。并且注册一个 <code>0</code>，表示注册成功，但并没有注册读（1）事件</li>
</ol>
<h3 id="10-4-Pipeline-Handler-HandlerContext-创建源码剖析"><a href="#10-4-Pipeline-Handler-HandlerContext-创建源码剖析" class="headerlink" title="10.4 Pipeline Handler HandlerContext 创建源码剖析"></a>10.4 Pipeline Handler HandlerContext 创建源码剖析</h3><h4 id="10-4-1-源码剖析目的"><a href="#10-4-1-源码剖析目的" class="headerlink" title="10.4.1 源码剖析目的"></a>10.4.1 源码剖析目的</h4><p><code>Netty</code> 中的 <code>ChannelPipeline</code>、<code>ChannelHandler</code> 和 <code>ChannelHandlerContext</code> 是非常核心的组件，我们从源码来分析 <code>Netty</code> 是如何设计这三个核心组件的，并分析是如何创建和协调工作的.</p>
<h4 id="10-4-2-源码剖析说明"><a href="#10-4-2-源码剖析说明" class="headerlink" title="10.4.2 源码剖析说明"></a>10.4.2 源码剖析说明</h4><p>说明 分析过程中，有很多的图形，所以我们准备了一个文档，在文档的基础上来做源码剖析</p>
<h4 id="10-4-3-源码剖析"><a href="#10-4-3-源码剖析" class="headerlink" title="10.4.3 源码剖析"></a>10.4.3 源码剖析</h4><ol>
<li>ChannelPipeline | ChannelHandler | ChannelHandlerContext介绍</li>
<li>1 三者关系</li>
</ol>
<p>1)每当 <code>ServerSocket</code> 创建一个新的连接，就会创建一个 <code>Socket</code>，对应的就是目标客户端。</p>
<p>2)每一个新创建的 <code>Socket</code> 都将会分配一个全新的 <code>ChannelPipeline</code>（以下简称 <code>pipeline</code>）</p>
<p>3)每一个 <code>ChannelPipeline</code> 内部都含有多个 <code>ChannelHandlerContext</code>（以下简称 <code>Context</code>）</p>
<p>4)他们一起组成了双向链表，这些 <code>Context</code> 用于包装我们调用 <code>addLast</code> 方法时添加的 <code>ChannelHandler</code>（以下简称 <code>handler</code>）</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_02.png" alt="img"></p>
<p>1)上图中：<code>ChannelSocket</code> 和 <code>ChannelPipeline</code> 是一对一的关联关系，而 <code>pipeline</code> 内部的多个 <code>Context</code> 形成了链表，<code>Context</code> 只是对 <code>Handler</code> 的封装。 2)当一个请求进来的时候，会进入 <code>Socket</code> 对应的 <code>pipeline</code>，并经过 <code>pipeline</code> 所有的 <code>handler</code>，对，就是设计模式中的过滤器模式。</p>
<p>1.2 ChannelPipeline 作用及设计</p>
<p>1)<code>pipeline</code> 的接口设计</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_03.png" alt="img"></p>
<p>部分源码</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_04.png" alt="img"></p>
<p>可以看到该接口继承了 <code>inBound</code>，<code>outBound</code>，<code>Iterable</code> 接口，表示他可以调用数据出站的方法和入站的方法，同时也能遍历内部的链表，看看他的几个代表性的方法，基本上都是针对 <code>handler</code> 链表的插入，追加，删除，替换操作，类似是一个 <code>LinkedList</code>。同时，也能返回 <code>channel</code>（也就是 <code>socket</code>）</p>
<p>1)在 <code>pipeline</code> 的接口文档上，提供了一幅图</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_05.png" alt="img"></p>
<p>对上图的解释说明： *这是一个 <code>handler</code> 的 <code>list</code>，<code>handler</code> 用于处理或拦截入站事件和出站事件，<code>pipeline</code> 实现了过滤器的高级形式，以便用户控制事件如何处理以及 <code>handler</code> 在 <code>pipeline</code> 中如何交互。</p>
<p>*上图描述了一个典型的 <code>handler</code> 在 <code>pipeline</code> 中处理 <code>I/O</code> 事件的方式，<code>IO</code> 事件由 <code>inboundHandler</code> 或者 <code>outBoundHandler</code> 处理，并通过调用 <code>ChannelHandlerContext.fireChannelRead</code> 方法转发给其最近的处理程序。</p>
<p>*入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的 <code>I/O</code> 线程生成入站数据。入站数据通常从如 <code>SocketChannel.read(ByteBuffer)</code> 获取。</p>
<p>*通常一个 <code>pipeline</code> 有多个 <code>handler</code>，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序协议解码器-将二进制数据转换为 <code>Java</code> 对象。协议编码器-将 <code>Java</code> 对象转换为二进制数据。业务逻辑处理程序-执行实际业务逻辑（例如数据库访问）</p>
<p>*你的业务程序不能将线程阻塞，会影响 <code>IO</code> 的速度，进而影响整个 <code>Netty</code> 程序的性能。如果你的业务程序很快，就可以放在 <code>IO</code> 线程中，反之，你需要异步执行。或者在添加 <code>handler</code> 的时候添加一个线程池，例如：</p>
<p>// 下面这个任务执行的时候，将不会阻塞 <code>IO</code> 线程，执行的线程来自 <code>group</code> 线程池</p>
<div class="code-wrapper"><pre><code class="hljs reasonml">pipeline.add<span class="hljs-constructor">Last(<span class="hljs-params">group</span>, <span class="hljs-string">&quot;handler&quot;</span>, <span class="hljs-params">new</span> MyBusinessLogicHandler()</span>);</code></pre></div>

<p>1.3 <code>ChannelHandler</code> 作用及设计</p>
<p>1)源码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelHandler</span> </span>&#123;
    <span class="hljs-comment">//当把 ChannelHandler 添加到 pipeline 时被调用</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;
    <span class="hljs-comment">//当从 pipeline 中移除时调用</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception</span>;
    <span class="hljs-comment">//当处理过程中在 pipeline 发生异常时调用</span>
    <span class="hljs-meta">@Deprecated</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception</span>;
&#125;</code></pre></div>

<p>2)<code>ChannelHandler</code> 的作用就是处理 <code>IO</code> 事件或拦截 <code>IO</code> 事件，并将其转发给下一个处理程序 <code>ChannelHandler</code>。<code>Handler</code> 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，<code>Netty</code> 定义了两个子接口继承 <code>ChannelHandler</code></p>
<p>2)<code>ChannelInboundHandler</code> 入站事件接口</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_06.png" alt="img"></p>
<p>*<code>channelActive</code> 用于当 <code>Channel</code> 处于活动状态时被调用；</p>
<p>*<code>channelRead</code> 当从 <code>Channel</code> 读取数据时被调用等等方法。</p>
<p>*程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，<code>Netty</code> 会回调对应的方法。</p>
<p>3)`ChannelOutboundHandler 出站事件接口</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_07.png" alt="img"></p>
<p>*<code>bind</code> 方法，当请求将 <code>Channel</code> 绑定到本地地址时调用</p>
<p>*<code>close</code> 方法，当请求关闭 <code>Channel</code> 时调用等等</p>
<p>*出站操作都是一些连接和写出数据类似的方法。</p>
<p>4)<code>ChannelDuplexHandler</code> 处理出站和入站事件</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_08.png" alt="img"></p>
<p>*<code>ChannelDuplexHandler</code> 间接实现了入站接口并直接实现了出站接口。</p>
<p>*是一个通用的能够同时处理入站事件和出站事件的类。</p>
<p>1.4 <code>ChannelHandlerContext</code> 作用及设计</p>
<p>1)<code>ChannelHandlerContext</code> <code>UML</code> 图</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_09.png" alt="img"></p>
<p><code>ChannelHandlerContext</code> 继承了出站方法调用接口和入站方法调用接口</p>
<p>1)<code>ChannelOutboundInvoker</code> 和 <code>ChannelInboundInvoker</code> 部分源码</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_10.png" alt="img"></p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_11.png" alt="img"></p>
<p>*这两个 <code>invoker</code> 就是针对入站或出站方法来的，就是在入站或出站 <code>handler</code> 的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的</p>
<p>2)<code>ChannelHandlerContext</code> 部分源码</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter10_12.png" alt="img"></p>
<p>*<code>ChannelHandlerContext</code> 不仅仅时继承了他们两个的方法，同时也定义了一些自己的方法</p>
<p>*这些方法能够获取 <code>Context</code> 上下文环境中对应的比如 <code>channel</code>，<code>executor</code>，<code>handler</code>，<code>pipeline</code>，内存分配器，关联的 <code>handler</code> 是否被删除。</p>
<p>*<code>Context</code> 就是包装了 <code>handler</code> 相关的一切，以方便 <code>Context</code> 可以在 <code>pipeline</code> 方便的操作 <code>handler</code></p>
<p>2.ChannelPipeline | ChannelHandler | ChannelHandlerContext</p>
<p>创建过程分为 <code>3</code> 个步骤来看创建的过程：</p>
<p>*任何一个 <code>ChannelSocket</code> 创建的同时都会创建一个 <code>pipeline</code>。</p>
<p>*当用户或系统内部调用 <code>pipeline</code> 的 <code>add</code></p>
<p>*** 方法添加 <code>handler</code> 时，都会创建一个包装这 <code>handler</code> 的 <code>Context</code>。</p>
<p>*这些 <code>Context</code> 在 <code>pipeline</code> 中组成了双向链表。</p>
<p>2.1 <code>Socket</code> 创建的时候创建 <code>pipeline</code> 在 <code>SocketChannel</code> 的抽象父类 <code>AbstractChannel</code> 的构造方法中</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractChannel</span><span class="hljs-params">(Channel parent)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.parent=parent;<span class="hljs-comment">//断点测试</span>
    id = newId();
    unsafe = <span class="hljs-keyword">new</span> Unsafe();
    pipeline = <span class="hljs-keyword">new</span> ChannelPipeline();
&#125;</code></pre></div>

<p><code>Debug</code> 一下，可以看到代码会执行到这里，然后继续追踪到</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">DefaultChannelPipeline</span><span class="hljs-params">(Channel channel)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="hljs-string">&quot;channel&quot;</span>);
    succeededFuture = <span class="hljs-keyword">new</span> SucceededChannelFuture(channel, <span class="hljs-keyword">null</span>);
    voidPromise = <span class="hljs-keyword">new</span> VoidChannelPromise(channel, <span class="hljs-keyword">true</span>);
    tail = <span class="hljs-keyword">new</span> TailContext(<span class="hljs-keyword">this</span>);
    head = <span class="hljs-keyword">new</span> HeadContext(<span class="hljs-keyword">this</span>);
    head.next = tail;
    tail.prev = head;
&#125;</code></pre></div>

<p>说明：</p>
<p>1）将 <code>channel</code> 赋值给 <code>channel</code> 字段，用于 <code>pipeline</code> 操作 <code>channel</code>。</p>
<p>2）创建一个 <code>future</code> 和 <code>promise</code>，用于异步回调使用。</p>
<p>3）创建一个 <code>inbound</code> 的 <code>tailContext</code>，创建一个既是 <code>inbound</code> 类型又是 <code>outbound</code> 类型的 <code>headContext</code>。</p>
<p>4）最后，将两个 <code>Context</code> 互相连接，形成双向链表。</p>
<p>5）<code>tailContext</code> 和 <code>HeadContext</code> 非常的重要，所有 <code>pipeline</code> 中的事件都会流经他们，</p>
<p>2.2 在 add<strong>添加处理器的时候创建Context</strong>看下 <code>DefaultChannelPipeline</code> 的 <code>addLast</code> 方法如何创建的 <code>Context</code>，代码如下</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (handlers == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//断点</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;handlers&quot;</span>);
    &#125;
    <span class="hljs-keyword">for</span> (ChannelHandler h : handlers) &#123;
        <span class="hljs-keyword">if</span> (h == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        addLast(executor, <span class="hljs-keyword">null</span>, h);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre></div>

<p>继续 Debug</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;
    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;
    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;
        checkMultiplicity(handler);

        newCtx = newContext(group, filterName(name, handler), handler);
        addLast0(newCtx);
        <span class="hljs-comment">//If the registered is false it means that the channel was not registered on an eventloop yet.</span>
        <span class="hljs-comment">//In this case we add the context to the pipeline and add a task that will call</span>
        <span class="hljs-comment">//ChannelHandler.handlerAdded(...) once the channel is registered.</span>
        <span class="hljs-keyword">if</span> (!registered) &#123;
            newCtx.setAddPending();
            callHandlerCallbackLater(newCtx, <span class="hljs-keyword">true</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        &#125;

        EventExecutor executor = newCtx.executor();
        <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;
            newCtx.setAddPending();
            executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>&#123;
                    callHandlerAdded0(newCtx);
                &#125;
            &#125;);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        &#125;
    &#125;
    callHandlerAdded0(newCtx);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre></div>

<p>说明 1)<code>pipeline</code> 添加 <code>handler</code>，参数是线程池，<code>name</code> 是 <code>null</code>，<code>handler</code> 是我们或者系统传入的 <code>handler</code>。<code>Netty</code> 为了防止多个线程导致安全问题，同步了这段代码，步骤如下：</p>
<p>2)检查这个 <code>handler</code> 实例是否是共享的，如果不是，并且已经被别的 <code>pipeline</code> 使用了，则抛出异常。</p>
<p>3)调用 <code>new Context(group, filterName(name, handler), handler)</code> 方法，创建一个 <code>Context</code>。从这里可以看出来了，每次添加一个 <code>handler</code> 都会创建一个关联 <code>Context</code>。</p>
<p>4)调用 <code>addLast</code> 方法，将 <code>Context</code> 追加到链表中。</p>
<p>5)如果这个通道还没有注册到 <code>selecor</code> 上，就将这个 <code>Context</code> 添加到这个 <code>pipeline</code> 的待办任务中。当注册好了以后，就会调用 <code>callHandlerAdded0</code> 方法（默认是什么都不做，用户可以实现这个方法）。</p>
<p>6)到这里，针对三对象创建过程，了解的差不多了，和最初说的一样，每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。<code>tail</code> 是入站 <code>inbound</code> 类型的 <code>handler</code>，<code>head</code> 既是 <code>inbound</code> 也是 <code>outbound</code> 类型的 <code>handler</code>。在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。到此就 <code>OK</code> 了。</p>
<h4 id="10-4-4-Pipeline-Handler-HandlerContext-创建过程梳理"><a href="#10-4-4-Pipeline-Handler-HandlerContext-创建过程梳理" class="headerlink" title="10.4.4 Pipeline Handler HandlerContext 创建过程梳理"></a>10.4.4 Pipeline Handler HandlerContext 创建过程梳理</h4><ol>
<li>每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。</li>
<li>在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。</li>
<li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表</li>
<li>入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始</li>
</ol>
<h3 id="10-5-ChannelPipeline-调度-handler-的源码剖析"><a href="#10-5-ChannelPipeline-调度-handler-的源码剖析" class="headerlink" title="10.5 ChannelPipeline 调度 handler 的源码剖析"></a>10.5 ChannelPipeline 调度 handler 的源码剖析</h3><h4 id="10-5-1-源码剖析目的"><a href="#10-5-1-源码剖析目的" class="headerlink" title="10.5.1 源码剖析目的"></a>10.5.1 源码剖析目的</h4><ol>
<li>当一个请求进来的时候，<code>ChannelPipeline</code> 是如何调用内部的这些 <code>handler</code> 的呢？我们一起来分析下。</li>
<li>首先，当一个请求进来的时候，会第一个调用 <code>pipeline</code> 的相关方法，如果是入站事件，这些方法由 <code>fire</code> 开头，表示开始管道的流动。让后面的 <code>handler</code> 继续处理</li>
</ol>
<h4 id="10-5-2-源码剖析"><a href="#10-5-2-源码剖析" class="headerlink" title="10.5.2 源码剖析"></a>10.5.2 源码剖析</h4><p>当浏览器输入 <code>http://localhost:8007</code> 。可以看到会执行 <code>handler</code> 在 <code>Debug</code> 时，可以将断点下在 <code>DefaultChannelPipeline</code> 类的</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelActive</span><span class="hljs-params">()</span> </span>&#123;
    AbstractChannelHandlerContext.invokeChannelActive(head);<span class="hljs-comment">//断点</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre></div>

<p>源码分析</p>
<ol>
<li><code>DefaultChannelPipeline</code> 是如何实现这些 <code>fire</code> 方法的 3.1 <code>DefaultChannelPipeline</code> 源码</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultChannelPipeline</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelPipeline</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelActive</span><span class="hljs-params">()</span> </span>&#123;
        AbstractChannelHandlerContext.invokeChannelActive(head);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-title">ChannelPipelinefireChannelInactive</span><span class="hljs-params">()</span> </span>&#123;
        AbstractChannelHandlerContext.invokeChannelInactive(head);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireExceptionCaught</span><span class="hljs-params">(Throwable cause)</span> </span>&#123;
        AbstractChannelHandlerContext.invokeExceptionCaught(head, cause);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireUserEventTriggered</span><span class="hljs-params">(Object event)</span> </span>&#123;
        AbstractChannelHandlerContext.invokeUserEventTriggered(head, event);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelRead</span><span class="hljs-params">(Objectmsg)</span> </span>&#123;
        AbstractChannelHandlerContext.invokeChannelRead(head, msg);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelReadComplete</span><span class="hljs-params">()</span> </span>&#123;
        AbstractChannelHandlerContext.invokeChannelReadComplete(head);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">fireChannelWritabilityChanged</span><span class="hljs-params">()</span> </span>&#123;
        AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
&#125;</code></pre></div>

<p>说明： 可以看出来，这些方法都是 <code>inbound</code> 的方法，也就是入站事件，调用静态方法传入的也是 <code>inbound</code> 的类型 <code>head</code> <code>handler</code>。这些静态方法则会调用 <code>head</code> 的 <code>ChannelInboundInvoker</code> 接口的方法，再然后调用 <code>handler</code> 的真正方法</p>
<p>3.2再看下 <code>piepline</code> 的 <code>outbound</code> 的 <code>fire</code> 方法实现源码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultChannelPipeline</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelPipeline</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.bind(localAddress);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.connect(remoteAddress);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, localAddress);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> tail.disconnect();
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.close();
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">deregister</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.deregister();
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;
        tail.flush();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.bind(localAddress, promise);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, promise);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.connect(remoteAddress, localAddress, promise);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title">disconnect</span><span class="hljs-params">(ChannelPromise promise)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tail.disconnect(promise);
    &#125;
&#125;</code></pre></div>

<p>说明：</p>
<p>1)这些都是出站的实现，但是调用的是 <code>outbound</code> 类型的 <code>tailhandler</code> 来进行处理，因为这些都是 <code>outbound</code> 事件。</p>
<p>2)出站是 <code>tail</code> 开始，入站从 <code>head</code> 开始。因为出站是从内部向外面写，从 <code>tail</code> 开始，能够让前面的 <code>handler</code> 进行处理，防止 <code>handler</code> 被遗漏，比如编码。反之，入站当然是从 <code>head</code> 往内部输入，让后面的 <code>handler</code> 能够处理这些输入的数据。比如解码。因此虽然 <code>head</code> 也实现了 <code>outbound</code> 接口，但不是从 head 开始执行出站任务</p>
<p>4.关于如何调度，用一张图来表示:</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_13.png" alt="img"></p>
<p>说明： 1)<code>pipeline</code> 首先会调用 <code>Context</code> 的静态方法 <code>fireXXX</code>，并传入 <code>Context</code></p>
<p>2)然后，静态方法调用 <code>Context</code> 的 <code>invoker</code> 方法，而 <code>invoker</code> 方法内部会调用该 <code>Context</code> 所包含的 <code>Handler</code> 的真正的 <code>XXX</code> 方法，调用结束后，如果还需要继续向后传递，就调用 <code>Context</code> 的 <code>fireXXX2</code> 方法，循环往复。</p>
<h4 id="10-5-3-ChannelPipeline-调度-handler-梳理"><a href="#10-5-3-ChannelPipeline-调度-handler-梳理" class="headerlink" title="10.5.3 ChannelPipeline 调度 handler 梳理"></a>10.5.3 ChannelPipeline 调度 handler 梳理</h4><ol>
<li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表，入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始。</li>
<li>而节点中间的传递通过 <code>Abstract ChannelHandlerContext</code> 类内部的 <code>fire</code> 系列方法，找到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对 <code>handler</code> 的调度</li>
</ol>
<h3 id="10-6-Netty-心跳-heartbeat-服务源码剖析"><a href="#10-6-Netty-心跳-heartbeat-服务源码剖析" class="headerlink" title="10.6 Netty 心跳(heartbeat)服务源码剖析"></a>10.6 Netty 心跳(heartbeat)服务源码剖析</h3><h4 id="10-6-1-源码剖析目的"><a href="#10-6-1-源码剖析目的" class="headerlink" title="10.6.1 源码剖析目的"></a>10.6.1 源码剖析目的</h4><p><code>Netty</code> 作为一个网络框架，提供了诸多功能，比如编码解码等，<code>Netty</code> 还提供了非常重要的一个服务 – 心跳机制 <code>heartbeat</code>。通过心跳检查对方是否有效，这是 <code>RPC</code> 框架中是必不可少的功能。下面我们分析一下 <code>Netty</code> 内部心跳服务源码实现。</p>
<h4 id="10-6-2-源码剖析"><a href="#10-6-2-源码剖析" class="headerlink" title="10.6.2 源码剖析"></a>10.6.2 源码剖析</h4><p><code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性，重点分析 <code>IdleStateHandler</code>。</p>
<p>如图</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_14.png" alt="img"></p>
<p>源码剖析：</p>
<p>5.<code>Netty</code> 提供的心跳介绍</p>
<p>1)<code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性。</p>
<p>2)如图</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_15.png" alt="img"></p>
<p>3)<code>ReadTimeout</code> 事件和 <code>WriteTimeout</code> 事件都会自动关闭连接，而且，属于异常处理，所以，这里只是介绍以下，我们重点看 <code>IdleStateHandler</code>。</p>
<p>6.<code>IdleStateHandler</code> 分析</p>
<p>6.1 <code>4</code> 个属性</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> observeOutput; <span class="hljs-comment">//是否考虑出站时较慢的情况。默认值是 false</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> readerIdleTimeNanos; <span class="hljs-comment">//读事件空闲时间，0 则禁用事件</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> writerIdleTimeNanos;<span class="hljs-comment">//写事件空闲时间，0 则禁用事件</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> allIdleTimeNanos;<span class="hljs-comment">//读或写空闲时间，0 则禁用事件</span></code></pre></div>

<p>6.2<code>handlerAdded</code> 方法</p>
<p>当该 <code>handler</code> 被添加到 <code>pipeline</code> 中时，则调用 <code>initialize</code> 方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
    <span class="hljs-comment">//Avoid the case where destroy() is called before scheduling timeouts.</span>
    <span class="hljs-comment">//See:https://github.com/netty/netty/issues/143</span>
    <span class="hljs-keyword">switch</span>(state) &#123;
        case1:
        case2:
            <span class="hljs-keyword">return</span>;
    &#125;
    
    state=<span class="hljs-number">1</span>;
    initOutputChanged(ctx);
    
    lastReadTime = lastWriteTime = ticksInNanos();
    
    <span class="hljs-keyword">if</span>(readerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">//这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列中</span>
        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> ReaderIdleTimeoutTask(ctx), readerIdleTimeNanos, TimeUnit.NANOSECONDS);
    &#125;
    
    <span class="hljs-keyword">if</span>(writerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;
        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> WriterIdleTimeoutTask(ctx), writerIdleTimeNanos, TimeUnit.NANOSECONDS);
    &#125;
    
    <span class="hljs-keyword">if</span>(allIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;
        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> AllIdleTimeoutTask(ctx), allIdleTimeNanos, TimeUnit.NANOSECONDS);
    &#125;
&#125;</code></pre></div>

<p>只要给定的参数大于 <code>0</code>，就创建一个定时任务，每个事件都创建。同时，将 <code>state</code> 状态设置为 <code>1</code>，防止重复初始化。调用 <code>initOutputChanged</code> 方法，初始化“监控出站数据属性”。</p>
<p>6.3该类内部的 <code>3</code> 个定时任务类</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_16.png" alt="img"></p>
<p>1)这 <code>3</code> 个定时任务分别对应读，写，读或者写事件。共有一个父类（<code>AbstractIdleTask</code>）。这个父类提供了一个模板方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractIdleTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelHandlerContext ctx;
    
    AbstractIdleTask(ChannelHandlerContext ctx) &#123;
        <span class="hljs-keyword">this</span>.ctx = ctx;
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(!ctx.channel().isOpen()) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        run(ctx);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span></span>;
&#125;</code></pre></div>

<p>说明：当通道关闭了，就不执行任务了。反之，执行子类的 <code>run</code> 方法</p>
<p>7.读事件的 <code>run</code> 方法（即 <code>ReaderIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>
<p>1)代码及其说明</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
    <span class="hljs-keyword">long</span> nextDelay = readerIdleTimeNanos;
    <span class="hljs-keyword">if</span>(!reading) &#123;
        nextDelay -= ticksInNanos() - lastReadTime;
    &#125;
    
    <span class="hljs-keyword">if</span>(nextDelay &lt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">//Reader is idle-set a new timeout and notify the callback.</span>
        <span class="hljs-comment">//用于取消任务 promise</span>
        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);
        <span class="hljs-keyword">boolean</span> first = firstReaderIdleEvent;
        firstReaderIdleEvent = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//再次提交任务</span>
            IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.READER_IDLE, first);
            <span class="hljs-comment">//触发用户 handler use</span>
            channelIdle(ctx, event);
        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
            ctx.fireExceptionCaught(t);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">//Read occurred before the timeout - set a new timeout with shorter delay.</span>
        readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);
    &#125;
&#125;</code></pre></div>

<p>说明：</p>
<p>1)得到用户设置的超时时间。</p>
<p>2)如果读取操作结束了（执行了 <code>channelReadComplete</code> 方法设置），就用当前时间减去给定时间和最后一次读（执操作的时间行了 <code>channelReadComplete</code> 方法设置），如果小于 <code>0</code>，就触发事件。反之，继续放入队列。间隔时间是新的计算时间。</p>
<p>3)触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个 <code>promise</code> 对象，用于做取消操作。然后，设置 <code>first</code> 属性为<code>false</code>，表示，下一次读取不再是第一次了，这个属性在 <code>channelRead</code> 方法会被改成 <code>true</code>。</p>
<p>4)创建一个 <code>IdleStateEvent</code> 类型的写事件对象，将此对象传递给用户的 <code>UserEventTriggered</code> 方法。完成触发事件的操作。</p>
<p>5)总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发 <code>UserEventTriggered</code> 方法。//前面介绍 <code>IdleStateHandler</code> 说过,可以看一下</p>
<p>8.写事件的 <code>run</code> 方法（即 <code>WriterIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>
<p>1)<code>run</code> 代码和分析</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
    <span class="hljs-keyword">long</span> lastWriteTime = IdleStateHandler.<span class="hljs-keyword">this</span>.lastWriteTime;
    <span class="hljs-keyword">long</span> nextDelay = writerIdleTimeNanos - (ticksInNanos()-lastWriteTime);
    <span class="hljs-keyword">if</span> (nextDelay &lt;=<span class="hljs-number">0</span> ) &#123;
        <span class="hljs-comment">//Writer is idle - set a new timeout and notify the callback.</span>
        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, writerIdleTimeNanos, TimeUnit.NANOSECONDS);
        <span class="hljs-keyword">boolean</span> first = firstWriterIdleEvent;
        firstWriterIdleEvent = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span>(hasOutputChanged(ctx, first)) &#123;
                <span class="hljs-keyword">return</span>;
            &#125;
            
            IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.WRITER_IDLE, first);
            channelIdle(ctx, event);
        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
            ctx.fireExceptionCaught(t);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">//Write occurred before the timeout - set a new timeout with shorter delay.</span>
        writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);
    &#125;
&#125;</code></pre></div>

<p>说明：写任务的 <code>run</code> 代码逻辑基本和读任务的逻辑一样，唯一不同的就是有一个针对出站较慢数据的判断 <code>hasOutputChanged</code></p>
<p>9.所有事件的 <code>run</code> 方法（即 <code>AllIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>
<p>代码分析</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
    <span class="hljs-keyword">long</span> nextDelay = allIdleTimeNanos;
    <span class="hljs-keyword">if</span>(!reading) &#123;
        nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);
    &#125;
    
    <span class="hljs-keyword">if</span>(nextDelay &lt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">//Both reader and writer are idle - set a new timeout and</span>
        <span class="hljs-comment">//notify the callback.</span>
        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, allIdleTimeNanos, TimeUnit.NANOSECONDS);
        <span class="hljs-keyword">boolean</span> first = firstAllIdleEvent;
        firstAllIdleEvent = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span>(hasOutputChanged(ctx, first)) &#123;
                <span class="hljs-keyword">return</span>;
            &#125;
            
            IdleStateEvent event = <span class="hljs-keyword">new</span> IdleStateEvent(IdleState.ALL_IDLE, first);
            channelIdle(ctx, event);
        &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;
            ctx.fireExceptionCaught(t);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">//Either read or write occurred before the timeout - set a new</span>
        <span class="hljs-comment">//timeout with shorter delay.</span>
        allIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);
    &#125;
&#125;</code></pre></div>

<p>说明：</p>
<p>1)表示这个监控着所有的事件。当读写事件发生时，都会记录。代码逻辑和写事件的的基本一致：</p>
<p>2)需要大家注意的地方是</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">long</span> nextDelay = allIdleTimeNanos;
<span class="hljs-keyword">if</span>(!reading) &#123;
    <span class="hljs-comment">//当前时间减去最后一次写或读的时间，若大于 0，说明超时了</span>
    nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);
&#125;</code></pre></div>

<p>3)这里的时间计算是取读写事件中的最大值来的。然后像写事件一样，判断是否发生了写的慢的情况。</p>
<p>10.小结 <code>Netty</code> 的心跳机制</p>
<p>1)<code>IdleStateHandler</code> 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 <code>handler</code> 的 <code>userEventTriggered</code> 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接。</p>
<p>2)<code>IdleStateHandler</code> 的实现基于 <code>EventLoop</code> 的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。</p>
<p>3)内部有 <code>3</code> 个定时任务，分别对应读事件，写事件，读写事件。通常用户监听读写事件就足够了。</p>
<p>4)同时，<code>IdleStateHandler</code> 内部也考虑了一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间。<code>Netty</code> 通过构造方法中的 <code>observeOutput</code> 属性来决定是否对出站缓冲区的情况进行判断。</p>
<p>5)如果出站缓慢，<code>Netty</code> 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，可能造成 <code>OOM</code>，<code>OOM</code> 比空闲的问题更大。</p>
<p>6)所以，当你的应用出现了内存溢出，<code>OOM</code> 之类，并且写空闲极少发生（使用了 <code>observeOutput</code> 为 <code>true</code>），那么就需要注意是不是数据出站速度过慢。</p>
<p>7)还有一个注意的地方：就是 <code>ReadTimeoutHandler</code>，它继承自 <code>IdleStateHandler</code>，当触发读空闲事件的时候，就触发 <code>ctx</code>. <code>fireExceptionCaught</code> 方法，并传入一个 <code>ReadTimeoutException</code>，然后关闭 <code>Socket</code>。</p>
<p>8)而 <code>WriteTimeoutHandler</code> 的实现不是基于 <code>IdleStateHandler</code> 的，他的原理是，当调用 <code>write</code> 方法的时候，会创建一个定时任务，任务内容是根据传入的 <code>promise</code> 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 <code>promise</code> 的 <code>isDone</code> 方法返回 <code>false</code>，表明还没有写完，说明超时了，则抛出异常。当 <code>write</code> 方法完成后，会打断定时任务。</p>
<h3 id="10-7-Netty-核心组件-EventLoop-源码剖析"><a href="#10-7-Netty-核心组件-EventLoop-源码剖析" class="headerlink" title="10.7 Netty 核心组件 EventLoop 源码剖析]"></a>10.7 Netty 核心组件 EventLoop 源码剖析]</h3><h4 id="10-7-1-源码剖析目的"><a href="#10-7-1-源码剖析目的" class="headerlink" title="10.7.1 源码剖析目的"></a>10.7.1 源码剖析目的</h4><p><code>Echo</code> 第一行代码就是：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1)</code>; 下面分析其最核心的组件 <code>EventLoop</code>。</p>
<h4 id="10-7-2-源码剖析"><a href="#10-7-2-源码剖析" class="headerlink" title="10.7.2 源码剖析"></a>10.7.2 源码剖析</h4><p>源码剖析</p>
<p>1.<code>EventLoop</code>介绍 1.1首先看看 <code>NioEventLoop</code> 的继承图</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_17.png" alt="img"></p>
<p>说明重点： 1)<code>ScheduledExecutorService</code> 接口表示是一个定时任务接口，<code>EventLoop</code> 可以接受定时任务。</p>
<p>2)<code>EventLoop</code> 接口：<code>Netty</code> 接口文档说明该接口作用：一旦 <code>Channel</code> 注册了，就处理该 <code>Channel</code> 对应的所有 <code>I/O</code> 操作。</p>
<p>3)<code>SingleThreadEventExecutor</code> 表示这是一个单个线程的线程池</p>
<p>4)<code>EventLoop</code> 是一个单例的线程池，里面含有一个死循环的线程不断的做着 <code>3</code> 件事情：监听端口，处理端口事件，处理队列事件。每个 <code>EventLoop</code> 都可以绑定多个 <code>Channel</code>，而每个 <code>Channel</code> 始终只能由一个 <code>EventLoop</code> 来处理</p>
<ol>
<li><code>NioEventLoop</code> 的使用 - <code>execute</code> 方法</li>
</ol>
<p>2.1 <code>execute</code> 源码剖析</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_18.png" alt="img"></p>
<p>在 <code>EventLoop</code> 的使用，一般就是 <code>eventloop.execute(task);</code> 看下 <code>execute</code> 方法的实现(在 <code>SingleThreadEventExecutor</code> 类中)</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(task == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);
    &#125;
    <span class="hljs-keyword">boolean</span> inEventLoop = inEventLoop();
    <span class="hljs-keyword">if</span>(inEventLoop) &#123;
        addTask(task);
    &#125; <span class="hljs-keyword">else</span> &#123;
        startThread();
        addTask(task);
        <span class="hljs-keyword">if</span>(isShutdown() &amp;&amp; removeTask(task)) &#123;
            reject();
        &#125;
    &#125;
    
    <span class="hljs-keyword">if</span>(!addTaskWakesUp&amp;&amp;wakesUpForTask(task)) &#123;
        wakeup(inEventLoop);
    &#125;
&#125;</code></pre></div>

<p>说明: 1)首先判断该 <code>EventLoop</code> 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。</p>
<p>2)如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。</p>
<p>3)如果 <code>addTaskWakesUp</code> 是 <code>false</code>，并且任务不是 <code>NonWakeupRunnable</code> 类型的，就尝试唤醒 <code>selector</code>。这个时候，阻塞在 <code>selecor</code>的线程就会立即返回</p>
<p>4)可以下断点来追踪</p>
<p>2.2我们 <code>debugaddTask</code> 和 <code>offerTask</code> 方法源码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(Runnable task)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(task == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;task&quot;</span>);
    &#125;
    
    <span class="hljs-keyword">if</span>(!offerTask(task)) &#123;
        reject(task);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offerTask</span><span class="hljs-params">(Runnable task)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(isShutdown()) &#123;
        reject();
    &#125;
    <span class="hljs-keyword">return</span> taskQueue.offer(task);
&#125;</code></pre></div>

<p>3.<code>NioEventLoop</code> 的父类 <code>SingleThreadEventExecutor</code> 的 <code>startThread</code> 方法 3.1当执行 <code>execute</code> 方法的时候，如果当前线程不是 <code>EventLoop</code> 所属线程，则尝试启动线程，也就是 <code>startThread</code> 方法，dubug 代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startThread</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span>(state == ST_NOT_STARTED) &#123;
        <span class="hljs-keyword">if</span>(STATE_UPDATER.compareAndSet(<span class="hljs-keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;
            <span class="hljs-keyword">try</span>&#123;
                doStartThread();
            &#125; <span class="hljs-keyword">catch</span>(Throwable cause) &#123;
                STATE_UPDATER.set(<span class="hljs-keyword">this</span>, ST_NOT_STARTED);
                PlatformDependent.throwException(cause);
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>说明:该方法首先判断是否启动过了，保证 <code>EventLoop</code> 只有一个线程，如果没有启动过，则尝试使用 <code>Cas</code> 将 <code>state</code> 状态改为 <code>ST_STARTED</code>，也就是已启动。然后调用 <code>doStartThread</code> 方法。如果失败，则进行回滚</p>
<p>看下 <code>doStartThread</code> 方法</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStartThread</span><span class="hljs-params">()</span> </span>&#123;
    executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;
            updateLastExecutionTime();
            <span class="hljs-keyword">try</span>&#123;
                SingleThreadEventExecutor.<span class="hljs-keyword">this</span>.run();
                success=<span class="hljs-keyword">true</span>;
            &#125; <span class="hljs-keyword">finally</span> &#123;
                <span class="hljs-keyword">for</span>( ; ; ) &#123;
                    intoldState = state;
                    <span class="hljs-keyword">if</span>(oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.<span class="hljs-keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;
                        <span class="hljs-keyword">break</span>;
                    &#125;
                &#125;
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-keyword">for</span>( ; ; ) &#123;
                        <span class="hljs-keyword">if</span>(confirmShutdown()) &#123;
                            <span class="hljs-keyword">break</span>;
                        &#125;
                    &#125;
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-keyword">try</span> &#123;
                        cleanup();
                    &#125; <span class="hljs-keyword">finally</span> &#123;
                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class="hljs-keyword">this</span>,ST_TERMINATED);
                        threadLock.release();
                        terminationFuture.setSuccess(<span class="hljs-keyword">null</span>);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;);
&#125;</code></pre></div>

<p>说明： 1)首先调用 <code>executor</code> 的 <code>execute</code> 方法，这个 <code>executor</code> 就是在创建 <code>EventLoopGroup</code> 的时候创建的 <code>ThreadPerTaskExecutor</code> 类。该 <code>execute</code> 方法会将 <code>Runnable</code> 包装成 <code>Netty</code> 的 <code>FastThreadLocalThread</code>。</p>
<p>2)任务中，首先判断线程中断状态，然后设置最后一次的执行时间。</p>
<p>3)执行当前 <code>NioEventLoop</code> 的 <code>run</code> 方法，注意：这个方法是个死循环，是整个 <code>EventLoop</code> 的核心</p>
<p>4)在 <code>finally</code> 块中，使用 <code>CAS</code> 不断修改 <code>state</code> 状态，改成 <code>ST_SHUTTING_DOWN</code>。也就是当线程 <code>Loop</code> 结束的时候。关闭线程。最后还要死循环确认是否关闭，否则不会 <code>break</code>。然后，执行 <code>cleanup</code> 操作，更新状态为</p>
<p>5)<code>ST_TERMINATED</code>，并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。并回调 <code>terminationFuture</code> 方法。</p>
<p>6)其实最核心的就是 <code>EventLoop</code> 自身的 <code>run</code> 方法。再继续深入 <code>run</code> 方法</p>
<p>4.<code>EventLoop</code> 中的 <code>Loop</code> 是靠 <code>run</code> 实现的，我们分析下 <code>run</code> 方法(该方法在 <code>NioEventLoop</code>)</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">for</span>( ; ; ) &#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">switch</span>(selectStrategy.calculateStrategy(selectNowSupplier,hasTasks())) &#123;
                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:
                    <span class="hljs-keyword">continue</span>;
                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:
                    select(wakenUp.getAndSet(<span class="hljs-keyword">false</span>));
                    <span class="hljs-keyword">if</span>(wakenUp.get()) &#123;
                        selector.wakeup();
                    &#125;    
                <span class="hljs-keyword">default</span>:
            &#125;
            
            cancelledKeys = <span class="hljs-number">0</span>;
            needsToSelectAgain = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;
            <span class="hljs-keyword">if</span>(ioRatio == <span class="hljs-number">100</span>) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    processSelectedKeys();
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-comment">//Ensure we always run tasks.</span>
                    runAllTasks();
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();
                <span class="hljs-keyword">try</span> &#123;
                    processSelectedKeys();
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-comment">//Ensure we always runtasks.</span>
                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;
                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">catch</span>(Throwable t) &#123;
            handleLoopException(t);
        &#125;
        <span class="hljs-comment">//Always handle shutdown even if the loop processing threw an exception.</span>
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span>(isShuttingDown()) &#123;
                closeAll();
                <span class="hljs-keyword">if</span>(confirmShutdown()) &#123;
                    <span class="hljs-keyword">return</span>;
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
            handleLoopException(t);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>说明: 1)从上面的步骤可以看出，整个 <code>run</code> 方法做了 <code>3</code> 件事情： <code>select</code> 获取感兴趣的事件。 <code>processSelectedKeys</code> 处理事件。 <code>runAllTasks</code> 执行队列中的任务。</p>
<p>2)上面的三个方法，我们就追一下 <code>select</code> 方法(体现非阻塞)核心 <code>select</code> 方法解析</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> oldWakenUp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    Selector selector = <span class="hljs-keyword">this</span>.selector;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">long</span> currentTimeNanos = System.nanoTime();
        <span class="hljs-keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);
        <span class="hljs-keyword">for</span>( ; ; ) &#123;
            <span class="hljs-keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="hljs-number">500000L</span>)/<span class="hljs-number">1000000L</span>;
            <span class="hljs-keyword">if</span>(timeoutMillis &lt;= <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">if</span>(selectCnt == <span class="hljs-number">0</span>) &#123;
                    selector.selectNow();
                    selectCnt=<span class="hljs-number">1</span>;
                &#125;
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-comment">//If a task was submitted when wakenUp value was true, the task didn&#x27;t get a chance to call</span>
            <span class="hljs-comment">//Selector#wakeup. So we need to check task queue again before executing select operation.</span>
            <span class="hljs-comment">//If wedon&#x27;t, the task might be pended until select operation was timedout.</span>
            <span class="hljs-comment">//It might be pended until idle timeout if IdleStateHandler existed inpipeline.</span>
            <span class="hljs-keyword">if</span>(hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;
                selector.selectNow();
                selectCnt = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
            
            <span class="hljs-keyword">int</span> selectedKeys = selector.select(timeoutMillis);<span class="hljs-comment">//否则阻塞给定时间，默认一秒</span>
            selectCnt++;
            <span class="hljs-comment">//如果 1 秒后返回，有返回值||select被用户唤醒||任务队列有任务||有定时任务即将被执行；则跳出循环</span>
            <span class="hljs-keyword">if</span>(selectedKeys != <span class="hljs-number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;
                <span class="hljs-comment">//-Selected something,</span>
                <span class="hljs-comment">//-waken up by user,or</span>
                <span class="hljs-comment">//-the task queue has apending task.</span>
                <span class="hljs-comment">//-a scheduled task is ready for processing</span>
                <span class="hljs-keyword">break</span>;
            &#125;
            
            <span class="hljs-keyword">if</span>(Thread.interrupted()) &#123;
                <span class="hljs-comment">//Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span>
                <span class="hljs-comment">//As this is most likely a bug in the handler of the user or it&#x27;s client library we will</span>
                <span class="hljs-comment">//also log it.</span>
                <span class="hljs-comment">//</span>
                <span class="hljs-comment">//See https://github.com/netty/netty/issues/2426</span>
                <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;
                    logger.debug(<span class="hljs-string">&quot;Selector.select() returned prematurely because &quot;</span> + <span class="hljs-string">&quot; Thread.currentThread().interrupt() was called. Use &quot;</span> + <span class="hljs-string">&quot; NioEventLoop.shutdownGracefully() to shutdowntheNioEventLoop.&quot;</span>);
                &#125;
                selectCnt = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
            <span class="hljs-keyword">long</span> time = System.nanoTime();
            <span class="hljs-keyword">if</span>(time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;
                <span class="hljs-comment">//timeoutMillis elapsed without any thing selected.</span>
                selectCnt =<span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;
                <span class="hljs-comment">//The selector returned prematurely many times in a row.</span>
                <span class="hljs-comment">//Rebuild the selector to work around the problem.</span>
                logger.warn(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>, selectCnt, selector);
                rebuildSelector();
                selector = <span class="hljs-keyword">this</span>.selector;
                <span class="hljs-comment">//Select again to populate selectedKeys.</span>
                selector.selectNow();
                selectCnt = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
            
            currentTimeNanos = time;
        &#125;
        
        <span class="hljs-keyword">if</span>(selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;
            <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;
                logger.debug(<span class="hljs-string">&quot;Selector.select()returned prematurely &#123;&#125; times in a row for Selector&#123;&#125;.&quot;</span>, selectCnt - <span class="hljs-number">1</span>, selector);
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;
        <span class="hljs-keyword">if</span>(logger.isDebugEnabled()) &#123;
            logger.debug(CancelledKeyException.class.getSimpleName() + <span class="hljs-string">&quot;raisedbyaSelector &#123;&#125; - JDKbug?&quot;</span>, selector, e);
        &#125;
        <span class="hljs-comment">//Harmless exception - log anyway</span>
    &#125;
&#125;</code></pre></div>

<p>说明：调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selector</code>，防止 <code>selector</code> 阻塞时间过长</p>
<p>5.<code>EventLoop</code> 作为 <code>Netty</code> 的核心的运行机制小结</p>
<p>1)每次执行 <code>execute</code> 方法都是向队列中添加任务。当第一次添加时就启动线程，执行 <code>run</code> 方法，而 <code>run</code> 方法是整个 <code>EventLoop</code> 的核心，就像 <code>EventLoop</code> 的名字一样，<code>LoopLoop</code>，不停的 <code>Loop</code>，<code>Loop</code> 做什么呢？做 <code>3</code> 件事情。</p>
<p>调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selecor</code>，防止 <code>selector</code> 阻塞时间过长。</p>
<p>当 <code>selector</code> 返回的时候，回调用 <code>processSelectedKeys</code> 方法对 <code>selectKey</code> 进行处理。</p>
<p>当 <code>processSelectedKeys</code> 方法执行结束后，则按照 <code>ioRatio</code> 的比例执行 <code>runAllTasks</code> 方法，默认是 <code>IO</code> 任务时间和非 <code>IO</code> 任务时间是相同的，你也可以根据你的应用特点进行调优。比如非 <code>IO</code> 任务比较多，那么你就将</p>
<p><code>ioRatio</code> 调小一点，这样非 <code>IO</code> 任务就能执行的长一点。防止队列积攒过多的任务。</p>
<h3 id="10-8-handler-中加入线程池和-Context-中添加线程池的源码剖析"><a href="#10-8-handler-中加入线程池和-Context-中添加线程池的源码剖析" class="headerlink" title="10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析"></a>10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析</h3><h4 id="10-8-1-源码剖析目的"><a href="#10-8-1-源码剖析目的" class="headerlink" title="10.8.1 源码剖析目的"></a>10.8.1 源码剖析目的</h4><ol>
<li>在 <code>Netty</code> 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 <code>Netty</code> 对 <code>Socket</code> 的处理速度。</li>
<li>而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有 <code>2</code> 种方式，而且这 <code>2</code> 种方式实现的区别也蛮大的。</li>
<li>处理耗时业务的第一种方式 – <code>handler</code> 中加入线程池</li>
<li>处理耗时业务的第二种方式 – <code>Context</code> 中添加线程池</li>
<li>我们就来分析下两种方式</li>
</ol>
<h4 id="10-8-2-源码剖析"><a href="#10-8-2-源码剖析" class="headerlink" title="10.8.2 源码剖析"></a>10.8.2 源码剖析</h4><p>说明 演示两种方式的实现，以及从源码来追踪两种方式执行流程</p>
<ol>
<li>处理耗时业务的第一种方式 – handler种加入线程池</li>
<li>1对前面的 <code>Netty</code> <code>demo</code>源码进行修改，在 <code>EchoServerHandler</code> 的 <code>channelRead</code> 方法进行异步</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventExecutorGroup group = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<span class="hljs-number">16</span>);

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException, InterruptedException </span>&#123;
        <span class="hljs-keyword">final</span> Object msgCop = msg;
        <span class="hljs-keyword">final</span> ChannelHandlerContext cxtCop = ctx;
        group.submit(<span class="hljs-keyword">new</span> Callable&lt;Object&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                ByteBuf buf = (ByteBuf)msgCop;
                <span class="hljs-keyword">byte</span>[] req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buf.readableBytes()];
                buf.readBytes(req);
                String body = <span class="hljs-keyword">new</span> String(req, <span class="hljs-string">&quot;UTF-8&quot;</span>);
                Thread.sleep(<span class="hljs-number">10</span> * <span class="hljs-number">1000</span>);
                System.err.println(body + <span class="hljs-string">&quot; &quot;</span> + Thread.currentThread().getName());
                String reqString = <span class="hljs-string">&quot;Helloiamserver~~~&quot;</span>;
                ByteBuf resp = Unpooled.copiedBuffer(reqString.getBytes());
                cxtCop.writeAndFlush(resp);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
            &#125;
        &#125;);
        System.out.println(<span class="hljs-string">&quot;goon..&quot;</span>);
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
        ctx.flush();
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;
        <span class="hljs-comment">// Close the connection when an exception is raised.</span>
        cause.printStackTrace();
        ctx.close();
    &#125;
&#125;</code></pre></div>

<p>说明： 1)在 <code>channelRead</code> 方法，模拟了一个耗时 <code>10</code> 秒的操作，这里，我们将这个任务提交到了一个自定义的业务线程池中，这样，就不会阻塞 <code>Netty</code> 的 <code>IO</code> 线程。</p>
<p>11.2这样处理之后，整个程序的逻辑如图</p>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_19.png" alt="img"></p>
<p>说明：</p>
<p>1)解释一下上图，当 <code>IO</code> 线程轮询到一个 <code>socket</code> 事件，然后，<code>IO</code> 线程开始处理，当走到耗时 <code>handler</code> 的时候，将耗时任务交给业务线程池。</p>
<p>2)当耗时任务执行完毕再执行 <code>pipeline write</code> 方法的时候，(代码中使用的是 <code>context</code> 的 <code>write</code> 方法，上图画的是执行 <code>pipeline</code> 方法，是一个意思)会将任务这个任务交给 <code>IO</code> 线程</p>
<p>11.3 <code>write</code> 方法的源码(在 <code>AbstractChannelHandlerContext</code> 类)</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Object msg, <span class="hljs-keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;
    AbstractChannelHandlerContext next = findContextOutbound();
    <span class="hljs-keyword">final</span> Object m = pipeline.touch(msg, next);
    EventExecutor executor = next.executor();
    <span class="hljs-keyword">if</span>(executor.inEventLoop()) &#123;
        <span class="hljs-keyword">if</span>(flush) &#123;
            next.invokeWriteAndFlush(m, promise);
        &#125; <span class="hljs-keyword">else</span> &#123;
            next.invokeWrite(m, promise);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        AbstractWriteTask task;
        <span class="hljs-keyword">if</span>(flush) &#123;
            task = WriteAndFlushTask.newInstance(next, m, promise);
        &#125; <span class="hljs-keyword">else</span> &#123;
            task = WriteTask.newInstance(next, m, promise);
        &#125;
        safeExecute(executor, task, promise, m);
    &#125;
&#125;</code></pre></div>

<p>说明:</p>
<p>1)当判定下个 <code>outbound</code> 的 <code>executor</code> 线程不是当前线程的时候，会将当前的工作封装成 <code>task</code>，然后放入 <code>mpsc</code> 队列中，等待 <code>IO</code> 任务执行完毕后执行队列中的任务。</p>
<p>2)这里可以 Debug 来验证(提醒：Debug 时，服务器端 Debug, 客户端 <code>Run</code> 的方式)，当我们使用了 <code>group.submit(new Callable&lt;Object&gt; ()&#123;&#125;</code> 在 <code>handler</code> 中加入线程池，就会进入到 <code>safeExecute(executor, task, promise, m);</code> 如果去掉这段代码，而使用普通方式来执行耗时的业务，那么就不会进入到 <code>safeExecute(executor, task, promise, m);</code>（说明：普通方式执行耗时代码，看我准备好的案例即可）</p>
<p>12.处理耗时业务的第二种方式 -<code>Context</code> 中添加线程池 1.1在添加 <code>pipeline</code> 中的 <code>handler</code> 时候，添加一个线程池</p>
<p>//属性</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventExecutorGroup group = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<span class="hljs-number">16</span>);
ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();
                b.group(bossGroup, workerGroup)
                 .channel(NioServerSocketChannel.class)
                 .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)
                 .handler(newLoggingHandler(LogLevel.INFO))
                 .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
                     <span class="hljs-meta">@Override</span>
                     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                         ChannelPipeline p = ch.pipeline();
                         <span class="hljs-keyword">if</span>(sslCtx != <span class="hljs-keyword">null</span>) &#123;
                             p.addLast(sslCtx.newHandler(ch.alloc()));
                         &#125;
                         <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>
                         <span class="hljs-comment">//p.addLast(new EchoServerHandler());</span>
                         p.addLast(group, <span class="hljs-keyword">new</span> EchoServerHandler());
                    &#125;
                &#125;);</code></pre></div>

<p>说明：</p>
<p>1)<code>handler</code> 中的代码就使用普通的方式来处理耗时业务。</p>
<p>2)当我们在调用 <code>addLast</code> 方法添加线程池后，<code>handler</code> 将优先使用这个线程池，如果不添加，将使用 <code>IO</code> 线程</p>
<p>3)当走到 <code>AbstractChannelHandlerContext</code> 的 <code>invokeChannelRead</code> 方法的时候，<code>executor.inEventLoop()</code> 是不会通过的，因为当前线程是 <code>IO</code> 线程 <code>Context</code>（也就是 <code>Handler</code>）的 <code>executor</code> 是业务线程，所以会异步执行，debug 下源码</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;
    <span class="hljs-keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);
    EventExecutor executor = next.executor();
    <span class="hljs-keyword">if</span>(executor.inEventLoop()) &#123;
        next.invokeChannelRead(m);
    &#125; <span class="hljs-keyword">else</span> &#123;
        executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-comment">//执行run</span>
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                next.invokeChannelRead(m);
            &#125;
        &#125;);
    &#125;
&#125;</code></pre></div>

<p>4)验证时，我们如果去掉 <code>p.addLast(group,newEchoServerHandler());</code> 改成 <code>p.addLastnewEchoServerHandler());</code> 你会发现代码不会进行异步执行。</p>
<p>5)后面的整个流程就变成和第一个方式一样了</p>
<p>13.两种方式的比较</p>
<p>1)第一种方式在 <code>handler</code> 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 <code>mpscTask</code> 中。如果 <code>IO</code> 时间很短，<code>task</code> 很多，可能一个循环下来，都没时间执行整个 <code>task</code>，导致响应时间达不到指标。</p>
<p>2)第二种方式是 <code>Netty</code> 标准方式(即加入到队列)，但是，这么做会将整个 <code>handler</code> 都交给业务线程池。不论耗时不耗时，都加入到队列里，不够灵活。</p>
<p>3)各有优劣，从灵活性考虑，第一种较好。</p>
<h2 id="11-用-Netty-自己实现-Dubbo-RPC"><a href="#11-用-Netty-自己实现-Dubbo-RPC" class="headerlink" title="11 用 Netty 自己实现 Dubbo RPC"></a>11 用 Netty 自己实现 Dubbo RPC</h2><h3 id="11-1-RPC-基本介绍"><a href="#11-1-RPC-基本介绍" class="headerlink" title="11.1 RPC 基本介绍"></a>11.1 RPC 基本介绍</h3><ol>
<li><code>RPC（Remote Procedure Call）</code>—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li>
<li>两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图)</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_01.png" alt="img"></p>
<ol>
<li>常见的 <code>RPC</code> 框架有：比较知名的如阿里的 <code>Dubbo</code>、<code>Google</code> 的 <code>gRPC</code>、<code>Go</code> 语言的 <code>rpcx</code>、<code>Apache</code> 的 <code>thrift</code>，<code>Spring</code> 旗下的 <code>SpringCloud</code>。</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_02.png" alt="img"></p>
<h3 id="11-2-RPC-调用流程图"><a href="#11-2-RPC-调用流程图" class="headerlink" title="11.2 RPC 调用流程图"></a>11.2 RPC 调用流程图<img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_03.png" alt="img"></h3><h3 id="11-3-PRC-调用流程说明"><a href="#11-3-PRC-调用流程说明" class="headerlink" title="11.3 PRC 调用流程说明"></a>11.3 PRC 调用流程说明</h3><ol>
<li>服务消费方（<code>client</code>）以本地调用方式调用服务</li>
<li><code>client stub</code> 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体</li>
<li><code>client stub</code> 将消息进行编码并发送到服务端</li>
<li><code>server stub</code> 收到消息后进行解码</li>
<li><code>server stub</code> 根据解码结果调用本地的服务</li>
<li>本地服务执行并将结果返回给 <code>server stub</code></li>
<li><code>server stub</code> 将返回导入结果进行编码并发送至消费方</li>
<li><code>client stub</code> 接收到消息并进行解码</li>
<li>服务消费方（<code>client</code>）得到结果</li>
</ol>
<p>小结：<code>RPC</code> 的目标就是将 <code>2 - 8</code> 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用</p>
<h3 id="11-4-自己实现-Dubbo-RPC（基于-Netty）"><a href="#11-4-自己实现-Dubbo-RPC（基于-Netty）" class="headerlink" title="11.4 自己实现 Dubbo RPC（基于 Netty）"></a>11.4 自己实现 Dubbo RPC（基于 Netty）</h3><h4 id="11-4-1-需求说明"><a href="#11-4-1-需求说明" class="headerlink" title="11.4.1 需求说明"></a>11.4.1 需求说明</h4><ol>
<li><code>Dubbo</code> 底层使用了 <code>Netty</code> 作为网络通讯框架，要求用 <code>Netty</code> 实现一个简单的 <code>RPC</code> 框架</li>
<li>模仿 <code>Dubbo</code>，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 <code>Netty 4.1.20</code></li>
</ol>
<h4 id="11-4-2-设计说明"><a href="#11-4-2-设计说明" class="headerlink" title="11.4.2 设计说明"></a>11.4.2 设计说明</h4><ol>
<li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。</li>
<li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。</li>
<li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 <code>Netty</code> 请求提供者返回数据</li>
<li>开发的分析图</li>
</ol>
<p><img src="/uploads/loading.jpg" srcset="/img/loading.gif" lazyload data-original="/2021/05/22/Netty%E5%AD%A6%E4%B9%A0/chapter11_04.png" alt="img"></p>
<h4 id="11-4-3-代码实现"><a href="#11-4-3-代码实现" class="headerlink" title="11.4.3 代码实现"></a>11.4.3 代码实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.publicinterface;

<span class="hljs-comment">//这个是接口，是服务提供方和 服务消费方都需要</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;

    <span class="hljs-function">String <span class="hljs-title">hello</span><span class="hljs-params">(String mes)</span></span>;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.provider;

<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>&#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-comment">//当有消费方调用该方法时， 就返回一个结果</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String mes)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot;收到客户端消息=&quot;</span> + mes);
        <span class="hljs-comment">//根据mes 返回不同的结果</span>
        <span class="hljs-keyword">if</span> (mes != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好客户端, 我已经收到你的消息 [&quot;</span> + mes + <span class="hljs-string">&quot;] 第&quot;</span> + (++count) + <span class="hljs-string">&quot; 次&quot;</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好客户端, 我已经收到你的消息 &quot;</span>;
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.provider;

<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyServer;

<span class="hljs-comment">//ServerBootstrap 会启动一个服务提供者，就是 NettyServer</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerBootstrap</span> </span>&#123;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">//代码代填..</span>
        NettyServer.startServer(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>);
    &#125;
&#125;


<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;


<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer</span><span class="hljs-params">(String hostName, <span class="hljs-keyword">int</span> port)</span> </span>&#123;
        startServer0(hostName, port);
    &#125;

    <span class="hljs-comment">//编写一个方法，完成对NettyServer的初始化和启动</span>

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer0</span><span class="hljs-params">(String hostname, <span class="hljs-keyword">int</span> port)</span> </span>&#123;

        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();

        <span class="hljs-keyword">try</span> &#123;

            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();

            serverBootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
                                      <span class="hljs-meta">@Override</span>
                                      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                                          ChannelPipeline pipeline = ch.pipeline();
                                          pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());
                                          pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());
                                          pipeline.addLast(<span class="hljs-keyword">new</span> NettyServerHandler()); <span class="hljs-comment">//业务处理器</span>

                                      &#125;
                                  &#125;

                    );

            ChannelFuture channelFuture = serverBootstrap.bind(hostname, port).sync();
            System.out.println(<span class="hljs-string">&quot;服务提供方开始提供服务~~&quot;</span>);
            channelFuture.channel().closeFuture().sync();

        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;

<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.customer.ClientBootstrap;
<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.provider.HelloServiceImpl;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;

<span class="hljs-comment">//服务器这边handler比较简单</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-comment">//获取客户端发送的消息，并调用服务</span>
        System.out.println(<span class="hljs-string">&quot;msg=&quot;</span> + msg);
        <span class="hljs-comment">//客户端在调用服务器的api 时，我们需要定义一个协议</span>
        <span class="hljs-comment">//比如我们要求 每次发消息是都必须以某个字符串开头 &quot;HelloService#hello#你好&quot;</span>
        <span class="hljs-keyword">if</span> (msg.toString().startsWith(ClientBootstrap.providerName)) &#123;

            String result = <span class="hljs-keyword">new</span> HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(<span class="hljs-string">&quot;#&quot;</span>) + <span class="hljs-number">1</span>));
            ctx.writeAndFlush(result);
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ctx.close();
    &#125;
&#125;


<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;

<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;

<span class="hljs-keyword">import</span> java.util.concurrent.Callable;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;

    <span class="hljs-keyword">private</span> ChannelHandlerContext context;<span class="hljs-comment">//上下文</span>
    <span class="hljs-keyword">private</span> String result; <span class="hljs-comment">//返回的结果</span>
    <span class="hljs-keyword">private</span> String para; <span class="hljs-comment">//客户端调用方法时，传入的参数</span>
    
    <span class="hljs-comment">//与服务器的连接创建后，就会被调用, 这个方法是第一个被调用(1)</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot; channelActive 被调用  &quot;</span>);
        context = ctx; <span class="hljs-comment">//因为我们在其它方法会使用到 ctx</span>
    &#125;

    <span class="hljs-comment">//收到服务器的数据后，调用方法 (4)</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot; channelRead 被调用  &quot;</span>);
        result = msg.toString();
        notify(); <span class="hljs-comment">//唤醒等待的线程</span>
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ctx.close();
    &#125;

    <span class="hljs-comment">//被代理对象调用, 发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果 (3)-》5</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        System.out.println(<span class="hljs-string">&quot; call1 被调用  &quot;</span>);
        context.writeAndFlush(para);
        <span class="hljs-comment">//进行wait</span>
        wait(); <span class="hljs-comment">//等待channelRead 方法获取到服务器的结果后，唤醒</span>
        System.out.println(<span class="hljs-string">&quot; call2 被调用  &quot;</span>);
        <span class="hljs-keyword">return</span> result; <span class="hljs-comment">//服务方返回的结果</span>

    &#125;

    <span class="hljs-comment">//(2)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPara</span><span class="hljs-params">(String para)</span> </span>&#123;
        System.out.println(<span class="hljs-string">&quot; setPara  &quot;</span>);
        <span class="hljs-keyword">this</span>.para = para;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.netty;


<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelOption;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;
<span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;

<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;
<span class="hljs-keyword">import</span> java.util.concurrent.Executor;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;

    <span class="hljs-comment">//创建线程池</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> NettyClientHandler client;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-comment">//编写方法使用代理模式，获取一个代理对象</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; serivceClass, <span class="hljs-keyword">final</span> String providerName)</span> </span>&#123;

        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
                <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;serivceClass&#125;, (proxy, method, args) -&gt; &#123;

                    System.out.println(<span class="hljs-string">&quot;(proxy, method, args) 进入....&quot;</span> + (++count) + <span class="hljs-string">&quot; 次&quot;</span>);
                    <span class="hljs-comment">//&#123;&#125;  部分的代码，客户端每调用一次 hello, 就会进入到该代码</span>
                    <span class="hljs-keyword">if</span> (client == <span class="hljs-keyword">null</span>) &#123;
                        initClient();
                    &#125;

                    <span class="hljs-comment">//设置要发给服务器端的信息</span>
                    <span class="hljs-comment">//providerName 协议头 args[0] 就是客户端调用api hello(???), 参数</span>
                    client.setPara(providerName + args[<span class="hljs-number">0</span>]);

                    <span class="hljs-comment">//</span>
                    <span class="hljs-keyword">return</span> executor.submit(client).get();

                &#125;);
    &#125;

    <span class="hljs-comment">//初始化客户端</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initClient</span><span class="hljs-params">()</span> </span>&#123;
        client = <span class="hljs-keyword">new</span> NettyClientHandler();
        <span class="hljs-comment">//创建EventLoopGroup</span>
        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();
        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();
        bootstrap.group(group)
                .channel(NioSocketChannel.class)
                .option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)
                .handler(
                        <span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
                            <span class="hljs-meta">@Override</span>
                            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                                ChannelPipeline pipeline = ch.pipeline();
                                pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());
                                pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());
                                pipeline.addLast(client);
                            &#125;
                        &#125;
                );

        <span class="hljs-keyword">try</span> &#123;
            bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">7000</span>).sync();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">package</span> com.atguigu.netty.dubborpc.customer;

<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.netty.NettyClient;
<span class="hljs-keyword">import</span> com.atguigu.netty.dubborpc.publicinterface.HelloService;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientBootstrap</span> </span>&#123;
    
    <span class="hljs-comment">//这里定义协议头</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String providerName = <span class="hljs-string">&quot;HelloService#hello#&quot;</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;

        <span class="hljs-comment">//创建一个消费者</span>
        NettyClient customer = <span class="hljs-keyword">new</span> NettyClient();

        <span class="hljs-comment">//创建代理对象</span>
        HelloService service = (HelloService) customer.getBean(HelloService.class, providerName);

        <span class="hljs-keyword">for</span> (; ; ) &#123;
            Thread.sleep(<span class="hljs-number">2</span> * <span class="hljs-number">1000</span>);
            <span class="hljs-comment">//通过代理对象调用服务提供者的方法(服务)</span>
            String res = service.hello(<span class="hljs-string">&quot;你好 dubbo~&quot;</span>);
            System.out.println(<span class="hljs-string">&quot;调用的结果 res= &quot;</span> + res);
        &#125;
    &#125;
&#125;</code></pre></div>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/Network/">Network</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/network/">network</a>
                    
                      <a class="hover-with-bg" href="/tags/framework/">framework</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/05/22/Clion%E6%90%AD%E5%BB%BAGtest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Clion搭建Gtest单元测试框架</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/05/20/Win10%E6%90%AD%E5%BB%BAPyTorch%E7%8E%AF%E5%A2%83/">
                        <span class="hidden-mobile">Win10 搭建 PyTorch 环境</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=a;var i=n.imageLazyLoadSetting.isSPA,o=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function a(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var a=0;a<r.length;a++)t=r[a],0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight*o||document.documentElement.clientHeight*o)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}();var t,e}a(),n.addEventListener("scroll",function(){var t,e;t=a,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>
